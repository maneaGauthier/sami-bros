<html>
<head>
<title>libp3event.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3event.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">10 libp3event 4 _0BP 12 panda3d.core </span>
<span class="s0">269</span>
<span class="s0">252 14 EventParameter 0 260 521 30 EventParameter::EventParameter 0 9 1 2 3 4 5 6 7 8 9 1162</span>
<span class="s0">/**</span>
 <span class="s0">* Defines an EventParameter that stores a pointer to any kind of</span>
 <span class="s0">* TypedWritableReferenceCount object.  This is the most general constructor.</span>
 <span class="s0">*</span>
 <span class="s0">* This accepts a const pointer, even though it stores (and eventually</span>
 <span class="s0">* returns) a non-const pointer.  This is just the simplest way to allow both</span>
 <span class="s0">* const and non-const pointers to be stored, but it does lose the constness.</span>
 <span class="s0">* Be careful.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Defines an EventParameter that stores a pointer to a TypedReferenceCount</span>
 <span class="s0">* object.  Note that a TypedReferenceCount is not the same kind of pointer as</span>
 <span class="s0">* a TypedWritableReferenceCount, hence we require both constructors.</span>
 <span class="s0">*</span>
 <span class="s0">* This accepts a const pointer, even though it stores (and eventually</span>
 <span class="s0">* returns) a non-const pointer.  This is just the simplest way to allow both</span>
 <span class="s0">* const and non-const pointers to be stored, but it does lose the constness.</span>
 <span class="s0">* Be careful.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Defines an EventParameter that stores an integer value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Defines an EventParameter that stores a floating-point value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Defines an EventParameter that stores a string value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Defines an EventParameter that stores a wstring value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">561</span>
<span class="s0">inline EventParameter::EventParameter(void) = default;</span>
<span class="s0">inline EventParameter::EventParameter(std::nullptr_t );</span>
<span class="s0">inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr);</span>
<span class="s0">inline EventParameter::EventParameter(TypedReferenceCount const *ptr);</span>
<span class="s0">inline EventParameter::EventParameter(int value);</span>
<span class="s0">inline EventParameter::EventParameter(double value);</span>
<span class="s0">inline EventParameter::EventParameter(std::string const &amp;value);</span>
<span class="s0">inline EventParameter::EventParameter(std::wstring const &amp;value);</span>
<span class="s0">inline EventParameter::EventParameter(EventParameter const &amp;copy);</span>

<span class="s0">253 10 operator = 0 4 521 26 EventParameter::operator = 0 1 10 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void EventParameter::operator =(EventParameter const &amp;copy);</span>

<span class="s0">254 15 ~EventParameter 0 516 521 31 EventParameter::~EventParameter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline EventParameter::~EventParameter(void);</span>

<span class="s0">255 8 is_empty 0 4 521 24 EventParameter::is_empty 0 1 11 377</span>
<span class="s0">// These functions are conveniences to easily determine if the</span>
<span class="s0">// EventParameter is one of the predefined parameter types, and retrieve the</span>
<span class="s0">// corresponding value.  Of course, it is possible that the EventParameter</span>
<span class="s0">// is some user-defined type, and is none of these.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the EventParameter is the empty parameter, storing nothing,</span>
 <span class="s0">* or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool EventParameter::is_empty(void) const;</span>

<span class="s0">256 6 is_int 0 4 521 22 EventParameter::is_int 0 1 12 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the EventParameter stores an integer value, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool EventParameter::is_int(void) const;</span>

<span class="s0">257 13 get_int_value 0 4 521 29 EventParameter::get_int_value 0 1 13 133</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_int() has already returned true.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int EventParameter::get_int_value(void) const;</span>

<span class="s0">258 9 is_double 0 4 521 25 EventParameter::is_double 0 1 14 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the EventParameter stores a double floating-point value,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool EventParameter::is_double(void) const;</span>

<span class="s0">259 16 get_double_value 0 4 521 32 EventParameter::get_double_value 0 1 15 136</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_double() has already returned true.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline double EventParameter::get_double_value(void) const;</span>

<span class="s0">260 9 is_string 0 4 521 25 EventParameter::is_string 0 1 16 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the EventParameter stores a string value, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool EventParameter::is_string(void) const;</span>

<span class="s0">261 16 get_string_value 0 4 521 32 EventParameter::get_string_value 0 1 17 136</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_string() has already returned true.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::string EventParameter::get_string_value(void) const;</span>

<span class="s0">262 10 is_wstring 0 4 521 26 EventParameter::is_wstring 0 1 18 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the EventParameter stores a wstring value, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool EventParameter::is_wstring(void) const;</span>

<span class="s0">263 17 get_wstring_value 0 4 521 33 EventParameter::get_wstring_value 0 1 19 137</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_wstring() has already returned true.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::wstring EventParameter::get_wstring_value(void) const;</span>

<span class="s0">264 18 is_typed_ref_count 0 4 521 34 EventParameter::is_typed_ref_count 0 1 20 255</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the EventParameter stores a TypedReferenceCount pointer,</span>
 <span class="s0">* false otherwise.  Note that a TypedReferenceCount is not exactly the same</span>
 <span class="s0">* kind of pointer as a TypedWritableReferenceCount, hence the need for this</span>
 <span class="s0">* separate call.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool EventParameter::is_typed_ref_count(void) const;</span>

<span class="s0">265 25 get_typed_ref_count_value 0 4 521 41 EventParameter::get_typed_ref_count_value 0 1 21 145</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_typed_ref_count() has already returned true.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const;</span>

<span class="s0">266 7 get_ptr 0 4 521 23 EventParameter::get_ptr 0 1 22 281</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves a pointer to the actual value stored in the parameter.  The</span>
 <span class="s0">* TypeHandle of this pointer may be examined to determine the actual type of</span>
 <span class="s0">* parameter it contains.  This is the only way to retrieve the value when it</span>
 <span class="s0">* is not one of the above predefined types.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const;</span>

<span class="s0">267 6 output 0 4 521 22 EventParameter::output 0 1 23 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void EventParameter::output(std::ostream &amp;out) const;</span>

<span class="s0">268 11 AsyncFuture 0 260 522 24 AsyncFuture::AsyncFuture 0 2 24 25 55</span>
<span class="s0">/**</span>
 <span class="s0">* Initializes the future in the pending state.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline AsyncFuture::AsyncFuture(void);</span>
<span class="s0">inline AsyncFuture::AsyncFuture(AsyncFuture const &amp;) = default;</span>

<span class="s0">269 9 __await__ 0 4 522 22 AsyncFuture::__await__ 0 1 26 0</span>
<span class="s0">56</span>
<span class="s0">static PyObject *AsyncFuture::__await__(PyObject *self);</span>

<span class="s0">270 8 __iter__ 0 4 522 21 AsyncFuture::__iter__ 0 1 27 0</span>
<span class="s0">55</span>
<span class="s0">static PyObject *AsyncFuture::__iter__(PyObject *self);</span>

<span class="s0">271 4 done 0 4 522 17 AsyncFuture::done 0 1 28 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the future is done or has been cancelled.  It is always</span>
 <span class="s0">* safe to call this.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool AsyncFuture::done(void) const;</span>

<span class="s0">272 9 cancelled 0 4 522 22 AsyncFuture::cancelled 0 1 29 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the future was cancelled.  It is always safe to call this.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool AsyncFuture::cancelled(void) const;</span>

<span class="s0">273 6 result 0 4 522 19 AsyncFuture::result 0 1 30 0</span>
<span class="s0">78</span>
<span class="s0">PyObject *AsyncFuture::result(PyObject *timeout = (&amp; ::_Py_NoneStruct)) const;</span>

<span class="s0">274 6 cancel 0 6 522 19 AsyncFuture::cancel 0 1 31 235</span>
<span class="s0">/**</span>
 <span class="s0">* Cancels the future.  Returns true if it was cancelled, or false if the</span>
 <span class="s0">* future was already done.  Either way, done() will return true after this</span>
 <span class="s0">* call returns.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of a task, this is equivalent to remove().</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">virtual bool AsyncFuture::cancel(void);</span>

<span class="s0">275 14 set_done_event 0 4 522 27 AsyncFuture::set_done_event 0 1 32 212</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the event name that will be triggered when the future finishes.  Will</span>
 <span class="s0">* not be triggered if the future is cancelled, but it will be triggered for</span>
 <span class="s0">* a coroutine task that exits with an exception.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void AsyncFuture::set_done_event(std::string const &amp;done_event);</span>

<span class="s0">276 14 get_done_event 0 4 522 27 AsyncFuture::get_done_event 0 1 33 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the event name that will be triggered when the future finishes.</span>
 <span class="s0">* See set_done_event().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::string const &amp;AsyncFuture::get_done_event(void) const;</span>

<span class="s0">277 17 add_done_callback 0 4 522 30 AsyncFuture::add_done_callback 0 1 34 0</span>
<span class="s0">71</span>
<span class="s0">PyObject *AsyncFuture::add_done_callback(PyObject *self, PyObject *fn);</span>

<span class="s0">278 6 gather 0 4 522 19 AsyncFuture::gather 0 1 35 232</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new future that returns `done()` when all of the contained</span>
 <span class="s0">* futures are done.</span>
 <span class="s0">*</span>
 <span class="s0">* Calling `cancel()` on the returned future will result in all contained</span>
 <span class="s0">* futures that have not yet finished to be cancelled.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static PyObject *AsyncFuture::gather(PyObject *args);</span>

<span class="s0">279 6 output 0 6 522 19 AsyncFuture::output 0 1 36 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual void AsyncFuture::output(std::ostream &amp;out) const;</span>

<span class="s0">280 4 wait 0 4 522 17 AsyncFuture::wait 0 2 37 38 119</span>
<span class="s0">/**</span>
 <span class="s0">* Waits until the future is done.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Waits until the future is done, or until the timeout is reached.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void AsyncFuture::wait(void);</span>
<span class="s0">void AsyncFuture::wait(double timeout);</span>

<span class="s0">281 10 set_result 0 4 522 23 AsyncFuture::set_result 0 1 39 439</span>
<span class="s0">/**</span>
 <span class="s0">* Sets this future's result.  Can only be called if done() returns false.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets this future's result.  Can only be done while the future is not done.</span>
 <span class="s0">* Calling this marks the future as done and schedules the done callbacks.</span>
 <span class="s0">*</span>
 <span class="s0">* This variant takes two pointers; the second one is only set if this object</span>
 <span class="s0">* inherits from ReferenceCount, so that a reference can be held.</span>
 <span class="s0">*</span>
 <span class="s0">* Assumes the manager's lock is *not* held.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void AsyncFuture::set_result(PyObject *);</span>

<span class="s0">282 14 get_class_type 0 4 522 27 AsyncFuture::get_class_type 0 1 40 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle AsyncFuture::get_class_type(void);</span>

<span class="s0">283 21 upcast_to_AsyncFuture 0 12 527 32 AsyncTask::upcast_to_AsyncFuture 0 1 72 36</span>
<span class="s0">upcast from AsyncTask to AsyncFuture</span>
<span class="s0">52</span>
<span class="s0">AsyncFuture *AsyncTask::upcast_to_AsyncFuture(void);</span>

<span class="s0">284 21 downcast_to_AsyncTask 0 12 522 34 AsyncFuture::downcast_to_AsyncTask 0 0 38</span>
<span class="s0">downcast from AsyncFuture to AsyncTask</span>
<span class="s0">52</span>
<span class="s0">AsyncTask *AsyncFuture::downcast_to_AsyncTask(void);</span>

<span class="s0">285 17 upcast_to_Namable 0 12 527 28 AsyncTask::upcast_to_Namable 0 1 73 32</span>
<span class="s0">upcast from AsyncTask to Namable</span>
<span class="s0">44</span>
<span class="s0">Namable *AsyncTask::upcast_to_Namable(void);</span>

<span class="s0">286 21 downcast_to_AsyncTask 0 12 528 30 Namable::downcast_to_AsyncTask 0 0 34</span>
<span class="s0">downcast from Namable to AsyncTask</span>
<span class="s0">48</span>
<span class="s0">AsyncTask *Namable::downcast_to_AsyncTask(void);</span>

<span class="s0">287 10 ~AsyncTask 0 518 527 21 AsyncTask::~AsyncTask 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">virtual AsyncTask::~AsyncTask(void);</span>

<span class="s0">288 9 get_state 0 4 527 20 AsyncTask::get_state 0 1 42 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current state of the task.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline AsyncTask::State AsyncTask::get_state(void) const;</span>

<span class="s0">289 8 is_alive 0 4 527 19 AsyncTask::is_alive 0 1 43 332</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the task is currently active or sleeping on some task</span>
 <span class="s0">* chain, meaning that it will be executed in its turn, or false if it is not</span>
 <span class="s0">* active.  If the task has recently been removed while it is in the middle of</span>
 <span class="s0">* execution, this will return false, because the task will not run again once</span>
 <span class="s0">* it finishes.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool AsyncTask::is_alive(void) const;</span>

<span class="s0">290 11 get_manager 0 4 527 22 AsyncTask::get_manager 0 1 44 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the AsyncTaskManager that this task is active on.  This will be</span>
 <span class="s0">* NULL if the state is S_inactive.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline AsyncTaskManager *AsyncTask::get_manager(void) const;</span>

<span class="s0">291 6 remove 0 4 527 17 AsyncTask::remove 0 1 45 185</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the task from its active manager, if any, and makes the state</span>
 <span class="s0">* S_inactive (or possible S_servicing_removed).  This is a no-op if the state</span>
 <span class="s0">* is already S_inactive.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">bool AsyncTask::remove(void);</span>

<span class="s0">292 9 set_delay 0 4 527 20 AsyncTask::set_delay 0 1 46 686</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the amount of time, in seconds, by which this task will be</span>
 <span class="s0">* delayed after it has been added to the AsyncTaskManager.  At least the</span>
 <span class="s0">* specified amount of time (and possibly more) will elapse before the task</span>
 <span class="s0">* begins.</span>
 <span class="s0">*</span>
 <span class="s0">* You may specify a delay of 0.0 to guarantee that the task will run in the</span>
 <span class="s0">* next epoch following the one in which it is added.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this value after the task has already been added will not affect</span>
 <span class="s0">* the task's wake time; it will only affect the task if it is re-added to the</span>
 <span class="s0">* queue in the future, for instance if the task returns DS_again.  However,</span>
 <span class="s0">* see recalc_wake_time() if you wish to apply the delay effect immediately.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void AsyncTask::set_delay(double delay);</span>

<span class="s0">293 11 clear_delay 0 4 527 22 AsyncTask::clear_delay 0 1 47 216</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any delay specified for the task.  The next time the task is added</span>
 <span class="s0">* to the queue, it will run immediately.  This does not affect the task's</span>
 <span class="s0">* wake time if it has already been added to the queue.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void AsyncTask::clear_delay(void);</span>

<span class="s0">294 9 has_delay 0 4 527 20 AsyncTask::has_delay 0 1 48 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a delay has been set for this task via set_delay(), or</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool AsyncTask::has_delay(void) const;</span>

<span class="s0">295 9 get_delay 0 4 527 20 AsyncTask::get_delay 0 1 49 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the delay value that has been set via set_delay, if any.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline double AsyncTask::get_delay(void) const;</span>

<span class="s0">296 13 get_wake_time 0 4 527 24 AsyncTask::get_wake_time 0 1 50 354</span>
<span class="s0">/**</span>
 <span class="s0">* If this task has been added to an AsyncTaskManager with a delay in effect,</span>
 <span class="s0">* this returns the time at which the task is expected to awaken.  It has no</span>
 <span class="s0">* meaning if the task has not yet been added to a queue, or if there was no</span>
 <span class="s0">* delay in effect at the time the task was added.</span>
 <span class="s0">*</span>
 <span class="s0">* If the task's status is not S_sleeping, this returns 0.0.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">double AsyncTask::get_wake_time(void) const;</span>

<span class="s0">297 16 recalc_wake_time 0 4 527 27 AsyncTask::recalc_wake_time 0 1 51 437</span>
<span class="s0">/**</span>
 <span class="s0">* If the task is currently sleeping on a task chain, this resets its wake</span>
 <span class="s0">* time to the current time + get_delay().  It is as if the task had suddenly</span>
 <span class="s0">* returned DS_again.  The task will sleep for its current delay seconds</span>
 <span class="s0">* before running again.  This method may therefore be used to make the task</span>
 <span class="s0">* wake up sooner or later than it would have otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* If the task is not already sleeping, this method has no effect.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void AsyncTask::recalc_wake_time(void);</span>

<span class="s0">298 14 get_start_time 0 4 527 25 AsyncTask::get_start_time 0 1 52 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time at which the task was started, according to the task</span>
 <span class="s0">* manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline double AsyncTask::get_start_time(void) const;</span>

<span class="s0">299 16 get_elapsed_time 0 4 527 27 AsyncTask::get_elapsed_time 0 1 53 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of time that has elapsed since the task was started,</span>
 <span class="s0">* according to the task manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">double AsyncTask::get_elapsed_time(void) const;</span>

<span class="s0">300 15 get_start_frame 0 4 527 26 AsyncTask::get_start_frame 0 1 54 184</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the frame number at which the task was started, according to the</span>
 <span class="s0">* task manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int AsyncTask::get_start_frame(void) const;</span>

<span class="s0">301 18 get_elapsed_frames 0 4 527 29 AsyncTask::get_elapsed_frames 0 1 55 203</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of frames that have elapsed since the task was started,</span>
 <span class="s0">* according to the task manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">int AsyncTask::get_elapsed_frames(void) const;</span>

<span class="s0">302 8 set_name 0 4 527 19 AsyncTask::set_name 0 1 56 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void AsyncTask::set_name(std::string const &amp;name);</span>

<span class="s0">303 10 clear_name 0 4 527 21 AsyncTask::clear_name 0 1 57 43</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the task's name to empty.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline void AsyncTask::clear_name(void);</span>

<span class="s0">304 15 get_name_prefix 0 4 527 26 AsyncTask::get_name_prefix 0 1 58 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the initial part of the name, up to but not including any trailing</span>
 <span class="s0">* digits following a hyphen or underscore.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">std::string AsyncTask::get_name_prefix(void) const;</span>

<span class="s0">305 11 get_task_id 0 4 527 22 AsyncTask::get_task_id 0 1 59 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number guaranteed to be unique for each different AsyncTask</span>
 <span class="s0">* object in the universe.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline AtomicAdjust::Integer AsyncTask::get_task_id(void) const;</span>

<span class="s0">306 14 set_task_chain 0 4 527 25 AsyncTask::set_task_chain 0 1 60 135</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the AsyncTaskChain on which this task will be running.  Each task</span>
 <span class="s0">* chain runs tasks independently of the others.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void AsyncTask::set_task_chain(std::string const &amp;chain_name);</span>

<span class="s0">307 14 get_task_chain 0 4 527 25 AsyncTask::get_task_chain 0 1 61 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the AsyncTaskChain on which this task will be running.  Each task</span>
 <span class="s0">* chain runs tasks independently of the others.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::string const &amp;AsyncTask::get_task_chain(void) const;</span>

<span class="s0">308 8 set_sort 0 4 527 19 AsyncTask::set_sort 0 1 62 483</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a sort value for this task.  Within a given AsyncTaskManager, all</span>
 <span class="s0">* of the tasks with a given sort value are guaranteed to be completed before</span>
 <span class="s0">* any tasks with a higher sort value are begun.</span>
 <span class="s0">*</span>
 <span class="s0">* To put it another way, two tasks might execute in parallel with each other</span>
 <span class="s0">* only if they both have the same sort value.  Tasks with a lower sort value</span>
 <span class="s0">* are executed first.</span>
 <span class="s0">*</span>
 <span class="s0">* This is different from the priority, which makes no such exclusion</span>
 <span class="s0">* guarantees.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">void AsyncTask::set_sort(int sort);</span>

<span class="s0">309 8 get_sort 0 4 527 19 AsyncTask::get_sort 0 1 63 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the task's current sort value.  See set_sort().</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int AsyncTask::get_sort(void) const;</span>

<span class="s0">310 12 set_priority 0 4 527 23 AsyncTask::set_priority 0 1 64 874</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a priority value for this task.  In general, tasks with a higher</span>
 <span class="s0">* priority value are executed before tasks with a lower priority value (but</span>
 <span class="s0">* only for tasks with the same sort value).</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the sort value, tasks with different priorities may execute at the</span>
 <span class="s0">* same time, if the AsyncTaskManager has more than one thread servicing</span>
 <span class="s0">* tasks.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see AsyncTaskChain::set_timeslice_priority(), which changes the</span>
 <span class="s0">* meaning of this value.  In the default mode, when the timeslice_priority</span>
 <span class="s0">* flag is false, all tasks always run once per epoch, regardless of their</span>
 <span class="s0">* priority values (that is, the priority controls the order of the task</span>
 <span class="s0">* execution only, not the number of times it runs).  On the other hand, if</span>
 <span class="s0">* you set the timeslice_priority flag to true, then changing a task's</span>
 <span class="s0">* priority has an effect on the number of times it runs.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void AsyncTask::set_priority(int priority);</span>

<span class="s0">311 12 get_priority 0 4 527 23 AsyncTask::get_priority 0 1 65 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the task's current priority value.  See set_priority().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int AsyncTask::get_priority(void) const;</span>

<span class="s0">312 14 set_done_event 0 4 527 25 AsyncTask::set_done_event 0 1 66 257</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the event name that will be triggered when the task finishes.  This</span>
 <span class="s0">* should only be called before the task has been started, or after it has</span>
 <span class="s0">* finished and before it is about to be restarted (i.e.  when get_state()</span>
 <span class="s0">* returns S_inactive).</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void AsyncTask::set_done_event(std::string const &amp;done_event);</span>

<span class="s0">313 6 get_dt 0 4 527 17 AsyncTask::get_dt 0 1 67 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of time elapsed during the task's previous run cycle, in</span>
 <span class="s0">* seconds.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double AsyncTask::get_dt(void) const;</span>

<span class="s0">314 10 get_max_dt 0 4 527 21 AsyncTask::get_max_dt 0 1 68 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum amount of time elapsed during any one of the task's</span>
 <span class="s0">* previous run cycles, in seconds.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline double AsyncTask::get_max_dt(void) const;</span>

<span class="s0">315 14 get_average_dt 0 4 527 25 AsyncTask::get_average_dt 0 1 69 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the average amount of time elapsed during each of the task's</span>
 <span class="s0">* previous run cycles, in seconds.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline double AsyncTask::get_average_dt(void) const;</span>

<span class="s0">316 6 output 0 6 527 17 AsyncTask::output 0 1 70 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual void AsyncTask::output(std::ostream &amp;out) const;</span>

<span class="s0">317 29 upcast_to_TypedReferenceCount 0 12 533 47 AsyncTaskManager::upcast_to_TypedReferenceCount 0 1 103 51</span>
<span class="s0">upcast from AsyncTaskManager to TypedReferenceCount</span>
<span class="s0">75</span>
<span class="s0">TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void);</span>

<span class="s0">318 28 downcast_to_AsyncTaskManager 0 12 523 49 TypedReferenceCount::downcast_to_AsyncTaskManager 0 0 53</span>
<span class="s0">downcast from TypedReferenceCount to AsyncTaskManager</span>
<span class="s0">74</span>
<span class="s0">AsyncTaskManager *TypedReferenceCount::downcast_to_AsyncTaskManager(void);</span>

<span class="s0">319 17 upcast_to_Namable 0 12 533 35 AsyncTaskManager::upcast_to_Namable 0 1 104 39</span>
<span class="s0">upcast from AsyncTaskManager to Namable</span>
<span class="s0">51</span>
<span class="s0">Namable *AsyncTaskManager::upcast_to_Namable(void);</span>

<span class="s0">320 28 downcast_to_AsyncTaskManager 0 12 528 37 Namable::downcast_to_AsyncTaskManager 0 0 41</span>
<span class="s0">downcast from Namable to AsyncTaskManager</span>
<span class="s0">62</span>
<span class="s0">AsyncTaskManager *Namable::downcast_to_AsyncTaskManager(void);</span>

<span class="s0">321 16 AsyncTaskManager 0 260 533 34 AsyncTaskManager::AsyncTaskManager 0 1 74 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">explicit AsyncTaskManager::AsyncTaskManager(std::string const &amp;name);</span>

<span class="s0">322 17 ~AsyncTaskManager 0 518 533 35 AsyncTaskManager::~AsyncTaskManager 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">virtual AsyncTaskManager::~AsyncTaskManager(void);</span>

<span class="s0">323 7 cleanup 0 4 533 25 AsyncTaskManager::cleanup 0 1 75 118</span>
<span class="s0">/**</span>
 <span class="s0">* Stops all threads and messily empties the task list.  This is intended to</span>
 <span class="s0">* be called on destruction only.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void AsyncTaskManager::cleanup(void);</span>

<span class="s0">324 9 set_clock 0 4 533 27 AsyncTaskManager::set_clock 0 1 76 286</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the clock pointer used within the AsyncTaskManager.  This is used</span>
 <span class="s0">* to control when tasks with a set_delay() specified will be scheduled.  It</span>
 <span class="s0">* can also be ticked automatically each epoch, if set_tick_clock() is true.</span>
 <span class="s0">*</span>
 <span class="s0">* The default is the global clock pointer.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void AsyncTaskManager::set_clock(ClockObject *clock);</span>

<span class="s0">325 9 get_clock 0 4 533 27 AsyncTaskManager::get_clock 0 1 77 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the clock pointer used within the AsyncTaskManager.  See</span>
 <span class="s0">* set_clock().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline ClockObject *AsyncTaskManager::get_clock(void);</span>

<span class="s0">326 19 get_num_task_chains 0 4 533 37 AsyncTaskManager::get_num_task_chains 0 1 78 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of different task chains.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int AsyncTaskManager::get_num_task_chains(void) const;</span>

<span class="s0">327 14 get_task_chain 0 4 533 32 AsyncTaskManager::get_task_chain 0 1 79 38</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth task chain.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const;</span>

<span class="s0">328 15 make_task_chain 0 4 533 33 AsyncTaskManager::make_task_chain 0 1 80 178</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new AsyncTaskChain of the indicated name and stores it within the</span>
 <span class="s0">* AsyncTaskManager.  If a task chain with this name already exists, returns</span>
 <span class="s0">* it instead.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">AsyncTaskChain *AsyncTaskManager::make_task_chain(std::string const &amp;name);</span>

<span class="s0">329 15 find_task_chain 0 4 533 33 AsyncTaskManager::find_task_chain 0 1 81 113</span>
<span class="s0">/**</span>
 <span class="s0">* Searches a new AsyncTaskChain of the indicated name and returns it if it</span>
 <span class="s0">* exists, or NULL otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">AsyncTaskChain *AsyncTaskManager::find_task_chain(std::string const &amp;name);</span>

<span class="s0">330 17 remove_task_chain 0 4 533 35 AsyncTaskManager::remove_task_chain 0 1 82 211</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the AsyncTaskChain of the indicated name.  If the chain still has</span>
 <span class="s0">* tasks, this will block until all tasks are finished.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, or false if the chain did not exist.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">bool AsyncTaskManager::remove_task_chain(std::string const &amp;name);</span>

<span class="s0">331 3 add 0 4 533 21 AsyncTaskManager::add 0 1 83 138</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated task to the active queue.  It is an error if the task is</span>
 <span class="s0">* already added to this or any other active queue.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void AsyncTaskManager::add(AsyncTask *task);</span>

<span class="s0">332 8 has_task 0 4 533 26 AsyncTaskManager::has_task 0 1 84 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated task has been added to this AsyncTaskManager,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool AsyncTaskManager::has_task(AsyncTask *task) const;</span>

<span class="s0">333 9 find_task 0 4 533 27 AsyncTaskManager::find_task 0 1 85 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first task found with the indicated name, or NULL if there is</span>
 <span class="s0">* no task with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* If there are multiple tasks with the same name, returns one of them</span>
 <span class="s0">* arbitrarily.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">AsyncTask *AsyncTaskManager::find_task(std::string const &amp;name) const;</span>

<span class="s0">334 10 find_tasks 0 4 533 28 AsyncTaskManager::find_tasks 0 1 86 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the list of tasks found with the indicated name.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">AsyncTaskCollection AsyncTaskManager::find_tasks(std::string const &amp;name) const;</span>

<span class="s0">335 19 find_tasks_matching 0 4 533 37 AsyncTaskManager::find_tasks_matching 0 1 87 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the list of tasks found whose name matches the indicated glob</span>
 <span class="s0">* pattern, e.g.  &quot;my_task_*&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &amp;pattern) const;</span>

<span class="s0">336 6 remove 0 4 533 24 AsyncTaskManager::remove 0 2 88 89 249</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated task from the active queue.  Returns true if the task</span>
 <span class="s0">* is successfully removed, or false if it wasn't there.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes all of the tasks in the AsyncTaskCollection.  Returns the number of</span>
 <span class="s0">* tasks removed.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">bool AsyncTaskManager::remove(AsyncTask *task);</span>
<span class="s0">std::size_t AsyncTaskManager::remove(AsyncTaskCollection const &amp;tasks);</span>

<span class="s0">337 14 wait_for_tasks 0 4 533 32 AsyncTaskManager::wait_for_tasks 0 1 90 47</span>
<span class="s0">/**</span>
 <span class="s0">* Blocks until the task list is empty.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void AsyncTaskManager::wait_for_tasks(void);</span>

<span class="s0">338 12 stop_threads 0 4 533 30 AsyncTaskManager::stop_threads 0 1 91 215</span>
<span class="s0">/**</span>
 <span class="s0">* Stops any threads that are currently running.  If any tasks are still</span>
 <span class="s0">* pending and have not yet been picked up by a thread, they will not be</span>
 <span class="s0">* serviced unless poll() or start_threads() is later called.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void AsyncTaskManager::stop_threads(void);</span>

<span class="s0">339 13 start_threads 0 4 533 31 AsyncTaskManager::start_threads 0 1 92 171</span>
<span class="s0">/**</span>
 <span class="s0">* Starts any requested threads to service the tasks on the queue.  This is</span>
 <span class="s0">* normally not necessary, since adding a task will start the threads</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void AsyncTaskManager::start_threads(void);</span>

<span class="s0">340 13 get_num_tasks 0 4 533 31 AsyncTaskManager::get_num_tasks 0 1 93 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of tasks that are currently active or sleeping within</span>
 <span class="s0">* the task manager.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::size_t AsyncTaskManager::get_num_tasks(void) const;</span>

<span class="s0">341 9 get_tasks 0 4 533 27 AsyncTaskManager::get_tasks 0 1 94 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of tasks that are active or sleeping on the task manager,</span>
 <span class="s0">* at the time of the call.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">AsyncTaskCollection AsyncTaskManager::get_tasks(void) const;</span>

<span class="s0">342 16 get_active_tasks 0 4 533 34 AsyncTaskManager::get_active_tasks 0 1 95 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of tasks that are active (and not sleeping) on the task</span>
 <span class="s0">* manager, at the time of the call.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const;</span>

<span class="s0">343 18 get_sleeping_tasks 0 4 533 36 AsyncTaskManager::get_sleeping_tasks 0 1 96 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of tasks that are sleeping (and not active) on the task</span>
 <span class="s0">* manager, at the time of the call.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const;</span>

<span class="s0">344 19 AsyncTaskCollection 0 260 536 40 AsyncTaskCollection::AsyncTaskCollection 0 2 105 106 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">AsyncTaskCollection::AsyncTaskCollection(void);</span>
<span class="s0">AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &amp;copy);</span>

<span class="s0">345 10 operator = 0 4 536 31 AsyncTaskCollection::operator = 0 1 107 0</span>
<span class="s0">70</span>
<span class="s0">void AsyncTaskCollection::operator =(AsyncTaskCollection const &amp;copy);</span>

<span class="s0">346 20 ~AsyncTaskCollection 0 516 536 41 AsyncTaskCollection::~AsyncTaskCollection 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline AsyncTaskCollection::~AsyncTaskCollection(void);</span>

<span class="s0">347 8 add_task 0 4 536 29 AsyncTaskCollection::add_task 0 1 108 50</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new AsyncTask to the collection.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void AsyncTaskCollection::add_task(AsyncTask *task);</span>

<span class="s0">348 11 remove_task 0 4 536 32 AsyncTaskCollection::remove_task 0 2 109 110 212</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated AsyncTask from the collection.  Returns true if the</span>
 <span class="s0">* task was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the nth AsyncTask from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">bool AsyncTaskCollection::remove_task(AsyncTask *task);</span>
<span class="s0">void AsyncTaskCollection::remove_task(std::size_t index);</span>

<span class="s0">349 14 add_tasks_from 0 4 536 35 AsyncTaskCollection::add_tasks_from 0 1 111 204</span>
<span class="s0">/**</span>
 <span class="s0">* Adds all the AsyncTasks indicated in the other collection to this task.</span>
 <span class="s0">* The other tasks are simply appended to the end of the tasks in this list;</span>
 <span class="s0">* duplicates are not automatically removed.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &amp;other);</span>

<span class="s0">350 17 remove_tasks_from 0 4 536 38 AsyncTaskCollection::remove_tasks_from 0 1 112 96</span>
<span class="s0">/**</span>
 <span class="s0">* Removes from this collection all of the AsyncTasks listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &amp;other);</span>

<span class="s0">351 22 remove_duplicate_tasks 0 4 536 43 AsyncTaskCollection::remove_duplicate_tasks 0 1 113 198</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any duplicate entries of the same AsyncTasks on this collection.</span>
 <span class="s0">* If a AsyncTask appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void AsyncTaskCollection::remove_duplicate_tasks(void);</span>

<span class="s0">352 8 has_task 0 4 536 29 AsyncTaskCollection::has_task 0 1 114 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated AsyncTask appears in this collection, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">bool AsyncTaskCollection::has_task(AsyncTask *task) const;</span>

<span class="s0">353 5 clear 0 4 536 26 AsyncTaskCollection::clear 0 1 115 54</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all AsyncTasks from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void AsyncTaskCollection::clear(void);</span>

<span class="s0">354 9 find_task 0 4 536 30 AsyncTaskCollection::find_task 0 1 116 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the task in the collection with the indicated name, if any, or NULL</span>
 <span class="s0">* if no task has that name.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">AsyncTask *AsyncTaskCollection::find_task(std::string const &amp;name) const;</span>

<span class="s0">355 13 get_num_tasks 0 4 536 34 AsyncTaskCollection::get_num_tasks 0 1 117 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of AsyncTasks in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">std::size_t AsyncTaskCollection::get_num_tasks(void) const;</span>

<span class="s0">356 8 get_task 0 4 536 29 AsyncTaskCollection::get_task 0 1 118 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth AsyncTask in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">AsyncTask *AsyncTaskCollection::get_task(std::size_t index) const;</span>

<span class="s0">357 11 operator [] 0 4 536 32 AsyncTaskCollection::operator [] 0 1 119 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth AsyncTask in the collection.  This is the same as</span>
 <span class="s0">* get_task(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">AsyncTask *AsyncTaskCollection::operator [](std::size_t index) const;</span>

<span class="s0">358 4 size 0 4 536 25 AsyncTaskCollection::size 0 1 120 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of tasks in the collection.  This is the same thing as</span>
 <span class="s0">* get_num_tasks().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">std::size_t AsyncTaskCollection::size(void) const;</span>

<span class="s0">359 11 operator += 0 4 536 32 AsyncTaskCollection::operator += 0 1 121 0</span>
<span class="s0">79</span>
<span class="s0">inline void AsyncTaskCollection::operator +=(AsyncTaskCollection const &amp;other);</span>

<span class="s0">360 10 operator + 0 4 536 31 AsyncTaskCollection::operator + 0 1 122 0</span>
<span class="s0">99</span>
<span class="s0">inline AsyncTaskCollection AsyncTaskCollection::operator +(AsyncTaskCollection const &amp;other) const;</span>

<span class="s0">361 6 output 0 4 536 27 AsyncTaskCollection::output 0 1 123 108</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief one-line description of the AsyncTaskCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void AsyncTaskCollection::output(std::ostream &amp;out) const;</span>

<span class="s0">362 5 write 0 4 536 26 AsyncTaskCollection::write 0 1 124 113</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a complete multi-line description of the AsyncTaskCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void AsyncTaskCollection::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">363 4 poll 0 4 533 22 AsyncTaskManager::poll 0 1 97 233</span>
<span class="s0">/**</span>
 <span class="s0">* Runs through all the tasks in the task list, once, if the task manager is</span>
 <span class="s0">* running in single-threaded mode (no threads available).  This method does</span>
 <span class="s0">* nothing in threaded mode, so it may safely be called in either case.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void AsyncTaskManager::poll(void);</span>

<span class="s0">364 18 get_next_wake_time 0 4 533 36 AsyncTaskManager::get_next_wake_time 0 1 98 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scheduled time (on the manager's clock) of the next sleeping</span>
 <span class="s0">* task, on any task chain, to awaken.  Returns -1 if there are no sleeping</span>
 <span class="s0">* tasks.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">double AsyncTaskManager::get_next_wake_time(void) const;</span>

<span class="s0">365 6 output 0 6 533 24 AsyncTaskManager::output 0 1 99 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">virtual void AsyncTaskManager::output(std::ostream &amp;out) const;</span>

<span class="s0">366 5 write 0 6 533 23 AsyncTaskManager::write 0 1 100 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">virtual void AsyncTaskManager::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">367 14 get_global_ptr 0 4 533 32 AsyncTaskManager::get_global_ptr 0 1 101 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global AsyncTaskManager.  This is the</span>
 <span class="s0">* AsyncTaskManager that most code should use for queueing tasks and suchlike.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void);</span>

<span class="s0">368 14 get_class_type 0 4 533 32 AsyncTaskManager::get_class_type 0 1 102 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle AsyncTaskManager::get_class_type(void);</span>

<span class="s0">369 8 get_name 0 4 527 19 AsyncTask::get_name 0 0 0</span>
<span class="s0">58</span>
<span class="s0">inline std::string const &amp;AsyncTask::get_name(void) const;</span>

<span class="s0">370 14 get_done_event 0 4 527 25 AsyncTask::get_done_event 0 0 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the event name that will be triggered when the future finishes.</span>
 <span class="s0">* See set_done_event().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::string const &amp;AsyncTask::get_done_event(void) const;</span>

<span class="s0">371 14 get_class_type 0 4 527 25 AsyncTask::get_class_type 0 1 71 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle AsyncTask::get_class_type(void);</span>

<span class="s0">372 9 AsyncTask 0 260 527 20 AsyncTask::AsyncTask 0 1 41 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline AsyncTask::AsyncTask(AsyncTask const &amp;) = default;</span>

<span class="s0">373 29 upcast_to_TypedReferenceCount 0 12 542 45 AsyncTaskChain::upcast_to_TypedReferenceCount 0 1 152 49</span>
<span class="s0">upcast from AsyncTaskChain to TypedReferenceCount</span>
<span class="s0">73</span>
<span class="s0">TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void);</span>

<span class="s0">374 26 downcast_to_AsyncTaskChain 0 12 523 47 TypedReferenceCount::downcast_to_AsyncTaskChain 0 0 51</span>
<span class="s0">downcast from TypedReferenceCount to AsyncTaskChain</span>
<span class="s0">70</span>
<span class="s0">AsyncTaskChain *TypedReferenceCount::downcast_to_AsyncTaskChain(void);</span>

<span class="s0">375 17 upcast_to_Namable 0 12 542 33 AsyncTaskChain::upcast_to_Namable 0 1 153 37</span>
<span class="s0">upcast from AsyncTaskChain to Namable</span>
<span class="s0">49</span>
<span class="s0">Namable *AsyncTaskChain::upcast_to_Namable(void);</span>

<span class="s0">376 26 downcast_to_AsyncTaskChain 0 12 528 35 Namable::downcast_to_AsyncTaskChain 0 0 39</span>
<span class="s0">downcast from Namable to AsyncTaskChain</span>
<span class="s0">58</span>
<span class="s0">AsyncTaskChain *Namable::downcast_to_AsyncTaskChain(void);</span>

<span class="s0">377 15 ~AsyncTaskChain 0 518 542 31 AsyncTaskChain::~AsyncTaskChain 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">virtual AsyncTaskChain::~AsyncTaskChain(void);</span>

<span class="s0">378 14 set_tick_clock 0 4 542 30 AsyncTaskChain::set_tick_clock 0 1 125 155</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the tick_clock flag.  When this is true, get_clock()-&gt;tick() will be</span>
 <span class="s0">* called automatically at each task epoch.  This is false by default.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void AsyncTaskChain::set_tick_clock(bool tick_clock);</span>

<span class="s0">379 14 get_tick_clock 0 4 542 30 AsyncTaskChain::get_tick_clock 0 1 126 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the tick_clock flag.  See set_tick_clock().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool AsyncTaskChain::get_tick_clock(void) const;</span>

<span class="s0">380 15 set_num_threads 0 4 542 31 AsyncTaskChain::set_num_threads 0 1 127 132</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the number of threads for this task chain.  This may require</span>
 <span class="s0">* stopping the threads if they are already running.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void AsyncTaskChain::set_num_threads(int num_threads);</span>

<span class="s0">381 15 get_num_threads 0 4 542 31 AsyncTaskChain::get_num_threads 0 1 128 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of threads that will be servicing tasks for this chain.</span>
 <span class="s0">* Also see get_num_running_threads().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int AsyncTaskChain::get_num_threads(void) const;</span>

<span class="s0">382 23 get_num_running_threads 0 4 542 39 AsyncTaskChain::get_num_running_threads 0 1 129 211</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of threads that have been created and are actively</span>
 <span class="s0">* running.  This will return 0 before the threads have been started; it will</span>
 <span class="s0">* also return 0 if thread support is not available.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">int AsyncTaskChain::get_num_running_threads(void) const;</span>

<span class="s0">383 19 set_thread_priority 0 4 542 35 AsyncTaskChain::set_thread_priority 0 1 130 153</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the priority associated with threads that serve this task chain.</span>
 <span class="s0">* This may require stopping the threads if they are already running.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void AsyncTaskChain::set_thread_priority(ThreadPriority priority);</span>

<span class="s0">384 19 get_thread_priority 0 4 542 35 AsyncTaskChain::get_thread_priority 0 1 131 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the priority associated with threads that serve this task chain.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">ThreadPriority AsyncTaskChain::get_thread_priority(void) const;</span>

<span class="s0">385 16 set_frame_budget 0 4 542 32 AsyncTaskChain::set_frame_budget 0 1 132 414</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the maximum amount of time per frame the tasks on this chain are</span>
 <span class="s0">* granted for execution.  If this is less than zero, there is no limit; if it</span>
 <span class="s0">* is &gt;= 0, it represents a maximum amount of time (in seconds) that will be</span>
 <span class="s0">* used to execute tasks.  If this time is exceeded in any one frame, the task</span>
 <span class="s0">* chain will stop executing tasks until the next frame, as defined by the</span>
 <span class="s0">* TaskManager's clock.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void AsyncTaskChain::set_frame_budget(double frame_budget);</span>

<span class="s0">386 16 get_frame_budget 0 4 542 32 AsyncTaskChain::get_frame_budget 0 1 133 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum amount of time per frame the tasks on this chain are</span>
 <span class="s0">* granted for execution.  See set_frame_budget().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">double AsyncTaskChain::get_frame_budget(void) const;</span>

<span class="s0">387 14 set_frame_sync 0 4 542 30 AsyncTaskChain::set_frame_sync 0 1 134 638</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the frame_sync flag.  When this flag is true, this task chain will be</span>
 <span class="s0">* forced to sync with the TaskManager's clock.  It will run no faster than</span>
 <span class="s0">* one epoch per clock frame.</span>
 <span class="s0">*</span>
 <span class="s0">* When this flag is false, the default, the task chain will finish all of its</span>
 <span class="s0">* tasks and then immediately start from the first task again, regardless of</span>
 <span class="s0">* the clock frame.  When it is true, the task chain will finish all of its</span>
 <span class="s0">* tasks and then wait for the clock to tick to the next frame before resuming</span>
 <span class="s0">* the first task.</span>
 <span class="s0">*</span>
 <span class="s0">* This only makes sense for threaded task chains.  Non-threaded task chains</span>
 <span class="s0">* are automatically synchronous.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void AsyncTaskChain::set_frame_sync(bool frame_sync);</span>

<span class="s0">388 14 get_frame_sync 0 4 542 30 AsyncTaskChain::get_frame_sync 0 1 135 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the frame_sync flag.  See set_frame_sync().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool AsyncTaskChain::get_frame_sync(void) const;</span>

<span class="s0">389 22 set_timeslice_priority 0 4 542 38 AsyncTaskChain::set_timeslice_priority 0 1 136 903</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the timeslice_priority flag.  This changes the interpretation of</span>
 <span class="s0">* priority, and the number of times per epoch each task will run.</span>
 <span class="s0">*</span>
 <span class="s0">* When this flag is true, some tasks might not run in any given epoch.</span>
 <span class="s0">* Instead, tasks with priority higher than 1 will be given precedence, in</span>
 <span class="s0">* proportion to the amount of time they have already used.  This gives</span>
 <span class="s0">* higher-priority tasks more runtime than lower-priority tasks.  Each task</span>
 <span class="s0">* gets the amount of time proportional to its priority value, so a task with</span>
 <span class="s0">* priority 100 will get five times as much processing time as a task with</span>
 <span class="s0">* priority 20.  For these purposes, priority values less than 1 are deemed to</span>
 <span class="s0">* be equal to 1.</span>
 <span class="s0">*</span>
 <span class="s0">* When this flag is false (the default), all tasks are run exactly once each</span>
 <span class="s0">* epoch, round-robin style.  Priority is only used to determine which task</span>
 <span class="s0">* runs first within tasks of the same sort value.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority);</span>

<span class="s0">390 22 get_timeslice_priority 0 4 542 38 AsyncTaskChain::get_timeslice_priority 0 1 137 184</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the timeslice_priority flag.  This changes the interpretation of</span>
 <span class="s0">* priority, and the number of times per epoch each task will run.  See</span>
 <span class="s0">* set_timeslice_priority().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">bool AsyncTaskChain::get_timeslice_priority(void) const;</span>

<span class="s0">391 12 stop_threads 0 4 542 28 AsyncTaskChain::stop_threads 0 1 138 215</span>
<span class="s0">/**</span>
 <span class="s0">* Stops any threads that are currently running.  If any tasks are still</span>
 <span class="s0">* pending and have not yet been picked up by a thread, they will not be</span>
 <span class="s0">* serviced unless poll() or start_threads() is later called.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void AsyncTaskChain::stop_threads(void);</span>

<span class="s0">392 13 start_threads 0 4 542 29 AsyncTaskChain::start_threads 0 1 139 171</span>
<span class="s0">/**</span>
 <span class="s0">* Starts any requested threads to service the tasks on the queue.  This is</span>
 <span class="s0">* normally not necessary, since adding a task will start the threads</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void AsyncTaskChain::start_threads(void);</span>

<span class="s0">393 10 is_started 0 4 542 26 AsyncTaskChain::is_started 0 1 140 212</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the thread(s) have been started and are ready to service</span>
 <span class="s0">* requests, false otherwise.  If this is false, the next call to add() or</span>
 <span class="s0">* add_and_do() will automatically start the threads.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool AsyncTaskChain::is_started(void) const;</span>

<span class="s0">394 8 has_task 0 4 542 24 AsyncTaskChain::has_task 0 1 141 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated task has been added to this AsyncTaskChain,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">bool AsyncTaskChain::has_task(AsyncTask *task) const;</span>

<span class="s0">395 14 wait_for_tasks 0 4 542 30 AsyncTaskChain::wait_for_tasks 0 1 142 47</span>
<span class="s0">/**</span>
 <span class="s0">* Blocks until the task list is empty.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void AsyncTaskChain::wait_for_tasks(void);</span>

<span class="s0">396 13 get_num_tasks 0 4 542 29 AsyncTaskChain::get_num_tasks 0 1 143 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of tasks that are currently active or sleeping within</span>
 <span class="s0">* the task chain.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">int AsyncTaskChain::get_num_tasks(void) const;</span>

<span class="s0">397 9 get_tasks 0 4 542 25 AsyncTaskChain::get_tasks 0 1 144 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of tasks that are active or sleeping on the task chain, at</span>
 <span class="s0">* the time of the call.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">AsyncTaskCollection AsyncTaskChain::get_tasks(void) const;</span>

<span class="s0">398 16 get_active_tasks 0 4 542 32 AsyncTaskChain::get_active_tasks 0 1 145 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of tasks that are active (and not sleeping) on the task</span>
 <span class="s0">* chain, at the time of the call.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const;</span>

<span class="s0">399 18 get_sleeping_tasks 0 4 542 34 AsyncTaskChain::get_sleeping_tasks 0 1 146 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of tasks that are sleeping (and not active) on the task</span>
 <span class="s0">* chain, at the time of the call.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const;</span>

<span class="s0">400 4 poll 0 4 542 20 AsyncTaskChain::poll 0 1 147 381</span>
<span class="s0">/**</span>
 <span class="s0">* Runs through all the tasks in the task list, once, if the task chain is</span>
 <span class="s0">* running in single-threaded mode (no threads available).  This method does</span>
 <span class="s0">* nothing in threaded mode, so it may safely be called in either case.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, you would not call this function directly; instead, call</span>
 <span class="s0">* AsyncTaskManager::poll(), which polls all of the task chains in sequence.</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">void AsyncTaskChain::poll(void);</span>

<span class="s0">401 18 get_next_wake_time 0 4 542 34 AsyncTaskChain::get_next_wake_time 0 1 148 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scheduled time (on the manager's clock) of the next sleeping</span>
 <span class="s0">* task, on any task chain, to awaken.  Returns -1 if there are no sleeping</span>
 <span class="s0">* tasks.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">double AsyncTaskChain::get_next_wake_time(void) const;</span>

<span class="s0">402 6 output 0 6 542 22 AsyncTaskChain::output 0 1 149 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual void AsyncTaskChain::output(std::ostream &amp;out) const;</span>

<span class="s0">403 5 write 0 6 542 21 AsyncTaskChain::write 0 1 150 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">virtual void AsyncTaskChain::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">404 14 get_class_type 0 4 542 30 AsyncTaskChain::get_class_type 0 1 151 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle AsyncTaskChain::get_class_type(void);</span>

<span class="s0">405 14 AsyncTaskPause 0 260 543 30 AsyncTaskPause::AsyncTaskPause 0 2 154 155 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">AsyncTaskPause::AsyncTaskPause(double delay);</span>
<span class="s0">inline AsyncTaskPause::AsyncTaskPause(AsyncTaskPause const &amp;) = default;</span>

<span class="s0">406 12 operator new 0 4 543 28 AsyncTaskPause::operator new 0 1 156 0</span>
<span class="s0">132</span>
<span class="s0">inline void *AsyncTaskPause::operator new(std::size_t size);</span>
<span class="s0">inline void *AsyncTaskPause::operator new(std::size_t size, void *ptr);</span>

<span class="s0">407 15 operator delete 0 4 543 31 AsyncTaskPause::operator delete 0 0 0</span>
<span class="s0">116</span>
<span class="s0">inline void AsyncTaskPause::operator delete(void *ptr);</span>
<span class="s0">inline void AsyncTaskPause::operator delete(void *, void *);</span>

<span class="s0">408 12 validate_ptr 0 4 543 28 AsyncTaskPause::validate_ptr 0 0 0</span>
<span class="s0">65</span>
<span class="s0">static inline bool AsyncTaskPause::validate_ptr(void const *ptr);</span>

<span class="s0">409 14 get_class_type 0 4 543 30 AsyncTaskPause::get_class_type 0 1 157 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle AsyncTaskPause::get_class_type(void);</span>

<span class="s0">410 15 ~AsyncTaskPause 0 516 543 31 AsyncTaskPause::~AsyncTaskPause 0 0 0</span>
<span class="s0">38</span>
<span class="s0">AsyncTaskPause::~AsyncTaskPause(void);</span>

<span class="s0">411 19 upcast_to_AsyncTask 0 12 544 38 AsyncTaskSequence::upcast_to_AsyncTask 0 1 165 42</span>
<span class="s0">upcast from AsyncTaskSequence to AsyncTask</span>
<span class="s0">56</span>
<span class="s0">AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void);</span>

<span class="s0">412 29 downcast_to_AsyncTaskSequence 0 12 527 40 AsyncTask::downcast_to_AsyncTaskSequence 0 0 44</span>
<span class="s0">downcast from AsyncTask to AsyncTaskSequence</span>
<span class="s0">66</span>
<span class="s0">AsyncTaskSequence *AsyncTask::downcast_to_AsyncTaskSequence(void);</span>

<span class="s0">413 29 upcast_to_AsyncTaskCollection 0 12 544 48 AsyncTaskSequence::upcast_to_AsyncTaskCollection 0 1 166 52</span>
<span class="s0">upcast from AsyncTaskSequence to AsyncTaskCollection</span>
<span class="s0">76</span>
<span class="s0">AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void);</span>

<span class="s0">414 29 downcast_to_AsyncTaskSequence 0 12 536 50 AsyncTaskCollection::downcast_to_AsyncTaskSequence 0 0 54</span>
<span class="s0">downcast from AsyncTaskCollection to AsyncTaskSequence</span>
<span class="s0">76</span>
<span class="s0">AsyncTaskSequence *AsyncTaskCollection::downcast_to_AsyncTaskSequence(void);</span>

<span class="s0">415 17 AsyncTaskSequence 0 260 544 36 AsyncTaskSequence::AsyncTaskSequence 0 2 158 159 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">explicit AsyncTaskSequence::AsyncTaskSequence(std::string const &amp;name);</span>
<span class="s0">inline AsyncTaskSequence::AsyncTaskSequence(AsyncTaskSequence const &amp;) = default;</span>

<span class="s0">416 18 ~AsyncTaskSequence 0 518 544 37 AsyncTaskSequence::~AsyncTaskSequence 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">virtual AsyncTaskSequence::~AsyncTaskSequence(void);</span>

<span class="s0">417 12 operator new 0 4 544 31 AsyncTaskSequence::operator new 0 1 160 0</span>
<span class="s0">138</span>
<span class="s0">inline void *AsyncTaskSequence::operator new(std::size_t size);</span>
<span class="s0">inline void *AsyncTaskSequence::operator new(std::size_t size, void *ptr);</span>

<span class="s0">418 15 operator delete 0 4 544 34 AsyncTaskSequence::operator delete 0 0 0</span>
<span class="s0">122</span>
<span class="s0">inline void AsyncTaskSequence::operator delete(void *ptr);</span>
<span class="s0">inline void AsyncTaskSequence::operator delete(void *, void *);</span>

<span class="s0">419 12 validate_ptr 0 4 544 31 AsyncTaskSequence::validate_ptr 0 0 0</span>
<span class="s0">68</span>
<span class="s0">static inline bool AsyncTaskSequence::validate_ptr(void const *ptr);</span>

<span class="s0">420 16 set_repeat_count 0 4 544 35 AsyncTaskSequence::set_repeat_count 0 1 161 251</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the repeat count of the sequence.  If the count is 0 or 1, the</span>
 <span class="s0">* sequence will run exactly once.  If it is greater than 0, it will run that</span>
 <span class="s0">* number of times.  If it is negative, it will run forever until it is</span>
 <span class="s0">* explicitly removed.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void AsyncTaskSequence::set_repeat_count(int repeat_count);</span>

<span class="s0">421 16 get_repeat_count 0 4 544 35 AsyncTaskSequence::get_repeat_count 0 1 162 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the repeat count of the sequence.  See set_repeat_count().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int AsyncTaskSequence::get_repeat_count(void) const;</span>

<span class="s0">422 22 get_current_task_index 0 4 544 41 AsyncTaskSequence::get_current_task_index 0 1 163 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the task within the sequence that is currently being</span>
 <span class="s0">* executed (or that will be executed at the next epoch).</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline std::size_t AsyncTaskSequence::get_current_task_index(void) const;</span>

<span class="s0">423 14 get_class_type 0 4 544 33 AsyncTaskSequence::get_class_type 0 1 164 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle AsyncTaskSequence::get_class_type(void);</span>

<span class="s0">424 11 operator == 0 4 545 24 ButtonEvent::operator == 0 1 167 0</span>
<span class="s0">69</span>
<span class="s0">inline bool ButtonEvent::operator ==(ButtonEvent const &amp;other) const;</span>

<span class="s0">425 11 operator != 0 4 545 24 ButtonEvent::operator != 0 1 168 0</span>
<span class="s0">69</span>
<span class="s0">inline bool ButtonEvent::operator !=(ButtonEvent const &amp;other) const;</span>

<span class="s0">426 10 operator &lt; 0 4 545 23 ButtonEvent::operator &lt; 0 1 169 0</span>
<span class="s0">68</span>
<span class="s0">inline bool ButtonEvent::operator &lt;(ButtonEvent const &amp;other) const;</span>

<span class="s0">427 10 get_button 0 4 545 23 ButtonEvent::get_button 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline ButtonHandle ButtonEvent::get_button(void) const;</span>

<span class="s0">428 11 get_keycode 0 4 545 24 ButtonEvent::get_keycode 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int ButtonEvent::get_keycode(void) const;</span>

<span class="s0">429 8 get_type 0 4 545 21 ButtonEvent::get_type 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline ButtonEvent::Type ButtonEvent::get_type(void) const;</span>

<span class="s0">430 8 get_time 0 4 545 21 ButtonEvent::get_time 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline double ButtonEvent::get_time(void) const;</span>

<span class="s0">431 12 ~ButtonEvent 0 516 545 25 ButtonEvent::~ButtonEvent 0 0 0</span>
<span class="s0">32</span>
<span class="s0">ButtonEvent::~ButtonEvent(void);</span>

<span class="s0">432 15 ButtonEventList 0 260 548 32 ButtonEventList::ButtonEventList 0 2 170 171 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline ButtonEventList::ButtonEventList(void);</span>
<span class="s0">inline ButtonEventList::ButtonEventList(ButtonEventList const &amp;copy);</span>

<span class="s0">433 10 operator = 0 4 548 27 ButtonEventList::operator = 0 1 172 0</span>
<span class="s0">69</span>
<span class="s0">inline void ButtonEventList::operator =(ButtonEventList const &amp;copy);</span>

<span class="s0">434 9 add_event 0 4 548 26 ButtonEventList::add_event 0 1 173 51</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new event to the end of the list.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void ButtonEventList::add_event(ButtonEvent event);</span>

<span class="s0">435 14 get_num_events 0 4 548 31 ButtonEventList::get_num_events 0 1 174 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of events in the list.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int ButtonEventList::get_num_events(void) const;</span>

<span class="s0">436 9 get_event 0 4 548 26 ButtonEventList::get_event 0 1 175 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth event in the list.  This does not remove the event from the</span>
 <span class="s0">* list; the only way to remove events is to empty the whole list with</span>
 <span class="s0">* clear().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline ButtonEvent const &amp;ButtonEventList::get_event(int n) const;</span>

<span class="s0">437 5 clear 0 4 548 22 ButtonEventList::clear 0 1 176 48</span>
<span class="s0">/**</span>
 <span class="s0">* Empties all the events from the list.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void ButtonEventList::clear(void);</span>

<span class="s0">438 10 add_events 0 4 548 27 ButtonEventList::add_events 0 1 177 75</span>
<span class="s0">/**</span>
 <span class="s0">* Appends the events from the other list onto the end of this one.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void ButtonEventList::add_events(ButtonEventList const &amp;other);</span>

<span class="s0">439 11 update_mods 0 4 548 28 ButtonEventList::update_mods 0 1 178 124</span>
<span class="s0">/**</span>
 <span class="s0">* Updates the indicated ModifierButtons object with all of the button up/down</span>
 <span class="s0">* transitions indicated in the list.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void ButtonEventList::update_mods(ModifierButtons &amp;mods) const;</span>

<span class="s0">440 5 write 0 4 548 22 ButtonEventList::write 0 1 179 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void ButtonEventList::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">441 14 get_class_type 0 4 548 31 ButtonEventList::get_class_type 0 1 180 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle ButtonEventList::get_class_type(void);</span>

<span class="s0">442 16 ~ButtonEventList 0 516 548 33 ButtonEventList::~ButtonEventList 0 0 0</span>
<span class="s0">40</span>
<span class="s0">ButtonEventList::~ButtonEventList(void);</span>

<span class="s0">443 5 Event 0 260 551 12 Event::Event 0 2 181 182 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">Event::Event(std::string const &amp;event_name, EventReceiver *receiver = nullptr);</span>
<span class="s0">Event::Event(Event const &amp;copy);</span>

<span class="s0">444 10 operator = 0 4 551 17 Event::operator = 0 1 183 0</span>
<span class="s0">42</span>
<span class="s0">void Event::operator =(Event const &amp;copy);</span>

<span class="s0">445 8 set_name 0 4 551 15 Event::set_name 0 1 184 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void Event::set_name(std::string const &amp;name);</span>

<span class="s0">446 10 clear_name 0 4 551 17 Event::clear_name 0 1 185 44</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the Event's name to empty.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">inline void Event::clear_name(void);</span>

<span class="s0">447 8 has_name 0 4 551 15 Event::has_name 0 1 186 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Event has a nonempty name set, false if the name is</span>
 <span class="s0">* empty.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool Event::has_name(void) const;</span>

<span class="s0">448 8 get_name 0 4 551 15 Event::get_name 0 1 187 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline std::string const &amp;Event::get_name(void) const;</span>

<span class="s0">449 13 add_parameter 0 4 551 20 Event::add_parameter 0 1 188 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void Event::add_parameter(EventParameter const &amp;obj);</span>

<span class="s0">450 18 get_num_parameters 0 4 551 25 Event::get_num_parameters 0 1 189 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">int Event::get_num_parameters(void) const;</span>

<span class="s0">451 13 get_parameter 0 4 551 20 Event::get_parameter 0 1 190 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">EventParameter Event::get_parameter(int n) const;</span>

<span class="s0">452 12 has_receiver 0 4 551 19 Event::has_receiver 0 1 191 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">bool Event::has_receiver(void) const;</span>

<span class="s0">453 12 get_receiver 0 4 551 19 Event::get_receiver 0 1 192 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">EventReceiver *Event::get_receiver(void) const;</span>

<span class="s0">454 12 set_receiver 0 4 551 19 Event::set_receiver 0 1 193 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void Event::set_receiver(EventReceiver *receiver);</span>

<span class="s0">455 14 clear_receiver 0 4 551 21 Event::clear_receiver 0 1 194 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void Event::clear_receiver(void);</span>

<span class="s0">456 6 output 0 4 551 13 Event::output 0 1 195 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void Event::output(std::ostream &amp;out) const;</span>

<span class="s0">457 14 get_class_type 0 4 551 21 Event::get_class_type 0 1 196 0</span>
<span class="s0">46</span>
<span class="s0">static TypeHandle Event::get_class_type(void);</span>

<span class="s0">458 12 EventHandler 0 260 554 26 EventHandler::EventHandler 0 1 197 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">explicit EventHandler::EventHandler(EventQueue *ev_queue);</span>

<span class="s0">459 10 get_future 0 4 554 24 EventHandler::get_future 0 1 198 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pending future that will be marked as done when the event is next</span>
 <span class="s0">* fired.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">AsyncFuture *EventHandler::get_future(std::string const &amp;event_name);</span>

<span class="s0">460 14 process_events 0 4 554 28 EventHandler::process_events 0 1 199 188</span>
<span class="s0">/**</span>
 <span class="s0">* The main processing loop of the EventHandler.  This function must be called</span>
 <span class="s0">* periodically to service events.  Walks through each pending event and calls</span>
 <span class="s0">* its assigned hooks.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void EventHandler::process_events(void);</span>

<span class="s0">461 14 dispatch_event 0 6 554 28 EventHandler::dispatch_event 0 1 200 66</span>
<span class="s0">/**</span>
 <span class="s0">* Calls the hooks assigned to the indicated single event.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">virtual void EventHandler::dispatch_event(Event const *event);</span>

<span class="s0">462 5 write 0 4 554 19 EventHandler::write 0 1 201 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void EventHandler::write(std::ostream &amp;out) const;</span>

<span class="s0">463 24 get_global_event_handler 0 4 554 38 EventHandler::get_global_event_handler 0 1 202 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the one global EventHandler object.  If the global</span>
 <span class="s0">* object has not yet been created, this will create it.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = nullptr);</span>

<span class="s0">464 14 get_class_type 0 4 554 28 EventHandler::get_class_type 0 1 203 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle EventHandler::get_class_type(void);</span>

<span class="s0">465 10 EventQueue 0 260 556 22 EventQueue::EventQueue 0 1 204 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">EventQueue::EventQueue(void);</span>

<span class="s0">466 11 ~EventQueue 0 516 556 23 EventQueue::~EventQueue 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">EventQueue::~EventQueue(void);</span>

<span class="s0">467 11 queue_event 0 4 556 23 EventQueue::queue_event 0 1 205 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void EventQueue::queue_event(CPT_Event event);</span>

<span class="s0">468 5 clear 0 4 556 17 EventQueue::clear 0 1 206 71</span>
<span class="s0">/**</span>
 <span class="s0">* Empties all events on the queue, throwing them on the floor.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">void EventQueue::clear(void);</span>

<span class="s0">469 14 is_queue_empty 0 4 556 26 EventQueue::is_queue_empty 0 1 207 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">bool EventQueue::is_queue_empty(void) const;</span>

<span class="s0">470 13 is_queue_full 0 4 556 25 EventQueue::is_queue_full 0 1 208 73</span>
<span class="s0">/**</span>
 <span class="s0">* @deprecated Always returns false; the queue can never be full.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">bool EventQueue::is_queue_full(void) const;</span>

<span class="s0">471 13 dequeue_event 0 4 556 25 EventQueue::dequeue_event 0 1 209 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">CPT_Event EventQueue::dequeue_event(void);</span>

<span class="s0">472 22 get_global_event_queue 0 4 556 34 EventQueue::get_global_event_queue 0 1 210 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the one global EventQueue object.  If the global</span>
 <span class="s0">* object has not yet been created, this will create it.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">static inline EventQueue *EventQueue::get_global_event_queue(void);</span>

<span class="s0">473 16 PointerEventList 0 260 557 34 PointerEventList::PointerEventList 0 1 211 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline PointerEventList::PointerEventList(void);</span>

<span class="s0">474 14 get_num_events 0 4 557 32 PointerEventList::get_num_events 0 1 212 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of events in the list.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t PointerEventList::get_num_events(void) const;</span>

<span class="s0">475 13 get_in_window 0 4 557 31 PointerEventList::get_in_window 0 1 213 51</span>
<span class="s0">/**</span>
 <span class="s0">* Get the in-window flag of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool PointerEventList::get_in_window(std::size_t n) const;</span>

<span class="s0">476 8 get_xpos 0 4 557 26 PointerEventList::get_xpos 0 1 214 49</span>
<span class="s0">/**</span>
 <span class="s0">* Get the x-coordinate of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int PointerEventList::get_xpos(std::size_t n) const;</span>

<span class="s0">477 8 get_ypos 0 4 557 26 PointerEventList::get_ypos 0 1 215 49</span>
<span class="s0">/**</span>
 <span class="s0">* Get the y-coordinate of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int PointerEventList::get_ypos(std::size_t n) const;</span>

<span class="s0">478 6 get_dx 0 4 557 24 PointerEventList::get_dx 0 1 216 44</span>
<span class="s0">/**</span>
 <span class="s0">* Get the x-delta of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline double PointerEventList::get_dx(std::size_t n) const;</span>

<span class="s0">479 6 get_dy 0 4 557 24 PointerEventList::get_dy 0 1 217 44</span>
<span class="s0">/**</span>
 <span class="s0">* Get the y-delta of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline double PointerEventList::get_dy(std::size_t n) const;</span>

<span class="s0">480 12 get_sequence 0 4 557 30 PointerEventList::get_sequence 0 1 218 52</span>
<span class="s0">/**</span>
 <span class="s0">* Get the sequence number of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int PointerEventList::get_sequence(std::size_t n) const;</span>

<span class="s0">481 10 get_length 0 4 557 28 PointerEventList::get_length 0 1 219 43</span>
<span class="s0">/**</span>
 <span class="s0">* Get the length of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline double PointerEventList::get_length(std::size_t n) const;</span>

<span class="s0">482 13 get_direction 0 4 557 31 PointerEventList::get_direction 0 1 220 46</span>
<span class="s0">/**</span>
 <span class="s0">* Get the direction of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline double PointerEventList::get_direction(std::size_t n) const;</span>

<span class="s0">483 12 get_rotation 0 4 557 30 PointerEventList::get_rotation 0 1 221 45</span>
<span class="s0">/**</span>
 <span class="s0">* Get the rotation of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline double PointerEventList::get_rotation(std::size_t n) const;</span>

<span class="s0">484 8 get_time 0 4 557 26 PointerEventList::get_time 0 1 222 46</span>
<span class="s0">/**</span>
 <span class="s0">* Get the timestamp of the nth event.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline double PointerEventList::get_time(std::size_t n) const;</span>

<span class="s0">485 5 clear 0 4 557 23 PointerEventList::clear 0 1 223 48</span>
<span class="s0">/**</span>
 <span class="s0">* Empties all the events from the list.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void PointerEventList::clear(void);</span>

<span class="s0">486 9 pop_front 0 4 557 27 PointerEventList::pop_front 0 1 224 48</span>
<span class="s0">/**</span>
 <span class="s0">* Discards the first event on the list.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void PointerEventList::pop_front(void);</span>

<span class="s0">487 9 add_event 0 4 557 27 PointerEventList::add_event 0 3 225 226 227 304</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new event from the given PointerData object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new event to the end of the list.  Automatically calculates the dx,</span>
 <span class="s0">* dy, length, direction, and rotation for all but the first event.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new event to the end of the list based on the given mouse movement.</span>
 <span class="s0">*/</span>
<span class="s0">288</span>
<span class="s0">void PointerEventList::add_event(PointerData const &amp;data, int seq, double time);</span>
<span class="s0">void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time);</span>
<span class="s0">void PointerEventList::add_event(bool in_win, int xpos, int ypos, double xdelta, double ydelta, int seq, double time);</span>

<span class="s0">488 9 encircles 0 4 557 27 PointerEventList::encircles 0 1 228 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the trail loops around the specified point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">bool PointerEventList::encircles(int x, int y) const;</span>

<span class="s0">489 11 total_turns 0 4 557 29 PointerEventList::total_turns 0 1 229 279</span>
<span class="s0">/**</span>
 <span class="s0">* returns the total angular deviation that the trail has made in the</span>
 <span class="s0">* specified time period.  A small number means that the trail is moving in a</span>
 <span class="s0">* relatively straight line, a large number means that the trail is zig-</span>
 <span class="s0">* zagging or spinning.  The result is in degrees.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">double PointerEventList::total_turns(double sec) const;</span>

<span class="s0">490 13 match_pattern 0 4 557 31 PointerEventList::match_pattern 0 1 230 540</span>
<span class="s0">/**</span>
 <span class="s0">* This function is not implemented yet.  It is a work in progress.  The</span>
 <span class="s0">* intent is as follows:</span>
 <span class="s0">*</span>
 <span class="s0">* Returns a nonzero value if the mouse movements match the specified pattern.</span>
 <span class="s0">* The higher the value, the better the match.  The pattern is a sequence of</span>
 <span class="s0">* compass directions (ie, &quot;E&quot;, &quot;NE&quot;, etc) separated by spaces.  If rot is</span>
 <span class="s0">* nonzero, then the pattern is rotated counterclockwise by the specified</span>
 <span class="s0">* amount before testing.  Seglen is the minimum length a mouse movement needs</span>
 <span class="s0">* to be in order to be considered significant.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">double PointerEventList::match_pattern(std::string const &amp;pattern, double rot, double seglen);</span>

<span class="s0">491 14 get_class_type 0 4 557 32 PointerEventList::get_class_type 0 1 231 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle PointerEventList::get_class_type(void);</span>

<span class="s0">492 17 ~PointerEventList 0 516 557 35 PointerEventList::~PointerEventList 0 0 0</span>
<span class="s0">42</span>
<span class="s0">PointerEventList::~PointerEventList(void);</span>

<span class="s0">493 10 PythonTask 0 260 558 22 PythonTask::PythonTask 0 2 232 233 0</span>
<span class="s0">163</span>
<span class="s0">PythonTask::PythonTask(PyObject *function = (&amp; ::_Py_NoneStruct), std::string const &amp;name = string());</span>
<span class="s0">inline PythonTask::PythonTask(PythonTask const &amp;) = default;</span>

<span class="s0">494 12 operator new 0 4 558 24 PythonTask::operator new 0 1 234 0</span>
<span class="s0">124</span>
<span class="s0">inline void *PythonTask::operator new(std::size_t size);</span>
<span class="s0">inline void *PythonTask::operator new(std::size_t size, void *ptr);</span>

<span class="s0">495 15 operator delete 0 4 558 27 PythonTask::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void PythonTask::operator delete(void *ptr);</span>
<span class="s0">inline void PythonTask::operator delete(void *, void *);</span>

<span class="s0">496 12 validate_ptr 0 4 558 24 PythonTask::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool PythonTask::validate_ptr(void const *ptr);</span>

<span class="s0">497 12 set_function 0 4 558 24 PythonTask::set_function 0 1 235 0</span>
<span class="s0">50</span>
<span class="s0">void PythonTask::set_function(PyObject *function);</span>

<span class="s0">498 12 get_function 0 4 558 24 PythonTask::get_function 0 1 236 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the function that is called when the task runs.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline PyObject *PythonTask::get_function(void);</span>

<span class="s0">499 8 set_args 0 4 558 20 PythonTask::set_args 0 1 237 0</span>
<span class="s0">60</span>
<span class="s0">void PythonTask::set_args(PyObject *args, bool append_task);</span>

<span class="s0">500 8 get_args 0 4 558 20 PythonTask::get_args 0 1 238 0</span>
<span class="s0">37</span>
<span class="s0">PyObject *PythonTask::get_args(void);</span>

<span class="s0">501 14 set_upon_death 0 4 558 26 PythonTask::set_upon_death 0 1 239 0</span>
<span class="s0">54</span>
<span class="s0">void PythonTask::set_upon_death(PyObject *upon_death);</span>

<span class="s0">502 14 get_upon_death 0 4 558 26 PythonTask::get_upon_death 0 1 240 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the function that is called when the task finishes.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline PyObject *PythonTask::get_upon_death(void);</span>

<span class="s0">503 9 set_owner 0 4 558 21 PythonTask::set_owner 0 1 241 0</span>
<span class="s0">44</span>
<span class="s0">void PythonTask::set_owner(PyObject *owner);</span>

<span class="s0">504 9 get_owner 0 4 558 21 PythonTask::get_owner 0 1 242 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;owner&quot; object.  See set_owner().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline PyObject *PythonTask::get_owner(void) const;</span>

<span class="s0">505 10 set_result 0 4 558 22 PythonTask::set_result 0 1 243 172</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;result&quot; of this task.  This is the value returned from an &quot;await&quot;</span>
 <span class="s0">* expression on this task.</span>
 <span class="s0">* This can only be called while the task is still alive.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void PythonTask::set_result(PyObject *result);</span>

<span class="s0">506 11 __setattr__ 0 4 558 23 PythonTask::__setattr__ 0 1 244 0</span>
<span class="s0">73</span>
<span class="s0">int PythonTask::__setattr__(PyObject *self, PyObject *attr, PyObject *v);</span>

<span class="s0">507 11 __delattr__ 0 4 558 23 PythonTask::__delattr__ 0 1 245 0</span>
<span class="s0">60</span>
<span class="s0">int PythonTask::__delattr__(PyObject *self, PyObject *attr);</span>

<span class="s0">508 11 __getattr__ 0 4 558 23 PythonTask::__getattr__ 0 1 246 0</span>
<span class="s0">56</span>
<span class="s0">PyObject *PythonTask::__getattr__(PyObject *attr) const;</span>

<span class="s0">509 12 __traverse__ 0 4 558 24 PythonTask::__traverse__ 0 1 247 0</span>
<span class="s0">57</span>
<span class="s0">int PythonTask::__traverse__(visitproc visit, void *arg);</span>

<span class="s0">510 9 __clear__ 0 4 558 21 PythonTask::__clear__ 0 1 248 0</span>
<span class="s0">32</span>
<span class="s0">int PythonTask::__clear__(void);</span>

<span class="s0">511 16 get_elapsed_time 0 4 558 28 PythonTask::get_elapsed_time 0 0 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of time that has elapsed since the task was started,</span>
 <span class="s0">* according to the task manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">double PythonTask::get_elapsed_time(void) const;</span>

<span class="s0">512 13 get_wake_time 0 4 558 25 PythonTask::get_wake_time 0 0 710</span>
<span class="s0">/**</span>
 <span class="s0">* If this task has been added to an AsyncTaskManager with a delay in effect,</span>
 <span class="s0">* this returns the time at which the task is expected to awaken.  It has no</span>
 <span class="s0">* meaning if the task has not yet been added to a queue, or if there was no</span>
 <span class="s0">* delay in effect at the time the task was added.</span>
 <span class="s0">*</span>
 <span class="s0">* If the task's status is not S_sleeping, this returns 0.0.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* If this task has been added to an AsyncTaskManager with a delay in effect,</span>
 <span class="s0">* this returns the time at which the task is expected to awaken.  It has no</span>
 <span class="s0">* meaning if the task has not yet been added to a queue, or if there was no</span>
 <span class="s0">* delay in effect at the time the task was added.</span>
 <span class="s0">*</span>
 <span class="s0">* If the task's status is not S_sleeping, this returns 0.0.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">double PythonTask::get_wake_time(void) const;</span>

<span class="s0">513 9 get_delay 0 4 558 21 PythonTask::get_delay 0 0 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the delay value that has been set via set_delay, if any.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the delay value that has been set via set_delay, if any.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline double PythonTask::get_delay(void) const;</span>

<span class="s0">514 9 has_delay 0 4 558 21 PythonTask::has_delay 0 1 250 204</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a delay has been set for this task via set_delay(), or</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if a delay has been set for this task via set_delay(), or</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool PythonTask::has_delay(void) const;</span>

<span class="s0">515 9 set_delay 0 4 558 21 PythonTask::set_delay 0 0 1374</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the amount of time, in seconds, by which this task will be</span>
 <span class="s0">* delayed after it has been added to the AsyncTaskManager.  At least the</span>
 <span class="s0">* specified amount of time (and possibly more) will elapse before the task</span>
 <span class="s0">* begins.</span>
 <span class="s0">*</span>
 <span class="s0">* You may specify a delay of 0.0 to guarantee that the task will run in the</span>
 <span class="s0">* next epoch following the one in which it is added.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this value after the task has already been added will not affect</span>
 <span class="s0">* the task's wake time; it will only affect the task if it is re-added to the</span>
 <span class="s0">* queue in the future, for instance if the task returns DS_again.  However,</span>
 <span class="s0">* see recalc_wake_time() if you wish to apply the delay effect immediately.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies the amount of time, in seconds, by which this task will be</span>
 <span class="s0">* delayed after it has been added to the AsyncTaskManager.  At least the</span>
 <span class="s0">* specified amount of time (and possibly more) will elapse before the task</span>
 <span class="s0">* begins.</span>
 <span class="s0">*</span>
 <span class="s0">* You may specify a delay of 0.0 to guarantee that the task will run in the</span>
 <span class="s0">* next epoch following the one in which it is added.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this value after the task has already been added will not affect</span>
 <span class="s0">* the task's wake time; it will only affect the task if it is re-added to the</span>
 <span class="s0">* queue in the future, for instance if the task returns DS_again.  However,</span>
 <span class="s0">* see recalc_wake_time() if you wish to apply the delay effect immediately.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void PythonTask::set_delay(double delay);</span>

<span class="s0">516 11 clear_delay 0 4 558 23 PythonTask::clear_delay 0 1 251 434</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any delay specified for the task.  The next time the task is added</span>
 <span class="s0">* to the queue, it will run immediately.  This does not affect the task's</span>
 <span class="s0">* wake time if it has already been added to the queue.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes any delay specified for the task.  The next time the task is added</span>
 <span class="s0">* to the queue, it will run immediately.  This does not affect the task's</span>
 <span class="s0">* wake time if it has already been added to the queue.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void PythonTask::clear_delay(void);</span>

<span class="s0">517 18 get_elapsed_frames 0 4 558 30 PythonTask::get_elapsed_frames 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of frames that have elapsed since the task was started,</span>
 <span class="s0">* according to the task manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">int PythonTask::get_elapsed_frames(void) const;</span>

<span class="s0">518 8 get_dict 0 20 558 20 PythonTask::get_dict 0 0 42</span>
<span class="s0">getter for PyObject *PythonTask::__dict__;</span>
<span class="s0">43</span>
<span class="s0">PyObject *PythonTask::get_dict(void) const;</span>

<span class="s0">519 8 set_dict 0 36 558 20 PythonTask::set_dict 0 0 42</span>
<span class="s0">setter for PyObject *PythonTask::__dict__;</span>
<span class="s0">43</span>
<span class="s0">void PythonTask::set_dict(PyObject *value);</span>

<span class="s0">520 14 get_class_type 0 4 558 26 PythonTask::get_class_type 0 1 249 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle PythonTask::get_class_type(void);</span>

<span class="s0">251</span>
<span class="s0">1 0 0 7 2 562 254 0 0 0 </span>
<span class="s0">2 0 0 15 2 562 254 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 563  </span>
<span class="s0">3 0 0 23 2 562 254 0 477 /**</span>
 <span class="s0">* Defines an EventParameter that stores a pointer to a TypedReferenceCount</span>
 <span class="s0">* object.  Note that a TypedReferenceCount is not the same kind of pointer as</span>
 <span class="s0">* a TypedWritableReferenceCount, hence we require both constructors.</span>
 <span class="s0">*</span>
 <span class="s0">* This accepts a const pointer, even though it stores (and eventually</span>
 <span class="s0">* returns) a non-const pointer.  This is just the simplest way to allow both</span>
 <span class="s0">* const and non-const pointers to be stored, but it does lose the constness.</span>
 <span class="s0">* Be careful.</span>
 <span class="s0">*/ 1 3 ptr 1 565  </span>
<span class="s0">4 0 0 23 2 562 254 0 396 /**</span>
 <span class="s0">* Defines an EventParameter that stores a pointer to any kind of</span>
 <span class="s0">* TypedWritableReferenceCount object.  This is the most general constructor.</span>
 <span class="s0">*</span>
 <span class="s0">* This accepts a const pointer, even though it stores (and eventually</span>
 <span class="s0">* returns) a non-const pointer.  This is just the simplest way to allow both</span>
 <span class="s0">* const and non-const pointers to be stored, but it does lose the constness.</span>
 <span class="s0">* Be careful.</span>
 <span class="s0">*/ 1 3 ptr 1 567  </span>
<span class="s0">5 0 0 23 2 562 254 0 72 /**</span>
 <span class="s0">* Defines an EventParameter that stores a floating-point value.</span>
 <span class="s0">*/ 1 5 value 1 537  </span>
<span class="s0">6 0 0 23 2 562 254 0 66 /**</span>
 <span class="s0">* Defines an EventParameter that stores an integer value.</span>
 <span class="s0">*/ 1 5 value 1 541  </span>
<span class="s0">7 0 0 23 2 562 254 0 0 1 6 param0 0 570  </span>
<span class="s0">8 0 0 23 2 562 254 0 64 /**</span>
 <span class="s0">* Defines an EventParameter that stores a string value.</span>
 <span class="s0">*/ 1 5 value 1 572  </span>
<span class="s0">9 0 0 23 2 562 254 0 65 /**</span>
 <span class="s0">* Defines an EventParameter that stores a wstring value.</span>
 <span class="s0">*/ 1 5 value 1 572  </span>
<span class="s0">10 0 0 6 3 562 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 562  4 copy 1 563  </span>
<span class="s0">11 0 0 6 5 531 0 0 266 // These functions are conveniences to easily determine if the</span>
<span class="s0">// EventParameter is one of the predefined parameter types, and retrieve the</span>
<span class="s0">// corresponding value.  Of course, it is possible that the EventParameter</span>
<span class="s0">// is some user-defined type, and is none of these. 1 4 this 3 563  </span>
<span class="s0">12 0 0 6 6 531 0 0 90 /**</span>
 <span class="s0">* Returns true if the EventParameter stores an integer value, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">13 0 0 6 7 541 0 0 133 /**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_int() has already returned true.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">14 0 0 6 8 531 0 0 103 /**</span>
 <span class="s0">* Returns true if the EventParameter stores a double floating-point value,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">15 0 0 6 9 537 0 0 136 /**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_double() has already returned true.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">16 0 0 6 10 531 0 0 85 /**</span>
 <span class="s0">* Returns true if the EventParameter stores a string value, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">17 0 0 6 11 572 0 0 136 /**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_string() has already returned true.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">18 0 0 6 12 531 0 0 86 /**</span>
 <span class="s0">* Returns true if the EventParameter stores a wstring value, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">19 0 0 6 13 572 0 0 137 /**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_wstring() has already returned true.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">20 0 0 6 14 531 0 0 255 /**</span>
 <span class="s0">* Returns true if the EventParameter stores a TypedReferenceCount pointer,</span>
 <span class="s0">* false otherwise.  Note that a TypedReferenceCount is not exactly the same</span>
 <span class="s0">* kind of pointer as a TypedWritableReferenceCount, hence the need for this</span>
 <span class="s0">* separate call.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">21 0 0 7 15 573 0 0 145 /**</span>
 <span class="s0">* Retrieves the value stored in the EventParameter.  It is only valid to call</span>
 <span class="s0">* this if is_typed_ref_count() has already returned true.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">22 0 0 7 16 574 0 0 281 /**</span>
 <span class="s0">* Retrieves a pointer to the actual value stored in the parameter.  The</span>
 <span class="s0">* TypeHandle of this pointer may be examined to determine the actual type of</span>
 <span class="s0">* parameter it contains.  This is the only way to retrieve the value when it</span>
 <span class="s0">* is not one of the above predefined types.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">23 0 0 4 17 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 563  3 out 1 575  </span>
<span class="s0">24 0 0 7 20 578 0 0 55 /**</span>
 <span class="s0">* Initializes the future in the pending state.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">25 0 0 15 20 578 0 0 0 1 6 param0 0 579  </span>
<span class="s0">26 0 0 38 21 559 0 0 0 0 </span>
<span class="s0">27 0 0 38 22 559 0 0 0 0 </span>
<span class="s0">28 0 0 6 23 531 0 0 104 /**</span>
 <span class="s0">* Returns true if the future is done or has been cancelled.  It is always</span>
 <span class="s0">* safe to call this.</span>
 <span class="s0">*/ 1 4 this 3 579  </span>
<span class="s0">29 0 0 6 24 531 0 0 85 /**</span>
 <span class="s0">* Returns true if the future was cancelled.  It is always safe to call this.</span>
 <span class="s0">*/ 1 4 this 3 579  </span>
<span class="s0">30 0 0 38 25 559 0 0 0 2 4 this 3 579  7 timeout 5 559  </span>
<span class="s0">31 0 0 6 26 531 0 0 235 /**</span>
 <span class="s0">* Cancels the future.  Returns true if it was cancelled, or false if the</span>
 <span class="s0">* future was already done.  Either way, done() will return true after this</span>
 <span class="s0">* call returns.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of a task, this is equivalent to remove().</span>
 <span class="s0">*/ 1 4 this 3 578  </span>
<span class="s0">32 0 0 4 27 577 0 0 212 /**</span>
 <span class="s0">* Sets the event name that will be triggered when the future finishes.  Will</span>
 <span class="s0">* not be triggered if the future is cancelled, but it will be triggered for</span>
 <span class="s0">* a coroutine task that exits with an exception.</span>
 <span class="s0">*/ 2 4 this 3 578  10 done_event 1 572  </span>
<span class="s0">33 0 0 6 28 572 0 0 107 /**</span>
 <span class="s0">* Returns the event name that will be triggered when the future finishes.</span>
 <span class="s0">* See set_done_event().</span>
 <span class="s0">*/ 1 4 this 3 579  </span>
<span class="s0">34 0 0 38 33 559 0 0 0 2 4 this 3 578  2 fn 1 559  </span>
<span class="s0">35 0 0 38 34 559 0 0 0 1 4 args 1 559  </span>
<span class="s0">36 0 0 4 35 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 579  3 out 1 575  </span>
<span class="s0">37 0 0 4 36 577 0 0 42 /**</span>
 <span class="s0">* Waits until the future is done.</span>
 <span class="s0">*/ 1 4 this 3 578  </span>
<span class="s0">38 0 0 4 36 577 0 0 75 /**</span>
 <span class="s0">* Waits until the future is done, or until the timeout is reached.</span>
 <span class="s0">*/ 2 4 this 3 578  7 timeout 1 537  </span>
<span class="s0">39 0 0 36 37 577 0 0 0 2 4 this 3 578  6 param0 0 559  </span>
<span class="s0">40 0 0 7 38 582 0 0 0 0 </span>
<span class="s0">41 0 0 15 162 585 287 0 0 1 6 param0 0 583  </span>
<span class="s0">42 0 0 6 48 530 0 0 49 /**</span>
 <span class="s0">* Returns the current state of the task.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">43 0 0 6 49 531 0 0 332 /**</span>
 <span class="s0">* Returns true if the task is currently active or sleeping on some task</span>
 <span class="s0">* chain, meaning that it will be executed in its turn, or false if it is not</span>
 <span class="s0">* active.  If the task has recently been removed while it is in the middle of</span>
 <span class="s0">* execution, this will return false, because the task will not run again once</span>
 <span class="s0">* it finishes.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">44 0 0 7 50 532 322 0 118 /**</span>
 <span class="s0">* Returns the AsyncTaskManager that this task is active on.  This will be</span>
 <span class="s0">* NULL if the state is S_inactive.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">45 0 0 6 51 531 0 0 185 /**</span>
 <span class="s0">* Removes the task from its active manager, if any, and makes the state</span>
 <span class="s0">* S_inactive (or possible S_servicing_removed).  This is a no-op if the state</span>
 <span class="s0">* is already S_inactive.</span>
 <span class="s0">*/ 1 4 this 3 585  </span>
<span class="s0">46 0 0 4 52 577 0 0 686 /**</span>
 <span class="s0">* Specifies the amount of time, in seconds, by which this task will be</span>
 <span class="s0">* delayed after it has been added to the AsyncTaskManager.  At least the</span>
 <span class="s0">* specified amount of time (and possibly more) will elapse before the task</span>
 <span class="s0">* begins.</span>
 <span class="s0">*</span>
 <span class="s0">* You may specify a delay of 0.0 to guarantee that the task will run in the</span>
 <span class="s0">* next epoch following the one in which it is added.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this value after the task has already been added will not affect</span>
 <span class="s0">* the task's wake time; it will only affect the task if it is re-added to the</span>
 <span class="s0">* queue in the future, for instance if the task returns DS_again.  However,</span>
 <span class="s0">* see recalc_wake_time() if you wish to apply the delay effect immediately.</span>
 <span class="s0">*/ 2 4 this 3 585  5 delay 1 537  </span>
<span class="s0">47 0 0 4 53 577 0 0 216 /**</span>
 <span class="s0">* Removes any delay specified for the task.  The next time the task is added</span>
 <span class="s0">* to the queue, it will run immediately.  This does not affect the task's</span>
 <span class="s0">* wake time if it has already been added to the queue.</span>
 <span class="s0">*/ 1 4 this 3 585  </span>
<span class="s0">48 0 0 6 54 531 0 0 101 /**</span>
 <span class="s0">* Returns true if a delay has been set for this task via set_delay(), or</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">49 0 0 6 55 537 0 0 75 /**</span>
 <span class="s0">* Returns the delay value that has been set via set_delay, if any.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">50 0 0 6 56 537 0 0 354 /**</span>
 <span class="s0">* If this task has been added to an AsyncTaskManager with a delay in effect,</span>
 <span class="s0">* this returns the time at which the task is expected to awaken.  It has no</span>
 <span class="s0">* meaning if the task has not yet been added to a queue, or if there was no</span>
 <span class="s0">* delay in effect at the time the task was added.</span>
 <span class="s0">*</span>
 <span class="s0">* If the task's status is not S_sleeping, this returns 0.0.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">51 0 0 4 57 577 0 0 437 /**</span>
 <span class="s0">* If the task is currently sleeping on a task chain, this resets its wake</span>
 <span class="s0">* time to the current time + get_delay().  It is as if the task had suddenly</span>
 <span class="s0">* returned DS_again.  The task will sleep for its current delay seconds</span>
 <span class="s0">* before running again.  This method may therefore be used to make the task</span>
 <span class="s0">* wake up sooner or later than it would have otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* If the task is not already sleeping, this method has no effect.</span>
 <span class="s0">*/ 1 4 this 3 585  </span>
<span class="s0">52 0 0 6 58 537 0 0 176 /**</span>
 <span class="s0">* Returns the time at which the task was started, according to the task</span>
 <span class="s0">* manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">53 0 0 6 59 537 0 0 200 /**</span>
 <span class="s0">* Returns the amount of time that has elapsed since the task was started,</span>
 <span class="s0">* according to the task manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">54 0 0 6 60 541 0 0 184 /**</span>
 <span class="s0">* Returns the frame number at which the task was started, according to the</span>
 <span class="s0">* task manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">55 0 0 6 61 541 0 0 203 /**</span>
 <span class="s0">* Returns the number of frames that have elapsed since the task was started,</span>
 <span class="s0">* according to the task manager's clock.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the task's status is not S_inactive.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">56 0 0 4 62 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 585  4 name 1 572  </span>
<span class="s0">57 0 0 4 63 577 0 0 43 /**</span>
 <span class="s0">* Resets the task's name to empty.</span>
 <span class="s0">*/ 1 4 this 3 585  </span>
<span class="s0">58 0 0 6 64 572 0 0 129 /**</span>
 <span class="s0">* Returns the initial part of the name, up to but not including any trailing</span>
 <span class="s0">* digits following a hyphen or underscore.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">59 0 0 6 65 538 0 0 107 /**</span>
 <span class="s0">* Returns a number guaranteed to be unique for each different AsyncTask</span>
 <span class="s0">* object in the universe.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">60 0 0 4 66 577 0 0 135 /**</span>
 <span class="s0">* Specifies the AsyncTaskChain on which this task will be running.  Each task</span>
 <span class="s0">* chain runs tasks independently of the others.</span>
 <span class="s0">*/ 2 4 this 3 585  10 chain_name 1 572  </span>
<span class="s0">61 0 0 6 67 572 0 0 133 /**</span>
 <span class="s0">* Returns the AsyncTaskChain on which this task will be running.  Each task</span>
 <span class="s0">* chain runs tasks independently of the others.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">62 0 0 4 68 577 0 0 483 /**</span>
 <span class="s0">* Specifies a sort value for this task.  Within a given AsyncTaskManager, all</span>
 <span class="s0">* of the tasks with a given sort value are guaranteed to be completed before</span>
 <span class="s0">* any tasks with a higher sort value are begun.</span>
 <span class="s0">*</span>
 <span class="s0">* To put it another way, two tasks might execute in parallel with each other</span>
 <span class="s0">* only if they both have the same sort value.  Tasks with a lower sort value</span>
 <span class="s0">* are executed first.</span>
 <span class="s0">*</span>
 <span class="s0">* This is different from the priority, which makes no such exclusion</span>
 <span class="s0">* guarantees.</span>
 <span class="s0">*/ 2 4 this 3 585  4 sort 1 541  </span>
<span class="s0">63 0 0 6 69 541 0 0 66 /**</span>
 <span class="s0">* Returns the task's current sort value.  See set_sort().</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">64 0 0 4 70 577 0 0 874 /**</span>
 <span class="s0">* Specifies a priority value for this task.  In general, tasks with a higher</span>
 <span class="s0">* priority value are executed before tasks with a lower priority value (but</span>
 <span class="s0">* only for tasks with the same sort value).</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the sort value, tasks with different priorities may execute at the</span>
 <span class="s0">* same time, if the AsyncTaskManager has more than one thread servicing</span>
 <span class="s0">* tasks.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see AsyncTaskChain::set_timeslice_priority(), which changes the</span>
 <span class="s0">* meaning of this value.  In the default mode, when the timeslice_priority</span>
 <span class="s0">* flag is false, all tasks always run once per epoch, regardless of their</span>
 <span class="s0">* priority values (that is, the priority controls the order of the task</span>
 <span class="s0">* execution only, not the number of times it runs).  On the other hand, if</span>
 <span class="s0">* you set the timeslice_priority flag to true, then changing a task's</span>
 <span class="s0">* priority has an effect on the number of times it runs.</span>
 <span class="s0">*/ 2 4 this 3 585  8 priority 1 541  </span>
<span class="s0">65 0 0 6 71 541 0 0 74 /**</span>
 <span class="s0">* Returns the task's current priority value.  See set_priority().</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">66 0 0 4 72 577 0 0 257 /**</span>
 <span class="s0">* Sets the event name that will be triggered when the task finishes.  This</span>
 <span class="s0">* should only be called before the task has been started, or after it has</span>
 <span class="s0">* finished and before it is about to be restarted (i.e.  when get_state()</span>
 <span class="s0">* returns S_inactive).</span>
 <span class="s0">*/ 2 4 this 3 585  10 done_event 1 572  </span>
<span class="s0">67 0 0 6 73 537 0 0 98 /**</span>
 <span class="s0">* Returns the amount of time elapsed during the task's previous run cycle, in</span>
 <span class="s0">* seconds.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">68 0 0 6 74 537 0 0 118 /**</span>
 <span class="s0">* Returns the maximum amount of time elapsed during any one of the task's</span>
 <span class="s0">* previous run cycles, in seconds.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">69 0 0 6 75 537 0 0 115 /**</span>
 <span class="s0">* Returns the average amount of time elapsed during each of the task's</span>
 <span class="s0">* previous run cycles, in seconds.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">70 0 0 4 76 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 583  3 out 1 575  </span>
<span class="s0">71 0 0 7 161 582 0 0 0 0 </span>
<span class="s0">72 0 0 7 40 578 0 0 0 1 4 this 3 585  </span>
<span class="s0">73 0 0 6 43 586 0 0 0 1 4 this 3 585  </span>
<span class="s0">74 0 0 7 87 532 322 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 572  </span>
<span class="s0">75 0 0 4 89 577 0 0 118 /**</span>
 <span class="s0">* Stops all threads and messily empties the task list.  This is intended to</span>
 <span class="s0">* be called on destruction only.</span>
 <span class="s0">*/ 1 4 this 3 532  </span>
<span class="s0">76 0 0 4 90 577 0 0 286 /**</span>
 <span class="s0">* Replaces the clock pointer used within the AsyncTaskManager.  This is used</span>
 <span class="s0">* to control when tasks with a set_delay() specified will be scheduled.  It</span>
 <span class="s0">* can also be ticked automatically each epoch, if set_tick_clock() is true.</span>
 <span class="s0">*</span>
 <span class="s0">* The default is the global clock pointer.</span>
 <span class="s0">*/ 2 4 this 3 532  5 clock 1 534  </span>
<span class="s0">77 0 0 7 91 534 0 0 91 /**</span>
 <span class="s0">* Returns the clock pointer used within the AsyncTaskManager.  See</span>
 <span class="s0">* set_clock().</span>
 <span class="s0">*/ 1 4 this 3 532  </span>
<span class="s0">78 0 0 6 95 541 0 0 55 /**</span>
 <span class="s0">* Returns the number of different task chains.</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">79 0 0 7 96 589 377 0 38 /**</span>
 <span class="s0">* Returns the nth task chain.</span>
 <span class="s0">*/ 2 4 this 3 587  1 n 1 541  </span>
<span class="s0">80 0 0 7 98 589 377 0 178 /**</span>
 <span class="s0">* Creates a new AsyncTaskChain of the indicated name and stores it within the</span>
 <span class="s0">* AsyncTaskManager.  If a task chain with this name already exists, returns</span>
 <span class="s0">* it instead.</span>
 <span class="s0">*/ 2 4 this 3 532  4 name 1 572  </span>
<span class="s0">81 0 0 7 99 589 377 0 113 /**</span>
 <span class="s0">* Searches a new AsyncTaskChain of the indicated name and returns it if it</span>
 <span class="s0">* exists, or NULL otherwise.</span>
 <span class="s0">*/ 2 4 this 3 532  4 name 1 572  </span>
<span class="s0">82 0 0 6 100 531 0 0 211 /**</span>
 <span class="s0">* Removes the AsyncTaskChain of the indicated name.  If the chain still has</span>
 <span class="s0">* tasks, this will block until all tasks are finished.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, or false if the chain did not exist.</span>
 <span class="s0">*/ 2 4 this 3 532  4 name 1 572  </span>
<span class="s0">83 0 0 4 101 577 0 0 138 /**</span>
 <span class="s0">* Adds the indicated task to the active queue.  It is an error if the task is</span>
 <span class="s0">* already added to this or any other active queue.</span>
 <span class="s0">*/ 2 4 this 3 532  4 task 1 585  </span>
<span class="s0">84 0 0 6 102 531 0 0 106 /**</span>
 <span class="s0">* Returns true if the indicated task has been added to this AsyncTaskManager,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 587  4 task 1 585  </span>
<span class="s0">85 0 0 7 103 585 287 0 210 /**</span>
 <span class="s0">* Returns the first task found with the indicated name, or NULL if there is</span>
 <span class="s0">* no task with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* If there are multiple tasks with the same name, returns one of them</span>
 <span class="s0">* arbitrarily.</span>
 <span class="s0">*/ 2 4 this 3 587  4 name 1 572  </span>
<span class="s0">86 0 0 7 104 590 346 0 67 /**</span>
 <span class="s0">* Returns the list of tasks found with the indicated name.</span>
 <span class="s0">*/ 2 4 this 3 587  4 name 1 572  </span>
<span class="s0">87 0 0 7 105 590 346 0 111 /**</span>
 <span class="s0">* Returns the list of tasks found whose name matches the indicated glob</span>
 <span class="s0">* pattern, e.g.  &quot;my_task_*&quot;.</span>
 <span class="s0">*/ 2 4 this 3 587  7 pattern 1 591  </span>
<span class="s0">88 0 0 6 106 531 0 0 143 /**</span>
 <span class="s0">* Removes the indicated task from the active queue.  Returns true if the task</span>
 <span class="s0">* is successfully removed, or false if it wasn't there.</span>
 <span class="s0">*/ 2 4 this 3 532  4 task 1 585  </span>
<span class="s0">89 0 0 6 106 596 0 0 104 /**</span>
 <span class="s0">* Removes all of the tasks in the AsyncTaskCollection.  Returns the number of</span>
 <span class="s0">* tasks removed.</span>
 <span class="s0">*/ 2 4 this 3 532  5 tasks 1 594  </span>
<span class="s0">90 0 0 4 107 577 0 0 47 /**</span>
 <span class="s0">* Blocks until the task list is empty.</span>
 <span class="s0">*/ 1 4 this 3 532  </span>
<span class="s0">91 0 0 4 108 577 0 0 215 /**</span>
 <span class="s0">* Stops any threads that are currently running.  If any tasks are still</span>
 <span class="s0">* pending and have not yet been picked up by a thread, they will not be</span>
 <span class="s0">* serviced unless poll() or start_threads() is later called.</span>
 <span class="s0">*/ 1 4 this 3 532  </span>
<span class="s0">92 0 0 4 109 577 0 0 171 /**</span>
 <span class="s0">* Starts any requested threads to service the tasks on the queue.  This is</span>
 <span class="s0">* normally not necessary, since adding a task will start the threads</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*/ 1 4 this 3 532  </span>
<span class="s0">93 0 0 6 110 596 0 0 104 /**</span>
 <span class="s0">* Returns the number of tasks that are currently active or sleeping within</span>
 <span class="s0">* the task manager.</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">94 0 0 7 111 590 346 0 112 /**</span>
 <span class="s0">* Returns the set of tasks that are active or sleeping on the task manager,</span>
 <span class="s0">* at the time of the call.</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">95 0 0 7 112 590 346 0 119 /**</span>
 <span class="s0">* Returns the set of tasks that are active (and not sleeping) on the task</span>
 <span class="s0">* manager, at the time of the call.</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">96 0 0 7 113 590 346 0 119 /**</span>
 <span class="s0">* Returns the set of tasks that are sleeping (and not active) on the task</span>
 <span class="s0">* manager, at the time of the call.</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">97 0 0 4 138 577 0 0 233 /**</span>
 <span class="s0">* Runs through all the tasks in the task list, once, if the task manager is</span>
 <span class="s0">* running in single-threaded mode (no threads available).  This method does</span>
 <span class="s0">* nothing in threaded mode, so it may safely be called in either case.</span>
 <span class="s0">*/ 1 4 this 3 532  </span>
<span class="s0">98 0 0 6 139 537 0 0 169 /**</span>
 <span class="s0">* Returns the scheduled time (on the manager's clock) of the next sleeping</span>
 <span class="s0">* task, on any task chain, to awaken.  Returns -1 if there are no sleeping</span>
 <span class="s0">* tasks.</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">99 0 0 4 142 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 587  3 out 1 575  </span>
<span class="s0">100 0 0 4 143 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 587  3 out 1 575  12 indent_level 5 541  </span>
<span class="s0">101 0 0 7 144 532 322 0 152 /**</span>
 <span class="s0">* Returns a pointer to the global AsyncTaskManager.  This is the</span>
 <span class="s0">* AsyncTaskManager that most code should use for queueing tasks and suchlike.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">102 0 0 7 145 582 0 0 0 0 </span>
<span class="s0">103 0 0 7 83 573 0 0 0 1 4 this 3 532  </span>
<span class="s0">104 0 0 6 85 586 0 0 0 1 4 this 3 532  </span>
<span class="s0">105 0 0 7 116 590 346 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">106 0 0 15 116 590 346 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 594  </span>
<span class="s0">107 0 0 6 117 590 0 0 0 2 4 this 3 590  4 copy 1 594  </span>
<span class="s0">108 0 0 4 119 577 0 0 50 /**</span>
 <span class="s0">* Adds a new AsyncTask to the collection.</span>
 <span class="s0">*/ 2 4 this 3 590  4 task 1 585  </span>
<span class="s0">109 0 0 6 120 531 0 0 153 /**</span>
 <span class="s0">* Removes the indicated AsyncTask from the collection.  Returns true if the</span>
 <span class="s0">* task was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/ 2 4 this 3 590  4 task 1 585  </span>
<span class="s0">110 0 0 4 120 577 0 0 57 /**</span>
 <span class="s0">* Removes the nth AsyncTask from the collection.</span>
 <span class="s0">*/ 2 4 this 3 590  5 index 1 596  </span>
<span class="s0">111 0 0 4 121 577 0 0 204 /**</span>
 <span class="s0">* Adds all the AsyncTasks indicated in the other collection to this task.</span>
 <span class="s0">* The other tasks are simply appended to the end of the tasks in this list;</span>
 <span class="s0">* duplicates are not automatically removed.</span>
 <span class="s0">*/ 2 4 this 3 590  5 other 1 594  </span>
<span class="s0">112 0 0 4 122 577 0 0 96 /**</span>
 <span class="s0">* Removes from this collection all of the AsyncTasks listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/ 2 4 this 3 590  5 other 1 594  </span>
<span class="s0">113 0 0 4 123 577 0 0 198 /**</span>
 <span class="s0">* Removes any duplicate entries of the same AsyncTasks on this collection.</span>
 <span class="s0">* If a AsyncTask appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/ 1 4 this 3 590  </span>
<span class="s0">114 0 0 6 124 531 0 0 98 /**</span>
 <span class="s0">* Returns true if the indicated AsyncTask appears in this collection, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 594  4 task 1 585  </span>
<span class="s0">115 0 0 4 125 577 0 0 54 /**</span>
 <span class="s0">* Removes all AsyncTasks from the collection.</span>
 <span class="s0">*/ 1 4 this 3 590  </span>
<span class="s0">116 0 0 7 126 585 287 0 115 /**</span>
 <span class="s0">* Returns the task in the collection with the indicated name, if any, or NULL</span>
 <span class="s0">* if no task has that name.</span>
 <span class="s0">*/ 2 4 this 3 594  4 name 1 572  </span>
<span class="s0">117 0 0 6 127 596 0 0 62 /**</span>
 <span class="s0">* Returns the number of AsyncTasks in the collection.</span>
 <span class="s0">*/ 1 4 this 3 594  </span>
<span class="s0">118 0 0 7 128 585 287 0 55 /**</span>
 <span class="s0">* Returns the nth AsyncTask in the collection.</span>
 <span class="s0">*/ 2 4 this 3 594  5 index 1 596  </span>
<span class="s0">119 0 0 7 130 585 287 0 141 /**</span>
 <span class="s0">* Returns the nth AsyncTask in the collection.  This is the same as</span>
 <span class="s0">* get_task(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/ 2 4 this 3 594  5 index 1 596  </span>
<span class="s0">120 0 0 6 131 596 0 0 104 /**</span>
 <span class="s0">* Returns the number of tasks in the collection.  This is the same thing as</span>
 <span class="s0">* get_num_tasks().</span>
 <span class="s0">*/ 1 4 this 3 594  </span>
<span class="s0">121 0 0 6 132 590 0 0 0 2 4 this 3 590  5 other 1 594  </span>
<span class="s0">122 0 0 7 133 590 346 0 0 2 4 this 3 594  5 other 1 594  </span>
<span class="s0">123 0 0 4 134 577 0 0 108 /**</span>
 <span class="s0">* Writes a brief one-line description of the AsyncTaskCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 594  3 out 1 575  </span>
<span class="s0">124 0 0 4 135 577 0 0 113 /**</span>
 <span class="s0">* Writes a complete multi-line description of the AsyncTaskCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 3 4 this 3 594  3 out 1 575  12 indent_level 5 541  </span>
<span class="s0">125 0 0 4 169 577 0 0 155 /**</span>
 <span class="s0">* Sets the tick_clock flag.  When this is true, get_clock()-&gt;tick() will be</span>
 <span class="s0">* called automatically at each task epoch.  This is false by default.</span>
 <span class="s0">*/ 2 4 this 3 589  10 tick_clock 1 531  </span>
<span class="s0">126 0 0 6 170 531 0 0 62 /**</span>
 <span class="s0">* Returns the tick_clock flag.  See set_tick_clock().</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">127 0 0 4 171 577 0 0 132 /**</span>
 <span class="s0">* Changes the number of threads for this task chain.  This may require</span>
 <span class="s0">* stopping the threads if they are already running.</span>
 <span class="s0">*/ 2 4 this 3 589  11 num_threads 1 541  </span>
<span class="s0">128 0 0 6 172 541 0 0 124 /**</span>
 <span class="s0">* Returns the number of threads that will be servicing tasks for this chain.</span>
 <span class="s0">* Also see get_num_running_threads().</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">129 0 0 6 173 541 0 0 211 /**</span>
 <span class="s0">* Returns the number of threads that have been created and are actively</span>
 <span class="s0">* running.  This will return 0 before the threads have been started; it will</span>
 <span class="s0">* also return 0 if thread support is not available.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">130 0 0 4 174 577 0 0 153 /**</span>
 <span class="s0">* Changes the priority associated with threads that serve this task chain.</span>
 <span class="s0">* This may require stopping the threads if they are already running.</span>
 <span class="s0">*/ 2 4 this 3 589  8 priority 1 600  </span>
<span class="s0">131 0 0 6 175 600 0 0 83 /**</span>
 <span class="s0">* Returns the priority associated with threads that serve this task chain.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">132 0 0 4 176 577 0 0 414 /**</span>
 <span class="s0">* Sets the maximum amount of time per frame the tasks on this chain are</span>
 <span class="s0">* granted for execution.  If this is less than zero, there is no limit; if it</span>
 <span class="s0">* is &gt;= 0, it represents a maximum amount of time (in seconds) that will be</span>
 <span class="s0">* used to execute tasks.  If this time is exceeded in any one frame, the task</span>
 <span class="s0">* chain will stop executing tasks until the next frame, as defined by the</span>
 <span class="s0">* TaskManager's clock.</span>
 <span class="s0">*/ 2 4 this 3 589  12 frame_budget 1 537  </span>
<span class="s0">133 0 0 6 177 537 0 0 134 /**</span>
 <span class="s0">* Returns the maximum amount of time per frame the tasks on this chain are</span>
 <span class="s0">* granted for execution.  See set_frame_budget().</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">134 0 0 4 178 577 0 0 638 /**</span>
 <span class="s0">* Sets the frame_sync flag.  When this flag is true, this task chain will be</span>
 <span class="s0">* forced to sync with the TaskManager's clock.  It will run no faster than</span>
 <span class="s0">* one epoch per clock frame.</span>
 <span class="s0">*</span>
 <span class="s0">* When this flag is false, the default, the task chain will finish all of its</span>
 <span class="s0">* tasks and then immediately start from the first task again, regardless of</span>
 <span class="s0">* the clock frame.  When it is true, the task chain will finish all of its</span>
 <span class="s0">* tasks and then wait for the clock to tick to the next frame before resuming</span>
 <span class="s0">* the first task.</span>
 <span class="s0">*</span>
 <span class="s0">* This only makes sense for threaded task chains.  Non-threaded task chains</span>
 <span class="s0">* are automatically synchronous.</span>
 <span class="s0">*/ 2 4 this 3 589  10 frame_sync 1 531  </span>
<span class="s0">135 0 0 6 179 531 0 0 62 /**</span>
 <span class="s0">* Returns the frame_sync flag.  See set_frame_sync().</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">136 0 0 4 180 577 0 0 903 /**</span>
 <span class="s0">* Sets the timeslice_priority flag.  This changes the interpretation of</span>
 <span class="s0">* priority, and the number of times per epoch each task will run.</span>
 <span class="s0">*</span>
 <span class="s0">* When this flag is true, some tasks might not run in any given epoch.</span>
 <span class="s0">* Instead, tasks with priority higher than 1 will be given precedence, in</span>
 <span class="s0">* proportion to the amount of time they have already used.  This gives</span>
 <span class="s0">* higher-priority tasks more runtime than lower-priority tasks.  Each task</span>
 <span class="s0">* gets the amount of time proportional to its priority value, so a task with</span>
 <span class="s0">* priority 100 will get five times as much processing time as a task with</span>
 <span class="s0">* priority 20.  For these purposes, priority values less than 1 are deemed to</span>
 <span class="s0">* be equal to 1.</span>
 <span class="s0">*</span>
 <span class="s0">* When this flag is false (the default), all tasks are run exactly once each</span>
 <span class="s0">* epoch, round-robin style.  Priority is only used to determine which task</span>
 <span class="s0">* runs first within tasks of the same sort value.</span>
 <span class="s0">*/ 2 4 this 3 589  18 timeslice_priority 1 531  </span>
<span class="s0">137 0 0 6 181 531 0 0 184 /**</span>
 <span class="s0">* Returns the timeslice_priority flag.  This changes the interpretation of</span>
 <span class="s0">* priority, and the number of times per epoch each task will run.  See</span>
 <span class="s0">* set_timeslice_priority().</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">138 0 0 4 182 577 0 0 215 /**</span>
 <span class="s0">* Stops any threads that are currently running.  If any tasks are still</span>
 <span class="s0">* pending and have not yet been picked up by a thread, they will not be</span>
 <span class="s0">* serviced unless poll() or start_threads() is later called.</span>
 <span class="s0">*/ 1 4 this 3 589  </span>
<span class="s0">139 0 0 4 183 577 0 0 171 /**</span>
 <span class="s0">* Starts any requested threads to service the tasks on the queue.  This is</span>
 <span class="s0">* normally not necessary, since adding a task will start the threads</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*/ 1 4 this 3 589  </span>
<span class="s0">140 0 0 6 184 531 0 0 212 /**</span>
 <span class="s0">* Returns true if the thread(s) have been started and are ready to service</span>
 <span class="s0">* requests, false otherwise.  If this is false, the next call to add() or</span>
 <span class="s0">* add_and_do() will automatically start the threads.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">141 0 0 6 185 531 0 0 104 /**</span>
 <span class="s0">* Returns true if the indicated task has been added to this AsyncTaskChain,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 598  4 task 1 585  </span>
<span class="s0">142 0 0 4 186 577 0 0 47 /**</span>
 <span class="s0">* Blocks until the task list is empty.</span>
 <span class="s0">*/ 1 4 this 3 589  </span>
<span class="s0">143 0 0 6 187 541 0 0 102 /**</span>
 <span class="s0">* Returns the number of tasks that are currently active or sleeping within</span>
 <span class="s0">* the task chain.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">144 0 0 7 188 590 346 0 110 /**</span>
 <span class="s0">* Returns the set of tasks that are active or sleeping on the task chain, at</span>
 <span class="s0">* the time of the call.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">145 0 0 7 189 590 346 0 117 /**</span>
 <span class="s0">* Returns the set of tasks that are active (and not sleeping) on the task</span>
 <span class="s0">* chain, at the time of the call.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">146 0 0 7 190 590 346 0 117 /**</span>
 <span class="s0">* Returns the set of tasks that are sleeping (and not active) on the task</span>
 <span class="s0">* chain, at the time of the call.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">147 0 0 4 191 577 0 0 381 /**</span>
 <span class="s0">* Runs through all the tasks in the task list, once, if the task chain is</span>
 <span class="s0">* running in single-threaded mode (no threads available).  This method does</span>
 <span class="s0">* nothing in threaded mode, so it may safely be called in either case.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, you would not call this function directly; instead, call</span>
 <span class="s0">* AsyncTaskManager::poll(), which polls all of the task chains in sequence.</span>
 <span class="s0">*/ 1 4 this 3 589  </span>
<span class="s0">148 0 0 6 192 537 0 0 169 /**</span>
 <span class="s0">* Returns the scheduled time (on the manager's clock) of the next sleeping</span>
 <span class="s0">* task, on any task chain, to awaken.  Returns -1 if there are no sleeping</span>
 <span class="s0">* tasks.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">149 0 0 4 193 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 598  3 out 1 575  </span>
<span class="s0">150 0 0 4 194 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 598  3 out 1 575  12 indent_level 5 541  </span>
<span class="s0">151 0 0 7 195 582 0 0 0 0 </span>
<span class="s0">152 0 0 7 164 573 0 0 0 1 4 this 3 589  </span>
<span class="s0">153 0 0 6 166 586 0 0 0 1 4 this 3 589  </span>
<span class="s0">154 0 0 15 197 603 410 0 0 1 6 param0 0 601  </span>
<span class="s0">155 0 0 23 197 603 410 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 delay 1 537  </span>
<span class="s0">156 0 0 4 198 577 0 0 0 2 4 this 3 603  4 size 1 596  </span>
<span class="s0">157 0 0 7 201 582 0 0 0 0 </span>
<span class="s0">158 0 0 15 208 606 416 0 0 1 6 param0 0 604  </span>
<span class="s0">159 0 0 7 208 606 416 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 572  </span>
<span class="s0">160 0 0 4 210 577 0 0 0 2 4 this 3 606  4 size 1 596  </span>
<span class="s0">161 0 0 4 213 577 0 0 251 /**</span>
 <span class="s0">* Sets the repeat count of the sequence.  If the count is 0 or 1, the</span>
 <span class="s0">* sequence will run exactly once.  If it is greater than 0, it will run that</span>
 <span class="s0">* number of times.  If it is negative, it will run forever until it is</span>
 <span class="s0">* explicitly removed.</span>
 <span class="s0">*/ 2 4 this 3 606  12 repeat_count 1 541  </span>
<span class="s0">162 0 0 6 214 541 0 0 77 /**</span>
 <span class="s0">* Returns the repeat count of the sequence.  See set_repeat_count().</span>
 <span class="s0">*/ 1 4 this 3 604  </span>
<span class="s0">163 0 0 6 215 596 0 0 142 /**</span>
 <span class="s0">* Returns the index of the task within the sequence that is currently being</span>
 <span class="s0">* executed (or that will be executed at the next epoch).</span>
 <span class="s0">*/ 1 4 this 3 604  </span>
<span class="s0">164 0 0 7 216 582 0 0 0 0 </span>
<span class="s0">165 0 0 7 204 585 287 0 0 1 4 this 3 606  </span>
<span class="s0">166 0 0 6 206 590 0 0 0 1 4 this 3 606  </span>
<span class="s0">167 0 0 6 219 531 0 0 0 2 4 this 3 607  5 other 1 607  </span>
<span class="s0">168 0 0 6 220 531 0 0 0 2 4 this 3 607  5 other 1 607  </span>
<span class="s0">169 0 0 6 221 531 0 0 0 2 4 this 3 607  5 other 1 607  </span>
<span class="s0">170 0 0 7 234 608 442 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">171 0 0 15 234 608 442 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 609  </span>
<span class="s0">172 0 0 7 235 608 442 0 0 2 4 this 3 608  4 copy 1 609  </span>
<span class="s0">173 0 0 4 236 577 0 0 51 /**</span>
 <span class="s0">* Adds a new event to the end of the list.</span>
 <span class="s0">*/ 2 4 this 3 608  5 event 1 611  </span>
<span class="s0">174 0 0 6 237 541 0 0 52 /**</span>
 <span class="s0">* Returns the number of events in the list.</span>
 <span class="s0">*/ 1 4 this 3 609  </span>
<span class="s0">175 0 0 6 238 607 0 0 169 /**</span>
 <span class="s0">* Returns the nth event in the list.  This does not remove the event from the</span>
 <span class="s0">* list; the only way to remove events is to empty the whole list with</span>
 <span class="s0">* clear().</span>
 <span class="s0">*/ 2 4 this 3 609  1 n 1 541  </span>
<span class="s0">176 0 0 4 239 577 0 0 48 /**</span>
 <span class="s0">* Empties all the events from the list.</span>
 <span class="s0">*/ 1 4 this 3 608  </span>
<span class="s0">177 0 0 4 240 577 0 0 75 /**</span>
 <span class="s0">* Appends the events from the other list onto the end of this one.</span>
 <span class="s0">*/ 2 4 this 3 608  5 other 1 609  </span>
<span class="s0">178 0 0 4 241 577 0 0 124 /**</span>
 <span class="s0">* Updates the indicated ModifierButtons object with all of the button up/down</span>
 <span class="s0">* transitions indicated in the list.</span>
 <span class="s0">*/ 2 4 this 3 609  4 mods 1 612  </span>
<span class="s0">179 0 0 4 242 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 609  3 out 1 575  12 indent_level 5 541  </span>
<span class="s0">180 0 0 7 245 582 0 0 0 0 </span>
<span class="s0">181 0 0 15 248 616 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 614  </span>
<span class="s0">182 0 0 23 248 616 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 10 event_name 1 572  8 receiver 5 552  </span>
<span class="s0">183 0 0 7 249 616 0 0 0 2 4 this 3 616  4 copy 1 614  </span>
<span class="s0">184 0 0 4 250 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 616  4 name 1 572  </span>
<span class="s0">185 0 0 4 251 577 0 0 44 /**</span>
 <span class="s0">* Resets the Event's name to empty.</span>
 <span class="s0">*/ 1 4 this 3 616  </span>
<span class="s0">186 0 0 6 252 531 0 0 92 /**</span>
 <span class="s0">* Returns true if the Event has a nonempty name set, false if the name is</span>
 <span class="s0">* empty.</span>
 <span class="s0">*/ 1 4 this 3 614  </span>
<span class="s0">187 0 0 6 253 572 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 614  </span>
<span class="s0">188 0 0 4 254 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 616  3 obj 1 563  </span>
<span class="s0">189 0 0 6 255 541 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 614  </span>
<span class="s0">190 0 0 7 256 562 254 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 614  1 n 1 541  </span>
<span class="s0">191 0 0 6 258 531 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 614  </span>
<span class="s0">192 0 0 6 259 552 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 614  </span>
<span class="s0">193 0 0 4 260 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 616  8 receiver 1 552  </span>
<span class="s0">194 0 0 4 261 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 616  </span>
<span class="s0">195 0 0 4 262 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 614  3 out 1 575  </span>
<span class="s0">196 0 0 7 268 582 0 0 0 0 </span>
<span class="s0">197 0 0 7 271 618 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 8 ev_queue 1 617  </span>
<span class="s0">198 0 0 7 272 578 0 0 96 /**</span>
 <span class="s0">* Returns a pending future that will be marked as done when the event is next</span>
 <span class="s0">* fired.</span>
 <span class="s0">*/ 2 4 this 3 618  10 event_name 1 572  </span>
<span class="s0">199 0 0 4 273 577 0 0 188 /**</span>
 <span class="s0">* The main processing loop of the EventHandler.  This function must be called</span>
 <span class="s0">* periodically to service events.  Walks through each pending event and calls</span>
 <span class="s0">* its assigned hooks.</span>
 <span class="s0">*/ 1 4 this 3 618  </span>
<span class="s0">200 0 0 4 274 577 0 0 66 /**</span>
 <span class="s0">* Calls the hooks assigned to the indicated single event.</span>
 <span class="s0">*/ 2 4 this 3 618  5 event 1 614  </span>
<span class="s0">201 0 0 4 275 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 619  3 out 1 575  </span>
<span class="s0">202 0 0 6 276 618 0 0 139 /**</span>
 <span class="s0">* Returns a pointer to the one global EventHandler object.  If the global</span>
 <span class="s0">* object has not yet been created, this will create it.</span>
 <span class="s0">*/ 1 5 queue 5 617  </span>
<span class="s0">203 0 0 7 277 582 0 0 0 0 </span>
<span class="s0">204 0 0 7 279 617 466 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">205 0 0 4 281 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 617  5 event 1 614  </span>
<span class="s0">206 0 0 4 282 577 0 0 71 /**</span>
 <span class="s0">* Empties all events on the queue, throwing them on the floor.</span>
 <span class="s0">*/ 1 4 this 3 617  </span>
<span class="s0">207 0 0 6 283 531 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 621  </span>
<span class="s0">208 0 0 6 284 531 0 0 73 /**</span>
 <span class="s0">* @deprecated Always returns false; the queue can never be full.</span>
 <span class="s0">*/ 1 4 this 3 621  </span>
<span class="s0">209 0 0 7 285 614 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 617  </span>
<span class="s0">210 0 0 6 286 617 0 0 137 /**</span>
 <span class="s0">* Returns a pointer to the one global EventQueue object.  If the global</span>
 <span class="s0">* object has not yet been created, this will create it.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">211 0 0 7 288 623 492 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">212 0 0 6 289 596 0 0 52 /**</span>
 <span class="s0">* Returns the number of events in the list.</span>
 <span class="s0">*/ 1 4 this 3 624  </span>
<span class="s0">213 0 0 6 290 531 0 0 51 /**</span>
 <span class="s0">* Get the in-window flag of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">214 0 0 6 291 541 0 0 49 /**</span>
 <span class="s0">* Get the x-coordinate of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">215 0 0 6 292 541 0 0 49 /**</span>
 <span class="s0">* Get the y-coordinate of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">216 0 0 6 293 537 0 0 44 /**</span>
 <span class="s0">* Get the x-delta of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">217 0 0 6 294 537 0 0 44 /**</span>
 <span class="s0">* Get the y-delta of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">218 0 0 6 295 541 0 0 52 /**</span>
 <span class="s0">* Get the sequence number of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">219 0 0 6 296 537 0 0 43 /**</span>
 <span class="s0">* Get the length of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">220 0 0 6 297 537 0 0 46 /**</span>
 <span class="s0">* Get the direction of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">221 0 0 6 298 537 0 0 45 /**</span>
 <span class="s0">* Get the rotation of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">222 0 0 6 299 537 0 0 46 /**</span>
 <span class="s0">* Get the timestamp of the nth event.</span>
 <span class="s0">*/ 2 4 this 3 624  1 n 1 596  </span>
<span class="s0">223 0 0 4 300 577 0 0 48 /**</span>
 <span class="s0">* Empties all the events from the list.</span>
 <span class="s0">*/ 1 4 this 3 623  </span>
<span class="s0">224 0 0 4 301 577 0 0 48 /**</span>
 <span class="s0">* Discards the first event on the list.</span>
 <span class="s0">*/ 1 4 this 3 623  </span>
<span class="s0">225 0 0 4 302 577 0 0 62 /**</span>
 <span class="s0">* Adds a new event from the given PointerData object.</span>
 <span class="s0">*/ 4 4 this 3 623  4 data 1 626  3 seq 1 541  4 time 1 537  </span>
<span class="s0">226 0 0 4 302 577 0 0 85 /**</span>
 <span class="s0">* Adds a new event to the end of the list based on the given mouse movement.</span>
 <span class="s0">*/ 8 4 this 3 623  6 in_win 1 531  4 xpos 1 541  4 ypos 1 541  6 xdelta 1 537  6 ydelta 1 537  3 seq 1 541  4 time 1 537  </span>
<span class="s0">227 0 0 4 302 577 0 0 153 /**</span>
 <span class="s0">* Adds a new event to the end of the list.  Automatically calculates the dx,</span>
 <span class="s0">* dy, length, direction, and rotation for all but the first event.</span>
 <span class="s0">*/ 6 4 this 3 623  6 in_win 1 531  4 xpos 1 541  4 ypos 1 541  3 seq 1 541  4 time 1 537  </span>
<span class="s0">228 0 0 6 303 531 0 0 70 /**</span>
 <span class="s0">* Returns true if the trail loops around the specified point.</span>
 <span class="s0">*/ 3 4 this 3 624  1 x 1 541  1 y 1 541  </span>
<span class="s0">229 0 0 6 304 537 0 0 279 /**</span>
 <span class="s0">* returns the total angular deviation that the trail has made in the</span>
 <span class="s0">* specified time period.  A small number means that the trail is moving in a</span>
 <span class="s0">* relatively straight line, a large number means that the trail is zig-</span>
 <span class="s0">* zagging or spinning.  The result is in degrees.</span>
 <span class="s0">*/ 2 4 this 3 624  3 sec 1 537  </span>
<span class="s0">230 0 0 6 305 537 0 0 540 /**</span>
 <span class="s0">* This function is not implemented yet.  It is a work in progress.  The</span>
 <span class="s0">* intent is as follows:</span>
 <span class="s0">*</span>
 <span class="s0">* Returns a nonzero value if the mouse movements match the specified pattern.</span>
 <span class="s0">* The higher the value, the better the match.  The pattern is a sequence of</span>
 <span class="s0">* compass directions (ie, &quot;E&quot;, &quot;NE&quot;, etc) separated by spaces.  If rot is</span>
 <span class="s0">* nonzero, then the pattern is rotated counterclockwise by the specified</span>
 <span class="s0">* amount before testing.  Seglen is the minimum length a mouse movement needs</span>
 <span class="s0">* to be in order to be considered significant.</span>
 <span class="s0">*/ 4 4 this 3 623  7 pattern 1 572  3 rot 1 537  6 seglen 1 537  </span>
<span class="s0">231 0 0 7 306 582 0 0 0 0 </span>
<span class="s0">232 0 0 23 309 629 287 0 0 2 8 function 5 559  4 name 5 572  </span>
<span class="s0">233 0 0 15 309 629 287 0 0 1 6 param0 0 630  </span>
<span class="s0">234 0 0 4 310 577 0 0 0 2 4 this 3 629  4 size 1 596  </span>
<span class="s0">235 0 0 4 313 577 0 0 0 2 4 this 3 629  8 function 1 559  </span>
<span class="s0">236 0 0 6 314 559 0 0 66 /**</span>
 <span class="s0">* Returns the function that is called when the task runs.</span>
 <span class="s0">*/ 1 4 this 3 629  </span>
<span class="s0">237 0 0 4 315 577 0 0 0 3 4 this 3 629  4 args 1 559  11 append_task 1 531  </span>
<span class="s0">238 0 0 6 316 559 0 0 0 1 4 this 3 629  </span>
<span class="s0">239 0 0 4 317 577 0 0 0 2 4 this 3 629  10 upon_death 1 559  </span>
<span class="s0">240 0 0 6 318 559 0 0 70 /**</span>
 <span class="s0">* Returns the function that is called when the task finishes.</span>
 <span class="s0">*/ 1 4 this 3 629  </span>
<span class="s0">241 0 0 4 319 577 0 0 0 2 4 this 3 629  5 owner 1 559  </span>
<span class="s0">242 0 0 6 320 559 0 0 56 /**</span>
 <span class="s0">* Returns the &quot;owner&quot; object.  See set_owner().</span>
 <span class="s0">*/ 1 4 this 3 630  </span>
<span class="s0">243 0 0 4 321 577 0 0 172 /**</span>
 <span class="s0">* Sets the &quot;result&quot; of this task.  This is the value returned from an &quot;await&quot;</span>
 <span class="s0">* expression on this task.</span>
 <span class="s0">* This can only be called while the task is still alive.</span>
 <span class="s0">*/ 2 4 this 3 629  6 result 1 559  </span>
<span class="s0">244 0 0 6 322 541 0 0 0 3 4 this 3 629  4 attr 1 559  1 v 1 559  </span>
<span class="s0">245 0 0 6 323 541 0 0 0 2 4 this 3 629  4 attr 1 559  </span>
<span class="s0">246 0 0 6 324 559 0 0 0 2 4 this 3 630  4 attr 1 559  </span>
<span class="s0">247 0 0 6 325 541 0 0 0 3 4 this 3 629  5 visit 1 632  3 arg 1 633  </span>
<span class="s0">248 0 0 6 326 541 0 0 0 1 4 this 3 629  </span>
<span class="s0">249 0 0 7 346 582 0 0 0 0 </span>
<span class="s0">250 0 0 6 334 531 0 0 101 /**</span>
 <span class="s0">* Returns true if a delay has been set for this task via set_delay(), or</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 630  </span>
<span class="s0">251 0 0 4 336 577 0 0 216 /**</span>
 <span class="s0">* Removes any delay specified for the task.  The next time the task is added</span>
 <span class="s0">* to the queue, it will run immediately.  This does not affect the task's</span>
 <span class="s0">* wake time if it has already been added to the queue.</span>
 <span class="s0">*/ 1 4 this 3 629  </span>
<span class="s0">113</span>
<span class="s0">521 14 EventParameter 0 26625 14 EventParameter 14 EventParameter 0 0 0 1 252 254 0 14 253 255 256 257 258 259 260 261 262 263 264 265 266 267 0 0 0 0 0 389</span>
<span class="s0">/**</span>
 <span class="s0">* An optional parameter associated with an event.  Each event may have zero</span>
 <span class="s0">* or more of these.  Each parameter stores a pointer to a</span>
 <span class="s0">* TypedWritableReferenceCount object, which of course could be pretty much</span>
 <span class="s0">* anything.  To store a simple value like a double or a string, the</span>
 <span class="s0">* EventParameter constructors transparently use the ParamValue template class</span>
 <span class="s0">* from paramValue.h.</span>
 <span class="s0">*/</span>

<span class="s0">522 11 AsyncFuture 0 75777 11 AsyncFuture 11 AsyncFuture 0 0 0 1 268 0 1 634 14 269 270 271 272 273 274 275 276 277 278 279 280 281 282 0 0 1 0 523 0 0 0 0 1711</span>
<span class="s0">/**</span>
 <span class="s0">* This class represents a thread-safe handle to a promised future result of</span>
 <span class="s0">* an asynchronous operation, providing methods to query its status and result</span>
 <span class="s0">* as well as register callbacks for this future's completion.</span>
 <span class="s0">*</span>
 <span class="s0">* An AsyncFuture can be awaited from within a coroutine or task.  It keeps</span>
 <span class="s0">* track of tasks waiting for this future and automatically reactivates them</span>
 <span class="s0">* upon this future's completion.</span>
 <span class="s0">*</span>
 <span class="s0">* A task itself is also a subclass of AsyncFuture.  Other subclasses are</span>
 <span class="s0">* not generally necessary, except to override the function of `cancel()`.</span>
 <span class="s0">*</span>
 <span class="s0">* Until the future is done, it is &quot;owned&quot; by the resolver thread, though it's</span>
 <span class="s0">* still legal for other threads to query its state.  When the resolver thread</span>
 <span class="s0">* resolves this future using `set_result()`, or any thread calls `cancel()`,</span>
 <span class="s0">* it instantly enters the &quot;done&quot; state, after which the result becomes a</span>
 <span class="s0">* read-only field that all threads can access.</span>
 <span class="s0">*</span>
 <span class="s0">* When the future returns true for done(), a thread can use cancelled() to</span>
 <span class="s0">* determine whether the future was cancelled or get_result() to access the</span>
 <span class="s0">* result of the operation.  Not all operations define a meaningful result</span>
 <span class="s0">* value, so some will always return nullptr.</span>
 <span class="s0">*</span>
 <span class="s0">* In Python, the `cancelled()`, `wait()` and `get_result()` methods are</span>
 <span class="s0">* wrapped up into a single `result()` method which waits for the future to</span>
 <span class="s0">* complete before either returning the result or throwing an exception if the</span>
 <span class="s0">* future was cancelled.</span>
 <span class="s0">* However, it is preferable to use the `await` keyword when running from a</span>
 <span class="s0">* coroutine, which only suspends the current task and not the entire thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This API aims to mirror and be compatible with Python's Future class.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">523 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">524 12 string const 0 8832 17 std::string const 17 std::string const 0 0 525 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">525 6 string 0 2105344 11 std::string 11 std::string 0 0 526 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">526 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">527 9 AsyncTask 0 26625 9 AsyncTask 9 AsyncTask 0 0 0 1 372 287 12 635 636 637 643 644 645 646 647 648 649 650 651 30 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 371 0 0 2 3 522 283 284 3 528 285 286 0 2 529 530 217</span>
<span class="s0">/**</span>
 <span class="s0">* This class represents a concrete task performed by an AsyncManager.</span>
 <span class="s0">* Normally, you would subclass from this class, and override do_task(), to</span>
 <span class="s0">* define the functionality you wish to have the task perform.</span>
 <span class="s0">*/</span>

<span class="s0">528 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">529 10 DoneStatus 0 794624 21 AsyncTask::DoneStatus 21 AsyncTask::DoneStatus 527 0 0 0 0 0 0 0 0 0 8 7 DS_done 18 AsyncTask::DS_done 25</span>
<span class="s0">// normal task completion</span>
<span class="s0">0 7 DS_cont 18 AsyncTask::DS_cont 28</span>
<span class="s0">// run task again next epoch</span>
<span class="s0">1 8 DS_again 19 AsyncTask::DS_again 41</span>
<span class="s0">// start the task over from the beginning</span>
<span class="s0">2 9 DS_pickup 20 AsyncTask::DS_pickup 52</span>
<span class="s0">// run task again this frame, if frame budget allows</span>
<span class="s0">3 7 DS_exit 18 AsyncTask::DS_exit 30</span>
<span class="s0">// stop the enclosing sequence</span>
<span class="s0">4 8 DS_pause 19 AsyncTask::DS_pause 46</span>
<span class="s0">// pause, then exit (useful within a sequence)</span>
<span class="s0">5 12 DS_interrupt 23 AsyncTask::DS_interrupt 49</span>
<span class="s0">// interrupt the task manager, but run task again</span>
<span class="s0">6 8 DS_await 19 AsyncTask::DS_await 38</span>
<span class="s0">// await a different task's completion</span>
<span class="s0">7 0 0</span>

<span class="s0">530 5 State 0 794624 16 AsyncTask::State 16 AsyncTask::State 527 0 0 0 0 0 0 0 0 0 7 10 S_inactive 21 AsyncTask::S_inactive 0</span>
<span class="s0">0 8 S_active 19 AsyncTask::S_active 0</span>
<span class="s0">1 11 S_servicing 22 AsyncTask::S_servicing 0</span>
<span class="s0">2 19 S_servicing_removed 30 AsyncTask::S_servicing_removed 51</span>
<span class="s0">// Still servicing, but wants removal from manager.</span>
<span class="s0">3 10 S_sleeping 21 AsyncTask::S_sleeping 0</span>
<span class="s0">4 15 S_active_nested 26 AsyncTask::S_active_nested 28</span>
<span class="s0">// active within a sequence.</span>
<span class="s0">5 10 S_awaiting 21 AsyncTask::S_awaiting 43</span>
<span class="s0">// Waiting for a dependent task to complete</span>
<span class="s0">6 0 0</span>

<span class="s0">531 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">532 18 AsyncTaskManager * 0 8576 18 AsyncTaskManager * 18 AsyncTaskManager * 0 0 533 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">533 16 AsyncTaskManager 0 26625 16 AsyncTaskManager 16 AsyncTaskManager 0 0 0 1 321 322 5 638 639 640 641 642 27 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 363 364 365 366 367 368 1 667 0 2 3 523 317 318 3 528 319 320 0 0 674</span>
<span class="s0">/**</span>
 <span class="s0">* A class to manage a loose queue of isolated tasks, which can be performed</span>
 <span class="s0">* either synchronously (in the foreground thread) or asynchronously (by a</span>
 <span class="s0">* background thread).</span>
 <span class="s0">*</span>
 <span class="s0">* The AsyncTaskManager is actually a collection of AsyncTaskChains, each of</span>
 <span class="s0">* which maintains a list of tasks.  Each chain can be either foreground or</span>
 <span class="s0">* background (it may run only in the main thread, or it may be serviced by</span>
 <span class="s0">* one or more background threads). See AsyncTaskChain for more information.</span>
 <span class="s0">*</span>
 <span class="s0">* If you do not require background processing, it is perfectly acceptable to</span>
 <span class="s0">* create only one AsyncTaskChain, which runs in the main thread.  This is a</span>
 <span class="s0">* common configuration.</span>
 <span class="s0">*/</span>

<span class="s0">534 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 535 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">535 11 ClockObject 0 2048 11 ClockObject 11 ClockObject 0 0 0 0 0 0 0 0 0 0 0 0 1000</span>
<span class="s0">/**</span>
 <span class="s0">* A ClockObject keeps track of elapsed real time and discrete time.  In</span>
 <span class="s0">* normal mode, get_frame_time() returns the time as of the last time tick()</span>
 <span class="s0">* was called.  This is the &quot;discrete&quot; time, and is usually used to get the</span>
 <span class="s0">* time as of, for instance, the beginning of the current frame.</span>
 <span class="s0">*</span>
 <span class="s0">* In other modes, as set by set_mode() or the clock-mode config variable,</span>
 <span class="s0">* get_frame_time() may return other values to simulate different timing</span>
 <span class="s0">* effects, for instance to perform non-real-time animation.  See set_mode().</span>
 <span class="s0">*</span>
 <span class="s0">* In all modes, get_real_time() always returns the elapsed real time in</span>
 <span class="s0">* seconds since the ClockObject was constructed, or since it was last reset.</span>
 <span class="s0">*</span>
 <span class="s0">* You can create your own ClockObject whenever you want to have your own</span>
 <span class="s0">* local timer.  There is also a default, global ClockObject intended to</span>
 <span class="s0">* represent global time for the application; this is normally set up to tick</span>
 <span class="s0">* every frame so that its get_frame_time() will return the time for the</span>
 <span class="s0">* current frame.</span>
 <span class="s0">*/</span>

<span class="s0">536 19 AsyncTaskCollection 0 26625 19 AsyncTaskCollection 19 AsyncTaskCollection 0 0 0 1 344 346 0 17 345 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 1 668 0 0 0 0 199</span>
<span class="s0">/**</span>
 <span class="s0">* A list of tasks, for instance as returned by some of the AsyncTaskManager</span>
 <span class="s0">* query functions.  This also serves to define an AsyncTaskSequence.</span>
 <span class="s0">*</span>
 <span class="s0">* TODO: None of this is thread-safe yet.</span>
 <span class="s0">*/</span>

<span class="s0">537 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">538 7 Integer 0 2367488 21 AtomicAdjust::Integer 21 AtomicAdjust::Integer 539 0 540 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">539 12 AtomicAdjust 0 1024 12 AtomicAdjust 12 AtomicAdjust 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">540 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">541 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">542 14 AsyncTaskChain 0 26625 14 AsyncTaskChain 14 AsyncTaskChain 0 0 0 0 377 0 27 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 0 0 2 3 523 373 374 3 528 375 376 0 0 1007</span>
<span class="s0">/**</span>
 <span class="s0">* The AsyncTaskChain is a subset of the AsyncTaskManager.  Each chain</span>
 <span class="s0">* maintains a separate list of tasks, and will execute them with its own set</span>
 <span class="s0">* of threads.  Each chain may thereby operate independently of the other</span>
 <span class="s0">* chains.</span>
 <span class="s0">*</span>
 <span class="s0">* The AsyncTaskChain will spawn a specified number of threads (possibly 0) to</span>
 <span class="s0">* serve the tasks.  If there are no threads, you must call poll() from time</span>
 <span class="s0">* to time to serve the tasks in the main thread.  Normally this is done by</span>
 <span class="s0">* calling AsyncTaskManager::poll().</span>
 <span class="s0">*</span>
 <span class="s0">* Each task will run exactly once each epoch.  Beyond that, the tasks' sort</span>
 <span class="s0">* and priority values control the order in which they are run: tasks are run</span>
 <span class="s0">* in increasing order by sort value, and within the same sort value, they are</span>
 <span class="s0">* run roughly in decreasing order by priority value, with some exceptions for</span>
 <span class="s0">* parallelism.  Tasks with different sort values are never run in parallel</span>
 <span class="s0">* together, but tasks with different priority values might be (if there is</span>
 <span class="s0">* more than one thread).</span>
 <span class="s0">*/</span>

<span class="s0">543 14 AsyncTaskPause 0 141313 14 AsyncTaskPause 14 AsyncTaskPause 0 0 0 1 405 410 0 4 406 407 408 409 0 0 1 0 527 0 0 0 0 184</span>
<span class="s0">/**</span>
 <span class="s0">* A special kind of task that simple returns DS_pause, to pause for a</span>
 <span class="s0">* specified number of seconds and then finish.  It's intended to be used</span>
 <span class="s0">* within an AsyncTaskSequence.</span>
 <span class="s0">*/</span>

<span class="s0">544 17 AsyncTaskSequence 0 26625 17 AsyncTaskSequence 17 AsyncTaskSequence 0 0 0 1 415 416 0 7 417 418 419 420 421 422 423 0 0 2 3 527 411 412 3 536 413 414 0 0 400</span>
<span class="s0">/**</span>
 <span class="s0">* A special kind of task that serves as a list of tasks internally.  Each</span>
 <span class="s0">* task on the list is executed in sequence, one per epoch.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to a Sequence interval, though it has some slightly</span>
 <span class="s0">* different abilities.  For instance, although you can't start at any</span>
 <span class="s0">* arbitrary point in the sequence, you can construct a task sequence whose</span>
 <span class="s0">* duration changes during playback.</span>
 <span class="s0">*/</span>

<span class="s0">545 11 ButtonEvent 0 141313 11 ButtonEvent 11 ButtonEvent 0 0 0 0 431 4 652 653 654 655 3 424 425 426 0 0 0 0 1 546 1081</span>
<span class="s0">/**</span>
 <span class="s0">* Records a button event of some kind.  This is either a keyboard or mouse</span>
 <span class="s0">* button (or some other kind of button) changing state from up to down, or</span>
 <span class="s0">* vice-versa, or it is a single &quot;keystroke&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* A keystroke is different than a button event in that (a) it does not</span>
 <span class="s0">* necessarily correspond to a physical button on a keyboard, but might be the</span>
 <span class="s0">* result of a combination of buttons (e.g.  &quot;A&quot; is the result of shift +</span>
 <span class="s0">* &quot;a&quot;); and (b) it does not manage separate &quot;up&quot; and &quot;down&quot; events, but is</span>
 <span class="s0">* itself an instantaneous event.</span>
 <span class="s0">*</span>
 <span class="s0">* Normal up/down button events can be used to track the state of a particular</span>
 <span class="s0">* button on the keyboard, while keystroke events are best used to monitor</span>
 <span class="s0">* what a user is attempting to type.</span>
 <span class="s0">*</span>
 <span class="s0">* Button up/down events are defined across all the physical keys on the</span>
 <span class="s0">* keyboard (and other buttons for which there is a corresponding ButtonHandle</span>
 <span class="s0">* object), while keystroke events are defined across the entire Unicode</span>
 <span class="s0">* character set.</span>
 <span class="s0">*</span>
 <span class="s0">* This API should not be considered stable and may change in a future version</span>
 <span class="s0">* of Panda3D.</span>
 <span class="s0">*/</span>

<span class="s0">546 4 Type 0 794624 17 ButtonEvent::Type 17 ButtonEvent::Type 545 0 0 0 0 0 0 0 0 0 9 6 T_down 19 ButtonEvent::T_down 49</span>
<span class="s0">// T_down is sent when a button was just pressed.</span>
<span class="s0">0 13 T_resume_down 26 ButtonEvent::T_resume_down 446</span>
<span class="s0">// T_resume_down is a special event that is only thrown when focus is</span>
<span class="s0">// returned to a window and a button is detected as being held down at that</span>
<span class="s0">// point; it indicates that the button should be considered down now (if it</span>
<span class="s0">// wasn't already), but it didn't just get pressed down at this moment, it</span>
<span class="s0">// was depressed some time ago.  It's mainly used for correct tracking of</span>
<span class="s0">// modifier keys like shift and control, and can be ignored for other keys.</span>
<span class="s0">1 4 T_up 17 ButtonEvent::T_up 44</span>
<span class="s0">// T_down is sent when a button is released.</span>
<span class="s0">2 8 T_repeat 21 ButtonEvent::T_repeat 196</span>
<span class="s0">// T_repeat is sent for each a keyrepeat event generated by the system,</span>
<span class="s0">// for a button that is continually held down.  If you want to respect</span>
<span class="s0">// keyrepeat, treat T_down and T_repeat equivalently.</span>
<span class="s0">3 11 T_keystroke 24 ButtonEvent::T_keystroke 115</span>
<span class="s0">// T_keystroke is a special keystroke event, and is sent along with a</span>
<span class="s0">// Unicode keycode value, not a ButtonHandle.</span>
<span class="s0">4 11 T_candidate 24 ButtonEvent::T_candidate 144</span>
<span class="s0">// T_candidate is used to indicate that the user is using the IME and has</span>
<span class="s0">// in the process of selecting some possible text to type from a menu.</span>
<span class="s0">5 6 T_move 19 ButtonEvent::T_move 143</span>
<span class="s0">// T_move is used to indicate that the mouse has moved within the current</span>
<span class="s0">// region.  Button drag mode needs this, others may ignore this event</span>
<span class="s0">6 10 T_raw_down 23 ButtonEvent::T_raw_down 241</span>
<span class="s0">// T_raw_down is usually sent together with T_down, except that this is</span>
<span class="s0">// the original, untransformed scan key sent by the keyboard.  It is not</span>
<span class="s0">// altered by modifier keys and acts as if the user is using the US</span>
<span class="s0">// (qwerty) keyboard layout.</span>
<span class="s0">7 8 T_raw_up 21 ButtonEvent::T_raw_up 0</span>
<span class="s0">8 0 0</span>

<span class="s0">547 12 ButtonHandle 0 16779264 12 ButtonHandle 12 ButtonHandle 0 0 0 0 0 0 0 0 0 0 0 0 162</span>
<span class="s0">/**</span>
 <span class="s0">* A ButtonHandle represents a single button from any device, including</span>
 <span class="s0">* keyboard buttons and mouse buttons (but see KeyboardButton and</span>
 <span class="s0">* MouseButton).</span>
 <span class="s0">*/</span>

<span class="s0">548 15 ButtonEventList 0 141313 15 ButtonEventList 15 ButtonEventList 0 0 0 1 432 442 1 656 9 433 434 435 436 437 438 439 440 441 0 0 1 0 549 0 0 0 0 225</span>
<span class="s0">/**</span>
 <span class="s0">* Records a set of button events that happened recently.  This class is</span>
 <span class="s0">* usually used only in the data graph, to transmit the recent button presses,</span>
 <span class="s0">* but it may be used anywhere a list of ButtonEvents is desired.</span>
 <span class="s0">*/</span>

<span class="s0">549 14 ParamValueBase 0 2048 14 ParamValueBase 14 ParamValueBase 0 0 0 0 0 0 0 0 0 0 0 0 141</span>
<span class="s0">/**</span>
 <span class="s0">* A non-template base class of ParamValue (below), which serves mainly to</span>
 <span class="s0">* define the placeholder for the virtual output function.</span>
 <span class="s0">*/</span>

<span class="s0">550 17 ButtonEvent const 0 8832 17 ButtonEvent const 17 ButtonEvent const 0 0 545 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">551 5 Event 0 75777 5 Event 5 Event 0 0 0 1 443 0 3 657 658 659 14 444 445 446 447 448 449 450 451 452 453 454 455 456 457 1 669 0 1 0 523 0 0 0 0 391</span>
<span class="s0">/**</span>
 <span class="s0">* A named event, possibly with parameters.  Anyone in any thread may throw an</span>
 <span class="s0">* event at any time; there will be one process responsible for reading and</span>
 <span class="s0">* dispacting on the events (but not necessarily immediately).</span>
 <span class="s0">*</span>
 <span class="s0">* This function use to inherit from Namable, but that makes it too expensive</span>
 <span class="s0">* to get its name the Python code.  Now it just copies the Namable interface</span>
 <span class="s0">* in.</span>
 <span class="s0">*/</span>

<span class="s0">552 15 EventReceiver * 0 8576 15 EventReceiver * 15 EventReceiver * 0 0 553 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">553 13 EventReceiver 0 1050624 13 EventReceiver 13 EventReceiver 0 0 0 0 0 0 0 0 0 0 0 0 225</span>
<span class="s0">/**</span>
 <span class="s0">* An abstract base class for anything that might care about receiving events.</span>
 <span class="s0">* An object that might receive an event should inherit from this class; each</span>
 <span class="s0">* event may be sent with an optional EventReceiver pointer.</span>
 <span class="s0">*/</span>

<span class="s0">554 12 EventHandler 0 75777 12 EventHandler 12 EventHandler 0 0 0 1 458 0 0 6 459 460 461 462 463 464 0 0 1 0 555 0 0 0 0 384</span>
<span class="s0">/**</span>
 <span class="s0">* A class to monitor events from the C++ side of things.  It maintains a set</span>
 <span class="s0">* of &quot;hooks&quot;, function pointers assigned to event names, and calls the</span>
 <span class="s0">* appropriate hooks when the matching event is detected.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is not necessary when the hooks are detected and processed</span>
 <span class="s0">* entirely by the scripting language, e.g.  via Scheme hooks or the messenger</span>
 <span class="s0">* in Python.</span>
 <span class="s0">*/</span>

<span class="s0">555 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">556 10 EventQueue 0 26625 10 EventQueue 10 EventQueue 0 0 0 1 465 466 0 6 467 468 469 470 471 472 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A queue of pending events.  As events are thrown, they are added to this</span>
 <span class="s0">* queue; eventually, they will be extracted out again by an EventHandler and</span>
 <span class="s0">* processed.</span>
 <span class="s0">*/</span>

<span class="s0">557 16 PointerEventList 0 141313 16 PointerEventList 16 PointerEventList 0 0 0 1 473 492 0 18 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 0 0 1 0 549 0 0 0 0 228</span>
<span class="s0">/**</span>
 <span class="s0">* Records a set of pointer events that happened recently.  This class is</span>
 <span class="s0">* usually used only in the data graph, to transmit the recent pointer</span>
 <span class="s0">* presses, but it may be used anywhere a list of PointerEvents is desired.</span>
 <span class="s0">*/</span>

<span class="s0">558 10 PythonTask 0 16852993 10 PythonTask 10 PythonTask 0 0 0 1 493 287 7 660 661 662 663 664 665 666 18 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 520 0 0 1 0 527 0 0 0 0 113</span>
<span class="s0">/**</span>
 <span class="s0">* This class exists to allow association of a Python function or coroutine</span>
 <span class="s0">* with the AsyncTaskManager.</span>
 <span class="s0">*/</span>

<span class="s0">559 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 560 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">560 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 561 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">561 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">562 16 EventParameter * 0 8576 16 EventParameter * 16 EventParameter * 0 0 521 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">563 22 EventParameter const * 0 8576 22 EventParameter const * 22 EventParameter const * 0 0 564 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">564 20 EventParameter const 0 8832 20 EventParameter const 20 EventParameter const 0 0 521 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">565 27 TypedReferenceCount const * 0 8576 27 TypedReferenceCount const * 27 TypedReferenceCount const * 0 0 566 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">566 25 TypedReferenceCount const 0 8832 25 TypedReferenceCount const 25 TypedReferenceCount const 0 0 523 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">567 35 TypedWritableReferenceCount const * 0 8576 35 TypedWritableReferenceCount const * 35 TypedWritableReferenceCount const * 0 0 568 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">568 33 TypedWritableReferenceCount const 0 8832 33 TypedWritableReferenceCount const 33 TypedWritableReferenceCount const 0 0 569 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">569 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedWritable and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedWritables and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">570 9 nullptr_t 0 2105344 14 std::nullptr_t 14 std::nullptr_t 0 0 571 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">571 17 decltype(nullptr) 0 8194 17 decltype(nullptr) 17 decltype(nullptr) 0 9 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">572 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">573 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 523 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">574 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 569 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">575 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 576 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">576 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">577 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">578 13 AsyncFuture * 0 8576 13 AsyncFuture * 13 AsyncFuture * 0 0 522 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">579 19 AsyncFuture const * 0 8576 19 AsyncFuture const * 19 AsyncFuture const * 0 0 580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">580 17 AsyncFuture const 0 8832 17 AsyncFuture const 17 AsyncFuture const 0 0 522 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">581 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">582 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 581 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">583 17 AsyncTask const * 0 8576 17 AsyncTask const * 17 AsyncTask const * 0 0 584 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">584 15 AsyncTask const 0 8832 15 AsyncTask const 15 AsyncTask const 0 0 527 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">585 11 AsyncTask * 0 8576 11 AsyncTask * 11 AsyncTask * 0 0 527 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">586 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 528 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">587 24 AsyncTaskManager const * 0 8576 24 AsyncTaskManager const * 24 AsyncTaskManager const * 0 0 588 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">588 22 AsyncTaskManager const 0 8832 22 AsyncTaskManager const 22 AsyncTaskManager const 0 0 533 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">589 16 AsyncTaskChain * 0 8576 16 AsyncTaskChain * 16 AsyncTaskChain * 0 0 542 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">590 21 AsyncTaskCollection * 0 8576 21 AsyncTaskCollection * 21 AsyncTaskCollection * 0 0 536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">591 19 GlobPattern const * 0 8576 19 GlobPattern const * 19 GlobPattern const * 0 0 592 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">592 17 GlobPattern const 0 8832 17 GlobPattern const 17 GlobPattern const 0 0 593 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">593 11 GlobPattern 0 2048 11 GlobPattern 11 GlobPattern 0 0 0 0 0 0 0 0 0 0 0 0 538</span>
<span class="s0">/**</span>
 <span class="s0">* This class can be used to test for string matches against standard Unix-</span>
 <span class="s0">* shell filename globbing conventions.  It serves as a portable standin for</span>
 <span class="s0">* the Posix fnmatch() call.</span>
 <span class="s0">*</span>
 <span class="s0">* A GlobPattern is given a pattern string, which can contain operators like</span>
 <span class="s0">* *, ?, and [].  Then it can be tested against any number of candidate</span>
 <span class="s0">* strings; for each candidate, it will indicate whether the string matches</span>
 <span class="s0">* the pattern or not.  It can be used, for example, to scan a directory for</span>
 <span class="s0">* all files matching a particular pattern.</span>
 <span class="s0">*/</span>

<span class="s0">594 27 AsyncTaskCollection const * 0 8576 27 AsyncTaskCollection const * 27 AsyncTaskCollection const * 0 0 595 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">595 25 AsyncTaskCollection const 0 8832 25 AsyncTaskCollection const 25 AsyncTaskCollection const 0 0 536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">596 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 597 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">597 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">598 22 AsyncTaskChain const * 0 8576 22 AsyncTaskChain const * 22 AsyncTaskChain const * 0 0 599 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">599 20 AsyncTaskChain const 0 8832 20 AsyncTaskChain const 20 AsyncTaskChain const 0 0 542 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">600 14 ThreadPriority 0 532480 14 ThreadPriority 14 ThreadPriority 0 0 0 0 0 0 0 0 0 0 4 6 TP_low 6 TP_low 0</span>
<span class="s0">0 9 TP_normal 9 TP_normal 0</span>
<span class="s0">1 7 TP_high 7 TP_high 0</span>
<span class="s0">2 9 TP_urgent 9 TP_urgent 0</span>
<span class="s0">3 0 105</span>
<span class="s0">// An enumerated type used by Thread to specify a suggested relative priority</span>
<span class="s0">// for a particular thread.</span>

<span class="s0">601 22 AsyncTaskPause const * 0 8576 22 AsyncTaskPause const * 22 AsyncTaskPause const * 0 0 602 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">602 20 AsyncTaskPause const 0 8832 20 AsyncTaskPause const 20 AsyncTaskPause const 0 0 543 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">603 16 AsyncTaskPause * 0 8576 16 AsyncTaskPause * 16 AsyncTaskPause * 0 0 543 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">604 25 AsyncTaskSequence const * 0 8576 25 AsyncTaskSequence const * 25 AsyncTaskSequence const * 0 0 605 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">605 23 AsyncTaskSequence const 0 8832 23 AsyncTaskSequence const 23 AsyncTaskSequence const 0 0 544 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">606 19 AsyncTaskSequence * 0 8576 19 AsyncTaskSequence * 19 AsyncTaskSequence * 0 0 544 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">607 19 ButtonEvent const * 0 8576 19 ButtonEvent const * 19 ButtonEvent const * 0 0 550 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">608 17 ButtonEventList * 0 8576 17 ButtonEventList * 17 ButtonEventList * 0 0 548 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">609 23 ButtonEventList const * 0 8576 23 ButtonEventList const * 23 ButtonEventList const * 0 0 610 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">610 21 ButtonEventList const 0 8832 21 ButtonEventList const 21 ButtonEventList const 0 0 548 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">611 13 ButtonEvent * 0 8576 13 ButtonEvent * 13 ButtonEvent * 0 0 545 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">612 17 ModifierButtons * 0 8576 17 ModifierButtons * 17 ModifierButtons * 0 0 613 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">613 15 ModifierButtons 0 2048 15 ModifierButtons 15 ModifierButtons 0 0 0 0 0 0 0 0 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* This class monitors the state of a number of individual buttons and tracks</span>
 <span class="s0">* whether each button is known to be down or up.</span>
 <span class="s0">*/</span>

<span class="s0">614 13 Event const * 0 8576 13 Event const * 13 Event const * 0 0 615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">615 11 Event const 0 8832 11 Event const 11 Event const 0 0 551 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">616 7 Event * 0 8576 7 Event * 7 Event * 0 0 551 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">617 12 EventQueue * 0 8576 12 EventQueue * 12 EventQueue * 0 0 556 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">618 14 EventHandler * 0 8576 14 EventHandler * 14 EventHandler * 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">619 20 EventHandler const * 0 8576 20 EventHandler const * 20 EventHandler const * 0 0 620 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">620 18 EventHandler const 0 8832 18 EventHandler const 18 EventHandler const 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">621 18 EventQueue const * 0 8576 18 EventQueue const * 18 EventQueue const * 0 0 622 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">622 16 EventQueue const 0 8832 16 EventQueue const 16 EventQueue const 0 0 556 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">623 18 PointerEventList * 0 8576 18 PointerEventList * 18 PointerEventList * 0 0 557 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">624 24 PointerEventList const * 0 8576 24 PointerEventList const * 24 PointerEventList const * 0 0 625 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">625 22 PointerEventList const 0 8832 22 PointerEventList const 22 PointerEventList const 0 0 557 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">626 19 PointerData const * 0 8576 19 PointerData const * 19 PointerData const * 0 0 627 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">627 17 PointerData const 0 8832 17 PointerData const 17 PointerData const 0 0 628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">628 11 PointerData 0 2048 11 PointerData 11 PointerData 0 0 0 0 0 0 0 0 0 0 0 0 124</span>
<span class="s0">/**</span>
 <span class="s0">* Holds the data that might be generated by a 2-d pointer input device, such</span>
 <span class="s0">* as the mouse in the GraphicsWindow.</span>
 <span class="s0">*/</span>

<span class="s0">629 12 PythonTask * 0 8576 12 PythonTask * 12 PythonTask * 0 0 558 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">630 18 PythonTask const * 0 8576 18 PythonTask const * 18 PythonTask const * 0 0 631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">631 16 PythonTask const 0 8832 16 PythonTask const 16 PythonTask const 0 0 558 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">632 9 visitproc 0 2105344 9 visitproc 9 visitproc 0 0 633 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">633 6 void * 0 8576 6 void * 6 void * 0 0 577 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">33</span>
<span class="s0">634 10 done_event 0 6 524 276 275 0 0 0 0 0 0 23 AsyncFuture::done_event 0</span>

<span class="s0">635 5 state 0 2 530 288 0 0 0 0 0 0 0 16 AsyncTask::state 0</span>

<span class="s0">636 5 alive 0 2 531 289 0 0 0 0 0 0 0 16 AsyncTask::alive 0</span>

<span class="s0">637 7 manager 0 2 532 290 0 0 0 0 0 0 0 18 AsyncTask::manager 0</span>

<span class="s0">638 5 clock 0 6 534 325 324 0 0 0 0 0 0 23 AsyncTaskManager::clock 0</span>

<span class="s0">639 5 tasks 0 2 536 341 0 0 0 0 0 0 0 23 AsyncTaskManager::tasks 0</span>

<span class="s0">640 12 active_tasks 0 2 536 342 0 0 0 0 0 0 0 30 AsyncTaskManager::active_tasks 0</span>

<span class="s0">641 14 sleeping_tasks 0 2 536 343 0 0 0 0 0 0 0 32 AsyncTaskManager::sleeping_tasks 0</span>

<span class="s0">642 14 next_wake_time 0 2 537 364 0 0 0 0 0 0 0 32 AsyncTaskManager::next_wake_time 0</span>

<span class="s0">643 4 name 0 6 524 369 302 0 0 0 0 0 0 15 AsyncTask::name 25</span>
<span class="s0">// The name of this task.</span>

<span class="s0">644 2 id 0 2 538 305 0 0 0 0 0 0 0 13 AsyncTask::id 99</span>
<span class="s0">// This is a number guaranteed to be unique for each different AsyncTask</span>
<span class="s0">// object in the universe.</span>

<span class="s0">645 10 task_chain 0 6 524 307 306 0 0 0 0 0 0 21 AsyncTask::task_chain 0</span>

<span class="s0">646 4 sort 0 6 541 309 308 0 0 0 0 0 0 15 AsyncTask::sort 0</span>

<span class="s0">647 8 priority 0 6 541 311 310 0 0 0 0 0 0 19 AsyncTask::priority 0</span>

<span class="s0">648 10 done_event 0 6 524 370 312 0 0 0 0 0 0 21 AsyncTask::done_event 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the event name that will be triggered when the future finishes.</span>
 <span class="s0">* See set_done_event().</span>
 <span class="s0">*/</span>

<span class="s0">649 2 dt 0 2 537 313 0 0 0 0 0 0 0 13 AsyncTask::dt 0</span>

<span class="s0">650 6 max_dt 0 2 537 314 0 0 0 0 0 0 0 17 AsyncTask::max_dt 0</span>

<span class="s0">651 10 average_dt 0 2 537 315 0 0 0 0 0 0 0 21 AsyncTask::average_dt 0</span>

<span class="s0">652 6 button 0 2 547 427 0 0 0 0 0 0 0 19 ButtonEvent::button 0</span>

<span class="s0">653 7 keycode 0 2 541 428 0 0 0 0 0 0 0 20 ButtonEvent::keycode 0</span>

<span class="s0">654 4 type 0 2 546 429 0 0 0 0 0 0 0 17 ButtonEvent::type 0</span>

<span class="s0">655 4 time 0 2 537 430 0 0 0 0 0 0 0 17 ButtonEvent::time 0</span>

<span class="s0">656 6 events 0 66 550 436 0 0 0 0 435 0 0 23 ButtonEventList::events 0</span>

<span class="s0">657 4 name 0 6 524 448 445 0 0 0 0 0 0 11 Event::name 0</span>

<span class="s0">658 10 parameters 0 66 521 451 0 0 0 0 450 0 0 17 Event::parameters 0</span>

<span class="s0">659 8 receiver 0 30 552 453 454 452 455 0 0 0 0 15 Event::receiver 0</span>

<span class="s0">660 4 time 0 2 537 511 0 0 0 0 0 0 0 16 PythonTask::time 112</span>
<span class="s0">// The amount of seconds that have elapsed since the task was started,</span>
<span class="s0">// according to the task manager's clock.</span>

<span class="s0">661 9 wake_time 0 2 537 512 0 0 0 0 0 0 0 21 PythonTask::wake_time 345</span>
<span class="s0">// If this task has been added to an AsyncTaskManager with a delay in</span>
<span class="s0">// effect, this contains the time at which the task is expected to awaken.</span>
<span class="s0">// It has no meaning of the task has not yet been added to a queue, or if</span>
<span class="s0">// there was no delay in effect at the time the task was added.  If the</span>
<span class="s0">// task's status is not S_sleeping, this contains 0.0.</span>

<span class="s0">662 8 wakeTime 0 2 537 512 0 0 0 0 0 0 0 20 PythonTask::wakeTime 22</span>
<span class="s0">// Alias of wake_time.</span>

<span class="s0">663 10 delay_time 0 30 537 513 515 514 516 0 0 0 0 22 PythonTask::delay_time 67</span>
<span class="s0">// The delay value that has been set on this task, if any, or None.</span>

<span class="s0">664 9 delayTime 0 30 537 513 515 514 516 0 0 0 0 21 PythonTask::delayTime 23</span>
<span class="s0">// Alias of delay_time.</span>

<span class="s0">665 5 frame 0 2 541 517 0 0 0 0 0 0 0 17 PythonTask::frame 111</span>
<span class="s0">// The number of frames that have elapsed since the task was started,</span>
<span class="s0">// according to the task manager's clock.</span>

<span class="s0">666 8 __dict__ 0 6 559 518 519 0 0 0 0 0 0 20 PythonTask::__dict__ 105</span>
<span class="s0">// This is a special variable to hold the instance dictionary in which</span>
<span class="s0">// custom variables may be stored.</span>

<span class="s0">3</span>
<span class="s0">667 15 get_task_chains 0 326 327 33 AsyncTaskManager::get_task_chains 0</span>

<span class="s0">668 9 get_tasks 0 355 356 30 AsyncTaskCollection::get_tasks 0</span>

<span class="s0">669 14 get_parameters 0 450 451 21 Event::get_parameters 0</span>

</pre>
</body>
</html>