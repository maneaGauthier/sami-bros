<html>
<head>
<title>ClockDelta.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ClockDelta.py</font>
</center></td></tr></table>
<pre><span class="s0"># ClockDelta provides the ability to use clock synchronization for</span>
<span class="s0"># distributed objects</span>

<span class="s2">from </span><span class="s1">panda3d</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">ClockObject</span>
<span class="s2">from </span><span class="s1">direct</span><span class="s3">.</span><span class="s1">directnotify </span><span class="s2">import </span><span class="s1">DirectNotifyGlobal</span>
<span class="s2">from </span><span class="s1">direct</span><span class="s3">.</span><span class="s1">showbase </span><span class="s2">import </span><span class="s1">DirectObject</span>
<span class="s2">import </span><span class="s1">math</span>

<span class="s0"># The following two parameters, NetworkTimeBits and</span>
<span class="s0"># NetworkTimePrecision, define the number of bits required to store a</span>
<span class="s0"># network time, and the number of ticks per second it represents,</span>
<span class="s0"># respectively.  The tradeoff is the longest period of elapsed time we</span>
<span class="s0"># can measure, vs. the precision with which we can measure it.</span>

<span class="s0"># 16 and 100 give us precision to 1/100th of a second, with a range of</span>
<span class="s0"># +/- 5 minutes in a 16-bit integer.  These are eminently tweakable,</span>
<span class="s0"># but the parameter types in toon.dc must match the number of bits</span>
<span class="s0"># specified here (i.e. int16 if NetworkTimeBits is 16; int32 if</span>
<span class="s0"># NetworkTimeBits is 32).</span>
<span class="s1">NetworkTimeBits </span><span class="s3">= </span><span class="s4">16</span>
<span class="s1">NetworkTimePrecision </span><span class="s3">= </span><span class="s4">100.0</span>


<span class="s0"># These values are derived from the above.</span>
<span class="s1">NetworkTimeMask </span><span class="s3">= (</span><span class="s4">1 </span><span class="s3">&lt;&lt; </span><span class="s1">NetworkTimeBits</span><span class="s3">) - </span><span class="s4">1</span>
<span class="s1">NetworkTimeSignedMask </span><span class="s3">= </span><span class="s1">NetworkTimeMask </span><span class="s3">&gt;&gt; </span><span class="s4">1 </span><span class="s0"># the max absolute value bits.</span>
<span class="s1">NetworkTimeTopBits </span><span class="s3">= </span><span class="s4">32 </span><span class="s3">- </span><span class="s1">NetworkTimeBits</span>
<span class="s1">MaxTimeDelta </span><span class="s3">= </span><span class="s1">NetworkTimeSignedMask </span><span class="s3">/ </span><span class="s1">NetworkTimePrecision</span>

<span class="s0"># This is the maximum number of seconds by which we expect our clock</span>
<span class="s0"># (or the server's clock) to drift over an hour.</span>
<span class="s1">ClockDriftPerHour </span><span class="s3">= </span><span class="s4">1.0   </span><span class="s0"># Is this generous enough?</span>

<span class="s0"># And the above, scaled into a per-second value.</span>
<span class="s1">ClockDriftPerSecond </span><span class="s3">= </span><span class="s1">ClockDriftPerHour </span><span class="s3">/ </span><span class="s4">3600.0</span>

<span class="s0"># How many seconds to insist on waiting before accepting a second</span>
<span class="s0"># resync request from another client.</span>
<span class="s1">P2PResyncDelay </span><span class="s3">= </span><span class="s4">10.0</span>

<span class="s2">class </span><span class="s1">ClockDelta</span><span class="s3">(</span><span class="s1">DirectObject</span><span class="s3">.</span><span class="s1">DirectObject</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    The ClockDelta object converts between universal (&quot;network&quot;) time, 
    which is used for all network traffic, and local time (e.g. as 
    returned by getFrameTime() or getRealTime()), which is used for 
    everything else. 
    &quot;&quot;&quot;</span>

    <span class="s1">notify </span><span class="s3">= </span><span class="s1">DirectNotifyGlobal</span><span class="s3">.</span><span class="s1">directNotify</span><span class="s3">.</span><span class="s1">newCategory</span><span class="s3">(</span><span class="s6">'ClockDelta'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">globalClock </span><span class="s3">= </span><span class="s1">ClockObject</span><span class="s3">.</span><span class="s1">getGlobalClock</span><span class="s3">()</span>

        <span class="s0"># self.delta is the relative delta from our clock to the</span>
        <span class="s0"># server's clock.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">delta </span><span class="s3">= </span><span class="s4">0</span>

        <span class="s0"># self.uncertainty represents the number of seconds plus or</span>
        <span class="s0"># minus in which we are confident our delta matches the</span>
        <span class="s0"># server's actual time.  The initial value, None, represents</span>
        <span class="s0"># infinity--we have no idea.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">uncertainty </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s0"># self.lastResync is the time at which self.uncertainty</span>
        <span class="s0"># was measured.  It is important to remember because our</span>
        <span class="s0"># uncertainty increases over time (due to relative clock</span>
        <span class="s0"># drift).</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lastResync </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">accept</span><span class="s3">(</span><span class="s6">&quot;resetClock&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__resetClock</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">getDelta</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delta</span>

    <span class="s2">def </span><span class="s1">getUncertainty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Returns our current uncertainty with our clock measurement,</span>
        <span class="s0"># as a number of seconds plus or minus.  Returns None,</span>
        <span class="s0"># representing infinite uncertainty, if we have never received</span>
        <span class="s0"># a time measurement.</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">uncertainty </span><span class="s3">== </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s2">return None</span>

        <span class="s1">now </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">globalClock</span><span class="s3">.</span><span class="s1">getRealTime</span><span class="s3">()</span>
        <span class="s1">elapsed </span><span class="s3">= </span><span class="s1">now </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lastResync</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">uncertainty </span><span class="s3">+ </span><span class="s1">elapsed </span><span class="s3">* </span><span class="s1">ClockDriftPerSecond</span>

    <span class="s2">def </span><span class="s1">getLastResync</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Returns the local time at which we last resynchronized the</span>
        <span class="s0"># clock delta.</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lastResync</span>

    <span class="s2">def </span><span class="s1">__resetClock</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">timeDelta</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        this is called when the global clock gets adjusted 
        timeDelta is equal to the amount of time, in seconds, 
        that has been added to the global clock 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
            <span class="s6">&quot;adjusting timebase by %f seconds&quot; </span><span class="s3">% </span><span class="s1">timeDelta</span><span class="s3">)</span>
        <span class="s0"># adjust our timebase by the same amount</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">delta </span><span class="s3">+= </span><span class="s1">timeDelta</span>

    <span class="s2">def </span><span class="s1">clear</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Throws away any previous synchronization information. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">delta </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">uncertainty </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lastResync </span><span class="s3">= </span><span class="s4">0.0</span>

    <span class="s2">def </span><span class="s1">resynchronize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">localTime</span><span class="s3">, </span><span class="s1">networkTime</span><span class="s3">, </span><span class="s1">newUncertainty</span><span class="s3">,</span>
                      <span class="s1">trustNew </span><span class="s3">= </span><span class="s4">1</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;resynchronize(self, float localTime, int32 networkTime, 
                         float newUncertainty) 
 
        Accepts a new networkTime value, which is understood to 
        represent the same moment as localTime, plus or minus 
        uncertainty seconds.  Improves our current notion of the time 
        delta accordingly. 
        &quot;&quot;&quot;</span>
        <span class="s1">newDelta </span><span class="s3">= (</span><span class="s1">float</span><span class="s3">(</span><span class="s1">localTime</span><span class="s3">) -</span>
            <span class="s3">(</span><span class="s1">float</span><span class="s3">(</span><span class="s1">networkTime</span><span class="s3">) / </span><span class="s1">NetworkTimePrecision</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">newDelta</span><span class="s3">(</span>
            <span class="s1">localTime</span><span class="s3">, </span><span class="s1">newDelta</span><span class="s3">, </span><span class="s1">newUncertainty</span><span class="s3">, </span><span class="s1">trustNew </span><span class="s3">= </span><span class="s1">trustNew</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">peerToPeerResync</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">avId</span><span class="s3">, </span><span class="s1">timestamp</span><span class="s3">, </span><span class="s1">serverTime</span><span class="s3">, </span><span class="s1">uncertainty</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Accepts an AI time and uncertainty value from another client, 
        along with a local timestamp value of the message from this 
        client which prompted the other client to send us its delta 
        information. 
 
        The return value is true if the other client's measurement was 
        reasonably close to our own, or false if the other client's 
        time estimate was wildly divergent from our own; the return 
        value is negative if the test was not even considered (because 
        it happened too soon after another recent request). 
        &quot;&quot;&quot;</span>

        <span class="s1">now </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">globalClock</span><span class="s3">.</span><span class="s1">getRealTime</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">now </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lastResync </span><span class="s3">&lt; </span><span class="s1">P2PResyncDelay</span><span class="s3">:</span>
            <span class="s0"># We can't process this request; it came in on the heels</span>
            <span class="s0"># of some other request, and our local timestamp may have</span>
            <span class="s0"># been resynced since then: ergo, the timestamp in this</span>
            <span class="s0"># request is meaningless.</span>
            <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
                <span class="s6">&quot;Ignoring request for resync from %s within %.3f s.&quot; </span><span class="s3">%</span>
                <span class="s3">(</span><span class="s1">avId</span><span class="s3">, </span><span class="s1">now </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lastResync</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s3">-</span><span class="s4">1</span>

        <span class="s0"># The timestamp value will be a timestamp that we sent out</span>
        <span class="s0"># previously, echoed back to us.  Therefore we can confidently</span>
        <span class="s0"># convert it back into our local time, even though we suspect</span>
        <span class="s0"># our clock delta might be off.</span>
        <span class="s1">local </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">networkToLocalTime</span><span class="s3">(</span><span class="s1">timestamp</span><span class="s3">, </span><span class="s1">now</span><span class="s3">)</span>
        <span class="s1">elapsed </span><span class="s3">= </span><span class="s1">now </span><span class="s3">- </span><span class="s1">local</span>
        <span class="s1">delta </span><span class="s3">= (</span><span class="s1">local </span><span class="s3">+ </span><span class="s1">now</span><span class="s3">) / </span><span class="s4">2.0 </span><span class="s3">- </span><span class="s1">serverTime</span>

        <span class="s1">gotSync </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">elapsed </span><span class="s3">&lt;= </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">elapsed </span><span class="s3">&gt; </span><span class="s1">P2PResyncDelay</span><span class="s3">:</span>
            <span class="s0"># The elapsed time must be positive (the local timestamp</span>
            <span class="s0"># must be in the past), and shouldn't be more than</span>
            <span class="s0"># P2PResyncDelay.  If it does not meet these requirements,</span>
            <span class="s0"># it must be very old indeed, or someone is playing tricks</span>
            <span class="s0"># on us.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span>
                <span class="s6">&quot;Ignoring old request for resync from %s.&quot; </span><span class="s3">% (</span><span class="s1">avId</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Now the other client has told us his delta and uncertainty</span>
            <span class="s0"># information, which was generated somewhere in the range</span>
            <span class="s0"># [-elapsed, 0] seconds ago.  That means our complete window</span>
            <span class="s0"># is wider by that amount.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span>
                <span class="s6">&quot;Got sync +/- %.3f s, elapsed %.3f s, from %s.&quot; </span><span class="s3">%</span>
                <span class="s3">(</span><span class="s1">uncertainty</span><span class="s3">, </span><span class="s1">elapsed</span><span class="s3">, </span><span class="s1">avId</span><span class="s3">))</span>
            <span class="s1">delta </span><span class="s3">-= </span><span class="s1">elapsed </span><span class="s3">/ </span><span class="s4">2.0</span>
            <span class="s1">uncertainty </span><span class="s3">+= </span><span class="s1">elapsed </span><span class="s3">/ </span><span class="s4">2.0</span>

            <span class="s1">gotSync </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">newDelta</span><span class="s3">(</span><span class="s1">local</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">, </span><span class="s1">uncertainty</span><span class="s3">, </span><span class="s1">trustNew </span><span class="s3">= </span><span class="s4">0</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">gotSync</span>

    <span class="s2">def </span><span class="s1">newDelta</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">localTime</span><span class="s3">, </span><span class="s1">newDelta</span><span class="s3">, </span><span class="s1">newUncertainty</span><span class="s3">,</span>
                 <span class="s1">trustNew </span><span class="s3">= </span><span class="s4">1</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Accepts a new delta and uncertainty pair, understood to 
        represent time as of localTime.  Improves our current notion 
        of the time delta accordingly.  The return value is true if 
        the new measurement was used, false if it was discarded. 
        &quot;&quot;&quot;</span>
        <span class="s1">oldUncertainty </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getUncertainty</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">oldUncertainty </span><span class="s3">!= </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span>
                <span class="s6">'previous delta at %.3f s, +/- %.3f s.' </span><span class="s3">%</span>
                <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">delta</span><span class="s3">, </span><span class="s1">oldUncertainty</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span>
                <span class="s6">'new delta at %.3f s, +/- %.3f s.' </span><span class="s3">%</span>
                <span class="s3">(</span><span class="s1">newDelta</span><span class="s3">, </span><span class="s1">newUncertainty</span><span class="s3">))</span>
            <span class="s0"># Our previous measurement was self.delta +/- oldUncertainty;</span>
            <span class="s0"># our new measurement is newDelta +/- newUncertainty.  Take</span>
            <span class="s0"># the intersection of both.</span>

            <span class="s1">oldLow </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delta </span><span class="s3">- </span><span class="s1">oldUncertainty</span>
            <span class="s1">oldHigh </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delta </span><span class="s3">+ </span><span class="s1">oldUncertainty</span>
            <span class="s1">newLow </span><span class="s3">= </span><span class="s1">newDelta </span><span class="s3">- </span><span class="s1">newUncertainty</span>
            <span class="s1">newHigh </span><span class="s3">= </span><span class="s1">newDelta </span><span class="s3">+ </span><span class="s1">newUncertainty</span>

            <span class="s1">low </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">oldLow</span><span class="s3">, </span><span class="s1">newLow</span><span class="s3">)</span>
            <span class="s1">high </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">oldHigh</span><span class="s3">, </span><span class="s1">newHigh</span><span class="s3">)</span>

            <span class="s0"># If there is no intersection, whoops!  Either the old</span>
            <span class="s0"># measurement or the new measurement is completely wrong.</span>
            <span class="s2">if </span><span class="s1">low </span><span class="s3">&gt; </span><span class="s1">high</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">trustNew</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s6">'discarding new delta.'</span><span class="s3">)</span>
                    <span class="s2">return </span><span class="s4">0</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s6">'discarding previous delta.'</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">newDelta </span><span class="s3">= (</span><span class="s1">low </span><span class="s3">+ </span><span class="s1">high</span><span class="s3">) / </span><span class="s4">2.0</span>
                <span class="s1">newUncertainty </span><span class="s3">= (</span><span class="s1">high </span><span class="s3">- </span><span class="s1">low</span><span class="s3">) / </span><span class="s4">2.0</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">notify</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span>
                    <span class="s6">'intersection at %.3f s, +/- %.3f s.' </span><span class="s3">%</span>
                    <span class="s3">(</span><span class="s1">newDelta</span><span class="s3">, </span><span class="s1">newUncertainty</span><span class="s3">))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">delta </span><span class="s3">= </span><span class="s1">newDelta</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">uncertainty </span><span class="s3">= </span><span class="s1">newUncertainty</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lastResync </span><span class="s3">= </span><span class="s1">localTime</span>

        <span class="s2">return </span><span class="s4">1</span>

    <span class="s0">### Primary interface functions ###</span>

    <span class="s2">def </span><span class="s1">networkToLocalTime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">networkTime</span><span class="s3">, </span><span class="s1">now </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">bits </span><span class="s3">= </span><span class="s4">16</span><span class="s3">,</span>
                           <span class="s1">ticksPerSec</span><span class="s3">=</span><span class="s1">NetworkTimePrecision</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;networkToLocalTime(self, int networkTime) 
 
        Converts the indicated networkTime to the corresponding 
        localTime value.  The time is assumed to be within +/- 5 
        minutes of the current local time given in now, or 
        getRealTime() if now is not specified. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">now </span><span class="s3">== </span><span class="s2">None</span><span class="s3">:</span>
            <span class="s1">now </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">globalClock</span><span class="s3">.</span><span class="s1">getRealTime</span><span class="s3">()</span>

        <span class="s0"># Are we in non-real-time mode (i.e. filming a movie)?  If you</span>
        <span class="s0"># set movie-network-time 1, then we'll circumvent this logic</span>
        <span class="s0"># and always return now.</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">globalClock</span><span class="s3">.</span><span class="s1">getMode</span><span class="s3">() == </span><span class="s1">ClockObject</span><span class="s3">.</span><span class="s1">MNonRealTime </span><span class="s2">and </span><span class="s1">\</span>
           <span class="s1">base</span><span class="s3">.</span><span class="s1">config</span><span class="s3">.</span><span class="s1">GetBool</span><span class="s3">(</span><span class="s6">'movie-network-time'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">now</span>

        <span class="s0"># First, determine what network time we have for 'now'.</span>
        <span class="s1">ntime </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(((</span><span class="s1">now </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delta</span><span class="s3">) * </span><span class="s1">ticksPerSec</span><span class="s3">) + </span><span class="s4">0.5</span><span class="s3">))</span>

        <span class="s0"># The signed difference between these is the number of ticks</span>
        <span class="s0"># by which the network time differs from 'now'.</span>
        <span class="s2">if </span><span class="s1">bits </span><span class="s3">== </span><span class="s4">16</span><span class="s3">:</span>
            <span class="s1">diff </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__signExtend</span><span class="s3">(</span><span class="s1">networkTime </span><span class="s3">- </span><span class="s1">ntime</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Assume the bits is either 16 or 32.  If it's 32, no need</span>
            <span class="s0"># to sign-extend.  32 bits gives us about 227 days of</span>
            <span class="s0"># continuous timestamp.</span>

            <span class="s1">diff </span><span class="s3">= </span><span class="s1">networkTime </span><span class="s3">- </span><span class="s1">ntime</span>

        <span class="s2">return </span><span class="s1">now </span><span class="s3">+ </span><span class="s1">float</span><span class="s3">(</span><span class="s1">diff</span><span class="s3">) / </span><span class="s1">ticksPerSec</span>

    <span class="s2">def </span><span class="s1">localToNetworkTime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">localTime</span><span class="s3">, </span><span class="s1">bits </span><span class="s3">= </span><span class="s4">16</span><span class="s3">,</span>
                           <span class="s1">ticksPerSec</span><span class="s3">=</span><span class="s1">NetworkTimePrecision</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;localToNetworkTime(self, float localTime) 
 
        Converts the indicated localTime to the corresponding 
        networkTime value. 
        &quot;&quot;&quot;</span>
        <span class="s1">ntime </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(((</span><span class="s1">localTime </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">delta</span><span class="s3">) * </span><span class="s1">ticksPerSec</span><span class="s3">) + </span><span class="s4">0.5</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">bits </span><span class="s3">== </span><span class="s4">16</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__signExtend</span><span class="s3">(</span><span class="s1">ntime</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Assume the bits is either 16 or 32.  If it's 32, no need</span>
            <span class="s0"># to sign-extend.  32 bits gives us about 227 days of</span>
            <span class="s0"># continuous timestamp.</span>
            <span class="s2">return </span><span class="s1">ntime</span>


    <span class="s0">### Convenience functions ###</span>

    <span class="s2">def </span><span class="s1">getRealNetworkTime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">bits</span><span class="s3">=</span><span class="s4">16</span><span class="s3">,</span>
                           <span class="s1">ticksPerSec</span><span class="s3">=</span><span class="s1">NetworkTimePrecision</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the current getRealTime() expressed as a network time. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">localToNetworkTime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">globalClock</span><span class="s3">.</span><span class="s1">getRealTime</span><span class="s3">(),</span>
                                       <span class="s1">bits</span><span class="s3">=</span><span class="s1">bits</span><span class="s3">,</span>
                                       <span class="s1">ticksPerSec</span><span class="s3">=</span><span class="s1">ticksPerSec</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">getFrameNetworkTime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">bits</span><span class="s3">=</span><span class="s4">16</span><span class="s3">,</span>
                            <span class="s1">ticksPerSec</span><span class="s3">=</span><span class="s1">NetworkTimePrecision</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the current getFrameTime() expressed as a network time. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">localToNetworkTime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">globalClock</span><span class="s3">.</span><span class="s1">getFrameTime</span><span class="s3">(),</span>
                                       <span class="s1">bits</span><span class="s3">=</span><span class="s1">bits</span><span class="s3">,</span>
                                       <span class="s1">ticksPerSec</span><span class="s3">=</span><span class="s1">ticksPerSec</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">localElapsedTime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">networkTime</span><span class="s3">, </span><span class="s1">bits</span><span class="s3">=</span><span class="s4">16</span><span class="s3">,</span>
                         <span class="s1">ticksPerSec</span><span class="s3">=</span><span class="s1">NetworkTimePrecision</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;localElapsedTime(self, int networkTime) 
 
        Returns the amount of time elapsed (in seconds) on the client 
        since the server message was sent.  Negative values are 
        clamped to zero. 
        &quot;&quot;&quot;</span>
        <span class="s1">now </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">globalClock</span><span class="s3">.</span><span class="s1">getFrameTime</span><span class="s3">()</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">now </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">networkToLocalTime</span><span class="s3">(</span><span class="s1">networkTime</span><span class="s3">, </span><span class="s1">now</span><span class="s3">, </span><span class="s1">bits</span><span class="s3">=</span><span class="s1">bits</span><span class="s3">,</span>
                                           <span class="s1">ticksPerSec</span><span class="s3">=</span><span class="s1">ticksPerSec</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">max</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">)</span>

    <span class="s0">### Private functions ###</span>

    <span class="s2">def </span><span class="s1">__signExtend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">networkTime</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;__signExtend(self, int networkTime) 
 
        Preserves the lower NetworkTimeBits of the networkTime value, 
        and extends the sign bit all the way up. 
        &quot;&quot;&quot;</span>
        <span class="s1">r </span><span class="s3">= ((</span><span class="s1">networkTime</span><span class="s3">+</span><span class="s4">32768</span><span class="s3">) &amp; </span><span class="s1">NetworkTimeMask</span><span class="s3">) - </span><span class="s4">32768</span>
        <span class="s2">assert </span><span class="s3">-</span><span class="s4">32768 </span><span class="s3">&lt;= </span><span class="s1">r </span><span class="s3">&lt;= </span><span class="s4">32767</span>
        <span class="s2">return </span><span class="s1">r</span>


<span class="s1">globalClockDelta </span><span class="s3">= </span><span class="s1">ClockDelta</span><span class="s3">()</span>
</pre>
</body>
</html>