<html>
<head>
<title>python-mode.el</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
python-mode.el</font>
</center></td></tr></table>
<pre><span class="s0">;;; python-mode.el --- Major mode for editing Python programs</span>
<span class="s0">;;; Typically this goes in your emacs/lisp/progmodes directory</span>

<span class="s0">;; Copyright (C) 1992,1993,1994  Tim Peters</span>

<span class="s0">;; Author: 1995-1998 Barry A. Warsaw</span>
<span class="s0">;;         1992-1994 Tim Peters</span>
<span class="s0">;; Maintainer: python-mode@python.org</span>
<span class="s0">;; Created:    Feb 1992</span>
<span class="s0">;; Keywords:   python languages oop</span>

<span class="s0">(defconst py-version &quot;3.105&quot;</span>
  <span class="s0">&quot;`python-mode' version number.&quot;)</span>

<span class="s0">;; This software is provided as-is, without express or implied</span>
<span class="s0">;; warranty.  Permission to use, copy, modify, distribute or sell this</span>
<span class="s0">;; software, without fee, for any purpose and by any individual or</span>
<span class="s0">;; organization, is hereby granted, provided that the above copyright</span>
<span class="s0">;; notice and this paragraph appear in all copies.</span>

<span class="s0">;;; Commentary:</span>

<span class="s0">;; This is a major mode for editing Python programs.  It was developed</span>
<span class="s0">;; by Tim Peters after an original idea by Michael A. Guravage.  Tim</span>
<span class="s0">;; subsequently left the net; in 1995, Barry Warsaw inherited the mode</span>
<span class="s0">;; and is the current maintainer.  Tim's now back but disavows all</span>
<span class="s0">;; responsibility for the mode.  Smart Tim :-)</span>

<span class="s0">;; This version of python-mode.el is no longer compatible with Emacs</span>
<span class="s0">;; 18.  I am striving to maintain compatibility with the X/Emacs 19</span>
<span class="s0">;; lineage but as time goes on that becomes more and more difficult.</span>
<span class="s0">;; I current recommend that you upgrade to the latest stable released</span>
<span class="s0">;; version of your favorite branch: Emacs 20.3 or better, or XEmacs</span>
<span class="s0">;; 20.4 or better (XEmacs 21.0 is in beta testing as of this writing</span>
<span class="s0">;; 27-Oct-1998 appears to work fine with this version of</span>
<span class="s0">;; python-mode.el).  Even Windows users should be using at least</span>
<span class="s0">;; NTEmacs 20.3, and XEmacs 21.0 will work very nicely on Windows when</span>
<span class="s0">;; it is released.</span>

<span class="s0">;; FOR MORE INFORMATION:</span>

<span class="s0">;; For more information on installing python-mode.el, especially with</span>
<span class="s0">;; respect to compatibility information, please see</span>
<span class="s0">;;</span>
<span class="s0">;;     http://www.python.org/emacs/python-mode/</span>
<span class="s0">;;</span>
<span class="s0">;; This site also contains links to other packages that you might find </span>
<span class="s0">;; useful, such as pdb interfaces, OO-Browser links, etc.</span>

<span class="s0">;; BUG REPORTING:</span>

<span class="s0">;; To submit bug reports, use C-c C-b.  Please include a complete, but</span>
<span class="s0">;; concise code sample and a recipe for reproducing the bug.  Send</span>
<span class="s0">;; suggestions and other comments to python-mode@python.org.</span>

<span class="s0">;; When in a Python mode buffer, do a C-h m for more help.  It's</span>
<span class="s0">;; doubtful that a texinfo manual would be very useful, but if you</span>
<span class="s0">;; want to contribute one, I'll certainly accept it!</span>

<span class="s0">;; TO DO LIST:</span>

<span class="s0">;; - Better integration with pdb.py and gud-mode for debugging.</span>
<span class="s0">;; - Rewrite according to GNU Emacs Lisp standards.</span>
<span class="s0">;; - have py-execute-region on indented code act as if the region is</span>
<span class="s0">;;   left justified.  Avoids syntax errors.</span>
<span class="s0">;; - add a py-goto-block-down, bound to C-c C-d</span>

<span class="s0">;;; Code:</span>

<span class="s0">(require 'comint)</span>
<span class="s0">(require 'custom)</span>
<span class="s0">(eval-when-compile</span>
  <span class="s0">(require 'cl)</span>
  <span class="s0">(if (not (and (condition-case nil</span>
		    <span class="s0">(require 'custom)</span>
		  <span class="s0">(error nil))</span>
<span class="s0">;; Stock Emacs 19.34 has a broken/old Custom library</span>
<span class="s0">;; that does more harm than good.  Fortunately, it is</span>
<span class="s0">;; missing defcustom</span>
		<span class="s0">(fboundp 'defcustom)))</span>
      <span class="s0">(error &quot;STOP! STOP! STOP! STOP!</span>

<span class="s0">The Custom library was not found or is out of date.  A more current</span>
<span class="s0">version is required.  Please download and install the latest version</span>
<span class="s0">of the Custom library from:</span>

    <span class="s0">&lt;http://www.dina.kvl.dk/~abraham/custom/&gt;</span>

<span class="s0">See the Python Mode home page for details:</span>

    <span class="s0">&lt;http://www.python.org/emacs/python-mode&gt;</span>
<span class="s0">&quot;)))</span>



<span class="s0">;; user definable variables</span>
<span class="s0">;; vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</span>

<span class="s0">(defgroup python nil</span>
  <span class="s0">&quot;Support for the Python programming language, &lt;http://www.python.org/&gt;&quot;</span>
  <span class="s0">:group 'languages</span>
  <span class="s0">:prefix &quot;py-&quot;)</span>

<span class="s0">(defcustom py-python-command &quot;python&quot;</span>
  <span class="s0">&quot;*Shell command used to start Python interpreter.&quot;</span>
  <span class="s0">:type 'string</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom ppy-python-command &quot;ppython&quot;</span>
  <span class="s0">&quot;*Shell command used to start Python interpreter.&quot;</span>
  <span class="s0">:type 'string</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom pyd-python-command &quot;python_d&quot;</span>
  <span class="s0">&quot;*Shell command used to start Python interpreter.&quot;</span>
  <span class="s0">:type 'string</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom pyo-python-command &quot;python&quot;</span>
  <span class="s0">&quot;*Shell command used to start Python interpreter.&quot;</span>
  <span class="s0">:type 'string</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-jpython-command &quot;jpython&quot;</span>
  <span class="s0">&quot;*Shell command used to start the JPython interpreter.&quot;</span>
  <span class="s0">:type 'string</span>
  <span class="s0">:group 'python</span>
  <span class="s0">:tag &quot;JPython Command&quot;)</span>

<span class="s0">(defcustom py-default-interpreter 'cpython</span>
  <span class="s0">&quot;*Which Python interpreter is used by default.</span>
<span class="s0">The value for this variable can be either `cpython' or `jpython'.</span>

<span class="s0">When the value is `cpython', the variables `py-python-command' and</span>
<span class="s0">`py-python-command-args' are consulted to determine the interpreter</span>
<span class="s0">and arguments to use.</span>

<span class="s0">When the value is `jpython', the variables `py-jpython-command' and</span>
<span class="s0">`py-jpython-command-args' are consulted to determine the interpreter</span>
<span class="s0">and arguments to use.</span>

<span class="s0">Note that this variable is consulted only the first time that a Python</span>
<span class="s0">mode buffer is visited during an Emacs session.  After that, use</span>
<span class="s0">\\[py-toggle-shells] to change the interpreter shell.&quot;</span>
  <span class="s0">:type '(choice (const :tag &quot;Python (a.k.a. CPython)&quot; cpython)</span>
		 <span class="s0">(const :tag &quot;JPython&quot; jpython))</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-python-command-args '(&quot;-u&quot; &quot;-i&quot;)</span>
  <span class="s0">&quot;*List of string arguments to be used when starting a Python shell.&quot;</span>
  <span class="s0">:type '(repeat string)</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom ppy-python-command-args '(&quot;-i&quot;)</span>
  <span class="s0">&quot;*List of string arguments to be used when starting a Python shell.&quot;</span>
  <span class="s0">:type '(repeat string)</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom pyd-python-command-args '(&quot;-u&quot; &quot;-i&quot;)</span>
  <span class="s0">&quot;*List of string arguments to be used when starting a Python shell.&quot;</span>
  <span class="s0">:type '(repeat string)</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom pyo-python-command-args '(&quot;-i&quot; &quot;-OO&quot;)</span>
  <span class="s0">&quot;*List of string arguments to be used when starting a Python shell.&quot;</span>
  <span class="s0">:type '(repeat string)</span>
  <span class="s0">:group 'python)</span>


<span class="s0">(defcustom py-jpython-command-args '(&quot;-i&quot;)</span>
  <span class="s0">&quot;*List of string arguments to be used when starting a JPython shell.&quot;</span>
  <span class="s0">:type '(repeat string)</span>
  <span class="s0">:group 'python</span>
  <span class="s0">:tag &quot;JPython Command Args&quot;)</span>

<span class="s0">(defcustom py-indent-offset 4</span>
  <span class="s0">&quot;*Amount of offset per level of indentation.</span>
<span class="s0">`\\[py-guess-indent-offset]' can usually guess a good value when</span>
<span class="s0">you're editing someone else's Python code.&quot;</span>
  <span class="s0">:type 'integer</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-smart-indentation t</span>
  <span class="s0">&quot;*Should `python-mode' try to automagically set some indentation variables?</span>
<span class="s0">When this variable is non-nil, two things happen when a buffer is set</span>
<span class="s0">to `python-mode':</span>

    <span class="s0">1. `py-indent-offset' is guessed from existing code in the buffer.</span>
       <span class="s0">Only guessed values between 2 and 8 are considered.  If a valid</span>
       <span class="s0">guess can't be made (perhaps because you are visiting a new</span>
       <span class="s0">file), then the value in `py-indent-offset' is used.</span>

    <span class="s0">2. `indent-tabs-mode' is turned off if `py-indent-offset' does not</span>
       <span class="s0">equal `tab-width' (`indent-tabs-mode' is never turned on by</span>
       <span class="s0">Python mode).  This means that for newly written code, tabs are</span>
       <span class="s0">only inserted in indentation if one tab is one indentation</span>
       <span class="s0">level, otherwise only spaces are used.</span>

<span class="s0">Note that both these settings occur *after* `python-mode-hook' is run,</span>
<span class="s0">so if you want to defeat the automagic configuration, you must also</span>
<span class="s0">set `py-smart-indentation' to nil in your `python-mode-hook'.&quot;</span>
  <span class="s0">:type 'boolean</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-align-multiline-strings-p t</span>
  <span class="s0">&quot;*Flag describing how multi-line triple quoted strings are aligned.</span>
<span class="s0">When this flag is non-nil, continuation lines are lined up under the</span>
<span class="s0">preceding line's indentation.  When this flag is nil, continuation</span>
<span class="s0">lines are aligned to column zero.&quot;</span>
  <span class="s0">:type '(choice (const :tag &quot;Align under preceding line&quot; t)</span>
		 <span class="s0">(const :tag &quot;Align to column zero&quot; nil))</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-block-comment-prefix &quot;##&quot;</span>
  <span class="s0">&quot;*String used by \\[comment-region] to comment out a block of code.</span>
<span class="s0">This should follow the convention for non-indenting comment lines so</span>
<span class="s0">that the indentation commands won't get confused (i.e., the string</span>
<span class="s0">should be of the form `#x...' where `x' is not a blank or a tab, and</span>
<span class="s0">`...' is arbitrary).  However, this string should not end in whitespace.&quot;</span>
  <span class="s0">:type 'string</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-honor-comment-indentation t</span>
  <span class="s0">&quot;*Controls how comment lines influence subsequent indentation.</span>

<span class="s0">When nil, all comment lines are skipped for indentation purposes, and</span>
<span class="s0">if possible, a faster algorithm is used (i.e. X/Emacs 19 and beyond).</span>

<span class="s0">When t, lines that begin with a single `#' are a hint to subsequent</span>
<span class="s0">line indentation.  If the previous line is such a comment line (as</span>
<span class="s0">opposed to one that starts with `py-block-comment-prefix'), then its</span>
<span class="s0">indentation is used as a hint for this line's indentation.  Lines that</span>
<span class="s0">begin with `py-block-comment-prefix' are ignored for indentation</span>
<span class="s0">purposes.</span>

<span class="s0">When not nil or t, comment lines that begin with a `#' are used as</span>
<span class="s0">indentation hints, unless the comment character is in column zero.&quot;</span>
  <span class="s0">:type '(choice</span>
	  <span class="s0">(const :tag &quot;Skip all comment lines (fast)&quot; nil)</span>
	  <span class="s0">(const :tag &quot;Single # `sets' indentation for next line&quot; t)</span>
	  <span class="s0">(const :tag &quot;Single # `sets' indentation except at column zero&quot;</span>
		 <span class="s0">other)</span>
	  <span class="s0">)</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-temp-directory</span>
  <span class="s0">(let ((ok '(lambda (x)</span>
	       <span class="s0">(and x</span>
		    <span class="s0">(setq x (expand-file-name x)) ; always true</span>
		    <span class="s0">(file-directory-p x)</span>
		    <span class="s0">(file-writable-p x)</span>
		    <span class="s0">x))))</span>
    <span class="s0">(or (funcall ok (getenv &quot;TMPDIR&quot;))</span>
	<span class="s0">(funcall ok &quot;/usr/tmp&quot;)</span>
	<span class="s0">(funcall ok &quot;/tmp&quot;)</span>
	<span class="s0">(funcall ok  &quot;.&quot;)</span>
	<span class="s0">(error</span>
	 <span class="s0">&quot;Couldn't find a usable temp directory -- set `py-temp-directory'&quot;)))</span>
  <span class="s0">&quot;*Directory used for temp files created by a *Python* process.</span>
<span class="s0">By default, the first directory from this list that exists and that you</span>
<span class="s0">can write into:  the value (if any) of the environment variable TMPDIR,</span>
<span class="s0">/usr/tmp, /tmp, or the current directory.&quot;</span>
  <span class="s0">:type 'string</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-beep-if-tab-change t</span>
  <span class="s0">&quot;*Ring the bell if `tab-width' is changed.</span>
<span class="s0">If a comment of the form</span>

  <span class="s0">\t# vi:set tabsize=&lt;number&gt;:</span>

<span class="s0">is found before the first code line when the file is entered, and the</span>
<span class="s0">current value of (the general Emacs variable) `tab-width' does not</span>
<span class="s0">equal &lt;number&gt;, `tab-width' is set to &lt;number&gt;, a message saying so is</span>
<span class="s0">displayed in the echo area, and if `py-beep-if-tab-change' is non-nil</span>
<span class="s0">the Emacs bell is also rung as a warning.&quot;</span>
  <span class="s0">:type 'boolean</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-jump-on-exception t</span>
  <span class="s0">&quot;*Jump to innermost exception frame in *Python Output* buffer.</span>
<span class="s0">When this variable is non-nil and an exception occurs when running</span>
<span class="s0">Python code synchronously in a subprocess, jump immediately to the</span>
<span class="s0">source code of the innermost traceback frame.&quot;</span>
  <span class="s0">:type 'boolean</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-ask-about-save t</span>
  <span class="s0">&quot;If not nil, ask about which buffers to save before executing some code.</span>
<span class="s0">Otherwise, all modified buffers are saved without asking.&quot;</span>
  <span class="s0">:type 'boolean</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-backspace-function 'backward-delete-char-untabify</span>
  <span class="s0">&quot;*Function called by `py-electric-backspace' when deleting backwards.&quot;</span>
  <span class="s0">:type 'function</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-delete-function 'delete-char</span>
  <span class="s0">&quot;*Function called by `py-electric-delete' when deleting forwards.&quot;</span>
  <span class="s0">:type 'function</span>
  <span class="s0">:group 'python)</span>

<span class="s0">(defcustom py-imenu-show-method-args-p nil </span>
  <span class="s0">&quot;*Controls echoing of arguments of functions &amp; methods in the Imenu buffer.</span>
<span class="s0">When non-nil, arguments are printed.&quot;</span>
  <span class="s0">:type 'boolean</span>
  <span class="s0">:group 'python)</span>
<span class="s0">(make-variable-buffer-local 'py-indent-offset)</span>

<span class="s0">;; Not customizable</span>
<span class="s0">(defvar py-master-file nil</span>
  <span class="s0">&quot;If non-nil, execute the named file instead of the buffer's file.</span>
<span class="s0">The intent is to allow you to set this variable in the file's local</span>
<span class="s0">variable section, e.g.:</span>

    <span class="s0"># Local Variables:</span>
    <span class="s0"># py-master-file: \&quot;master.py\&quot;</span>
    <span class="s0"># End:</span>

<span class="s0">so that typing \\[py-execute-buffer] in that buffer executes the named</span>
<span class="s0">master file instead of the buffer's file.  If the file name has a</span>
<span class="s0">relative path, the value of variable `default-directory' for the</span>
<span class="s0">buffer is prepended to come up with a file name.&quot;)</span>
<span class="s0">(make-variable-buffer-local 'py-master-file)</span>



<span class="s0">;; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="s0">;; NO USER DEFINABLE VARIABLES BEYOND THIS POINT</span>

<span class="s0">(defconst py-emacs-features</span>
  <span class="s0">(let (features)</span>
   <span class="s0">;; NTEmacs 19.34.6 has a broken make-temp-name; it always returns</span>
   <span class="s0">;; the same string.</span>
   <span class="s0">(let ((tmp1 (make-temp-name &quot;&quot;))</span>
	 <span class="s0">(tmp2 (make-temp-name &quot;&quot;)))</span>
     <span class="s0">(if (string-equal tmp1 tmp2)</span>
	 <span class="s0">(push 'broken-temp-names features)))</span>
   <span class="s0">;; return the features</span>
   <span class="s0">features)</span>
  <span class="s0">&quot;A list of features extant in the Emacs you are using.</span>
<span class="s0">There are many flavors of Emacs out there, with different levels of</span>
<span class="s0">support for features needed by `python-mode'.&quot;)</span>

<span class="s0">(defvar python-font-lock-keywords</span>
  <span class="s0">(let ((kw1 (mapconcat 'identity</span>
			<span class="s0">'(&quot;and&quot;      &quot;assert&quot;   &quot;break&quot;   &quot;class&quot;</span>
			  <span class="s0">&quot;continue&quot; &quot;def&quot;      &quot;del&quot;     &quot;elif&quot;</span>
			  <span class="s0">&quot;else&quot;     &quot;except&quot;   &quot;exec&quot;    &quot;for&quot;</span>
			  <span class="s0">&quot;from&quot;     &quot;global&quot;   &quot;if&quot;      &quot;import&quot;</span>
			  <span class="s0">&quot;in&quot;       &quot;is&quot;       &quot;lambda&quot;  &quot;not&quot;</span>
			  <span class="s0">&quot;or&quot;       &quot;pass&quot;     &quot;print&quot;   &quot;raise&quot;</span>
			  <span class="s0">&quot;return&quot;   &quot;while&quot;</span>
			  <span class="s0">)</span>
			<span class="s0">&quot;\\|&quot;))</span>
	<span class="s0">(kw2 (mapconcat 'identity</span>
			<span class="s0">'(&quot;else:&quot; &quot;except:&quot; &quot;finally:&quot; &quot;try:&quot;)</span>
			<span class="s0">&quot;\\|&quot;))</span>
	<span class="s0">)</span>
    <span class="s0">(list</span>
     <span class="s0">;; keywords</span>
     <span class="s0">(cons (concat &quot;\\b\\(&quot; kw1 &quot;\\)\\b[ \n\t(]&quot;) 1)</span>
     <span class="s0">;; block introducing keywords with immediately following colons.</span>
     <span class="s0">;; Yes &quot;except&quot; is in both lists.</span>
     <span class="s0">(cons (concat &quot;\\b\\(&quot; kw2 &quot;\\)[ \n\t(]&quot;) 1)</span>
     <span class="s0">;; classes</span>
     <span class="s0">'(&quot;\\bclass[ \t]+\\([a-zA-Z_]+[a-zA-Z0-9_]*\\)&quot;</span>
       <span class="s0">1 font-lock-type-face)</span>
     <span class="s0">;; functions</span>
     <span class="s0">'(&quot;\\bdef[ \t]+\\([a-zA-Z_]+[a-zA-Z0-9_]*\\)&quot;</span>
       <span class="s0">1 font-lock-function-name-face)</span>
     <span class="s0">))</span>
  <span class="s0">&quot;Additional expressions to highlight in Python mode.&quot;)</span>
<span class="s0">(put 'python-mode 'font-lock-defaults '(python-font-lock-keywords))</span>

<span class="s0">;; have to bind py-file-queue before installing the kill-emacs-hook</span>
<span class="s0">;; (defvar py-file-queue nil</span>
<span class="s0">;;   &quot;Queue of Python temp files awaiting execution.</span>
<span class="s0">;; Currently-active file is at the head of the list.&quot;)</span>
<span class="s0">(defvar py-file-queues (make-hash-table)</span>
  <span class="s0">&quot;hash table of Python process to queue of Python temp files awaiting</span>
   <span class="s0">execution. Currently-active file is at the head of each list.&quot;)</span>

<span class="s0">;; Constants</span>

<span class="s0">(defconst py-stringlit-re</span>
  <span class="s0">(concat</span>
   <span class="s0">;; These fail if backslash-quote ends the string (not worth</span>
   <span class="s0">;; fixing?).  They precede the short versions so that the first two</span>
   <span class="s0">;; quotes don't look like an empty short string.</span>
   <span class="s0">;;</span>
   <span class="s0">;; (maybe raw), long single quoted triple quoted strings (SQTQ),</span>
   <span class="s0">;; with potential embedded single quotes</span>
   <span class="s0">&quot;[rR]?'''[^']*\\(\\('[^']\\|''[^']\\)[^']*\\)*'''&quot;</span>
   <span class="s0">&quot;\\|&quot;</span>
   <span class="s0">;; (maybe raw), long double quoted triple quoted strings (DQTQ),</span>
   <span class="s0">;; with potential embedded double quotes</span>
   <span class="s0">&quot;[rR]?\&quot;\&quot;\&quot;[^\&quot;]*\\(\\(\&quot;[^\&quot;]\\|\&quot;\&quot;[^\&quot;]\\)[^\&quot;]*\\)*\&quot;\&quot;\&quot;&quot;</span>
   <span class="s0">&quot;\\|&quot;</span>
   <span class="s0">&quot;[rR]?'\\([^'\n\\]\\|\\\\.\\)*'&quot;; single-quoted</span>
   <span class="s0">&quot;\\|&quot;; or</span>
   <span class="s0">&quot;[rR]?\&quot;\\([^\&quot;\n\\]\\|\\\\.\\)*\&quot;&quot;; double-quoted</span>
   <span class="s0">)</span>
  <span class="s0">&quot;Regular expression matching a Python string literal.&quot;)</span>

<span class="s0">(defconst py-continued-re</span>
  <span class="s0">;; This is tricky because a trailing backslash does not mean</span>
  <span class="s0">;; continuation if it's in a comment</span>
  <span class="s0">(concat</span>
   <span class="s0">&quot;\\(&quot; &quot;[^#'\&quot;\n\\]&quot; &quot;\\|&quot; py-stringlit-re &quot;\\)*&quot;</span>
   <span class="s0">&quot;\\\\$&quot;)</span>
  <span class="s0">&quot;Regular expression matching Python backslash continuation lines.&quot;)</span>
  
<span class="s0">(defconst py-blank-or-comment-re &quot;[ \t]*\\($\\|#\\)&quot;</span>
  <span class="s0">&quot;Regular expression matching a blank or comment line.&quot;)</span>

<span class="s0">(defconst py-outdent-re</span>
  <span class="s0">(concat &quot;\\(&quot; (mapconcat 'identity</span>
			   <span class="s0">'(&quot;else:&quot;</span>
			     <span class="s0">&quot;except\\(\\s +.*\\)?:&quot;</span>
			     <span class="s0">&quot;finally:&quot;</span>
			     <span class="s0">&quot;elif\\s +.*:&quot;)</span>
			   <span class="s0">&quot;\\|&quot;)</span>
	  <span class="s0">&quot;\\)&quot;)</span>
  <span class="s0">&quot;Regular expression matching statements to be dedented one level.&quot;)</span>
  
<span class="s0">(defconst py-block-closing-keywords-re</span>
  <span class="s0">&quot;\\(return\\|raise\\|break\\|continue\\|pass\\)&quot;</span>
  <span class="s0">&quot;Regular expression matching keywords which typically close a block.&quot;)</span>

<span class="s0">(defconst py-no-outdent-re</span>
  <span class="s0">(concat</span>
   <span class="s0">&quot;\\(&quot;</span>
   <span class="s0">(mapconcat 'identity</span>
	      <span class="s0">(list &quot;try:&quot;</span>
		    <span class="s0">&quot;except\\(\\s +.*\\)?:&quot;</span>
		    <span class="s0">&quot;while\\s +.*:&quot;</span>
		    <span class="s0">&quot;for\\s +.*:&quot;</span>
		    <span class="s0">&quot;if\\s +.*:&quot;</span>
		    <span class="s0">&quot;elif\\s +.*:&quot;</span>
		    <span class="s0">(concat py-block-closing-keywords-re &quot;[ \t\n]&quot;)</span>
		    <span class="s0">)</span>
	      <span class="s0">&quot;\\|&quot;)</span>
   <span class="s0">&quot;\\)&quot;)</span>
  <span class="s0">&quot;Regular expression matching lines not to dedent after.&quot;)</span>

<span class="s0">(defconst py-defun-start-re</span>
  <span class="s0">&quot;^\\([ \t]*\\)def[ \t]+\\([a-zA-Z_0-9]+\\)\\|\\(^[a-zA-Z_0-9]+\\)[ \t]*=&quot;</span>
  <span class="s0">;; If you change this, you probably have to change py-current-defun</span>
  <span class="s0">;; as well.  This is only used by py-current-defun to find the name</span>
  <span class="s0">;; for add-log.el.</span>
  <span class="s0">&quot;Regular expression matching a function, method, or variable assignment.&quot;)</span>

<span class="s0">(defconst py-class-start-re &quot;^class[ \t]*\\([a-zA-Z_0-9]+\\)&quot;</span>
  <span class="s0">;; If you change this, you probably have to change py-current-defun</span>
  <span class="s0">;; as well.  This is only used by py-current-defun to find the name</span>
  <span class="s0">;; for add-log.el.</span>
  <span class="s0">&quot;Regular expression for finding a class name.&quot;)</span>

<span class="s0">(defconst py-traceback-line-re</span>
  <span class="s0">&quot;[ \t]+File \&quot;\\([^\&quot;]+\\)\&quot;, line \\([0-9]+\\)&quot;</span>
  <span class="s0">&quot;Regular expression that describes tracebacks.&quot;)</span>



<span class="s0">;; Major mode boilerplate</span>

<span class="s0">;; define a mode-specific abbrev table for those who use such things</span>
<span class="s0">(defvar python-mode-abbrev-table nil</span>
  <span class="s0">&quot;Abbrev table in use in `python-mode' buffers.&quot;)</span>
<span class="s0">(define-abbrev-table 'python-mode-abbrev-table nil)</span>

<span class="s0">(defvar python-mode-hook nil</span>
  <span class="s0">&quot;*Hook called by `python-mode'.&quot;)</span>

<span class="s0">;; In previous version of python-mode.el, the hook was incorrectly</span>
<span class="s0">;; called py-mode-hook, and was not defvar'd.  Deprecate its use.</span>
<span class="s0">(and (fboundp 'make-obsolete-variable)</span>
     <span class="s0">(make-obsolete-variable 'py-mode-hook 'python-mode-hook))</span>

<span class="s0">(defvar py-mode-map ()</span>
  <span class="s0">&quot;Keymap used in `python-mode' buffers.&quot;)</span>
<span class="s0">(if py-mode-map</span>
    <span class="s0">nil</span>
  <span class="s0">(setq py-mode-map (make-sparse-keymap))</span>
  <span class="s0">;; electric keys</span>
  <span class="s0">(define-key py-mode-map &quot;:&quot; 'py-electric-colon)</span>
  <span class="s0">;; indentation level modifiers</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-l&quot;  'py-shift-region-left)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-r&quot;  'py-shift-region-right)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c&lt;&quot;     'py-shift-region-left)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c&gt;&quot;     'py-shift-region-right)</span>
  <span class="s0">;; subprocess commands</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-c&quot;  'py-execute-buffer)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-v&quot;  'py-redefine-class)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-m&quot;  'py-execute-import-or-reload)</span>
  <span class="s0">;; (define-key py-mode-map &quot;\C-c\C-s&quot;  'py-execute-string)</span>
  <span class="s0">;; VR STUDIO ENHANCEMENT</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-s&quot;  'pyd-shell)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c|&quot;     'py-execute-region)</span>
  <span class="s0">(define-key py-mode-map &quot;\e\C-x&quot;    'py-execute-def-or-class)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c!&quot;     'py-shell)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-t&quot;  'py-toggle-shells)</span>
  <span class="s0">;; Caution!  Enter here at your own risk.  We are trying to support</span>
  <span class="s0">;; several behaviors and it gets disgusting. :-( This logic ripped</span>
  <span class="s0">;; largely from CC Mode.</span>
  <span class="s0">;;</span>
  <span class="s0">;; In XEmacs 19, Emacs 19, and Emacs 20, we use this to bind</span>
  <span class="s0">;; backwards deletion behavior to DEL, which both Delete and</span>
  <span class="s0">;; Backspace get translated to.  There's no way to separate this</span>
  <span class="s0">;; behavior in a clean way, so deal with it!  Besides, it's been</span>
  <span class="s0">;; this way since the dawn of time.</span>
  <span class="s0">(if (not (boundp 'delete-key-deletes-forward))</span>
      <span class="s0">(define-key py-mode-map &quot;\177&quot; 'py-electric-backspace)</span>
    <span class="s0">;; However, XEmacs 20 actually achieved enlightenment.  It is</span>
    <span class="s0">;; possible to sanely define both backward and forward deletion</span>
    <span class="s0">;; behavior under X separately (TTYs are forever beyond hope, but</span>
    <span class="s0">;; who cares?  XEmacs 20 does the right thing with these too).</span>
    <span class="s0">(define-key py-mode-map [delete]    'py-electric-delete)</span>
    <span class="s0">(define-key py-mode-map [backspace] 'py-electric-backspace))</span>
  <span class="s0">;; Separate M-BS from C-M-h.  The former should remain</span>
  <span class="s0">;; backward-kill-word.</span>
  <span class="s0">(define-key py-mode-map [(control meta h)] 'py-mark-def-or-class)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-k&quot;  'py-mark-block)</span>
  <span class="s0">;; Miscellaneous</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c:&quot;     'py-guess-indent-offset)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\t&quot;    'py-indent-region)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-n&quot;  'py-next-statement)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-p&quot;  'py-previous-statement)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-u&quot;  'py-goto-block-up)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c#&quot;     'py-comment-region)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c?&quot;     'py-describe-mode)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-hm&quot; 'py-describe-mode)</span>
  <span class="s0">(define-key py-mode-map &quot;\e\C-a&quot;    'py-beginning-of-def-or-class)</span>
  <span class="s0">(define-key py-mode-map &quot;\e\C-e&quot;    'py-end-of-def-or-class)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c-&quot;     'py-up-exception)</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c=&quot;     'py-down-exception)</span>
  <span class="s0">;; stuff that is `standard' but doesn't interface well with</span>
  <span class="s0">;; python-mode, which forces us to rebind to special commands</span>
  <span class="s0">(define-key py-mode-map &quot;\C-xnd&quot;    'py-narrow-to-defun)</span>
  <span class="s0">;; information</span>
  <span class="s0">(define-key py-mode-map &quot;\C-c\C-b&quot; 'py-submit-bug-report)</span>
  <span class="s0">;(define-key py-mode-map &quot;\C-c\C-v&quot; 'py-version)</span>
  <span class="s0">;; shadow global bindings for newline-and-indent w/ the py- version.</span>
  <span class="s0">;; BAW - this is extremely bad form, but I'm not going to change it</span>
  <span class="s0">;; for now.</span>
  <span class="s0">(mapcar #'(lambda (key)</span>
	      <span class="s0">(define-key py-mode-map key 'py-newline-and-indent))</span>
	  <span class="s0">(where-is-internal 'newline-and-indent))</span>
  <span class="s0">;; Force RET to be py-newline-and-indent even if it didn't get</span>
  <span class="s0">;; mapped by the above code.  motivation: Emacs' default binding for</span>
  <span class="s0">;; RET is `newline' and C-j is `newline-and-indent'.  Most Pythoneers</span>
  <span class="s0">;; expect RET to do a `py-newline-and-indent' and any Emacsers who</span>
  <span class="s0">;; dislike this are probably knowledgeable enough to do a rebind.</span>
  <span class="s0">;; However, we do *not* change C-j since many Emacsers have already</span>
  <span class="s0">;; swapped RET and C-j and they don't want C-j bound to `newline' to </span>
  <span class="s0">;; change.</span>
  <span class="s0">(define-key py-mode-map &quot;\C-m&quot; 'py-newline-and-indent)</span>
  <span class="s0">)</span>

<span class="s0">(defvar py-mode-output-map nil</span>
  <span class="s0">&quot;Keymap used in *Python Output* buffers.&quot;)</span>
<span class="s0">(if py-mode-output-map</span>
    <span class="s0">nil</span>
  <span class="s0">(setq py-mode-output-map (make-sparse-keymap))</span>
  <span class="s0">(define-key py-mode-output-map [button2]  'py-mouseto-exception)</span>
  <span class="s0">(define-key py-mode-output-map &quot;\C-c\C-c&quot; 'py-goto-exception)</span>
  <span class="s0">;; TBD: Disable all self-inserting keys.  This is bogus, we should</span>
  <span class="s0">;; really implement this as *Python Output* buffer being read-only</span>
  <span class="s0">(mapcar #' (lambda (key)</span>
	       <span class="s0">(define-key py-mode-output-map key</span>
		 <span class="s0">#'(lambda () (interactive) (beep))))</span>
	     <span class="s0">(where-is-internal 'self-insert-command))</span>
  <span class="s0">)</span>

<span class="s0">(defvar py-shell-map nil</span>
  <span class="s0">&quot;Keymap used in *Python* shell buffers.&quot;)</span>
<span class="s0">(if py-shell-map</span>
    <span class="s0">nil</span>
  <span class="s0">(setq py-shell-map (copy-keymap comint-mode-map))</span>
  <span class="s0">(define-key py-shell-map [tab]   'tab-to-tab-stop)</span>
  <span class="s0">(define-key py-shell-map &quot;\C-c-&quot; 'py-up-exception)</span>
  <span class="s0">(define-key py-shell-map &quot;\C-c=&quot; 'py-down-exception)</span>
  <span class="s0">;; VR STUDIO ENHANCEMENTS</span>
  <span class="s0">(define-key py-shell-map &quot;\C-d&quot;  'comint-delchar-or-maybe-python-resume)</span>
  <span class="s0">(define-key py-shell-map [return] 'comint-interrupt-subjob-or-maybe-return-curbuf)</span>
  <span class="s0">(define-key py-shell-map [C-return] 'comint-interrupt-subjob-or-maybe-return)</span>
  <span class="s0">(define-key py-shell-map &quot;\C-c\C-r&quot; 'python-resume)</span>
  <span class="s0">(define-key py-shell-map &quot;\C-c\C-s&quot; 'pyd-shell)</span>
  <span class="s0">(define-key py-shell-map &quot;\C-c\C-f&quot; 'py-kill-shells)</span>
  <span class="s0">)</span>

<span class="s0">(defvar py-mode-syntax-table nil</span>
  <span class="s0">&quot;Syntax table used in `python-mode' buffers.&quot;)</span>
<span class="s0">(if py-mode-syntax-table</span>
    <span class="s0">nil</span>
  <span class="s0">(setq py-mode-syntax-table (make-syntax-table))</span>
  <span class="s0">(modify-syntax-entry ?\( &quot;()&quot; py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\) &quot;)(&quot; py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\[ &quot;(]&quot; py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\] &quot;)[&quot; py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\{ &quot;(}&quot; py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\} &quot;){&quot; py-mode-syntax-table)</span>
  <span class="s0">;; Add operator symbols misassigned in the std table</span>
  <span class="s0">(modify-syntax-entry ?\$ &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\% &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\&amp; &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\* &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\+ &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\- &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\/ &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\&lt; &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\= &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\&gt; &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\| &quot;.&quot;  py-mode-syntax-table)</span>
  <span class="s0">;; For historical reasons, underscore is word class instead of</span>
  <span class="s0">;; symbol class.  GNU conventions say it should be symbol class, but</span>
  <span class="s0">;; there's a natural conflict between what major mode authors want</span>
  <span class="s0">;; and what users expect from `forward-word' and `backward-word'.</span>
  <span class="s0">;; Guido and I have hashed this out and have decided to keep</span>
  <span class="s0">;; underscore in word class.  If you're tempted to change it, try</span>
  <span class="s0">;; binding M-f and M-b to py-forward-into-nomenclature and</span>
  <span class="s0">;; py-backward-into-nomenclature instead.  This doesn't help in all</span>
  <span class="s0">;; situations where you'd want the different behavior</span>
  <span class="s0">;; (e.g. backward-kill-word).</span>
  <span class="s0">(modify-syntax-entry ?\_ &quot;w&quot;  py-mode-syntax-table)</span>
  <span class="s0">;; Both single quote and double quote are string delimiters</span>
  <span class="s0">(modify-syntax-entry ?\' &quot;\&quot;&quot; py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\&quot; &quot;\&quot;&quot; py-mode-syntax-table)</span>
  <span class="s0">;; backquote is open and close paren</span>
  <span class="s0">(modify-syntax-entry ?\` &quot;$&quot;  py-mode-syntax-table)</span>
  <span class="s0">;; comment delimiters</span>
  <span class="s0">(modify-syntax-entry ?\# &quot;&lt;&quot;  py-mode-syntax-table)</span>
  <span class="s0">(modify-syntax-entry ?\n &quot;&gt;&quot;  py-mode-syntax-table)</span>
  <span class="s0">)</span>



<span class="s0">;; Utilities</span>

<span class="s0">(defmacro py-safe (&amp;rest body)</span>
  <span class="s0">&quot;Safely execute BODY, return nil if an error occurred.&quot;</span>
  <span class="s0">(` (condition-case nil</span>
	 <span class="s0">(progn (,@ body))</span>
       <span class="s0">(error nil))))</span>

<span class="s0">(defsubst py-keep-region-active ()</span>
  <span class="s0">&quot;Keep the region active in XEmacs.&quot;</span>
  <span class="s0">;; Ignore byte-compiler warnings you might see.  Also note that</span>
  <span class="s0">;; FSF's Emacs 19 does it differently; its policy doesn't require us</span>
  <span class="s0">;; to take explicit action.</span>
  <span class="s0">(and (boundp 'zmacs-region-stays)</span>
       <span class="s0">(setq zmacs-region-stays t)))</span>

<span class="s0">(defsubst py-point (position)</span>
  <span class="s0">&quot;Returns the value of point at certain commonly referenced POSITIONs.</span>
<span class="s0">POSITION can be one of the following symbols:</span>

  <span class="s0">bol  -- beginning of line</span>
  <span class="s0">eol  -- end of line</span>
  <span class="s0">bod  -- beginning of def or class</span>
  <span class="s0">eod  -- end of def or class</span>
  <span class="s0">bob  -- beginning of buffer</span>
  <span class="s0">eob  -- end of buffer</span>
  <span class="s0">boi  -- back to indentation</span>
  <span class="s0">bos  -- beginning of statement</span>

<span class="s0">This function does not modify point or mark.&quot;</span>
  <span class="s0">(let ((here (point)))</span>
    <span class="s0">(cond</span>
     <span class="s0">((eq position 'bol) (beginning-of-line))</span>
     <span class="s0">((eq position 'eol) (end-of-line))</span>
     <span class="s0">((eq position 'bod) (py-beginning-of-def-or-class))</span>
     <span class="s0">((eq position 'eod) (py-end-of-def-or-class))</span>
     <span class="s0">;; Kind of funny, I know, but useful for py-up-exception.</span>
     <span class="s0">((eq position 'bob) (beginning-of-buffer))</span>
     <span class="s0">((eq position 'eob) (end-of-buffer))</span>
     <span class="s0">((eq position 'boi) (back-to-indentation))</span>
     <span class="s0">((eq position 'bos) (py-goto-initial-line))</span>
     <span class="s0">(t (error &quot;Unknown buffer position requested: %s&quot; position))</span>
     <span class="s0">)</span>
    <span class="s0">(prog1</span>
	<span class="s0">(point)</span>
      <span class="s0">(goto-char here))))</span>

<span class="s0">(defsubst py-highlight-line (from to file line)</span>
  <span class="s0">(cond</span>
   <span class="s0">((fboundp 'make-extent)</span>
    <span class="s0">;; XEmacs</span>
    <span class="s0">(let ((e (make-extent from to)))</span>
      <span class="s0">(set-extent-property e 'mouse-face 'highlight)</span>
      <span class="s0">(set-extent-property e 'py-exc-info (cons file line))</span>
      <span class="s0">(set-extent-property e 'keymap py-mode-output-map)))</span>
   <span class="s0">(t</span>
    <span class="s0">;; Emacs -- Please port this!</span>
    <span class="s0">)</span>
   <span class="s0">))</span>

<span class="s0">(defun py-in-literal (&amp;optional lim)</span>
  <span class="s0">&quot;Return non-nil if point is in a Python literal (a comment or string).</span>
<span class="s0">Optional argument LIM indicates the beginning of the containing form,</span>
<span class="s0">i.e. the limit on how far back to scan.&quot;</span>
  <span class="s0">;; This is the version used for non-XEmacs, which has a nicer</span>
  <span class="s0">;; interface.</span>
  <span class="s0">;;</span>
  <span class="s0">;; WARNING: Watch out for infinite recursion.</span>
  <span class="s0">(let* ((lim (or lim (py-point 'bod)))</span>
	 <span class="s0">(state (parse-partial-sexp lim (point))))</span>
    <span class="s0">(cond</span>
     <span class="s0">((nth 3 state) 'string)</span>
     <span class="s0">((nth 4 state) 'comment)</span>
     <span class="s0">(t nil))))</span>

<span class="s0">;; XEmacs has a built-in function that should make this much quicker.</span>
<span class="s0">;; In this case, lim is ignored</span>
<span class="s0">(defun py-fast-in-literal (&amp;optional lim)</span>
  <span class="s0">&quot;Fast version of `py-in-literal', used only by XEmacs.</span>
<span class="s0">Optional LIM is ignored.&quot;</span>
  <span class="s0">;; don't have to worry about context == 'block-comment</span>
  <span class="s0">(buffer-syntactic-context))</span>

<span class="s0">(if (fboundp 'buffer-syntactic-context)</span>
    <span class="s0">(defalias 'py-in-literal 'py-fast-in-literal))</span>



<span class="s0">;; Menu definitions, only relevent if you have the easymenu.el package</span>
<span class="s0">;; (standard in the latest Emacs 19 and XEmacs 19 distributions).</span>
<span class="s0">(defvar py-menu nil</span>
  <span class="s0">&quot;Menu for Python Mode.</span>
<span class="s0">This menu will get created automatically if you have the `easymenu'</span>
<span class="s0">package.  Note that the latest X/Emacs releases contain this package.&quot;)</span>

<span class="s0">(and (py-safe (require 'easymenu) t)</span>
     <span class="s0">(easy-menu-define</span>
      <span class="s0">py-menu py-mode-map &quot;Python Mode menu&quot;</span>
      <span class="s0">'(&quot;Python&quot;</span>
	<span class="s0">[&quot;Comment Out Region&quot;   py-comment-region  (mark)]</span>
	<span class="s0">[&quot;Uncomment Region&quot;     (py-comment-region (point) (mark) '(4)) (mark)]</span>
	<span class="s0">&quot;-&quot;</span>
	<span class="s0">[&quot;Mark current block&quot;   py-mark-block t]</span>
	<span class="s0">[&quot;Mark current def&quot;     py-mark-def-or-class t]</span>
	<span class="s0">[&quot;Mark current class&quot;   (py-mark-def-or-class t) t]</span>
	<span class="s0">&quot;-&quot;</span>
	<span class="s0">[&quot;Shift region left&quot;    py-shift-region-left (mark)]</span>
	<span class="s0">[&quot;Shift region right&quot;   py-shift-region-right (mark)]</span>
	<span class="s0">&quot;-&quot;</span>
	<span class="s0">[&quot;Import/reload file&quot;   py-execute-import-or-reload t]</span>
	<span class="s0">[&quot;Execute buffer&quot;       py-execute-buffer t]</span>
	<span class="s0">[&quot;Execute region&quot;       py-execute-region (mark)]</span>
	<span class="s0">[&quot;Execute def or class&quot; py-execute-def-or-class (mark)]</span>
	<span class="s0">[&quot;Execute string&quot;       py-execute-string t]</span>
	<span class="s0">[&quot;Redefine class&quot;       py-redefine-class t]</span>
	<span class="s0">[&quot;Start interpreter...&quot; py-shell t]</span>
	<span class="s0">&quot;-&quot;</span>
	<span class="s0">[&quot;Go to start of block&quot; py-goto-block-up t]</span>
	<span class="s0">[&quot;Go to start of class&quot; (py-beginning-of-def-or-class t) t]</span>
	<span class="s0">[&quot;Move to end of class&quot; (py-end-of-def-or-class t) t]</span>
	<span class="s0">[&quot;Move to start of def&quot; py-beginning-of-def-or-class t]</span>
	<span class="s0">[&quot;Move to end of def&quot;   py-end-of-def-or-class t]</span>
	<span class="s0">&quot;-&quot;</span>
	<span class="s0">[&quot;Describe mode&quot;        py-describe-mode t]</span>
	<span class="s0">)))</span>



<span class="s0">;; Imenu definitions</span>
<span class="s0">(defvar py-imenu-class-regexp</span>
  <span class="s0">(concat; &lt;&lt;classes&gt;&gt;</span>
   <span class="s0">&quot;\\(&quot;;</span>
   <span class="s0">&quot;^[ \t]*&quot;; newline and maybe whitespace</span>
   <span class="s0">&quot;\\(class[ \t]+[a-zA-Z0-9_]+\\)&quot;; class name</span>
					<span class="s0">; possibly multiple superclasses</span>
   <span class="s0">&quot;\\([ \t]*\\((\\([a-zA-Z0-9_,. \t\n]\\)*)\\)?\\)&quot;</span>
   <span class="s0">&quot;[ \t]*:&quot;; and the final :</span>
   <span class="s0">&quot;\\)&quot;; &gt;&gt;classes&lt;&lt;</span>
   <span class="s0">)</span>
  <span class="s0">&quot;Regexp for Python classes for use with the Imenu package.&quot;</span>
  <span class="s0">)</span>

<span class="s0">(defvar py-imenu-method-regexp</span>
  <span class="s0">(concat                               ; &lt;&lt;methods and functions&gt;&gt;</span>
   <span class="s0">&quot;\\(&quot;                                ; </span>
   <span class="s0">&quot;^[ \t]*&quot;                            ; new line and maybe whitespace</span>
   <span class="s0">&quot;\\(def[ \t]+&quot;                       ; function definitions start with def</span>
   <span class="s0">&quot;\\([a-zA-Z0-9_]+\\)&quot;                ;   name is here</span>
					<span class="s0">;   function arguments...</span>
<span class="s0">;;   &quot;[ \t]*(\\([-+/a-zA-Z0-9_=,\* \t\n.()\&quot;'#]*\\))&quot;</span>
   <span class="s0">&quot;[ \t]*(\\([^:#]*\\))&quot;</span>
   <span class="s0">&quot;\\)&quot;                                ; end of def</span>
   <span class="s0">&quot;[ \t]*:&quot;                            ; and then the :</span>
   <span class="s0">&quot;\\)&quot;                                ; &gt;&gt;methods and functions&lt;&lt;</span>
   <span class="s0">)</span>
  <span class="s0">&quot;Regexp for Python methods/functions for use with the Imenu package.&quot;</span>
  <span class="s0">)</span>

<span class="s0">(defvar py-imenu-method-no-arg-parens '(2 8)</span>
  <span class="s0">&quot;Indices into groups of the Python regexp for use with Imenu.</span>

<span class="s0">Using these values will result in smaller Imenu lists, as arguments to</span>
<span class="s0">functions are not listed.</span>

<span class="s0">See the variable `py-imenu-show-method-args-p' for more</span>
<span class="s0">information.&quot;)</span>

<span class="s0">(defvar py-imenu-method-arg-parens '(2 7)</span>
  <span class="s0">&quot;Indices into groups of the Python regexp for use with imenu.</span>
<span class="s0">Using these values will result in large Imenu lists, as arguments to</span>
<span class="s0">functions are listed.</span>

<span class="s0">See the variable `py-imenu-show-method-args-p' for more</span>
<span class="s0">information.&quot;)</span>

<span class="s0">;; Note that in this format, this variable can still be used with the</span>
<span class="s0">;; imenu--generic-function. Otherwise, there is no real reason to have</span>
<span class="s0">;; it.</span>
<span class="s0">(defvar py-imenu-generic-expression</span>
  <span class="s0">(cons</span>
   <span class="s0">(concat </span>
    <span class="s0">py-imenu-class-regexp</span>
    <span class="s0">&quot;\\|&quot;; or...</span>
    <span class="s0">py-imenu-method-regexp</span>
    <span class="s0">)</span>
   <span class="s0">py-imenu-method-no-arg-parens)</span>
  <span class="s0">&quot;Generic Python expression which may be used directly with Imenu.</span>
<span class="s0">Used by setting the variable `imenu-generic-expression' to this value.</span>
<span class="s0">Also, see the function \\[py-imenu-create-index] for a better</span>
<span class="s0">alternative for finding the index.&quot;)</span>

<span class="s0">;; These next two variables are used when searching for the Python</span>
<span class="s0">;; class/definitions. Just saving some time in accessing the</span>
<span class="s0">;; generic-python-expression, really.</span>
<span class="s0">(defvar py-imenu-generic-regexp nil)</span>
<span class="s0">(defvar py-imenu-generic-parens nil)</span>


<span class="s0">(defun py-imenu-create-index-function ()</span>
  <span class="s0">&quot;Python interface function for the Imenu package.</span>
<span class="s0">Finds all Python classes and functions/methods. Calls function</span>
<span class="s0">\\[py-imenu-create-index-engine].  See that function for the details</span>
<span class="s0">of how this works.&quot;</span>
  <span class="s0">(setq py-imenu-generic-regexp (car py-imenu-generic-expression)</span>
	<span class="s0">py-imenu-generic-parens (if py-imenu-show-method-args-p</span>
				    <span class="s0">py-imenu-method-arg-parens</span>
				  <span class="s0">py-imenu-method-no-arg-parens))</span>
  <span class="s0">(goto-char (point-min))</span>
  <span class="s0">;; Warning: When the buffer has no classes or functions, this will</span>
  <span class="s0">;; return nil, which seems proper according to the Imenu API, but</span>
  <span class="s0">;; causes an error in the XEmacs port of Imenu.  Sigh.</span>
  <span class="s0">(py-imenu-create-index-engine nil))</span>

<span class="s0">(defun py-imenu-create-index-engine (&amp;optional start-indent)</span>
  <span class="s0">&quot;Function for finding Imenu definitions in Python.</span>

<span class="s0">Finds all definitions (classes, methods, or functions) in a Python</span>
<span class="s0">file for the Imenu package.</span>

<span class="s0">Returns a possibly nested alist of the form</span>

<span class="s0">(INDEX-NAME . INDEX-POSITION)</span>

<span class="s0">The second element of the alist may be an alist, producing a nested</span>
<span class="s0">list as in</span>

<span class="s0">(INDEX-NAME . INDEX-ALIST)</span>

<span class="s0">This function should not be called directly, as it calls itself</span>
<span class="s0">recursively and requires some setup.  Rather this is the engine for</span>
<span class="s0">the function \\[py-imenu-create-index-function].</span>

<span class="s0">It works recursively by looking for all definitions at the current</span>
<span class="s0">indention level.  When it finds one, it adds it to the alist.  If it</span>
<span class="s0">finds a definition at a greater indentation level, it removes the</span>
<span class="s0">previous definition from the alist. In its place it adds all</span>
<span class="s0">definitions found at the next indentation level.  When it finds a</span>
<span class="s0">definition that is less indented then the current level, it returns</span>
<span class="s0">the alist it has created thus far.</span>

<span class="s0">The optional argument START-INDENT indicates the starting indentation</span>
<span class="s0">at which to continue looking for Python classes, methods, or</span>
<span class="s0">functions.  If this is not supplied, the function uses the indentation</span>
<span class="s0">of the first definition found.&quot;</span>
  <span class="s0">(let (index-alist</span>
<span class="s0">sub-method-alist</span>
<span class="s0">looking-p</span>
<span class="s0">def-name prev-name</span>
<span class="s0">cur-indent def-pos</span>
<span class="s0">(class-paren (first  py-imenu-generic-parens)) </span>
<span class="s0">(def-paren   (second py-imenu-generic-parens)))</span>
    <span class="s0">(setq looking-p</span>
<span class="s0">(re-search-forward py-imenu-generic-regexp (point-max) t))</span>
    <span class="s0">(while looking-p</span>
      <span class="s0">(save-excursion</span>
	<span class="s0">;; used to set def-name to this value but generic-extract-name</span>
	<span class="s0">;; is new to imenu-1.14. this way it still works with</span>
	<span class="s0">;; imenu-1.11</span>
	<span class="s0">;;(imenu--generic-extract-name py-imenu-generic-parens))</span>
	<span class="s0">(let ((cur-paren (if (match-beginning class-paren)</span>
			     <span class="s0">class-paren def-paren)))</span>
	  <span class="s0">(setq def-name</span>
		<span class="s0">(buffer-substring-no-properties (match-beginning cur-paren)</span>
						<span class="s0">(match-end cur-paren))))</span>
	<span class="s0">(save-match-data</span>
	  <span class="s0">(py-beginning-of-def-or-class 'either))</span>
	<span class="s0">(beginning-of-line)</span>
	<span class="s0">(setq cur-indent (current-indentation)))</span>
      <span class="s0">;; HACK: want to go to the next correct definition location.  We</span>
      <span class="s0">;; explicitly list them here but it would be better to have them</span>
      <span class="s0">;; in a list.</span>
      <span class="s0">(setq def-pos</span>
	    <span class="s0">(or (match-beginning class-paren)</span>
		<span class="s0">(match-beginning def-paren)))</span>
      <span class="s0">;; if we don't have a starting indent level, take this one</span>
      <span class="s0">(or start-indent</span>
	  <span class="s0">(setq start-indent cur-indent))</span>
      <span class="s0">;; if we don't have class name yet, take this one</span>
      <span class="s0">(or prev-name</span>
	  <span class="s0">(setq prev-name def-name))</span>
      <span class="s0">;; what level is the next definition on?  must be same, deeper</span>
      <span class="s0">;; or shallower indentation</span>
      <span class="s0">(cond</span>
       <span class="s0">;; at the same indent level, add it to the list...</span>
       <span class="s0">((= start-indent cur-indent)</span>
	<span class="s0">(push (cons def-name def-pos) index-alist))</span>
       <span class="s0">;; deeper indented expression, recurse</span>
       <span class="s0">((&lt; start-indent cur-indent)</span>
	<span class="s0">;; the point is currently on the expression we're supposed to</span>
	<span class="s0">;; start on, so go back to the last expression. The recursive</span>
	<span class="s0">;; call will find this place again and add it to the correct</span>
	<span class="s0">;; list</span>
	<span class="s0">(re-search-backward py-imenu-generic-regexp (point-min) 'move)</span>
	<span class="s0">(setq sub-method-alist (py-imenu-create-index-engine cur-indent))</span>
	<span class="s0">(if sub-method-alist</span>
	    <span class="s0">;; we put the last element on the index-alist on the start</span>
	    <span class="s0">;; of the submethod alist so the user can still get to it.</span>
	    <span class="s0">(let ((save-elmt (pop index-alist)))</span>
	      <span class="s0">(push (cons prev-name</span>
			  <span class="s0">(cons save-elmt sub-method-alist))</span>
		    <span class="s0">index-alist))))</span>
       <span class="s0">;; found less indented expression, we're done.</span>
       <span class="s0">(t </span>
	<span class="s0">(setq looking-p nil)</span>
	<span class="s0">(re-search-backward py-imenu-generic-regexp (point-min) t)))</span>
      <span class="s0">;; end-cond</span>
      <span class="s0">(setq prev-name def-name)</span>
      <span class="s0">(and looking-p</span>
	   <span class="s0">(setq looking-p</span>
		 <span class="s0">(re-search-forward py-imenu-generic-regexp</span>
				    <span class="s0">(point-max) 'move))))</span>
    <span class="s0">(nreverse index-alist)))</span>


<span class="s0">;;;###autoload</span>
<span class="s0">(defun python-mode ()</span>
  <span class="s0">&quot;Major mode for editing Python files.</span>
<span class="s0">To submit a problem report, enter `\\[py-submit-bug-report]' from a</span>
<span class="s0">`python-mode' buffer.  Do `\\[py-describe-mode]' for detailed</span>
<span class="s0">documentation.  To see what version of `python-mode' you are running,</span>
<span class="s0">enter `\\[py-version]'.</span>

<span class="s0">This mode knows about Python indentation, tokens, comments and</span>
<span class="s0">continuation lines.  Paragraphs are separated by blank lines only.</span>

<span class="s0">COMMANDS</span>
<span class="s0">\\{py-mode-map}</span>
<span class="s0">VARIABLES</span>

<span class="s0">py-indent-offset\t\tindentation increment</span>
<span class="s0">py-block-comment-prefix\t\tcomment string used by `comment-region'</span>
<span class="s0">py-python-command\t\tshell command to invoke Python interpreter</span>
<span class="s0">py-temp-directory\t\tdirectory used for temp files (if needed)</span>
<span class="s0">py-beep-if-tab-change\t\tring the bell if `tab-width' is changed&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">;; set up local variables</span>
  <span class="s0">(kill-all-local-variables)</span>
  <span class="s0">(make-local-variable 'font-lock-defaults)</span>
  <span class="s0">(make-local-variable 'paragraph-separate)</span>
  <span class="s0">(make-local-variable 'paragraph-start)</span>
  <span class="s0">(make-local-variable 'require-final-newline)</span>
  <span class="s0">(make-local-variable 'comment-start)</span>
  <span class="s0">(make-local-variable 'comment-end)</span>
  <span class="s0">(make-local-variable 'comment-start-skip)</span>
  <span class="s0">(make-local-variable 'comment-column)</span>
  <span class="s0">(make-local-variable 'comment-indent-function)</span>
  <span class="s0">(make-local-variable 'indent-region-function)</span>
  <span class="s0">(make-local-variable 'indent-line-function)</span>
  <span class="s0">(make-local-variable 'add-log-current-defun-function)</span>
  <span class="s0">;;</span>
  <span class="s0">(set-syntax-table py-mode-syntax-table)</span>
  <span class="s0">(setq major-mode              'python-mode</span>
	<span class="s0">mode-name               &quot;Python&quot;</span>
	<span class="s0">local-abbrev-table      python-mode-abbrev-table</span>
	<span class="s0">font-lock-defaults      '(python-font-lock-keywords)</span>
	<span class="s0">paragraph-separate      &quot;^[ \t]*$&quot;</span>
	<span class="s0">paragraph-start         &quot;^[ \t]*$&quot;</span>
	<span class="s0">require-final-newline   t</span>
	<span class="s0">comment-start           &quot;# &quot;</span>
	<span class="s0">comment-end             &quot;&quot;</span>
	<span class="s0">comment-start-skip      &quot;# *&quot;</span>
	<span class="s0">comment-column          40</span>
	<span class="s0">comment-indent-function 'py-comment-indent-function</span>
	<span class="s0">indent-region-function  'py-indent-region</span>
	<span class="s0">indent-line-function    'py-indent-line</span>
	<span class="s0">;; tell add-log.el how to find the current function/method/variable</span>
	<span class="s0">add-log-current-defun-function 'py-current-defun</span>
	<span class="s0">)</span>
  <span class="s0">(use-local-map py-mode-map)</span>
  <span class="s0">;; add the menu</span>
  <span class="s0">(if py-menu</span>
      <span class="s0">(easy-menu-add py-menu))</span>
  <span class="s0">;; Emacs 19 requires this</span>
  <span class="s0">(if (boundp 'comment-multi-line)</span>
      <span class="s0">(setq comment-multi-line nil))</span>
  <span class="s0">;; Install Imenu if available</span>
  <span class="s0">(when (py-safe (require 'imenu))</span>
    <span class="s0">(setq imenu-create-index-function #'py-imenu-create-index-function)</span>
    <span class="s0">(setq imenu-generic-expression py-imenu-generic-expression)</span>
    <span class="s0">(if (fboundp 'imenu-add-to-menubar)</span>
	<span class="s0">(imenu-add-to-menubar (format &quot;%s-%s&quot; &quot;IM&quot; mode-name)))</span>
    <span class="s0">)</span>
  <span class="s0">;; Run the mode hook.  Note that py-mode-hook is deprecated.</span>
  <span class="s0">(if python-mode-hook</span>
      <span class="s0">(run-hooks 'python-mode-hook)</span>
    <span class="s0">(run-hooks 'py-mode-hook))</span>
  <span class="s0">;; Now do the automagical guessing</span>
  <span class="s0">(if py-smart-indentation</span>
    <span class="s0">(let ((offset py-indent-offset))</span>
      <span class="s0">;; It's okay if this fails to guess a good value</span>
      <span class="s0">(if (and (py-safe (py-guess-indent-offset))</span>
	       <span class="s0">(&lt;= py-indent-offset 8)</span>
	       <span class="s0">(&gt;= py-indent-offset 2))</span>
	  <span class="s0">(setq offset py-indent-offset))</span>
      <span class="s0">(setq py-indent-offset offset)</span>
      <span class="s0">;; Only turn indent-tabs-mode off if tab-width !=</span>
      <span class="s0">;; py-indent-offset.  Never turn it on, because the user must</span>
      <span class="s0">;; have explicitly turned it off.</span>
      <span class="s0">(if (/= tab-width py-indent-offset)</span>
	  <span class="s0">(setq indent-tabs-mode nil))</span>
      <span class="s0">))</span>
  <span class="s0">;; Set the default shell if not already set</span>
  <span class="s0">(when (null py-which-shell)</span>
    <span class="s0">(py-toggle-shells py-default-interpreter))</span>
  <span class="s0">;; Add colors</span>
  <span class="s0">(font-lock-fontify-buffer)</span>
  <span class="s0">;; Make sure we use unix encoding</span>
  <span class="s0">(setq local-write-file-hooks  'Use-Undecided-Unix-Mode)</span>
  <span class="s0">)</span>


<span class="s0">(defun Use-Undecided-Unix-Mode()</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(set-buffer-file-coding-system 'undecided-unix)</span>
  <span class="s0">(message &quot;buffer-file-coding-system: undecided-unix&quot;)</span>
  <span class="s0">nil</span>
  <span class="s0">)</span>

<span class="s0">;; electric characters</span>
<span class="s0">(defun py-outdent-p ()</span>
  <span class="s0">&quot;Returns non-nil if the current line should dedent one level.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(and (progn (back-to-indentation)</span>
		<span class="s0">(looking-at py-outdent-re))</span>
	 <span class="s0">;; short circuit infloop on illegal construct</span>
	 <span class="s0">(not (bobp))</span>
	 <span class="s0">(progn (forward-line -1)</span>
		<span class="s0">(py-goto-initial-line)</span>
		<span class="s0">(back-to-indentation)</span>
		<span class="s0">(while (or (looking-at py-blank-or-comment-re)</span>
			   <span class="s0">(bobp))</span>
		  <span class="s0">(backward-to-indentation 1))</span>
		<span class="s0">(not (looking-at py-no-outdent-re)))</span>
	 <span class="s0">)))</span>
      
<span class="s0">(defun py-electric-colon (arg)</span>
  <span class="s0">&quot;Insert a colon.</span>
<span class="s0">In certain cases the line is dedented appropriately.  If a numeric</span>
<span class="s0">argument ARG is provided, that many colons are inserted</span>
<span class="s0">non-electrically.  Electric behavior is inhibited inside a string or</span>
<span class="s0">comment.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(self-insert-command (prefix-numeric-value arg))</span>
  <span class="s0">;; are we in a string or comment?</span>
  <span class="s0">(if (save-excursion</span>
	<span class="s0">(let ((pps (parse-partial-sexp (save-excursion</span>
					 <span class="s0">(py-beginning-of-def-or-class)</span>
					 <span class="s0">(point))</span>
				       <span class="s0">(point))))</span>
	  <span class="s0">(not (or (nth 3 pps) (nth 4 pps)))))</span>
      <span class="s0">(save-excursion</span>
	<span class="s0">(let ((here (point))</span>
	      <span class="s0">(outdent 0)</span>
	      <span class="s0">(indent (py-compute-indentation t)))</span>
	  <span class="s0">(if (and (not arg)</span>
		   <span class="s0">(py-outdent-p)</span>
		   <span class="s0">(= indent (save-excursion</span>
			       <span class="s0">(py-next-statement -1)</span>
			       <span class="s0">(py-compute-indentation t)))</span>
		   <span class="s0">)</span>
	      <span class="s0">(setq outdent py-indent-offset))</span>
	  <span class="s0">;; Don't indent, only dedent.  This assumes that any lines</span>
	  <span class="s0">;; that are already dedented relative to</span>
	  <span class="s0">;; py-compute-indentation were put there on purpose.  It's</span>
	  <span class="s0">;; highly annoying to have `:' indent for you.  Use TAB, C-c</span>
	  <span class="s0">;; C-l or C-c C-r to adjust.  TBD: Is there a better way to</span>
	  <span class="s0">;; determine this???</span>
	  <span class="s0">(if (&lt; (current-indentation) indent) nil</span>
	    <span class="s0">(goto-char here)</span>
	    <span class="s0">(beginning-of-line)</span>
	    <span class="s0">(delete-horizontal-space)</span>
	    <span class="s0">(indent-to (- indent outdent))</span>
	    <span class="s0">)))))</span>


<span class="s0">;; Python subprocess utilities and filters</span>
<span class="s0">(defun py-execute-file (proc filename)</span>
  <span class="s0">&quot;Send to Python interpreter process PROC \&quot;execfile('FILENAME')\&quot;.</span>
<span class="s0">Make that process's buffer visible and force display.  Also make</span>
<span class="s0">comint believe the user typed this string so that</span>
<span class="s0">`kill-output-from-shell' does The Right Thing.&quot;</span>
  <span class="s0">(let ((procbuf (process-buffer proc))</span>
					<span class="s0">;(comint-scroll-to-bottom-on-output t)</span>
	<span class="s0">;; VR STUDIO DE-HANCEMENT: GET RID OF ANNOYING MESSAGE</span>
	<span class="s0">;(msg (format &quot;## working on region in file %s...\n&quot; filename))</span>
	<span class="s0">(msg &quot;&quot;)</span>
	<span class="s0">(cmd (format &quot;execfile(r'%s')\n&quot; filename)))</span>
    <span class="s0">(unwind-protect</span>
	<span class="s0">(save-excursion</span>
	  <span class="s0">(set-buffer procbuf)</span>
	  <span class="s0">(goto-char (point-max))</span>
	  <span class="s0">(move-marker (process-mark proc) (point))</span>
	  <span class="s0">(funcall (process-filter proc) proc msg)))</span>
    <span class="s0">(process-send-string proc cmd)))</span>

<span class="s0">(defun py-comint-output-filter-function (string)</span>
  <span class="s0">&quot;Watch output for Python prompt and exec next file waiting in queue.</span>
<span class="s0">This function is appropriate for `comint-output-filter-functions'.&quot;</span>
  <span class="s0">(let* ((proc (get-buffer-process (current-buffer)))</span>
	 <span class="s0">(file-queue (gethash proc py-file-queues nil)))</span>
    <span class="s0">;; TBD: this should probably use split-string</span>
    <span class="s0">(when (and file-queue</span>
	       <span class="s0">(or (string-equal string &quot;&gt;&gt;&gt; &quot;)</span>
		   <span class="s0">(and (&gt;= (length string) 5)</span>
			<span class="s0">(string-equal (substring string -5) &quot;\n&gt;&gt;&gt; &quot;))))</span>
      <span class="s0">(let ((entry (car file-queue)))</span>
	<span class="s0">(py-safe (delete-file (car entry)))</span>
	<span class="s0">(setq file-queue (cdr file-queue))</span>
	<span class="s0">(if file-queue</span>
	    <span class="s0">(let ((entry (car file-queue)))</span>
	      <span class="s0">(py-execute-file (cdar entry) (car entry))))</span>
	<span class="s0">))))</span>

<span class="s0">(defun py-postprocess-output-buffer (buf)</span>
  <span class="s0">&quot;Highlight exceptions found in BUF.</span>
<span class="s0">If an exception occurred return t, otherwise return nil.  BUF must exist.&quot;</span>
  <span class="s0">(let (line file bol err-p)</span>
    <span class="s0">(save-excursion</span>
      <span class="s0">(set-buffer buf)</span>
      <span class="s0">(beginning-of-buffer)</span>
      <span class="s0">(while (re-search-forward py-traceback-line-re nil t)</span>
	<span class="s0">(setq file (match-string 1)</span>
	      <span class="s0">line (string-to-int (match-string 2))</span>
	      <span class="s0">bol (py-point 'bol))</span>
	<span class="s0">(py-highlight-line bol (py-point 'eol) file line)))</span>
    <span class="s0">(when (and py-jump-on-exception line)</span>
      <span class="s0">(beep)</span>
      <span class="s0">(py-jump-to-exception file line)</span>
      <span class="s0">(setq err-p t))</span>
    <span class="s0">err-p))</span>



<span class="s0">;;; Subprocess commands</span>

<span class="s0">;; only used when (memq 'broken-temp-names py-emacs-features)</span>
<span class="s0">(defvar py-serial-number 0)</span>
<span class="s0">(defvar py-exception-buffer nil)</span>
<span class="s0">(defconst py-output-buffer &quot;*Python Output*&quot;)</span>
<span class="s0">(make-variable-buffer-local 'py-output-buffer)</span>

<span class="s0">;; for toggling between CPython and JPython</span>
<span class="s0">(defvar py-which-shell nil)</span>
<span class="s0">(defvar ppy-which-shell nil)</span>
<span class="s0">(defvar pyd-which-shell nil)</span>
<span class="s0">(defvar pyo-which-shell nil)</span>
<span class="s0">(defvar py-which-args  py-python-command-args)</span>
<span class="s0">(defvar ppy-which-args  ppy-python-command-args)</span>
<span class="s0">(defvar pyd-which-args  pyd-python-command-args)</span>
<span class="s0">(defvar pyo-which-args  pyo-python-command-args)</span>
<span class="s0">(defvar py-which-bufname-moved &quot;Python&quot;)</span>
<span class="s0">(make-variable-buffer-local 'py-which-shell)</span>
<span class="s0">(make-variable-buffer-local 'ppy-which-shell)</span>
<span class="s0">(make-variable-buffer-local 'pyd-which-shell)</span>
<span class="s0">(make-variable-buffer-local 'pyo-which-shell)</span>
<span class="s0">(make-variable-buffer-local 'py-which-args)</span>
<span class="s0">(make-variable-buffer-local 'ppy-which-args)</span>
<span class="s0">(make-variable-buffer-local 'pyd-which-args)</span>
<span class="s0">(make-variable-buffer-local 'pyo-which-args)</span>
<span class="s0">(make-variable-buffer-local 'py-which-bufname-moved)</span>
<span class="s0">(make-variable-buffer-local 'ppy-which-bufname)</span>
<span class="s0">(make-variable-buffer-local 'pyd-which-bufname)</span>
<span class="s0">(make-variable-buffer-local 'pyo-which-bufname)</span>

<span class="s0">(defun py-toggle-shells (arg)</span>
  <span class="s0">&quot;Toggles between the CPython and JPython shells.</span>

<span class="s0">With positive argument ARG (interactively \\[universal-argument]),</span>
<span class="s0">uses the CPython shell, with negative ARG uses the JPython shell, and</span>
<span class="s0">with a zero argument, toggles the shell.</span>

<span class="s0">Programmatically, ARG can also be one of the symbols `cpython' or</span>
<span class="s0">`jpython', equivalent to positive arg and negative arg respectively.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">;; default is to toggle</span>
  <span class="s0">(if (null arg)</span>
      <span class="s0">(setq arg 0))</span>
  <span class="s0">;; preprocess arg</span>
  <span class="s0">(cond</span>
   <span class="s0">((equal arg 0)</span>
    <span class="s0">;; toggle</span>
    <span class="s0">(if (string-equal py-which-bufname &quot;Python&quot;)</span>
	<span class="s0">(setq arg -1)</span>
      <span class="s0">(setq arg 1)))</span>
   <span class="s0">((equal arg 'cpython) (setq arg 1))</span>
   <span class="s0">((equal arg 'jpython) (setq arg -1)))</span>
  <span class="s0">(let (msg)</span>
    <span class="s0">(cond</span>
     <span class="s0">((&lt; 0 arg)</span>
      <span class="s0">;; set to CPython</span>
      <span class="s0">(setq py-which-shell py-python-command</span>
	    <span class="s0">ppy-which-shell ppy-python-command</span>
	    <span class="s0">pyd-which-shell pyd-python-command</span>
	    <span class="s0">pyo-which-shell pyo-python-command</span>
	    <span class="s0">py-which-args py-python-command-args</span>
	    <span class="s0">ppy-which-args ppy-python-command-args</span>
	    <span class="s0">pyd-which-args pyd-python-command-args</span>
	    <span class="s0">pyo-which-args pyo-python-command-args</span>
	    <span class="s0">py-which-bufname &quot;Python&quot;</span>
	    <span class="s0">msg &quot;CPython&quot;</span>
	    <span class="s0">mode-name &quot;Python&quot;))</span>
     <span class="s0">((&gt; 0 arg)</span>
      <span class="s0">(setq py-which-shell py-jpython-command</span>
	    <span class="s0">ppy-which-shell ppy-jpython-command</span>
	    <span class="s0">pyd-which-shell pyd-python-command</span>
	    <span class="s0">pyo-which-shell pyo-python-command</span>
	    <span class="s0">py-which-args py-jpython-command-args</span>
	    <span class="s0">py-which-bufname &quot;JPython&quot;</span>
	    <span class="s0">msg &quot;JPython&quot;</span>
	    <span class="s0">mode-name &quot;JPython&quot;))</span>
     <span class="s0">)</span>
    <span class="s0">(message &quot;Using the %s shell&quot; msg)</span>
    <span class="s0">(setq py-output-buffer (format &quot;*%s Output*&quot; py-which-bufname))))</span>

<span class="s0">(defun py-kill-shells ()</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(save-current-buffer</span>
    <span class="s0">(for-all-py-procs</span>
     <span class="s0">(lambda (proc)</span>
       <span class="s0">(let ((procbuf (process-buffer proc)))</span>
	 <span class="s0">(set-buffer procbuf)</span>
	 <span class="s0">(comint-send-eof)</span>
	 <span class="s0">(py-point-to-max proc)</span>
	 <span class="s0">)</span>
       <span class="s0">)</span>
     <span class="s0">)</span>
    <span class="s0">)</span>
  <span class="s0">)</span>

<span class="s0">;;;###autoload</span>
<span class="s0">(defun py-shell (&amp;optional argprompt)</span>
  <span class="s0">&quot;Start an interactive Python interpreter in another window.</span>
<span class="s0">This is like Shell mode, except that Python is running in the window</span>
<span class="s0">instead of a shell.  See the `Interactive Shell' and `Shell Mode'</span>
<span class="s0">sections of the Emacs manual for details, especially for the key</span>
<span class="s0">bindings active in the `*Python*' buffer.</span>

<span class="s0">With optional \\[universal-argument], the user is prompted for the</span>
<span class="s0">flags to pass to the Python interpreter.  This has no effect when this</span>
<span class="s0">command is used to switch to an existing process, only when a new</span>
<span class="s0">process is started.  If you use this, you will probably want to ensure</span>
<span class="s0">that the current arguments are retained (they will be included in the</span>
<span class="s0">prompt).  This argument is ignored when this function is called</span>
<span class="s0">programmatically, or when running in Emacs 19.34 or older.</span>

<span class="s0">Note: You can toggle between using the CPython interpreter and the</span>
<span class="s0">JPython interpreter by hitting \\[py-toggle-shells].  This toggles</span>
<span class="s0">buffer local variables which control whether all your subshell</span>
<span class="s0">interactions happen to the `*JPython*' or `*Python*' buffers (the</span>
<span class="s0">latter is the name used for the CPython buffer).</span>

<span class="s0">Warning: Don't use an interactive Python if you change sys.ps1 or</span>
<span class="s0">sys.ps2 from their default values, or if you're running code that</span>
<span class="s0">prints `&gt;&gt;&gt; ' or `... ' at the start of a line.  `python-mode' can't</span>
<span class="s0">distinguish your output from Python's output, and assumes that `&gt;&gt;&gt; '</span>
<span class="s0">at the start of a line is a prompt from Python.  Similarly, the Emacs</span>
<span class="s0">Shell mode code assumes that both `&gt;&gt;&gt; ' and `... ' at the start of a</span>
<span class="s0">line are Python prompts.  Bad things can happen if you fool either</span>
<span class="s0">mode.</span>

<span class="s0">Warning:  If you do any editing *in* the process buffer *while* the</span>
<span class="s0">buffer is accepting output from Python, do NOT attempt to `undo' the</span>
<span class="s0">changes.  Some of the output (nowhere near the parts you changed!) may</span>
<span class="s0">be lost if you do.  This appears to be an Emacs bug, an unfortunate</span>
<span class="s0">interaction between undo and process filters; the same problem exists in</span>
<span class="s0">non-Python process buffers using the default (Emacs-supplied) process</span>
<span class="s0">filter.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">;; Set the default shell if not already set</span>
  <span class="s0">(when (null py-which-shell)</span>
    <span class="s0">(py-toggle-shells py-default-interpreter))</span>
  <span class="s0">(let ((args py-which-args))</span>
    <span class="s0">(when (and argprompt</span>
	       <span class="s0">(interactive-p)</span>
	       <span class="s0">(fboundp 'split-string))</span>
      <span class="s0">;; TBD: Perhaps force &quot;-i&quot; in the final list?</span>
      <span class="s0">(setq args (split-string</span>
		  <span class="s0">(read-string (concat py-which-bufname</span>
				       <span class="s0">&quot; arguments: &quot;)</span>
			       <span class="s0">(concat</span>
				<span class="s0">(mapconcat 'identity py-which-args &quot; &quot;) &quot; &quot;)</span>
			       <span class="s0">))))</span>
    <span class="s0">(switch-to-buffer ;; -other-window</span>
     <span class="s0">(apply 'make-comint py-which-bufname py-which-shell nil args))</span>
    <span class="s0">(make-local-variable 'comint-prompt-regexp)</span>
    <span class="s0">(setq comint-prompt-regexp &quot;^&gt;&gt;&gt; \\|^[.][.][.] \\|^(pdb) &quot;)</span>
    <span class="s0">(add-hook 'comint-output-filter-functions</span>
	      <span class="s0">'py-comint-output-filter-function)</span>
    <span class="s0">(set-syntax-table py-mode-syntax-table)</span>
    <span class="s0">(use-local-map py-shell-map)</span>
    <span class="s0">))</span>

<span class="s0">(defun pyd-shell (&amp;optional argprompt)</span>
  <span class="s0">&quot;This is Jesse's hacked version of py-shell which runs the debug python&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">;; Set the default shell if not already set</span>
  <span class="s0">(when (null pyd-which-shell)</span>
    <span class="s0">(py-toggle-shells py-default-interpreter))</span>
  <span class="s0">(let ((args pyd-which-args))</span>
    <span class="s0">(when (and argprompt</span>
	       <span class="s0">(interactive-p)</span>
	       <span class="s0">(fboundp 'split-string))</span>
      <span class="s0">;; TBD: Perhaps force &quot;-i&quot; in the final list?</span>
      <span class="s0">(setq args (split-string</span>
		  <span class="s0">(read-string (concat py-which-bufname</span>
				       <span class="s0">&quot; arguments: &quot;)</span>
			       <span class="s0">(concat</span>
				<span class="s0">(mapconcat 'identity py-which-args &quot; &quot;) &quot; &quot;)</span>
			       <span class="s0">))))</span>
    <span class="s0">(switch-to-buffer ;; -other-window</span>
     <span class="s0">(apply 'make-comint py-which-bufname pyd-which-shell nil args))</span>
    <span class="s0">(make-local-variable 'comint-prompt-regexp)</span>
    <span class="s0">(setq comint-prompt-regexp &quot;^&gt;&gt;&gt; \\|^[.][.][.] \\|^(pdb) &quot;)</span>
    <span class="s0">(add-hook 'comint-output-filter-functions</span>
	      <span class="s0">'py-comint-output-filter-function)</span>
    <span class="s0">(set-syntax-table py-mode-syntax-table)</span>
    <span class="s0">(use-local-map py-shell-map)</span>
    <span class="s0">))</span>

<span class="s0">(defun pyo-shell (&amp;optional argprompt)</span>
  <span class="s0">&quot;This is Jesse's hacked version of py-shell which runs the optimized python&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">;; Set the default shell if not already set</span>
  <span class="s0">(when (null pyo-which-shell)</span>
    <span class="s0">(py-toggle-shells py-default-interpreter))</span>
  <span class="s0">(let ((args pyo-which-args))</span>
    <span class="s0">(when (and argprompt</span>
	       <span class="s0">(interactive-p)</span>
	       <span class="s0">(fboundp 'split-string))</span>
      <span class="s0">;; TBD: Perhaps force &quot;-i&quot; in the final list?</span>
      <span class="s0">(setq args (split-string</span>
		  <span class="s0">(read-string (concat py-which-bufname</span>
				       <span class="s0">&quot; arguments: &quot;)</span>
			       <span class="s0">(concat</span>
				<span class="s0">(mapconcat 'identity py-which-args &quot; &quot;) &quot; &quot;)</span>
			       <span class="s0">))))</span>
    <span class="s0">(switch-to-buffer ;; -other-window</span>
     <span class="s0">(apply 'make-comint py-which-bufname pyo-which-shell nil args))</span>
    <span class="s0">(make-local-variable 'comint-prompt-regexp)</span>
    <span class="s0">(setq comint-prompt-regexp &quot;^&gt;&gt;&gt; \\|^[.][.][.] \\|^(pdb) &quot;)</span>
    <span class="s0">(add-hook 'comint-output-filter-functions</span>
	      <span class="s0">'py-comint-output-filter-function)</span>
    <span class="s0">(set-syntax-table py-mode-syntax-table)</span>
    <span class="s0">(use-local-map py-shell-map)</span>
    <span class="s0">))</span>



<span class="s0">(defun ppy-shell (&amp;optional argprompt)</span>
  <span class="s0">&quot;This is Joe's hacked version of py-shell which runs ppython for linux&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">;; Set the default shell if not already set</span>
  <span class="s0">(when (null ppy-which-shell)</span>
    <span class="s0">(py-toggle-shells py-default-interpreter))</span>
  <span class="s0">(let ((args ppy-which-args))</span>
    <span class="s0">(when (and argprompt</span>
	       <span class="s0">(interactive-p)</span>
	       <span class="s0">(fboundp 'split-string))</span>
      <span class="s0">;; TBD: Perhaps force &quot;-i&quot; in the final list?</span>
      <span class="s0">(setq args (split-string</span>
		  <span class="s0">(read-string (concat py-which-bufname</span>
				       <span class="s0">&quot; arguments: &quot;)</span>
			       <span class="s0">(concat</span>
				<span class="s0">(mapconcat 'identity py-which-args &quot; &quot;) &quot; &quot;)</span>
			       <span class="s0">))))</span>
    <span class="s0">(switch-to-buffer ;; -other-window</span>
     <span class="s0">(apply 'make-comint py-which-bufname ppy-which-shell nil args))</span>
    <span class="s0">(make-local-variable 'comint-prompt-regexp)</span>
    <span class="s0">(setq comint-prompt-regexp &quot;^&gt;&gt;&gt; \\|^[.][.][.] \\|^(pdb) &quot;)</span>
    <span class="s0">(add-hook 'comint-output-filter-functions</span>
	      <span class="s0">'py-comint-output-filter-function)</span>
    <span class="s0">(set-syntax-table py-mode-syntax-table)</span>
    <span class="s0">(use-local-map py-shell-map)</span>
    <span class="s0">))</span>

<span class="s0">(defun py-shell-named (bufname)</span>
  <span class="s0">&quot;This is Darren's hacked version of py-shell that allows for multiple</span>
   <span class="s0">Python shells in a single Emacs window via different buffer names.</span>
   <span class="s0">Creates a buffer named *Python-bufname*</span>
   <span class="s0">&quot;</span>
  <span class="s0">(interactive &quot;sShell Name: &quot;)</span>
  <span class="s0">;; Set the default shell if not already set</span>
  <span class="s0">(when (null py-which-shell)</span>
    <span class="s0">(py-toggle-shells py-default-interpreter))</span>
  <span class="s0">(let ((bname py-which-bufname))</span>
    <span class="s0">(when bufname</span>
      <span class="s0">(setq bname (concat py-which-bufname &quot;-&quot; bufname)))</span>
    <span class="s0">(switch-to-buffer ;; -other-window</span>
     <span class="s0">(apply 'make-comint bname py-which-shell nil py-which-args))</span>
    <span class="s0">(make-local-variable 'comint-prompt-regexp)</span>
    <span class="s0">(setq comint-prompt-regexp &quot;^&gt;&gt;&gt; \\|^[.][.][.] \\|^(pdb) &quot;)</span>
    <span class="s0">(add-hook 'comint-output-filter-functions</span>
             <span class="s0">'py-comint-output-filter-function)</span>
    <span class="s0">(set-syntax-table py-mode-syntax-table)</span>
    <span class="s0">(use-local-map py-shell-map))</span>
  <span class="s0">)</span>

<span class="s0">(defun py-start-process (name command)</span>
  <span class="s0">(let ((bufname (format &quot;*Python-%s*&quot; name))</span>
	<span class="s0">(macro (format &quot;%s\r&quot; command))</span>
	<span class="s0">(curbuf (current-buffer))</span>
	<span class="s0">(newbuf nil))</span>
    <span class="s0">(py-shell-named name)</span>
    <span class="s0">(switch-to-buffer bufname)</span>
    <span class="s0">(setq newbuf (current-buffer))</span>
    <span class="s0">(execute-kbd-macro macro)</span>
    <span class="s0">(py-point-to-max (get-buffer-process (current-buffer)))</span>
    <span class="s0">(switch-to-buffer curbuf)</span>
    <span class="s0">; make sure that the new buffer is visible</span>
    <span class="s0">(display-buffer newbuf)</span>
    <span class="s0">)</span>
  <span class="s0">)</span>

<span class="s0">(defun is-py-bufname (bufname)</span>
  <span class="s0">(and (eq (compare-strings py-which-bufname 0 (length py-which-bufname)</span>
			    <span class="s0">bufname 0 (length py-which-bufname)) t)</span>
       <span class="s0">(not (string-equal bufname &quot;Python Output&quot;)))</span>
  <span class="s0">)</span>

<span class="s0">(defun is-py-proc (proc)</span>
  <span class="s0">(is-py-bufname (process-name proc))</span>
<span class="s0">)</span>

<span class="s0">(defun for-all-py-procs (callback)</span>
  <span class="s0">&quot;Call a function for each python process. Callback must accept process.</span>
  <span class="s0">If args are provided they will be passed to callback before process.&quot;</span>
  <span class="s0">;; run through all the Python processes and call the callback</span>
  <span class="s0">(mapcar</span>
   <span class="s0">(lambda (proc)</span>
     <span class="s0">(if (is-py-proc proc)</span>
        <span class="s0">(let ()</span>
          <span class="s0">(apply callback (list proc))</span>
          <span class="s0">)</span>
       <span class="s0">)</span>
     <span class="s0">)</span>
   <span class="s0">(process-list)</span>
   <span class="s0">)</span>
  <span class="s0">)</span>

<span class="s0">(defun py-clear-queues ()</span>
  <span class="s0">&quot;Clear the queue of temporary files waiting to execute.&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(when py-file-queues</span>
    <span class="s0">(let ()</span>
      <span class="s0">(maphash (lambda (proc file-queue)</span>
		 <span class="s0">(let ((n (length file-queue)))</span>
		   <span class="s0">(mapcar #'(lambda (entry)</span>
			       <span class="s0">(py-safe (delete-file (car entry))))</span>
			   <span class="s0">file-queue)</span>
		   <span class="s0">(setq file-queue nil)</span>
		   <span class="s0">(message &quot;%d pending files de-queued.&quot; n)))</span>
	       <span class="s0">py-file-queues</span>
	       <span class="s0">)</span>
      <span class="s0">(clrhash py-file-queues))</span>
    <span class="s0">))</span>

<span class="s0">(defun py-execute-region (start end proc &amp;optional async)</span>
  <span class="s0">&quot;Execute the region in a Python interpreter.</span>

<span class="s0">The region is first copied into a temporary file (in the directory</span>
<span class="s0">`py-temp-directory').  If there is no Python interpreter shell</span>
<span class="s0">running, this file is executed synchronously using</span>
<span class="s0">`shell-command-on-region'.  If the program is long running, use</span>
<span class="s0">\\[universal-argument] to run the command asynchronously in its own</span>
<span class="s0">buffer.</span>

<span class="s0">When this function is used programmatically, arguments START and END</span>
<span class="s0">specify the region to execute, and optional third argument ASYNC, if</span>
<span class="s0">non-nil, specifies to run the command asynchronously in its own</span>
<span class="s0">buffer.</span>

<span class="s0">If the Python interpreter shell is running, the region is execfile()'d</span>
<span class="s0">in that shell.  If you try to execute regions too quickly,</span>
<span class="s0">`python-mode' will queue them up and execute them one at a time when</span>
<span class="s0">it sees a `&gt;&gt;&gt; ' prompt from Python.  Each time this happens, the</span>
<span class="s0">process buffer is popped into a window (if it's not already in some</span>
<span class="s0">window) so you can see it, and a comment of the form</span>

    <span class="s0">\t## working on region in file &lt;name&gt;...</span>

<span class="s0">is inserted at the end.  See also the command `py-clear-queues'.&quot;</span>
  <span class="s0">(interactive &quot;r\nP&quot;)</span>
  <span class="s0">(or (&lt; start end)</span>
      <span class="s0">(error &quot;Region is empty&quot;))</span>
  <span class="s0">(let* ((bufname (process-name proc))</span>
	 <span class="s0">(temp (if (memq 'broken-temp-names py-emacs-features)</span>
		   <span class="s0">(let</span>
		       <span class="s0">((sn py-serial-number)</span>
			<span class="s0">(pid (and (fboundp 'emacs-pid) (emacs-pid))))</span>
		     <span class="s0">(setq py-serial-number (1+ py-serial-number))</span>
		     <span class="s0">(if pid</span>
			 <span class="s0">(format &quot;python-%d-%d&quot; sn pid)</span>
		       <span class="s0">(format &quot;python-%d&quot; sn)))</span>
		 <span class="s0">(make-temp-name &quot;python-&quot;)))</span>
	 <span class="s0">(file (expand-file-name temp py-temp-directory)))</span>
    <span class="s0">(write-region start end file nil 'nomsg)</span>
    <span class="s0">(cond</span>
     <span class="s0">;; always run the code in its own asynchronous subprocess</span>
     <span class="s0">(async</span>
      <span class="s0">(let* ((buf (generate-new-buffer-name py-output-buffer))</span>
	     <span class="s0">;; TBD: a horrible hack, but why create new Custom variables?</span>
	     <span class="s0">(arg (if (string-equal py-which-bufname &quot;Python&quot;)</span>
		      <span class="s0">&quot;-u&quot; &quot;&quot;)))</span>
	<span class="s0">(start-process py-which-bufname buf py-which-shell arg file)</span>
	<span class="s0">(pop-to-buffer buf)</span>
	<span class="s0">(py-postprocess-output-buffer buf)</span>
	<span class="s0">))</span>
     <span class="s0">;; if the Python interpreter shell is running, queue it up for</span>
     <span class="s0">;; execution there.</span>
     <span class="s0">(proc</span>
      <span class="s0">;; use the existing python shell</span>
      <span class="s0">(let ((file-queue (gethash proc py-file-queues nil)))</span>
	<span class="s0">(if (not file-queue)</span>
	    <span class="s0">(py-execute-file proc file)</span>
	  <span class="s0">(message &quot;File %s queued for execution&quot; file))</span>
	<span class="s0">(setq file-queue (append file-queue (list file)))</span>
	<span class="s0">(setq py-exception-buffer (cons file (current-buffer)))</span>
	<span class="s0">)</span>
      <span class="s0">)</span>
     <span class="s0">(t</span>
      <span class="s0">;; TBD: a horrible hack, buy why create new Custom variables?</span>
      <span class="s0">(let ((cmd (concat py-which-shell</span>
			 <span class="s0">(if (string-equal py-which-bufname &quot;JPython&quot;)</span>
			     <span class="s0">&quot; -&quot; &quot;&quot;))))</span>
	<span class="s0">;; otherwise either run it synchronously in a subprocess</span>
	<span class="s0">(shell-command-on-region start end cmd py-output-buffer)</span>
	<span class="s0">;; shell-command-on-region kills the output buffer if it never</span>
	<span class="s0">;; existed and there's no output from the command</span>
	<span class="s0">(if (not (get-buffer py-output-buffer))</span>
	    <span class="s0">(message &quot;No output.&quot;)</span>
	  <span class="s0">(setq py-exception-buffer (current-buffer))</span>
	  <span class="s0">(let ((err-p (py-postprocess-output-buffer py-output-buffer)))</span>
	    <span class="s0">(pop-to-buffer py-output-buffer)</span>
	    <span class="s0">(if err-p</span>
		<span class="s0">(pop-to-buffer py-exception-buffer)))</span>
	  <span class="s0">)))</span>
     <span class="s0">)))</span>


<span class="s0">;; Code execution commands</span>
<span class="s0">(defun py-execute-buffer (&amp;optional async)</span>
  <span class="s0">&quot;Send the contents of the buffer to a Python interpreter.</span>
<span class="s0">If the file local variable `py-master-file' is non-nil, execute the</span>
<span class="s0">named file instead of the buffer's file.</span>

<span class="s0">If there is a *Python* process buffer it is used.  If a clipping</span>
<span class="s0">restriction is in effect, only the accessible portion of the buffer is</span>
<span class="s0">sent.  A trailing newline will be supplied if needed.</span>

<span class="s0">See the `\\[py-execute-region]' docs for an account of some</span>
<span class="s0">subtleties, including the use of the optional ASYNC argument.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(if py-master-file</span>
      <span class="s0">(let* ((filename (expand-file-name py-master-file))</span>
	     <span class="s0">(buffer (or (get-file-buffer filename)</span>
			 <span class="s0">(find-file-noselect filename))))</span>
	<span class="s0">(set-buffer buffer)))</span>
  <span class="s0">(py-execute-region (point-min) (point-max) async))</span>

<span class="s0">(defun py-execute-import-or-reload (&amp;optional async)</span>
  <span class="s0">&quot;Import the current buffer's file in a Python interpreter.</span>

<span class="s0">If the file has already been imported, then do reload instead to get</span>
<span class="s0">the latest version.</span>

<span class="s0">If the file's name does not end in \&quot;.py\&quot;, then do execfile instead.</span>

<span class="s0">If the current buffer is not visiting a file, do `py-execute-buffer'</span>
<span class="s0">instead.</span>

<span class="s0">If the file local variable `py-master-file' is non-nil, import or</span>
<span class="s0">reload the named file instead of the buffer's file.  The file may be</span>
<span class="s0">saved based on the value of `py-execute-import-or-reload-save-p'.</span>

<span class="s0">See the `\\[py-execute-region]' docs for an account of some</span>
<span class="s0">subtleties, including the use of the optional ASYNC argument.</span>

<span class="s0">This may be preferable to `\\[py-execute-buffer]' because:</span>

 <span class="s0">- Definitions stay in their module rather than appearing at top</span>
   <span class="s0">level, where they would clutter the global namespace and not affect</span>
   <span class="s0">uses of qualified names (MODULE.NAME).</span>

 <span class="s0">- The Python debugger gets line number information about the functions.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">;; Check file local variable py-master-file</span>
  <span class="s0">(if py-master-file</span>
      <span class="s0">(let* ((filename (expand-file-name py-master-file))</span>
             <span class="s0">(buffer (or (get-file-buffer filename)</span>
                         <span class="s0">(find-file-noselect filename))))</span>
        <span class="s0">(set-buffer buffer)))</span>
  <span class="s0">(let ((file (buffer-file-name (current-buffer))))</span>
    <span class="s0">(if file</span>
        <span class="s0">(progn</span>
	  <span class="s0">;; Maybe save some buffers</span>
	  <span class="s0">(save-some-buffers (not py-ask-about-save) nil)</span>
          <span class="s0">(py-execute-string</span>
           <span class="s0">(if (string-match &quot;\\.py$&quot; file)</span>
               <span class="s0">(let ((f (file-name-sans-extension</span>
			 <span class="s0">(file-name-nondirectory file))))</span>
                 <span class="s0">(format &quot;if globals().has_key('%s'):\n    reload(%s)\nelse:\n    import %s\n&quot;</span>
                         <span class="s0">f f f))</span>
             <span class="s0">(format &quot;execfile(r'%s')\n&quot; file))</span>
           <span class="s0">async))</span>
      <span class="s0">;; else</span>
      <span class="s0">(py-execute-buffer async))))</span>


<span class="s0">(defun py-execute-def-or-class (&amp;optional async)</span>
  <span class="s0">&quot;Send the current function or class definition to a Python interpreter.</span>

<span class="s0">If there is a *Python* process buffer it is used.</span>

<span class="s0">See the `\\[py-execute-region]' docs for an account of some</span>
<span class="s0">subtleties, including the use of the optional ASYNC argument.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(py-mark-def-or-class)</span>
    <span class="s0">;; mark is before point</span>
    <span class="s0">(py-execute-region (mark) (point) async)))</span>


<span class="s0">(defun py-execute-string (string proc &amp;optional async)</span>
  <span class="s0">&quot;Send the argument STRING to a Python interpreter.</span>

<span class="s0">If there is a *Python* process buffer it is used.</span>

<span class="s0">See the `\\[py-execute-region]' docs for an account of some</span>
<span class="s0">subtleties, including the use of the optional ASYNC argument.&quot;</span>
  <span class="s0">(interactive &quot;sExecute Python command: &quot;)</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(set-buffer (get-buffer-create</span>
                 <span class="s0">(generate-new-buffer-name &quot; *Python Command*&quot;)))</span>
    <span class="s0">(insert string)</span>
    <span class="s0">(py-execute-region (point-min) (point-max) proc async)))</span>



<span class="s0">(defun py-jump-to-exception (file line)</span>
  <span class="s0">&quot;Jump to the Python code in FILE at LINE.&quot;</span>
  <span class="s0">(let ((buffer (cond ((string-equal file &quot;&lt;stdin&gt;&quot;)</span>
		       <span class="s0">(if (consp py-exception-buffer)</span>
			   <span class="s0">(cdr py-exception-buffer)</span>
			 <span class="s0">py-exception-buffer))</span>
		      <span class="s0">((and (consp py-exception-buffer)</span>
			    <span class="s0">(string-equal file (car py-exception-buffer)))</span>
		       <span class="s0">(cdr py-exception-buffer))</span>
		      <span class="s0">((py-safe (find-file-noselect file)))</span>
		      <span class="s0">;; could not figure out what file the exception</span>
		      <span class="s0">;; is pointing to, so prompt for it</span>
		      <span class="s0">(t (find-file (read-file-name &quot;Exception file: &quot;</span>
						    <span class="s0">nil</span>
						    <span class="s0">file t))))))</span>
    <span class="s0">(pop-to-buffer buffer)</span>
    <span class="s0">;; Force Python mode</span>
    <span class="s0">(if (not (eq major-mode 'python-mode))</span>
	<span class="s0">(python-mode))</span>
    <span class="s0">(goto-line line)</span>
    <span class="s0">(message &quot;Jumping to exception in file %s on line %d&quot; file line)))</span>

<span class="s0">(defun py-mouseto-exception (event)</span>
  <span class="s0">&quot;Jump to the code which caused the Python exception at EVENT.</span>
<span class="s0">EVENT is usually a mouse click.&quot;</span>
  <span class="s0">(interactive &quot;e&quot;)</span>
  <span class="s0">(cond</span>
   <span class="s0">((fboundp 'event-point)</span>
    <span class="s0">;; XEmacs</span>
    <span class="s0">(let* ((point (event-point event))</span>
	   <span class="s0">(buffer (event-buffer event))</span>
	   <span class="s0">(e (and point buffer (extent-at point buffer 'py-exc-info)))</span>
	   <span class="s0">(info (and e (extent-property e 'py-exc-info))))</span>
      <span class="s0">(message &quot;Event point: %d, info: %s&quot; point info)</span>
      <span class="s0">(and info</span>
	   <span class="s0">(py-jump-to-exception (car info) (cdr info)))</span>
      <span class="s0">))</span>
   <span class="s0">;; Emacs -- Please port this!</span>
   <span class="s0">))</span>

<span class="s0">(defun py-goto-exception ()</span>
  <span class="s0">&quot;Go to the line indicated by the traceback.&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(let (file line)</span>
    <span class="s0">(save-excursion</span>
      <span class="s0">(beginning-of-line)</span>
      <span class="s0">(if (looking-at py-traceback-line-re)</span>
	  <span class="s0">(setq file (match-string 1)</span>
		<span class="s0">line (string-to-int (match-string 2)))))</span>
    <span class="s0">(if (not file)</span>
	<span class="s0">(error &quot;Not on a traceback line&quot;))</span>
    <span class="s0">(py-jump-to-exception file line)))</span>

<span class="s0">(defun py-find-next-exception (start buffer searchdir errwhere)</span>
  <span class="s0">&quot;Find the next Python exception and jump to the code that caused it.</span>
<span class="s0">START is the buffer position in BUFFER from which to begin searching</span>
<span class="s0">for an exception.  SEARCHDIR is a function, either</span>
<span class="s0">`re-search-backward' or `re-search-forward' indicating the direction</span>
<span class="s0">to search.  ERRWHERE is used in an error message if the limit (top or</span>
<span class="s0">bottom) of the trackback stack is encountered.&quot;</span>
  <span class="s0">(let (file line)</span>
    <span class="s0">(save-excursion</span>
      <span class="s0">(set-buffer buffer)</span>
      <span class="s0">(goto-char (py-point start))</span>
      <span class="s0">(if (funcall searchdir py-traceback-line-re nil t)</span>
	  <span class="s0">(setq file (match-string 1)</span>
		<span class="s0">line (string-to-int (match-string 2)))))</span>
    <span class="s0">(if (and file line)</span>
	<span class="s0">(py-jump-to-exception file line)</span>
      <span class="s0">(error &quot;%s of traceback&quot; errwhere))))</span>

<span class="s0">(defun py-down-exception (&amp;optional bottom)</span>
  <span class="s0">&quot;Go to the next line down in the traceback.</span>
<span class="s0">With \\[univeral-argument] (programmatically, optional argument</span>
<span class="s0">BOTTOM), jump to the bottom (innermost) exception in the exception</span>
<span class="s0">stack.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(let* ((proc (get-process &quot;Python&quot;))</span>
	 <span class="s0">(buffer (if proc &quot;*Python*&quot; py-output-buffer)))</span>
    <span class="s0">(if bottom</span>
	<span class="s0">(py-find-next-exception 'eob buffer 're-search-backward &quot;Bottom&quot;)</span>
      <span class="s0">(py-find-next-exception 'eol buffer 're-search-forward &quot;Bottom&quot;))))</span>

<span class="s0">(defun py-up-exception (&amp;optional top)</span>
  <span class="s0">&quot;Go to the previous line up in the traceback.</span>
<span class="s0">With \\[universal-argument] (programmatically, optional argument TOP)</span>
<span class="s0">jump to the top (outermost) exception in the exception stack.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(let* ((proc (get-process &quot;Python&quot;))</span>
	 <span class="s0">(buffer (if proc &quot;*Python*&quot; py-output-buffer)))</span>
    <span class="s0">(if top</span>
	<span class="s0">(py-find-next-exception 'bob buffer 're-search-forward &quot;Top&quot;)</span>
      <span class="s0">(py-find-next-exception 'bol buffer 're-search-backward &quot;Top&quot;))))</span>


<span class="s0">;; Electric deletion</span>
<span class="s0">(defun py-electric-backspace (arg)</span>
  <span class="s0">&quot;Delete preceding character or levels of indentation.</span>
<span class="s0">Deletion is performed by calling the function in `py-backspace-function'</span>
<span class="s0">with a single argument (the number of characters to delete).</span>

<span class="s0">If point is at the leftmost column, delete the preceding newline.</span>

<span class="s0">Otherwise, if point is at the leftmost non-whitespace character of a</span>
<span class="s0">line that is neither a continuation line nor a non-indenting comment</span>
<span class="s0">line, or if point is at the end of a blank line, this command reduces</span>
<span class="s0">the indentation to match that of the line that opened the current</span>
<span class="s0">block of code.  The line that opened the block is displayed in the</span>
<span class="s0">echo area to help you keep track of where you are.  With</span>
<span class="s0">\\[universal-argument] dedents that many blocks (but not past column</span>
<span class="s0">zero).</span>

<span class="s0">Otherwise the preceding character is deleted, converting a tab to</span>
<span class="s0">spaces if needed so that only a single column position is deleted.</span>
<span class="s0">\\[universal-argument] specifies how many characters to delete;</span>
<span class="s0">default is 1.</span>

<span class="s0">When used programmatically, argument ARG specifies the number of</span>
<span class="s0">blocks to dedent, or the number of characters to delete, as indicated</span>
<span class="s0">above.&quot;</span>
  <span class="s0">(interactive &quot;*p&quot;)</span>
  <span class="s0">(if (or (/= (current-indentation) (current-column))</span>
	  <span class="s0">(bolp)</span>
	  <span class="s0">(py-continuation-line-p)</span>
					<span class="s0">;  (not py-honor-comment-indentation)</span>
					<span class="s0">;  (looking-at &quot;#[^ \t\n]&quot;); non-indenting #</span>
	  <span class="s0">)</span>
      <span class="s0">(funcall py-backspace-function arg)</span>
    <span class="s0">;; else indent the same as the colon line that opened the block</span>
    <span class="s0">;; force non-blank so py-goto-block-up doesn't ignore it</span>
    <span class="s0">(insert-char ?* 1)</span>
    <span class="s0">(backward-char)</span>
    <span class="s0">(let ((base-indent 0); indentation of base line</span>
	  <span class="s0">(base-text &quot;&quot;); and text of base line</span>
	  <span class="s0">(base-found-p nil))</span>
      <span class="s0">(save-excursion</span>
	<span class="s0">(while (&lt; 0 arg)</span>
	  <span class="s0">(condition-case nil; in case no enclosing block</span>
	      <span class="s0">(progn</span>
		<span class="s0">(py-goto-block-up 'no-mark)</span>
		<span class="s0">(setq base-indent (current-indentation)</span>
		      <span class="s0">base-text   (py-suck-up-leading-text)</span>
		      <span class="s0">base-found-p t))</span>
	    <span class="s0">(error nil))</span>
	  <span class="s0">(setq arg (1- arg))))</span>
      <span class="s0">(delete-char 1); toss the dummy character</span>
      <span class="s0">(delete-horizontal-space)</span>
      <span class="s0">(indent-to base-indent)</span>
      <span class="s0">(if base-found-p</span>
	  <span class="s0">(message &quot;Closes block: %s&quot; base-text)))))</span>


<span class="s0">(defun py-electric-delete (arg)</span>
  <span class="s0">&quot;Delete preceding or following character or levels of whitespace.</span>

<span class="s0">The behavior of this function depends on the variable</span>
<span class="s0">`delete-key-deletes-forward'.  If this variable is nil (or does not</span>
<span class="s0">exist, as in older Emacsen and non-XEmacs versions), then this</span>
<span class="s0">function behaves identically to \\[c-electric-backspace].</span>

<span class="s0">If `delete-key-deletes-forward' is non-nil and is supported in your</span>
<span class="s0">Emacs, then deletion occurs in the forward direction, by calling the</span>
<span class="s0">function in `py-delete-function'.</span>

<span class="s0">\\[universal-argument] (programmatically, argument ARG) specifies the</span>
<span class="s0">number of characters to delete (default is 1).&quot;</span>
  <span class="s0">(interactive &quot;*p&quot;)</span>
  <span class="s0">(if (or (and (fboundp 'delete-forward-p) ;XEmacs 21</span>
	       <span class="s0">(delete-forward-p))</span>
	  <span class="s0">(and (boundp 'delete-key-deletes-forward) ;XEmacs 20</span>
	       <span class="s0">delete-key-deletes-forward))</span>
      <span class="s0">(funcall py-delete-function arg)</span>
    <span class="s0">(py-electric-backspace arg)))</span>

<span class="s0">;; required for pending-del and delsel modes</span>
<span class="s0">(put 'py-electric-backspace 'delete-selection 'supersede) ;delsel</span>
<span class="s0">(put 'py-electric-backspace 'pending-delete   'supersede) ;pending-del</span>
<span class="s0">(put 'py-electric-delete    'delete-selection 'supersede) ;delsel</span>
<span class="s0">(put 'py-electric-delete    'pending-delete   'supersede) ;pending-del</span>



<span class="s0">(defun py-indent-line (&amp;optional arg)</span>
  <span class="s0">&quot;Fix the indentation of the current line according to Python rules.</span>
<span class="s0">With \\[universal-argument] (programmatically, the optional argument</span>
<span class="s0">ARG non-nil), ignore dedenting rules for block closing statements</span>
<span class="s0">(e.g. return, raise, break, continue, pass)</span>

<span class="s0">This function is normally bound to `indent-line-function' so</span>
<span class="s0">\\[indent-for-tab-command] will call it.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(let* ((ci (current-indentation))</span>
 <span class="s0">(move-to-indentation-p (&lt;= (current-column) ci))</span>
 <span class="s0">(need (py-compute-indentation (not arg))))</span>
    <span class="s0">;; see if we need to dedent</span>
    <span class="s0">(if (py-outdent-p)</span>
<span class="s0">(setq need (- need py-indent-offset)))</span>
    <span class="s0">(if (/= ci need)</span>
<span class="s0">(save-excursion</span>
  <span class="s0">(beginning-of-line)</span>
  <span class="s0">(delete-horizontal-space)</span>
  <span class="s0">(indent-to need)))</span>
    <span class="s0">(if move-to-indentation-p (back-to-indentation))))</span>

<span class="s0">(defun py-newline-and-indent ()</span>
  <span class="s0">&quot;Strives to act like the Emacs `newline-and-indent'.</span>
<span class="s0">This is just `strives to' because correct indentation can't be computed</span>
<span class="s0">from scratch for Python code.  In general, deletes the whitespace before</span>
<span class="s0">point, inserts a newline, and takes an educated guess as to how you want</span>
<span class="s0">the new line indented.&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(let ((ci (current-indentation)))</span>
    <span class="s0">(if (&lt; ci (current-column)); if point beyond indentation</span>
	<span class="s0">(newline-and-indent)</span>
      <span class="s0">;; else try to act like newline-and-indent &quot;normally&quot; acts</span>
      <span class="s0">(beginning-of-line)</span>
      <span class="s0">(insert-char ?\n 1)</span>
      <span class="s0">(move-to-column ci))))</span>

<span class="s0">(defun py-compute-indentation (honor-block-close-p)</span>
  <span class="s0">&quot;Compute Python indentation.</span>
<span class="s0">When HONOR-BLOCK-CLOSE-P is non-nil, statements such as `return',</span>
<span class="s0">`raise', `break', `continue', and `pass' force one level of</span>
<span class="s0">dedenting.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(beginning-of-line)</span>
    <span class="s0">(let* ((bod (py-point 'bod))</span>
	   <span class="s0">(pps (parse-partial-sexp bod (point)))</span>
	   <span class="s0">(boipps (parse-partial-sexp bod (py-point 'boi)))</span>
	   <span class="s0">placeholder)</span>
      <span class="s0">(cond</span>
       <span class="s0">;; are we inside a multi-line string or comment?</span>
       <span class="s0">((or (and (nth 3 pps) (nth 3 boipps))</span>
	    <span class="s0">(and (nth 4 pps) (nth 4 boipps)))</span>
	<span class="s0">(save-excursion</span>
	  <span class="s0">(if (not py-align-multiline-strings-p) 0</span>
	    <span class="s0">;; skip back over blank &amp; non-indenting comment lines</span>
	    <span class="s0">;; note: will skip a blank or non-indenting comment line</span>
	    <span class="s0">;; that happens to be a continuation line too</span>
	    <span class="s0">(re-search-backward &quot;^[ \t]*\\([^ \t\n#]\\|#[ \t\n]\\)&quot; nil 'move)</span>
	    <span class="s0">(back-to-indentation)</span>
	    <span class="s0">(current-column))))</span>
       <span class="s0">;; are we on a continuation line?</span>
       <span class="s0">((py-continuation-line-p)</span>
	<span class="s0">(let ((startpos (point))</span>
	      <span class="s0">(open-bracket-pos (py-nesting-level))</span>
	      <span class="s0">endpos searching found state)</span>
	  <span class="s0">(if open-bracket-pos</span>
	      <span class="s0">(progn</span>
		<span class="s0">;; align with first item in list; else a normal</span>
		<span class="s0">;; indent beyond the line with the open bracket</span>
		<span class="s0">(goto-char (1+ open-bracket-pos)) ; just beyond bracket</span>
		<span class="s0">;; is the first list item on the same line?</span>
		<span class="s0">(skip-chars-forward &quot; \t&quot;)</span>
		<span class="s0">(if (null (memq (following-char) '(?\n ?# ?\\)))</span>
					<span class="s0">; yes, so line up with it</span>
		    <span class="s0">(current-column)</span>
		  <span class="s0">;; first list item on another line, or doesn't exist yet</span>
		  <span class="s0">(forward-line 1)</span>
		  <span class="s0">(while (and (&lt; (point) startpos)</span>
			      <span class="s0">(looking-at &quot;[ \t]*[#\n\\\\]&quot;)) ; skip noise</span>
		    <span class="s0">(forward-line 1))</span>
		  <span class="s0">(if (and (&lt; (point) startpos)</span>
			   <span class="s0">(/= startpos</span>
			       <span class="s0">(save-excursion</span>
				 <span class="s0">(goto-char (1+ open-bracket-pos))</span>
				 <span class="s0">(forward-comment (point-max))</span>
				 <span class="s0">(point))))</span>
		      <span class="s0">;; again mimic the first list item</span>
		      <span class="s0">(current-indentation)</span>
		    <span class="s0">;; else they're about to enter the first item</span>
		    <span class="s0">(goto-char open-bracket-pos)</span>
		    <span class="s0">(setq placeholder (point))</span>
		    <span class="s0">(py-goto-initial-line)</span>
		    <span class="s0">(py-goto-beginning-of-tqs</span>
		     <span class="s0">(save-excursion (nth 3 (parse-partial-sexp</span>
					     <span class="s0">placeholder (point)))))</span>
		    <span class="s0">(+ (current-indentation) py-indent-offset))))</span>

	    <span class="s0">;; else on backslash continuation line</span>
	    <span class="s0">(forward-line -1)</span>
	    <span class="s0">(if (py-continuation-line-p) ; on at least 3rd line in block</span>
		<span class="s0">(current-indentation); so just continue the pattern</span>
	      <span class="s0">;; else started on 2nd line in block, so indent more.</span>
	      <span class="s0">;; if base line is an assignment with a start on a RHS,</span>
	      <span class="s0">;; indent to 2 beyond the leftmost &quot;=&quot;; else skip first</span>
	      <span class="s0">;; chunk of non-whitespace characters on base line, + 1 more</span>
	      <span class="s0">;; column</span>
	      <span class="s0">(end-of-line)</span>
	      <span class="s0">(setq endpos (point)  searching t)</span>
	      <span class="s0">(back-to-indentation)</span>
	      <span class="s0">(setq startpos (point))</span>
	      <span class="s0">;; look at all &quot;=&quot; from left to right, stopping at first</span>
	      <span class="s0">;; one not nested in a list or string</span>
	      <span class="s0">(while searching</span>
		<span class="s0">(skip-chars-forward &quot;^=&quot; endpos)</span>
		<span class="s0">(if (= (point) endpos)</span>
		    <span class="s0">(setq searching nil)</span>
		  <span class="s0">(forward-char 1)</span>
		  <span class="s0">(setq state (parse-partial-sexp startpos (point)))</span>
		  <span class="s0">(if (and (zerop (car state)) ; not in a bracket</span>
			   <span class="s0">(null (nth 3 state))) ; &amp; not in a string</span>
		      <span class="s0">(progn</span>
			<span class="s0">(setq searching nil) ; done searching in any case</span>
			<span class="s0">(setq found</span>
			      <span class="s0">(not (or</span>
				    <span class="s0">(eq (following-char) ?=)</span>
				    <span class="s0">(memq (char-after (- (point) 2))</span>
					  <span class="s0">'(?&lt; ?&gt; ?!)))))))))</span>
	      <span class="s0">(if (or (not found); not an assignment</span>
		      <span class="s0">(looking-at &quot;[ \t]*\\\\&quot;)) ; &lt;=&gt;&lt;spaces&gt;&lt;backslash&gt;</span>
		  <span class="s0">(progn</span>
		    <span class="s0">(goto-char startpos)</span>
		    <span class="s0">(skip-chars-forward &quot;^ \t\n&quot;)))</span>
	      <span class="s0">(1+ (current-column))))))</span>

       <span class="s0">;; not on a continuation line</span>
       <span class="s0">((bobp) (current-indentation))</span>

       <span class="s0">;; Dfn: &quot;Indenting comment line&quot;.  A line containing only a</span>
       <span class="s0">;; comment, but which is treated like a statement for</span>
       <span class="s0">;; indentation calculation purposes.  Such lines are only</span>
       <span class="s0">;; treated specially by the mode; they are not treated</span>
       <span class="s0">;; specially by the Python interpreter.</span>

       <span class="s0">;; The rules for indenting comment lines are a line where:</span>
       <span class="s0">;;   - the first non-whitespace character is `#', and</span>
       <span class="s0">;;   - the character following the `#' is whitespace, and</span>
       <span class="s0">;;   - the line is dedented with respect to (i.e. to the left</span>
       <span class="s0">;;     of) the indentation of the preceding non-blank line.</span>

       <span class="s0">;; The first non-blank line following an indenting comment</span>
       <span class="s0">;; line is given the same amount of indentation as the</span>
       <span class="s0">;; indenting comment line.</span>

       <span class="s0">;; All other comment-only lines are ignored for indentation</span>
       <span class="s0">;; purposes.</span>

       <span class="s0">;; Are we looking at a comment-only line which is *not* an</span>
       <span class="s0">;; indenting comment line?  If so, we assume that it's been</span>
       <span class="s0">;; placed at the desired indentation, so leave it alone.</span>
       <span class="s0">;; Indenting comment lines are aligned as statements down</span>
       <span class="s0">;; below.</span>
       <span class="s0">((and (looking-at &quot;[ \t]*#[^ \t\n]&quot;)</span>
	     <span class="s0">;; NOTE: this test will not be performed in older Emacsen</span>
	     <span class="s0">(fboundp 'forward-comment)</span>
	     <span class="s0">(&lt;= (current-indentation)</span>
		 <span class="s0">(save-excursion</span>
		   <span class="s0">(forward-comment (- (point-max)))</span>
		   <span class="s0">(current-indentation))))</span>
	<span class="s0">(current-indentation))</span>

       <span class="s0">;; else indentation based on that of the statement that</span>
       <span class="s0">;; precedes us; use the first line of that statement to</span>
       <span class="s0">;; establish the base, in case the user forced a non-std</span>
       <span class="s0">;; indentation for the continuation lines (if any)</span>
       <span class="s0">(t</span>
	<span class="s0">;; skip back over blank &amp; non-indenting comment lines note:</span>
	<span class="s0">;; will skip a blank or non-indenting comment line that</span>
	<span class="s0">;; happens to be a continuation line too.  use fast Emacs 19</span>
	<span class="s0">;; function if it's there.</span>
	<span class="s0">(if (and (eq py-honor-comment-indentation nil)</span>
		 <span class="s0">(fboundp 'forward-comment))</span>
	    <span class="s0">(forward-comment (- (point-max)))</span>
	  <span class="s0">(let ((prefix-re (concat py-block-comment-prefix &quot;[ \t]*&quot;))</span>
		<span class="s0">done)</span>
	    <span class="s0">(while (not done)</span>
	      <span class="s0">(re-search-backward &quot;^[ \t]*\\([^ \t\n#]\\|#\\)&quot; nil 'move)</span>
	      <span class="s0">(setq done (or (bobp)</span>
			     <span class="s0">(and (eq py-honor-comment-indentation t)</span>
				  <span class="s0">(save-excursion</span>
				    <span class="s0">(back-to-indentation)</span>
				    <span class="s0">(not (looking-at prefix-re))</span>
				    <span class="s0">))</span>
			     <span class="s0">(and (not (eq py-honor-comment-indentation t))</span>
				  <span class="s0">(save-excursion</span>
				    <span class="s0">(back-to-indentation)</span>
				    <span class="s0">(not (zerop (current-column)))))</span>
			     <span class="s0">))</span>
	      <span class="s0">)))</span>
	<span class="s0">;; if we landed inside a string, go to the beginning of that</span>
	<span class="s0">;; string. this handles triple quoted, multi-line spanning</span>
	<span class="s0">;; strings.</span>
	<span class="s0">(py-goto-beginning-of-tqs (nth 3 (parse-partial-sexp bod (point))))</span>
	<span class="s0">;; now skip backward over continued lines</span>
	<span class="s0">(setq placeholder (point))</span>
	<span class="s0">(py-goto-initial-line)</span>
	<span class="s0">;; we may *now* have landed in a TQS, so find the beginning of</span>
	<span class="s0">;; this string.</span>
	<span class="s0">(py-goto-beginning-of-tqs</span>
	 <span class="s0">(save-excursion (nth 3 (parse-partial-sexp</span>
				 <span class="s0">placeholder (point)))))</span>
	<span class="s0">(+ (current-indentation)</span>
	   <span class="s0">(if (py-statement-opens-block-p)</span>
	       <span class="s0">py-indent-offset</span>
	     <span class="s0">(if (and honor-block-close-p (py-statement-closes-block-p))</span>
		 <span class="s0">(- py-indent-offset)</span>
	       <span class="s0">0)))</span>
	<span class="s0">)))))</span>

<span class="s0">(defun py-guess-indent-offset (&amp;optional global)</span>
  <span class="s0">&quot;Guess a good value for, and change, `py-indent-offset'.</span>

<span class="s0">By default, make a buffer-local copy of `py-indent-offset' with the</span>
<span class="s0">new value, so that other Python buffers are not affected.  With</span>
<span class="s0">\\[universal-argument] (programmatically, optional argument GLOBAL),</span>
<span class="s0">change the global value of `py-indent-offset'.  This affects all</span>
<span class="s0">Python buffers (that don't have their own buffer-local copy), both</span>
<span class="s0">those currently existing and those created later in the Emacs session.</span>

<span class="s0">Some people use a different value for `py-indent-offset' than you use.</span>
<span class="s0">There's no excuse for such foolishness, but sometimes you have to deal</span>
<span class="s0">with their ugly code anyway.  This function examines the file and sets</span>
<span class="s0">`py-indent-offset' to what it thinks it was when they created the</span>
<span class="s0">mess.</span>

<span class="s0">Specifically, it searches forward from the statement containing point,</span>
<span class="s0">looking for a line that opens a block of code.  `py-indent-offset' is</span>
<span class="s0">set to the difference in indentation between that line and the Python</span>
<span class="s0">statement following it.  If the search doesn't succeed going forward,</span>
<span class="s0">it's tried again going backward.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;); raw prefix arg</span>
  <span class="s0">(let (new-value</span>
	<span class="s0">(start (point))</span>
	<span class="s0">(restart (point))</span>
	<span class="s0">(found nil)</span>
	<span class="s0">colon-indent)</span>
    <span class="s0">(py-goto-initial-line)</span>
    <span class="s0">(while (not (or found (eobp)))</span>
      <span class="s0">(when (and (re-search-forward &quot;:[ \t]*\\($\\|[#\\]\\)&quot; nil 'move)</span>
		 <span class="s0">(not (py-in-literal restart)))</span>
	    <span class="s0">(setq restart (point))</span>
	    <span class="s0">(py-goto-initial-line)</span>
	    <span class="s0">(if (py-statement-opens-block-p)</span>
		<span class="s0">(setq found t)</span>
	      <span class="s0">(goto-char restart))))</span>
    <span class="s0">(unless found</span>
      <span class="s0">(goto-char start)</span>
      <span class="s0">(py-goto-initial-line)</span>
      <span class="s0">(while (not (or found (bobp)))</span>
	<span class="s0">(setq found (and</span>
		     <span class="s0">(re-search-backward &quot;:[ \t]*\\($\\|[#\\]\\)&quot; nil 'move)</span>
		     <span class="s0">(or (py-goto-initial-line) t) ; always true -- side effect</span>
		     <span class="s0">(py-statement-opens-block-p)))))</span>
    <span class="s0">(setq colon-indent (current-indentation)</span>
	  <span class="s0">found (and found (zerop (py-next-statement 1)))</span>
	  <span class="s0">new-value (- (current-indentation) colon-indent))</span>
    <span class="s0">(goto-char start)</span>
    <span class="s0">(if (not found)</span>
	<span class="s0">(error &quot;Sorry, couldn't guess a value for py-indent-offset&quot;)</span>
      <span class="s0">(funcall (if global 'kill-local-variable 'make-local-variable)</span>
	       <span class="s0">'py-indent-offset)</span>
      <span class="s0">(setq py-indent-offset new-value)</span>
      <span class="s0">(or noninteractive</span>
	  <span class="s0">(message &quot;%s value of py-indent-offset set to %d&quot;</span>
		   <span class="s0">(if global &quot;Global&quot; &quot;Local&quot;)</span>
		   <span class="s0">py-indent-offset)))</span>
    <span class="s0">))</span>

<span class="s0">(defun py-comment-indent-function ()</span>
  <span class="s0">&quot;Python version of `comment-indent-function'.&quot;</span>
  <span class="s0">;; This is required when filladapt is turned off.  Without it, when</span>
  <span class="s0">;; filladapt is not used, comments which start in column zero</span>
  <span class="s0">;; cascade one character to the right</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(beginning-of-line)</span>
    <span class="s0">(let ((eol (py-point 'eol)))</span>
      <span class="s0">(and comment-start-skip</span>
	   <span class="s0">(re-search-forward comment-start-skip eol t)</span>
	   <span class="s0">(setq eol (match-beginning 0)))</span>
      <span class="s0">(goto-char eol)</span>
      <span class="s0">(skip-chars-backward &quot; \t&quot;)</span>
      <span class="s0">(max comment-column (+ (current-column) (if (bolp) 0 1)))</span>
      <span class="s0">)))</span>

<span class="s0">(defun py-narrow-to-defun (&amp;optional class)</span>
  <span class="s0">&quot;Make text outside current defun invisible.</span>
<span class="s0">The defun visible is the one that contains point or follows point.</span>
<span class="s0">Optional CLASS is passed directly to `py-beginning-of-def-or-class'.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(widen)</span>
    <span class="s0">(py-end-of-def-or-class class)</span>
    <span class="s0">(let ((end (point)))</span>
      <span class="s0">(py-beginning-of-def-or-class class)</span>
      <span class="s0">(narrow-to-region (point) end))))</span>


<span class="s0">(defun py-shift-region (start end count)</span>
  <span class="s0">&quot;Indent lines from START to END by COUNT spaces.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(goto-char end)</span>
    <span class="s0">(beginning-of-line)</span>
    <span class="s0">(setq end (point))</span>
    <span class="s0">(goto-char start)</span>
    <span class="s0">(beginning-of-line)</span>
    <span class="s0">(setq start (point))</span>
    <span class="s0">(indent-rigidly start end count)))</span>

<span class="s0">(defun py-shift-region-left (start end &amp;optional count)</span>
  <span class="s0">&quot;Shift region of Python code to the left.</span>
<span class="s0">The lines from the line containing the start of the current region up</span>
<span class="s0">to (but not including) the line containing the end of the region are</span>
<span class="s0">shifted to the left, by `py-indent-offset' columns.</span>

<span class="s0">If a prefix argument is given, the region is instead shifted by that</span>
<span class="s0">many columns.  With no active region, dedent only the current line.</span>
<span class="s0">You cannot dedent the region if any line is already at column zero.&quot;</span>
  <span class="s0">(interactive</span>
   <span class="s0">(let ((p (point))</span>
	 <span class="s0">(m (mark))</span>
	 <span class="s0">(arg current-prefix-arg))</span>
     <span class="s0">(if m</span>
	 <span class="s0">(list (min p m) (max p m) arg)</span>
       <span class="s0">(list p (save-excursion (forward-line 1) (point)) arg))))</span>
  <span class="s0">;; if any line is at column zero, don't shift the region</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(goto-char start)</span>
    <span class="s0">(while (&lt; (point) end)</span>
      <span class="s0">(back-to-indentation)</span>
      <span class="s0">(if (and (zerop (current-column))</span>
	       <span class="s0">(not (looking-at &quot;\\s *$&quot;)))</span>
	  <span class="s0">(error &quot;Region is at left edge&quot;))</span>
      <span class="s0">(forward-line 1)))</span>
  <span class="s0">(py-shift-region start end (- (prefix-numeric-value</span>
				 <span class="s0">(or count py-indent-offset))))</span>
  <span class="s0">(py-keep-region-active))</span>

<span class="s0">(defun py-shift-region-right (start end &amp;optional count)</span>
  <span class="s0">&quot;Shift region of Python code to the right.</span>
<span class="s0">The lines from the line containing the start of the current region up</span>
<span class="s0">to (but not including) the line containing the end of the region are</span>
<span class="s0">shifted to the right, by `py-indent-offset' columns.</span>

<span class="s0">If a prefix argument is given, the region is instead shifted by that</span>
<span class="s0">many columns.  With no active region, indent only the current line.&quot;</span>
  <span class="s0">(interactive</span>
   <span class="s0">(let ((p (point))</span>
	 <span class="s0">(m (mark))</span>
	 <span class="s0">(arg current-prefix-arg))</span>
     <span class="s0">(if m</span>
	 <span class="s0">(list (min p m) (max p m) arg)</span>
       <span class="s0">(list p (save-excursion (forward-line 1) (point)) arg))))</span>
  <span class="s0">(py-shift-region start end (prefix-numeric-value</span>
			      <span class="s0">(or count py-indent-offset)))</span>
  <span class="s0">(py-keep-region-active))</span>

<span class="s0">(defun py-indent-region (start end &amp;optional indent-offset)</span>
  <span class="s0">&quot;Reindent a region of Python code.</span>

<span class="s0">The lines from the line containing the start of the current region up</span>
<span class="s0">to (but not including) the line containing the end of the region are</span>
<span class="s0">reindented.  If the first line of the region has a non-whitespace</span>
<span class="s0">character in the first column, the first line is left alone and the</span>
<span class="s0">rest of the region is reindented with respect to it.  Else the entire</span>
<span class="s0">region is reindented with respect to the (closest code or indenting</span>
<span class="s0">comment) statement immediately preceding the region.</span>

<span class="s0">This is useful when code blocks are moved or yanked, when enclosing</span>
<span class="s0">control structures are introduced or removed, or to reformat code</span>
<span class="s0">using a new value for the indentation offset.</span>

<span class="s0">If a numeric prefix argument is given, it will be used as the value of</span>
<span class="s0">the indentation offset.  Else the value of `py-indent-offset' will be</span>
<span class="s0">used.</span>

<span class="s0">Warning: The region must be consistently indented before this function</span>
<span class="s0">is called!  This function does not compute proper indentation from</span>
<span class="s0">scratch (that's impossible in Python), it merely adjusts the existing</span>
<span class="s0">indentation to be correct in context.</span>

<span class="s0">Warning: This function really has no idea what to do with</span>
<span class="s0">non-indenting comment lines, and shifts them as if they were indenting</span>
<span class="s0">comment lines.  Fixing this appears to require telepathy.</span>

<span class="s0">Special cases: whitespace is deleted from blank lines; continuation</span>
<span class="s0">lines are shifted by the same amount their initial line was shifted,</span>
<span class="s0">in order to preserve their relative indentation with respect to their</span>
<span class="s0">initial line; and comment lines beginning in column 1 are ignored.&quot;</span>
  <span class="s0">(interactive &quot;*r\nP&quot;); region; raw prefix arg</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(goto-char end)   (beginning-of-line) (setq end (point-marker))</span>
    <span class="s0">(goto-char start) (beginning-of-line)</span>
    <span class="s0">(let ((py-indent-offset (prefix-numeric-value</span>
			     <span class="s0">(or indent-offset py-indent-offset)))</span>
	  <span class="s0">(indents '(-1)); stack of active indent levels</span>
	  <span class="s0">(target-column 0); column to which to indent</span>
	  <span class="s0">(base-shifted-by 0); amount last base line was shifted</span>
	  <span class="s0">(indent-base (if (looking-at &quot;[ \t\n]&quot;)</span>
			   <span class="s0">(py-compute-indentation t)</span>
			 <span class="s0">0))</span>
	  <span class="s0">ci)</span>
      <span class="s0">(while (&lt; (point) end)</span>
	<span class="s0">(setq ci (current-indentation))</span>
	<span class="s0">;; figure out appropriate target column</span>
	<span class="s0">(cond</span>
	 <span class="s0">((or (eq (following-char) ?#); comment in column 1</span>
	      <span class="s0">(looking-at &quot;[ \t]*$&quot;)); entirely blank</span>
	  <span class="s0">(setq target-column 0))</span>
	 <span class="s0">((py-continuation-line-p); shift relative to base line</span>
	  <span class="s0">(setq target-column (+ ci base-shifted-by)))</span>
	 <span class="s0">(t; new base line</span>
	  <span class="s0">(if (&gt; ci (car indents)); going deeper; push it</span>
	      <span class="s0">(setq indents (cons ci indents))</span>
	    <span class="s0">;; else we should have seen this indent before</span>
	    <span class="s0">(setq indents (memq ci indents)) ; pop deeper indents</span>
	    <span class="s0">(if (null indents)</span>
		<span class="s0">(error &quot;Bad indentation in region, at line %d&quot;</span>
		       <span class="s0">(save-restriction</span>
			 <span class="s0">(widen)</span>
			 <span class="s0">(1+ (count-lines 1 (point)))))))</span>
	  <span class="s0">(setq target-column (+ indent-base</span>
				 <span class="s0">(* py-indent-offset</span>
				    <span class="s0">(- (length indents) 2))))</span>
	  <span class="s0">(setq base-shifted-by (- target-column ci))))</span>
	<span class="s0">;; shift as needed</span>
	<span class="s0">(if (/= ci target-column)</span>
	    <span class="s0">(progn</span>
	      <span class="s0">(delete-horizontal-space)</span>
	      <span class="s0">(indent-to target-column)))</span>
	<span class="s0">(forward-line 1))))</span>
  <span class="s0">(set-marker end nil))</span>

<span class="s0">(defun py-comment-region (beg end &amp;optional arg)</span>
  <span class="s0">&quot;Like `comment-region' but uses double hash (`#') comment starter.&quot;</span>
  <span class="s0">(interactive &quot;r\nP&quot;)</span>
  <span class="s0">(let ((comment-start py-block-comment-prefix))</span>
    <span class="s0">(comment-region beg end arg)))</span>


<span class="s0">;; Functions for moving point</span>
<span class="s0">(defun py-previous-statement (count)</span>
  <span class="s0">&quot;Go to the start of the COUNTth preceding Python statement.</span>
<span class="s0">By default, goes to the previous statement.  If there is no such</span>
<span class="s0">statement, goes to the first statement.  Return count of statements</span>
<span class="s0">left to move.  `Statements' do not include blank, comment, or</span>
<span class="s0">continuation lines.&quot;</span>
  <span class="s0">(interactive &quot;p&quot;); numeric prefix arg</span>
  <span class="s0">(if (&lt; count 0) (py-next-statement (- count))</span>
    <span class="s0">(py-goto-initial-line)</span>
    <span class="s0">(let (start)</span>
      <span class="s0">(while (and</span>
	      <span class="s0">(setq start (point)); always true -- side effect</span>
	      <span class="s0">(&gt; count 0)</span>
	      <span class="s0">(zerop (forward-line -1))</span>
	      <span class="s0">(py-goto-statement-at-or-above))</span>
	<span class="s0">(setq count (1- count)))</span>
      <span class="s0">(if (&gt; count 0) (goto-char start)))</span>
    <span class="s0">count))</span>

<span class="s0">(defun py-next-statement (count)</span>
  <span class="s0">&quot;Go to the start of next Python statement.</span>
<span class="s0">If the statement at point is the i'th Python statement, goes to the</span>
<span class="s0">start of statement i+COUNT.  If there is no such statement, goes to the</span>
<span class="s0">last statement.  Returns count of statements left to move.  `Statements'</span>
<span class="s0">do not include blank, comment, or continuation lines.&quot;</span>
  <span class="s0">(interactive &quot;p&quot;); numeric prefix arg</span>
  <span class="s0">(if (&lt; count 0) (py-previous-statement (- count))</span>
    <span class="s0">(beginning-of-line)</span>
    <span class="s0">(let (start)</span>
      <span class="s0">(while (and</span>
	      <span class="s0">(setq start (point)); always true -- side effect</span>
	      <span class="s0">(&gt; count 0)</span>
	      <span class="s0">(py-goto-statement-below))</span>
	<span class="s0">(setq count (1- count)))</span>
      <span class="s0">(if (&gt; count 0) (goto-char start)))</span>
    <span class="s0">count))</span>

<span class="s0">(defun py-goto-block-up (&amp;optional nomark)</span>
  <span class="s0">&quot;Move up to start of current block.</span>
<span class="s0">Go to the statement that starts the smallest enclosing block; roughly</span>
<span class="s0">speaking, this will be the closest preceding statement that ends with a</span>
<span class="s0">colon and is indented less than the statement you started on.  If</span>
<span class="s0">successful, also sets the mark to the starting point.</span>

<span class="s0">`\\[py-mark-block]' can be used afterward to mark the whole code</span>
<span class="s0">block, if desired.</span>

<span class="s0">If called from a program, the mark will not be set if optional argument</span>
<span class="s0">NOMARK is not nil.&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(let ((start (point))</span>
	<span class="s0">(found nil)</span>
	<span class="s0">initial-indent)</span>
    <span class="s0">(py-goto-initial-line)</span>
    <span class="s0">;; if on blank or non-indenting comment line, use the preceding stmt</span>
    <span class="s0">(if (looking-at &quot;[ \t]*\\($\\|#[^ \t\n]\\)&quot;)</span>
	<span class="s0">(progn</span>
	  <span class="s0">(py-goto-statement-at-or-above)</span>
	  <span class="s0">(setq found (py-statement-opens-block-p))))</span>
    <span class="s0">;; search back for colon line indented less</span>
    <span class="s0">(setq initial-indent (current-indentation))</span>
    <span class="s0">(if (zerop initial-indent)</span>
	<span class="s0">;; force fast exit</span>
	<span class="s0">(goto-char (point-min)))</span>
    <span class="s0">(while (not (or found (bobp)))</span>
      <span class="s0">(setq found</span>
	    <span class="s0">(and</span>
	     <span class="s0">(re-search-backward &quot;:[ \t]*\\($\\|[#\\]\\)&quot; nil 'move)</span>
	     <span class="s0">(or (py-goto-initial-line) t) ; always true -- side effect</span>
	     <span class="s0">(&lt; (current-indentation) initial-indent)</span>
	     <span class="s0">(py-statement-opens-block-p))))</span>
    <span class="s0">(if found</span>
	<span class="s0">(progn</span>
	  <span class="s0">(or nomark (push-mark start))</span>
	  <span class="s0">(back-to-indentation))</span>
      <span class="s0">(goto-char start)</span>
      <span class="s0">(error &quot;Enclosing block not found&quot;))))</span>

<span class="s0">(defun py-beginning-of-def-or-class (&amp;optional class count)</span>
  <span class="s0">&quot;Move point to start of `def' or `class'.</span>

<span class="s0">Searches back for the closest preceding `def'.  If you supply a prefix</span>
<span class="s0">arg, looks for a `class' instead.  The docs below assume the `def'</span>
<span class="s0">case; just substitute `class' for `def' for the other case.</span>
<span class="s0">Programmatically, if CLASS is `either', then moves to either `class'</span>
<span class="s0">or `def'.</span>

<span class="s0">When second optional argument is given programmatically, move to the</span>
<span class="s0">COUNTth start of `def'.</span>

<span class="s0">If point is in a `def' statement already, and after the `d', simply</span>
<span class="s0">moves point to the start of the statement.</span>

<span class="s0">Otherwise (i.e. when point is not in a `def' statement, or at or</span>
<span class="s0">before the `d' of a `def' statement), searches for the closest</span>
<span class="s0">preceding `def' statement, and leaves point at its start.  If no such</span>
<span class="s0">statement can be found, leaves point at the start of the buffer.</span>

<span class="s0">Returns t iff a `def' statement is found by these rules.</span>

<span class="s0">Note that doing this command repeatedly will take you closer to the</span>
<span class="s0">start of the buffer each time.</span>

<span class="s0">To mark the current `def', see `\\[py-mark-def-or-class]'.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;); raw prefix arg</span>
  <span class="s0">(setq count (or count 1))</span>
  <span class="s0">(let ((at-or-before-p (&lt;= (current-column) (current-indentation)))</span>
	<span class="s0">(start-of-line (goto-char (py-point 'bol)))</span>
	<span class="s0">(start-of-stmt (goto-char (py-point 'bos)))</span>
	<span class="s0">(start-re (cond ((eq class 'either) &quot;^[ \t]*\\(class\\|def\\)\\&gt;&quot;)</span>
			<span class="s0">(class &quot;^[ \t]*class\\&gt;&quot;)</span>
			<span class="s0">(t &quot;^[ \t]*def\\&gt;&quot;)))</span>
	<span class="s0">)</span>
    <span class="s0">;; searching backward</span>
    <span class="s0">(if (and (&lt; 0 count)</span>
	     <span class="s0">(or (/= start-of-stmt start-of-line)</span>
		 <span class="s0">(not at-or-before-p)))</span>
	<span class="s0">(end-of-line))</span>
    <span class="s0">;; search forward</span>
    <span class="s0">(if (and (&gt; 0 count)</span>
	     <span class="s0">(zerop (current-column))</span>
	     <span class="s0">(looking-at start-re))</span>
	<span class="s0">(end-of-line))</span>
    <span class="s0">(if (re-search-backward start-re nil 'move count)</span>
	<span class="s0">(goto-char (match-beginning 0)))))</span>

<span class="s0">;; Backwards compatibility</span>
<span class="s0">(defalias 'beginning-of-python-def-or-class 'py-beginning-of-def-or-class)</span>

<span class="s0">(defun py-end-of-def-or-class (&amp;optional class count)</span>
  <span class="s0">&quot;Move point beyond end of `def' or `class' body.</span>

<span class="s0">By default, looks for an appropriate `def'.  If you supply a prefix</span>
<span class="s0">arg, looks for a `class' instead.  The docs below assume the `def'</span>
<span class="s0">case; just substitute `class' for `def' for the other case.</span>
<span class="s0">Programmatically, if CLASS is `either', then moves to either `class'</span>
<span class="s0">or `def'.</span>

<span class="s0">When second optional argument is given programmatically, move to the</span>
<span class="s0">COUNTth end of `def'.</span>

<span class="s0">If point is in a `def' statement already, this is the `def' we use.</span>

<span class="s0">Else, if the `def' found by `\\[py-beginning-of-def-or-class]'</span>
<span class="s0">contains the statement you started on, that's the `def' we use.</span>

<span class="s0">Otherwise, we search forward for the closest following `def', and use that.</span>

<span class="s0">If a `def' can be found by these rules, point is moved to the start of</span>
<span class="s0">the line immediately following the `def' block, and the position of the</span>
<span class="s0">start of the `def' is returned.</span>

<span class="s0">Else point is moved to the end of the buffer, and nil is returned.</span>

<span class="s0">Note that doing this command repeatedly will take you closer to the</span>
<span class="s0">end of the buffer each time.</span>

<span class="s0">To mark the current `def', see `\\[py-mark-def-or-class]'.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;); raw prefix arg</span>
  <span class="s0">(if (and count (/= count 1))</span>
      <span class="s0">(py-beginning-of-def-or-class (- 1 count)))</span>
  <span class="s0">(let ((start (progn (py-goto-initial-line) (point)))</span>
	<span class="s0">(which (cond ((eq class 'either) &quot;\\(class\\|def\\)&quot;)</span>
		     <span class="s0">(class &quot;class&quot;)</span>
		     <span class="s0">(t &quot;def&quot;)))</span>
	<span class="s0">(state 'not-found))</span>
    <span class="s0">;; move point to start of appropriate def/class</span>
    <span class="s0">(if (looking-at (concat &quot;[ \t]*&quot; which &quot;\\&gt;&quot;)) ; already on one</span>
	<span class="s0">(setq state 'at-beginning)</span>
      <span class="s0">;; else see if py-beginning-of-def-or-class hits container</span>
      <span class="s0">(if (and (py-beginning-of-def-or-class class)</span>
	       <span class="s0">(progn (py-goto-beyond-block)</span>
		      <span class="s0">(&gt; (point) start)))</span>
	  <span class="s0">(setq state 'at-end)</span>
	<span class="s0">;; else search forward</span>
	<span class="s0">(goto-char start)</span>
	<span class="s0">(if (re-search-forward (concat &quot;^[ \t]*&quot; which &quot;\\&gt;&quot;) nil 'move)</span>
	    <span class="s0">(progn (setq state 'at-beginning)</span>
		   <span class="s0">(beginning-of-line)))))</span>
    <span class="s0">(cond</span>
     <span class="s0">((eq state 'at-beginning) (py-goto-beyond-block) t)</span>
     <span class="s0">((eq state 'at-end) t)</span>
     <span class="s0">((eq state 'not-found) nil)</span>
     <span class="s0">(t (error &quot;Internal error in `py-end-of-def-or-class'&quot;)))))</span>

<span class="s0">;; Backwards compabitility</span>
<span class="s0">(defalias 'end-of-python-def-or-class 'py-end-of-def-or-class)</span>


<span class="s0">;; Functions for marking regions</span>
<span class="s0">(defun py-mark-block (&amp;optional extend just-move)</span>
  <span class="s0">&quot;Mark following block of lines.  With prefix arg, mark structure.</span>
<span class="s0">Easier to use than explain.  It sets the region to an `interesting'</span>
<span class="s0">block of succeeding lines.  If point is on a blank line, it goes down to</span>
<span class="s0">the next non-blank line.  That will be the start of the region.  The end</span>
<span class="s0">of the region depends on the kind of line at the start:</span>

 <span class="s0">- If a comment, the region will include all succeeding comment lines up</span>
   <span class="s0">to (but not including) the next non-comment line (if any).</span>

 <span class="s0">- Else if a prefix arg is given, and the line begins one of these</span>
   <span class="s0">structures:</span>

     <span class="s0">if elif else try except finally for while def class</span>

   <span class="s0">the region will be set to the body of the structure, including</span>
   <span class="s0">following blocks that `belong' to it, but excluding trailing blank</span>
   <span class="s0">and comment lines.  E.g., if on a `try' statement, the `try' block</span>
   <span class="s0">and all (if any) of the following `except' and `finally' blocks</span>
   <span class="s0">that belong to the `try' structure will be in the region.  Ditto</span>
   <span class="s0">for if/elif/else, for/else and while/else structures, and (a bit</span>
   <span class="s0">degenerate, since they're always one-block structures) def and</span>
   <span class="s0">class blocks.</span>

 <span class="s0">- Else if no prefix argument is given, and the line begins a Python</span>
   <span class="s0">block (see list above), and the block is not a `one-liner' (i.e.,</span>
   <span class="s0">the statement ends with a colon, not with code), the region will</span>
   <span class="s0">include all succeeding lines up to (but not including) the next</span>
   <span class="s0">code statement (if any) that's indented no more than the starting</span>
   <span class="s0">line, except that trailing blank and comment lines are excluded.</span>
   <span class="s0">E.g., if the starting line begins a multi-statement `def'</span>
   <span class="s0">structure, the region will be set to the full function definition,</span>
   <span class="s0">but without any trailing `noise' lines.</span>

 <span class="s0">- Else the region will include all succeeding lines up to (but not</span>
   <span class="s0">including) the next blank line, or code or indenting-comment line</span>
   <span class="s0">indented strictly less than the starting line.  Trailing indenting</span>
   <span class="s0">comment lines are included in this case, but not trailing blank</span>
   <span class="s0">lines.</span>

<span class="s0">A msg identifying the location of the mark is displayed in the echo</span>
<span class="s0">area; or do `\\[exchange-point-and-mark]' to flip down to the end.</span>

<span class="s0">If called from a program, optional argument EXTEND plays the role of</span>
<span class="s0">the prefix arg, and if optional argument JUST-MOVE is not nil, just</span>
<span class="s0">moves to the end of the block (&amp; does not set mark or display a msg).&quot;</span>
  <span class="s0">(interactive &quot;P&quot;); raw prefix arg</span>
  <span class="s0">(py-goto-initial-line)</span>
  <span class="s0">;; skip over blank lines</span>
  <span class="s0">(while (and</span>
	  <span class="s0">(looking-at &quot;[ \t]*$&quot;); while blank line</span>
	  <span class="s0">(not (eobp))); &amp; somewhere to go</span>
    <span class="s0">(forward-line 1))</span>
  <span class="s0">(if (eobp)</span>
      <span class="s0">(error &quot;Hit end of buffer without finding a non-blank stmt&quot;))</span>
  <span class="s0">(let ((initial-pos (point))</span>
	<span class="s0">(initial-indent (current-indentation))</span>
	<span class="s0">last-pos; position of last stmt in region</span>
	<span class="s0">(followers</span>
	 <span class="s0">'((if elif else) (elif elif else) (else)</span>
	   <span class="s0">(try except finally) (except except) (finally)</span>
	   <span class="s0">(for else) (while else)</span>
	   <span class="s0">(def) (class) ) )</span>
	<span class="s0">first-symbol next-symbol)</span>

    <span class="s0">(cond</span>
     <span class="s0">;; if comment line, suck up the following comment lines</span>
     <span class="s0">((looking-at &quot;[ \t]*#&quot;)</span>
      <span class="s0">(re-search-forward &quot;^[ \t]*[^ \t#]&quot; nil 'move) ; look for non-comment</span>
      <span class="s0">(re-search-backward &quot;^[ \t]*#&quot;); and back to last comment in block</span>
      <span class="s0">(setq last-pos (point)))</span>

     <span class="s0">;; else if line is a block line and EXTEND given, suck up</span>
     <span class="s0">;; the whole structure</span>
     <span class="s0">((and extend</span>
	   <span class="s0">(setq first-symbol (py-suck-up-first-keyword) )</span>
	   <span class="s0">(assq first-symbol followers))</span>
      <span class="s0">(while (and</span>
	      <span class="s0">(or (py-goto-beyond-block) t) ; side effect</span>
	      <span class="s0">(forward-line -1); side effect</span>
	      <span class="s0">(setq last-pos (point)); side effect</span>
	      <span class="s0">(py-goto-statement-below)</span>
	      <span class="s0">(= (current-indentation) initial-indent)</span>
	      <span class="s0">(setq next-symbol (py-suck-up-first-keyword))</span>
	      <span class="s0">(memq next-symbol (cdr (assq first-symbol followers))))</span>
	<span class="s0">(setq first-symbol next-symbol)))</span>

     <span class="s0">;; else if line *opens* a block, search for next stmt indented &lt;=</span>
     <span class="s0">((py-statement-opens-block-p)</span>
      <span class="s0">(while (and</span>
	      <span class="s0">(setq last-pos (point)); always true -- side effect</span>
	      <span class="s0">(py-goto-statement-below)</span>
	      <span class="s0">(&gt; (current-indentation) initial-indent))</span>
	<span class="s0">nil))</span>

     <span class="s0">;; else plain code line; stop at next blank line, or stmt or</span>
     <span class="s0">;; indenting comment line indented &lt;</span>
     <span class="s0">(t</span>
      <span class="s0">(while (and</span>
	      <span class="s0">(setq last-pos (point)); always true -- side effect</span>
	      <span class="s0">(or (py-goto-beyond-final-line) t)</span>
	      <span class="s0">(not (looking-at &quot;[ \t]*$&quot;)) ; stop at blank line</span>
	      <span class="s0">(or</span>
	       <span class="s0">(&gt;= (current-indentation) initial-indent)</span>
	       <span class="s0">(looking-at &quot;[ \t]*#[^ \t\n]&quot;))) ; ignore non-indenting #</span>
	<span class="s0">nil)))</span>

    <span class="s0">;; skip to end of last stmt</span>
    <span class="s0">(goto-char last-pos)</span>
    <span class="s0">(py-goto-beyond-final-line)</span>

    <span class="s0">;; set mark &amp; display</span>
    <span class="s0">(if just-move</span>
	<span class="s0">(); just return</span>
      <span class="s0">(push-mark (point) 'no-msg)</span>
      <span class="s0">(forward-line -1)</span>
      <span class="s0">(message &quot;Mark set after: %s&quot; (py-suck-up-leading-text))</span>
      <span class="s0">(goto-char initial-pos))))</span>

<span class="s0">(defun py-mark-def-or-class (&amp;optional class)</span>
  <span class="s0">&quot;Set region to body of def (or class, with prefix arg) enclosing point.</span>
<span class="s0">Pushes the current mark, then point, on the mark ring (all language</span>
<span class="s0">modes do this, but although it's handy it's never documented ...).</span>

<span class="s0">In most Emacs language modes, this function bears at least a</span>
<span class="s0">hallucinogenic resemblance to `\\[py-end-of-def-or-class]' and</span>
<span class="s0">`\\[py-beginning-of-def-or-class]'.</span>

<span class="s0">And in earlier versions of Python mode, all 3 were tightly connected.</span>
<span class="s0">Turned out that was more confusing than useful: the `goto start' and</span>
<span class="s0">`goto end' commands are usually used to search through a file, and</span>
<span class="s0">people expect them to act a lot like `search backward' and `search</span>
<span class="s0">forward' string-search commands.  But because Python `def' and `class'</span>
<span class="s0">can nest to arbitrary levels, finding the smallest def containing</span>
<span class="s0">point cannot be done via a simple backward search: the def containing</span>
<span class="s0">point may not be the closest preceding def, or even the closest</span>
<span class="s0">preceding def that's indented less.  The fancy algorithm required is</span>
<span class="s0">appropriate for the usual uses of this `mark' command, but not for the</span>
<span class="s0">`goto' variations.</span>

<span class="s0">So the def marked by this command may not be the one either of the</span>
<span class="s0">`goto' commands find: If point is on a blank or non-indenting comment</span>
<span class="s0">line, moves back to start of the closest preceding code statement or</span>
<span class="s0">indenting comment line.  If this is a `def' statement, that's the def</span>
<span class="s0">we use.  Else searches for the smallest enclosing `def' block and uses</span>
<span class="s0">that.  Else signals an error.</span>

<span class="s0">When an enclosing def is found: The mark is left immediately beyond</span>
<span class="s0">the last line of the def block.  Point is left at the start of the</span>
<span class="s0">def, except that: if the def is preceded by a number of comment lines</span>
<span class="s0">followed by (at most) one optional blank line, point is left at the</span>
<span class="s0">start of the comments; else if the def is preceded by a blank line,</span>
<span class="s0">point is left at its start.</span>

<span class="s0">The intent is to mark the containing def/class and its associated</span>
<span class="s0">documentation, to make moving and duplicating functions and classes</span>
<span class="s0">pleasant.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;); raw prefix arg</span>
  <span class="s0">(let ((start (point))</span>
	<span class="s0">(which (cond ((eq class 'either) &quot;\\(class\\|def\\)&quot;)</span>
		     <span class="s0">(class &quot;class&quot;)</span>
		     <span class="s0">(t &quot;def&quot;))))</span>
    <span class="s0">(push-mark start)</span>
    <span class="s0">(if (not (py-go-up-tree-to-keyword which))</span>
	<span class="s0">(progn (goto-char start)</span>
	       <span class="s0">(error &quot;Enclosing %s not found&quot;</span>
		      <span class="s0">(if (eq class 'either)</span>
			  <span class="s0">&quot;def or class&quot;</span>
			<span class="s0">which)))</span>
      <span class="s0">;; else enclosing def/class found</span>
      <span class="s0">(setq start (point))</span>
      <span class="s0">(py-goto-beyond-block)</span>
      <span class="s0">(push-mark (point))</span>
      <span class="s0">(goto-char start)</span>
      <span class="s0">(if (zerop (forward-line -1)); if there is a preceding line</span>
	  <span class="s0">(progn</span>
	    <span class="s0">(if (looking-at &quot;[ \t]*$&quot;); it's blank</span>
		<span class="s0">(setq start (point)); so reset start point</span>
	      <span class="s0">(goto-char start)); else try again</span>
	    <span class="s0">(if (zerop (forward-line -1))</span>
		<span class="s0">(if (looking-at &quot;[ \t]*#&quot;) ; a comment</span>
		    <span class="s0">;; look back for non-comment line</span>
		    <span class="s0">;; tricky: note that the regexp matches a blank</span>
		    <span class="s0">;; line, cuz \n is in the 2nd character class</span>
		    <span class="s0">(and</span>
		     <span class="s0">(re-search-backward &quot;^[ \t]*[^ \t#]&quot; nil 'move)</span>
		     <span class="s0">(forward-line 1))</span>
		  <span class="s0">;; no comment, so go back</span>
		  <span class="s0">(goto-char start)))))))</span>
  <span class="s0">(exchange-point-and-mark)</span>
  <span class="s0">(py-keep-region-active))</span>

<span class="s0">;; ripped from cc-mode</span>
<span class="s0">(defun py-forward-into-nomenclature (&amp;optional arg)</span>
  <span class="s0">&quot;Move forward to end of a nomenclature section or word.</span>
<span class="s0">With \\[universal-argument] (programmatically, optional argument ARG), </span>
<span class="s0">do it that many times.</span>

<span class="s0">A `nomenclature' is a fancy way of saying AWordWithMixedCaseNotUnderscores.&quot;</span>
  <span class="s0">(interactive &quot;p&quot;)</span>
  <span class="s0">(let ((case-fold-search nil))</span>
    <span class="s0">(if (&gt; arg 0)</span>
	<span class="s0">(re-search-forward</span>
	 <span class="s0">&quot;\\(\\W\\|[_]\\)*\\([A-Z]*[a-z0-9]*\\)&quot;</span>
	 <span class="s0">(point-max) t arg)</span>
      <span class="s0">(while (and (&lt; arg 0)</span>
		  <span class="s0">(re-search-backward</span>
		   <span class="s0">&quot;\\(\\W\\|[a-z0-9]\\)[A-Z]+\\|\\(\\W\\|[_]\\)\\w+&quot;</span>
		   <span class="s0">(point-min) 0))</span>
	<span class="s0">(forward-char 1)</span>
	<span class="s0">(setq arg (1+ arg)))))</span>
  <span class="s0">(py-keep-region-active))</span>

<span class="s0">(defun py-backward-into-nomenclature (&amp;optional arg)</span>
  <span class="s0">&quot;Move backward to beginning of a nomenclature section or word.</span>
<span class="s0">With optional ARG, move that many times.  If ARG is negative, move</span>
<span class="s0">forward.</span>

<span class="s0">A `nomenclature' is a fancy way of saying AWordWithMixedCaseNotUnderscores.&quot;</span>
  <span class="s0">(interactive &quot;p&quot;)</span>
  <span class="s0">(py-forward-into-nomenclature (- arg))</span>
  <span class="s0">(py-keep-region-active))</span>



<span class="s0">;; Documentation functions</span>

<span class="s0">;; dump the long form of the mode blurb; does the usual doc escapes,</span>
<span class="s0">;; plus lines of the form ^[vc]:name$ to suck variable &amp; command docs</span>
<span class="s0">;; out of the right places, along with the keys they're on &amp; current</span>
<span class="s0">;; values</span>
<span class="s0">(defun py-dump-help-string (str)</span>
  <span class="s0">(with-output-to-temp-buffer &quot;*Help*&quot;</span>
    <span class="s0">(let ((locals (buffer-local-variables))</span>
	  <span class="s0">funckind funcname func funcdoc</span>
	  <span class="s0">(start 0) mstart end</span>
	  <span class="s0">keys )</span>
      <span class="s0">(while (string-match &quot;^%\\([vc]\\):\\(.+\\)\n&quot; str start)</span>
	<span class="s0">(setq mstart (match-beginning 0)  end (match-end 0)</span>
	      <span class="s0">funckind (substring str (match-beginning 1) (match-end 1))</span>
	      <span class="s0">funcname (substring str (match-beginning 2) (match-end 2))</span>
	      <span class="s0">func (intern funcname))</span>
	<span class="s0">(princ (substitute-command-keys (substring str start mstart)))</span>
	<span class="s0">(cond</span>
	 <span class="s0">((equal funckind &quot;c&quot;); command</span>
	  <span class="s0">(setq funcdoc (documentation func)</span>
		<span class="s0">keys (concat</span>
		      <span class="s0">&quot;Key(s): &quot;</span>
		      <span class="s0">(mapconcat 'key-description</span>
				 <span class="s0">(where-is-internal func py-mode-map)</span>
				 <span class="s0">&quot;, &quot;))))</span>
	 <span class="s0">((equal funckind &quot;v&quot;); variable</span>
	  <span class="s0">(setq funcdoc (documentation-property func 'variable-documentation)</span>
		<span class="s0">keys (if (assq func locals)</span>
			 <span class="s0">(concat</span>
			  <span class="s0">&quot;Local/Global values: &quot;</span>
			  <span class="s0">(prin1-to-string (symbol-value func))</span>
			  <span class="s0">&quot; / &quot;</span>
			  <span class="s0">(prin1-to-string (default-value func)))</span>
		       <span class="s0">(concat</span>
			<span class="s0">&quot;Value: &quot;</span>
			<span class="s0">(prin1-to-string (symbol-value func))))))</span>
	 <span class="s0">(t; unexpected</span>
	  <span class="s0">(error &quot;Error in py-dump-help-string, tag `%s'&quot; funckind)))</span>
	<span class="s0">(princ (format &quot;\n-&gt; %s:\t%s\t%s\n\n&quot;</span>
		       <span class="s0">(if (equal funckind &quot;c&quot;) &quot;Command&quot; &quot;Variable&quot;)</span>
		       <span class="s0">funcname keys))</span>
	<span class="s0">(princ funcdoc)</span>
	<span class="s0">(terpri)</span>
	<span class="s0">(setq start end))</span>
      <span class="s0">(princ (substitute-command-keys (substring str start))))</span>
    <span class="s0">(print-help-return-message)))</span>

<span class="s0">(defun py-describe-mode ()</span>
  <span class="s0">&quot;Dump long form of Python-mode docs.&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(py-dump-help-string &quot;Major mode for editing Python files.</span>
<span class="s0">Knows about Python indentation, tokens, comments and continuation lines.</span>
<span class="s0">Paragraphs are separated by blank lines only.</span>

<span class="s0">Major sections below begin with the string `@'; specific function and</span>
<span class="s0">variable docs begin with `-&gt;'.</span>

<span class="s0">@EXECUTING PYTHON CODE</span>

<span class="s0">\\[py-execute-import-or-reload]\timports or reloads the file in the Python interpreter</span>
<span class="s0">\\[py-execute-buffer]\tsends the entire buffer to the Python interpreter</span>
<span class="s0">\\[py-execute-region]\tsends the current region</span>
<span class="s0">\\[py-execute-def-or-class]\tsends the current function or class definition</span>
<span class="s0">\\[py-execute-string]\tsends an arbitrary string</span>
<span class="s0">\\[py-shell]\tstarts a Python interpreter window; this will be used by</span>
<span class="s0">\tsubsequent Python execution commands</span>
<span class="s0">%c:py-execute-import-or-reload</span>
<span class="s0">%c:py-execute-buffer</span>
<span class="s0">%c:py-execute-region</span>
<span class="s0">%c:py-execute-def-or-class</span>
<span class="s0">%c:py-execute-string</span>
<span class="s0">%c:py-shell</span>

<span class="s0">@VARIABLES</span>

<span class="s0">py-indent-offset\tindentation increment</span>
<span class="s0">py-block-comment-prefix\tcomment string used by comment-region</span>

<span class="s0">py-python-command\tshell command to invoke Python interpreter</span>
<span class="s0">py-temp-directory\tdirectory used for temp files (if needed)</span>

<span class="s0">py-beep-if-tab-change\tring the bell if tab-width is changed</span>
<span class="s0">%v:py-indent-offset</span>
<span class="s0">%v:py-block-comment-prefix</span>
<span class="s0">%v:py-python-command</span>
<span class="s0">%v:py-temp-directory</span>
<span class="s0">%v:py-beep-if-tab-change</span>

<span class="s0">@KINDS OF LINES</span>

<span class="s0">Each physical line in the file is either a `continuation line' (the</span>
<span class="s0">preceding line ends with a backslash that's not part of a comment, or</span>
<span class="s0">the paren/bracket/brace nesting level at the start of the line is</span>
<span class="s0">non-zero, or both) or an `initial line' (everything else).</span>

<span class="s0">An initial line is in turn a `blank line' (contains nothing except</span>
<span class="s0">possibly blanks or tabs), a `comment line' (leftmost non-blank</span>
<span class="s0">character is `#'), or a `code line' (everything else).</span>

<span class="s0">Comment Lines</span>

<span class="s0">Although all comment lines are treated alike by Python, Python mode</span>
<span class="s0">recognizes two kinds that act differently with respect to indentation.</span>

<span class="s0">An `indenting comment line' is a comment line with a blank, tab or</span>
<span class="s0">nothing after the initial `#'.  The indentation commands (see below)</span>
<span class="s0">treat these exactly as if they were code lines: a line following an</span>
<span class="s0">indenting comment line will be indented like the comment line.  All</span>
<span class="s0">other comment lines (those with a non-whitespace character immediately</span>
<span class="s0">following the initial `#') are `non-indenting comment lines', and</span>
<span class="s0">their indentation is ignored by the indentation commands.</span>

<span class="s0">Indenting comment lines are by far the usual case, and should be used</span>
<span class="s0">whenever possible.  Non-indenting comment lines are useful in cases</span>
<span class="s0">like these:</span>

<span class="s0">\ta = b   # a very wordy single-line comment that ends up being</span>
<span class="s0">\t        #... continued onto another line</span>

<span class="s0">\tif a == b:</span>
<span class="s0">##\t\tprint 'panic!' # old code we've `commented out'</span>
<span class="s0">\t\treturn a</span>

<span class="s0">Since the `#...' and `##' comment lines have a non-whitespace</span>
<span class="s0">character following the initial `#', Python mode ignores them when</span>
<span class="s0">computing the proper indentation for the next line.</span>

<span class="s0">Continuation Lines and Statements</span>

<span class="s0">The Python-mode commands generally work on statements instead of on</span>
<span class="s0">individual lines, where a `statement' is a comment or blank line, or a</span>
<span class="s0">code line and all of its following continuation lines (if any)</span>
<span class="s0">considered as a single logical unit.  The commands in this mode</span>
<span class="s0">generally (when it makes sense) automatically move to the start of the</span>
<span class="s0">statement containing point, even if point happens to be in the middle</span>
<span class="s0">of some continuation line.</span>


<span class="s0">@INDENTATION</span>

<span class="s0">Primarily for entering new code:</span>
<span class="s0">\t\\[indent-for-tab-command]\t indent line appropriately</span>
<span class="s0">\t\\[py-newline-and-indent]\t insert newline, then indent</span>
<span class="s0">\t\\[py-electric-backspace]\t reduce indentation, or delete single character</span>

<span class="s0">Primarily for reindenting existing code:</span>
<span class="s0">\t\\[py-guess-indent-offset]\t guess py-indent-offset from file content; change locally</span>
<span class="s0">\t\\[universal-argument] \\[py-guess-indent-offset]\t ditto, but change globally</span>

<span class="s0">\t\\[py-indent-region]\t reindent region to match its context</span>
<span class="s0">\t\\[py-shift-region-left]\t shift region left by py-indent-offset</span>
<span class="s0">\t\\[py-shift-region-right]\t shift region right by py-indent-offset</span>

<span class="s0">Unlike most programming languages, Python uses indentation, and only</span>
<span class="s0">indentation, to specify block structure.  Hence the indentation supplied</span>
<span class="s0">automatically by Python-mode is just an educated guess:  only you know</span>
<span class="s0">the block structure you intend, so only you can supply correct</span>
<span class="s0">indentation.</span>

<span class="s0">The \\[indent-for-tab-command] and \\[py-newline-and-indent] keys try to suggest plausible indentation, based on</span>
<span class="s0">the indentation of preceding statements.  E.g., assuming</span>
<span class="s0">py-indent-offset is 4, after you enter</span>
<span class="s0">\tif a &gt; 0: \\[py-newline-and-indent]</span>
<span class="s0">the cursor will be moved to the position of the `_' (_ is not a</span>
<span class="s0">character in the file, it's just used here to indicate the location of</span>
<span class="s0">the cursor):</span>
<span class="s0">\tif a &gt; 0:</span>
<span class="s0">\t    _</span>
<span class="s0">If you then enter `c = d' \\[py-newline-and-indent], the cursor will move</span>
<span class="s0">to</span>
<span class="s0">\tif a &gt; 0:</span>
<span class="s0">\t    c = d</span>
<span class="s0">\t    _</span>
<span class="s0">Python-mode cannot know whether that's what you intended, or whether</span>
<span class="s0">\tif a &gt; 0:</span>
<span class="s0">\t    c = d</span>
<span class="s0">\t_</span>
<span class="s0">was your intent.  In general, Python-mode either reproduces the</span>
<span class="s0">indentation of the (closest code or indenting-comment) preceding</span>
<span class="s0">statement, or adds an extra py-indent-offset blanks if the preceding</span>
<span class="s0">statement has `:' as its last significant (non-whitespace and non-</span>
<span class="s0">comment) character.  If the suggested indentation is too much, use</span>
<span class="s0">\\[py-electric-backspace] to reduce it.</span>

<span class="s0">Continuation lines are given extra indentation.  If you don't like the</span>
<span class="s0">suggested indentation, change it to something you do like, and Python-</span>
<span class="s0">mode will strive to indent later lines of the statement in the same way.</span>

<span class="s0">If a line is a continuation line by virtue of being in an unclosed</span>
<span class="s0">paren/bracket/brace structure (`list', for short), the suggested</span>
<span class="s0">indentation depends on whether the current line contains the first item</span>
<span class="s0">in the list.  If it does, it's indented py-indent-offset columns beyond</span>
<span class="s0">the indentation of the line containing the open bracket.  If you don't</span>
<span class="s0">like that, change it by hand.  The remaining items in the list will mimic</span>
<span class="s0">whatever indentation you give to the first item.</span>

<span class="s0">If a line is a continuation line because the line preceding it ends with</span>
<span class="s0">a backslash, the third and following lines of the statement inherit their</span>
<span class="s0">indentation from the line preceding them.  The indentation of the second</span>
<span class="s0">line in the statement depends on the form of the first (base) line:  if</span>
<span class="s0">the base line is an assignment statement with anything more interesting</span>
<span class="s0">than the backslash following the leftmost assigning `=', the second line</span>
<span class="s0">is indented two columns beyond that `='.  Else it's indented to two</span>
<span class="s0">columns beyond the leftmost solid chunk of non-whitespace characters on</span>
<span class="s0">the base line.</span>

<span class="s0">Warning:  indent-region should not normally be used!  It calls \\[indent-for-tab-command]</span>
<span class="s0">repeatedly, and as explained above, \\[indent-for-tab-command] can't guess the block</span>
<span class="s0">structure you intend.</span>
<span class="s0">%c:indent-for-tab-command</span>
<span class="s0">%c:py-newline-and-indent</span>
<span class="s0">%c:py-electric-backspace</span>


<span class="s0">The next function may be handy when editing code you didn't write:</span>
<span class="s0">%c:py-guess-indent-offset</span>


<span class="s0">The remaining `indent' functions apply to a region of Python code.  They</span>
<span class="s0">assume the block structure (equals indentation, in Python) of the region</span>
<span class="s0">is correct, and alter the indentation in various ways while preserving</span>
<span class="s0">the block structure:</span>
<span class="s0">%c:py-indent-region</span>
<span class="s0">%c:py-shift-region-left</span>
<span class="s0">%c:py-shift-region-right</span>

<span class="s0">@MARKING &amp; MANIPULATING REGIONS OF CODE</span>

<span class="s0">\\[py-mark-block]\t mark block of lines</span>
<span class="s0">\\[py-mark-def-or-class]\t mark smallest enclosing def</span>
<span class="s0">\\[universal-argument] \\[py-mark-def-or-class]\t mark smallest enclosing class</span>
<span class="s0">\\[comment-region]\t comment out region of code</span>
<span class="s0">\\[universal-argument] \\[comment-region]\t uncomment region of code</span>
<span class="s0">%c:py-mark-block</span>
<span class="s0">%c:py-mark-def-or-class</span>
<span class="s0">%c:comment-region</span>

<span class="s0">@MOVING POINT</span>

<span class="s0">\\[py-previous-statement]\t move to statement preceding point</span>
<span class="s0">\\[py-next-statement]\t move to statement following point</span>
<span class="s0">\\[py-goto-block-up]\t move up to start of current block</span>
<span class="s0">\\[py-beginning-of-def-or-class]\t move to start of def</span>
<span class="s0">\\[universal-argument] \\[py-beginning-of-def-or-class]\t move to start of class</span>
<span class="s0">\\[py-end-of-def-or-class]\t move to end of def</span>
<span class="s0">\\[universal-argument] \\[py-end-of-def-or-class]\t move to end of class</span>

<span class="s0">The first two move to one statement beyond the statement that contains</span>
<span class="s0">point.  A numeric prefix argument tells them to move that many</span>
<span class="s0">statements instead.  Blank lines, comment lines, and continuation lines</span>
<span class="s0">do not count as `statements' for these commands.  So, e.g., you can go</span>
<span class="s0">to the first code statement in a file by entering</span>
<span class="s0">\t\\[beginning-of-buffer]\t to move to the top of the file</span>
<span class="s0">\t\\[py-next-statement]\t to skip over initial comments and blank lines</span>
<span class="s0">Or do `\\[py-previous-statement]' with a huge prefix argument.</span>
<span class="s0">%c:py-previous-statement</span>
<span class="s0">%c:py-next-statement</span>
<span class="s0">%c:py-goto-block-up</span>
<span class="s0">%c:py-beginning-of-def-or-class</span>
<span class="s0">%c:py-end-of-def-or-class</span>

<span class="s0">@LITTLE-KNOWN EMACS COMMANDS PARTICULARLY USEFUL IN PYTHON MODE</span>

<span class="s0">`\\[indent-new-comment-line]' is handy for entering a multi-line comment.</span>

<span class="s0">`\\[set-selective-display]' with a `small' prefix arg is ideally suited for viewing the</span>
<span class="s0">overall class and def structure of a module.</span>

<span class="s0">`\\[back-to-indentation]' moves point to a line's first non-blank character.</span>

<span class="s0">`\\[indent-relative]' is handy for creating odd indentation.</span>

<span class="s0">@OTHER EMACS HINTS</span>

<span class="s0">If you don't like the default value of a variable, change its value to</span>
<span class="s0">whatever you do like by putting a `setq' line in your .emacs file.</span>
<span class="s0">E.g., to set the indentation increment to 4, put this line in your</span>
<span class="s0">.emacs:</span>
<span class="s0">\t(setq  py-indent-offset  4)</span>
<span class="s0">To see the value of a variable, do `\\[describe-variable]' and enter the variable</span>
<span class="s0">name at the prompt.</span>

<span class="s0">When entering a key sequence like `C-c C-n', it is not necessary to</span>
<span class="s0">release the CONTROL key after doing the `C-c' part -- it suffices to</span>
<span class="s0">press the CONTROL key, press and release `c' (while still holding down</span>
<span class="s0">CONTROL), press and release `n' (while still holding down CONTROL), &amp;</span>
<span class="s0">then release CONTROL.</span>

<span class="s0">Entering Python mode calls with no arguments the value of the variable</span>
<span class="s0">`python-mode-hook', if that value exists and is not nil; for backward</span>
<span class="s0">compatibility it also tries `py-mode-hook'; see the `Hooks' section of</span>
<span class="s0">the Elisp manual for details.</span>

<span class="s0">Obscure:  When python-mode is first loaded, it looks for all bindings</span>
<span class="s0">to newline-and-indent in the global keymap, and shadows them with</span>
<span class="s0">local bindings to py-newline-and-indent.&quot;))</span>


<span class="s0">;; Helper functions</span>
<span class="s0">(defvar py-parse-state-re</span>
  <span class="s0">(concat</span>
   <span class="s0">&quot;^[ \t]*\\(if\\|elif\\|else\\|while\\|def\\|class\\)\\&gt;&quot;</span>
   <span class="s0">&quot;\\|&quot;</span>
   <span class="s0">&quot;^[^ #\t\n]&quot;))</span>

<span class="s0">(defun py-parse-state ()</span>
  <span class="s0">&quot;Return the parse state at point (see `parse-partial-sexp' docs).&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(let ((here (point))</span>
	  <span class="s0">pps done)</span>
      <span class="s0">(while (not done)</span>
	<span class="s0">;; back up to the first preceding line (if any; else start of</span>
	<span class="s0">;; buffer) that begins with a popular Python keyword, or a</span>
	<span class="s0">;; non- whitespace and non-comment character.  These are good</span>
	<span class="s0">;; places to start parsing to see whether where we started is</span>
	<span class="s0">;; at a non-zero nesting level.  It may be slow for people who</span>
	<span class="s0">;; write huge code blocks or huge lists ... tough beans.</span>
	<span class="s0">(re-search-backward py-parse-state-re nil 'move)</span>
	<span class="s0">(beginning-of-line)</span>
	<span class="s0">;; In XEmacs, we have a much better way to test for whether</span>
	<span class="s0">;; we're in a triple-quoted string or not.  Emacs does not</span>
	<span class="s0">;; have this built-in function, which is its loss because</span>
	<span class="s0">;; without scanning from the beginning of the buffer, there's</span>
	<span class="s0">;; no accurate way to determine this otherwise.</span>
	<span class="s0">(if (not (fboundp 'buffer-syntactic-context))</span>
	    <span class="s0">;; Emacs</span>
	    <span class="s0">(progn</span>
	      <span class="s0">(save-excursion (setq pps (parse-partial-sexp (point) here)))</span>
	      <span class="s0">;; make sure we don't land inside a triple-quoted string</span>
	      <span class="s0">(setq done (or (not (nth 3 pps))</span>
			     <span class="s0">(bobp)))</span>
	      <span class="s0">;; Just go ahead and short circuit the test back to the</span>
	      <span class="s0">;; beginning of the buffer.  This will be slow, but not</span>
	      <span class="s0">;; nearly as slow as looping through many</span>
	      <span class="s0">;; re-search-backwards.</span>
	      <span class="s0">(if (not done)</span>
		  <span class="s0">(goto-char (point-min))))</span>
	  <span class="s0">;; XEmacs</span>
	  <span class="s0">(setq done (or (not (buffer-syntactic-context))</span>
			 <span class="s0">(bobp)))</span>
	  <span class="s0">(when done</span>
		<span class="s0">(setq pps (parse-partial-sexp (point) here)))</span>
	  <span class="s0">))</span>
      <span class="s0">pps)))</span>

<span class="s0">(defun py-nesting-level ()</span>
  <span class="s0">&quot;Return the buffer position of the last unclosed enclosing list.</span>
<span class="s0">If nesting level is zero, return nil.&quot;</span>
  <span class="s0">(let ((status (py-parse-state)))</span>
    <span class="s0">(if (zerop (car status))</span>
	<span class="s0">nil; not in a nest</span>
      <span class="s0">(car (cdr status))))); char# of open bracket</span>

<span class="s0">(defun py-backslash-continuation-line-p ()</span>
  <span class="s0">&quot;Return t iff preceding line ends with backslash that is not in a comment.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(beginning-of-line)</span>
    <span class="s0">(and</span>
     <span class="s0">;; use a cheap test first to avoid the regexp if possible</span>
     <span class="s0">;; use 'eq' because char-after may return nil</span>
     <span class="s0">(eq (char-after (- (point) 2)) ?\\ )</span>
     <span class="s0">;; make sure; since eq test passed, there is a preceding line</span>
     <span class="s0">(forward-line -1); always true -- side effect</span>
     <span class="s0">(looking-at py-continued-re))))</span>

<span class="s0">(defun py-continuation-line-p ()</span>
  <span class="s0">&quot;Return t iff current line is a continuation line.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(beginning-of-line)</span>
    <span class="s0">(or (py-backslash-continuation-line-p)</span>
	<span class="s0">(py-nesting-level))))</span>

<span class="s0">(defun py-goto-beginning-of-tqs (delim)</span>
  <span class="s0">&quot;Go to the beginning of the triple quoted string we find ourselves in.</span>
<span class="s0">DELIM is the TQS string delimiter character we're searching backwards</span>
<span class="s0">for.&quot;</span>
  <span class="s0">(let ((skip (and delim (make-string 1 delim))))</span>
    <span class="s0">(when skip</span>
      <span class="s0">(save-excursion</span>
	<span class="s0">(py-safe (search-backward skip))</span>
	<span class="s0">(if (and (eq (char-before) delim)</span>
		 <span class="s0">(eq (char-before (1- (point))) delim))</span>
	    <span class="s0">(setq skip (make-string 3 delim))))</span>
      <span class="s0">;; we're looking at a triple-quoted string</span>
      <span class="s0">(py-safe (search-backward skip)))))</span>

<span class="s0">(defun py-goto-initial-line ()</span>
  <span class="s0">&quot;Go to the initial line of the current statement.</span>
<span class="s0">Usually this is the line we're on, but if we're on the 2nd or</span>
<span class="s0">following lines of a continuation block, we need to go up to the first</span>
<span class="s0">line of the block.&quot;</span>
  <span class="s0">;; Tricky: We want to avoid quadratic-time behavior for long</span>
  <span class="s0">;; continued blocks, whether of the backslash or open-bracket</span>
  <span class="s0">;; varieties, or a mix of the two.  The following manages to do that</span>
  <span class="s0">;; in the usual cases.</span>
  <span class="s0">;;</span>
  <span class="s0">;; Also, if we're sitting inside a triple quoted string, this will</span>
  <span class="s0">;; drop us at the line that begins the string.</span>
  <span class="s0">(let (open-bracket-pos)</span>
    <span class="s0">(while (py-continuation-line-p)</span>
      <span class="s0">(beginning-of-line)</span>
      <span class="s0">(if (py-backslash-continuation-line-p)</span>
	  <span class="s0">(while (py-backslash-continuation-line-p)</span>
	    <span class="s0">(forward-line -1))</span>
	<span class="s0">;; else zip out of nested brackets/braces/parens</span>
	<span class="s0">(while (setq open-bracket-pos (py-nesting-level))</span>
	  <span class="s0">(goto-char open-bracket-pos)))))</span>
  <span class="s0">(beginning-of-line))</span>

<span class="s0">(defun py-goto-beyond-final-line ()</span>
  <span class="s0">&quot;Go to the point just beyond the fine line of the current statement.</span>
<span class="s0">Usually this is the start of the next line, but if this is a</span>
<span class="s0">multi-line statement we need to skip over the continuation lines.&quot;</span>
  <span class="s0">;; Tricky: Again we need to be clever to avoid quadratic time</span>
  <span class="s0">;; behavior.</span>
  <span class="s0">;;</span>
  <span class="s0">;; XXX: Not quite the right solution, but deals with multi-line doc</span>
  <span class="s0">;; strings</span>
  <span class="s0">(if (looking-at (concat &quot;[ \t]*\\(&quot; py-stringlit-re &quot;\\)&quot;))</span>
      <span class="s0">(goto-char (match-end 0)))</span>
  <span class="s0">;;</span>
  <span class="s0">(forward-line 1)</span>
  <span class="s0">(let (state)</span>
    <span class="s0">(while (and (py-continuation-line-p)</span>
		<span class="s0">(not (eobp)))</span>
      <span class="s0">;; skip over the backslash flavor</span>
      <span class="s0">(while (and (py-backslash-continuation-line-p)</span>
		  <span class="s0">(not (eobp)))</span>
	<span class="s0">(forward-line 1))</span>
      <span class="s0">;; if in nest, zip to the end of the nest</span>
      <span class="s0">(setq state (py-parse-state))</span>
      <span class="s0">(if (and (not (zerop (car state)))</span>
	       <span class="s0">(not (eobp)))</span>
	  <span class="s0">(progn</span>
	    <span class="s0">(parse-partial-sexp (point) (point-max) 0 nil state)</span>
	    <span class="s0">(forward-line 1))))))</span>

<span class="s0">(defun py-statement-opens-block-p ()</span>
  <span class="s0">&quot;Return t iff the current statement opens a block.</span>
<span class="s0">I.e., iff it ends with a colon that is not in a comment.  Point should </span>
<span class="s0">be at the start of a statement.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(let ((start (point))</span>
	  <span class="s0">(finish (progn (py-goto-beyond-final-line) (1- (point))))</span>
	  <span class="s0">(searching t)</span>
	  <span class="s0">(answer nil)</span>
	  <span class="s0">state)</span>
      <span class="s0">(goto-char start)</span>
      <span class="s0">(while searching</span>
	<span class="s0">;; look for a colon with nothing after it except whitespace, and</span>
	<span class="s0">;; maybe a comment</span>
	<span class="s0">(if (re-search-forward &quot;:\\([ \t]\\|\\\\\n\\)*\\(#.*\\)?$&quot;</span>
			       <span class="s0">finish t)</span>
	    <span class="s0">(if (eq (point) finish); note: no `else' clause; just</span>
					<span class="s0">; keep searching if we're not at</span>
					<span class="s0">; the end yet</span>
		<span class="s0">;; sure looks like it opens a block -- but it might</span>
		<span class="s0">;; be in a comment</span>
		<span class="s0">(progn</span>
		  <span class="s0">(setq searching nil); search is done either way</span>
		  <span class="s0">(setq state (parse-partial-sexp start</span>
						  <span class="s0">(match-beginning 0)))</span>
		  <span class="s0">(setq answer (not (nth 4 state)))))</span>
	  <span class="s0">;; search failed: couldn't find another interesting colon</span>
	  <span class="s0">(setq searching nil)))</span>
      <span class="s0">answer)))</span>

<span class="s0">(defun py-statement-closes-block-p ()</span>
  <span class="s0">&quot;Return t iff the current statement closes a block.</span>
<span class="s0">I.e., if the line starts with `return', `raise', `break', `continue',</span>
<span class="s0">and `pass'.  This doesn't catch embedded statements.&quot;</span>
  <span class="s0">(let ((here (point)))</span>
    <span class="s0">(py-goto-initial-line)</span>
    <span class="s0">(back-to-indentation)</span>
    <span class="s0">(prog1</span>
	<span class="s0">(looking-at (concat py-block-closing-keywords-re &quot;\\&gt;&quot;))</span>
      <span class="s0">(goto-char here))))</span>

<span class="s0">(defun py-goto-beyond-block ()</span>
  <span class="s0">&quot;Go to point just beyond the final line of block begun by the current line.</span>
<span class="s0">This is the same as where `py-goto-beyond-final-line' goes unless</span>
<span class="s0">we're on colon line, in which case we go to the end of the block.</span>
<span class="s0">Assumes point is at the beginning of the line.&quot;</span>
  <span class="s0">(if (py-statement-opens-block-p)</span>
      <span class="s0">(py-mark-block nil 'just-move)</span>
    <span class="s0">(py-goto-beyond-final-line)))</span>

<span class="s0">(defun py-goto-statement-at-or-above ()</span>
  <span class="s0">&quot;Go to the start of the first statement at or preceding point.</span>
<span class="s0">Return t if there is such a statement, otherwise nil.  `Statement'</span>
<span class="s0">does not include blank lines, comments, or continuation lines.&quot;</span>
  <span class="s0">(py-goto-initial-line)</span>
  <span class="s0">(if (looking-at py-blank-or-comment-re)</span>
      <span class="s0">;; skip back over blank &amp; comment lines</span>
      <span class="s0">;; note:  will skip a blank or comment line that happens to be</span>
      <span class="s0">;; a continuation line too</span>
      <span class="s0">(if (re-search-backward &quot;^[ \t]*[^ \t#\n]&quot; nil t)</span>
	  <span class="s0">(progn (py-goto-initial-line) t)</span>
	<span class="s0">nil)</span>
    <span class="s0">t))</span>

<span class="s0">(defun py-goto-statement-below ()</span>
  <span class="s0">&quot;Go to start of the first statement following the statement containing point.</span>
<span class="s0">Return t if there is such a statement, otherwise nil.  `Statement'</span>
<span class="s0">does not include blank lines, comments, or continuation lines.&quot;</span>
  <span class="s0">(beginning-of-line)</span>
  <span class="s0">(let ((start (point)))</span>
    <span class="s0">(py-goto-beyond-final-line)</span>
    <span class="s0">(while (and</span>
	    <span class="s0">(looking-at py-blank-or-comment-re)</span>
	    <span class="s0">(not (eobp)))</span>
      <span class="s0">(forward-line 1))</span>
    <span class="s0">(if (eobp)</span>
	<span class="s0">(progn (goto-char start) nil)</span>
      <span class="s0">t)))</span>

<span class="s0">(defun py-go-up-tree-to-keyword (key)</span>
  <span class="s0">&quot;Go to beginning of statement starting with KEY, at or preceding point.</span>

<span class="s0">KEY is a regular expression describing a Python keyword.  Skip blank</span>
<span class="s0">lines and non-indenting comments.  If the statement found starts with</span>
<span class="s0">KEY, then stop, otherwise go back to first enclosing block starting</span>
<span class="s0">with KEY.  If successful, leave point at the start of the KEY line and </span>
<span class="s0">return t.  Otherwise, leav point at an undefined place and return nil.&quot;</span>
  <span class="s0">;; skip blanks and non-indenting #</span>
  <span class="s0">(py-goto-initial-line)</span>
  <span class="s0">(while (and</span>
	  <span class="s0">(looking-at &quot;[ \t]*\\($\\|#[^ \t\n]\\)&quot;)</span>
	  <span class="s0">(zerop (forward-line -1))); go back</span>
    <span class="s0">nil)</span>
  <span class="s0">(py-goto-initial-line)</span>
  <span class="s0">(let* ((re (concat &quot;[ \t]*&quot; key &quot;\\b&quot;))</span>
	 <span class="s0">(case-fold-search nil); let* so looking-at sees this</span>
	 <span class="s0">(found (looking-at re))</span>
	 <span class="s0">(dead nil))</span>
    <span class="s0">(while (not (or found dead))</span>
      <span class="s0">(condition-case nil; in case no enclosing block</span>
	  <span class="s0">(py-goto-block-up 'no-mark)</span>
	<span class="s0">(error (setq dead t)))</span>
      <span class="s0">(or dead (setq found (looking-at re))))</span>
    <span class="s0">(beginning-of-line)</span>
    <span class="s0">found))</span>

<span class="s0">(defun py-suck-up-leading-text ()</span>
  <span class="s0">&quot;Return string in buffer from start of indentation to end of line.</span>
<span class="s0">Prefix with \&quot;...\&quot; if leading whitespace was skipped.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(back-to-indentation)</span>
    <span class="s0">(concat</span>
     <span class="s0">(if (bolp) &quot;&quot; &quot;...&quot;)</span>
     <span class="s0">(buffer-substring (point) (progn (end-of-line) (point))))))</span>

<span class="s0">(defun py-suck-up-first-keyword ()</span>
  <span class="s0">&quot;Return first keyword on the line as a Lisp symbol.</span>
<span class="s0">`Keyword' is defined (essentially) as the regular expression</span>
<span class="s0">([a-z]+).  Returns nil if none was found.&quot;</span>
  <span class="s0">(let ((case-fold-search nil))</span>
    <span class="s0">(if (looking-at &quot;[ \t]*\\([a-z]+\\)\\b&quot;)</span>
<span class="s0">(intern (buffer-substring (match-beginning 1) (match-end 1)))</span>
      <span class="s0">nil)))</span>

<span class="s0">(defun py-current-defun ()</span>
  <span class="s0">&quot;Python value for `add-log-current-defun-function'.</span>
<span class="s0">This tells add-log.el how to find the current function/method/variable.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(if (re-search-backward py-defun-start-re nil t)</span>
	<span class="s0">(or (match-string 3)</span>
	    <span class="s0">(let ((method (match-string 2)))</span>
	      <span class="s0">(if (and (not (zerop (length (match-string 1))))</span>
		       <span class="s0">(re-search-backward py-class-start-re nil t))</span>
		  <span class="s0">(concat (match-string 1) &quot;.&quot; method)</span>
		<span class="s0">method)))</span>
      <span class="s0">nil)))</span>


<span class="s0">(defconst py-help-address &quot;python-mode@python.org&quot;</span>
  <span class="s0">&quot;Address accepting submission of bug reports.&quot;)</span>

<span class="s0">(defun py-version ()</span>
  <span class="s0">&quot;Echo the current version of `python-mode' in the minibuffer.&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(message &quot;Using `python-mode' version %s&quot; py-version)</span>
  <span class="s0">(py-keep-region-active))</span>

<span class="s0">;; only works under Emacs 19</span>
<span class="s0">;(eval-when-compile</span>
<span class="s0">;  (require 'reporter))</span>

<span class="s0">(defun py-submit-bug-report (enhancement-p)</span>
  <span class="s0">&quot;Submit via mail a bug report on `python-mode'.</span>
<span class="s0">With \\[universal-argument] (programmatically, argument ENHANCEMENT-P</span>
<span class="s0">non-nil) just submit an enhancement request.&quot;</span>
  <span class="s0">(interactive</span>
   <span class="s0">(list (not (y-or-n-p</span>
	       <span class="s0">&quot;Is this a bug report (hit `n' to send other comments)? &quot;))))</span>
  <span class="s0">(let ((reporter-prompt-for-summary-p (if enhancement-p</span>
					   <span class="s0">&quot;(Very) brief summary: &quot;</span>
					 <span class="s0">t)))</span>
    <span class="s0">(require 'reporter)</span>
    <span class="s0">(reporter-submit-bug-report</span>
     <span class="s0">py-help-address;address</span>
     <span class="s0">(concat &quot;python-mode &quot; py-version);pkgname</span>
     <span class="s0">;; varlist</span>
     <span class="s0">(if enhancement-p nil</span>
       <span class="s0">'(py-python-command</span>
	 <span class="s0">py-indent-offset</span>
	 <span class="s0">py-block-comment-prefix</span>
	 <span class="s0">py-temp-directory</span>
	 <span class="s0">py-beep-if-tab-change))</span>
     <span class="s0">nil;pre-hooks</span>
     <span class="s0">nil;post-hooks</span>
     <span class="s0">&quot;Dear Barry,&quot;);salutation</span>
    <span class="s0">(if enhancement-p nil</span>
      <span class="s0">(set-mark (point))</span>
      <span class="s0">(insert </span>
<span class="s0">&quot;Please replace this text with a sufficiently large code sample\n\</span>
<span class="s0">and an exact recipe so that I can reproduce your problem.  Failure\n\</span>
<span class="s0">to do so may mean a greater delay in fixing your bug.\n\n&quot;)</span>
      <span class="s0">(exchange-point-and-mark)</span>
      <span class="s0">(py-keep-region-active))))</span>


<span class="s0">(defun py-kill-emacs-hook ()</span>
  <span class="s0">&quot;Delete files in `py-file-queues'.</span>
<span class="s0">These are Python temporary files awaiting execution.&quot;</span>
  <span class="s0">(py-clear-queues)</span>
  <span class="s0">)</span>

<span class="s0">;; arrange to kill temp files when Emacs exists</span>
<span class="s0">(add-hook 'kill-emacs-hook 'py-kill-emacs-hook)</span>

<span class="s0">;; VR STUDIO ENHANCEMENT</span>
<span class="s0">(defun comint-delchar-or-maybe-python-resume (arg)</span>
  <span class="s0">&quot;Delete ARG characters forward or send a python-resume to subprocess.</span>
  <span class="s0">Sends a python-resume only if point is at the end of the buffer and there is no input.&quot;</span>
  <span class="s0">(interactive &quot;p&quot;)</span>
  <span class="s0">(let ((proc (get-buffer-process (current-buffer))))</span>
    <span class="s0">(if (and (eobp) proc (= (point) (marker-position (process-mark proc))))</span>
	<span class="s0">(let ((current (point)))</span>
	  <span class="s0">(goto-char (- current 4))</span>
	  <span class="s0">(if (or (search-forward &quot;&gt;&gt;&gt; &quot; current t)</span>
		  <span class="s0">(search-forward &quot;... &quot; current t))</span>
	      <span class="s0">(save-current-buffer</span>
		<span class="s0">(goto-char current)</span>
		<span class="s0">(for-all-py-procs</span>
		 <span class="s0">(lambda (proc)</span>
		   <span class="s0">(let ((procbuf (process-buffer proc)))</span>
		     <span class="s0">(set-buffer procbuf)</span>
		     <span class="s0">(let ((current (point)))</span>
		       <span class="s0">(goto-char (point-max))</span>
		       <span class="s0">(if (and (eobp) (= (point) (marker-position (process-mark proc))))</span>
			   <span class="s0">(let ()</span>
			     <span class="s0">(goto-char (- current 4))</span>
			     <span class="s0">(if (or (search-forward &quot;&gt;&gt;&gt; &quot; current t)</span>
				     <span class="s0">(search-forward &quot;... &quot; current t))</span>
				 <span class="s0">(let ()</span>
				   <span class="s0">(python-resume proc)</span>
				   <span class="s0">)</span>
			       <span class="s0">(let ()</span>
				 <span class="s0">(goto-char current)</span>
				 <span class="s0">))))</span>
		       <span class="s0">)))))</span>
	    <span class="s0">(let ()</span>
	      <span class="s0">(goto-char current)</span>
	      <span class="s0">(message &quot;End of buffer&quot;)</span>
	      <span class="s0">)))</span>
      <span class="s0">(delete-char arg)</span>
      <span class="s0">)))</span>


<span class="s0">(defun comint-interrupt-subjob-or-maybe-return (arg)</span>
  <span class="s0">&quot;Enter a return (comint-send-input) or send a comint-interrupt-subjob</span>
   <span class="s0">if point is at the end of the buffer and there is no input&quot;</span>
  <span class="s0">(interactive &quot;p&quot;)</span>
  <span class="s0">(let ((proc (get-buffer-process (current-buffer))))</span>
    <span class="s0">(if (and (eobp) proc (= (point) (marker-position (process-mark proc))))</span>
	<span class="s0">(let ((current (point)))</span>
	  <span class="s0">(goto-char (- current 4))</span>
	  <span class="s0">(if (or (search-forward &quot;&gt;&gt;&gt; &quot; current t)</span>
		  <span class="s0">(search-forward &quot;... &quot; current t))</span>
	      <span class="s0">(comint-send-input)</span>
	    <span class="s0">(save-current-buffer</span>
	      <span class="s0">(goto-char current)</span>
	      <span class="s0">(for-all-py-procs</span>
	       <span class="s0">(lambda (proc)</span>
		 <span class="s0">(let ((procbuf (process-buffer proc)))</span>
		   <span class="s0">(set-buffer procbuf)</span>
                   <span class="s0">(let ((current (point)))</span>
                     <span class="s0">(goto-char (point-max))</span>
                     <span class="s0">(let ((maxp (point)))</span>
                       <span class="s0">(if (and (eobp) proc (= (point) (marker-position (process-mark proc))))</span>
                           <span class="s0">(let ()</span>
                             <span class="s0">(goto-char (- maxp 4))</span>
                             <span class="s0">(if (or (search-forward &quot;&gt;&gt;&gt; &quot; maxp t)</span>
                                     <span class="s0">(search-forward &quot;... &quot; maxp t))</span>
                                 <span class="s0">(goto-char current)</span>
                               <span class="s0">(let ()</span>
                                 <span class="s0">(comint-interrupt-subjob)</span>
                                 <span class="s0">(goto-char (point-max))</span>
                                 <span class="s0">); let</span>
                               <span class="s0">); if</span>
                             <span class="s0">) ; let</span>
                         <span class="s0">) ; if</span>
                       <span class="s0">) ; let max</span>
                     <span class="s0">) ; let current</span>
                   <span class="s0">) ; let procbuf</span>
                 <span class="s0">) ; lambda proc</span>
	       <span class="s0">))</span>
	    <span class="s0">)</span>
	  <span class="s0">)</span>
      <span class="s0">(comint-send-input)</span>
      <span class="s0">)</span>
    <span class="s0">)</span>
  <span class="s0">)</span>

<span class="s0">(defun comint-interrupt-subjob-or-maybe-return-curbuf (arg)</span>
  <span class="s0">&quot;Enter a return (comint-send-input) or send a comint-interrupt-subjob</span>
   <span class="s0">if point is at the end of the buffer and there is no input&quot;</span>
  <span class="s0">(interactive &quot;p&quot;)</span>
  <span class="s0">(let ((proc (get-buffer-process (current-buffer))))</span>
    <span class="s0">(if (and (eobp) proc (= (point) (marker-position (process-mark proc))))</span>
	<span class="s0">(let ((current (point)))</span>
	  <span class="s0">(goto-char (- current 4))</span>
	  <span class="s0">(if (or (search-forward &quot;&gt;&gt;&gt; &quot; current t)</span>
		  <span class="s0">(search-forward &quot;... &quot; current t))</span>
	      <span class="s0">(comint-send-input)</span>
	    <span class="s0">(save-current-buffer</span>
	      <span class="s0">(goto-char current)</span>
              <span class="s0">(let ((procbuf (process-buffer proc)))</span>
                <span class="s0">(set-buffer procbuf)</span>
                <span class="s0">(goto-char (point-max))</span>
                <span class="s0">(if (and (eobp) proc (= (point) (marker-position (process-mark proc))))</span>
                    <span class="s0">(comint-interrupt-subjob))</span>
                <span class="s0">)</span>
              <span class="s0">)</span>
	    <span class="s0">)</span>
	  <span class="s0">)</span>
      <span class="s0">(comint-send-input)</span>
      <span class="s0">)</span>
    <span class="s0">)</span>
  <span class="s0">)</span>

<span class="s0">(defun py-point-to-max (proc)</span>
  <span class="s0">;; updates the cursor position of a buffer for all windows</span>
  <span class="s0">;; into that buffer</span>
  <span class="s0">(save-current-buffer</span>
    <span class="s0">(let ((procbuf (process-buffer proc)))</span>
      <span class="s0">(mapcar (lambda (window)</span>
		<span class="s0">(set-window-point window (point-max)))</span>
	      <span class="s0">(get-buffer-window-list procbuf))</span>
      <span class="s0">(set-buffer procbuf)</span>
      <span class="s0">(goto-char (point-max))</span>
      <span class="s0">)</span>
    <span class="s0">)</span>
  <span class="s0">)</span>

<span class="s0">;; Function to try to resume panda mainloop</span>
<span class="s0">(defun python-resume (proc)</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(save-current-buffer</span>
    <span class="s0">(let ((procbuf (process-buffer proc))</span>
	  <span class="s0">)</span>
      <span class="s0">(set-buffer procbuf)</span>
      <span class="s0">(goto-char (point-max))</span>
      <span class="s0">(insert &quot;run()\n&quot;)</span>
      <span class="s0">(py-execute-string &quot;try:\n\trun()\nexcept NameError,e:\n\tif e.__str__() == 'run':\n\t\tpass\n\telse:\n\t\traise\nexcept:\n\traise&quot; proc)</span>
      <span class="s0">(py-point-to-max proc)</span>
    <span class="s0">))</span>
  <span class="s0">)</span>


<span class="s0">(defun py-redefine-class (&amp;optional async)</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(py-mark-def-or-class t)</span>
    <span class="s0">;; mark is before point</span>
    <span class="s0">(py-redefine-class-region (mark) (point) async)</span>
    <span class="s0">)</span>
  <span class="s0">)</span>


<span class="s0">(defun py-redefine-class-region-for-proc (start end proc)</span>
  <span class="s0">(interactive &quot;r\nP&quot;)</span>
  <span class="s0">(let* ((temp (if (memq 'broken-temp-names py-emacs-features)</span>
		   <span class="s0">(let</span>
		       <span class="s0">((sn py-serial-number)</span>
			<span class="s0">(pid (and (fboundp 'emacs-pid) (emacs-pid))))</span>
		     <span class="s0">(setq py-serial-number (1+ py-serial-number))</span>
		     <span class="s0">(if pid</span>
			 <span class="s0">(format &quot;python-%d-%d&quot; sn pid)</span>
		       <span class="s0">(format &quot;python-%d&quot; sn)))</span>
		 <span class="s0">(make-temp-name &quot;python-&quot;)))</span>
	 <span class="s0">(file (expand-file-name temp py-temp-directory)))</span>
    <span class="s0">(write-region start end file nil 'nomsg)</span>
    <span class="s0">(cond</span>
     <span class="s0">(proc</span>
      <span class="s0">;; use the existing python shell</span>
      <span class="s0">(py-redefine-class-file proc file)</span>
     <span class="s0">))))</span>

<span class="s0">(defun py-redefine-class-region (start end &amp;optional async)</span>
  <span class="s0">(interactive &quot;r\nP&quot;)</span>
  <span class="s0">(or (&lt; start end)</span>
      <span class="s0">(error &quot;Region is empty&quot;))</span>
  <span class="s0">;; run through all the Python processes and redefine the class</span>
  <span class="s0">(save-current-buffer</span>
    <span class="s0">(let ((curbuf (current-buffer)))</span>
      <span class="s0">(for-all-py-procs (lambda (proc)</span>
			  <span class="s0">(set-buffer curbuf)</span>
			  <span class="s0">(py-redefine-class-region-for-proc start end proc)))</span>
      <span class="s0">)</span>
    <span class="s0">)</span>
  <span class="s0">)</span>

<span class="s0">;; Python subprocess utilities and filters</span>
<span class="s0">(defun py-redefine-class-file (proc filename)</span>
  <span class="s0">&quot;Send to Python interpreter process PROC \&quot;execfile('FILENAME')\&quot;.</span>
<span class="s0">Make that process's buffer visible and force display.  Also make</span>
<span class="s0">comint believe the user typed this string so that</span>
<span class="s0">`kill-output-from-shell' does The Right Thing.&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(let ((procbuf (process-buffer proc))</span>
        <span class="s0">(cmd (format &quot;from direct.showbase import Finder; Finder.rebindClass(r'%s')\n&quot; filename))</span>

	<span class="s0">)</span>
	  <span class="s0">;; Goto the python buffer</span>
	  <span class="s0">(set-buffer procbuf)</span>
	  <span class="s0">(goto-char (point-max))</span>
	  <span class="s0">(let ((current (point)))</span>
	    <span class="s0">(goto-char (- current 4))</span>
	    <span class="s0">;; Look for the python prompt</span>
	    <span class="s0">(if (or (search-forward &quot;&gt;&gt;&gt; &quot; current t)</span>
		    <span class="s0">(search-forward &quot;... &quot; current t)</span>
                    <span class="s0">;; This is the (Pdb) case, but we are only looking at the last 4 chars</span>
		    <span class="s0">(search-forward &quot;db) &quot; current t)</span>
                    <span class="s0">)</span>
              <span class="s0">(let ()</span>
                <span class="s0">;; We are already at a prompt, no need to interrupt</span>
                <span class="s0">(process-send-string proc cmd)</span>
                <span class="s0">)</span>
	      <span class="s0">(let ()</span>
                <span class="s0">;; This is the else clause</span>
		<span class="s0">;; Interrupt the task loop</span>
		<span class="s0">(interrupt-process procbuf nil)</span>
		<span class="s0">(process-send-string proc cmd)</span>
                <span class="s0">;; Since we started running, let's return to running</span>
                <span class="s0">(python-resume proc)</span>
		<span class="s0">)</span>
	      <span class="s0">)</span>
	    <span class="s0">)</span>
	  <span class="s0">)</span>
  <span class="s0">)</span>


<span class="s0">(provide 'python-mode)</span>
<span class="s0">;;; python-mode.el ends here</span>

</pre>
</body>
</html>