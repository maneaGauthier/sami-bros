<html>
<head>
<title>libpandaai.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libpandaai.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">10 libpandaai 4 s1eG 10 panda3d.ai </span>
<span class="s0">52</span>
<span class="s0">55 12 ~AIBehaviors 0 516 107 25 AIBehaviors::~AIBehaviors 0 0 0</span>
<span class="s0">32</span>
<span class="s0">AIBehaviors::~AIBehaviors(void);</span>

<span class="s0">56 4 seek 0 4 107 17 AIBehaviors::seek 0 2 2 3 219</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates seek and makes an object of the Seek class.  This</span>
 <span class="s0">* is the function we want the user to call for seek to be done.  This</span>
 <span class="s0">* function is overloaded to accept a NodePath or an LVecBase3.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">void AIBehaviors::seek(NodePath target_object, float seek_wt = 1.0);</span>
<span class="s0">void AIBehaviors::seek(LVecBase3 pos, float seek_wt = 1.0);</span>

<span class="s0">57 4 flee 0 4 107 17 AIBehaviors::flee 0 2 4 5 159</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates flee_activate and creates an object of the Flee</span>
 <span class="s0">* class.  This function is overloaded to accept a NodePath or an LVecBase3.</span>
 <span class="s0">*/</span>
<span class="s0">248</span>
<span class="s0">void AIBehaviors::flee(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0);</span>
<span class="s0">void AIBehaviors::flee(LVecBase3 pos, double panic_distance = 10.0, double relax_distance = 10.0, float flee_wt = 1.0);</span>

<span class="s0">58 6 pursue 0 4 107 19 AIBehaviors::pursue 0 1 6 115</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates pursue.  This is the function we want the user to</span>
 <span class="s0">* call for pursue to be done.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void AIBehaviors::pursue(NodePath target_object, float pursue_wt = 1.0);</span>

<span class="s0">59 5 evade 0 4 107 18 AIBehaviors::evade 0 1 7 50</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates evade_activate.</span>
 <span class="s0">*/</span>
<span class="s0">130</span>
<span class="s0">void AIBehaviors::evade(NodePath target_object, double panic_distance = 10.0, double relax_distance = 10.0, float evade_wt = 1.0);</span>

<span class="s0">60 7 arrival 0 4 107 20 AIBehaviors::arrival 0 1 8 117</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates arrival.  This is the function we want the user to</span>
 <span class="s0">* call for arrival to be done.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void AIBehaviors::arrival(double distance = 10.0);</span>

<span class="s0">61 5 flock 0 4 107 18 AIBehaviors::flock 0 1 9 113</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates flock.  This is the function we want the user to</span>
 <span class="s0">* call for flock to be done.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void AIBehaviors::flock(float flock_wt);</span>

<span class="s0">62 6 wander 0 4 107 19 AIBehaviors::wander 0 1 10 114</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates wander.  This is the function we want the user to</span>
 <span class="s0">* call for flock to be done.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">void AIBehaviors::wander(double wander_radius = 5.0, int flag = 0, double aoe = 0.0, float wander_weight = 1.0);</span>

<span class="s0">63 18 obstacle_avoidance 0 4 107 31 AIBehaviors::obstacle_avoidance 0 1 11 169</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates obstacle avoidance for a given character.  This is</span>
 <span class="s0">* the function we want the user to call for obstacle avoidance to be</span>
 <span class="s0">* performed.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void AIBehaviors::obstacle_avoidance(float feeler_length = 1.0);</span>

<span class="s0">64 11 path_follow 0 4 107 24 AIBehaviors::path_follow 0 1 12 120</span>
<span class="s0">/**</span>
 <span class="s0">* This function activates path following.  This is the function we want the</span>
 <span class="s0">* user to call for path following.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void AIBehaviors::path_follow(float follow_wt = 1.0);</span>

<span class="s0">65 11 add_to_path 0 4 107 24 AIBehaviors::add_to_path 0 1 13 62</span>
<span class="s0">/**</span>
 <span class="s0">* This function adds positions to the path to follow.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void AIBehaviors::add_to_path(LVecBase3 pos);</span>

<span class="s0">66 12 start_follow 0 4 107 25 AIBehaviors::start_follow 0 1 14 0</span>
<span class="s0">60</span>
<span class="s0">void AIBehaviors::start_follow(std::string type = &quot;normal&quot;);</span>

<span class="s0">67 14 init_path_find 0 4 107 27 AIBehaviors::init_path_find 0 1 15 165</span>
<span class="s0">// should have different function names.</span>

<span class="s0">/**</span>
 <span class="s0">* This function activates path finding in the character.  This function</span>
 <span class="s0">* accepts the meshdata in .csv format.</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void AIBehaviors::init_path_find(char const *navmesh_filename);</span>

<span class="s0">68 12 path_find_to 0 4 107 25 AIBehaviors::path_find_to 0 2 16 17 452</span>
<span class="s0">/**</span>
 <span class="s0">* This function checks for the source and target in the navigation mesh for</span>
 <span class="s0">* its availability and then finds the best path via the A* algorithm Then it</span>
 <span class="s0">* calls the path follower to make the object follow the path.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This function checks for the source and target in the navigation mesh for</span>
 <span class="s0">* its availability and then finds the best path via the A* algorithm Then it</span>
 <span class="s0">* calls the path follower to make the object follow the path.</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">void AIBehaviors::path_find_to(LVecBase3 pos, std::string type = &quot;normal&quot;);</span>
<span class="s0">void AIBehaviors::path_find_to(NodePath target, std::string type = &quot;normal&quot;);</span>

<span class="s0">69 19 add_static_obstacle 0 4 107 32 AIBehaviors::add_static_obstacle 0 1 18 262</span>
<span class="s0">/**</span>
 <span class="s0">* This function allows the user to dynamically add obstacles to the game</span>
 <span class="s0">* environment.  The function will update the nodes within the bounding volume</span>
 <span class="s0">* of the obstacle as non-traversable.  Hence will not be considered by the</span>
 <span class="s0">* pathfinding algorithm.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void AIBehaviors::add_static_obstacle(NodePath obstacle);</span>

<span class="s0">70 20 add_dynamic_obstacle 0 4 107 33 AIBehaviors::add_dynamic_obstacle 0 1 19 98</span>
<span class="s0">/**</span>
 <span class="s0">* This function starts the pathfinding obstacle navigation for the passed in</span>
 <span class="s0">* obstacle.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void AIBehaviors::add_dynamic_obstacle(NodePath obstacle);</span>

<span class="s0">71 9 remove_ai 0 4 107 22 AIBehaviors::remove_ai 0 1 20 59</span>
<span class="s0">/**</span>
 <span class="s0">* This function removes individual or all the AIs.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void AIBehaviors::remove_ai(std::string ai_type);</span>

<span class="s0">72 8 pause_ai 0 4 107 21 AIBehaviors::pause_ai 0 1 21 58</span>
<span class="s0">/**</span>
 <span class="s0">* This function pauses individual or all the AIs.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void AIBehaviors::pause_ai(std::string ai_type);</span>

<span class="s0">73 9 resume_ai 0 4 107 22 AIBehaviors::resume_ai 0 1 22 58</span>
<span class="s0">/**</span>
 <span class="s0">* This function resumes individual or all the AIs</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void AIBehaviors::resume_ai(std::string ai_type);</span>

<span class="s0">74 15 behavior_status 0 4 107 28 AIBehaviors::behavior_status 0 1 23 149</span>
<span class="s0">/**</span>
 <span class="s0">* This function returns the status of an AI Type whether it is active, paused</span>
 <span class="s0">* or disabled.  It returns -1 if an invalid string is passed.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">std::string AIBehaviors::behavior_status(std::string ai_type);</span>

<span class="s0">75 11 AIBehaviors 0 260 107 24 AIBehaviors::AIBehaviors 0 1 1 0</span>
<span class="s0">63</span>
<span class="s0">inline AIBehaviors::AIBehaviors(AIBehaviors const &amp;) = default;</span>

<span class="s0">76 8 get_mass 0 4 108 21 AICharacter::get_mass 0 1 26 0</span>
<span class="s0">35</span>
<span class="s0">double AICharacter::get_mass(void);</span>

<span class="s0">77 8 set_mass 0 4 108 21 AICharacter::set_mass 0 1 27 0</span>
<span class="s0">37</span>
<span class="s0">void AICharacter::set_mass(double m);</span>

<span class="s0">78 12 get_velocity 0 4 108 25 AICharacter::get_velocity 0 1 28 0</span>
<span class="s0">42</span>
<span class="s0">LVecBase3 AICharacter::get_velocity(void);</span>

<span class="s0">79 13 get_max_force 0 4 108 26 AICharacter::get_max_force 0 1 29 0</span>
<span class="s0">40</span>
<span class="s0">double AICharacter::get_max_force(void);</span>

<span class="s0">80 13 set_max_force 0 4 108 26 AICharacter::set_max_force 0 1 30 0</span>
<span class="s0">50</span>
<span class="s0">void AICharacter::set_max_force(double max_force);</span>

<span class="s0">81 13 get_node_path 0 4 108 26 AICharacter::get_node_path 0 1 31 0</span>
<span class="s0">42</span>
<span class="s0">NodePath AICharacter::get_node_path(void);</span>

<span class="s0">82 13 set_node_path 0 4 108 26 AICharacter::set_node_path 0 1 32 0</span>
<span class="s0">45</span>
<span class="s0">void AICharacter::set_node_path(NodePath np);</span>

<span class="s0">83 16 get_ai_behaviors 0 4 108 29 AICharacter::get_ai_behaviors 0 1 33 0</span>
<span class="s0">49</span>
<span class="s0">AIBehaviors *AICharacter::get_ai_behaviors(void);</span>

<span class="s0">84 12 set_pf_guide 0 4 108 25 AICharacter::set_pf_guide 0 1 34 74</span>
<span class="s0">// This function is used to enable or disable the guides for path finding.</span>
<span class="s0">46</span>
<span class="s0">void AICharacter::set_pf_guide(bool pf_guide);</span>

<span class="s0">85 11 AICharacter 0 260 108 24 AICharacter::AICharacter 0 2 24 25 0</span>
<span class="s0">191</span>
<span class="s0">explicit AICharacter::AICharacter(std::string model_name, NodePath model_np, double mass, double movt_force, double max_force);</span>
<span class="s0">inline AICharacter::AICharacter(AICharacter const &amp;) = default;</span>

<span class="s0">86 8 get_name 0 4 108 21 AICharacter::get_name 0 0 0</span>
<span class="s0">40</span>
<span class="s0">std::string AICharacter::get_name(void);</span>

<span class="s0">87 6 AINode 0 260 112 14 AINode::AINode 0 2 35 36 0</span>
<span class="s0">139</span>
<span class="s0">explicit AINode::AINode(int grid_x, int grid_y, LVecBase3 pos, float w, float l, float h);</span>
<span class="s0">inline AINode::AINode(AINode const &amp;) = default;</span>

<span class="s0">88 7 ~AINode 0 516 112 15 AINode::~AINode 0 0 0</span>
<span class="s0">22</span>
<span class="s0">AINode::~AINode(void);</span>

<span class="s0">89 8 contains 0 4 112 16 AINode::contains 0 1 37 113</span>
<span class="s0">/**</span>
 <span class="s0">* This is a handy function which returns true if the passed position is</span>
 <span class="s0">* within the node's dimensions.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">bool AINode::contains(float x, float y);</span>

<span class="s0">90 5 Flock 0 260 113 12 Flock::Flock 0 2 38 39 0</span>
<span class="s0">225</span>
<span class="s0">explicit Flock::Flock(unsigned int flock_id, double vcone_angle, double vcone_radius, unsigned int separation_wt = 2, unsigned int cohesion_wt = 4, unsigned int alignment_wt = 1);</span>
<span class="s0">inline Flock::Flock(Flock const &amp;) = default;</span>

<span class="s0">91 6 ~Flock 0 516 113 13 Flock::~Flock 0 0 0</span>
<span class="s0">20</span>
<span class="s0">Flock::~Flock(void);</span>

<span class="s0">92 11 add_ai_char 0 4 113 18 Flock::add_ai_char 0 1 40 113</span>
<span class="s0">// Function to add the ai characters to _ai_char_list.</span>

<span class="s0">/**</span>
 <span class="s0">* This function adds AI characters to the flock.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void Flock::add_ai_char(AICharacter *ai_char);</span>

<span class="s0">93 6 get_id 0 4 113 13 Flock::get_id 0 1 41 50</span>
<span class="s0">// Function to access the private member flock_id.</span>
<span class="s0">33</span>
<span class="s0">unsigned int Flock::get_id(void);</span>

<span class="s0">94 7 AIWorld 0 260 114 16 AIWorld::AIWorld 0 2 42 43 0</span>
<span class="s0">86</span>
<span class="s0">AIWorld::AIWorld(NodePath render);</span>
<span class="s0">inline AIWorld::AIWorld(AIWorld const &amp;) = default;</span>

<span class="s0">95 8 ~AIWorld 0 516 114 17 AIWorld::~AIWorld 0 0 0</span>
<span class="s0">24</span>
<span class="s0">AIWorld::~AIWorld(void);</span>

<span class="s0">96 11 add_ai_char 0 4 114 20 AIWorld::add_ai_char 0 1 44 0</span>
<span class="s0">46</span>
<span class="s0">void AIWorld::add_ai_char(AICharacter *ai_ch);</span>

<span class="s0">97 14 remove_ai_char 0 4 114 23 AIWorld::remove_ai_char 0 1 45 0</span>
<span class="s0">47</span>
<span class="s0">void AIWorld::remove_ai_char(std::string name);</span>

<span class="s0">98 9 add_flock 0 4 114 18 AIWorld::add_flock 0 1 46 163</span>
<span class="s0">/**</span>
 <span class="s0">* This function adds all the AI characters in the Flock object to the</span>
 <span class="s0">* AICharPool.  This function allows adding the AI characetrs as part of a</span>
 <span class="s0">* flock.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void AIWorld::add_flock(Flock *flock);</span>

<span class="s0">99 9 flock_off 0 4 114 18 AIWorld::flock_off 0 1 47 103</span>
<span class="s0">/**</span>
 <span class="s0">* This function turns off the flock behavior temporarily.  Similar to pausing</span>
 <span class="s0">* the behavior.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void AIWorld::flock_off(unsigned int flock_id);</span>

<span class="s0">100 8 flock_on 0 4 114 17 AIWorld::flock_on 0 1 48 53</span>
<span class="s0">/**</span>
 <span class="s0">* This function turns on the flock behavior.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void AIWorld::flock_on(unsigned int flock_id);</span>

<span class="s0">101 12 remove_flock 0 4 114 21 AIWorld::remove_flock 0 1 49 63</span>
<span class="s0">/**</span>
 <span class="s0">* This function removes the flock behavior completely.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void AIWorld::remove_flock(unsigned int flock_id);</span>

<span class="s0">102 9 get_flock 0 4 114 18 AIWorld::get_flock 0 1 50 74</span>
<span class="s0">/**</span>
 <span class="s0">* This function returns a handle to the Flock whose id is passed.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">Flock AIWorld::get_flock(unsigned int flock_id);</span>

<span class="s0">103 12 add_obstacle 0 4 114 21 AIWorld::add_obstacle 0 1 51 111</span>
<span class="s0">/**</span>
 <span class="s0">* This function adds the nodepath as an obstacle that is needed by the</span>
 <span class="s0">* obstacle avoidance behavior.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void AIWorld::add_obstacle(NodePath obstacle);</span>

<span class="s0">104 15 remove_obstacle 0 4 114 24 AIWorld::remove_obstacle 0 1 52 123</span>
<span class="s0">/**</span>
 <span class="s0">* This function removes the nodepath from the obstacles list that is needed</span>
 <span class="s0">* by the obstacle avoidance behavior.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void AIWorld::remove_obstacle(NodePath obstacle);</span>

<span class="s0">105 10 print_list 0 4 114 19 AIWorld::print_list 0 1 53 134</span>
<span class="s0">/**</span>
 <span class="s0">* This function prints the names of the AI characters that have been added to</span>
 <span class="s0">* the AIWorld.  Useful for debugging purposes.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void AIWorld::print_list(void);</span>

<span class="s0">106 6 update 0 4 114 15 AIWorld::update 0 1 54 130</span>
<span class="s0">/**</span>
 <span class="s0">* The AIWorld update function calls the update function of all the AI</span>
 <span class="s0">* characters which have been added to the AIWorld.</span>
 <span class="s0">*/</span>
<span class="s0">27</span>
<span class="s0">void AIWorld::update(void);</span>

<span class="s0">54</span>
<span class="s0">1 0 0 15 22 117 55 0 0 1 6 param0 0 115  </span>
<span class="s0">2 0 0 4 3 122 0 0 0 3 4 this 3 117  3 pos 1 118  7 seek_wt 5 121  </span>
<span class="s0">3 0 0 4 3 122 0 0 219 /**</span>
 <span class="s0">* This function activates seek and makes an object of the Seek class.  This</span>
 <span class="s0">* is the function we want the user to call for seek to be done.  This</span>
 <span class="s0">* function is overloaded to accept a NodePath or an LVecBase3.</span>
 <span class="s0">*/ 3 4 this 3 117  13 target_object 1 123  7 seek_wt 5 121  </span>
<span class="s0">4 0 0 4 4 122 0 0 0 5 4 this 3 117  3 pos 1 118  14 panic_distance 5 125  14 relax_distance 5 125  7 flee_wt 5 121  </span>
<span class="s0">5 0 0 4 4 122 0 0 159 /**</span>
 <span class="s0">* This function activates flee_activate and creates an object of the Flee</span>
 <span class="s0">* class.  This function is overloaded to accept a NodePath or an LVecBase3.</span>
 <span class="s0">*/ 5 4 this 3 117  13 target_object 1 123  14 panic_distance 5 125  14 relax_distance 5 125  7 flee_wt 5 121  </span>
<span class="s0">6 0 0 4 5 122 0 0 115 /**</span>
 <span class="s0">* This function activates pursue.  This is the function we want the user to</span>
 <span class="s0">* call for pursue to be done.</span>
 <span class="s0">*/ 3 4 this 3 117  13 target_object 1 123  9 pursue_wt 5 121  </span>
<span class="s0">7 0 0 4 6 122 0 0 50 /**</span>
 <span class="s0">* This function activates evade_activate.</span>
 <span class="s0">*/ 5 4 this 3 117  13 target_object 1 123  14 panic_distance 5 125  14 relax_distance 5 125  8 evade_wt 5 121  </span>
<span class="s0">8 0 0 4 7 122 0 0 117 /**</span>
 <span class="s0">* This function activates arrival.  This is the function we want the user to</span>
 <span class="s0">* call for arrival to be done.</span>
 <span class="s0">*/ 2 4 this 3 117  8 distance 5 125  </span>
<span class="s0">9 0 0 4 8 122 0 0 113 /**</span>
 <span class="s0">* This function activates flock.  This is the function we want the user to</span>
 <span class="s0">* call for flock to be done.</span>
 <span class="s0">*/ 2 4 this 3 117  8 flock_wt 1 121  </span>
<span class="s0">10 0 0 4 9 122 0 0 114 /**</span>
 <span class="s0">* This function activates wander.  This is the function we want the user to</span>
 <span class="s0">* call for flock to be done.</span>
 <span class="s0">*/ 5 4 this 3 117  13 wander_radius 5 125  4 flag 5 126  3 aoe 5 125  13 wander_weight 5 121  </span>
<span class="s0">11 0 0 4 10 122 0 0 169 /**</span>
 <span class="s0">* This function activates obstacle avoidance for a given character.  This is</span>
 <span class="s0">* the function we want the user to call for obstacle avoidance to be</span>
 <span class="s0">* performed.</span>
 <span class="s0">*/ 2 4 this 3 117  13 feeler_length 5 121  </span>
<span class="s0">12 0 0 4 11 122 0 0 120 /**</span>
 <span class="s0">* This function activates path following.  This is the function we want the</span>
 <span class="s0">* user to call for path following.</span>
 <span class="s0">*/ 2 4 this 3 117  9 follow_wt 5 121  </span>
<span class="s0">13 0 0 4 12 122 0 0 62 /**</span>
 <span class="s0">* This function adds positions to the path to follow.</span>
 <span class="s0">*/ 2 4 this 3 117  3 pos 1 118  </span>
<span class="s0">14 0 0 4 13 122 0 0 0 2 4 this 3 117  4 type 5 127  </span>
<span class="s0">15 0 0 4 14 122 0 0 123 /**</span>
 <span class="s0">* This function activates path finding in the character.  This function</span>
 <span class="s0">* accepts the meshdata in .csv format.</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 117  16 navmesh_filename 1 127  </span>
<span class="s0">16 0 0 4 15 122 0 0 225 /**</span>
 <span class="s0">* This function checks for the source and target in the navigation mesh for</span>
 <span class="s0">* its availability and then finds the best path via the A* algorithm Then it</span>
 <span class="s0">* calls the path follower to make the object follow the path.</span>
 <span class="s0">*/ 3 4 this 3 117  3 pos 1 118  4 type 5 127  </span>
<span class="s0">17 0 0 4 15 122 0 0 225 /**</span>
 <span class="s0">* This function checks for the source and target in the navigation mesh for</span>
 <span class="s0">* its availability and then finds the best path via the A* algorithm Then it</span>
 <span class="s0">* calls the path follower to make the object follow the path.</span>
 <span class="s0">*/ 3 4 this 3 117  6 target 1 123  4 type 5 127  </span>
<span class="s0">18 0 0 4 16 122 0 0 262 /**</span>
 <span class="s0">* This function allows the user to dynamically add obstacles to the game</span>
 <span class="s0">* environment.  The function will update the nodes within the bounding volume</span>
 <span class="s0">* of the obstacle as non-traversable.  Hence will not be considered by the</span>
 <span class="s0">* pathfinding algorithm.</span>
 <span class="s0">*/ 2 4 this 3 117  8 obstacle 1 123  </span>
<span class="s0">19 0 0 4 17 122 0 0 98 /**</span>
 <span class="s0">* This function starts the pathfinding obstacle navigation for the passed in</span>
 <span class="s0">* obstacle.</span>
 <span class="s0">*/ 2 4 this 3 117  8 obstacle 1 123  </span>
<span class="s0">20 0 0 4 18 122 0 0 59 /**</span>
 <span class="s0">* This function removes individual or all the AIs.</span>
 <span class="s0">*/ 2 4 this 3 117  7 ai_type 1 127  </span>
<span class="s0">21 0 0 4 19 122 0 0 58 /**</span>
 <span class="s0">* This function pauses individual or all the AIs.</span>
 <span class="s0">*/ 2 4 this 3 117  7 ai_type 1 127  </span>
<span class="s0">22 0 0 4 20 122 0 0 58 /**</span>
 <span class="s0">* This function resumes individual or all the AIs</span>
 <span class="s0">*/ 2 4 this 3 117  7 ai_type 1 127  </span>
<span class="s0">23 0 0 6 21 127 0 0 149 /**</span>
 <span class="s0">* This function returns the status of an AI Type whether it is active, paused</span>
 <span class="s0">* or disabled.  It returns -1 if an invalid string is passed.</span>
 <span class="s0">*/ 2 4 this 3 117  7 ai_type 1 127  </span>
<span class="s0">24 0 0 15 34 130 0 0 0 1 6 param0 0 128  </span>
<span class="s0">25 0 0 7 34 130 0 0 0 5 10 model_name 1 127  8 model_np 1 123  4 mass 1 125  10 movt_force 1 125  9 max_force 1 125  </span>
<span class="s0">26 0 0 6 25 125 0 0 0 1 4 this 3 130  </span>
<span class="s0">27 0 0 4 26 122 0 0 0 2 4 this 3 130  1 m 1 125  </span>
<span class="s0">28 0 0 7 27 118 0 0 0 1 4 this 3 130  </span>
<span class="s0">29 0 0 6 28 125 0 0 0 1 4 this 3 130  </span>
<span class="s0">30 0 0 4 29 122 0 0 0 2 4 this 3 130  9 max_force 1 125  </span>
<span class="s0">31 0 0 7 30 123 0 0 0 1 4 this 3 130  </span>
<span class="s0">32 0 0 4 31 122 0 0 0 2 4 this 3 130  2 np 1 123  </span>
<span class="s0">33 0 0 6 32 117 0 0 0 1 4 this 3 130  </span>
<span class="s0">34 0 0 4 33 122 0 0 74 // This function is used to enable or disable the guides for path finding. 2 4 this 3 130  8 pf_guide 1 131  </span>
<span class="s0">35 0 0 15 40 134 88 0 0 1 6 param0 0 132  </span>
<span class="s0">36 0 0 7 40 134 88 0 0 6 6 grid_x 1 126  6 grid_y 1 126  3 pos 1 118  1 w 1 121  1 l 1 121  1 h 1 121  </span>
<span class="s0">37 0 0 6 42 131 0 0 113 /**</span>
 <span class="s0">* This is a handy function which returns true if the passed position is</span>
 <span class="s0">* within the node's dimensions.</span>
 <span class="s0">*/ 3 4 this 3 134  1 x 1 121  1 y 1 121  </span>
<span class="s0">38 0 0 15 44 137 91 0 0 1 6 param0 0 135  </span>
<span class="s0">39 0 0 7 44 137 91 0 0 6 8 flock_id 1 138  11 vcone_angle 1 125  12 vcone_radius 1 125  13 separation_wt 5 138  11 cohesion_wt 5 138  12 alignment_wt 5 138  </span>
<span class="s0">40 0 0 4 46 122 0 0 57 /**</span>
 <span class="s0">* This function adds AI characters to the flock.</span>
 <span class="s0">*/ 2 4 this 3 137  7 ai_char 1 130  </span>
<span class="s0">41 0 0 6 47 138 0 0 50 // Function to access the private member flock_id. 1 4 this 3 137  </span>
<span class="s0">42 0 0 15 49 141 95 0 0 1 6 param0 0 139  </span>
<span class="s0">43 0 0 23 49 141 95 0 0 1 6 render 1 123  </span>
<span class="s0">44 0 0 4 51 122 0 0 0 2 4 this 3 141  5 ai_ch 1 130  </span>
<span class="s0">45 0 0 4 52 122 0 0 0 2 4 this 3 141  4 name 1 127  </span>
<span class="s0">46 0 0 4 53 122 0 0 163 /**</span>
 <span class="s0">* This function adds all the AI characters in the Flock object to the</span>
 <span class="s0">* AICharPool.  This function allows adding the AI characetrs as part of a</span>
 <span class="s0">* flock.</span>
 <span class="s0">*/ 2 4 this 3 141  5 flock 1 137  </span>
<span class="s0">47 0 0 4 54 122 0 0 103 /**</span>
 <span class="s0">* This function turns off the flock behavior temporarily.  Similar to pausing</span>
 <span class="s0">* the behavior.</span>
 <span class="s0">*/ 2 4 this 3 141  8 flock_id 1 138  </span>
<span class="s0">48 0 0 4 55 122 0 0 53 /**</span>
 <span class="s0">* This function turns on the flock behavior.</span>
 <span class="s0">*/ 2 4 this 3 141  8 flock_id 1 138  </span>
<span class="s0">49 0 0 4 56 122 0 0 63 /**</span>
 <span class="s0">* This function removes the flock behavior completely.</span>
 <span class="s0">*/ 2 4 this 3 141  8 flock_id 1 138  </span>
<span class="s0">50 0 0 7 57 137 91 0 74 /**</span>
 <span class="s0">* This function returns a handle to the Flock whose id is passed.</span>
 <span class="s0">*/ 2 4 this 3 141  8 flock_id 1 138  </span>
<span class="s0">51 0 0 4 58 122 0 0 111 /**</span>
 <span class="s0">* This function adds the nodepath as an obstacle that is needed by the</span>
 <span class="s0">* obstacle avoidance behavior.</span>
 <span class="s0">*/ 2 4 this 3 141  8 obstacle 1 123  </span>
<span class="s0">52 0 0 4 59 122 0 0 123 /**</span>
 <span class="s0">* This function removes the nodepath from the obstacles list that is needed</span>
 <span class="s0">* by the obstacle avoidance behavior.</span>
 <span class="s0">*/ 2 4 this 3 141  8 obstacle 1 123  </span>
<span class="s0">53 0 0 4 60 122 0 0 134 /**</span>
 <span class="s0">* This function prints the names of the AI characters that have been added to</span>
 <span class="s0">* the AIWorld.  Useful for debugging purposes.</span>
 <span class="s0">*/ 1 4 this 3 141  </span>
<span class="s0">54 0 0 4 61 122 0 0 130 /**</span>
 <span class="s0">* The AIWorld update function calls the update function of all the AI</span>
 <span class="s0">* characters which have been added to the AIWorld.</span>
 <span class="s0">*/ 1 4 this 3 141  </span>
<span class="s0">35</span>
<span class="s0">107 11 AIBehaviors 0 26625 11 AIBehaviors 11 AIBehaviors 0 0 0 1 75 55 0 19 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 0 0 0 0 0 618</span>
<span class="s0">/**</span>
 <span class="s0">* This class implements all the steering behaviors of the AI framework, such</span>
 <span class="s0">* as seek, flee, pursue, evade, wander and flock.  Each steering behavior has</span>
 <span class="s0">* a weight which is used when more than one type of steering behavior is</span>
 <span class="s0">* acting on the same ai character.  The weight decides the contribution of</span>
 <span class="s0">* each type of steering behavior.  The AICharacter class has a handle to an</span>
 <span class="s0">* object of this class and this allows to invoke the steering behaviors via</span>
 <span class="s0">* the AICharacter.  This class also provides functionality such as pausing,</span>
 <span class="s0">* resuming and removing the AI behaviors of an AI character at anytime.</span>
 <span class="s0">*/</span>

<span class="s0">108 11 AICharacter 0 75777 11 AICharacter 11 AICharacter 0 0 0 1 85 0 1 142 9 76 77 78 79 80 81 82 83 84 0 0 1 0 109 0 0 0 0 0</span>

<span class="s0">109 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">110 6 string 0 2105344 11 std::string 11 std::string 0 0 111 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">111 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">112 6 AINode 0 26625 6 AINode 6 AINode 0 0 0 1 87 88 0 1 89 0 0 0 0 0 365</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used to assign the nodes on the mesh.  It holds all the data</span>
 <span class="s0">* necessary to compute A* algorithm.  It also maintains a lot of vital</span>
 <span class="s0">* information such as the neighbor nodes of each node and also its position</span>
 <span class="s0">* on the mesh.  Note: The Mesh Generator which is a standalone tool makes use</span>
 <span class="s0">* of this class to generate the nodes on the mesh.</span>
 <span class="s0">*/</span>

<span class="s0">113 5 Flock 0 26625 5 Flock 5 Flock 0 0 0 1 90 91 0 2 92 93 0 0 0 0 0 114</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used to define the flock attributes and the AI characters</span>
 <span class="s0">* which are part of the flock.</span>
 <span class="s0">*/</span>

<span class="s0">114 7 AIWorld 0 26625 7 AIWorld 7 AIWorld 0 0 0 1 94 95 0 11 96 97 98 99 100 101 102 103 104 105 106 0 0 0 0 0 329</span>
<span class="s0">/**</span>
 <span class="s0">* A class that implements the virtual AI world which keeps track of the AI</span>
 <span class="s0">* characters active at any given time.  It contains a linked list of AI</span>
 <span class="s0">* characters, obstactle data and unique name for each character.  It also</span>
 <span class="s0">* updates each characters state.  The AI characters can also be added to the</span>
 <span class="s0">* world as flocks.</span>
 <span class="s0">*/</span>

<span class="s0">115 19 AIBehaviors const * 0 8576 19 AIBehaviors const * 19 AIBehaviors const * 0 0 116 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">116 17 AIBehaviors const 0 8832 17 AIBehaviors const 17 AIBehaviors const 0 0 107 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">117 13 AIBehaviors * 0 8576 13 AIBehaviors * 13 AIBehaviors * 0 0 107 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">118 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 119 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">119 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 120 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">120 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">121 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">122 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">123 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 124 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">124 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">125 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">126 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">127 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">128 19 AICharacter const * 0 8576 19 AICharacter const * 19 AICharacter const * 0 0 129 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">129 17 AICharacter const 0 8832 17 AICharacter const 17 AICharacter const 0 0 108 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">130 13 AICharacter * 0 8576 13 AICharacter * 13 AICharacter * 0 0 108 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">131 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">132 14 AINode const * 0 8576 14 AINode const * 14 AINode const * 0 0 133 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">133 12 AINode const 0 8832 12 AINode const 12 AINode const 0 0 112 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">134 8 AINode * 0 8576 8 AINode * 8 AINode * 0 0 112 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">135 13 Flock const * 0 8576 13 Flock const * 13 Flock const * 0 0 136 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">136 11 Flock const 0 8832 11 Flock const 11 Flock const 0 0 113 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">137 7 Flock * 0 8576 7 Flock * 7 Flock * 0 0 113 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">138 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">139 15 AIWorld const * 0 8576 15 AIWorld const * 15 AIWorld const * 0 0 140 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">140 13 AIWorld const 0 8832 13 AIWorld const 13 AIWorld const 0 0 114 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">141 9 AIWorld * 0 8576 9 AIWorld * 9 AIWorld * 0 0 114 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">1</span>
<span class="s0">142 4 name 0 2 110 86 0 0 0 0 0 0 0 17 AICharacter::name 0</span>

<span class="s0">0</span>
</pre>
</body>
</html>