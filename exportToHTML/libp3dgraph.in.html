<html>
<head>
<title>libp3dgraph.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3dgraph.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">11 libp3dgraph 4 YJkp 12 panda3d.core </span>
<span class="s0">12</span>
<span class="s0">12 18 DataGraphTraverser 0 260 24 38 DataGraphTraverser::DataGraphTraverser 0 2 1 2 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">188</span>
<span class="s0">explicit DataGraphTraverser::DataGraphTraverser(Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline DataGraphTraverser::DataGraphTraverser(DataGraphTraverser const &amp;) = default;</span>

<span class="s0">13 19 ~DataGraphTraverser 0 516 24 39 DataGraphTraverser::~DataGraphTraverser 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">DataGraphTraverser::~DataGraphTraverser(void);</span>

<span class="s0">14 18 get_current_thread 0 4 24 38 DataGraphTraverser::get_current_thread 0 1 3 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the currently-executing thread object, as passed to the</span>
 <span class="s0">* DataGraphTraverser constructor.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline Thread *DataGraphTraverser::get_current_thread(void) const;</span>

<span class="s0">15 8 traverse 0 4 24 28 DataGraphTraverser::traverse 0 1 4 77</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the traversal of the data graph at the indicated root node.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void DataGraphTraverser::traverse(PandaNode *node);</span>

<span class="s0">16 14 traverse_below 0 4 24 34 DataGraphTraverser::traverse_below 0 1 5 170</span>
<span class="s0">/**</span>
 <span class="s0">* Continues the traversal to all the children of the indicated node, passing</span>
 <span class="s0">* in the given data, without actually calling transmit_data() on the given</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void DataGraphTraverser::traverse_below(PandaNode *node, DataNodeTransmit const &amp;output);</span>

<span class="s0">17 17 collect_leftovers 0 4 24 37 DataGraphTraverser::collect_leftovers 0 1 6 184</span>
<span class="s0">/**</span>
 <span class="s0">* Pick up any nodes that didn't get completely traversed.  These must be</span>
 <span class="s0">* nodes that have multiple parents, with at least one parent completely</span>
 <span class="s0">* outside of the data graph.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void DataGraphTraverser::collect_leftovers(void);</span>

<span class="s0">18 8 DataNode 0 260 25 18 DataNode::DataNode 0 1 7 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline explicit DataNode::DataNode(std::string const &amp;name);</span>

<span class="s0">19 12 write_inputs 0 4 25 22 DataNode::write_inputs 0 1 8 109</span>
<span class="s0">/**</span>
 <span class="s0">* Writes to the indicated ostream a list of all the inputs this DataNode</span>
 <span class="s0">* might expect to receive.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void DataNode::write_inputs(std::ostream &amp;out) const;</span>

<span class="s0">20 13 write_outputs 0 4 25 23 DataNode::write_outputs 0 1 9 101</span>
<span class="s0">/**</span>
 <span class="s0">* Writes to the indicated ostream a list of all the outputs this DataNode</span>
 <span class="s0">* might generate.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void DataNode::write_outputs(std::ostream &amp;out) const;</span>

<span class="s0">21 17 write_connections 0 4 25 27 DataNode::write_connections 0 1 10 134</span>
<span class="s0">/**</span>
 <span class="s0">* Writes to the indicated ostream a list of all the connections currently</span>
 <span class="s0">* showing between this DataNode and its parent(s).</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void DataNode::write_connections(std::ostream &amp;out) const;</span>

<span class="s0">22 14 get_class_type 0 4 25 24 DataNode::get_class_type 0 1 11 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle DataNode::get_class_type(void);</span>

<span class="s0">23 9 ~DataNode 0 516 25 19 DataNode::~DataNode 0 0 0</span>
<span class="s0">26</span>
<span class="s0">DataNode::~DataNode(void);</span>

<span class="s0">11</span>
<span class="s0">1 0 0 15 2 29 13 0 0 1 6 param0 0 27  </span>
<span class="s0">2 0 0 7 2 29 13 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 14 current_thread 5 30  </span>
<span class="s0">3 0 0 7 4 30 0 0 109 /**</span>
 <span class="s0">* Returns the currently-executing thread object, as passed to the</span>
 <span class="s0">* DataGraphTraverser constructor.</span>
 <span class="s0">*/ 1 4 this 3 27  </span>
<span class="s0">4 0 0 4 5 33 0 0 77 /**</span>
 <span class="s0">* Starts the traversal of the data graph at the indicated root node.</span>
 <span class="s0">*/ 2 4 this 3 29  4 node 1 32  </span>
<span class="s0">5 0 0 4 6 33 0 0 170 /**</span>
 <span class="s0">* Continues the traversal to all the children of the indicated node, passing</span>
 <span class="s0">* in the given data, without actually calling transmit_data() on the given</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 3 4 this 3 29  4 node 1 32  6 output 1 34  </span>
<span class="s0">6 0 0 4 7 33 0 0 184 /**</span>
 <span class="s0">* Pick up any nodes that didn't get completely traversed.  These must be</span>
 <span class="s0">* nodes that have multiple parents, with at least one parent completely</span>
 <span class="s0">* outside of the data graph.</span>
 <span class="s0">*/ 1 4 this 3 29  </span>
<span class="s0">7 0 0 7 10 38 23 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 37  </span>
<span class="s0">8 0 0 4 11 33 0 0 109 /**</span>
 <span class="s0">* Writes to the indicated ostream a list of all the inputs this DataNode</span>
 <span class="s0">* might expect to receive.</span>
 <span class="s0">*/ 2 4 this 3 39  3 out 1 41  </span>
<span class="s0">9 0 0 4 12 33 0 0 101 /**</span>
 <span class="s0">* Writes to the indicated ostream a list of all the outputs this DataNode</span>
 <span class="s0">* might generate.</span>
 <span class="s0">*/ 2 4 this 3 39  3 out 1 41  </span>
<span class="s0">10 0 0 4 13 33 0 0 134 /**</span>
 <span class="s0">* Writes to the indicated ostream a list of all the connections currently</span>
 <span class="s0">* showing between this DataNode and its parent(s).</span>
 <span class="s0">*/ 2 4 this 3 39  3 out 1 41  </span>
<span class="s0">11 0 0 7 14 44 0 0 0 0 </span>
<span class="s0">21</span>
<span class="s0">24 18 DataGraphTraverser 0 26625 18 DataGraphTraverser 18 DataGraphTraverser 0 0 0 1 12 13 0 4 14 15 16 17 0 0 0 0 0 247</span>
<span class="s0">/**</span>
 <span class="s0">* This object supervises the traversal of the data graph and the moving of</span>
 <span class="s0">* data from one DataNode to its children.  The data graph is used to manage</span>
 <span class="s0">* data from input devices, etc.  See the overview of the data graph in</span>
 <span class="s0">* dataNode.h.</span>
 <span class="s0">*/</span>

<span class="s0">25 8 DataNode 0 141313 8 DataNode 8 DataNode 0 0 0 1 18 23 0 4 19 20 21 22 0 0 1 0 26 0 0 0 0 422</span>
<span class="s0">/**</span>
 <span class="s0">* The fundamental type of node for the data graph.  The DataNode class is</span>
 <span class="s0">* itself primarily intended as an abstract class; it defines no inputs and no</span>
 <span class="s0">* outputs.  Most kinds of data nodes will derive from this to specify the</span>
 <span class="s0">* inputs and outputs in the constructor.</span>
 <span class="s0">*</span>
 <span class="s0">* DataNode does not attempt to cycle its data with a PipelineCycler.  The</span>
 <span class="s0">* data graph is intended to be used only within a single thread.</span>
 <span class="s0">*/</span>

<span class="s0">26 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A basic node of the scene graph or data graph.  This is the base class of</span>
 <span class="s0">* all specialized nodes, and also serves as a generic node with no special</span>
 <span class="s0">* properties.</span>
 <span class="s0">*/</span>

<span class="s0">27 26 DataGraphTraverser const * 0 8576 26 DataGraphTraverser const * 26 DataGraphTraverser const * 0 0 28 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">28 24 DataGraphTraverser const 0 8832 24 DataGraphTraverser const 24 DataGraphTraverser const 0 0 24 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">29 20 DataGraphTraverser * 0 8576 20 DataGraphTraverser * 20 DataGraphTraverser * 0 0 24 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">30 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 31 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">31 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 396</span>
<span class="s0">/**</span>
 <span class="s0">* A thread; that is, a lightweight process.  This is an abstract base class;</span>
 <span class="s0">* to use it, you must subclass from it and redefine thread_main().</span>
 <span class="s0">*</span>
 <span class="s0">* The thread itself will keep a reference count on the Thread object while it</span>
 <span class="s0">* is running; when the thread returns from its root function, the Thread</span>
 <span class="s0">* object will automatically be destructed if no other pointers are</span>
 <span class="s0">* referencing it.</span>
 <span class="s0">*/</span>

<span class="s0">32 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 26 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">33 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">34 24 DataNodeTransmit const * 0 8576 24 DataNodeTransmit const * 24 DataNodeTransmit const * 0 0 35 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">35 22 DataNodeTransmit const 0 8832 22 DataNodeTransmit const 22 DataNodeTransmit const 0 0 36 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">36 16 DataNodeTransmit 0 1050624 16 DataNodeTransmit 16 DataNodeTransmit 0 0 0 0 0 0 0 0 0 0 0 0 192</span>
<span class="s0">/**</span>
 <span class="s0">* Encapsulates the data generated from (or sent into) any particular</span>
 <span class="s0">* DataNode.  This is basically just an array of EventParameters, one for each</span>
 <span class="s0">* registered input or output wire.</span>
 <span class="s0">*/</span>

<span class="s0">37 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">38 10 DataNode * 0 8576 10 DataNode * 10 DataNode * 0 0 25 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">39 16 DataNode const * 0 8576 16 DataNode const * 16 DataNode const * 0 0 40 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">40 14 DataNode const 0 8832 14 DataNode const 14 DataNode const 0 0 25 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">41 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 42 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">42 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">43 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">44 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 43 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">0</span>
<span class="s0">0</span>
</pre>
</body>
</html>