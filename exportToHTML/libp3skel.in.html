<html>
<head>
<title>libp3skel.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3skel.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">9 libp3skel 4 5lWe 12 panda3d.skel </span>
<span class="s0">12</span>
<span class="s0">13 9 BasicSkel 0 260 25 20 BasicSkel::BasicSkel 0 2 1 2 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline BasicSkel::BasicSkel(void);</span>
<span class="s0">inline BasicSkel::BasicSkel(BasicSkel const &amp;) = default;</span>

<span class="s0">14 10 ~BasicSkel 0 516 25 21 BasicSkel::~BasicSkel 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">inline BasicSkel::~BasicSkel(void);</span>

<span class="s0">15 9 set_value 0 4 25 20 BasicSkel::set_value 0 1 3 95</span>
<span class="s0">// These inline functions allow you to get and set _value.</span>

<span class="s0">/**</span>
 <span class="s0">* Stores an integer value.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline void BasicSkel::set_value(int n);</span>

<span class="s0">16 9 get_value 0 4 25 20 BasicSkel::get_value 0 1 4 56</span>
<span class="s0">/**</span>
 <span class="s0">* Retreives a value that was previously stored.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline int BasicSkel::get_value(void);</span>

<span class="s0">17 13 set_value_alt 0 4 25 24 BasicSkel::set_value_alt 0 1 5 173</span>
<span class="s0">// These do the same thing as the functions above.</span>

<span class="s0">/**</span>
 <span class="s0">* Stores an integer value.  Exact same functionality as set_value, except</span>
 <span class="s0">* that this isn't an inline function.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void BasicSkel::set_value_alt(int n);</span>

<span class="s0">18 13 get_value_alt 0 4 25 24 BasicSkel::get_value_alt 0 1 6 142</span>
<span class="s0">/**</span>
 <span class="s0">* Retreives a value that was previously stored.  Exact same functionality as</span>
 <span class="s0">* get_value, except that this isn't an inline function.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">int BasicSkel::get_value_alt(void);</span>

<span class="s0">19 9 TypedSkel 0 260 26 20 TypedSkel::TypedSkel 0 1 7 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">inline TypedSkel::TypedSkel(void);</span>

<span class="s0">20 9 set_value 0 4 26 20 TypedSkel::set_value 0 1 8 95</span>
<span class="s0">// These inline functions allow you to get and set _value.</span>

<span class="s0">/**</span>
 <span class="s0">* Stores an integer value.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline void TypedSkel::set_value(int n);</span>

<span class="s0">21 9 get_value 0 4 26 20 TypedSkel::get_value 0 1 9 56</span>
<span class="s0">/**</span>
 <span class="s0">* Retreives a value that was previously stored.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline int TypedSkel::get_value(void);</span>

<span class="s0">22 13 set_value_alt 0 4 26 24 TypedSkel::set_value_alt 0 1 10 173</span>
<span class="s0">// These do the same thing as the functions above.</span>

<span class="s0">/**</span>
 <span class="s0">* Stores an integer value.  Exact same functionality as set_value, except</span>
 <span class="s0">* that this isn't an inline function.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void TypedSkel::set_value_alt(int n);</span>

<span class="s0">23 13 get_value_alt 0 4 26 24 TypedSkel::get_value_alt 0 1 11 142</span>
<span class="s0">/**</span>
 <span class="s0">* Retreives a value that was previously stored.  Exact same functionality as</span>
 <span class="s0">* get_value, except that this isn't an inline function.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">int TypedSkel::get_value_alt(void);</span>

<span class="s0">24 14 get_class_type 0 4 26 25 TypedSkel::get_class_type 0 1 12 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle TypedSkel::get_class_type(void);</span>

<span class="s0">12</span>
<span class="s0">1 0 0 7 2 28 14 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">2 0 0 15 2 28 14 0 0 1 6 param0 0 29  </span>
<span class="s0">3 0 0 4 4 32 0 0 58 // These inline functions allow you to get and set _value. 2 4 this 3 28  1 n 1 31  </span>
<span class="s0">4 0 0 6 5 31 0 0 56 /**</span>
 <span class="s0">* Retreives a value that was previously stored.</span>
 <span class="s0">*/ 1 4 this 3 28  </span>
<span class="s0">5 0 0 4 6 32 0 0 121 /**</span>
 <span class="s0">* Stores an integer value.  Exact same functionality as set_value, except</span>
 <span class="s0">* that this isn't an inline function.</span>
 <span class="s0">*/ 2 4 this 3 28  1 n 1 31  </span>
<span class="s0">6 0 0 6 7 31 0 0 142 /**</span>
 <span class="s0">* Retreives a value that was previously stored.  Exact same functionality as</span>
 <span class="s0">* get_value, except that this isn't an inline function.</span>
 <span class="s0">*/ 1 4 this 3 28  </span>
<span class="s0">7 0 0 7 10 33 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">8 0 0 4 11 32 0 0 58 // These inline functions allow you to get and set _value. 2 4 this 3 33  1 n 1 31  </span>
<span class="s0">9 0 0 6 12 31 0 0 56 /**</span>
 <span class="s0">* Retreives a value that was previously stored.</span>
 <span class="s0">*/ 1 4 this 3 33  </span>
<span class="s0">10 0 0 4 13 32 0 0 121 /**</span>
 <span class="s0">* Stores an integer value.  Exact same functionality as set_value, except</span>
 <span class="s0">* that this isn't an inline function.</span>
 <span class="s0">*/ 2 4 this 3 33  1 n 1 31  </span>
<span class="s0">11 0 0 6 14 31 0 0 142 /**</span>
 <span class="s0">* Retreives a value that was previously stored.  Exact same functionality as</span>
 <span class="s0">* get_value, except that this isn't an inline function.</span>
 <span class="s0">*/ 1 4 this 3 33  </span>
<span class="s0">12 0 0 7 15 35 0 0 0 0 </span>
<span class="s0">11</span>
<span class="s0">25 9 BasicSkel 0 26625 9 BasicSkel 9 BasicSkel 0 0 0 1 13 14 0 4 15 16 17 18 0 0 0 0 0 262</span>
<span class="s0">/**</span>
 <span class="s0">* This is the most basic of the skeleton classes.  It stores an integer, and</span>
 <span class="s0">* will return it on request.</span>
 <span class="s0">*</span>
 <span class="s0">* The skeleton classes are intended to help you learn how to add C++ classes</span>
 <span class="s0">* to panda.  See also the manual, &quot;Adding C++ Classes to Panda.&quot;</span>
 <span class="s0">*/</span>

<span class="s0">26 9 TypedSkel 0 75777 9 TypedSkel 9 TypedSkel 0 0 0 1 19 0 0 5 20 21 22 23 24 0 0 1 0 27 0 0 0 0 259</span>
<span class="s0">/**</span>
 <span class="s0">* Skeleton object that inherits from TypedObject.  Stores an integer, and</span>
 <span class="s0">* will return it on request.</span>
 <span class="s0">*</span>
 <span class="s0">* The skeleton classes are intended to help you learn how to add C++ classes</span>
 <span class="s0">* to panda.  See also the manual, &quot;Adding C++ Classes to Panda.&quot;</span>
 <span class="s0">*/</span>

<span class="s0">27 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">28 11 BasicSkel * 0 8576 11 BasicSkel * 11 BasicSkel * 0 0 25 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">29 17 BasicSkel const * 0 8576 17 BasicSkel const * 17 BasicSkel const * 0 0 30 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">30 15 BasicSkel const 0 8832 15 BasicSkel const 15 BasicSkel const 0 0 25 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">31 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">32 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">33 11 TypedSkel * 0 8576 11 TypedSkel * 11 TypedSkel * 0 0 26 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">34 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">35 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 34 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">0</span>
<span class="s0">0</span>
</pre>
</body>
</html>