<html>
<head>
<title>libp3dtoolbase.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3dtoolbase.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">14 libp3dtoolbase 4 NSJh 12 panda3d.core </span>
<span class="s0">60</span>
<span class="s0">56 15 get_total_alloc 0 4 116 32 NeverFreeMemory::get_total_alloc 0 1 1 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes consumed by all the pages allocated</span>
 <span class="s0">* internally by this object.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">static inline std::size_t NeverFreeMemory::get_total_alloc(void);</span>

<span class="s0">57 14 get_total_used 0 4 116 31 NeverFreeMemory::get_total_used 0 1 2 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes requested by the application in calls to</span>
 <span class="s0">* NeverFreeMemory::alloc().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">static inline std::size_t NeverFreeMemory::get_total_used(void);</span>

<span class="s0">58 16 get_total_unused 0 4 116 33 NeverFreeMemory::get_total_unused 0 1 3 178</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the difference between get_total_alloc() and get_total_used().</span>
 <span class="s0">* This represents bytes in allocated pages that have not (yet) been used by</span>
 <span class="s0">* the application.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline std::size_t NeverFreeMemory::get_total_unused(void);</span>

<span class="s0">59 16 ~NeverFreeMemory 0 516 116 33 NeverFreeMemory::~NeverFreeMemory 0 0 0</span>
<span class="s0">40</span>
<span class="s0">NeverFreeMemory::~NeverFreeMemory(void);</span>

<span class="s0">60 10 TypeHandle 0 260 117 22 TypeHandle::TypeHandle 0 2 4 5 114</span>
<span class="s0">/**</span>
 <span class="s0">* Private constructor for initializing a TypeHandle from an index, used by</span>
 <span class="s0">* none() and by from_index().</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">TypeHandle::TypeHandle(void) noexcept = default;</span>
<span class="s0">inline TypeHandle::TypeHandle(TypeHandle const &amp;) = default;</span>

<span class="s0">61 4 make 0 4 117 16 TypeHandle::make 0 1 6 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle TypeHandle::make(PyTypeObject *classobj);</span>

<span class="s0">62 11 operator == 0 4 117 23 TypeHandle::operator == 0 1 7 0</span>
<span class="s0">67</span>
<span class="s0">inline bool TypeHandle::operator ==(TypeHandle const &amp;other) const;</span>

<span class="s0">63 11 operator != 0 4 117 23 TypeHandle::operator != 0 1 8 0</span>
<span class="s0">67</span>
<span class="s0">inline bool TypeHandle::operator !=(TypeHandle const &amp;other) const;</span>

<span class="s0">64 10 operator &lt; 0 4 117 22 TypeHandle::operator &lt; 0 1 9 0</span>
<span class="s0">66</span>
<span class="s0">inline bool TypeHandle::operator &lt;(TypeHandle const &amp;other) const;</span>

<span class="s0">65 11 operator &lt;= 0 4 117 23 TypeHandle::operator &lt;= 0 1 10 0</span>
<span class="s0">67</span>
<span class="s0">inline bool TypeHandle::operator &lt;=(TypeHandle const &amp;other) const;</span>

<span class="s0">66 10 operator &gt; 0 4 117 22 TypeHandle::operator &gt; 0 1 11 0</span>
<span class="s0">66</span>
<span class="s0">inline bool TypeHandle::operator &gt;(TypeHandle const &amp;other) const;</span>

<span class="s0">67 11 operator &gt;= 0 4 117 23 TypeHandle::operator &gt;= 0 1 12 0</span>
<span class="s0">67</span>
<span class="s0">inline bool TypeHandle::operator &gt;=(TypeHandle const &amp;other) const;</span>

<span class="s0">68 10 compare_to 0 4 117 22 TypeHandle::compare_to 0 1 13 207</span>
<span class="s0">/**</span>
 <span class="s0">* Sorts TypeHandles arbitrarily (according to &lt;, &gt;, etc.).  Returns a number</span>
 <span class="s0">* less than 0 if this type sorts before the other one, greater than zero if</span>
 <span class="s0">* it sorts after, 0 if they are equivalent.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int TypeHandle::compare_to(TypeHandle const &amp;other) const;</span>

<span class="s0">69 8 get_hash 0 4 117 20 TypeHandle::get_hash 0 1 14 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a hash code suitable for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::size_t TypeHandle::get_hash(void) const;</span>

<span class="s0">70 8 get_name 0 4 117 20 TypeHandle::get_name 0 1 15 216</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the type.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline std::string TypeHandle::get_name(TypedObject *object = nullptr) const;</span>

<span class="s0">71 15 is_derived_from 0 4 117 27 TypeHandle::is_derived_from 0 1 16 268</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this type is derived from the indicated type, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object = nullptr) const;</span>

<span class="s0">72 22 get_num_parent_classes 0 4 117 34 TypeHandle::get_num_parent_classes 0 1 17 506</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of parent classes that this type is known to have.  This</span>
 <span class="s0">* may then be used to index into get_parent_class().  The result will be 0 if</span>
 <span class="s0">* this class does not inherit from any other classes, 1 if normal, single</span>
 <span class="s0">* inheritance is in effect, or greater than one if multiple inheritance is in</span>
 <span class="s0">* effect.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline int TypeHandle::get_num_parent_classes(TypedObject *object = nullptr) const;</span>

<span class="s0">73 16 get_parent_class 0 4 117 28 TypeHandle::get_parent_class 0 1 18 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth parent class of this type.  The index should be in the</span>
 <span class="s0">* range 0 &lt;= index &lt; get_num_parent_classes().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline TypeHandle TypeHandle::get_parent_class(int index) const;</span>

<span class="s0">74 21 get_num_child_classes 0 4 117 33 TypeHandle::get_num_child_classes 0 1 19 314</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of child classes that this type is known to have.  This</span>
 <span class="s0">* may then be used to index into get_child_class().</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline int TypeHandle::get_num_child_classes(TypedObject *object = nullptr) const;</span>

<span class="s0">75 15 get_child_class 0 4 117 27 TypeHandle::get_child_class 0 1 20 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth child class of this type.  The index should be in the range</span>
 <span class="s0">* 0 &lt;= index &lt; get_num_child_classes().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline TypeHandle TypeHandle::get_child_class(int index) const;</span>

<span class="s0">76 18 get_parent_towards 0 4 117 30 TypeHandle::get_parent_towards 0 1 21 577</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the parent class that is in a direct line of inheritance to the</span>
 <span class="s0">* indicated ancestor class.  This is useful in the presence of multiple</span>
 <span class="s0">* inheritance to try to determine what properties an unknown type may have.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is TypeHandle::none() if the type does not inherit from</span>
 <span class="s0">* the ancestor.  If ancestor is the same as this type, the return value is</span>
 <span class="s0">* this type.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object = nullptr) const;</span>

<span class="s0">77 24 get_best_parent_from_Set 0 4 117 36 TypeHandle::get_best_parent_from_Set 0 1 22 61</span>
<span class="s0">/**</span>
 <span class="s0">* Return the Index of the BEst fit Classs from a set</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">int TypeHandle::get_best_parent_from_Set(set&lt; int &gt; const &amp;legal_vals) const;</span>

<span class="s0">78 16 get_memory_usage 0 4 117 28 TypeHandle::get_memory_usage 0 1 23 194</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total allocated memory used by objects of this type, for the</span>
 <span class="s0">* indicated memory class.  This is only updated if track-memory-usage is set</span>
 <span class="s0">* true in your Config.prc file.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">std::size_t TypeHandle::get_memory_usage(TypeHandle::MemoryClass memory_class) const;</span>

<span class="s0">79 16 inc_memory_usage 0 4 117 28 TypeHandle::inc_memory_usage 0 1 24 110</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated amount to the record for the total allocated memory for</span>
 <span class="s0">* objects of this type.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">void TypeHandle::inc_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size);</span>

<span class="s0">80 16 dec_memory_usage 0 4 117 28 TypeHandle::dec_memory_usage 0 1 25 117</span>
<span class="s0">/**</span>
 <span class="s0">* Subtracts the indicated amount from the record for the total allocated</span>
 <span class="s0">* memory for objects of this type.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">void TypeHandle::dec_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size);</span>

<span class="s0">81 9 get_index 0 4 117 21 TypeHandle::get_index 0 1 26 354</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the integer index associated with this TypeHandle.  Each different</span>
 <span class="s0">* TypeHandle will have a different index.  However, you probably shouldn't be</span>
 <span class="s0">* using this method; you should just treat the TypeHandles as opaque classes.</span>
 <span class="s0">* This is provided for the convenience of non-C++ scripting languages to</span>
 <span class="s0">* build a hashtable of TypeHandles.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline int TypeHandle::get_index(void) const;</span>

<span class="s0">82 6 output 0 4 117 18 TypeHandle::output 0 1 27 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void TypeHandle::output(std::ostream &amp;out) const;</span>

<span class="s0">83 4 none 0 4 117 16 TypeHandle::none 0 1 28 0</span>
<span class="s0">51</span>
<span class="s0">static constexpr TypeHandle TypeHandle::none(void);</span>

<span class="s0">84 22 operator typecast bool 0 132 117 34 TypeHandle::operator typecast bool 0 1 29 0</span>
<span class="s0">34</span>
<span class="s0">inline operator bool (void) const;</span>

<span class="s0">85 11 ~TypeHandle 0 516 117 23 TypeHandle::~TypeHandle 0 0 0</span>
<span class="s0">30</span>
<span class="s0">TypeHandle::~TypeHandle(void);</span>

<span class="s0">86 21 register_dynamic_type 0 4 122 35 TypeRegistry::register_dynamic_type 0 1 31 219</span>
<span class="s0">/**</span>
 <span class="s0">* Registers a new type on-the-fly, presumably at runtime.  A new TypeHandle</span>
 <span class="s0">* is returned if the typename was not seen before; otherwise the same</span>
 <span class="s0">* TypeHandle that was last used for this typename is returned.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">TypeHandle TypeRegistry::register_dynamic_type(std::string const &amp;name);</span>

<span class="s0">87 17 record_derivation 0 4 122 31 TypeRegistry::record_derivation 0 1 32 201</span>
<span class="s0">/**</span>
 <span class="s0">* Records that the type referenced by child inherits directly from the type</span>
 <span class="s0">* referenced by parent.  In the event of multiple inheritance, this should be</span>
 <span class="s0">* called once for each parent class.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void TypeRegistry::record_derivation(TypeHandle child, TypeHandle parent);</span>

<span class="s0">88 21 record_alternate_name 0 4 122 35 TypeRegistry::record_alternate_name 0 1 33 278</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates an alternate name for the same type.  This is particularly useful</span>
 <span class="s0">* when a type has changed names, since the type is stored in a Bam file by</span>
 <span class="s0">* name; setting the original name as the alternate will allow the type to be</span>
 <span class="s0">* correctly read from old Bam files.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">void TypeRegistry::record_alternate_name(TypeHandle type, std::string const &amp;name);</span>

<span class="s0">89 18 record_python_type 0 4 122 32 TypeRegistry::record_python_type 0 1 34 157</span>
<span class="s0">/**</span>
 <span class="s0">* Records the given Python type pointer in the type registry for the benefit</span>
 <span class="s0">* of interrogate, which expects this to contain a Dtool_PyTypedObject.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void TypeRegistry::record_python_type(TypeHandle type, PyObject *python_type);</span>

<span class="s0">90 9 find_type 0 4 122 23 TypeRegistry::find_type 0 1 35 157</span>
<span class="s0">/**</span>
 <span class="s0">* Looks for a previously-registered type of the given name.  Returns its</span>
 <span class="s0">* TypeHandle if it exists, or TypeHandle::none() if there is no such type.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">TypeHandle TypeRegistry::find_type(std::string const &amp;name) const;</span>

<span class="s0">91 15 find_type_by_id 0 4 122 29 TypeRegistry::find_type_by_id 0 1 36 207</span>
<span class="s0">/**</span>
 <span class="s0">* Looks for a previously-registered type with the given id number (as</span>
 <span class="s0">* returned by TypeHandle::get_index()). Returns its TypeHandle if it exists,</span>
 <span class="s0">* or TypeHandle::none() if there is no such type.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">TypeHandle TypeRegistry::find_type_by_id(int id) const;</span>

<span class="s0">92 8 get_name 0 4 122 22 TypeRegistry::get_name 0 1 37 226</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the indicated type.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">std::string TypeRegistry::get_name(TypeHandle type, TypedObject *object) const;</span>

<span class="s0">93 15 is_derived_from 0 4 122 29 TypeRegistry::is_derived_from 0 1 38 571</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the first type is derived from the second type, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;child_object&quot; pointer is an optional pointer to the TypedObject class</span>
 <span class="s0">* that owns the child TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertently undefined.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition follows the definitions for look_up() and</span>
 <span class="s0">* freshen_derivations() just to maximize the chance the the compiler will be</span>
 <span class="s0">* able to inline the above functions.  Yeah, a compiler shouldn't care, but</span>
 <span class="s0">* there's a big different between &quot;shouldn't&quot; and &quot;doesn't&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">bool TypeRegistry::is_derived_from(TypeHandle child, TypeHandle base, TypedObject *child_object);</span>

<span class="s0">94 19 get_num_typehandles 0 4 122 33 TypeRegistry::get_num_typehandles 0 1 39 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of unique TypeHandles in the system.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">int TypeRegistry::get_num_typehandles(void);</span>

<span class="s0">95 14 get_typehandle 0 4 122 28 TypeRegistry::get_typehandle 0 1 40 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth TypeHandle in the system.  See get_num_typehandles().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">TypeHandle TypeRegistry::get_typehandle(int n);</span>

<span class="s0">96 20 get_num_root_classes 0 4 122 34 TypeRegistry::get_num_root_classes 0 1 41 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of root classes--that is, classes that do not inherit</span>
 <span class="s0">* from any other classes--known in the system.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int TypeRegistry::get_num_root_classes(void);</span>

<span class="s0">97 14 get_root_class 0 4 122 28 TypeRegistry::get_root_class 0 1 42 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth root class in the system.  See get_num_root_classes().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">TypeHandle TypeRegistry::get_root_class(int n);</span>

<span class="s0">98 22 get_num_parent_classes 0 4 122 36 TypeRegistry::get_num_parent_classes 0 1 43 515</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of parent classes that the indicated type is known to</span>
 <span class="s0">* have.  This may then be used to index into get_parent_class().  The result</span>
 <span class="s0">* will be 0 if this class does not inherit from any other classes, 1 if</span>
 <span class="s0">* normal, single inheritance is in effect, or greater than one if multiple</span>
 <span class="s0">* inheritance is in effect.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">int TypeRegistry::get_num_parent_classes(TypeHandle child, TypedObject *child_object) const;</span>

<span class="s0">99 16 get_parent_class 0 4 122 30 TypeRegistry::get_parent_class 0 1 44 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth parent class of this type.  The index should be in the</span>
 <span class="s0">* range 0 &lt;= index &lt; get_num_parent_classes().</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">TypeHandle TypeRegistry::get_parent_class(TypeHandle child, int index) const;</span>

<span class="s0">100 21 get_num_child_classes 0 4 122 35 TypeRegistry::get_num_child_classes 0 1 45 323</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of child classes that the indicated type is known to</span>
 <span class="s0">* have.  This may then be used to index into get_child_class().</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">int TypeRegistry::get_num_child_classes(TypeHandle child, TypedObject *child_object) const;</span>

<span class="s0">101 15 get_child_class 0 4 122 29 TypeRegistry::get_child_class 0 1 46 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth child class of this type.  The index should be in the range</span>
 <span class="s0">* 0 &lt;= index &lt; get_num_child_classes().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">TypeHandle TypeRegistry::get_child_class(TypeHandle child, int index) const;</span>

<span class="s0">102 18 get_parent_towards 0 4 122 32 TypeRegistry::get_parent_towards 0 1 47 434</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the parent of the indicated child class that is in a direct line of</span>
 <span class="s0">* inheritance to the indicated ancestor class.  This is useful in the</span>
 <span class="s0">* presence of multiple inheritance to try to determine what properties an</span>
 <span class="s0">* unknown type may have.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">TypeHandle TypeRegistry::get_parent_towards(TypeHandle child, TypeHandle base, TypedObject *child_object);</span>

<span class="s0">103 16 reregister_types 0 4 122 30 TypeRegistry::reregister_types 0 1 48 336</span>
<span class="s0">/**</span>
 <span class="s0">* Walks through the TypeRegistry tree and makes sure that each type that was</span>
 <span class="s0">* previously registered is *still* registered.  This seems to get broken in</span>
 <span class="s0">* certain circumstances when compiled against libc5--it is as if the static</span>
 <span class="s0">* initializer stomps on the _type_handle values of each class after they've</span>
 <span class="s0">* been registered.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static void TypeRegistry::reregister_types(void);</span>

<span class="s0">104 5 write 0 4 122 19 TypeRegistry::write 0 1 49 139</span>
<span class="s0">/**</span>
 <span class="s0">* Makes an attempt to format the entire TypeRegistry in a nice way that shows</span>
 <span class="s0">* the derivation tree as intelligently as possible.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void TypeRegistry::write(std::ostream &amp;out) const;</span>

<span class="s0">105 3 ptr 0 4 122 17 TypeRegistry::ptr 0 1 50 130</span>
<span class="s0">// ptr() returns the pointer to the global TypeRegistry object.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the global TypeRegistry object.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static inline TypeRegistry *TypeRegistry::ptr(void);</span>

<span class="s0">106 12 TypeRegistry 0 260 122 26 TypeRegistry::TypeRegistry 0 1 30 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline TypeRegistry::TypeRegistry(TypeRegistry const &amp;) = default;</span>

<span class="s0">107 13 ~TypeRegistry 0 516 122 27 TypeRegistry::~TypeRegistry 0 0 0</span>
<span class="s0">34</span>
<span class="s0">TypeRegistry::~TypeRegistry(void);</span>

<span class="s0">108 20 upcast_to_MemoryBase 0 12 124 33 TypedObject::upcast_to_MemoryBase 0 0 37</span>
<span class="s0">upcast from TypedObject to MemoryBase</span>
<span class="s0">52</span>
<span class="s0">MemoryBase *TypedObject::upcast_to_MemoryBase(void);</span>

<span class="s0">109 23 downcast_to_TypedObject 0 12 123 35 MemoryBase::downcast_to_TypedObject 0 0 39</span>
<span class="s0">downcast from MemoryBase to TypedObject</span>
<span class="s0">55</span>
<span class="s0">TypedObject *MemoryBase::downcast_to_TypedObject(void);</span>

<span class="s0">110 12 ~TypedObject 0 518 124 25 TypedObject::~TypedObject 0 0 56</span>
<span class="s0">// A virtual destructor is just a good idea.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">virtual TypedObject::~TypedObject(void);</span>

<span class="s0">111 8 get_type 0 6 124 21 TypedObject::get_type 0 1 51 166</span>
<span class="s0">// Derived classes should override this function to return get_class_type().</span>

<span class="s0">// Derived classes should override this function to return get_class_type().</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">virtual TypeHandle TypedObject::get_type(void) const = 0;</span>

<span class="s0">112 14 get_type_index 0 4 124 27 TypedObject::get_type_index 0 1 52 180</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the internal index number associated with this object's TypeHandle,</span>
 <span class="s0">* a unique number for each different type.  This is equivalent to</span>
 <span class="s0">* get_type().get_index().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int TypedObject::get_type_index(void) const;</span>

<span class="s0">113 10 is_of_type 0 4 124 23 TypedObject::is_of_type 0 1 53 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the current object is or derives from the indicated type.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool TypedObject::is_of_type(TypeHandle handle) const;</span>

<span class="s0">114 13 is_exact_type 0 4 124 26 TypedObject::is_exact_type 0 1 54 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the current object is the indicated type exactly.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool TypedObject::is_exact_type(TypeHandle handle) const;</span>

<span class="s0">115 14 get_class_type 0 4 124 27 TypedObject::get_class_type 0 1 55 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle TypedObject::get_class_type(void);</span>

<span class="s0">55</span>
<span class="s0">1 0 0 6 2 125 0 0 110 /**</span>
 <span class="s0">* Returns the total number of bytes consumed by all the pages allocated</span>
 <span class="s0">* internally by this object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">2 0 0 6 3 125 0 0 114 /**</span>
 <span class="s0">* Returns the total number of bytes requested by the application in calls to</span>
 <span class="s0">* NeverFreeMemory::alloc().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">3 0 0 6 4 125 0 0 178 /**</span>
 <span class="s0">* Returns the difference between get_total_alloc() and get_total_used().</span>
 <span class="s0">* This represents bytes in allocated pages that have not (yet) been used by</span>
 <span class="s0">* the application.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">4 0 0 7 7 127 85 0 0 0 </span>
<span class="s0">5 0 0 15 7 127 85 0 0 1 6 param0 0 128  </span>
<span class="s0">6 0 0 55 9 127 85 0 0 1 8 classobj 1 130  </span>
<span class="s0">7 0 0 6 10 133 0 0 0 2 4 this 3 128  5 other 1 128  </span>
<span class="s0">8 0 0 6 11 133 0 0 0 2 4 this 3 128  5 other 1 128  </span>
<span class="s0">9 0 0 6 12 133 0 0 0 2 4 this 3 128  5 other 1 128  </span>
<span class="s0">10 0 0 6 13 133 0 0 0 2 4 this 3 128  5 other 1 128  </span>
<span class="s0">11 0 0 6 14 133 0 0 0 2 4 this 3 128  5 other 1 128  </span>
<span class="s0">12 0 0 6 15 133 0 0 0 2 4 this 3 128  5 other 1 128  </span>
<span class="s0">13 0 0 6 16 119 0 0 207 /**</span>
 <span class="s0">* Sorts TypeHandles arbitrarily (according to &lt;, &gt;, etc.).  Returns a number</span>
 <span class="s0">* less than 0 if this type sorts before the other one, greater than zero if</span>
 <span class="s0">* it sorts after, 0 if they are equivalent.</span>
 <span class="s0">*/ 2 4 this 3 128  5 other 1 128  </span>
<span class="s0">14 0 0 6 17 125 0 0 54 /**</span>
 <span class="s0">* Returns a hash code suitable for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 128  </span>
<span class="s0">15 0 0 6 18 135 0 0 216 /**</span>
 <span class="s0">* Returns the name of the type.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 2 4 this 3 128  6 object 5 134  </span>
<span class="s0">16 0 0 6 19 133 0 0 268 /**</span>
 <span class="s0">* Returns true if this type is derived from the indicated type, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 3 4 this 3 128  6 parent 1 127  6 object 5 134  </span>
<span class="s0">17 0 0 6 20 119 0 0 506 /**</span>
 <span class="s0">* Returns the number of parent classes that this type is known to have.  This</span>
 <span class="s0">* may then be used to index into get_parent_class().  The result will be 0 if</span>
 <span class="s0">* this class does not inherit from any other classes, 1 if normal, single</span>
 <span class="s0">* inheritance is in effect, or greater than one if multiple inheritance is in</span>
 <span class="s0">* effect.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 2 4 this 3 128  6 object 5 134  </span>
<span class="s0">18 0 0 7 21 127 85 0 129 /**</span>
 <span class="s0">* Returns the nth parent class of this type.  The index should be in the</span>
 <span class="s0">* range 0 &lt;= index &lt; get_num_parent_classes().</span>
 <span class="s0">*/ 2 4 this 3 128  5 index 1 119  </span>
<span class="s0">19 0 0 6 22 119 0 0 314 /**</span>
 <span class="s0">* Returns the number of child classes that this type is known to have.  This</span>
 <span class="s0">* may then be used to index into get_child_class().</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 2 4 this 3 128  6 object 5 134  </span>
<span class="s0">20 0 0 7 23 127 85 0 127 /**</span>
 <span class="s0">* Returns the nth child class of this type.  The index should be in the range</span>
 <span class="s0">* 0 &lt;= index &lt; get_num_child_classes().</span>
 <span class="s0">*/ 2 4 this 3 128  5 index 1 119  </span>
<span class="s0">21 0 0 7 24 127 85 0 577 /**</span>
 <span class="s0">* Returns the parent class that is in a direct line of inheritance to the</span>
 <span class="s0">* indicated ancestor class.  This is useful in the presence of multiple</span>
 <span class="s0">* inheritance to try to determine what properties an unknown type may have.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is TypeHandle::none() if the type does not inherit from</span>
 <span class="s0">* the ancestor.  If ancestor is the same as this type, the return value is</span>
 <span class="s0">* this type.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 3 4 this 3 128  8 ancestor 1 127  6 object 5 134  </span>
<span class="s0">22 0 0 6 25 119 0 0 61 /**</span>
 <span class="s0">* Return the Index of the BEst fit Classs from a set</span>
 <span class="s0">*/ 2 4 this 3 128  10 legal_vals 1 136  </span>
<span class="s0">23 0 0 6 26 125 0 0 194 /**</span>
 <span class="s0">* Returns the total allocated memory used by objects of this type, for the</span>
 <span class="s0">* indicated memory class.  This is only updated if track-memory-usage is set</span>
 <span class="s0">* true in your Config.prc file.</span>
 <span class="s0">*/ 2 4 this 3 128  12 memory_class 1 118  </span>
<span class="s0">24 0 0 4 27 139 0 0 110 /**</span>
 <span class="s0">* Adds the indicated amount to the record for the total allocated memory for</span>
 <span class="s0">* objects of this type.</span>
 <span class="s0">*/ 3 4 this 3 127  12 memory_class 1 118  4 size 1 125  </span>
<span class="s0">25 0 0 4 28 139 0 0 117 /**</span>
 <span class="s0">* Subtracts the indicated amount from the record for the total allocated</span>
 <span class="s0">* memory for objects of this type.</span>
 <span class="s0">*/ 3 4 this 3 127  12 memory_class 1 118  4 size 1 125  </span>
<span class="s0">26 0 0 6 29 119 0 0 354 /**</span>
 <span class="s0">* Returns the integer index associated with this TypeHandle.  Each different</span>
 <span class="s0">* TypeHandle will have a different index.  However, you probably shouldn't be</span>
 <span class="s0">* using this method; you should just treat the TypeHandles as opaque classes.</span>
 <span class="s0">* This is provided for the convenience of non-C++ scripting languages to</span>
 <span class="s0">* build a hashtable of TypeHandles.</span>
 <span class="s0">*/ 1 4 this 3 128  </span>
<span class="s0">27 0 0 4 30 139 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 128  3 out 1 140  </span>
<span class="s0">28 0 0 7 31 127 85 0 0 0 </span>
<span class="s0">29 0 0 6 32 133 0 0 0 1 4 this 3 128  </span>
<span class="s0">30 0 0 15 67 144 107 0 0 1 6 param0 0 142  </span>
<span class="s0">31 0 0 7 43 127 85 0 219 /**</span>
 <span class="s0">* Registers a new type on-the-fly, presumably at runtime.  A new TypeHandle</span>
 <span class="s0">* is returned if the typename was not seen before; otherwise the same</span>
 <span class="s0">* TypeHandle that was last used for this typename is returned.</span>
 <span class="s0">*/ 2 4 this 3 144  4 name 1 135  </span>
<span class="s0">32 0 0 4 44 139 0 0 201 /**</span>
 <span class="s0">* Records that the type referenced by child inherits directly from the type</span>
 <span class="s0">* referenced by parent.  In the event of multiple inheritance, this should be</span>
 <span class="s0">* called once for each parent class.</span>
 <span class="s0">*/ 3 4 this 3 144  5 child 1 127  6 parent 1 127  </span>
<span class="s0">33 0 0 4 45 139 0 0 278 /**</span>
 <span class="s0">* Indicates an alternate name for the same type.  This is particularly useful</span>
 <span class="s0">* when a type has changed names, since the type is stored in a Bam file by</span>
 <span class="s0">* name; setting the original name as the alternate will allow the type to be</span>
 <span class="s0">* correctly read from old Bam files.</span>
 <span class="s0">*/ 3 4 this 3 144  4 type 1 127  4 name 1 135  </span>
<span class="s0">34 0 0 4 46 139 0 0 157 /**</span>
 <span class="s0">* Records the given Python type pointer in the type registry for the benefit</span>
 <span class="s0">* of interrogate, which expects this to contain a Dtool_PyTypedObject.</span>
 <span class="s0">*/ 3 4 this 3 144  4 type 1 127  11 python_type 1 145  </span>
<span class="s0">35 0 0 7 47 127 85 0 157 /**</span>
 <span class="s0">* Looks for a previously-registered type of the given name.  Returns its</span>
 <span class="s0">* TypeHandle if it exists, or TypeHandle::none() if there is no such type.</span>
 <span class="s0">*/ 2 4 this 3 142  4 name 1 135  </span>
<span class="s0">36 0 0 7 48 127 85 0 207 /**</span>
 <span class="s0">* Looks for a previously-registered type with the given id number (as</span>
 <span class="s0">* returned by TypeHandle::get_index()). Returns its TypeHandle if it exists,</span>
 <span class="s0">* or TypeHandle::none() if there is no such type.</span>
 <span class="s0">*/ 2 4 this 3 142  2 id 1 119  </span>
<span class="s0">37 0 0 6 49 135 0 0 226 /**</span>
 <span class="s0">* Returns the name of the indicated type.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 3 4 this 3 142  4 type 1 127  6 object 1 134  </span>
<span class="s0">38 0 0 6 50 133 0 0 571 /**</span>
 <span class="s0">* Returns true if the first type is derived from the second type, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;child_object&quot; pointer is an optional pointer to the TypedObject class</span>
 <span class="s0">* that owns the child TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertently undefined.</span>
 <span class="s0">*</span>
 <span class="s0">* This function definition follows the definitions for look_up() and</span>
 <span class="s0">* freshen_derivations() just to maximize the chance the the compiler will be</span>
 <span class="s0">* able to inline the above functions.  Yeah, a compiler shouldn't care, but</span>
 <span class="s0">* there's a big different between &quot;shouldn't&quot; and &quot;doesn't&quot;.</span>
 <span class="s0">*/ 4 4 this 3 144  5 child 1 127  4 base 1 127  12 child_object 1 134  </span>
<span class="s0">39 0 0 6 51 119 0 0 72 /**</span>
 <span class="s0">* Returns the total number of unique TypeHandles in the system.</span>
 <span class="s0">*/ 1 4 this 3 144  </span>
<span class="s0">40 0 0 7 52 127 85 0 80 /**</span>
 <span class="s0">* Returns the nth TypeHandle in the system.  See get_num_typehandles().</span>
 <span class="s0">*/ 2 4 this 3 144  1 n 1 119  </span>
<span class="s0">41 0 0 6 54 119 0 0 131 /**</span>
 <span class="s0">* Returns the number of root classes--that is, classes that do not inherit</span>
 <span class="s0">* from any other classes--known in the system.</span>
 <span class="s0">*/ 1 4 this 3 144  </span>
<span class="s0">42 0 0 7 55 127 85 0 81 /**</span>
 <span class="s0">* Returns the nth root class in the system.  See get_num_root_classes().</span>
 <span class="s0">*/ 2 4 this 3 144  1 n 1 119  </span>
<span class="s0">43 0 0 6 57 119 0 0 515 /**</span>
 <span class="s0">* Returns the number of parent classes that the indicated type is known to</span>
 <span class="s0">* have.  This may then be used to index into get_parent_class().  The result</span>
 <span class="s0">* will be 0 if this class does not inherit from any other classes, 1 if</span>
 <span class="s0">* normal, single inheritance is in effect, or greater than one if multiple</span>
 <span class="s0">* inheritance is in effect.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 3 4 this 3 142  5 child 1 127  12 child_object 1 134  </span>
<span class="s0">44 0 0 7 58 127 85 0 129 /**</span>
 <span class="s0">* Returns the nth parent class of this type.  The index should be in the</span>
 <span class="s0">* range 0 &lt;= index &lt; get_num_parent_classes().</span>
 <span class="s0">*/ 3 4 this 3 142  5 child 1 127  5 index 1 119  </span>
<span class="s0">45 0 0 6 59 119 0 0 323 /**</span>
 <span class="s0">* Returns the number of child classes that the indicated type is known to</span>
 <span class="s0">* have.  This may then be used to index into get_child_class().</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 3 4 this 3 142  5 child 1 127  12 child_object 1 134  </span>
<span class="s0">46 0 0 7 60 127 85 0 127 /**</span>
 <span class="s0">* Returns the nth child class of this type.  The index should be in the range</span>
 <span class="s0">* 0 &lt;= index &lt; get_num_child_classes().</span>
 <span class="s0">*/ 3 4 this 3 142  5 child 1 127  5 index 1 119  </span>
<span class="s0">47 0 0 7 61 127 85 0 434 /**</span>
 <span class="s0">* Returns the parent of the indicated child class that is in a direct line of</span>
 <span class="s0">* inheritance to the indicated ancestor class.  This is useful in the</span>
 <span class="s0">* presence of multiple inheritance to try to determine what properties an</span>
 <span class="s0">* unknown type may have.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;object&quot; pointer is an optional pointer to the TypedObject class that</span>
 <span class="s0">* owns this TypeHandle.  It is only used in case the TypeHandle is</span>
 <span class="s0">* inadvertantly undefined.</span>
 <span class="s0">*/ 4 4 this 3 144  5 child 1 127  4 base 1 127  12 child_object 1 134  </span>
<span class="s0">48 0 0 4 62 139 0 0 336 /**</span>
 <span class="s0">* Walks through the TypeRegistry tree and makes sure that each type that was</span>
 <span class="s0">* previously registered is *still* registered.  This seems to get broken in</span>
 <span class="s0">* certain circumstances when compiled against libc5--it is as if the static</span>
 <span class="s0">* initializer stomps on the _type_handle values of each class after they've</span>
 <span class="s0">* been registered.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">49 0 0 4 63 139 0 0 139 /**</span>
 <span class="s0">* Makes an attempt to format the entire TypeRegistry in a nice way that shows</span>
 <span class="s0">* the derivation tree as intelligently as possible.</span>
 <span class="s0">*/ 2 4 this 3 142  3 out 1 140  </span>
<span class="s0">50 0 0 6 64 144 0 0 65 /**</span>
 <span class="s0">* Returns the pointer to the global TypeRegistry object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">51 0 0 7 73 127 85 0 76 // Derived classes should override this function to return get_class_type(). 1 4 this 3 148  </span>
<span class="s0">52 0 0 6 75 119 0 0 180 /**</span>
 <span class="s0">* Returns the internal index number associated with this object's TypeHandle,</span>
 <span class="s0">* a unique number for each different type.  This is equivalent to</span>
 <span class="s0">* get_type().get_index().</span>
 <span class="s0">*/ 1 4 this 3 148  </span>
<span class="s0">53 0 0 6 76 133 0 0 84 /**</span>
 <span class="s0">* Returns true if the current object is or derives from the indicated type.</span>
 <span class="s0">*/ 2 4 this 3 148  6 handle 1 127  </span>
<span class="s0">54 0 0 6 77 133 0 0 76 /**</span>
 <span class="s0">* Returns true if the current object is the indicated type exactly.</span>
 <span class="s0">*/ 2 4 this 3 148  6 handle 1 127  </span>
<span class="s0">55 0 0 7 78 127 85 0 0 0 </span>
<span class="s0">34</span>
<span class="s0">116 15 NeverFreeMemory 0 141313 15 NeverFreeMemory 15 NeverFreeMemory 0 0 0 0 59 0 3 56 57 58 0 0 0 0 0 505</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used to allocate bytes of memory from a pool that is never</span>
 <span class="s0">* intended to be freed.  It is particularly useful to support DeletedChain,</span>
 <span class="s0">* which allocates memory in just such a fashion.</span>
 <span class="s0">*</span>
 <span class="s0">* When it is known that memory will not be freed, it is preferable to use</span>
 <span class="s0">* this instead of the standard malloc() (or global_operator_new()) call,</span>
 <span class="s0">* since this will help reduce fragmentation problems in the dynamic heap.</span>
 <span class="s0">* Also, memory allocated from here will exhibit less wasted space.</span>
 <span class="s0">*/</span>

<span class="s0">117 10 TypeHandle 0 16918529 10 TypeHandle 10 TypeHandle 0 0 0 1 60 85 4 151 152 153 154 23 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 0 1 84 0 0 1 118 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">118 11 MemoryClass 0 794624 23 TypeHandle::MemoryClass 23 TypeHandle::MemoryClass 117 0 0 0 0 0 0 0 0 0 5 12 MC_singleton 24 TypeHandle::MC_singleton 0</span>
<span class="s0">0 8 MC_array 20 TypeHandle::MC_array 0</span>
<span class="s0">1 23 MC_deleted_chain_active 35 TypeHandle::MC_deleted_chain_active 0</span>
<span class="s0">2 25 MC_deleted_chain_inactive 37 TypeHandle::MC_deleted_chain_inactive 0</span>
<span class="s0">3 8 MC_limit 20 TypeHandle::MC_limit 70</span>
<span class="s0">// Not a real value, just a placeholder for the maximum</span>
<span class="s0">// enum value.</span>
<span class="s0">4 0 0</span>

<span class="s0">119 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">120 6 string 0 2105344 11 std::string 11 std::string 0 0 121 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">121 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">122 12 TypeRegistry 0 141313 12 TypeRegistry 12 TypeRegistry 0 0 0 1 106 107 2 155 156 20 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 2 158 159 0 1 0 123 0 0 0 0 324</span>
<span class="s0">/**</span>
 <span class="s0">* The TypeRegistry class maintains all the assigned TypeHandles in a given</span>
 <span class="s0">* system.  There should be only one TypeRegistry class during the lifetime of</span>
 <span class="s0">* the application.  It will be created on the local heap initially, and it</span>
 <span class="s0">* should be migrated to shared memory as soon as shared memory becomes</span>
 <span class="s0">* available.</span>
 <span class="s0">*/</span>

<span class="s0">123 10 MemoryBase 0 1050624 10 MemoryBase 10 MemoryBase 0 0 0 0 0 0 0 0 0 0 0 0 428</span>
<span class="s0">/**</span>
 <span class="s0">* This class is intended to be the base class of all objects in Panda that</span>
 <span class="s0">* might be allocated and deleted via the new and delete operators.  It</span>
 <span class="s0">* redefines these operators to provide some memory tracking support.</span>
 <span class="s0">*</span>
 <span class="s0">* We used to try to override the global operator new and delete methods, but</span>
 <span class="s0">* that seems to cause problems when including header files for C++-based</span>
 <span class="s0">* system libraries (such as are found on OSX).</span>
 <span class="s0">*/</span>

<span class="s0">124 11 TypedObject 0 26625 11 TypedObject 11 TypedObject 0 0 0 0 110 1 157 5 111 112 113 114 115 0 0 1 3 123 108 109 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">125 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 126 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">126 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">127 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 117 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">128 18 TypeHandle const * 0 8576 18 TypeHandle const * 18 TypeHandle const * 0 0 129 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">129 16 TypeHandle const 0 8832 16 TypeHandle const 16 TypeHandle const 0 0 117 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">130 14 PyTypeObject * 0 8576 14 PyTypeObject * 14 PyTypeObject * 0 0 131 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">131 12 PyTypeObject 0 2105344 12 PyTypeObject 12 PyTypeObject 0 0 132 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">132 11 _typeobject 0 1024 11 _typeobject 11 _typeobject 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">133 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">134 13 TypedObject * 0 8576 13 TypedObject * 13 TypedObject * 0 0 124 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">135 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">136 18 set&lt; int &gt; const * 0 8576 18 set&lt; int &gt; const * 18 set&lt; int &gt; const * 0 0 137 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">137 16 set&lt; int &gt; const 0 8832 16 set&lt; int &gt; const 16 set&lt; int &gt; const 0 0 138 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">138 10 set&lt; int &gt; 0 2048 10 set&lt; int &gt; 10 set&lt; int &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">139 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">140 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 141 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">141 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">142 20 TypeRegistry const * 0 8576 20 TypeRegistry const * 20 TypeRegistry const * 0 0 143 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">143 18 TypeRegistry const 0 8832 18 TypeRegistry const 18 TypeRegistry const 0 0 122 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">144 14 TypeRegistry * 0 8576 14 TypeRegistry * 14 TypeRegistry * 0 0 122 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">145 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 146 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">146 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 147 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">147 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">148 19 TypedObject const * 0 8576 19 TypedObject const * 19 TypedObject const * 0 0 149 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">149 17 TypedObject const 0 8832 17 TypedObject const 17 TypedObject const 0 0 124 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1</span>
<span class="s0">150 11 END_PUBLISH 0 0 0 0 0 13 __end_publish </span>
<span class="s0">7</span>
<span class="s0">151 5 index 0 2 119 81 0 0 0 0 0 0 0 17 TypeHandle::index 0</span>

<span class="s0">152 4 name 0 2 120 70 0 0 0 0 0 0 0 16 TypeHandle::name 0</span>

<span class="s0">153 14 parent_classes 0 66 117 73 0 0 0 0 72 0 0 26 TypeHandle::parent_classes 0</span>

<span class="s0">154 13 child_classes 0 66 117 75 0 0 0 0 74 0 0 25 TypeHandle::child_classes 0</span>

<span class="s0">155 11 typehandles 0 66 117 95 0 0 0 0 94 0 0 25 TypeRegistry::typehandles 0</span>

<span class="s0">156 12 root_classes 0 66 117 97 0 0 0 0 96 0 0 26 TypeRegistry::root_classes 0</span>

<span class="s0">157 4 type 0 2 117 111 0 0 0 0 0 0 0 17 TypedObject::type 58</span>
<span class="s0">// Returns the TypeHandle representing this object's type.</span>

<span class="s0">2</span>
<span class="s0">158 15 get_typehandles 0 94 95 29 TypeRegistry::get_typehandles 0</span>

<span class="s0">159 16 get_root_classes 0 96 97 30 TypeRegistry::get_root_classes 0</span>

</pre>
</body>
</html>