<html>
<head>
<title>FreezeTool.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
FreezeTool.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; This module contains code to freeze a number of Python modules 
into a single (mostly) standalone DLL or EXE. &quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">modulefinder</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">marshal</span>
<span class="s2">import </span><span class="s1">imp</span>
<span class="s2">import </span><span class="s1">platform</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">distutils</span><span class="s3">.</span><span class="s1">sysconfig </span><span class="s2">as </span><span class="s1">sysconf</span>
<span class="s2">import </span><span class="s1">zipfile</span>
<span class="s2">import </span><span class="s1">importlib</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">pefile</span>

<span class="s4"># Temporary (?) try..except to protect against unbuilt p3extend_frozen.</span>
<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">p3extend_frozen</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s1">p3extend_frozen </span><span class="s3">= </span><span class="s2">None</span>

<span class="s2">from </span><span class="s1">panda3d</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s3">*</span>

<span class="s4"># Check to see if we are running python_d, which implies we have a</span>
<span class="s4"># debug build, and we have to build the module with debug options.</span>
<span class="s4"># This is only relevant on Windows.</span>

<span class="s4"># I wonder if there's a better way to determine this?</span>
<span class="s1">python </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">splitext</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">executable</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">])[</span><span class="s5">0</span><span class="s3">]</span>
<span class="s1">isDebugBuild </span><span class="s3">= (</span><span class="s1">python</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">().</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'_d'</span><span class="s3">))</span>

<span class="s4"># These are modules that Python always tries to import up-front.  They</span>
<span class="s4"># must be frozen in any main.exe.</span>
<span class="s4"># NB. if encodings are removed, be sure to remove them from the shortcut in</span>
<span class="s4"># deploy-stub.c.</span>
<span class="s1">startupModules </span><span class="s3">= [</span>
    <span class="s6">'imp'</span><span class="s3">, </span><span class="s6">'encodings'</span><span class="s3">, </span><span class="s6">'encodings.*'</span><span class="s3">,</span>
<span class="s3">]</span>
<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
    <span class="s4"># Modules specific to Python 3</span>
    <span class="s1">startupModules </span><span class="s3">+= [</span><span class="s6">'io'</span><span class="s3">, </span><span class="s6">'marshal'</span><span class="s3">, </span><span class="s6">'importlib.machinery'</span><span class="s3">, </span><span class="s6">'importlib.util'</span><span class="s3">]</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s4"># Modules specific to Python 2</span>
    <span class="s1">startupModules </span><span class="s3">+= []</span>

<span class="s4"># These are some special init functions for some built-in Python modules that</span>
<span class="s4"># deviate from the standard naming convention.  A value of None means that a</span>
<span class="s4"># dummy entry should be written to the inittab.</span>
<span class="s1">builtinInitFuncs </span><span class="s3">= {</span>
    <span class="s6">'builtins'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s6">'__builtin__'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s6">'sys'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s6">'exceptions'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s6">'_warnings'</span><span class="s3">: </span><span class="s6">'_PyWarnings_Init'</span><span class="s3">,</span>
    <span class="s6">'marshal'</span><span class="s3">: </span><span class="s6">'PyMarshal_Init'</span><span class="s3">,</span>
<span class="s3">}</span>
<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s3">):</span>
    <span class="s1">builtinInitFuncs</span><span class="s3">[</span><span class="s6">'_imp'</span><span class="s3">] = </span><span class="s6">'PyInit_imp'</span>

<span class="s4"># These are modules that are not found normally for these modules. Add them</span>
<span class="s4"># to an include list so users do not have to do this manually.</span>
<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">freeze_includes </span><span class="s2">as </span><span class="s1">pytest_imports</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">pytest_imports</span><span class="s3">():</span>
        <span class="s2">return </span><span class="s3">[]</span>

<span class="s1">hiddenImports </span><span class="s3">= {</span>
    <span class="s6">'pytest'</span><span class="s3">: </span><span class="s1">pytest_imports</span><span class="s3">(),</span>
    <span class="s6">'pkg_resources'</span><span class="s3">: [</span>
        <span class="s6">'pkg_resources.*.*'</span><span class="s3">,</span>
    <span class="s3">],</span>
    <span class="s6">'xml.etree.cElementTree'</span><span class="s3">: [</span><span class="s6">'xml.etree.ElementTree'</span><span class="s3">],</span>
    <span class="s6">'datetime'</span><span class="s3">: [</span><span class="s6">'_strptime'</span><span class="s3">],</span>
    <span class="s6">'keyring.backends'</span><span class="s3">: [</span><span class="s6">'keyring.backends.*'</span><span class="s3">],</span>
    <span class="s6">'matplotlib.font_manager'</span><span class="s3">: [</span><span class="s6">'encodings.mac_roman'</span><span class="s3">],</span>
    <span class="s6">'direct.particles'</span><span class="s3">: [</span><span class="s6">'direct.particles.ParticleManagerGlobal'</span><span class="s3">],</span>
    <span class="s6">'numpy.core._multiarray_umath'</span><span class="s3">: [</span>
        <span class="s6">'numpy.core._internal'</span><span class="s3">,</span>
        <span class="s6">'numpy.core._dtype_ctypes'</span><span class="s3">,</span>
        <span class="s6">'numpy.core._methods'</span><span class="s3">,</span>
    <span class="s3">],</span>
    <span class="s6">'pandas.compat'</span><span class="s3">: [</span><span class="s6">'lzma'</span><span class="s3">, </span><span class="s6">'cmath'</span><span class="s3">],</span>
    <span class="s6">'pandas._libs.tslibs.conversion'</span><span class="s3">: [</span><span class="s6">'pandas._libs.tslibs.base'</span><span class="s3">],</span>
    <span class="s6">'scipy.linalg'</span><span class="s3">: [</span><span class="s6">'scipy.linalg.cython_blas'</span><span class="s3">, </span><span class="s6">'scipy.linalg.cython_lapack'</span><span class="s3">],</span>
    <span class="s6">'scipy.sparse.csgraph'</span><span class="s3">: [</span><span class="s6">'scipy.sparse.csgraph._validation'</span><span class="s3">],</span>
    <span class="s6">'scipy.spatial._qhull'</span><span class="s3">: [</span><span class="s6">'scipy._lib.messagestream'</span><span class="s3">],</span>
    <span class="s6">'scipy.spatial.transform._rotation'</span><span class="s3">: [</span><span class="s6">'scipy.spatial.transform._rotation_groups'</span><span class="s3">],</span>
    <span class="s6">'scipy.special._ufuncs'</span><span class="s3">: [</span><span class="s6">'scipy.special._ufuncs_cxx'</span><span class="s3">],</span>
    <span class="s6">'scipy.stats._stats'</span><span class="s3">: [</span><span class="s6">'scipy.special.cython_special'</span><span class="s3">],</span>
<span class="s3">}</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">,):</span>
    <span class="s1">hiddenImports</span><span class="s3">[</span><span class="s6">'matplotlib.backends._backend_tk'</span><span class="s3">] = [</span><span class="s6">'tkinter'</span><span class="s3">]</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s1">hiddenImports</span><span class="s3">[</span><span class="s6">'matplotlib.backends._backend_tk'</span><span class="s3">] = [</span><span class="s6">'Tkinter'</span><span class="s3">]</span>


<span class="s4"># These are modules that import other modules but shouldn't pick them up as</span>
<span class="s4"># dependencies (usually because they are optional).  This prevents picking up</span>
<span class="s4"># unwanted dependencies.</span>
<span class="s1">ignoreImports </span><span class="s3">= {</span>
    <span class="s6">'direct.showbase.PythonUtil'</span><span class="s3">: [</span><span class="s6">'pstats'</span><span class="s3">, </span><span class="s6">'profile'</span><span class="s3">],</span>

    <span class="s6">'toml.encoder'</span><span class="s3">: [</span><span class="s6">'numpy'</span><span class="s3">],</span>
<span class="s3">}</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">8</span><span class="s3">):</span>
    <span class="s4"># importlib.metadata is a &quot;provisional&quot; module introduced in Python 3.8 that</span>
    <span class="s4"># conditionally pulls in dependency-rich packages like &quot;email&quot; and &quot;pep517&quot;</span>
    <span class="s4"># (the latter of which is a thirdparty package!)  But it's only imported in</span>
    <span class="s4"># one obscure corner, so we don't want to pull it in by default.</span>
    <span class="s1">ignoreImports</span><span class="s3">[</span><span class="s6">'importlib._bootstrap_external'</span><span class="s3">] = [</span><span class="s6">'importlib.metadata'</span><span class="s3">]</span>
    <span class="s1">ignoreImports</span><span class="s3">[</span><span class="s6">'importlib.metadata'</span><span class="s3">] = [</span><span class="s6">'pep517'</span><span class="s3">]</span>

<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
    <span class="s4"># Include everything that we know conditionally imports the &quot;builtins&quot;</span>
    <span class="s4"># module in Python 3 only, because otherwise it would cause the Python 2.7</span>
    <span class="s4"># package &quot;builtins&quot; to be included as a dependency.</span>
    <span class="s1">ignoreImports</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span>
        <span class="s6">'direct.p3d.AppRunner'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ContainerLeakDetector'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.LeakDetectors'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.MessengerLeakDetector'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ObjectReport'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ProfileSession'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.PythonUtil'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">] + </span><span class="s1">ignoreImports</span><span class="s3">[</span><span class="s6">'direct.showbase.PythonUtil'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ShowBase'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ShowBaseGlobal'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.TkGlobal'</span><span class="s3">: [</span><span class="s6">'tkinter'</span><span class="s3">],</span>
        <span class="s6">'direct.tkpanels.TaskManagerPanel'</span><span class="s3">: [</span><span class="s6">'tkinter'</span><span class="s3">],</span>
        <span class="s6">'direct.tkwidgets.WidgetPropertiesDialog'</span><span class="s3">: [</span><span class="s6">'tkinter'</span><span class="s3">],</span>
        <span class="s6">'py._builtin'</span><span class="s3">: [</span><span class="s6">'builtins'</span><span class="s3">],</span>
    <span class="s3">})</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s4"># And ignore attempts to conditionally import __builtin__ in Python 3,</span>
    <span class="s4"># suppressing a warning message.</span>
    <span class="s1">ignoreImports</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span>
        <span class="s6">'direct.directtools.DirectSession'</span><span class="s3">: [</span><span class="s6">'tkSimpleDialog'</span><span class="s3">],</span>
        <span class="s6">'direct.p3d.AppRunner'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ContainerLeakDetector'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.LeakDetectors'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.MessengerLeakDetector'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ObjectReport'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ProfileSession'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.PythonUtil'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">] + </span><span class="s1">ignoreImports</span><span class="s3">[</span><span class="s6">'direct.showbase.PythonUtil'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ShowBase'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.ShowBaseGlobal'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
        <span class="s6">'direct.showbase.TkGlobal'</span><span class="s3">: [</span><span class="s6">'Tkinter'</span><span class="s3">],</span>
        <span class="s6">'direct.tkpanels.AnimPanel'</span><span class="s3">: [</span><span class="s6">'tkFileDialog'</span><span class="s3">, </span><span class="s6">'tkSimpleDialog'</span><span class="s3">],</span>
        <span class="s6">'direct.tkpanels.FSMInspector'</span><span class="s3">: [</span><span class="s6">'tkSimpleDialog'</span><span class="s3">],</span>
        <span class="s6">'direct.tkpanels.MopathRecorder'</span><span class="s3">: [</span><span class="s6">'tkFileDialog'</span><span class="s3">],</span>
        <span class="s6">'direct.tkpanels.ParticlePanel'</span><span class="s3">: [</span><span class="s6">'tkFileDialog'</span><span class="s3">, </span><span class="s6">'tkSimpleDialog'</span><span class="s3">],</span>
        <span class="s6">'direct.tkpanels.TaskManagerPanel'</span><span class="s3">: [</span><span class="s6">'Tkinter'</span><span class="s3">],</span>
        <span class="s6">'direct.tkwidgets.AppShell'</span><span class="s3">: [</span><span class="s6">'tkFileDialog'</span><span class="s3">],</span>
        <span class="s6">'direct.tkwidgets.EntryScale'</span><span class="s3">: [</span><span class="s6">'tkColorChooser'</span><span class="s3">, </span><span class="s6">'tkSimpleDialog'</span><span class="s3">],</span>
        <span class="s6">'direct.tkwidgets.Valuator'</span><span class="s3">: [</span><span class="s6">'tkColorChooser'</span><span class="s3">],</span>
        <span class="s6">'direct.tkwidgets.VectorWidgets'</span><span class="s3">: [</span><span class="s6">'tkColorChooser'</span><span class="s3">],</span>
        <span class="s6">'direct.tkwidgets.WidgetPropertiesDialog'</span><span class="s3">: [</span><span class="s6">'Tkinter'</span><span class="s3">],</span>
        <span class="s6">'py._builtin'</span><span class="s3">: [</span><span class="s6">'__builtin__'</span><span class="s3">],</span>
    <span class="s3">})</span>


<span class="s4"># These are overrides for specific modules.</span>
<span class="s1">overrideModules </span><span class="s3">= {</span>
    <span class="s4"># Used by the warnings module, among others, to get line numbers.  Since</span>
    <span class="s4"># we set __file__, this would cause it to try and extract Python code</span>
    <span class="s4"># lines from the main executable, which we don't want.</span>
    <span class="s6">'linecache'</span><span class="s3">: </span><span class="s6">&quot;&quot;&quot;__all__ = [&quot;getline&quot;, &quot;clearcache&quot;, &quot;checkcache&quot;, &quot;lazycache&quot;] 
 
cache = {} 
 
def getline(filename, lineno, module_globals=None): 
    return '' 
 
def clearcache(): 
    global cache 
    cache = {} 
 
def getlines(filename, module_globals=None): 
    return [] 
 
def checkcache(filename=None): 
    pass 
 
def updatecache(filename, module_globals=None): 
    pass 
 
def lazycache(filename, module_globals): 
    pass 
&quot;&quot;&quot;</span><span class="s3">,</span>
<span class="s3">}</span>

<span class="s4"># These are missing modules that we've reported already this session.</span>
<span class="s1">reportedMissing </span><span class="s3">= {}</span>


<span class="s2">class </span><span class="s1">CompilationEnvironment</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; Create an instance of this class to record the commands to 
    invoke the compiler on a given platform.  If needed, the caller 
    can create a custom instance of this class (or simply set the 
    compile strings directly) to customize the build environment. &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">platform</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">= </span><span class="s1">platform</span>

        <span class="s4"># The command to compile a c to an object file.  Replace %(basename)s</span>
        <span class="s4"># with the basename of the source file, and an implicit .c extension.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObj </span><span class="s3">= </span><span class="s6">'error'</span>

        <span class="s4"># The command to link a single object file into an executable.  As</span>
        <span class="s4"># above, replace $(basename)s with the basename of the original source</span>
        <span class="s4"># file, and of the target executable.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">linkExe </span><span class="s3">= </span><span class="s6">'error'</span>

        <span class="s4"># The command to link a single object file into a shared library.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">linkDll </span><span class="s3">= </span><span class="s6">'error'</span>

        <span class="s4"># Paths to Python stuff.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Python </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">PythonIPath </span><span class="s3">= </span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">get_python_inc</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">PythonVersion </span><span class="s3">= </span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">get_config_var</span><span class="s3">(</span><span class="s6">&quot;LDVERSION&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">get_python_version</span><span class="s3">()</span>

        <span class="s4"># The VC directory of Microsoft Visual Studio (if relevant)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s4"># Directory to Windows Platform SDK (if relevant)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s4"># The setting to control release vs. debug builds.  Only relevant on</span>
        <span class="s4"># Windows.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">MD </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s4"># Added to the path to the MSVC bin and lib directories on 64-bits Windows.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">suffix64 </span><span class="s3">= </span><span class="s6">''</span>

        <span class="s4"># The _d extension to add to dll filenames on Windows in debug builds.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dllext </span><span class="s3">= </span><span class="s6">''</span>

        <span class="s4"># Any architecture-specific string.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">arch </span><span class="s3">= </span><span class="s6">''</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">determineStandardSetup</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">determineStandardSetup</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'win'</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">Python </span><span class="s3">= </span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">PREFIX</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s6">'VCINSTALLDIR' </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s6">'VCINSTALLDIR'</span><span class="s3">]</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">Filename</span><span class="s3">(</span><span class="s6">'/c/Program Files/Microsoft Visual Studio 9.0/VC'</span><span class="s3">).</span><span class="s1">exists</span><span class="s3">()):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">(</span><span class="s6">'/c/Program Files/Microsoft Visual Studio 9.0/VC'</span><span class="s3">).</span><span class="s1">toOsSpecific</span><span class="s3">()</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">Filename</span><span class="s3">(</span><span class="s6">'/c/Program Files (x86)/Microsoft Visual Studio 9.0/VC'</span><span class="s3">).</span><span class="s1">exists</span><span class="s3">()):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">(</span><span class="s6">'/c/Program Files (x86)/Microsoft Visual Studio 9.0/VC'</span><span class="s3">).</span><span class="s1">toOsSpecific</span><span class="s3">()</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">Filename</span><span class="s3">(</span><span class="s6">'/c/Program Files/Microsoft Visual Studio .NET 2003/Vc7'</span><span class="s3">).</span><span class="s1">exists</span><span class="s3">()):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">(</span><span class="s6">'/c/Program Files/Microsoft Visual Studio .NET 2003/Vc7'</span><span class="s3">).</span><span class="s1">toOsSpecific</span><span class="s3">()</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s6">'Could not locate Microsoft Visual C++ Compiler! Try running from the Visual Studio Command Prompt.'</span><span class="s3">)</span>
                <span class="s1">sys</span><span class="s3">.</span><span class="s1">exit</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s6">'WindowsSdkDir' </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s6">'WindowsSdkDir'</span><span class="s3">]</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">architecture</span><span class="s3">()[</span><span class="s5">0</span><span class="s3">] == </span><span class="s6">'32bit' </span><span class="s2">and </span><span class="s1">Filename</span><span class="s3">(</span><span class="s6">'/c/Program Files/Microsoft Platform SDK for Windows Server 2003 R2'</span><span class="s3">).</span><span class="s1">exists</span><span class="s3">()):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">(</span><span class="s6">'/c/Program Files/Microsoft Platform SDK for Windows Server 2003 R2'</span><span class="s3">).</span><span class="s1">toOsSpecific</span><span class="s3">()</span>
            <span class="s2">elif </span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC</span><span class="s3">, </span><span class="s6">'PlatformSDK'</span><span class="s3">))):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC</span><span class="s3">, </span><span class="s6">'PlatformSDK'</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s6">'Could not locate the Microsoft Windows Platform SDK! Try running from the Visual Studio Command Prompt.'</span><span class="s3">)</span>
                <span class="s1">sys</span><span class="s3">.</span><span class="s1">exit</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>

            <span class="s4"># We need to use the correct compiler setting for debug vs. release builds.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">MD </span><span class="s3">= </span><span class="s6">'/MD'</span>
            <span class="s2">if </span><span class="s1">isDebugBuild</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">MD </span><span class="s3">= </span><span class="s6">'/MDd'</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">dllext </span><span class="s3">= </span><span class="s6">'_d'</span>

            <span class="s4"># MSVC/bin and /lib directories have a different location</span>
            <span class="s4"># for win64.</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s6">'win_amd64'</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">suffix64 </span><span class="s3">= </span><span class="s6">'</span><span class="s2">\\</span><span class="s6">amd64'</span>

            <span class="s4"># If it is run by makepanda, it handles the MSVC and PlatformSDK paths itself.</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s6">'MAKEPANDA' </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjExe </span><span class="s3">= </span><span class="s6">'cl /wd4996 /Fo%(basename)s.obj /nologo /c %(MD)s /Zi /O2 /Ob2 /EHsc /Zm300 /W3 /I&quot;%(pythonIPath)s&quot; %(filename)s'</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjDll </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjExe</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">linkExe </span><span class="s3">= </span><span class="s6">'link /nologo /MAP:NUL /FIXED:NO /OPT:REF /STACK:4194304 /INCREMENTAL:NO /LIBPATH:&quot;%(python)s</span><span class="s2">\\</span><span class="s6">libs&quot;  /out:%(basename)s.exe %(basename)s.obj'</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">linkDll </span><span class="s3">= </span><span class="s6">'link /nologo /DLL /MAP:NUL /FIXED:NO /OPT:REF /INCREMENTAL:NO /LIBPATH:&quot;%(python)s</span><span class="s2">\\</span><span class="s6">libs&quot;  /out:%(basename)s%(dllext)s.pyd %(basename)s.obj'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s6">'PATH'</span><span class="s3">] += </span><span class="s6">';' </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC </span><span class="s3">+ </span><span class="s6">'</span><span class="s2">\\</span><span class="s6">bin' </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">suffix64 </span><span class="s3">+ </span><span class="s6">';' </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC </span><span class="s3">+ </span><span class="s6">'</span><span class="s2">\\</span><span class="s6">Common7</span><span class="s2">\\</span><span class="s6">IDE;' </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK </span><span class="s3">+ </span><span class="s6">'</span><span class="s2">\\</span><span class="s6">bin'</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjExe </span><span class="s3">= </span><span class="s6">'cl /wd4996 /Fo%(basename)s.obj /nologo /c %(MD)s /Zi /O2 /Ob2 /EHsc /Zm300 /W3 /I&quot;%(pythonIPath)s&quot; /I&quot;%(PSDK)s</span><span class="s2">\\</span><span class="s6">include&quot; /I&quot;%(MSVC)s</span><span class="s2">\\</span><span class="s6">include&quot; %(filename)s'</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjDll </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjExe</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">linkExe </span><span class="s3">= </span><span class="s6">'link /nologo /MAP:NUL /FIXED:NO /OPT:REF /STACK:4194304 /INCREMENTAL:NO /LIBPATH:&quot;%(PSDK)s</span><span class="s2">\\</span><span class="s6">lib&quot; /LIBPATH:&quot;%(MSVC)s</span><span class="s2">\\</span><span class="s6">lib%(suffix64)s&quot; /LIBPATH:&quot;%(python)s</span><span class="s2">\\</span><span class="s6">libs&quot;  /out:%(basename)s.exe %(basename)s.obj'</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">linkDll </span><span class="s3">= </span><span class="s6">'link /nologo /DLL /MAP:NUL /FIXED:NO /OPT:REF /INCREMENTAL:NO /LIBPATH:&quot;%(PSDK)s</span><span class="s2">\\</span><span class="s6">lib&quot; /LIBPATH:&quot;%(MSVC)s</span><span class="s2">\\</span><span class="s6">lib%(suffix64)s&quot; /LIBPATH:&quot;%(python)s</span><span class="s2">\\</span><span class="s6">libs&quot;  /out:%(basename)s%(dllext)s.pyd %(basename)s.obj'</span>

        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'osx_'</span><span class="s3">):</span>
            <span class="s4"># macOS</span>
            <span class="s1">proc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'_'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">proc </span><span class="s3">== </span><span class="s6">'i386'</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">arch </span><span class="s3">= </span><span class="s6">'-arch i386'</span>
            <span class="s2">elif </span><span class="s1">proc </span><span class="s3">== </span><span class="s6">'ppc'</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">arch </span><span class="s3">= </span><span class="s6">'-arch ppc'</span>
            <span class="s2">elif </span><span class="s1">proc </span><span class="s3">== </span><span class="s6">'amd64'</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">arch </span><span class="s3">= </span><span class="s6">'-arch x86_64'</span>
            <span class="s2">elif </span><span class="s1">proc </span><span class="s2">in </span><span class="s3">(</span><span class="s6">'arm64'</span><span class="s3">, </span><span class="s6">'aarch64'</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">arch </span><span class="s3">= </span><span class="s6">'-arch arm64'</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjExe </span><span class="s3">= </span><span class="s6">&quot;gcc -c %(arch)s -o %(basename)s.o -O2 -I%(pythonIPath)s %(filename)s&quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjDll </span><span class="s3">= </span><span class="s6">&quot;gcc -fPIC -c %(arch)s -o %(basename)s.o -O2 -I%(pythonIPath)s %(filename)s&quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">linkExe </span><span class="s3">= </span><span class="s6">&quot;gcc %(arch)s -o %(basename)s %(basename)s.o -framework Python&quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">linkDll </span><span class="s3">= </span><span class="s6">&quot;gcc %(arch)s -undefined dynamic_lookup -bundle -o %(basename)s.so %(basename)s.o&quot;</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># Unix</span>
            <span class="s1">lib_dir </span><span class="s3">= </span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">get_python_lib</span><span class="s3">(</span><span class="s1">plat_specific</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">standard_lib</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
            <span class="s4">#python_a = os.path.join(lib_dir, &quot;config&quot;, &quot;libpython%(pythonVersion)s.a&quot;)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjExe </span><span class="s3">= </span><span class="s6">&quot;%(CC)s %(CFLAGS)s -c -o %(basename)s.o -pthread -O2 %(filename)s -I%(pythonIPath)s&quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjDll </span><span class="s3">= </span><span class="s6">&quot;%(CC)s %(CFLAGS)s %(CCSHARED)s -c -o %(basename)s.o -O2 %(filename)s -I%(pythonIPath)s&quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">linkExe </span><span class="s3">= </span><span class="s6">&quot;%(CC)s -o %(basename)s %(basename)s.o -L/usr/local/lib -lpython%(pythonVersion)s&quot;</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">linkDll </span><span class="s3">= </span><span class="s6">&quot;%(LDSHARED)s -o %(basename)s.so %(basename)s.o -L/usr/local/lib -lpython%(pythonVersion)s&quot;</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s6">&quot;/usr/PCBSD/local/lib&quot;</span><span class="s3">)):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">linkExe </span><span class="s3">+= </span><span class="s6">&quot; -L/usr/PCBSD/local/lib&quot;</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">linkDll </span><span class="s3">+= </span><span class="s6">&quot; -L/usr/PCBSD/local/lib&quot;</span>

    <span class="s2">def </span><span class="s1">compileExe</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">, </span><span class="s1">extraLink</span><span class="s3">=[]):</span>
        <span class="s1">compile </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjExe </span><span class="s3">% </span><span class="s1">dict</span><span class="s3">({</span>
            <span class="s6">'python' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Python</span><span class="s3">,</span>
            <span class="s6">'MSVC' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC</span><span class="s3">,</span>
            <span class="s6">'PSDK' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK</span><span class="s3">,</span>
            <span class="s6">'suffix64' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">suffix64</span><span class="s3">,</span>
            <span class="s6">'MD' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">MD</span><span class="s3">,</span>
            <span class="s6">'pythonIPath' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PythonIPath</span><span class="s3">,</span>
            <span class="s6">'pythonVersion' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PythonVersion</span><span class="s3">,</span>
            <span class="s6">'arch' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arch</span><span class="s3">,</span>
            <span class="s6">'filename' </span><span class="s3">: </span><span class="s1">filename</span><span class="s3">,</span>
            <span class="s6">'basename' </span><span class="s3">: </span><span class="s1">basename</span><span class="s3">,</span>
            <span class="s3">}, **</span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">get_config_vars</span><span class="s3">())</span>
        <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">compile </span><span class="s3">+ </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">system</span><span class="s3">(</span><span class="s1">compile</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s6">'failed to compile %s.' </span><span class="s3">% </span><span class="s1">basename</span><span class="s3">)</span>

        <span class="s1">link </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">linkExe </span><span class="s3">% </span><span class="s1">dict</span><span class="s3">({</span>
            <span class="s6">'python' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Python</span><span class="s3">,</span>
            <span class="s6">'MSVC' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC</span><span class="s3">,</span>
            <span class="s6">'PSDK' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK</span><span class="s3">,</span>
            <span class="s6">'suffix64' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">suffix64</span><span class="s3">,</span>
            <span class="s6">'pythonIPath' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PythonIPath</span><span class="s3">,</span>
            <span class="s6">'pythonVersion' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PythonVersion</span><span class="s3">,</span>
            <span class="s6">'arch' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arch</span><span class="s3">,</span>
            <span class="s6">'filename' </span><span class="s3">: </span><span class="s1">filename</span><span class="s3">,</span>
            <span class="s6">'basename' </span><span class="s3">: </span><span class="s1">basename</span><span class="s3">,</span>
            <span class="s3">}, **</span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">get_config_vars</span><span class="s3">())</span>
        <span class="s1">link </span><span class="s3">+= </span><span class="s6">' ' </span><span class="s3">+ </span><span class="s6">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">extraLink</span><span class="s3">)</span>
        <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">link </span><span class="s3">+ </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">system</span><span class="s3">(</span><span class="s1">link</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s6">'failed to link %s.' </span><span class="s3">% </span><span class="s1">basename</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">compileDll</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">, </span><span class="s1">extraLink</span><span class="s3">=[]):</span>
        <span class="s1">compile </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compileObjDll </span><span class="s3">% </span><span class="s1">dict</span><span class="s3">({</span>
            <span class="s6">'python' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Python</span><span class="s3">,</span>
            <span class="s6">'MSVC' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC</span><span class="s3">,</span>
            <span class="s6">'PSDK' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK</span><span class="s3">,</span>
            <span class="s6">'suffix64' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">suffix64</span><span class="s3">,</span>
            <span class="s6">'MD' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">MD</span><span class="s3">,</span>
            <span class="s6">'pythonIPath' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PythonIPath</span><span class="s3">,</span>
            <span class="s6">'pythonVersion' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PythonVersion</span><span class="s3">,</span>
            <span class="s6">'arch' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arch</span><span class="s3">,</span>
            <span class="s6">'filename' </span><span class="s3">: </span><span class="s1">filename</span><span class="s3">,</span>
            <span class="s6">'basename' </span><span class="s3">: </span><span class="s1">basename</span><span class="s3">,</span>
            <span class="s3">}, **</span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">get_config_vars</span><span class="s3">())</span>
        <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">compile </span><span class="s3">+ </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">system</span><span class="s3">(</span><span class="s1">compile</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s6">'failed to compile %s.' </span><span class="s3">% </span><span class="s1">basename</span><span class="s3">)</span>

        <span class="s1">link </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">linkDll </span><span class="s3">% </span><span class="s1">dict</span><span class="s3">({</span>
            <span class="s6">'python' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Python</span><span class="s3">,</span>
            <span class="s6">'MSVC' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">MSVC</span><span class="s3">,</span>
            <span class="s6">'PSDK' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PSDK</span><span class="s3">,</span>
            <span class="s6">'suffix64' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">suffix64</span><span class="s3">,</span>
            <span class="s6">'pythonIPath' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PythonIPath</span><span class="s3">,</span>
            <span class="s6">'pythonVersion' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PythonVersion</span><span class="s3">,</span>
            <span class="s6">'arch' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">arch</span><span class="s3">,</span>
            <span class="s6">'filename' </span><span class="s3">: </span><span class="s1">filename</span><span class="s3">,</span>
            <span class="s6">'basename' </span><span class="s3">: </span><span class="s1">basename</span><span class="s3">,</span>
            <span class="s6">'dllext' </span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dllext</span><span class="s3">,</span>
            <span class="s3">}, **</span><span class="s1">sysconf</span><span class="s3">.</span><span class="s1">get_config_vars</span><span class="s3">())</span>
        <span class="s1">link </span><span class="s3">+= </span><span class="s6">' ' </span><span class="s3">+ </span><span class="s6">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">extraLink</span><span class="s3">)</span>
        <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">link </span><span class="s3">+ </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">system</span><span class="s3">(</span><span class="s1">link</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s6">'failed to link %s.' </span><span class="s3">% </span><span class="s1">basename</span><span class="s3">)</span>

<span class="s4"># The code from frozenmain.c in the Python source repository.</span>
<span class="s1">frozenMainCode </span><span class="s3">= </span><span class="s6">&quot;&quot;&quot; 
/* Python interpreter main program for frozen scripts */ 
 
#include &lt;Python.h&gt; 
 
#if PY_MAJOR_VERSION &gt;= 3 
#include &lt;locale.h&gt; 
 
#if PY_MINOR_VERSION &lt; 5 
#define Py_DecodeLocale _Py_char2wchar 
#endif 
#endif 
 
#ifdef MS_WINDOWS 
extern void PyWinFreeze_ExeInit(void); 
extern void PyWinFreeze_ExeTerm(void); 
 
extern PyAPI_FUNC(int) PyImport_ExtendInittab(struct _inittab *newtab); 
#endif 
 
/* Main program */ 
 
int 
Py_FrozenMain(int argc, char **argv) 
{ 
    char *p; 
    int n, sts = 1; 
    int inspect = 0; 
    int unbuffered = 0; 
 
#if PY_MAJOR_VERSION &gt;= 3 
    int i; 
    char *oldloc; 
    wchar_t **argv_copy = NULL; 
    /* We need a second copies, as Python might modify the first one. */ 
    wchar_t **argv_copy2 = NULL; 
 
    if (argc &gt; 0) { 
        argv_copy = (wchar_t **)alloca(sizeof(wchar_t *) * argc); 
        argv_copy2 = (wchar_t **)alloca(sizeof(wchar_t *) * argc); 
    } 
#endif 
 
    Py_FrozenFlag = 1; /* Suppress errors from getpath.c */ 
    Py_NoSiteFlag = 1; 
    Py_NoUserSiteDirectory = 1; 
 
    if ((p = Py_GETENV(&quot;PYTHONINSPECT&quot;)) &amp;&amp; *p != '</span><span class="s2">\\</span><span class="s6">0') 
        inspect = 1; 
    if ((p = Py_GETENV(&quot;PYTHONUNBUFFERED&quot;)) &amp;&amp; *p != '</span><span class="s2">\\</span><span class="s6">0') 
        unbuffered = 1; 
 
    if (unbuffered) { 
        setbuf(stdin, (char *)NULL); 
        setbuf(stdout, (char *)NULL); 
        setbuf(stderr, (char *)NULL); 
    } 
 
#if PY_MAJOR_VERSION &gt;= 3 
    oldloc = setlocale(LC_ALL, NULL); 
    setlocale(LC_ALL, </span><span class="s2">\&quot;\&quot;</span><span class="s6">); 
    for (i = 0; i &lt; argc; i++) { 
        argv_copy[i] = Py_DecodeLocale(argv[i], NULL); 
        argv_copy2[i] = argv_copy[i]; 
        if (!argv_copy[i]) { 
            fprintf(stderr, </span><span class="s2">\&quot;</span><span class="s6">Unable to decode the command line argument #%i</span><span class="s2">\\</span><span class="s6">n</span><span class="s2">\&quot;</span><span class="s6">, 
                            i + 1); 
            argc = i; 
            goto error; 
        } 
    } 
    setlocale(LC_ALL, oldloc); 
#endif 
 
#ifdef MS_WINDOWS 
    PyImport_ExtendInittab(extensions); 
#endif /* MS_WINDOWS */ 
 
    if (argc &gt;= 1) { 
#if PY_MAJOR_VERSION &gt;= 3 
        Py_SetProgramName(argv_copy[0]); 
#else 
        Py_SetProgramName(argv[0]); 
#endif 
    } 
 
    Py_Initialize(); 
#ifdef MS_WINDOWS 
    PyWinFreeze_ExeInit(); 
#endif 
 
    if (Py_VerboseFlag) 
        fprintf(stderr, &quot;Python %s</span><span class="s2">\\</span><span class="s6">n%s</span><span class="s2">\\</span><span class="s6">n&quot;, 
            Py_GetVersion(), Py_GetCopyright()); 
 
#if PY_MAJOR_VERSION &gt;= 3 
    PySys_SetArgv(argc, argv_copy); 
#else 
    PySys_SetArgv(argc, argv); 
#endif 
 
    n = PyImport_ImportFrozenModule(&quot;__main__&quot;); 
    if (n == 0) 
        Py_FatalError(&quot;__main__ not frozen&quot;); 
    if (n &lt; 0) { 
        PyErr_Print(); 
        sts = 1; 
    } 
    else 
        sts = 0; 
 
    if (inspect &amp;&amp; isatty((int)fileno(stdin))) 
        sts = PyRun_AnyFile(stdin, &quot;&lt;stdin&gt;&quot;) != 0; 
 
#ifdef MS_WINDOWS 
    PyWinFreeze_ExeTerm(); 
#endif 
    Py_Finalize(); 
 
#if PY_MAJOR_VERSION &gt;= 3 
error: 
    if (argv_copy2) { 
        for (i = 0; i &lt; argc; i++) { 
#if PY_MINOR_VERSION &gt;= 4 
            PyMem_RawFree(argv_copy2[i]); 
#else 
            PyMem_Free(argv_copy2[i]); 
#endif 
        } 
    } 
#endif 
    return sts; 
} 
&quot;&quot;&quot;</span>

<span class="s4"># The code from frozen_dllmain.c in the Python source repository.</span>
<span class="s4"># Windows only.</span>
<span class="s1">frozenDllMainCode </span><span class="s3">= </span><span class="s6">&quot;&quot;&quot; 
#include &lt;windows.h&gt; 
 
static char *possibleModules[] = { 
    &quot;pywintypes&quot;, 
    &quot;pythoncom&quot;, 
    &quot;win32ui&quot;, 
    NULL, 
}; 
 
BOOL CallModuleDllMain(char *modName, DWORD dwReason); 
 
 
/* 
  Called by a frozen .EXE only, so that built-in extension 
  modules are initialized correctly 
*/ 
void PyWinFreeze_ExeInit(void) 
{ 
    char **modName; 
    for (modName = possibleModules;*modName;*modName++) { 
/*      printf(&quot;Initialising '%s'</span><span class="s2">\\</span><span class="s6">n&quot;, *modName); */ 
        CallModuleDllMain(*modName, DLL_PROCESS_ATTACH); 
    } 
} 
 
/* 
  Called by a frozen .EXE only, so that built-in extension 
  modules are cleaned up 
*/ 
void PyWinFreeze_ExeTerm(void) 
{ 
    // Must go backwards 
    char **modName; 
    for (modName = possibleModules+(sizeof(possibleModules) / sizeof(char *))-2; 
         modName &gt;= possibleModules; 
         *modName--) { 
/*      printf(&quot;Terminating '%s'</span><span class="s2">\\</span><span class="s6">n&quot;, *modName);*/ 
        CallModuleDllMain(*modName, DLL_PROCESS_DETACH); 
    } 
} 
 
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) 
{ 
    BOOL ret = TRUE; 
    switch (dwReason) { 
        case DLL_PROCESS_ATTACH: 
        { 
            char **modName; 
            for (modName = possibleModules;*modName;*modName++) { 
                BOOL ok = CallModuleDllMain(*modName, dwReason); 
                if (!ok) 
                    ret = FALSE; 
            } 
            break; 
        } 
        case DLL_PROCESS_DETACH: 
        { 
            // Must go backwards 
            char **modName; 
            for (modName = possibleModules+(sizeof(possibleModules) / sizeof(char *))-2; 
                 modName &gt;= possibleModules; 
                 *modName--) 
                CallModuleDllMain(*modName, DLL_PROCESS_DETACH); 
            break; 
        } 
    } 
    return ret; 
} 
 
BOOL CallModuleDllMain(char *modName, DWORD dwReason) 
{ 
    BOOL (WINAPI * pfndllmain)(HINSTANCE, DWORD, LPVOID); 
 
    char funcName[255]; 
    HMODULE hmod = GetModuleHandle(NULL); 
    strcpy(funcName, &quot;_DllMain&quot;); 
    strcat(funcName, modName); 
    strcat(funcName, &quot;@12&quot;); // stdcall convention. 
    pfndllmain = (BOOL (WINAPI *)(HINSTANCE, DWORD, LPVOID))GetProcAddress(hmod, funcName); 
    if (pfndllmain==NULL) { 
        /* No function by that name exported - then that module does 
           not appear in our frozen program - return OK 
                */ 
        return TRUE; 
    } 
    return (*pfndllmain)(hmod, dwReason, NULL); 
} 
&quot;&quot;&quot;</span>

<span class="s4"># Our own glue code to start up a Python executable.</span>
<span class="s1">mainInitCode </span><span class="s3">= </span><span class="s6">&quot;&quot;&quot; 
%(frozenMainCode)s 
 
int 
main(int argc, char *argv[]) { 
  PyImport_FrozenModules = _PyImport_FrozenModules; 
  return Py_FrozenMain(argc, argv); 
} 
&quot;&quot;&quot;</span>

<span class="s4"># Our own glue code to start up a Python shared library.</span>
<span class="s1">dllInitCode </span><span class="s3">= </span><span class="s6">&quot;&quot;&quot; 
/* 
 * Call this function to extend the frozen modules array with a new 
 * array of frozen modules, provided in a C-style array, at runtime. 
 * Returns the total number of frozen modules. 
 */ 
static int 
extend_frozen_modules(const struct _frozen *new_modules, int new_count) { 
  int orig_count; 
  struct _frozen *realloc_FrozenModules; 
 
  /* First, count the number of frozen modules we had originally. */ 
  orig_count = 0; 
  while (PyImport_FrozenModules[orig_count].name != NULL) { 
    ++orig_count; 
  } 
 
  if (new_count == 0) { 
    /* Trivial no-op. */ 
    return orig_count; 
  } 
 
  /* Reallocate the PyImport_FrozenModules array bigger to make room 
     for the additional frozen modules.  We just leak the original 
     array; it's too risky to try to free it. */ 
  realloc_FrozenModules = (struct _frozen *)malloc((orig_count + new_count + 1) * sizeof(struct _frozen)); 
 
  /* The new frozen modules go at the front of the list. */ 
  memcpy(realloc_FrozenModules, new_modules, new_count * sizeof(struct _frozen)); 
 
  /* Then the original set of frozen modules. */ 
  memcpy(realloc_FrozenModules + new_count, PyImport_FrozenModules, orig_count * sizeof(struct _frozen)); 
 
  /* Finally, a single 0-valued entry marks the end of the array. */ 
  memset(realloc_FrozenModules + orig_count + new_count, 0, sizeof(struct _frozen)); 
 
  /* Assign the new pointer. */ 
  PyImport_FrozenModules = realloc_FrozenModules; 
 
  return orig_count + new_count; 
} 
 
#if PY_MAJOR_VERSION &gt;= 3 
static PyModuleDef mdef = { 
  PyModuleDef_HEAD_INIT, 
  &quot;%(moduleName)s&quot;, 
  &quot;&quot;, 
  -1, 
  NULL, NULL, NULL, NULL, NULL 
}; 
 
%(dllexport)sPyObject *PyInit_%(moduleName)s(void) { 
  extend_frozen_modules(_PyImport_FrozenModules, sizeof(_PyImport_FrozenModules) / sizeof(struct _frozen)); 
  return PyModule_Create(&amp;mdef); 
} 
#else 
static PyMethodDef nullMethods[] = { 
  {NULL, NULL} 
}; 
 
%(dllexport)svoid init%(moduleName)s(void) { 
  extend_frozen_modules(_PyImport_FrozenModules, sizeof(_PyImport_FrozenModules) / sizeof(struct _frozen)); 
  Py_InitModule(&quot;%(moduleName)s&quot;, nullMethods); 
} 
#endif 
&quot;&quot;&quot;</span>

<span class="s1">programFile </span><span class="s3">= </span><span class="s6">&quot;&quot;&quot; 
#include &lt;Python.h&gt; 
#ifdef _WIN32 
#include &lt;malloc.h&gt; 
#endif 
 
%(moduleDefs)s 
 
struct _frozen _PyImport_FrozenModules[] = { 
%(moduleList)s 
  {NULL, NULL, 0} 
}; 
&quot;&quot;&quot;</span>


<span class="s1">okMissing </span><span class="s3">= [</span>
    <span class="s6">'__main__'</span><span class="s3">, </span><span class="s6">'_dummy_threading'</span><span class="s3">, </span><span class="s6">'Carbon'</span><span class="s3">, </span><span class="s6">'Carbon.Files'</span><span class="s3">,</span>
    <span class="s6">'Carbon.Folder'</span><span class="s3">, </span><span class="s6">'Carbon.Folders'</span><span class="s3">, </span><span class="s6">'HouseGlobals'</span><span class="s3">, </span><span class="s6">'Carbon.File'</span><span class="s3">,</span>
    <span class="s6">'MacOS'</span><span class="s3">, </span><span class="s6">'_emx_link'</span><span class="s3">, </span><span class="s6">'ce'</span><span class="s3">, </span><span class="s6">'mac'</span><span class="s3">, </span><span class="s6">'org.python.core'</span><span class="s3">, </span><span class="s6">'os.path'</span><span class="s3">,</span>
    <span class="s6">'os2'</span><span class="s3">, </span><span class="s6">'posix'</span><span class="s3">, </span><span class="s6">'pwd'</span><span class="s3">, </span><span class="s6">'readline'</span><span class="s3">, </span><span class="s6">'riscos'</span><span class="s3">, </span><span class="s6">'riscosenviron'</span><span class="s3">,</span>
    <span class="s6">'riscospath'</span><span class="s3">, </span><span class="s6">'dbm'</span><span class="s3">, </span><span class="s6">'fcntl'</span><span class="s3">, </span><span class="s6">'win32api'</span><span class="s3">, </span><span class="s6">'win32pipe'</span><span class="s3">, </span><span class="s6">'usercustomize'</span><span class="s3">,</span>
    <span class="s6">'_winreg'</span><span class="s3">, </span><span class="s6">'winreg'</span><span class="s3">, </span><span class="s6">'ctypes'</span><span class="s3">, </span><span class="s6">'ctypes.wintypes'</span><span class="s3">, </span><span class="s6">'nt'</span><span class="s3">,</span><span class="s6">'msvcrt'</span><span class="s3">,</span>
    <span class="s6">'EasyDialogs'</span><span class="s3">, </span><span class="s6">'SOCKS'</span><span class="s3">, </span><span class="s6">'ic'</span><span class="s3">, </span><span class="s6">'rourl2path'</span><span class="s3">, </span><span class="s6">'termios'</span><span class="s3">, </span><span class="s6">'vms_lib'</span><span class="s3">,</span>
    <span class="s6">'OverrideFrom23._Res'</span><span class="s3">, </span><span class="s6">'email'</span><span class="s3">, </span><span class="s6">'email.Utils'</span><span class="s3">, </span><span class="s6">'email.Generator'</span><span class="s3">,</span>
    <span class="s6">'email.Iterators'</span><span class="s3">, </span><span class="s6">'_subprocess'</span><span class="s3">, </span><span class="s6">'gestalt'</span><span class="s3">, </span><span class="s6">'java.lang'</span><span class="s3">,</span>
    <span class="s6">'direct.extensions_native.extensions_darwin'</span><span class="s3">, </span><span class="s6">'_manylinux'</span><span class="s3">,</span>
    <span class="s6">'collections.Iterable'</span><span class="s3">, </span><span class="s6">'collections.Mapping'</span><span class="s3">, </span><span class="s6">'collections.MutableMapping'</span><span class="s3">,</span>
    <span class="s6">'collections.Sequence'</span><span class="s3">, </span><span class="s6">'numpy_distutils'</span><span class="s3">, </span><span class="s6">'_winapi'</span><span class="s3">,</span>
    <span class="s3">]</span>

<span class="s2">class </span><span class="s1">Freezer</span><span class="s3">:</span>
    <span class="s2">class </span><span class="s1">ModuleDef</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">filename </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
                     <span class="s1">implicit </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">guess </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
                     <span class="s1">exclude </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">forbid </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
                     <span class="s1">allowChildren </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">fromSource </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
                     <span class="s1">text </span><span class="s3">= </span><span class="s2">None</span><span class="s3">):</span>
            <span class="s4"># The Python module name.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">moduleName </span><span class="s3">= </span><span class="s1">moduleName</span>

            <span class="s4"># The file on disk it was loaded from, if any.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">filename </span><span class="s3">= </span><span class="s1">filename</span>
            <span class="s2">if </span><span class="s1">filename </span><span class="s2">is not None and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">Filename</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">filename </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">)</span>

            <span class="s4"># True if the module was found via the modulefinder.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">implicit </span><span class="s3">= </span><span class="s1">implicit</span>

            <span class="s4"># True if the moduleName might refer to some Python object</span>
            <span class="s4"># other than a module, in which case the module should be</span>
            <span class="s4"># ignored.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">guess </span><span class="s3">= </span><span class="s1">guess</span>

            <span class="s4"># True if the module should *not* be included in the</span>
            <span class="s4"># generated output.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">exclude </span><span class="s3">= </span><span class="s1">exclude</span>

            <span class="s4"># True if the module should never be allowed, even if it</span>
            <span class="s4"># exists at runtime.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">forbid </span><span class="s3">= </span><span class="s1">forbid</span>

            <span class="s4"># True if excluding the module still allows its children</span>
            <span class="s4"># to be included.  This only makes sense if the module</span>
            <span class="s4"># will exist at runtime through some other means</span>
            <span class="s4"># (e.g. from another package).</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">allowChildren </span><span class="s3">= </span><span class="s1">allowChildren</span>

            <span class="s4"># Additional black-box information about where this module</span>
            <span class="s4"># record came from, supplied by the caller.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">fromSource </span><span class="s3">= </span><span class="s1">fromSource</span>

            <span class="s4"># If this is set, it contains Python code of the module.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">text </span><span class="s3">= </span><span class="s1">text</span>

            <span class="s4"># Some sanity checks.</span>
            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">exclude</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">allowChildren </span><span class="s3">= </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">forbid</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">exclude </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">allowChildren </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s1">args </span><span class="s3">= [</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">), </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">)]</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">implicit</span><span class="s3">:</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s6">'implicit = True'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">guess</span><span class="s3">:</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s6">'guess = True'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">exclude</span><span class="s3">:</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s6">'exclude = True'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">forbid</span><span class="s3">:</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s6">'forbid = True'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">allowChildren</span><span class="s3">:</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s6">'allowChildren = True'</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s6">'ModuleDef(%s)' </span><span class="s3">% (</span><span class="s6">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">previous </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">debugLevel </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
                 <span class="s1">platform </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">path</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s4"># Normally, we are freezing for our own platform.  Change this</span>
        <span class="s4"># if untrue.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">= </span><span class="s1">platform </span><span class="s2">or </span><span class="s1">PandaSystem</span><span class="s3">.</span><span class="s1">getPlatform</span><span class="s3">()</span>

        <span class="s4"># This is the compilation environment.  Fill in your own</span>
        <span class="s4"># object here if you have custom needs (for instance, for a</span>
        <span class="s4"># cross-compiler or something).  If this is None, then a</span>
        <span class="s4"># default object will be created when it is needed.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">cenv </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s4"># This is the search path to use for Python modules.  Leave it</span>
        <span class="s4"># to the default value of None to use sys.path.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">path </span><span class="s3">= </span><span class="s1">path</span>

        <span class="s4"># The filename extension to append to the source file before</span>
        <span class="s4"># compiling.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sourceExtension </span><span class="s3">= </span><span class="s6">'.c'</span>

        <span class="s4"># The filename extension to append to the object file.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">objectExtension </span><span class="s3">= </span><span class="s6">'.o'</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'win'</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">objectExtension </span><span class="s3">= </span><span class="s6">'.obj'</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">keepTemporaryFiles </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s4"># Change any of these to change the generated startup and glue</span>
        <span class="s4"># code.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">frozenMainCode </span><span class="s3">= </span><span class="s1">frozenMainCode</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">frozenDllMainCode </span><span class="s3">= </span><span class="s1">frozenDllMainCode</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">mainInitCode </span><span class="s3">= </span><span class="s1">mainInitCode</span>

        <span class="s4"># Set this true to encode Python files in a Multifile as their</span>
        <span class="s4"># original source if possible, or false to encode them as</span>
        <span class="s4"># compiled pyc or pyo files.  This has no effect on frozen exe</span>
        <span class="s4"># or dll's; those are always stored with compiled code.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">storePythonSource </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s4"># This list will be filled in by generateCode() or</span>
        <span class="s4"># addToMultifile().  It contains a list of all the extension</span>
        <span class="s4"># modules that were discovered, which have not been added to</span>
        <span class="s4"># the output.  The list is a list of tuples of the form</span>
        <span class="s4"># (moduleName, filename).  filename will be None for built-in</span>
        <span class="s4"># modules.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">extras </span><span class="s3">= []</span>

        <span class="s4"># Set this to true if extension modules should be linked in to</span>
        <span class="s4"># the resulting executable.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">linkExtensionModules </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s4"># End of public interface.  These remaining members should not</span>
        <span class="s4"># be directly manipulated by callers.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">previousModules </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">modules </span><span class="s3">= {}</span>

        <span class="s2">if </span><span class="s1">previous</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">previousModules </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">previous</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modules </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">previous</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">)</span>

        <span class="s4"># Exclude doctest by default; it is not very useful in production</span>
        <span class="s4"># builds.  It can be explicitly included if desired.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s6">'doctest'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span><span class="s6">'doctest'</span><span class="s3">, </span><span class="s1">exclude </span><span class="s3">= </span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">mf </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">optimize </span><span class="s2">is None or </span><span class="s1">optimize </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">optimize </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">optimize</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">optimize </span><span class="s3">= </span><span class="s1">optimize</span>

        <span class="s4"># Actually, make sure we know how to find all of the</span>
        <span class="s4"># already-imported modules.  (Some of them might do their own</span>
        <span class="s4"># special path mangling.)</span>
        <span class="s2">for </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">module </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
            <span class="s2">if </span><span class="s1">module </span><span class="s2">and </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__path__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">path </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__path__'</span><span class="s3">))</span>
                <span class="s2">if </span><span class="s1">path</span><span class="s3">:</span>
                    <span class="s1">modulefinder</span><span class="s3">.</span><span class="s1">AddPackagePath</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">path</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

        <span class="s4"># Suffix/extension for Python C extension modules</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s1">PandaSystem</span><span class="s3">.</span><span class="s1">getPlatform</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes </span><span class="s3">= </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">get_suffixes</span><span class="s3">()</span>

            <span class="s4"># Set extension for Python files to binary mode</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">suffix </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">suffix</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] == </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PY_SOURCE</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = (</span><span class="s1">suffix</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PY_SOURCE</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes </span><span class="s3">= [(</span><span class="s6">'.py'</span><span class="s3">, </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (</span><span class="s6">'.pyc'</span><span class="s3">, </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)]</span>

            <span class="s1">abi_version </span><span class="s3">= </span><span class="s6">'{0}{1}'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(*</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info</span><span class="s3">)</span>
            <span class="s1">abi_flags </span><span class="s3">= </span><span class="s6">''</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">8</span><span class="s3">):</span>
                <span class="s1">abi_flags </span><span class="s3">+= </span><span class="s6">'m'</span>

            <span class="s2">if </span><span class="s6">'linux' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes </span><span class="s3">+= [</span>
                    <span class="s3">(</span><span class="s6">'.cpython-{0}{1}-x86_64-linux-gnu.so'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">abi_version</span><span class="s3">, </span><span class="s1">abi_flags</span><span class="s3">), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.cpython-{0}{1}-i686-linux-gnu.so'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">abi_version</span><span class="s3">, </span><span class="s1">abi_flags</span><span class="s3">), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.abi{0}.so'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.so'</span><span class="s3">, </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                <span class="s3">]</span>
            <span class="s2">elif </span><span class="s6">'win' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">:</span>
                <span class="s4"># ABI flags are not appended on Windows.</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes </span><span class="s3">+= [</span>
                    <span class="s3">(</span><span class="s6">'.cp{0}-win_amd64.pyd'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">abi_version</span><span class="s3">), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.cp{0}-win32.pyd'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">abi_version</span><span class="s3">), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.pyd'</span><span class="s3">, </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                <span class="s3">]</span>
            <span class="s2">elif </span><span class="s6">'mac' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes </span><span class="s3">+= [</span>
                    <span class="s3">(</span><span class="s6">'.cpython-{0}{1}-darwin.so'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">abi_version</span><span class="s3">, </span><span class="s1">abi_flags</span><span class="s3">), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.abi{0}.so'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.so'</span><span class="s3">, </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                <span class="s3">]</span>
            <span class="s2">else</span><span class="s3">: </span><span class="s4"># FreeBSD et al.</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes </span><span class="s3">+= [</span>
                    <span class="s3">(</span><span class="s6">'.cpython-{0}{1}.so'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">abi_version</span><span class="s3">, </span><span class="s1">abi_flags</span><span class="s3">), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.abi{0}.so'</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                    <span class="s3">(</span><span class="s6">'.so'</span><span class="s3">, </span><span class="s6">'rb'</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
                <span class="s3">]</span>

    <span class="s2">def </span><span class="s1">excludeFrom</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">freezer</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Excludes all modules that have already been processed by 
        the indicated FreezeTool.  This is equivalent to passing the 
        indicated FreezeTool object as previous to this object's 
        constructor, but it may be called at any point during 
        processing. &quot;&quot;&quot;</span>

        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">freezer</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">previousModules</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">excludeModule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">forbid </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">allowChildren </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
                      <span class="s1">fromSource </span><span class="s3">= </span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Adds a module to the list of modules not to be exported by 
        this tool.  If forbid is true, the module is furthermore 
        forbidden to be imported, even if it exists on disk.  If 
        allowChildren is true, the children of the indicated module 
        may still be included.&quot;&quot;&quot;</span>

        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf </span><span class="s2">is None</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">moduleName</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span>
            <span class="s1">moduleName</span><span class="s3">, </span><span class="s1">exclude </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">forbid </span><span class="s3">= </span><span class="s1">forbid</span><span class="s3">, </span><span class="s1">allowChildren </span><span class="s3">= </span><span class="s1">allowChildren</span><span class="s3">,</span>
            <span class="s1">fromSource </span><span class="s3">= </span><span class="s1">fromSource</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">handleCustomPath</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Indicates a module that may perform runtime manipulation 
        of its __path__ variable, and which must therefore be actually 
        imported at runtime in order to determine the true value of 
        __path__. &quot;&quot;&quot;</span>

        <span class="s1">str </span><span class="s3">= </span><span class="s6">'import %s' </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">)</span>
        <span class="s1">exec</span><span class="s3">(</span><span class="s1">str</span><span class="s3">)</span>

        <span class="s1">module </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">moduleName</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">module</span><span class="s3">.</span><span class="s1">__path__</span><span class="s3">:</span>
            <span class="s1">modulefinder</span><span class="s3">.</span><span class="s1">AddPackagePath</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">getModulePath</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Looks for the indicated directory module and returns the 
        __path__ member: the list of directories in which its python 
        files can be found.  If the module is a .py file and not a 
        directory, returns None. &quot;&quot;&quot;</span>

        <span class="s4"># First, try to import the module directly.  That's the most</span>
        <span class="s4"># reliable answer, if it works.</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">module </span><span class="s3">= </span><span class="s1">__import__</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">)</span>
        <span class="s2">except</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s6">&quot;couldn't import %s&quot; </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">))</span>
            <span class="s1">module </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">module </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">symbol </span><span class="s2">in </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">:]:</span>
                <span class="s1">module </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">symbol</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__path__'</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">module</span><span class="s3">.</span><span class="s1">__path__</span>

        <span class="s4"># If it didn't work--maybe the module is unimportable because</span>
        <span class="s4"># it makes certain assumptions about the builtins, or</span>
        <span class="s4"># whatever--then just look for file on disk.  That's usually</span>
        <span class="s4"># good enough.</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">baseName </span><span class="s3">= </span><span class="s1">moduleName</span>
        <span class="s2">if </span><span class="s6">'.' </span><span class="s2">in </span><span class="s1">baseName</span><span class="s3">:</span>
            <span class="s1">parentName</span><span class="s3">, </span><span class="s1">baseName </span><span class="s3">= </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">rsplit</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModulePath</span><span class="s3">(</span><span class="s1">parentName</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">path </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return None</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">file</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">description </span><span class="s3">= </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">find_module</span><span class="s3">(</span><span class="s1">baseName</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">return None</span>

        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">):</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">pathname</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">getModuleStar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Looks for the indicated directory module and returns the 
        __all__ member: the list of symbols within the module. &quot;&quot;&quot;</span>

        <span class="s4"># First, try to import the module directly.  That's the most</span>
        <span class="s4"># reliable answer, if it works.</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">module </span><span class="s3">= </span><span class="s1">__import__</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">)</span>
        <span class="s2">except</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s6">&quot;couldn't import %s&quot; </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">))</span>
            <span class="s1">module </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">module </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">symbol </span><span class="s2">in </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">:]:</span>
                <span class="s1">module </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">symbol</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__all__'</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">module</span><span class="s3">.</span><span class="s1">__all__</span>

        <span class="s4"># If it didn't work, just open the directory and scan for *.py</span>
        <span class="s4"># files.</span>
        <span class="s1">path </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">baseName </span><span class="s3">= </span><span class="s1">moduleName</span>
        <span class="s2">if </span><span class="s6">'.' </span><span class="s2">in </span><span class="s1">baseName</span><span class="s3">:</span>
            <span class="s1">parentName</span><span class="s3">, </span><span class="s1">baseName </span><span class="s3">= </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">rsplit</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModulePath</span><span class="s3">(</span><span class="s1">parentName</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">path </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return None</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">file</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">description </span><span class="s3">= </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">find_module</span><span class="s3">(</span><span class="s1">baseName</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">return None</span>

        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">):</span>
            <span class="s2">return None</span>

        <span class="s4"># Scan the directory, looking for .py files.</span>
        <span class="s1">modules </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">basename </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">listdir</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">basename</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'.py'</span><span class="s3">) </span><span class="s2">and </span><span class="s1">basename </span><span class="s3">!= </span><span class="s6">'__init__.py'</span><span class="s3">:</span>
                <span class="s1">modules</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">basename</span><span class="s3">[:-</span><span class="s5">3</span><span class="s3">])</span>

        <span class="s2">return </span><span class="s1">modules</span>

    <span class="s2">def </span><span class="s1">_gatherSubmodules</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">newName </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
                          <span class="s1">filename </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">guess </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">fromSource </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
                          <span class="s1">text </span><span class="s3">= </span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">newName</span><span class="s3">:</span>
            <span class="s1">newName </span><span class="s3">= </span><span class="s1">moduleName</span>

        <span class="s2">assert</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'.*'</span><span class="s3">))</span>
        <span class="s2">assert</span><span class="s3">(</span><span class="s1">newName</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'.*'</span><span class="s3">))</span>

        <span class="s1">mdefs </span><span class="s3">= {}</span>

        <span class="s4"># Find the parent module, so we can get its directory.</span>
        <span class="s1">parentName </span><span class="s3">= </span><span class="s1">moduleName</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s1">newParentName </span><span class="s3">= </span><span class="s1">newName</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s1">parentNames </span><span class="s3">= [(</span><span class="s1">parentName</span><span class="s3">, </span><span class="s1">newParentName</span><span class="s3">)]</span>

        <span class="s2">if </span><span class="s1">parentName</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'.*'</span><span class="s3">):</span>
            <span class="s2">assert</span><span class="s3">(</span><span class="s1">newParentName</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'.*'</span><span class="s3">))</span>
            <span class="s4"># Another special case.  The parent name &quot;*&quot; means to</span>
            <span class="s4"># return all possible directories within a particular</span>
            <span class="s4"># directory.</span>

            <span class="s1">topName </span><span class="s3">= </span><span class="s1">parentName</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">]</span>
            <span class="s1">newTopName </span><span class="s3">= </span><span class="s1">newParentName</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">]</span>
            <span class="s1">parentNames </span><span class="s3">= []</span>
            <span class="s1">modulePath </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModulePath</span><span class="s3">(</span><span class="s1">topName</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">modulePath</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">dirname </span><span class="s2">in </span><span class="s1">modulePath</span><span class="s3">:</span>
                    <span class="s2">for </span><span class="s1">basename </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">listdir</span><span class="s3">(</span><span class="s1">dirname</span><span class="s3">)):</span>
                        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirname</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">, </span><span class="s6">'__init__.py'</span><span class="s3">)):</span>
                            <span class="s1">parentName </span><span class="s3">= </span><span class="s6">'%s.%s' </span><span class="s3">% (</span><span class="s1">topName</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">)</span>
                            <span class="s1">newParentName </span><span class="s3">= </span><span class="s6">'%s.%s' </span><span class="s3">% (</span><span class="s1">newTopName</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModulePath</span><span class="s3">(</span><span class="s1">parentName</span><span class="s3">):</span>
                                <span class="s1">parentNames</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">parentName</span><span class="s3">, </span><span class="s1">newParentName</span><span class="s3">))</span>

        <span class="s2">for </span><span class="s1">parentName</span><span class="s3">, </span><span class="s1">newParentName </span><span class="s2">in </span><span class="s1">parentNames</span><span class="s3">:</span>
            <span class="s1">modules </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModuleStar</span><span class="s3">(</span><span class="s1">parentName</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">modules </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s4"># It's actually a regular module.</span>
                <span class="s1">mdefs</span><span class="s3">[</span><span class="s1">newParentName</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span>
                    <span class="s1">parentName</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s1">implicit</span><span class="s3">, </span><span class="s1">guess </span><span class="s3">= </span><span class="s1">guess</span><span class="s3">,</span>
                    <span class="s1">fromSource </span><span class="s3">= </span><span class="s1">fromSource</span><span class="s3">, </span><span class="s1">text </span><span class="s3">= </span><span class="s1">text</span><span class="s3">)</span>

            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># Now get all the py files in the parent directory.</span>
                <span class="s2">for </span><span class="s1">basename </span><span class="s2">in </span><span class="s1">modules</span><span class="s3">:</span>
                    <span class="s1">moduleName </span><span class="s3">= </span><span class="s6">'%s.%s' </span><span class="s3">% (</span><span class="s1">parentName</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">)</span>
                    <span class="s1">newName </span><span class="s3">= </span><span class="s6">'%s.%s' </span><span class="s3">% (</span><span class="s1">newParentName</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">)</span>
                    <span class="s1">mdefs</span><span class="s3">[</span><span class="s1">newName</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span>
                        <span class="s1">moduleName</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s1">implicit</span><span class="s3">, </span><span class="s1">guess </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
                        <span class="s1">fromSource </span><span class="s3">= </span><span class="s1">fromSource</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">mdefs</span>

    <span class="s2">def </span><span class="s1">addModule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">newName </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
                  <span class="s1">filename </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">guess </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">fromSource </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
                  <span class="s1">text </span><span class="s3">= </span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Adds a module to the list of modules to be exported by 
        this tool.  If implicit is true, it is OK if the module does 
        not actually exist. 
 
        newName is the name to call the module when it appears in the 
        output.  The default is the same name it had in the original. 
        Use caution when renaming a module; if another module imports 
        this module by its original name, you will also need to 
        explicitly add the module under its original name, duplicating 
        the module twice in the output. 
 
        The module name may end in &quot;.*&quot;, which means to add all of the 
        .py files (other than __init__.py) in a particular directory. 
        It may also end in &quot;.*.*&quot;, which means to cycle through all 
        directories within a particular directory. 
        &quot;&quot;&quot;</span>

        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf </span><span class="s2">is None</span>

        <span class="s2">if not </span><span class="s1">newName</span><span class="s3">:</span>
            <span class="s1">newName </span><span class="s3">= </span><span class="s1">moduleName</span>

        <span class="s2">if </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'.*'</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gatherSubmodules</span><span class="s3">(</span>
                <span class="s1">moduleName</span><span class="s3">, </span><span class="s1">implicit</span><span class="s3">, </span><span class="s1">newName</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">,</span>
                <span class="s1">guess</span><span class="s3">, </span><span class="s1">fromSource</span><span class="s3">, </span><span class="s1">text</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># A normal, explicit module name.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">newName</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span>
                <span class="s1">moduleName</span><span class="s3">, </span><span class="s1">filename </span><span class="s3">= </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s1">implicit</span><span class="s3">,</span>
                <span class="s1">guess </span><span class="s3">= </span><span class="s1">guess</span><span class="s3">, </span><span class="s1">fromSource </span><span class="s3">= </span><span class="s1">fromSource</span><span class="s3">, </span><span class="s1">text </span><span class="s3">= </span><span class="s1">text</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">done</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">addStartupModules </span><span class="s3">= </span><span class="s2">False</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Call this method after you have added all modules with 
        addModule().  You may then call generateCode() or 
        writeMultifile() to dump the resulting output.  After a call 
        to done(), you may not add any more modules until you call 
        reset(). &quot;&quot;&quot;</span>

        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf </span><span class="s2">is None</span>

        <span class="s4"># If we are building an exe, we also need to implicitly</span>
        <span class="s4"># bring in Python's startup modules.</span>
        <span class="s2">if </span><span class="s1">addStartupModules</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s6">'_frozen_importlib'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span><span class="s6">'importlib._bootstrap'</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s2">True</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s6">'_frozen_importlib_external'</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span><span class="s6">'importlib._bootstrap_external'</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s2">True</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">moduleName </span><span class="s2">in </span><span class="s1">startupModules</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">moduleName </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">addModule</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s2">True</span><span class="s3">)</span>

        <span class="s4"># Excluding a parent module also excludes all its</span>
        <span class="s4"># (non-explicit) children, unless the parent has allowChildren</span>
        <span class="s4"># set.</span>

        <span class="s4"># Walk through the list in sorted order, so we reach parents</span>
        <span class="s4"># before children.</span>
        <span class="s1">names </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
        <span class="s1">names</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>

        <span class="s1">excludeDict </span><span class="s3">= {}</span>
        <span class="s1">implicitParentDict </span><span class="s3">= {}</span>
        <span class="s1">includes </span><span class="s3">= []</span>
        <span class="s1">autoIncludes </span><span class="s3">= []</span>
        <span class="s1">origToNewName </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">newName</span><span class="s3">, </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">names</span><span class="s3">:</span>
            <span class="s1">moduleName </span><span class="s3">= </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span>
            <span class="s1">origToNewName</span><span class="s3">[</span><span class="s1">moduleName</span><span class="s3">] = </span><span class="s1">newName</span>
            <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">implicit </span><span class="s2">and </span><span class="s6">'.' </span><span class="s2">in </span><span class="s1">newName</span><span class="s3">:</span>
                <span class="s4"># For implicit modules, check if the parent is excluded.</span>
                <span class="s1">parentName</span><span class="s3">, </span><span class="s1">baseName </span><span class="s3">= </span><span class="s1">newName</span><span class="s3">.</span><span class="s1">rsplit</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">parentName </span><span class="s2">in </span><span class="s1">excludeDict </span><span class="s3">:</span>
                    <span class="s1">mdef </span><span class="s3">= </span><span class="s1">excludeDict</span><span class="s3">[</span><span class="s1">parentName</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">exclude</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">allowChildren</span><span class="s3">:</span>
                    <span class="s1">excludeDict</span><span class="s3">[</span><span class="s1">moduleName</span><span class="s3">] = </span><span class="s1">mdef</span>
            <span class="s2">elif </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">implicit </span><span class="s2">or </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">guess</span><span class="s3">:</span>
                <span class="s1">autoIncludes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">includes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">mf </span><span class="s3">= </span><span class="s1">PandaModuleFinder</span><span class="s3">(</span><span class="s1">excludes</span><span class="s3">=</span><span class="s1">list</span><span class="s3">(</span><span class="s1">excludeDict</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">suffixes</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">moduleSuffixes</span><span class="s3">, </span><span class="s1">path</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">path</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">)</span>

        <span class="s4"># Attempt to import the explicit modules into the modulefinder.</span>

        <span class="s4"># First, ensure the includes are sorted in order so that</span>
        <span class="s4"># packages appear before the modules they contain.  This</span>
        <span class="s4"># resolves potential ordering issues, especially with modules</span>
        <span class="s4"># that are discovered by filename rather than through import</span>
        <span class="s4"># statements.</span>
        <span class="s1">includes</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">key </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__sortModuleKey</span><span class="s3">)</span>

        <span class="s4"># Now walk through the list and import them all.</span>
        <span class="s2">for </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">includes</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">__loadModule</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">ex</span><span class="s3">:</span>
                <span class="s1">message </span><span class="s3">= </span><span class="s6">&quot;Unknown module: %s&quot; </span><span class="s3">% (</span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">str</span><span class="s3">(</span><span class="s1">ex</span><span class="s3">) != </span><span class="s6">&quot;No module named &quot; </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">):</span>
                    <span class="s1">message </span><span class="s3">+= </span><span class="s6">&quot; (%s)&quot; </span><span class="s3">% (</span><span class="s1">ex</span><span class="s3">)</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>

        <span class="s4"># Also attempt to import any implicit modules.  If any of</span>
        <span class="s4"># these fail to import, we don't really care.</span>
        <span class="s2">for </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">autoIncludes</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">__loadModule</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">)</span>
                <span class="s4"># Since it successfully loaded, it's no longer a guess.</span>
                <span class="s1">mdef</span><span class="s3">.</span><span class="s1">guess </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">except</span><span class="s3">:</span>
                <span class="s4"># Something went wrong, guess it's not an importable</span>
                <span class="s4"># module.</span>
                <span class="s2">pass</span>

        <span class="s4"># Check if any new modules we found have &quot;hidden&quot; imports</span>
        <span class="s2">for </span><span class="s1">origName </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
            <span class="s1">hidden </span><span class="s3">= </span><span class="s1">hiddenImports</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">origName</span><span class="s3">, [])</span>
            <span class="s2">for </span><span class="s1">modname </span><span class="s2">in </span><span class="s1">hidden</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">modname</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'.*'</span><span class="s3">):</span>
                    <span class="s1">mdefs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gatherSubmodules</span><span class="s3">(</span><span class="s1">modname</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s2">True</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">mdefs</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">__loadModule</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
                            <span class="s2">pass</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__loadModule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span><span class="s1">modname</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s2">True</span><span class="s3">))</span>

        <span class="s4"># Special case for sysconfig, which depends on a platform-specific</span>
        <span class="s4"># sysconfigdata module on POSIX systems.</span>
        <span class="s1">missing </span><span class="s3">= []</span>
        <span class="s2">if </span><span class="s6">'sysconfig' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules </span><span class="s2">and </span><span class="s1">\</span>
           <span class="s3">(</span><span class="s6">'linux' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform </span><span class="s2">or </span><span class="s6">'mac' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">):</span>
            <span class="s1">modname </span><span class="s3">= </span><span class="s6">'_sysconfigdata'</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">6</span><span class="s3">):</span>
                <span class="s1">modname </span><span class="s3">+= </span><span class="s6">'_'</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">8</span><span class="s3">):</span>
                    <span class="s1">modname </span><span class="s3">+= </span><span class="s6">'m'</span>

                <span class="s2">if </span><span class="s6">'linux' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">:</span>
                    <span class="s1">arch </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'_'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">modname </span><span class="s3">+= </span><span class="s6">'_linux_' </span><span class="s3">+ </span><span class="s1">arch </span><span class="s3">+ </span><span class="s6">'-linux-gnu'</span>
                <span class="s2">elif </span><span class="s6">'mac' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">:</span>
                    <span class="s1">modname </span><span class="s3">+= </span><span class="s6">'_darwin_darwin'</span>

            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">__loadModule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span><span class="s1">modname</span><span class="s3">, </span><span class="s1">implicit</span><span class="s3">=</span><span class="s2">True</span><span class="s3">))</span>
            <span class="s2">except</span><span class="s3">:</span>
                <span class="s1">missing</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">modname</span><span class="s3">)</span>

        <span class="s4"># Now, any new modules we found get added to the export list.</span>
        <span class="s2">for </span><span class="s1">origName </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
            <span class="s2">if </span><span class="s1">origName </span><span class="s2">not in </span><span class="s1">origToNewName</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">origName</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span><span class="s1">origName</span><span class="s3">, </span><span class="s1">implicit </span><span class="s3">= </span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">origName </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">any_missing_maybe</span><span class="s3">()[</span><span class="s5">0</span><span class="s3">]:</span>
            <span class="s2">if </span><span class="s1">origName </span><span class="s2">in </span><span class="s1">startupModules</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">origName </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">previousModules</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">origName </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
                <span class="s2">continue</span>

            <span class="s4"># This module is missing.  Let it be missing in the</span>
            <span class="s4"># runtime also.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">origName</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ModuleDef</span><span class="s3">(</span><span class="s1">origName</span><span class="s3">, </span><span class="s1">exclude </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
                                                    <span class="s1">implicit </span><span class="s3">= </span><span class="s2">True</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">origName </span><span class="s2">in </span><span class="s1">okMissing</span><span class="s3">:</span>
                <span class="s4"># If it's listed in okMissing, don't even report it.</span>
                <span class="s2">continue</span>

            <span class="s1">prefix </span><span class="s3">= </span><span class="s1">origName</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">origName </span><span class="s2">not in </span><span class="s1">reportedMissing</span><span class="s3">:</span>
                <span class="s1">missing</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">origName</span><span class="s3">)</span>
                <span class="s1">reportedMissing</span><span class="s3">[</span><span class="s1">origName</span><span class="s3">] = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">missing</span><span class="s3">:</span>
            <span class="s1">missing</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s6">&quot;There are some missing modules: %r&quot; </span><span class="s3">% </span><span class="s1">missing</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__sortModuleKey</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mdef</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; A sort key function to sort a list of mdef's into order, 
        primarily to ensure that packages proceed their modules. &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">:</span>
            <span class="s4"># If we have a moduleName, the key consists of the split</span>
            <span class="s4"># tuple of packages names.  That way, parents always sort</span>
            <span class="s4"># before children.</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s6">'a'</span><span class="s3">, </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># If we don't have a moduleName, the key doesn't really</span>
            <span class="s4"># matter--we use filename--but we start with 'b' to ensure</span>
            <span class="s4"># that all of non-named modules appear following all of</span>
            <span class="s4"># the named modules.</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s6">'b'</span><span class="s3">, </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__loadModule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mdef</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Adds the indicated module to the modulefinder. &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">:</span>
            <span class="s4"># If it has a filename, then we found it as a file on</span>
            <span class="s4"># disk.  In this case, the moduleName may not be accurate</span>
            <span class="s4"># and useful, so load it as a file instead.</span>

            <span class="s1">tempPath </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s6">'.' </span><span class="s2">not in </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">:</span>
                <span class="s4"># If we loaded a python file from the root, we need to</span>
                <span class="s4"># temporarily add its directory to the module search</span>
                <span class="s4"># path, so the modulefinder can find any sibling</span>
                <span class="s4"># python files it imports as well.</span>
                <span class="s1">tempPath </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">.</span><span class="s1">getDirname</span><span class="s3">()).</span><span class="s1">toOsSpecific</span><span class="s3">()</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tempPath</span><span class="s3">)</span>

            <span class="s1">pathname </span><span class="s3">= </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">.</span><span class="s1">toOsSpecific</span><span class="s3">()</span>
            <span class="s1">ext </span><span class="s3">= </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">.</span><span class="s1">getExtension</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">ext </span><span class="s3">== </span><span class="s6">'pyc' </span><span class="s2">or </span><span class="s1">ext </span><span class="s3">== </span><span class="s6">'pyo'</span><span class="s3">:</span>
                <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">, </span><span class="s6">'rb'</span><span class="s3">)</span>
                <span class="s1">stuff </span><span class="s3">= (</span><span class="s6">&quot;&quot;</span><span class="s3">, </span><span class="s6">&quot;rb&quot;</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PY_COMPILED</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">load_module</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">stuff</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">stuff </span><span class="s3">= (</span><span class="s6">&quot;&quot;</span><span class="s3">, </span><span class="s6">&quot;rb&quot;</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PY_SOURCE</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">text</span><span class="s3">:</span>
                    <span class="s1">fp </span><span class="s3">= </span><span class="s1">io</span><span class="s3">.</span><span class="s1">StringIO</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">text</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">, </span><span class="s6">'rb'</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">load_module</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">stuff</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">tempPath</span><span class="s3">:</span>
                <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">path</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># Otherwise, we can just import it normally.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">import_hook</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; After a previous call to done(), this resets the 
        FreezeTool object for a new pass.  More modules may be added 
        and dumped to a new target.  Previously-added modules are 
        remembered and will not be dumped again. &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">mf </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">previousModules </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">mangleName</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s6">'M_' </span><span class="s3">+ </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">, </span><span class="s6">'__'</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s6">'-'</span><span class="s3">, </span><span class="s6">'_'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">getAllModuleNames</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return a list of all module names that have been included 
        or forbidden, either in this current pass or in a previous 
        pass.  Module names that have been excluded are not included 
        in this list. &quot;&quot;&quot;</span>

        <span class="s1">moduleNames </span><span class="s3">= []</span>

        <span class="s2">for </span><span class="s1">newName</span><span class="s3">, </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
            <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">guess</span><span class="s3">:</span>
                <span class="s4"># Not really a module.</span>
                <span class="s2">pass</span>
            <span class="s2">elif </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">exclude </span><span class="s2">and not </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">forbid</span><span class="s3">:</span>
                <span class="s4"># An excluded (but not forbidden) file.</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">moduleNames</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">newName</span><span class="s3">)</span>

        <span class="s1">moduleNames</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">moduleNames</span>

    <span class="s2">def </span><span class="s1">getModuleDefs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return a list of all of the modules we will be explicitly 
        or implicitly including.  The return value is actually a list 
        of tuples: (moduleName, moduleDef).&quot;&quot;&quot;</span>

        <span class="s1">moduleDefs </span><span class="s3">= []</span>

        <span class="s2">for </span><span class="s1">newName</span><span class="s3">, </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
            <span class="s1">prev </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">previousModules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">newName</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">exclude</span><span class="s3">:</span>
                <span class="s4"># Include this module (even if a previous pass</span>
                <span class="s4"># excluded it).  But don't bother if we exported it</span>
                <span class="s4"># previously.</span>
                <span class="s2">if </span><span class="s1">prev </span><span class="s2">and not </span><span class="s1">prev</span><span class="s3">.</span><span class="s1">exclude</span><span class="s3">:</span>
                    <span class="s4"># Previously exported.</span>
                    <span class="s2">pass</span>
                <span class="s2">elif </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules </span><span class="s2">or </span><span class="s1">\</span>
                     <span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName </span><span class="s2">in </span><span class="s1">startupModules </span><span class="s2">or </span><span class="s1">\</span>
                     <span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">:</span>
                    <span class="s1">moduleDefs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">newName</span><span class="s3">, </span><span class="s1">mdef</span><span class="s3">))</span>
            <span class="s2">elif </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">forbid</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">prev </span><span class="s2">or not </span><span class="s1">prev</span><span class="s3">.</span><span class="s1">forbid</span><span class="s3">:</span>
                    <span class="s1">moduleDefs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">newName</span><span class="s3">, </span><span class="s1">mdef</span><span class="s3">))</span>

        <span class="s1">moduleDefs</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">moduleDefs</span>

    <span class="s2">def </span><span class="s1">__replacePaths</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s4"># Build up the replacement pathname table, so we can eliminate</span>
        <span class="s4"># the personal information in the frozen pathnames.  The</span>
        <span class="s4"># actual filename we put in there is meaningful only for stack</span>
        <span class="s4"># traces, so we'll just use the module name.</span>
        <span class="s1">replace_paths </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">module </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
            <span class="s2">if </span><span class="s1">module</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">:</span>
                <span class="s1">origPathname </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_filename</span>
                <span class="s2">if </span><span class="s1">origPathname</span><span class="s3">:</span>
                    <span class="s1">replace_paths</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">origPathname</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">replace_paths </span><span class="s3">= </span><span class="s1">replace_paths</span>

        <span class="s4"># Now that we have built up the replacement mapping, go back</span>
        <span class="s4"># through and actually replace the paths.</span>
        <span class="s2">for </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">module </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
            <span class="s2">if </span><span class="s1">module</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">:</span>
                <span class="s1">co </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">replace_paths_in_code</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">)</span>
                <span class="s1">module</span><span class="s3">.</span><span class="s1">__code__ </span><span class="s3">= </span><span class="s1">co;</span>

    <span class="s2">def </span><span class="s1">__addPyc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">compressionLevel</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">code</span><span class="s3">:</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">get_magic</span><span class="s3">() + </span><span class="s7">b'</span><span class="s2">\0\0\0\0</span><span class="s7">'</span>

            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
                <span class="s1">data </span><span class="s3">+= </span><span class="s7">b'</span><span class="s2">\0\0\0\0</span><span class="s7">'</span>

            <span class="s1">data </span><span class="s3">+= </span><span class="s1">marshal</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>

            <span class="s1">stream </span><span class="s3">= </span><span class="s1">StringStream</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
            <span class="s1">multifile</span><span class="s3">.</span><span class="s1">addSubfile</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">compressionLevel</span><span class="s3">)</span>
            <span class="s1">multifile</span><span class="s3">.</span><span class="s1">flush</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__addPythonDirs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">moduleDirs</span><span class="s3">, </span><span class="s1">dirnames</span><span class="s3">, </span><span class="s1">compressionLevel</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Adds all of the names on dirnames as a module directory. &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">dirnames</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s1">str </span><span class="s3">= </span><span class="s6">'.'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirnames</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">str </span><span class="s2">not in </span><span class="s1">moduleDirs</span><span class="s3">:</span>
            <span class="s4"># Add an implicit __init__.py file (but only if there's</span>
            <span class="s4"># not already a legitimate __init__.py file).</span>
            <span class="s1">moduleName </span><span class="s3">= </span><span class="s6">'.'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirnames</span><span class="s3">)</span>
            <span class="s1">filename </span><span class="s3">= </span><span class="s6">'/'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirnames</span><span class="s3">) + </span><span class="s6">'/__init__'</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">storePythonSource</span><span class="s3">:</span>
                <span class="s1">filename </span><span class="s3">+= </span><span class="s6">'.py'</span>
                <span class="s1">stream </span><span class="s3">= </span><span class="s1">StringStream</span><span class="s3">(</span><span class="s7">b''</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">multifile</span><span class="s3">.</span><span class="s1">findSubfile</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">) &lt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">multifile</span><span class="s3">.</span><span class="s1">addSubfile</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
                    <span class="s1">multifile</span><span class="s3">.</span><span class="s1">flush</span><span class="s3">()</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if __debug__</span><span class="s3">:</span>
                    <span class="s1">filename </span><span class="s3">+= </span><span class="s6">'.pyc'</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">filename </span><span class="s3">+= </span><span class="s6">'.pyo'</span>
                <span class="s2">if </span><span class="s1">multifile</span><span class="s3">.</span><span class="s1">findSubfile</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">) &lt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">):</span>
                        <span class="s1">code </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s6">''</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">code </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s6">''</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">__addPyc</span><span class="s3">(</span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">compressionLevel</span><span class="s3">)</span>

            <span class="s1">moduleDirs</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s2">True</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">__addPythonDirs</span><span class="s3">(</span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">moduleDirs</span><span class="s3">, </span><span class="s1">dirnames</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">compressionLevel</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__addPythonFile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">moduleDirs</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">mdef</span><span class="s3">,</span>
                        <span class="s1">compressionLevel</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Adds the named module to the multifile as a .pyc file. &quot;&quot;&quot;</span>

        <span class="s4"># First, split the module into its subdirectory names.</span>
        <span class="s1">dirnames </span><span class="s3">= </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dirnames</span><span class="s3">) &gt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">dirnames</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] == </span><span class="s6">'__init__'</span><span class="s3">:</span>
            <span class="s4"># The &quot;module&quot; may end in __init__, but that really means</span>
            <span class="s4"># the parent directory.</span>
            <span class="s1">dirnames </span><span class="s3">= </span><span class="s1">dirnames</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">__addPythonDirs</span><span class="s3">(</span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">moduleDirs</span><span class="s3">, </span><span class="s1">dirnames</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">compressionLevel</span><span class="s3">)</span>

        <span class="s1">filename </span><span class="s3">= </span><span class="s6">'/'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirnames</span><span class="s3">)</span>

        <span class="s1">module </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__path__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None or </span><span class="s1">\</span>
          <span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__file__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None and </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__file__'</span><span class="s3">).</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">'/__init__.py'</span><span class="s3">)):</span>
            <span class="s4"># It's actually a package.  In this case, we really write</span>
            <span class="s4"># the file moduleName/__init__.py.</span>
            <span class="s1">filename </span><span class="s3">+= </span><span class="s6">'/__init__'</span>
            <span class="s1">moduleDirs</span><span class="s3">[</span><span class="s1">moduleName</span><span class="s3">] = </span><span class="s2">True</span>

            <span class="s4"># Ensure we don't have an implicit filename from above.</span>
            <span class="s1">multifile</span><span class="s3">.</span><span class="s1">removeSubfile</span><span class="s3">(</span><span class="s1">filename </span><span class="s3">+ </span><span class="s6">'.py'</span><span class="s3">)</span>
            <span class="s2">if __debug__</span><span class="s3">:</span>
                <span class="s1">multifile</span><span class="s3">.</span><span class="s1">removeSubfile</span><span class="s3">(</span><span class="s1">filename </span><span class="s3">+ </span><span class="s6">'.pyc'</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">multifile</span><span class="s3">.</span><span class="s1">removeSubfile</span><span class="s3">(</span><span class="s1">filename </span><span class="s3">+ </span><span class="s6">'.pyo'</span><span class="s3">)</span>

        <span class="s4"># Attempt to add the original source file if we can.</span>
        <span class="s1">sourceFilename </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename </span><span class="s2">and </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">.</span><span class="s1">getExtension</span><span class="s3">() == </span><span class="s6">&quot;py&quot;</span><span class="s3">:</span>
            <span class="s1">sourceFilename </span><span class="s3">= </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">filename</span>
        <span class="s2">elif </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__file__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">):</span>
            <span class="s1">sourceFilename </span><span class="s3">= </span><span class="s1">Filename</span><span class="s3">.</span><span class="s1">fromOsSpecific</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">__file__</span><span class="s3">)</span>
            <span class="s1">sourceFilename</span><span class="s3">.</span><span class="s1">setExtension</span><span class="s3">(</span><span class="s6">&quot;py&quot;</span><span class="s3">)</span>
            <span class="s1">sourceFilename</span><span class="s3">.</span><span class="s1">setText</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">storePythonSource</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">sourceFilename </span><span class="s2">and </span><span class="s1">sourceFilename</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">():</span>
                <span class="s1">filename </span><span class="s3">+= </span><span class="s6">'.py'</span>
                <span class="s1">multifile</span><span class="s3">.</span><span class="s1">addSubfile</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">sourceFilename</span><span class="s3">, </span><span class="s1">compressionLevel</span><span class="s3">)</span>
                <span class="s2">return</span>

        <span class="s4"># If we can't find the source file, add the compiled pyc instead.</span>
        <span class="s2">if __debug__</span><span class="s3">:</span>
            <span class="s1">filename </span><span class="s3">+= </span><span class="s6">'.pyc'</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">filename </span><span class="s3">+= </span><span class="s6">'.pyo'</span>

        <span class="s1">code </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">module</span><span class="s3">:</span>
            <span class="s4"># Get the compiled code directly from the module object.</span>
            <span class="s1">code </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">&quot;__code__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">code</span><span class="s3">:</span>
                <span class="s4"># This is a module with no associated Python</span>
                <span class="s4"># code.  It must be an extension module.  Get the</span>
                <span class="s4"># filename.</span>
                <span class="s1">extensionFilename </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__file__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">extensionFilename</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">extensionFilename</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s4"># It doesn't even have a filename; it must</span>
                    <span class="s4"># be a built-in module.  No worries about</span>
                    <span class="s4"># this one, then.</span>
                    <span class="s2">pass</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># Read the code from the source file and compile it on-the-fly.</span>
            <span class="s2">if </span><span class="s1">sourceFilename </span><span class="s2">and </span><span class="s1">sourceFilename</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">():</span>
                <span class="s1">source </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">sourceFilename</span><span class="s3">.</span><span class="s1">toOsSpecific</span><span class="s3">(), </span><span class="s6">'r'</span><span class="s3">).</span><span class="s1">read</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">source </span><span class="s2">and </span><span class="s1">source</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] != </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span><span class="s3">:</span>
                    <span class="s1">source </span><span class="s3">= </span><span class="s1">source </span><span class="s3">+ </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">):</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">sourceFilename</span><span class="s3">), </span><span class="s6">'exec'</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">sourceFilename</span><span class="s3">), </span><span class="s6">'exec'</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">__addPyc</span><span class="s3">(</span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">compressionLevel</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">addToMultifile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">compressionLevel </span><span class="s3">= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; After a call to done(), this stores all of the accumulated 
        python code into the indicated Multifile.  Additional 
        extension modules are listed in self.extras.  &quot;&quot;&quot;</span>

        <span class="s1">moduleDirs </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModuleDefs</span><span class="s3">():</span>
            <span class="s2">if not </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">exclude</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">__addPythonFile</span><span class="s3">(</span><span class="s1">multifile</span><span class="s3">, </span><span class="s1">moduleDirs</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">mdef</span><span class="s3">,</span>
                                     <span class="s1">compressionLevel</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">writeMultifile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mfname</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; After a call to done(), this stores all of the accumulated 
        python code into a Multifile with the indicated filename, 
        including the extension.  Additional extension modules are 
        listed in self.extras.&quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">__replacePaths</span><span class="s3">()</span>

        <span class="s1">Filename</span><span class="s3">(</span><span class="s1">mfname</span><span class="s3">).</span><span class="s1">unlink</span><span class="s3">()</span>
        <span class="s1">multifile </span><span class="s3">= </span><span class="s1">Multifile</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">multifile</span><span class="s3">.</span><span class="s1">openReadWrite</span><span class="s3">(</span><span class="s1">mfname</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">Exception</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">addToMultifile</span><span class="s3">(</span><span class="s1">multifile</span><span class="s3">)</span>

        <span class="s1">multifile</span><span class="s3">.</span><span class="s1">flush</span><span class="s3">()</span>
        <span class="s1">multifile</span><span class="s3">.</span><span class="s1">repack</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">writeCode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">initCode </span><span class="s3">= </span><span class="s6">&quot;&quot;</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; After a call to done(), this freezes all of the accumulated 
        Python code into a C source file. &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">__replacePaths</span><span class="s3">()</span>

        <span class="s4"># Now generate the actual export table.</span>
        <span class="s1">moduleDefs </span><span class="s3">= []</span>
        <span class="s1">moduleList </span><span class="s3">= []</span>

        <span class="s2">for </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModuleDefs</span><span class="s3">():</span>
            <span class="s1">origName </span><span class="s3">= </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span>
            <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">forbid</span><span class="s3">:</span>
                <span class="s4"># Explicitly disallow importing this module.</span>
                <span class="s1">moduleList</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">makeForbiddenModuleListEntry</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">))</span>
                <span class="s2">continue</span>

            <span class="s2">assert not </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">exclude</span>
            <span class="s4"># Allow importing this module.</span>
            <span class="s1">module </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">origName</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s1">code </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">&quot;__code__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">code</span><span class="s3">:</span>
                <span class="s1">code </span><span class="s3">= </span><span class="s1">marshal</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>

                <span class="s1">mangledName </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mangleName</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">)</span>
                <span class="s1">moduleDefs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">makeModuleDef</span><span class="s3">(</span><span class="s1">mangledName</span><span class="s3">, </span><span class="s1">code</span><span class="s3">))</span>
                <span class="s1">moduleList</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">makeModuleListEntry</span><span class="s3">(</span><span class="s1">mangledName</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">module</span><span class="s3">))</span>
                <span class="s2">continue</span>

            <span class="s4">#if moduleName in startupModules:</span>
            <span class="s4">#    # Forbid the loading of this startup module.</span>
            <span class="s4">#    moduleList.append(self.makeForbiddenModuleListEntry(moduleName))</span>
            <span class="s4">#    continue</span>

            <span class="s4"># This is a module with no associated Python code.  It is either</span>
            <span class="s4"># an extension module or a builtin module.  Get the filename, if</span>
            <span class="s4"># it is the former.</span>
            <span class="s1">extensionFilename </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__file__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">extensionFilename </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">linkExtensionModules</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">extensionFilename</span><span class="s3">))</span>

            <span class="s4"># If it is a submodule of a frozen module, Python will have</span>
            <span class="s4"># trouble importing it as a builtin module.  Synthesize a frozen</span>
            <span class="s4"># module that loads it as builtin.</span>
            <span class="s2">if </span><span class="s6">'.' </span><span class="s2">in </span><span class="s1">moduleName </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">linkExtensionModules</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">):</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s6">'import sys;del sys.modules[&quot;%s&quot;];import imp;imp.init_builtin(&quot;%s&quot;)' </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">), </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s6">'import sys;del sys.modules[&quot;%s&quot;];import imp;imp.init_builtin(&quot;%s&quot;)' </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">), </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">)</span>
                <span class="s1">code </span><span class="s3">= </span><span class="s1">marshal</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>
                <span class="s1">mangledName </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mangleName</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">)</span>
                <span class="s1">moduleDefs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">makeModuleDef</span><span class="s3">(</span><span class="s1">mangledName</span><span class="s3">, </span><span class="s1">code</span><span class="s3">))</span>
                <span class="s1">moduleList</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">makeModuleListEntry</span><span class="s3">(</span><span class="s1">mangledName</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))</span>
            <span class="s2">elif </span><span class="s6">'.' </span><span class="s2">in </span><span class="s1">moduleName</span><span class="s3">:</span>
                <span class="s4"># Nothing we can do about this case except warn the user they</span>
                <span class="s4"># are in for some trouble.</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s6">'WARNING: Python cannot import extension modules under '</span>
                      <span class="s6">'frozen Python packages; %s will be inaccessible.  '</span>
                      <span class="s6">'passing either -l to link in extension modules or use '</span>
                      <span class="s6">'-x %s to exclude the entire package.' </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]))</span>

        <span class="s1">text </span><span class="s3">= </span><span class="s1">programFile </span><span class="s3">% {</span>
            <span class="s6">'moduleDefs'</span><span class="s3">: </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">moduleDefs</span><span class="s3">),</span>
            <span class="s6">'moduleList'</span><span class="s3">: </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">moduleList</span><span class="s3">),</span>
            <span class="s3">}</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">linkExtensionModules </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">:</span>
            <span class="s4"># Should we link in extension modules?  If so, we write out a new</span>
            <span class="s4"># built-in module table that directly hooks up with the init</span>
            <span class="s4"># functions.  On Linux, we completely override Python's own</span>
            <span class="s4"># built-in module table; on Windows, we can't do this, so we</span>
            <span class="s4"># instead use PyImport_ExtendInittab to add to it.</span>

            <span class="s4"># Python 3 case.</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'#if PY_MAJOR_VERSION &gt;= 3</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s2">for </span><span class="s1">module</span><span class="s3">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">!= </span><span class="s6">&quot;win32&quot; </span><span class="s2">or </span><span class="s1">fn</span><span class="s3">:</span>
                    <span class="s1">libName </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">initFunc </span><span class="s3">= </span><span class="s1">builtinInitFuncs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'PyInit_' </span><span class="s3">+ </span><span class="s1">libName</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">initFunc</span><span class="s3">:</span>
                        <span class="s1">text </span><span class="s3">+= </span><span class="s6">'extern PyAPI_FUNC(PyObject) *%s(void);</span><span class="s2">\n</span><span class="s6">' </span><span class="s3">% (</span><span class="s1">initFunc</span><span class="s3">)</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span>

            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s6">&quot;win32&quot;</span><span class="s3">:</span>
                <span class="s1">text </span><span class="s3">+= </span><span class="s6">'static struct _inittab extensions[] = {</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">text </span><span class="s3">+= </span><span class="s6">'struct _inittab _PyImport_Inittab[] = {</span><span class="s2">\n</span><span class="s6">'</span>

            <span class="s2">for </span><span class="s1">module</span><span class="s3">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">!= </span><span class="s6">&quot;win32&quot; </span><span class="s2">or </span><span class="s1">fn</span><span class="s3">:</span>
                    <span class="s1">libName </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">initFunc </span><span class="s3">= </span><span class="s1">builtinInitFuncs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'PyInit_' </span><span class="s3">+ </span><span class="s1">libName</span><span class="s3">) </span><span class="s2">or </span><span class="s6">'NULL'</span>
                    <span class="s1">text </span><span class="s3">+= </span><span class="s6">'  {&quot;%s&quot;, %s},</span><span class="s2">\n</span><span class="s6">' </span><span class="s3">% (</span><span class="s1">module</span><span class="s3">, </span><span class="s1">initFunc</span><span class="s3">)</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'  {0, 0},</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'};</span><span class="s2">\n\n</span><span class="s6">'</span>

            <span class="s4"># Python 2 case.</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'#else</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s2">for </span><span class="s1">module</span><span class="s3">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">!= </span><span class="s6">&quot;win32&quot; </span><span class="s2">or </span><span class="s1">fn</span><span class="s3">:</span>
                    <span class="s1">libName </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">initFunc </span><span class="s3">= </span><span class="s1">builtinInitFuncs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'init' </span><span class="s3">+ </span><span class="s1">libName</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">initFunc</span><span class="s3">:</span>
                        <span class="s1">text </span><span class="s3">+= </span><span class="s6">'extern PyAPI_FUNC(void) %s(void);</span><span class="s2">\n</span><span class="s6">' </span><span class="s3">% (</span><span class="s1">initFunc</span><span class="s3">)</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span>

            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s6">&quot;win32&quot;</span><span class="s3">:</span>
                <span class="s1">text </span><span class="s3">+= </span><span class="s6">'static struct _inittab extensions[] = {</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">text </span><span class="s3">+= </span><span class="s6">'struct _inittab _PyImport_Inittab[] = {</span><span class="s2">\n</span><span class="s6">'</span>

            <span class="s2">for </span><span class="s1">module</span><span class="s3">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">!= </span><span class="s6">&quot;win32&quot; </span><span class="s2">or </span><span class="s1">fn</span><span class="s3">:</span>
                    <span class="s1">libName </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">initFunc </span><span class="s3">= </span><span class="s1">builtinInitFuncs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'init' </span><span class="s3">+ </span><span class="s1">libName</span><span class="s3">) </span><span class="s2">or </span><span class="s6">'NULL'</span>
                    <span class="s1">text </span><span class="s3">+= </span><span class="s6">'  {&quot;%s&quot;, %s},</span><span class="s2">\n</span><span class="s6">' </span><span class="s3">% (</span><span class="s1">module</span><span class="s3">, </span><span class="s1">initFunc</span><span class="s3">)</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'  {0, 0},</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'};</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'#endif</span><span class="s2">\n\n</span><span class="s6">'</span>

        <span class="s2">elif </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s6">&quot;win32&quot;</span><span class="s3">:</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'static struct _inittab extensions[] = {</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'  {0, 0},</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s1">text </span><span class="s3">+= </span><span class="s6">'};</span><span class="s2">\n\n</span><span class="s6">'</span>

        <span class="s1">text </span><span class="s3">+= </span><span class="s1">initCode</span>

        <span class="s2">if </span><span class="s1">filename </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">file </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s6">'w'</span><span class="s3">)</span>
            <span class="s1">file</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">text</span><span class="s3">)</span>
            <span class="s1">file</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">generateCode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">, </span><span class="s1">compileToExe </span><span class="s3">= </span><span class="s2">False</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; After a call to done(), this freezes all of the 
        accumulated python code into either an executable program (if 
        compileToExe is true) or a dynamic library (if compileToExe is 
        false).  The basename is the name of the file to write, 
        without the extension. 
 
        The return value is the newly-generated filename, including 
        the filename extension.  Additional extension modules are 
        listed in self.extras. &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">compileToExe</span><span class="s3">:</span>
            <span class="s4"># We must have a __main__ module to make an exe file.</span>
            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__writingModule</span><span class="s3">(</span><span class="s6">'__main__'</span><span class="s3">):</span>
                <span class="s1">message </span><span class="s3">= </span><span class="s6">&quot;Can't generate an executable without a __main__ module.&quot;</span>
                <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>

        <span class="s1">filename </span><span class="s3">= </span><span class="s1">basename </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sourceExtension</span>

        <span class="s1">dllexport </span><span class="s3">= </span><span class="s6">''</span>
        <span class="s1">dllimport </span><span class="s3">= </span><span class="s6">''</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'win'</span><span class="s3">):</span>
            <span class="s1">dllexport </span><span class="s3">= </span><span class="s6">'__declspec(dllexport) '</span>
            <span class="s1">dllimport </span><span class="s3">= </span><span class="s6">'__declspec(dllimport) '</span>

        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cenv</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">cenv </span><span class="s3">= </span><span class="s1">CompilationEnvironment</span><span class="s3">(</span><span class="s1">platform </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">compileToExe</span><span class="s3">:</span>
            <span class="s1">code </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">frozenMainCode</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'win'</span><span class="s3">):</span>
                <span class="s1">code </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">frozenDllMainCode</span>
            <span class="s1">initCode </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mainInitCode </span><span class="s3">% {</span>
                <span class="s6">'frozenMainCode' </span><span class="s3">: </span><span class="s1">code</span><span class="s3">,</span>
                <span class="s6">'programName' </span><span class="s3">: </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">basename</span><span class="s3">),</span>
                <span class="s6">'dllexport' </span><span class="s3">: </span><span class="s1">dllexport</span><span class="s3">,</span>
                <span class="s6">'dllimport' </span><span class="s3">: </span><span class="s1">dllimport</span><span class="s3">,</span>
                <span class="s3">}</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'win'</span><span class="s3">):</span>
                <span class="s1">target </span><span class="s3">= </span><span class="s1">basename </span><span class="s3">+ </span><span class="s6">'.exe'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">target </span><span class="s3">= </span><span class="s1">basename</span>

            <span class="s1">compileFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cenv</span><span class="s3">.</span><span class="s1">compileExe</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'win'</span><span class="s3">):</span>
                <span class="s1">target </span><span class="s3">= </span><span class="s1">basename </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cenv</span><span class="s3">.</span><span class="s1">dllext </span><span class="s3">+ </span><span class="s6">'.pyd'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">target </span><span class="s3">= </span><span class="s1">basename </span><span class="s3">+ </span><span class="s6">'.so'</span>

            <span class="s1">initCode </span><span class="s3">= </span><span class="s1">dllInitCode </span><span class="s3">% {</span>
                <span class="s6">'moduleName' </span><span class="s3">: </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">basename</span><span class="s3">),</span>
                <span class="s6">'dllexport' </span><span class="s3">: </span><span class="s1">dllexport</span><span class="s3">,</span>
                <span class="s6">'dllimport' </span><span class="s3">: </span><span class="s1">dllimport</span><span class="s3">,</span>
                <span class="s3">}</span>
            <span class="s1">compileFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cenv</span><span class="s3">.</span><span class="s1">compileDll</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">writeCode</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">initCode</span><span class="s3">=</span><span class="s1">initCode</span><span class="s3">)</span>

        <span class="s4"># Keep track of the files we should clean up after use.</span>
        <span class="s1">cleanFiles </span><span class="s3">= [</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">basename </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">objectExtension</span><span class="s3">]</span>

        <span class="s1">extraLink </span><span class="s3">= []</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">linkExtensionModules</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">mod</span><span class="s3">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">fn</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s6">'win32'</span><span class="s3">:</span>
                    <span class="s4"># We can't link with a .pyd directly on Windows.  Check</span>
                    <span class="s4"># if there is a corresponding .lib file in the Python libs</span>
                    <span class="s4"># directory.</span>
                    <span class="s1">libsdir </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">exec_prefix</span><span class="s3">, </span><span class="s6">'libs'</span><span class="s3">)</span>
                    <span class="s1">libfile </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">libsdir</span><span class="s3">, </span><span class="s1">mod </span><span class="s3">+ </span><span class="s6">'.lib'</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">libfile</span><span class="s3">):</span>
                        <span class="s1">extraLink</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">mod </span><span class="s3">+ </span><span class="s6">'.lib'</span><span class="s3">)</span>
                        <span class="s2">continue</span>

                    <span class="s4"># No, so we have to generate a .lib file.  This is pretty</span>
                    <span class="s4"># easy given that we know the only symbol we need is a</span>
                    <span class="s4"># initmodule or PyInit_module function.</span>
                    <span class="s1">modname </span><span class="s3">= </span><span class="s1">mod</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">libfile </span><span class="s3">= </span><span class="s1">modname </span><span class="s3">+ </span><span class="s6">'.lib'</span>
                    <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">):</span>
                        <span class="s1">symbolName </span><span class="s3">= </span><span class="s6">'PyInit_' </span><span class="s3">+ </span><span class="s1">modname</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">symbolName </span><span class="s3">= </span><span class="s6">'init' </span><span class="s3">+ </span><span class="s1">modname</span>
                    <span class="s1">os</span><span class="s3">.</span><span class="s1">system</span><span class="s3">(</span><span class="s6">'lib /nologo /def /export:%s /name:%s.pyd /out:%s' </span><span class="s3">% (</span><span class="s1">symbolName</span><span class="s3">, </span><span class="s1">modname</span><span class="s3">, </span><span class="s1">libfile</span><span class="s3">))</span>
                    <span class="s1">extraLink</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">libfile</span><span class="s3">)</span>
                    <span class="s1">cleanFiles </span><span class="s3">+= [</span><span class="s1">libfile</span><span class="s3">, </span><span class="s1">modname </span><span class="s3">+ </span><span class="s6">'.exp'</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">extraLink</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">compileFunc</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">, </span><span class="s1">extraLink</span><span class="s3">=</span><span class="s1">extraLink</span><span class="s3">)</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">keepTemporaryFiles</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">cleanFiles</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">file</span><span class="s3">):</span>
                        <span class="s1">os</span><span class="s3">.</span><span class="s1">unlink</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">target</span>

    <span class="s2">def </span><span class="s1">generateRuntimeFromStub</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">stub_file</span><span class="s3">, </span><span class="s1">use_console</span><span class="s3">, </span><span class="s1">fields</span><span class="s3">={},</span>
                                <span class="s1">log_append</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">log_filename_strftime</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">__replacePaths</span><span class="s3">()</span>

        <span class="s4"># We must have a __main__ module to make an exe file.</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__writingModule</span><span class="s3">(</span><span class="s6">'__main__'</span><span class="s3">):</span>
            <span class="s1">message </span><span class="s3">= </span><span class="s6">&quot;Can't generate an executable without a __main__ module.&quot;</span>
            <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'win'</span><span class="s3">):</span>
            <span class="s1">modext </span><span class="s3">= </span><span class="s6">'.pyd'</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">modext </span><span class="s3">= </span><span class="s6">'.so'</span>

        <span class="s4"># First gather up the strings and code for all the module names, and</span>
        <span class="s4"># put those in a string pool.</span>
        <span class="s1">pool </span><span class="s3">= </span><span class="s7">b&quot;&quot;</span>
        <span class="s1">strings </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>

        <span class="s2">for </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModuleDefs</span><span class="s3">():</span>
            <span class="s1">strings</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(</span><span class="s6">'ascii'</span><span class="s3">))</span>

        <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">strings</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(</span><span class="s6">'utf-8'</span><span class="s3">))</span>

        <span class="s4"># Sort by length descending, allowing reuse of partial strings.</span>
        <span class="s1">strings </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">strings</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">str</span><span class="s3">:-</span><span class="s1">len</span><span class="s3">(</span><span class="s1">str</span><span class="s3">))</span>
        <span class="s1">string_offsets </span><span class="s3">= {}</span>

        <span class="s4"># Now add the strings to the pool, and collect the offsets relative to</span>
        <span class="s4"># the beginning of the pool.</span>
        <span class="s2">for </span><span class="s1">string </span><span class="s2">in </span><span class="s1">strings</span><span class="s3">:</span>
            <span class="s4"># First check whether it's already in there; it could be part of</span>
            <span class="s4"># a longer string.</span>
            <span class="s1">offset </span><span class="s3">= </span><span class="s1">pool</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s1">string </span><span class="s3">+ </span><span class="s7">b'</span><span class="s2">\0</span><span class="s7">'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">offset </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">offset </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">)</span>
                <span class="s1">pool </span><span class="s3">+= </span><span class="s1">string </span><span class="s3">+ </span><span class="s7">b'</span><span class="s2">\0</span><span class="s7">'</span>
            <span class="s1">string_offsets</span><span class="s3">[</span><span class="s1">string</span><span class="s3">] = </span><span class="s1">offset</span>

        <span class="s4"># Now go through the modules and add them to the pool as well.  These</span>
        <span class="s4"># are not 0-terminated, but we later record their sizes and names in</span>
        <span class="s4"># a table after the blob header.</span>
        <span class="s1">moduleList </span><span class="s3">= []</span>

        <span class="s2">for </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">mdef </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getModuleDefs</span><span class="s3">():</span>
            <span class="s1">origName </span><span class="s3">= </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">moduleName</span>
            <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">forbid</span><span class="s3">:</span>
                <span class="s4"># Explicitly disallow importing this module.</span>
                <span class="s1">moduleList</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>
                <span class="s2">continue</span>

            <span class="s4"># For whatever it's worth, align the code blocks.</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">) &amp; </span><span class="s5">3 </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">pad </span><span class="s3">= (</span><span class="s5">4 </span><span class="s3">- (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">) &amp; </span><span class="s5">3</span><span class="s3">))</span>
                <span class="s1">pool </span><span class="s3">+= </span><span class="s7">b'</span><span class="s2">\0</span><span class="s7">' </span><span class="s3">* </span><span class="s1">pad</span>

            <span class="s2">assert not </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">exclude</span>
            <span class="s4"># Allow importing this module.</span>
            <span class="s1">module </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mf</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">origName</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s1">code </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">&quot;__code__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">code</span><span class="s3">:</span>
                <span class="s1">code </span><span class="s3">= </span><span class="s1">marshal</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>
                <span class="s1">size </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">&quot;__path__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">):</span>
                    <span class="s4"># Indicate package by negative size</span>
                    <span class="s1">size </span><span class="s3">= -</span><span class="s1">size</span>
                <span class="s1">moduleList</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">), </span><span class="s1">size</span><span class="s3">))</span>
                <span class="s1">pool </span><span class="s3">+= </span><span class="s1">code</span>
                <span class="s2">continue</span>

            <span class="s4"># This is a module with no associated Python code.  It is either</span>
            <span class="s4"># an extension module or a builtin module.  Get the filename, if</span>
            <span class="s4"># it is the former.</span>
            <span class="s1">extensionFilename </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">'__file__'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">extensionFilename</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">extras</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">extensionFilename</span><span class="s3">))</span>

            <span class="s4"># If it is a submodule of a frozen module, Python will have</span>
            <span class="s4"># trouble importing it as a builtin module.  Synthesize a frozen</span>
            <span class="s4"># module that loads it dynamically.</span>
            <span class="s2">if </span><span class="s6">'.' </span><span class="s2">in </span><span class="s1">moduleName</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">&quot;macosx&quot;</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">use_console</span><span class="s3">:</span>
                    <span class="s4"># We write the Frameworks directory to sys.path[0].</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s6">'import sys;del sys.modules[&quot;%s&quot;];import sys,os,imp;imp.load_dynamic(&quot;%s&quot;,os.path.join(sys.path[0], &quot;%s%s&quot;))' </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">modext</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s6">'import sys;del sys.modules[&quot;%s&quot;];import sys,os,imp;imp.load_dynamic(&quot;%s&quot;,os.path.join(os.path.dirname(sys.executable), &quot;%s%s&quot;))' </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">modext</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">):</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">code</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">code </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">code</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">)</span>
                <span class="s1">code </span><span class="s3">= </span><span class="s1">marshal</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>
                <span class="s1">moduleList</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)))</span>
                <span class="s1">pool </span><span class="s3">+= </span><span class="s1">code</span>

        <span class="s4"># Determine the format of the header and module list entries depending</span>
        <span class="s4"># on the platform.</span>
        <span class="s1">num_pointers </span><span class="s3">= </span><span class="s5">12</span>
        <span class="s1">stub_data </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">(</span><span class="s1">stub_file</span><span class="s3">.</span><span class="s1">read</span><span class="s3">())</span>
        <span class="s1">bitnesses </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_executable_bitnesses</span><span class="s3">(</span><span class="s1">stub_data</span><span class="s3">)</span>

        <span class="s1">header_layouts </span><span class="s3">= {</span>
            <span class="s5">32</span><span class="s3">: </span><span class="s6">'&lt;QQHHHH8x%dII' </span><span class="s3">% </span><span class="s1">num_pointers</span><span class="s3">,</span>
            <span class="s5">64</span><span class="s3">: </span><span class="s6">'&lt;QQHHHH8x%dQQ' </span><span class="s3">% </span><span class="s1">num_pointers</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s1">entry_layouts </span><span class="s3">= {</span>
            <span class="s5">32</span><span class="s3">: </span><span class="s6">'&lt;IIi'</span><span class="s3">,</span>
            <span class="s5">64</span><span class="s3">: </span><span class="s6">'&lt;QQixxxx'</span><span class="s3">,</span>
        <span class="s3">}</span>

        <span class="s4"># Calculate the size of the module tables, so that we can determine</span>
        <span class="s4"># the proper offset for the string pointers.  There can be more than</span>
        <span class="s4"># one module table for macOS executables.  Sort the bitnesses so that</span>
        <span class="s4"># the alignment is correct.</span>
        <span class="s1">bitnesses </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">bitnesses</span><span class="s3">, </span><span class="s1">reverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">pool_offset </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">bitness </span><span class="s2">in </span><span class="s1">bitnesses</span><span class="s3">:</span>
            <span class="s1">pool_offset </span><span class="s3">+= (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">moduleList</span><span class="s3">) + </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">calcsize</span><span class="s3">(</span><span class="s1">entry_layouts</span><span class="s3">[</span><span class="s1">bitness</span><span class="s3">])</span>

        <span class="s4"># Now we can determine the offset of the blob.</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">platform</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'win'</span><span class="s3">):</span>
            <span class="s4"># We don't use mmap on Windows.  Align just for good measure.</span>
            <span class="s1">blob_align </span><span class="s3">= </span><span class="s5">32</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># Align to page size, so that it can be mmapped.</span>
            <span class="s1">blob_align </span><span class="s3">= </span><span class="s5">4096</span>

        <span class="s4"># Add padding before the blob if necessary.</span>
        <span class="s1">blob_offset </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">stub_data</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">blob_offset </span><span class="s3">&amp; (</span><span class="s1">blob_align </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)) != </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">pad </span><span class="s3">= (</span><span class="s1">blob_align </span><span class="s3">- (</span><span class="s1">blob_offset </span><span class="s3">&amp; (</span><span class="s1">blob_align </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)))</span>
            <span class="s1">stub_data </span><span class="s3">+= (</span><span class="s7">b'</span><span class="s2">\0</span><span class="s7">' </span><span class="s3">* </span><span class="s1">pad</span><span class="s3">)</span>
            <span class="s1">blob_offset </span><span class="s3">+= </span><span class="s1">pad</span>
        <span class="s2">assert </span><span class="s3">(</span><span class="s1">blob_offset </span><span class="s3">% </span><span class="s1">blob_align</span><span class="s3">) == </span><span class="s5">0</span>
        <span class="s2">assert </span><span class="s1">blob_offset </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">stub_data</span><span class="s3">)</span>

        <span class="s4"># Also determine the total blob size now.  Add padding to the end.</span>
        <span class="s1">blob_size </span><span class="s3">= </span><span class="s1">pool_offset </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">blob_size </span><span class="s3">&amp; </span><span class="s5">31 </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">pad </span><span class="s3">= (</span><span class="s5">32 </span><span class="s3">- (</span><span class="s1">blob_size </span><span class="s3">&amp; </span><span class="s5">31</span><span class="s3">))</span>
            <span class="s1">blob_size </span><span class="s3">+= </span><span class="s1">pad</span>

        <span class="s4"># Calculate the offsets for the variables.  These are pointers,</span>
        <span class="s4"># relative to the beginning of the blob.</span>
        <span class="s1">field_offsets </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">encoded </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(</span><span class="s6">'utf-8'</span><span class="s3">)</span>
                <span class="s1">field_offsets</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">pool_offset </span><span class="s3">+ </span><span class="s1">string_offsets</span><span class="s3">[</span><span class="s1">encoded</span><span class="s3">]</span>

        <span class="s4"># OK, now go and write the blob.  This consists of the module table</span>
        <span class="s4"># (there may be two in the case of a macOS universal (fat) binary).</span>
        <span class="s1">blob </span><span class="s3">= </span><span class="s7">b&quot;&quot;</span>
        <span class="s1">append_offset </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">bitness </span><span class="s2">in </span><span class="s1">bitnesses</span><span class="s3">:</span>
            <span class="s1">entry_layout </span><span class="s3">= </span><span class="s1">entry_layouts</span><span class="s3">[</span><span class="s1">bitness</span><span class="s3">]</span>
            <span class="s1">header_layout </span><span class="s3">= </span><span class="s1">header_layouts</span><span class="s3">[</span><span class="s1">bitness</span><span class="s3">]</span>

            <span class="s1">table_offset </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">blob</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size </span><span class="s2">in </span><span class="s1">moduleList</span><span class="s3">:</span>
                <span class="s1">encoded </span><span class="s3">= </span><span class="s1">moduleName</span><span class="s3">.</span><span class="s1">encode</span><span class="s3">(</span><span class="s6">'ascii'</span><span class="s3">)</span>
                <span class="s1">string_offset </span><span class="s3">= </span><span class="s1">pool_offset </span><span class="s3">+ </span><span class="s1">string_offsets</span><span class="s3">[</span><span class="s1">encoded</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">size </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">offset </span><span class="s3">+= </span><span class="s1">pool_offset</span>
                <span class="s1">blob </span><span class="s3">+= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s1">entry_layout</span><span class="s3">, </span><span class="s1">string_offset</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

            <span class="s4"># A null entry marks the end of the module table.</span>
            <span class="s1">blob </span><span class="s3">+= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s1">entry_layout</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

            <span class="s4"># These flags should match the enum in deploy-stub.c</span>
            <span class="s1">flags </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s2">if </span><span class="s1">log_append</span><span class="s3">:</span>
                <span class="s1">flags </span><span class="s3">|= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">log_filename_strftime</span><span class="s3">:</span>
                <span class="s1">flags </span><span class="s3">|= </span><span class="s5">2</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">optimize </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">:</span>
                <span class="s1">flags </span><span class="s3">|= </span><span class="s5">4 </span><span class="s4"># keep_docstrings</span>

            <span class="s4"># Compose the header we will be writing to the stub, to tell it</span>
            <span class="s4"># where to find the module data blob, as well as other variables.</span>
            <span class="s1">header </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s1">header_layout</span><span class="s3">,</span>
                <span class="s1">blob_offset</span><span class="s3">,</span>
                <span class="s1">blob_size</span><span class="s3">,</span>
                <span class="s5">1</span><span class="s3">, </span><span class="s4"># Version number</span>
                <span class="s1">num_pointers</span><span class="s3">, </span><span class="s4"># Number of pointers that follow</span>
                <span class="s5">0</span><span class="s3">, </span><span class="s4"># Codepage, not yet used</span>
                <span class="s1">flags</span><span class="s3">,</span>
                <span class="s1">table_offset</span><span class="s3">, </span><span class="s4"># Module table pointer.</span>
                <span class="s4"># The following variables need to be set before static init</span>
                <span class="s4"># time.  See configPageManager.cxx, where they are read.</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'prc_data'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'default_prc_dir'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'prc_dir_envvars'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'prc_path_envvars'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'prc_patterns'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'prc_encrypted_patterns'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'prc_encryption_key'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'prc_executable_patterns'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'prc_executable_args_envvar'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'main_dir'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s1">field_offsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s6">'log_filename'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                <span class="s5">0</span><span class="s3">)</span>

            <span class="s4"># Now, find the location of the 'blobinfo' symbol in the binary,</span>
            <span class="s4"># to which we will write our header.</span>
            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_replace_symbol</span><span class="s3">(</span><span class="s1">stub_data</span><span class="s3">, </span><span class="s7">b'blobinfo'</span><span class="s3">, </span><span class="s1">header</span><span class="s3">, </span><span class="s1">bitness</span><span class="s3">=</span><span class="s1">bitness</span><span class="s3">):</span>
                <span class="s4"># This must be a legacy deploy-stub, which requires the offset to</span>
                <span class="s4"># be appended to the end.</span>
                <span class="s1">append_offset </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s4"># Add the string/code pool.</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">blob</span><span class="s3">) == </span><span class="s1">pool_offset</span>
        <span class="s1">blob </span><span class="s3">+= </span><span class="s1">pool</span>
        <span class="s2">del </span><span class="s1">pool</span>

        <span class="s4"># Now pad out the blob to the calculated blob size.</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">blob</span><span class="s3">) &lt; </span><span class="s1">blob_size</span><span class="s3">:</span>
            <span class="s1">blob </span><span class="s3">+= </span><span class="s7">b'</span><span class="s2">\0</span><span class="s7">' </span><span class="s3">* (</span><span class="s1">blob_size </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">blob</span><span class="s3">))</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">blob</span><span class="s3">) == </span><span class="s1">blob_size</span>

        <span class="s2">if </span><span class="s1">append_offset</span><span class="s3">:</span>
            <span class="s4"># This is for legacy deploy-stub.</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s6">&quot;WARNING: Could not find blob header. Is deploy-stub outdated?&quot;</span><span class="s3">)</span>
            <span class="s1">blob </span><span class="s3">+= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s6">'&lt;Q'</span><span class="s3">, </span><span class="s1">blob_offset</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s6">'wb'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
            <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">stub_data</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">f</span><span class="s3">.</span><span class="s1">tell</span><span class="s3">() == </span><span class="s1">blob_offset</span>
            <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">blob</span><span class="s3">)</span>

        <span class="s1">os</span><span class="s3">.</span><span class="s1">chmod</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s5">0o755</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">target</span>

    <span class="s2">def </span><span class="s1">_get_executable_bitnesses</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the bitnesses (32 or 64) of the given executable data. 
        This will contain 1 element for non-fat executables.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s7">b'MZ'</span><span class="s3">):</span>
            <span class="s4"># A Windows PE file.</span>
            <span class="s1">offset</span><span class="s3">, = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&lt;I'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s5">0x3c</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">data</span><span class="s3">[</span><span class="s1">offset</span><span class="s3">:</span><span class="s1">offset</span><span class="s3">+</span><span class="s5">4</span><span class="s3">] == </span><span class="s7">b'PE</span><span class="s2">\0\0</span><span class="s7">'</span>

            <span class="s1">magic</span><span class="s3">, = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&lt;H'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">offset </span><span class="s3">+ </span><span class="s5">24</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">magic </span><span class="s2">in </span><span class="s3">(</span><span class="s5">0x010b</span><span class="s3">, </span><span class="s5">0x020b</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">magic </span><span class="s3">== </span><span class="s5">0x020b</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">(</span><span class="s5">64</span><span class="s3">,)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">(</span><span class="s5">32</span><span class="s3">,)</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s7">b&quot;</span><span class="s2">\177</span><span class="s7">ELF&quot;</span><span class="s3">):</span>
            <span class="s4"># A Linux/FreeBSD ELF executable.</span>
            <span class="s1">elfclass </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s5">4</span><span class="s3">:</span><span class="s5">5</span><span class="s3">])</span>
            <span class="s2">assert </span><span class="s1">elfclass </span><span class="s2">in </span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">elfclass </span><span class="s3">* </span><span class="s5">32</span><span class="s3">,)</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\xFE\xED\xFA\xCE</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xCE\xFA\xED\xFE</span><span class="s7">'</span><span class="s3">):</span>
            <span class="s4"># 32-bit Mach-O file, as used on macOS.</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s5">32</span><span class="s3">,)</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\xFE\xED\xFA\xCF</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xCF\xFA\xED\xFE</span><span class="s7">'</span><span class="s3">):</span>
            <span class="s4"># 64-bit Mach-O file, as used on macOS.</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s5">64</span><span class="s3">,)</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\xCA\xFE\xBA\xBE</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xBE\xBA\xFE\xCA</span><span class="s7">'</span><span class="s3">):</span>
            <span class="s4"># Universal binary with 32-bit offsets.</span>
            <span class="s1">num_fat</span><span class="s3">, = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&gt;I'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>
            <span class="s1">bitnesses </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s5">8</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_fat</span><span class="s3">):</span>
                <span class="s1">cputype</span><span class="s3">, </span><span class="s1">cpusubtype</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">align </span><span class="s3">= </span><span class="s1">\</span>
                    <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&gt;IIIII'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
                <span class="s1">ptr </span><span class="s3">+= </span><span class="s5">20</span>

                <span class="s2">if </span><span class="s3">(</span><span class="s1">cputype </span><span class="s3">&amp; </span><span class="s5">0x1000000</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">bitnesses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">64</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">bitnesses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">32</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">bitnesses</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\xCA\xFE\xBA\xBF</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xBF\xBA\xFE\xCA</span><span class="s7">'</span><span class="s3">):</span>
            <span class="s4"># Universal binary with 64-bit offsets.</span>
            <span class="s1">num_fat</span><span class="s3">, = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&gt;I'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>
            <span class="s1">bitnesses </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s5">8</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_fat</span><span class="s3">):</span>
                <span class="s1">cputype</span><span class="s3">, </span><span class="s1">cpusubtype</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">align </span><span class="s3">= </span><span class="s1">\</span>
                    <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&gt;QQQQQ'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
                <span class="s1">ptr </span><span class="s3">+= </span><span class="s5">40</span>

                <span class="s2">if </span><span class="s3">(</span><span class="s1">cputype </span><span class="s3">&amp; </span><span class="s5">0x1000000</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">bitnesses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">64</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">bitnesses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">32</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">bitnesses</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_replace_symbol</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">symbol_name</span><span class="s3">, </span><span class="s1">replacement</span><span class="s3">, </span><span class="s1">bitness</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;We store a custom section in the binary file containing a header 
        containing offsets to the binary data. 
        If bitness is set, and the binary in question is a macOS universal 
        binary, it only replaces for binaries with the given bitness. &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s7">b'MZ'</span><span class="s3">):</span>
            <span class="s4"># A Windows PE file.</span>
            <span class="s1">pe </span><span class="s3">= </span><span class="s1">pefile</span><span class="s3">.</span><span class="s1">PEFile</span><span class="s3">()</span>
            <span class="s1">pe</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s1">io</span><span class="s3">.</span><span class="s1">BytesIO</span><span class="s3">(</span><span class="s1">data</span><span class="s3">))</span>
            <span class="s1">addr </span><span class="s3">= </span><span class="s1">pe</span><span class="s3">.</span><span class="s1">get_export_address</span><span class="s3">(</span><span class="s1">symbol_name</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">addr </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s4"># We found it, return its offset in the file.</span>
                <span class="s1">offset </span><span class="s3">= </span><span class="s1">pe</span><span class="s3">.</span><span class="s1">get_address_offset</span><span class="s3">(</span><span class="s1">addr</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">offset </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">data</span><span class="s3">[</span><span class="s1">offset</span><span class="s3">:</span><span class="s1">offset</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">)] = </span><span class="s1">replacement</span>
                    <span class="s2">return True</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s7">b&quot;</span><span class="s2">\177</span><span class="s7">ELF&quot;</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_replace_symbol_elf</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">symbol_name</span><span class="s3">, </span><span class="s1">replacement</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\xFE\xED\xFA\xCE</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xCE\xFA\xED\xFE</span><span class="s7">'</span><span class="s3">,</span>
                          <span class="s7">b'</span><span class="s2">\xFE\xED\xFA\xCF</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xCF\xFA\xED\xFE</span><span class="s7">'</span><span class="s3">):</span>
            <span class="s1">off </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_find_symbol_macho</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">symbol_name</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">off </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">data</span><span class="s3">[</span><span class="s1">off</span><span class="s3">:</span><span class="s1">off</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">)] = </span><span class="s1">replacement</span>
                <span class="s2">return True</span>
            <span class="s2">return False</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\xCA\xFE\xBA\xBE</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xBE\xBA\xFE\xCA</span><span class="s7">'</span><span class="s3">):</span>
            <span class="s4"># Universal binary with 32-bit offsets.</span>
            <span class="s1">num_fat</span><span class="s3">, = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&gt;I'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>
            <span class="s1">replaced </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s5">8</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_fat</span><span class="s3">):</span>
                <span class="s1">cputype</span><span class="s3">, </span><span class="s1">cpusubtype</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">align </span><span class="s3">= </span><span class="s1">\</span>
                    <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&gt;IIIII'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
                <span class="s1">ptr </span><span class="s3">+= </span><span class="s5">20</span>

                <span class="s4"># Does this match the requested bitness?</span>
                <span class="s2">if </span><span class="s1">bitness </span><span class="s2">is not None and </span><span class="s3">((</span><span class="s1">cputype </span><span class="s3">&amp; </span><span class="s5">0x1000000</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">) != (</span><span class="s1">bitness </span><span class="s3">== </span><span class="s5">64</span><span class="s3">):</span>
                    <span class="s2">continue</span>

                <span class="s1">macho_data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">offset</span><span class="s3">:</span><span class="s1">offset</span><span class="s3">+</span><span class="s1">size</span><span class="s3">]</span>
                <span class="s1">off </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_find_symbol_macho</span><span class="s3">(</span><span class="s1">macho_data</span><span class="s3">, </span><span class="s1">symbol_name</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">off </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">off </span><span class="s3">+= </span><span class="s1">offset</span>
                    <span class="s1">data</span><span class="s3">[</span><span class="s1">off</span><span class="s3">:</span><span class="s1">off</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">)] = </span><span class="s1">replacement</span>
                    <span class="s1">replaced </span><span class="s3">= </span><span class="s2">True</span>

            <span class="s2">return </span><span class="s1">replaced</span>

        <span class="s2">elif </span><span class="s1">data</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\xCA\xFE\xBA\xBF</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xBF\xBA\xFE\xCA</span><span class="s7">'</span><span class="s3">):</span>
            <span class="s4"># Universal binary with 64-bit offsets.</span>
            <span class="s1">num_fat</span><span class="s3">, = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&gt;I'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>
            <span class="s1">replaced </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s5">8</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_fat</span><span class="s3">):</span>
                <span class="s1">cputype</span><span class="s3">, </span><span class="s1">cpusubtype</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">align </span><span class="s3">= </span><span class="s1">\</span>
                    <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s6">'&gt;QQQQQ'</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">ptr</span><span class="s3">)</span>
                <span class="s1">ptr </span><span class="s3">+= </span><span class="s5">40</span>

                <span class="s4"># Does this match the requested bitness?</span>
                <span class="s2">if </span><span class="s1">bitness </span><span class="s2">is not None and </span><span class="s3">((</span><span class="s1">cputype </span><span class="s3">&amp; </span><span class="s5">0x1000000</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">) != (</span><span class="s1">bitness </span><span class="s3">== </span><span class="s5">64</span><span class="s3">):</span>
                    <span class="s2">continue</span>

                <span class="s1">macho_data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">offset</span><span class="s3">:</span><span class="s1">offset</span><span class="s3">+</span><span class="s1">size</span><span class="s3">]</span>
                <span class="s1">off </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_find_symbol_macho</span><span class="s3">(</span><span class="s1">macho_data</span><span class="s3">, </span><span class="s1">symbol_name</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">off </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">off </span><span class="s3">+= </span><span class="s1">offset</span>
                    <span class="s1">data</span><span class="s3">[</span><span class="s1">off</span><span class="s3">:</span><span class="s1">off</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">)] = </span><span class="s1">replacement</span>
                    <span class="s1">replaced </span><span class="s3">= </span><span class="s2">True</span>

            <span class="s2">return </span><span class="s1">replaced</span>

        <span class="s4"># We don't know what kind of file this is.</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_replace_symbol_elf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">elf_data</span><span class="s3">, </span><span class="s1">symbol_name</span><span class="s3">, </span><span class="s1">replacement</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; The Linux/FreeBSD implementation of _replace_symbol. &quot;&quot;&quot;</span>

        <span class="s1">replaced </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s4"># Make sure we read in the correct endianness and integer size</span>
        <span class="s1">endian </span><span class="s3">= </span><span class="s6">&quot;&lt;&gt;&quot;</span><span class="s3">[</span><span class="s1">ord</span><span class="s3">(</span><span class="s1">elf_data</span><span class="s3">[</span><span class="s5">5</span><span class="s3">:</span><span class="s5">6</span><span class="s3">]) - </span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">is_64bit </span><span class="s3">= </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">elf_data</span><span class="s3">[</span><span class="s5">4</span><span class="s3">:</span><span class="s5">5</span><span class="s3">]) - </span><span class="s5">1 </span><span class="s4"># 0 = 32-bits, 1 = 64-bits</span>
        <span class="s1">header_struct </span><span class="s3">= </span><span class="s1">endian </span><span class="s3">+ (</span><span class="s6">&quot;HHIIIIIHHHHHH&quot;</span><span class="s3">, </span><span class="s6">&quot;HHIQQQIHHHHHH&quot;</span><span class="s3">)[</span><span class="s1">is_64bit</span><span class="s3">]</span>
        <span class="s1">section_struct </span><span class="s3">= </span><span class="s1">endian </span><span class="s3">+ (</span><span class="s6">&quot;4xI4xIIII8xI&quot;</span><span class="s3">, </span><span class="s6">&quot;4xI8xQQQI12xQ&quot;</span><span class="s3">)[</span><span class="s1">is_64bit</span><span class="s3">]</span>
        <span class="s1">symbol_struct </span><span class="s3">= </span><span class="s1">endian </span><span class="s3">+ (</span><span class="s6">&quot;IIIBBH&quot;</span><span class="s3">, </span><span class="s6">&quot;IBBHQQ&quot;</span><span class="s3">)[</span><span class="s1">is_64bit</span><span class="s3">]</span>

        <span class="s1">header_size </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">calcsize</span><span class="s3">(</span><span class="s1">header_struct</span><span class="s3">)</span>
        <span class="s1">type</span><span class="s3">, </span><span class="s1">machine</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">, </span><span class="s1">phoff</span><span class="s3">, </span><span class="s1">shoff</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">ehsize</span><span class="s3">, </span><span class="s1">phentsize</span><span class="s3">, </span><span class="s1">phnum</span><span class="s3">, </span><span class="s1">shentsize</span><span class="s3">, </span><span class="s1">shnum</span><span class="s3">, </span><span class="s1">shstrndx \</span>
          <span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">header_struct</span><span class="s3">, </span><span class="s1">elf_data</span><span class="s3">, </span><span class="s5">16</span><span class="s3">)</span>
        <span class="s1">section_offsets </span><span class="s3">= []</span>
        <span class="s1">symbol_tables </span><span class="s3">= []</span>
        <span class="s1">string_tables </span><span class="s3">= {}</span>

        <span class="s4"># Seek to the section header table and find the symbol tables.</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">shoff</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">shnum</span><span class="s3">):</span>
            <span class="s1">type</span><span class="s3">, </span><span class="s1">addr</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">link</span><span class="s3">, </span><span class="s1">entsize </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">section_struct</span><span class="s3">, </span><span class="s1">elf_data</span><span class="s3">[</span><span class="s1">ptr</span><span class="s3">:</span><span class="s1">ptr</span><span class="s3">+</span><span class="s1">shentsize</span><span class="s3">])</span>
            <span class="s1">ptr </span><span class="s3">+= </span><span class="s1">shentsize</span>
            <span class="s1">section_offsets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">offset </span><span class="s3">- </span><span class="s1">addr</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">type </span><span class="s3">== </span><span class="s5">0x0B </span><span class="s2">and </span><span class="s1">link </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">: </span><span class="s4"># SHT_DYNSYM, links to string table</span>
                <span class="s1">symbol_tables</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">link</span><span class="s3">, </span><span class="s1">entsize</span><span class="s3">))</span>
                <span class="s1">string_tables</span><span class="s3">[</span><span class="s1">link</span><span class="s3">] = </span><span class="s2">None</span>

        <span class="s4"># Read the relevant string tables.</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">string_tables</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
            <span class="s1">ptr </span><span class="s3">= </span><span class="s1">shoff </span><span class="s3">+ </span><span class="s1">idx </span><span class="s3">* </span><span class="s1">shentsize</span>
            <span class="s1">type</span><span class="s3">, </span><span class="s1">addr</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">link</span><span class="s3">, </span><span class="s1">entsize </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">section_struct</span><span class="s3">, </span><span class="s1">elf_data</span><span class="s3">[</span><span class="s1">ptr</span><span class="s3">:</span><span class="s1">ptr</span><span class="s3">+</span><span class="s1">shentsize</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s1">type </span><span class="s3">== </span><span class="s5">3</span><span class="s3">:</span>
                <span class="s1">string_tables</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">elf_data</span><span class="s3">[</span><span class="s1">offset</span><span class="s3">:</span><span class="s1">offset</span><span class="s3">+</span><span class="s1">size</span><span class="s3">]</span>

        <span class="s4"># Loop through to find the offset of the &quot;blobinfo&quot; symbol.</span>
        <span class="s2">for </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">link</span><span class="s3">, </span><span class="s1">entsize </span><span class="s2">in </span><span class="s1">symbol_tables</span><span class="s3">:</span>
            <span class="s1">entries </span><span class="s3">= </span><span class="s1">size </span><span class="s3">// </span><span class="s1">entsize</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">entries</span><span class="s3">):</span>
                <span class="s1">ptr </span><span class="s3">= </span><span class="s1">offset </span><span class="s3">+ </span><span class="s1">i </span><span class="s3">* </span><span class="s1">entsize</span>
                <span class="s1">fields </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">symbol_struct</span><span class="s3">, </span><span class="s1">elf_data</span><span class="s3">[</span><span class="s1">ptr</span><span class="s3">:</span><span class="s1">ptr</span><span class="s3">+</span><span class="s1">entsize</span><span class="s3">])</span>
                <span class="s2">if </span><span class="s1">is_64bit</span><span class="s3">:</span>
                    <span class="s1">name</span><span class="s3">, </span><span class="s1">info</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">shndx</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">size </span><span class="s3">= </span><span class="s1">fields</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">info</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">shndx </span><span class="s3">= </span><span class="s1">fields</span>

                <span class="s2">if not </span><span class="s1">name</span><span class="s3">:</span>
                    <span class="s2">continue</span>

                <span class="s1">name </span><span class="s3">= </span><span class="s1">string_tables</span><span class="s3">[</span><span class="s1">link</span><span class="s3">][</span><span class="s1">name </span><span class="s3">: </span><span class="s1">string_tables</span><span class="s3">[</span><span class="s1">link</span><span class="s3">].</span><span class="s1">find</span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\0</span><span class="s7">'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)]</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s1">symbol_name</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">shndx </span><span class="s3">== </span><span class="s5">0</span><span class="s3">: </span><span class="s4"># SHN_UNDEF</span>
                        <span class="s2">continue</span>
                    <span class="s2">elif </span><span class="s1">shndx </span><span class="s3">&gt;= </span><span class="s5">0xff00 </span><span class="s2">and </span><span class="s1">shndx </span><span class="s3">&lt;= </span><span class="s5">0xffff</span><span class="s3">:</span>
                        <span class="s2">assert False</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s4"># Got it.  Make the replacement.</span>
                        <span class="s1">off </span><span class="s3">= </span><span class="s1">section_offsets</span><span class="s3">[</span><span class="s1">shndx</span><span class="s3">] + </span><span class="s1">value</span>
                        <span class="s1">elf_data</span><span class="s3">[</span><span class="s1">off</span><span class="s3">:</span><span class="s1">off</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">)] = </span><span class="s1">replacement</span>
                        <span class="s1">replaced </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">replaced</span>

    <span class="s2">def </span><span class="s1">_find_symbol_macho</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">macho_data</span><span class="s3">, </span><span class="s1">symbol_name</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Returns the offset of the given symbol in the binary file. &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">macho_data</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\xCE\xFA\xED\xFE</span><span class="s7">'</span><span class="s3">, </span><span class="s7">b'</span><span class="s2">\xCF\xFA\xED\xFE</span><span class="s7">'</span><span class="s3">):</span>
            <span class="s1">endian </span><span class="s3">= </span><span class="s6">'&lt;'</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">endian </span><span class="s3">= </span><span class="s6">'&gt;'</span>

        <span class="s1">cputype</span><span class="s3">, </span><span class="s1">cpusubtype</span><span class="s3">, </span><span class="s1">filetype</span><span class="s3">, </span><span class="s1">ncmds</span><span class="s3">, </span><span class="s1">sizeofcmds</span><span class="s3">, </span><span class="s1">flags </span><span class="s3">= </span><span class="s1">\</span>
            <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">endian </span><span class="s3">+ </span><span class="s6">'IIIIII'</span><span class="s3">, </span><span class="s1">macho_data</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>

        <span class="s1">is_64bit </span><span class="s3">= (</span><span class="s1">cputype </span><span class="s3">&amp; </span><span class="s5">0x1000000</span><span class="s3">) != </span><span class="s5">0</span>
        <span class="s1">segments </span><span class="s3">= []</span>

        <span class="s1">cmd_ptr </span><span class="s3">= </span><span class="s5">28</span>
        <span class="s1">nlist_struct </span><span class="s3">= </span><span class="s1">endian </span><span class="s3">+ </span><span class="s6">'IBBHI'</span>
        <span class="s2">if </span><span class="s1">is_64bit</span><span class="s3">:</span>
            <span class="s1">nlist_struct </span><span class="s3">= </span><span class="s1">endian </span><span class="s3">+ </span><span class="s6">'IBBHQ'</span>
            <span class="s1">cmd_ptr </span><span class="s3">+= </span><span class="s5">4</span>
        <span class="s1">nlist_size </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">calcsize</span><span class="s3">(</span><span class="s1">nlist_struct</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ncmds</span><span class="s3">):</span>
            <span class="s1">cmd</span><span class="s3">, </span><span class="s1">cmd_size </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">endian </span><span class="s3">+ </span><span class="s6">'II'</span><span class="s3">, </span><span class="s1">macho_data</span><span class="s3">, </span><span class="s1">cmd_ptr</span><span class="s3">)</span>
            <span class="s1">cmd_data </span><span class="s3">= </span><span class="s1">macho_data</span><span class="s3">[</span><span class="s1">cmd_ptr</span><span class="s3">+</span><span class="s5">8</span><span class="s3">:</span><span class="s1">cmd_ptr</span><span class="s3">+</span><span class="s1">cmd_size</span><span class="s3">]</span>
            <span class="s1">cmd_ptr </span><span class="s3">+= </span><span class="s1">cmd_size</span>

            <span class="s1">cmd </span><span class="s3">&amp;= ~</span><span class="s5">0x80000000</span>

            <span class="s2">if </span><span class="s1">cmd </span><span class="s3">== </span><span class="s5">0x01</span><span class="s3">: </span><span class="s4"># LC_SEGMENT</span>
                <span class="s1">segname</span><span class="s3">, </span><span class="s1">vmaddr</span><span class="s3">, </span><span class="s1">vmsize</span><span class="s3">, </span><span class="s1">fileoff</span><span class="s3">, </span><span class="s1">filesize</span><span class="s3">, </span><span class="s1">maxprot</span><span class="s3">, </span><span class="s1">initprot</span><span class="s3">, </span><span class="s1">nsects</span><span class="s3">, </span><span class="s1">flags </span><span class="s3">= </span><span class="s1">\</span>
                    <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">endian </span><span class="s3">+ </span><span class="s6">'16sIIIIIIII'</span><span class="s3">, </span><span class="s1">cmd_data</span><span class="s3">)</span>
                <span class="s1">segments</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">vmaddr</span><span class="s3">, </span><span class="s1">vmsize</span><span class="s3">, </span><span class="s1">fileoff</span><span class="s3">))</span>

            <span class="s2">elif </span><span class="s1">cmd </span><span class="s3">== </span><span class="s5">0x19</span><span class="s3">: </span><span class="s4"># LC_SEGMENT_64</span>
                <span class="s1">segname</span><span class="s3">, </span><span class="s1">vmaddr</span><span class="s3">, </span><span class="s1">vmsize</span><span class="s3">, </span><span class="s1">fileoff</span><span class="s3">, </span><span class="s1">filesize</span><span class="s3">, </span><span class="s1">maxprot</span><span class="s3">, </span><span class="s1">initprot</span><span class="s3">, </span><span class="s1">nsects</span><span class="s3">, </span><span class="s1">flags </span><span class="s3">= </span><span class="s1">\</span>
                    <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">endian </span><span class="s3">+ </span><span class="s6">'16sQQQQIIII'</span><span class="s3">, </span><span class="s1">cmd_data</span><span class="s3">)</span>
                <span class="s1">segments</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">vmaddr</span><span class="s3">, </span><span class="s1">vmsize</span><span class="s3">, </span><span class="s1">fileoff</span><span class="s3">))</span>

            <span class="s2">elif </span><span class="s1">cmd </span><span class="s3">== </span><span class="s5">0x2</span><span class="s3">: </span><span class="s4"># LC_SYMTAB</span>
                <span class="s1">symoff</span><span class="s3">, </span><span class="s1">nsyms</span><span class="s3">, </span><span class="s1">stroff</span><span class="s3">, </span><span class="s1">strsize </span><span class="s3">= </span><span class="s1">\</span>
                    <span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">endian </span><span class="s3">+ </span><span class="s6">'IIII'</span><span class="s3">, </span><span class="s1">cmd_data</span><span class="s3">)</span>

                <span class="s1">strings </span><span class="s3">= </span><span class="s1">macho_data</span><span class="s3">[</span><span class="s1">stroff</span><span class="s3">:</span><span class="s1">stroff</span><span class="s3">+</span><span class="s1">strsize</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nsyms</span><span class="s3">):</span>
                    <span class="s1">strx</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">sect</span><span class="s3">, </span><span class="s1">desc</span><span class="s3">, </span><span class="s1">value </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">nlist_struct</span><span class="s3">, </span><span class="s1">macho_data</span><span class="s3">, </span><span class="s1">symoff</span><span class="s3">)</span>
                    <span class="s1">symoff </span><span class="s3">+= </span><span class="s1">nlist_size</span>
                    <span class="s1">name </span><span class="s3">= </span><span class="s1">strings</span><span class="s3">[</span><span class="s1">strx </span><span class="s3">: </span><span class="s1">strings</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s7">b'</span><span class="s2">\0</span><span class="s7">'</span><span class="s3">, </span><span class="s1">strx</span><span class="s3">)]</span>

                    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s7">b'_' </span><span class="s3">+ </span><span class="s1">symbol_name</span><span class="s3">:</span>
                        <span class="s4"># Find out in which segment this is.</span>
                        <span class="s2">for </span><span class="s1">vmaddr</span><span class="s3">, </span><span class="s1">vmsize</span><span class="s3">, </span><span class="s1">fileoff </span><span class="s2">in </span><span class="s1">segments</span><span class="s3">:</span>
                            <span class="s4"># Is it defined in this segment?</span>
                            <span class="s1">rel </span><span class="s3">= </span><span class="s1">value </span><span class="s3">- </span><span class="s1">vmaddr</span>
                            <span class="s2">if </span><span class="s1">rel </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">rel </span><span class="s3">&lt; </span><span class="s1">vmsize</span><span class="s3">:</span>
                                <span class="s4"># Yes, so return the symbol offset.</span>
                                <span class="s2">return </span><span class="s1">fileoff </span><span class="s3">+ </span><span class="s1">rel</span>
                        <span class="s1">print</span><span class="s3">(</span><span class="s6">&quot;Could not find memory address for symbol %s&quot; </span><span class="s3">% (</span><span class="s1">symbol_name</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">makeModuleDef</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mangledName</span><span class="s3">, </span><span class="s1">code</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s6">''</span>
        <span class="s1">result </span><span class="s3">+= </span><span class="s6">'static unsigned char %s[] = {' </span><span class="s3">% (</span><span class="s1">mangledName</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">code</span><span class="s3">), </span><span class="s5">16</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">+= </span><span class="s6">'</span><span class="s2">\n  </span><span class="s6">'</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">code</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:</span><span class="s1">i</span><span class="s3">+</span><span class="s5">16</span><span class="s3">]:</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">int</span><span class="s3">): </span><span class="s4"># Python 3</span>
                    <span class="s1">result </span><span class="s3">+= (</span><span class="s6">'%d,' </span><span class="s3">% </span><span class="s1">c</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">: </span><span class="s4"># Python 2</span>
                    <span class="s1">result </span><span class="s3">+= (</span><span class="s6">'%d,' </span><span class="s3">% </span><span class="s1">ord</span><span class="s3">(</span><span class="s1">c</span><span class="s3">))</span>
        <span class="s1">result </span><span class="s3">+= </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">};</span><span class="s2">\n</span><span class="s6">'</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">makeModuleListEntry</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mangledName</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">code</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s6">&quot;__path__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">):</span>
            <span class="s4"># Indicate package by negative size</span>
            <span class="s1">size </span><span class="s3">= -</span><span class="s1">size</span>
        <span class="s2">return </span><span class="s6">'  {&quot;%s&quot;, %s, %s},' </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">, </span><span class="s1">mangledName</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">makeForbiddenModuleListEntry</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s6">'  {&quot;%s&quot;, NULL, 0},' </span><span class="s3">% (</span><span class="s1">moduleName</span><span class="s3">)</span>


    <span class="s2">def </span><span class="s1">__writingModule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">moduleName</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Returns true if we are outputting the named module in this 
        pass, false if we have already output in a previous pass, or 
        if it is not yet on the output table. &quot;&quot;&quot;</span>

        <span class="s1">mdef </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">moduleName</span><span class="s3">, (</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">mdef</span><span class="s3">.</span><span class="s1">exclude</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">moduleName </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">previousModules</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s2">return True</span>


<span class="s1">_PKG_NAMESPACE_DIRECTORY </span><span class="s3">= </span><span class="s1">object</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">PandaModuleFinder</span><span class="s3">(</span><span class="s1">modulefinder</span><span class="s3">.</span><span class="s1">ModuleFinder</span><span class="s3">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kw</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param path: search path to look on, defaults to sys.path 
        :param suffixes: defaults to imp.get_suffixes() 
        :param excludes: a list of modules to exclude 
        :param debug: an integer indicating the level of verbosity 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">suffixes </span><span class="s3">= </span><span class="s1">kw</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s6">'suffixes'</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">get_suffixes</span><span class="s3">())</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">optimize </span><span class="s3">= </span><span class="s1">kw</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s6">'optimize'</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>

        <span class="s1">modulefinder</span><span class="s3">.</span><span class="s1">ModuleFinder</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kw</span><span class="s3">)</span>

        <span class="s4"># Make sure we don't open a .whl/.zip file more than once.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_zip_files </span><span class="s3">= {}</span>

    <span class="s2">def </span><span class="s1">_open_file</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Opens a module at the given path, which may contain a zip file. 
        Returns None if the module could not be found. &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s6">'b' </span><span class="s2">not in </span><span class="s1">mode</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">io</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s6">'utf8'</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">open</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)</span>

        <span class="s4"># Is there a zip file along the path?</span>
        <span class="s1">dir</span><span class="s3">, </span><span class="s1">dirname </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">dirname</span>
        <span class="s2">while </span><span class="s1">dirname</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">):</span>
                <span class="s4"># Okay, this is actually a file.  Is it a zip file?</span>
                <span class="s2">if </span><span class="s1">dir </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_zip_files</span><span class="s3">:</span>
                    <span class="s4"># Yes, and we've previously opened this.</span>
                    <span class="s1">zip </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_zip_files</span><span class="s3">[</span><span class="s1">dir</span><span class="s3">]</span>
                <span class="s2">elif </span><span class="s1">zipfile</span><span class="s3">.</span><span class="s1">is_zipfile</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">):</span>
                    <span class="s1">zip </span><span class="s3">= </span><span class="s1">zipfile</span><span class="s3">.</span><span class="s1">ZipFile</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_zip_files</span><span class="s3">[</span><span class="s1">dir</span><span class="s3">] = </span><span class="s1">zip</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s4"># It's a different kind of file.  Stop looking.</span>
                    <span class="s2">return None</span>

                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">zip_fn </span><span class="s3">= </span><span class="s1">fn</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">sep</span><span class="s3">, </span><span class="s6">'/'</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">zip_fn</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">'deploy_libs/_tkinter.'</span><span class="s3">):</span>
                        <span class="s4"># If we have a tkinter wheel on the path, ignore the</span>
                        <span class="s4"># _tkinter extension in deploy-libs.</span>
                        <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s6">&quot;.whl&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">).</span><span class="s1">startswith</span><span class="s3">(</span><span class="s6">&quot;tkinter-&quot;</span><span class="s3">) </span><span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">path</span><span class="s3">):</span>
                            <span class="s2">return None</span>
                    <span class="s1">fp </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">zip_fn</span><span class="s3">, </span><span class="s6">'r'</span><span class="s3">)</span>
                <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                    <span class="s2">return None</span>

                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) </span><span class="s2">and </span><span class="s6">'b' </span><span class="s2">not in </span><span class="s1">mode</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">io</span><span class="s3">.</span><span class="s1">TextIOWrapper</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s6">'utf8'</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">fp</span>

            <span class="s4"># Look at the parent directory.</span>
            <span class="s1">dir</span><span class="s3">, </span><span class="s1">dirname </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">)</span>
            <span class="s1">fn </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirname</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">)</span>

        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_dir_exists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns True if the given directory exists, either on disk or inside 
        a wheel.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">):</span>
            <span class="s2">return True</span>

        <span class="s4"># Is there a zip file along the path?</span>
        <span class="s1">dir</span><span class="s3">, </span><span class="s1">dirname </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">path</span><span class="s3">.</span><span class="s1">rstrip</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">sep </span><span class="s3">+ </span><span class="s6">'/'</span><span class="s3">))</span>
        <span class="s1">fn </span><span class="s3">= </span><span class="s1">dirname</span>
        <span class="s2">while </span><span class="s1">dirname</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">):</span>
                <span class="s4"># Okay, this is actually a file.  Is it a zip file?</span>
                <span class="s2">if </span><span class="s1">dir </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_zip_files</span><span class="s3">:</span>
                    <span class="s4"># Yes, and we've previously opened this.</span>
                    <span class="s1">zip </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_zip_files</span><span class="s3">[</span><span class="s1">dir</span><span class="s3">]</span>
                <span class="s2">elif </span><span class="s1">zipfile</span><span class="s3">.</span><span class="s1">is_zipfile</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">):</span>
                    <span class="s1">zip </span><span class="s3">= </span><span class="s1">zipfile</span><span class="s3">.</span><span class="s1">ZipFile</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_zip_files</span><span class="s3">[</span><span class="s1">dir</span><span class="s3">] = </span><span class="s1">zip</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s4"># It's a different kind of file.  Stop looking.</span>
                    <span class="s2">return None</span>

                <span class="s4"># (Most) zip files do not store directories; check instead for a</span>
                <span class="s4"># file whose path starts with this directory name.</span>
                <span class="s1">prefix </span><span class="s3">= </span><span class="s1">fn</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">sep</span><span class="s3">, </span><span class="s6">'/'</span><span class="s3">) + </span><span class="s6">'/'</span>
                <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">.</span><span class="s1">namelist</span><span class="s3">():</span>
                    <span class="s2">if </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">):</span>
                        <span class="s2">return True</span>

                <span class="s2">return False</span>

            <span class="s4"># Look at the parent directory.</span>
            <span class="s1">dir</span><span class="s3">, </span><span class="s1">dirname </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">)</span>
            <span class="s1">fn </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirname</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">)</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">load_module</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fqname</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">file_info</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Copied from ModuleFinder.load_module with fixes to handle sending bytes 
        to compile() for PY_SOURCE types. Sending bytes to compile allows it to 
        handle file encodings.&quot;&quot;&quot;</span>

        <span class="s1">suffix</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">type </span><span class="s3">= </span><span class="s1">file_info</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">msgin</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;load_module&quot;</span><span class="s3">, </span><span class="s1">fqname</span><span class="s3">, </span><span class="s1">fp </span><span class="s2">and </span><span class="s6">&quot;fp&quot;</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">type </span><span class="s3">== </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PKG_DIRECTORY</span><span class="s3">:</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">load_package</span><span class="s3">(</span><span class="s1">fqname</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">msgout</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;load_module -&gt;&quot;</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">m</span>

        <span class="s2">if </span><span class="s1">type </span><span class="s2">is </span><span class="s1">_PKG_NAMESPACE_DIRECTORY</span><span class="s3">:</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">add_module</span><span class="s3">(</span><span class="s1">fqname</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">):</span>
                <span class="s1">m</span><span class="s3">.</span><span class="s1">__code__ </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s6">''</span><span class="s3">, </span><span class="s6">''</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">m</span><span class="s3">.</span><span class="s1">__code__ </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s6">''</span><span class="s3">, </span><span class="s6">''</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">)</span>
            <span class="s1">m</span><span class="s3">.</span><span class="s1">__path__ </span><span class="s3">= </span><span class="s1">pathname</span>
            <span class="s2">return </span><span class="s1">m</span>

        <span class="s2">if </span><span class="s1">type </span><span class="s3">== </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PY_SOURCE</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">fqname </span><span class="s2">in </span><span class="s1">overrideModules</span><span class="s3">:</span>
                <span class="s4"># This module has a custom override.</span>
                <span class="s1">code </span><span class="s3">= </span><span class="s1">overrideModules</span><span class="s3">[</span><span class="s1">fqname</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">code </span><span class="s3">= </span><span class="s1">fp</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>

            <span class="s1">code </span><span class="s3">+= </span><span class="s7">b'</span><span class="s2">\n</span><span class="s7">' </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">code</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">) </span><span class="s2">else </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">):</span>
                <span class="s1">co </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">code</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">co </span><span class="s3">= </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">code</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s6">'exec'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">type </span><span class="s3">== </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PY_COMPILED</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s3">):</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">data </span><span class="s3">= </span><span class="s1">fp</span><span class="s3">.</span><span class="s1">read</span><span class="s3">()</span>
                    <span class="s1">importlib</span><span class="s3">.</span><span class="s1">_bootstrap_external</span><span class="s3">.</span><span class="s1">_classify_pyc</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">fqname</span><span class="s3">, {})</span>
                <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">msgout</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;raise ImportError: &quot; </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">), </span><span class="s1">pathname</span><span class="s3">)</span>
                    <span class="s2">raise</span>

                <span class="s1">co </span><span class="s3">= </span><span class="s1">marshal</span><span class="s3">.</span><span class="s1">loads</span><span class="s3">(</span><span class="s1">memoryview</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)[</span><span class="s5">16</span><span class="s3">:])</span>
            <span class="s2">elif </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">):</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">):</span>
                        <span class="s1">marshal_data </span><span class="s3">= </span><span class="s1">importlib</span><span class="s3">.</span><span class="s1">_bootstrap_external</span><span class="s3">.</span><span class="s1">_validate_bytecode_header</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">.</span><span class="s1">read</span><span class="s3">())</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">marshal_data </span><span class="s3">= </span><span class="s1">importlib</span><span class="s3">.</span><span class="s1">_bootstrap</span><span class="s3">.</span><span class="s1">_validate_bytecode_header</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">.</span><span class="s1">read</span><span class="s3">())</span>
                <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">msgout</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;raise ImportError: &quot; </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">), </span><span class="s1">pathname</span><span class="s3">)</span>
                    <span class="s2">raise</span>

                <span class="s1">co </span><span class="s3">= </span><span class="s1">marshal</span><span class="s3">.</span><span class="s1">loads</span><span class="s3">(</span><span class="s1">marshal_data</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">fp</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s5">4</span><span class="s3">) != </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">get_magic</span><span class="s3">():</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">msgout</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;raise ImportError: Bad magic number&quot;</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">)</span>
                    <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s6">&quot;Bad magic number in %s&quot; </span><span class="s3">% </span><span class="s1">pathname</span><span class="s3">)</span>

                <span class="s1">fp</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s5">4</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">):</span>
                    <span class="s1">fp</span><span class="s3">.</span><span class="s1">read</span><span class="s3">(</span><span class="s5">4</span><span class="s3">)</span>

                <span class="s1">co </span><span class="s3">= </span><span class="s1">marshal</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">co </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s1">m </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">add_module</span><span class="s3">(</span><span class="s1">fqname</span><span class="s3">)</span>
        <span class="s1">m</span><span class="s3">.</span><span class="s1">__file__ </span><span class="s3">= </span><span class="s1">pathname</span>
        <span class="s2">if </span><span class="s1">co</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">replace_paths</span><span class="s3">:</span>
                <span class="s1">co </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">replace_paths_in_code</span><span class="s3">(</span><span class="s1">co</span><span class="s3">)</span>
            <span class="s1">m</span><span class="s3">.</span><span class="s1">__code__ </span><span class="s3">= </span><span class="s1">co</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">scan_code</span><span class="s3">(</span><span class="s1">co</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">msgout</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;load_module -&gt;&quot;</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">m</span>

    <span class="s4"># This function is provided here since the Python library version has a bug</span>
    <span class="s4"># (see bpo-35376)</span>
    <span class="s2">def </span><span class="s1">_safe_import_hook</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">caller</span><span class="s3">, </span><span class="s1">fromlist</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">):</span>
        <span class="s4"># wrapper for self.import_hook() that won't raise ImportError</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">badmodules</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_badmodule</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">caller</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">level </span><span class="s3">&lt;= </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">caller </span><span class="s2">and </span><span class="s1">caller</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">in </span><span class="s1">ignoreImports</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">ignoreImports</span><span class="s3">[</span><span class="s1">caller</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">]:</span>
                <span class="s2">return</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">import_hook</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">caller</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">msg</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">msg</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;ImportError:&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_badmodule</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">caller</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">SyntaxError </span><span class="s2">as </span><span class="s1">msg</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">msg</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;SyntaxError:&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_badmodule</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">caller</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">fromlist</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">sub </span><span class="s2">in </span><span class="s1">fromlist</span><span class="s3">:</span>
                    <span class="s1">fullname </span><span class="s3">= </span><span class="s1">name </span><span class="s3">+ </span><span class="s6">&quot;.&quot; </span><span class="s3">+ </span><span class="s1">sub</span>
                    <span class="s2">if </span><span class="s1">fullname </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">badmodules</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_badmodule</span><span class="s3">(</span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">caller</span><span class="s3">)</span>
                        <span class="s2">continue</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">import_hook</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">caller</span><span class="s3">, [</span><span class="s1">sub</span><span class="s3">], </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">)</span>
                    <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">msg</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">msg</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;ImportError:&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">))</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_badmodule</span><span class="s3">(</span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">caller</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">scan_code</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">co</span><span class="s3">, </span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">code </span><span class="s3">= </span><span class="s1">co</span><span class="s3">.</span><span class="s1">co_code</span>
        <span class="s4"># This was renamed to scan_opcodes in Python 3.6</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s6">'scan_opcodes_25'</span><span class="s3">):</span>
            <span class="s1">scanner </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scan_opcodes_25</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">scanner </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scan_opcodes</span>

        <span class="s2">for </span><span class="s1">what</span><span class="s3">, </span><span class="s1">args </span><span class="s2">in </span><span class="s1">scanner</span><span class="s3">(</span><span class="s1">co</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">what </span><span class="s3">== </span><span class="s6">&quot;store&quot;</span><span class="s3">:</span>
                <span class="s1">name</span><span class="s3">, = </span><span class="s1">args</span>
                <span class="s1">m</span><span class="s3">.</span><span class="s1">globalnames</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s5">1</span>
            <span class="s2">elif </span><span class="s1">what </span><span class="s2">in </span><span class="s3">(</span><span class="s6">&quot;import&quot;</span><span class="s3">, </span><span class="s6">&quot;absolute_import&quot;</span><span class="s3">):</span>
                <span class="s1">fromlist</span><span class="s3">, </span><span class="s1">name </span><span class="s3">= </span><span class="s1">args</span>
                <span class="s1">have_star </span><span class="s3">= </span><span class="s5">0</span>
                <span class="s2">if </span><span class="s1">fromlist </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s6">&quot;*&quot; </span><span class="s2">in </span><span class="s1">fromlist</span><span class="s3">:</span>
                        <span class="s1">have_star </span><span class="s3">= </span><span class="s5">1</span>
                    <span class="s1">fromlist </span><span class="s3">= [</span><span class="s1">f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fromlist </span><span class="s2">if </span><span class="s1">f </span><span class="s3">!= </span><span class="s6">&quot;*&quot;</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">what </span><span class="s3">== </span><span class="s6">&quot;absolute_import&quot;</span><span class="s3">: </span><span class="s1">level </span><span class="s3">= </span><span class="s5">0</span>
                <span class="s2">else</span><span class="s3">: </span><span class="s1">level </span><span class="s3">= -</span><span class="s5">1</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_safe_import_hook</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">fromlist</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">have_star</span><span class="s3">:</span>
                    <span class="s4"># We've encountered an &quot;import *&quot;. If it is a Python module,</span>
                    <span class="s4"># the code has already been parsed and we can suck out the</span>
                    <span class="s4"># global names.</span>
                    <span class="s1">mm </span><span class="s3">= </span><span class="s2">None</span>
                    <span class="s2">if </span><span class="s1">m</span><span class="s3">.</span><span class="s1">__path__</span><span class="s3">:</span>
                        <span class="s4"># At this point we don't know whether 'name' is a</span>
                        <span class="s4"># submodule of 'm' or a global module. Let's just try</span>
                        <span class="s4"># the full name first.</span>
                        <span class="s1">mm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">+ </span><span class="s6">&quot;.&quot; </span><span class="s3">+ </span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">mm </span><span class="s2">is None</span><span class="s3">:</span>
                        <span class="s1">mm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">mm </span><span class="s2">is not None</span><span class="s3">:</span>
                        <span class="s1">m</span><span class="s3">.</span><span class="s1">globalnames</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">mm</span><span class="s3">.</span><span class="s1">globalnames</span><span class="s3">)</span>
                        <span class="s1">m</span><span class="s3">.</span><span class="s1">starimports</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">mm</span><span class="s3">.</span><span class="s1">starimports</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">mm</span><span class="s3">.</span><span class="s1">__code__ </span><span class="s2">is None</span><span class="s3">:</span>
                            <span class="s1">m</span><span class="s3">.</span><span class="s1">starimports</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s5">1</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">m</span><span class="s3">.</span><span class="s1">starimports</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s5">1</span>
            <span class="s2">elif </span><span class="s1">what </span><span class="s3">== </span><span class="s6">&quot;relative_import&quot;</span><span class="s3">:</span>
                <span class="s1">level</span><span class="s3">, </span><span class="s1">fromlist</span><span class="s3">, </span><span class="s1">name </span><span class="s3">= </span><span class="s1">args</span>
                <span class="s1">parent </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">determine_parent</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">name</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_safe_import_hook</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">fromlist</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_safe_import_hook</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">fromlist</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">fromlist </span><span class="s2">and </span><span class="s6">&quot;*&quot; </span><span class="s2">in </span><span class="s1">fromlist</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">name</span><span class="s3">:</span>
                        <span class="s1">mm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">+ </span><span class="s6">&quot;.&quot; </span><span class="s3">+ </span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">mm </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">)</span>

                    <span class="s2">if </span><span class="s1">mm </span><span class="s2">is not None</span><span class="s3">:</span>
                        <span class="s1">m</span><span class="s3">.</span><span class="s1">globalnames</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">mm</span><span class="s3">.</span><span class="s1">globalnames</span><span class="s3">)</span>
                        <span class="s1">m</span><span class="s3">.</span><span class="s1">starimports</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">mm</span><span class="s3">.</span><span class="s1">starimports</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">mm</span><span class="s3">.</span><span class="s1">__code__ </span><span class="s2">is None</span><span class="s3">:</span>
                            <span class="s1">m</span><span class="s3">.</span><span class="s1">starimports</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s5">1</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">m</span><span class="s3">.</span><span class="s1">starimports</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># We don't expect anything else from the generator.</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s1">what</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">co</span><span class="s3">.</span><span class="s1">co_consts</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">type</span><span class="s3">(</span><span class="s1">co</span><span class="s3">)):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">scan_code</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">find_module</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">path</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Finds a module with the indicated name on the given search path 
        (or self.path if None).  Returns a tuple like (fp, path, stuff), where 
        stuff is a tuple like (suffix, mode, type). &quot;&quot;&quot;</span>

        <span class="s4">#if imp.is_frozen(name):</span>
        <span class="s4">#    # Don't pick up modules that are frozen into p3dpython.</span>
        <span class="s4">#    raise ImportError(&quot;'%s' is a frozen module&quot; % (name))</span>

        <span class="s2">if </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">fullname </span><span class="s3">= </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">+</span><span class="s6">'.'</span><span class="s3">+</span><span class="s1">name</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">fullname </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s2">if </span><span class="s1">fullname </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">excludes</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s4"># If we have a custom override for this module, we know we have it.</span>
        <span class="s2">if </span><span class="s1">fullname </span><span class="s2">in </span><span class="s1">overrideModules</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s6">''</span><span class="s3">, (</span><span class="s6">'.py'</span><span class="s3">, </span><span class="s6">'r'</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PY_SOURCE</span><span class="s3">))</span>

        <span class="s4"># If no search path is given, look for a built-in module.</span>
        <span class="s2">if </span><span class="s1">path </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">builtin_module_names</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, (</span><span class="s6">''</span><span class="s3">, </span><span class="s6">''</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">C_BUILTIN</span><span class="s3">))</span>

            <span class="s1">path </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">path</span>

            <span class="s2">if </span><span class="s1">fullname </span><span class="s3">== </span><span class="s6">'distutils' </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s6">'real_prefix'</span><span class="s3">):</span>
                <span class="s4"># The PyPI version of virtualenv inserts a special version of</span>
                <span class="s4"># distutils that does some bizarre stuff that won't work in our</span>
                <span class="s4"># deployed application.  Force it to find the regular one.</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">fp</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">stuff </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">find_module</span><span class="s3">(</span><span class="s6">'opcode'</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">fn</span><span class="s3">:</span>
                        <span class="s1">path </span><span class="s3">= [</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">)] + </span><span class="s1">path</span>
                <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
                    <span class="s2">pass</span>

        <span class="s4"># Look for the module on the search path.</span>
        <span class="s1">ns_dirs </span><span class="s3">= []</span>

        <span class="s2">for </span><span class="s1">dir_path </span><span class="s2">in </span><span class="s1">path</span><span class="s3">:</span>
            <span class="s1">basename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dir_path</span><span class="s3">, </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s6">'.'</span><span class="s3">)[-</span><span class="s5">1</span><span class="s3">])</span>

            <span class="s4"># Look for recognized extensions.</span>
            <span class="s2">for </span><span class="s1">stuff </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">suffixes</span><span class="s3">:</span>
                <span class="s1">suffix</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">stuff</span>
                <span class="s1">fp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_open_file</span><span class="s3">(</span><span class="s1">basename </span><span class="s3">+ </span><span class="s1">suffix</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">fp</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s3">(</span><span class="s1">fp</span><span class="s3">, </span><span class="s1">basename </span><span class="s3">+ </span><span class="s1">suffix</span><span class="s3">, </span><span class="s1">stuff</span><span class="s3">)</span>

            <span class="s4"># Consider a package, i.e. a directory containing __init__.py.</span>
            <span class="s2">for </span><span class="s1">suffix</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">suffixes</span><span class="s3">:</span>
                <span class="s1">init </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">basename</span><span class="s3">, </span><span class="s6">'__init__' </span><span class="s3">+ </span><span class="s1">suffix</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_open_file</span><span class="s3">(</span><span class="s1">init</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">, (</span><span class="s6">''</span><span class="s3">, </span><span class="s6">''</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PKG_DIRECTORY</span><span class="s3">))</span>

            <span class="s4"># This may be a namespace package.</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_dir_exists</span><span class="s3">(</span><span class="s1">basename</span><span class="s3">):</span>
                <span class="s1">ns_dirs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">basename</span><span class="s3">)</span>

        <span class="s4"># It wasn't found through the normal channels.  Maybe it's one of</span>
        <span class="s4"># ours, or maybe it's frozen?</span>
        <span class="s2">if not </span><span class="s1">path</span><span class="s3">:</span>
            <span class="s4"># Only if we're not looking on a particular path, though.</span>
            <span class="s2">if </span><span class="s1">p3extend_frozen </span><span class="s2">and </span><span class="s1">p3extend_frozen</span><span class="s3">.</span><span class="s1">is_frozen_module</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
                <span class="s4"># It's a frozen module.</span>
                <span class="s2">return </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, (</span><span class="s6">''</span><span class="s3">, </span><span class="s6">''</span><span class="s3">, </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">PY_FROZEN</span><span class="s3">))</span>

        <span class="s4"># If we found folders on the path with this module name without an</span>
        <span class="s4"># __init__.py file, we should consider this a namespace package.</span>
        <span class="s2">if </span><span class="s1">ns_dirs </span><span class="s2">and </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">ns_dirs</span><span class="s3">, (</span><span class="s6">''</span><span class="s3">, </span><span class="s6">''</span><span class="s3">, </span><span class="s1">_PKG_NAMESPACE_DIRECTORY</span><span class="s3">))</span>

        <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">find_all_submodules</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">m</span><span class="s3">):</span>
        <span class="s4"># Overridden so that we can define our own suffixes.</span>
        <span class="s2">if not </span><span class="s1">m</span><span class="s3">.</span><span class="s1">__path__</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">modules </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">dir </span><span class="s2">in </span><span class="s1">m</span><span class="s3">.</span><span class="s1">__path__</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">names </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">listdir</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">OSError</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">msg</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s6">&quot;can't list directory&quot;</span><span class="s3">, </span><span class="s1">dir</span><span class="s3">)</span>
                <span class="s2">continue</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">names</span><span class="s3">):</span>
                <span class="s1">mod </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s2">for </span><span class="s1">suff </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">suffixes</span><span class="s3">:</span>
                    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">suff</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">name</span><span class="s3">[-</span><span class="s1">n</span><span class="s3">:] == </span><span class="s1">suff</span><span class="s3">:</span>
                        <span class="s1">mod </span><span class="s3">= </span><span class="s1">name</span><span class="s3">[:-</span><span class="s1">n</span><span class="s3">]</span>
                        <span class="s2">break</span>
                <span class="s2">if </span><span class="s1">mod </span><span class="s2">and </span><span class="s1">mod </span><span class="s3">!= </span><span class="s6">&quot;__init__&quot;</span><span class="s3">:</span>
                    <span class="s1">modules</span><span class="s3">[</span><span class="s1">mod</span><span class="s3">] = </span><span class="s1">mod</span>
        <span class="s2">return </span><span class="s1">modules</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>
</pre>
</body>
</html>