<html>
<head>
<title>shaders.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
shaders.py</font>
</center></td></tr></table>
<pre><span class="s0">shaders</span><span class="s1">={</span><span class="s2">'tonemap.frag'</span><span class="s1">: </span><span class="s2">'#version 120</span><span class="s3">\n\n</span><span class="s2">uniform sampler2D tex;</span><span class="s3">\n</span><span class="s2">uniform float exposure;</span><span class="s3">\n\n</span><span class="s2">varying vec2 v_texcoord;</span><span class="s3">\n\n</span><span class="s2">#ifdef USE_330</span><span class="s3">\n</span><span class="s2">out vec4 o_color;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">void main() {</span><span class="s3">\n    </span><span class="s2">vec3 color = texture2D(tex, v_texcoord).rgb;</span><span class="s3">\n\n    </span><span class="s2">color *= exposure;</span><span class="s3">\n    </span><span class="s2">color = max(vec3(0.0), color - vec3(0.004));</span><span class="s3">\n    </span><span class="s2">color = (color * (vec3(6.2) * color + vec3(0.5))) / (color * (vec3(6.2) * color + vec3(1.7)) + vec3(0.06));</span><span class="s3">\n\n</span><span class="s2">#ifdef USE_330</span><span class="s3">\n    </span><span class="s2">o_color = vec4(color, 1.0);</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">gl_FragColor = vec4(color, 1.0);</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">, </span><span class="s2">'post.vert'</span><span class="s1">: </span><span class="s2">'#version 120</span><span class="s3">\n\n</span><span class="s2">uniform mat4 p3d_ModelViewProjectionMatrix;</span><span class="s3">\n\n</span><span class="s2">attribute vec4 p3d_Vertex;</span><span class="s3">\n</span><span class="s2">attribute vec2 p3d_MultiTexCoord0;</span><span class="s3">\n\n</span><span class="s2">varying vec2 v_texcoord;</span><span class="s3">\n\n</span><span class="s2">void main() {</span><span class="s3">\n    </span><span class="s2">v_texcoord = p3d_MultiTexCoord0;</span><span class="s3">\n    </span><span class="s2">gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex;</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">, </span><span class="s2">'simplepbr.frag'</span><span class="s1">: </span><span class="s2">&quot;// Based on code from https://github.com/KhronosGroup/glTF-Sample-Viewer</span><span class="s3">\n\n</span><span class="s2">#version 120</span><span class="s3">\n\n</span><span class="s2">#ifndef MAX_LIGHTS</span><span class="s3">\n    </span><span class="s2">#define MAX_LIGHTS 8</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">uniform struct p3d_MaterialParameters {</span><span class="s3">\n    </span><span class="s2">vec4 baseColor;</span><span class="s3">\n    </span><span class="s2">vec4 emission;</span><span class="s3">\n    </span><span class="s2">float roughness;</span><span class="s3">\n    </span><span class="s2">float metallic;</span><span class="s3">\n</span><span class="s2">} p3d_Material;</span><span class="s3">\n\n</span><span class="s2">uniform struct p3d_LightSourceParameters {</span><span class="s3">\n    </span><span class="s2">vec4 position;</span><span class="s3">\n    </span><span class="s2">vec4 diffuse;</span><span class="s3">\n    </span><span class="s2">vec4 specular;</span><span class="s3">\n    </span><span class="s2">vec3 attenuation;</span><span class="s3">\n    </span><span class="s2">vec3 spotDirection;</span><span class="s3">\n    </span><span class="s2">float spotCosCutoff;</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SHADOWS</span><span class="s3">\n    </span><span class="s2">sampler2DShadow shadowMap;</span><span class="s3">\n    </span><span class="s2">mat4 shadowViewMatrix;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n</span><span class="s2">} p3d_LightSource[MAX_LIGHTS];</span><span class="s3">\n\n</span><span class="s2">uniform struct p3d_LightModelParameters {</span><span class="s3">\n    </span><span class="s2">vec4 ambient;</span><span class="s3">\n</span><span class="s2">} p3d_LightModel;</span><span class="s3">\n\n</span><span class="s2">#ifdef ENABLE_FOG</span><span class="s3">\n</span><span class="s2">uniform struct p3d_FogParameters {</span><span class="s3">\n    </span><span class="s2">vec4 color;</span><span class="s3">\n    </span><span class="s2">float density;</span><span class="s3">\n</span><span class="s2">} p3d_Fog;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">uniform vec4 p3d_ColorScale;</span><span class="s3">\n</span><span class="s2">uniform vec4 p3d_TexAlphaOnly;</span><span class="s3">\n\n</span><span class="s2">struct FunctionParamters {</span><span class="s3">\n    </span><span class="s2">float n_dot_l;</span><span class="s3">\n    </span><span class="s2">float n_dot_v;</span><span class="s3">\n    </span><span class="s2">float n_dot_h;</span><span class="s3">\n    </span><span class="s2">float l_dot_h;</span><span class="s3">\n    </span><span class="s2">float v_dot_h;</span><span class="s3">\n    </span><span class="s2">float roughness;</span><span class="s3">\n    </span><span class="s2">float metallic;</span><span class="s3">\n    </span><span class="s2">vec3 reflection0;</span><span class="s3">\n    </span><span class="s2">vec3 diffuse_color;</span><span class="s3">\n    </span><span class="s2">vec3 specular_color;</span><span class="s3">\n</span><span class="s2">};</span><span class="s3">\n\n</span><span class="s2">uniform sampler2D p3d_TextureBaseColor;</span><span class="s3">\n</span><span class="s2">uniform sampler2D p3d_TextureMetalRoughness;</span><span class="s3">\n</span><span class="s2">uniform sampler2D p3d_TextureNormal;</span><span class="s3">\n</span><span class="s2">uniform sampler2D p3d_TextureEmission;</span><span class="s3">\n\n</span><span class="s2">const vec3 F0 = vec3(0.04);</span><span class="s3">\n</span><span class="s2">const float PI = 3.141592653589793;</span><span class="s3">\n</span><span class="s2">const float SPOTSMOOTH = 0.001;</span><span class="s3">\n</span><span class="s2">const float LIGHT_CUTOFF = 0.001;</span><span class="s3">\n\n</span><span class="s2">varying vec3 v_position;</span><span class="s3">\n</span><span class="s2">varying vec4 v_color;</span><span class="s3">\n</span><span class="s2">varying vec2 v_texcoord;</span><span class="s3">\n</span><span class="s2">varying mat3 v_tbn;</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SHADOWS</span><span class="s3">\n</span><span class="s2">varying vec4 v_shadow_pos[MAX_LIGHTS];</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">#ifdef USE_330</span><span class="s3">\n</span><span class="s2">out vec4 o_color;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">// Schlick's Fresnel approximation with Spherical Gaussian approximation to replace the power</span><span class="s3">\n</span><span class="s2">vec3 specular_reflection(FunctionParamters func_params) {</span><span class="s3">\n    </span><span class="s2">vec3 f0 = func_params.reflection0;</span><span class="s3">\n    </span><span class="s2">float v_dot_h= func_params.v_dot_h;</span><span class="s3">\n    </span><span class="s2">return f0 + (1 - f0) * pow(2, (-5.55473 * v_dot_h - 6.98316) * v_dot_h);</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n\n</span><span class="s2">// Smith GGX with optional fast sqrt approximation (see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg))</span><span class="s3">\n</span><span class="s2">float visibility_occlusion(FunctionParamters func_params) {</span><span class="s3">\n    </span><span class="s2">float r = func_params.roughness;</span><span class="s3">\n    </span><span class="s2">float r2 = r * r;</span><span class="s3">\n    </span><span class="s2">float n_dot_l = func_params.n_dot_l;</span><span class="s3">\n    </span><span class="s2">float n_dot_v = func_params.n_dot_v;</span><span class="s3">\n</span><span class="s2">#ifdef SMITH_SQRT_APPROX</span><span class="s3">\n    </span><span class="s2">float ggxv = n_dot_l * (n_dot_v * (1.0 - r) + r);</span><span class="s3">\n    </span><span class="s2">float ggxl = n_dot_v * (n_dot_l * (1.0 - r) + r);</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">float ggxv = n_dot_l * sqrt(n_dot_v * n_dot_v * (1.0 - r2) + r2);</span><span class="s3">\n    </span><span class="s2">float ggxl = n_dot_v * sqrt(n_dot_l * n_dot_l * (1.0 - r2) + r2);</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n    </span><span class="s2">return max(0.0, 0.5 / (ggxv + ggxl));</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n\n</span><span class="s2">// GGX/Trowbridge-Reitz</span><span class="s3">\n</span><span class="s2">float microfacet_distribution(FunctionParamters func_params) {</span><span class="s3">\n    </span><span class="s2">float roughness2 = func_params.roughness * func_params.roughness;</span><span class="s3">\n    </span><span class="s2">float f = (func_params.n_dot_h * func_params.n_dot_h) * (roughness2 - 1.0) + 1.0;</span><span class="s3">\n    </span><span class="s2">return roughness2 / (PI * f * f);</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n\n</span><span class="s2">// Lambert</span><span class="s3">\n</span><span class="s2">float diffuse_function(FunctionParamters func_params) {</span><span class="s3">\n    </span><span class="s2">return 1.0 / PI;</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n\n</span><span class="s2">void main() {</span><span class="s3">\n    </span><span class="s2">vec4 metal_rough = texture2D(p3d_TextureMetalRoughness, v_texcoord);</span><span class="s3">\n    </span><span class="s2">float metallic = clamp(p3d_Material.metallic * metal_rough.b, 0.0, 1.0);</span><span class="s3">\n    </span><span class="s2">float perceptual_roughness = clamp(p3d_Material.roughness * metal_rough.g,  0.0, 1.0);</span><span class="s3">\n    </span><span class="s2">float alpha_roughness = perceptual_roughness * perceptual_roughness;</span><span class="s3">\n    </span><span class="s2">vec4 base_color = p3d_Material.baseColor * v_color * p3d_ColorScale * texture2D(p3d_TextureBaseColor, v_texcoord);</span><span class="s3">\n    </span><span class="s2">vec3 diffuse_color = (base_color.rgb * (vec3(1.0) - F0)) * (1.0 - metallic);</span><span class="s3">\n    </span><span class="s2">vec3 spec_color = mix(F0, base_color.rgb, metallic);</span><span class="s3">\n</span><span class="s2">#ifdef USE_NORMAL_MAP</span><span class="s3">\n    </span><span class="s2">vec3 n = normalize(v_tbn * (2.0 * texture2D(p3d_TextureNormal, v_texcoord).rgb - 1.0));</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">vec3 n = normalize(v_tbn[2]);</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n    </span><span class="s2">vec3 v = normalize(-v_position);</span><span class="s3">\n\n</span><span class="s2">#ifdef USE_OCCLUSION_MAP</span><span class="s3">\n    </span><span class="s2">float ambient_occlusion = metal_rough.r;</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">float ambient_occlusion = 1.0;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">#ifdef USE_EMISSION_MAP</span><span class="s3">\n    </span><span class="s2">vec3 emission = p3d_Material.emission.rgb * texture2D(p3d_TextureEmission, v_texcoord).rgb;</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">vec3 emission = vec3(0.0);</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n    </span><span class="s2">vec4 color = vec4(vec3(0.0), base_color.a) + p3d_TexAlphaOnly;</span><span class="s3">\n\n    </span><span class="s2">for (int i = 0; i &lt; p3d_LightSource.length(); ++i) {</span><span class="s3">\n        </span><span class="s2">vec3 lightcol = p3d_LightSource[i].diffuse.rgb;</span><span class="s3">\n\n        </span><span class="s2">if (dot(lightcol, lightcol) &lt; LIGHT_CUTOFF) {</span><span class="s3">\n            </span><span class="s2">continue;</span><span class="s3">\n        </span><span class="s2">}</span><span class="s3">\n\n        </span><span class="s2">vec3 light_pos = p3d_LightSource[i].position.xyz - v_position * p3d_LightSource[i].position.w;</span><span class="s3">\n        </span><span class="s2">vec3 l = normalize(light_pos);</span><span class="s3">\n        </span><span class="s2">vec3 h = normalize(l + v);</span><span class="s3">\n        </span><span class="s2">float dist = length(light_pos);</span><span class="s3">\n        </span><span class="s2">vec3 att_const = p3d_LightSource[i].attenuation;</span><span class="s3">\n        </span><span class="s2">float attenuation_factor = 1.0 / (att_const.x + att_const.y * dist + att_const.z * dist * dist);</span><span class="s3">\n        </span><span class="s2">float spotcos = dot(normalize(p3d_LightSource[i].spotDirection), -l);</span><span class="s3">\n        </span><span class="s2">float spotcutoff = p3d_LightSource[i].spotCosCutoff;</span><span class="s3">\n        </span><span class="s2">float shadowSpot = smoothstep(spotcutoff-SPOTSMOOTH, spotcutoff+SPOTSMOOTH, spotcos);</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SHADOWS</span><span class="s3">\n</span><span class="s2">#ifdef USE_330</span><span class="s3">\n        </span><span class="s2">float shadowCaster = textureProj(p3d_LightSource[i].shadowMap, v_shadow_pos[i]);</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n        </span><span class="s2">float shadowCaster = shadow2DProj(p3d_LightSource[i].shadowMap, v_shadow_pos[i]).r;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n        </span><span class="s2">float shadowCaster = 1.0;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n        </span><span class="s2">float shadow = shadowSpot * shadowCaster * attenuation_factor;</span><span class="s3">\n\n        </span><span class="s2">FunctionParamters func_params;</span><span class="s3">\n        </span><span class="s2">func_params.n_dot_l = clamp(dot(n, l), 0.0, 1.0);</span><span class="s3">\n        </span><span class="s2">func_params.n_dot_v = clamp(abs(dot(n, v)), 0.0, 1.0);</span><span class="s3">\n        </span><span class="s2">func_params.n_dot_h = clamp(dot(n, h), 0.0, 1.0);</span><span class="s3">\n        </span><span class="s2">func_params.l_dot_h = clamp(dot(l, h), 0.0, 1.0);</span><span class="s3">\n        </span><span class="s2">func_params.v_dot_h = clamp(dot(v, h), 0.0, 1.0);</span><span class="s3">\n        </span><span class="s2">func_params.roughness = alpha_roughness;</span><span class="s3">\n        </span><span class="s2">func_params.metallic =  metallic;</span><span class="s3">\n        </span><span class="s2">func_params.reflection0 = spec_color;</span><span class="s3">\n        </span><span class="s2">func_params.diffuse_color = diffuse_color;</span><span class="s3">\n        </span><span class="s2">func_params.specular_color = spec_color;</span><span class="s3">\n\n        </span><span class="s2">vec3 F = specular_reflection(func_params);</span><span class="s3">\n        </span><span class="s2">float V = visibility_occlusion(func_params); // V = G / (4 * n_dot_l * n_dot_v)</span><span class="s3">\n        </span><span class="s2">float D = microfacet_distribution(func_params);</span><span class="s3">\n\n        </span><span class="s2">vec3 diffuse_contrib = diffuse_color * diffuse_function(func_params);</span><span class="s3">\n        </span><span class="s2">vec3 spec_contrib = vec3(F * V * D);</span><span class="s3">\n        </span><span class="s2">color.rgb += func_params.n_dot_l * lightcol * (diffuse_contrib + spec_contrib) * shadow;</span><span class="s3">\n    </span><span class="s2">}</span><span class="s3">\n\n    </span><span class="s2">color.rgb += diffuse_color * p3d_LightModel.ambient.rgb * ambient_occlusion;</span><span class="s3">\n    </span><span class="s2">color.rgb += emission;</span><span class="s3">\n\n</span><span class="s2">#ifdef ENABLE_FOG</span><span class="s3">\n    </span><span class="s2">// Exponential fog</span><span class="s3">\n    </span><span class="s2">float fog_distance = length(v_position);</span><span class="s3">\n    </span><span class="s2">float fog_factor = clamp(1.0 / exp(fog_distance * p3d_Fog.density), 0.0, 1.0);</span><span class="s3">\n    </span><span class="s2">color = mix(p3d_Fog.color, color, fog_factor);</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">#ifdef USE_330</span><span class="s3">\n    </span><span class="s2">o_color = color;</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">gl_FragColor = color;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">, </span><span class="s2">'shadow.frag'</span><span class="s1">: </span><span class="s2">'#version 120</span><span class="s3">\n\n</span><span class="s2">uniform struct p3d_MaterialParameters {</span><span class="s3">\n    </span><span class="s2">vec4 baseColor;</span><span class="s3">\n</span><span class="s2">} p3d_Material;</span><span class="s3">\n\n</span><span class="s2">uniform vec4 p3d_ColorScale;</span><span class="s3">\n\n</span><span class="s2">uniform sampler2D p3d_TextureBaseColor;</span><span class="s3">\n</span><span class="s2">varying vec4 v_color;</span><span class="s3">\n</span><span class="s2">varying vec2 v_texcoord;</span><span class="s3">\n\n</span><span class="s2">#ifdef USE_330</span><span class="s3">\n</span><span class="s2">out vec4 o_color;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">void main() {</span><span class="s3">\n    </span><span class="s2">vec4 base_color = p3d_Material.baseColor * v_color * p3d_ColorScale * texture2D(p3d_TextureBaseColor, v_texcoord);</span><span class="s3">\n</span><span class="s2">#ifdef USE_330</span><span class="s3">\n    </span><span class="s2">o_color = base_color;</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">gl_FragColor = base_color;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">, </span><span class="s2">'shadow.vert'</span><span class="s1">: </span><span class="s2">'#version 120</span><span class="s3">\n\n</span><span class="s2">uniform mat4 p3d_ModelViewProjectionMatrix;</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SKINNING</span><span class="s3">\n</span><span class="s2">uniform mat4 p3d_TransformTable[100];</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">attribute vec4 p3d_Vertex;</span><span class="s3">\n</span><span class="s2">attribute vec4 p3d_Color;</span><span class="s3">\n</span><span class="s2">attribute vec2 p3d_MultiTexCoord0;</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SKINNING</span><span class="s3">\n</span><span class="s2">attribute vec4 transform_weight;</span><span class="s3">\n</span><span class="s2">attribute vec4 transform_index;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n\n</span><span class="s2">varying vec4 v_color;</span><span class="s3">\n</span><span class="s2">varying vec2 v_texcoord;</span><span class="s3">\n\n</span><span class="s2">void main() {</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SKINNING</span><span class="s3">\n    </span><span class="s2">mat4 skin_matrix = (</span><span class="s3">\n        </span><span class="s2">p3d_TransformTable[int(transform_index.x)] * transform_weight.x +</span><span class="s3">\n        </span><span class="s2">p3d_TransformTable[int(transform_index.y)] * transform_weight.y +</span><span class="s3">\n        </span><span class="s2">p3d_TransformTable[int(transform_index.z)] * transform_weight.z +</span><span class="s3">\n        </span><span class="s2">p3d_TransformTable[int(transform_index.w)] * transform_weight.w</span><span class="s3">\n    </span><span class="s2">);</span><span class="s3">\n    </span><span class="s2">vec4 vert_pos4 = skin_matrix * p3d_Vertex;</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">vec4 vert_pos4 = p3d_Vertex;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n    </span><span class="s2">v_color = p3d_Color;</span><span class="s3">\n    </span><span class="s2">v_texcoord = p3d_MultiTexCoord0;</span><span class="s3">\n    </span><span class="s2">gl_Position = p3d_ModelViewProjectionMatrix * vert_pos4;</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">, </span><span class="s2">'simplepbr.vert'</span><span class="s1">: </span><span class="s2">'#version 120</span><span class="s3">\n\n</span><span class="s2">#ifndef MAX_LIGHTS</span><span class="s3">\n    </span><span class="s2">#define MAX_LIGHTS 8</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">#ifdef ENABLE_SHADOWS</span><span class="s3">\n</span><span class="s2">uniform struct p3d_LightSourceParameters {</span><span class="s3">\n    </span><span class="s2">vec4 position;</span><span class="s3">\n    </span><span class="s2">vec4 diffuse;</span><span class="s3">\n    </span><span class="s2">vec4 specular;</span><span class="s3">\n    </span><span class="s2">vec3 attenuation;</span><span class="s3">\n    </span><span class="s2">vec3 spotDirection;</span><span class="s3">\n    </span><span class="s2">float spotCosCutoff;</span><span class="s3">\n    </span><span class="s2">sampler2DShadow shadowMap;</span><span class="s3">\n    </span><span class="s2">mat4 shadowViewMatrix;</span><span class="s3">\n</span><span class="s2">} p3d_LightSource[MAX_LIGHTS];</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">#ifdef ENABLE_SKINNING</span><span class="s3">\n</span><span class="s2">uniform mat4 p3d_TransformTable[100];</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">uniform mat4 p3d_ProjectionMatrix;</span><span class="s3">\n</span><span class="s2">uniform mat4 p3d_ModelViewMatrix;</span><span class="s3">\n</span><span class="s2">uniform mat3 p3d_NormalMatrix;</span><span class="s3">\n</span><span class="s2">uniform mat4 p3d_TextureMatrix;</span><span class="s3">\n\n</span><span class="s2">attribute vec4 p3d_Vertex;</span><span class="s3">\n</span><span class="s2">attribute vec4 p3d_Color;</span><span class="s3">\n</span><span class="s2">attribute vec3 p3d_Normal;</span><span class="s3">\n</span><span class="s2">attribute vec4 p3d_Tangent;</span><span class="s3">\n</span><span class="s2">attribute vec2 p3d_MultiTexCoord0;</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SKINNING</span><span class="s3">\n</span><span class="s2">attribute vec4 transform_weight;</span><span class="s3">\n</span><span class="s2">attribute vec4 transform_index;</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n\n</span><span class="s2">varying vec3 v_position;</span><span class="s3">\n</span><span class="s2">varying vec4 v_color;</span><span class="s3">\n</span><span class="s2">varying mat3 v_tbn;</span><span class="s3">\n</span><span class="s2">varying vec2 v_texcoord;</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SHADOWS</span><span class="s3">\n</span><span class="s2">varying vec4 v_shadow_pos[MAX_LIGHTS];</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n</span><span class="s2">void main() {</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SKINNING</span><span class="s3">\n    </span><span class="s2">mat4 skin_matrix = (</span><span class="s3">\n        </span><span class="s2">p3d_TransformTable[int(transform_index.x)] * transform_weight.x +</span><span class="s3">\n        </span><span class="s2">p3d_TransformTable[int(transform_index.y)] * transform_weight.y +</span><span class="s3">\n        </span><span class="s2">p3d_TransformTable[int(transform_index.z)] * transform_weight.z +</span><span class="s3">\n        </span><span class="s2">p3d_TransformTable[int(transform_index.w)] * transform_weight.w</span><span class="s3">\n    </span><span class="s2">);</span><span class="s3">\n    </span><span class="s2">vec4 vert_pos4 = p3d_ModelViewMatrix * skin_matrix * p3d_Vertex;</span><span class="s3">\n    </span><span class="s2">vec3 normal = normalize(p3d_NormalMatrix * (skin_matrix * vec4(p3d_Normal.xyz, 0.0)).xyz);</span><span class="s3">\n</span><span class="s2">#else</span><span class="s3">\n    </span><span class="s2">vec4 vert_pos4 = p3d_ModelViewMatrix * p3d_Vertex;</span><span class="s3">\n    </span><span class="s2">vec3 normal = normalize(p3d_NormalMatrix * p3d_Normal);</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n    </span><span class="s2">v_position = vec3(vert_pos4);</span><span class="s3">\n    </span><span class="s2">v_color = p3d_Color;</span><span class="s3">\n    </span><span class="s2">v_texcoord = (p3d_TextureMatrix * vec4(p3d_MultiTexCoord0, 0, 1)).xy;</span><span class="s3">\n</span><span class="s2">#ifdef ENABLE_SHADOWS</span><span class="s3">\n    </span><span class="s2">for (int i = 0; i &lt; p3d_LightSource.length(); ++i) {</span><span class="s3">\n        </span><span class="s2">v_shadow_pos[i] = p3d_LightSource[i].shadowViewMatrix * vert_pos4;</span><span class="s3">\n    </span><span class="s2">}</span><span class="s3">\n</span><span class="s2">#endif</span><span class="s3">\n\n    </span><span class="s2">vec3 tangent = normalize(vec3(p3d_ModelViewMatrix * vec4(p3d_Tangent.xyz, 0.0)));</span><span class="s3">\n    </span><span class="s2">vec3 bitangent = cross(normal, tangent) * p3d_Tangent.w;</span><span class="s3">\n    </span><span class="s2">v_tbn = mat3(</span><span class="s3">\n        </span><span class="s2">tangent,</span><span class="s3">\n        </span><span class="s2">bitangent,</span><span class="s3">\n        </span><span class="s2">normal</span><span class="s3">\n    </span><span class="s2">);</span><span class="s3">\n\n    </span><span class="s2">gl_Position = p3d_ProjectionMatrix * vert_pos4;</span><span class="s3">\n</span><span class="s2">}</span><span class="s3">\n</span><span class="s2">'</span><span class="s1">}</span></pre>
</body>
</html>