<html>
<head>
<title>libp3char.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3char.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">9 libp3char 4 uMZI 12 panda3d.core </span>
<span class="s0">44</span>
<span class="s0">48 14 CharacterJoint 0 260 92 30 CharacterJoint::CharacterJoint 0 1 1 57</span>
<span class="s0">/**</span>
 <span class="s0">* For internal use only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">explicit CharacterJoint::CharacterJoint(Character *character, PartBundle *root, PartGroup *parent, std::string const &amp;name, LMatrix4 const &amp;default_value);</span>

<span class="s0">49 17 add_net_transform 0 4 92 33 CharacterJoint::add_net_transform 0 1 2 334</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated node to the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's net transform from the root.  Returns true if the</span>
 <span class="s0">* node is successfully added, false if it had already been added.</span>
 <span class="s0">*</span>
 <span class="s0">* A CharacterJointEffect for this joint's Character will automatically be</span>
 <span class="s0">* added to the specified node.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">bool CharacterJoint::add_net_transform(PandaNode *node);</span>

<span class="s0">50 20 remove_net_transform 0 4 92 36 CharacterJoint::remove_net_transform 0 1 3 333</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated node from the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's net transform from the root.  Returns true if the</span>
 <span class="s0">* node is successfully removed, false if it was not on the list.</span>
 <span class="s0">*</span>
 <span class="s0">* If the node has a CharacterJointEffect that matches this joint's Character,</span>
 <span class="s0">* it will be cleared.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">bool CharacterJoint::remove_net_transform(PandaNode *node);</span>

<span class="s0">51 17 has_net_transform 0 4 92 33 CharacterJoint::has_net_transform 0 1 4 157</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the node is on the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's net transform from the root, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool CharacterJoint::has_net_transform(PandaNode *node) const;</span>

<span class="s0">52 20 clear_net_transforms 0 4 92 36 CharacterJoint::clear_net_transforms 0 1 5 132</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all nodes from the list of nodes that will be updated each frame</span>
 <span class="s0">* with the joint's net transform from the root.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void CharacterJoint::clear_net_transforms(void);</span>

<span class="s0">53 18 get_net_transforms 0 4 92 34 CharacterJoint::get_net_transforms 0 1 6 183</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a list of the net transforms set for this node.  Note that this</span>
 <span class="s0">* returns a list of NodePaths, even though the net transforms are actually a</span>
 <span class="s0">* list of PandaNodes.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">NodePathCollection CharacterJoint::get_net_transforms(void);</span>

<span class="s0">54 19 add_local_transform 0 4 92 35 CharacterJoint::add_local_transform 0 1 7 539</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated node to the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's local transform from its parent.  Returns true if</span>
 <span class="s0">* the node is successfully added, false if it had already been added.</span>
 <span class="s0">*</span>
 <span class="s0">* The Character pointer should be the Character object that owns this joint;</span>
 <span class="s0">* this will be used to create a CharacterJointEffect for this node.  If it is</span>
 <span class="s0">* NULL, no such effect will be created.</span>
 <span class="s0">*</span>
 <span class="s0">* A CharacterJointEffect for this joint's Character will automatically be</span>
 <span class="s0">* added to the specified node.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">bool CharacterJoint::add_local_transform(PandaNode *node);</span>

<span class="s0">55 22 remove_local_transform 0 4 92 38 CharacterJoint::remove_local_transform 0 1 8 337</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated node from the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's local transform from its parent.  Returns true if</span>
 <span class="s0">* the node is successfully removed, false if it was not on the list.</span>
 <span class="s0">*</span>
 <span class="s0">* If the node has a CharacterJointEffect that matches this joint's Character,</span>
 <span class="s0">* it will be cleared.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">bool CharacterJoint::remove_local_transform(PandaNode *node);</span>

<span class="s0">56 19 has_local_transform 0 4 92 35 CharacterJoint::has_local_transform 0 1 9 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the node is on the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's local transform from its parent, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool CharacterJoint::has_local_transform(PandaNode *node) const;</span>

<span class="s0">57 22 clear_local_transforms 0 4 92 38 CharacterJoint::clear_local_transforms 0 1 10 136</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all nodes from the list of nodes that will be updated each frame</span>
 <span class="s0">* with the joint's local transform from its parent.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void CharacterJoint::clear_local_transforms(void);</span>

<span class="s0">58 20 get_local_transforms 0 4 92 36 CharacterJoint::get_local_transforms 0 1 11 187</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a list of the local transforms set for this node.  Note that this</span>
 <span class="s0">* returns a list of NodePaths, even though the local transforms are actually</span>
 <span class="s0">* a list of PandaNodes.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">NodePathCollection CharacterJoint::get_local_transforms(void);</span>

<span class="s0">59 13 get_transform 0 4 92 29 CharacterJoint::get_transform 0 2 12 13 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transform matrix of the joint</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Copies the joint's current transform into the indicated matrix.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">void CharacterJoint::get_transform(LMatrix4 &amp;transform) const;</span>
<span class="s0">inline LMatrix4 const &amp;CharacterJoint::get_transform(void) const;</span>

<span class="s0">60 19 get_transform_state 0 4 92 35 CharacterJoint::get_transform_state 0 1 14 0</span>
<span class="s0">81</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; CharacterJoint::get_transform_state(void) const;</span>

<span class="s0">61 17 get_net_transform 0 4 92 33 CharacterJoint::get_net_transform 0 1 15 139</span>
<span class="s0">/**</span>
 <span class="s0">* Copies the joint's current net transform (composed from the root of the</span>
 <span class="s0">* character joint hierarchy) into the indicated matrix.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void CharacterJoint::get_net_transform(LMatrix4 &amp;transform) const;</span>

<span class="s0">62 13 get_character 0 4 92 29 CharacterJoint::get_character 0 1 16 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Character that owns this joint.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">Character *CharacterJoint::get_character(void) const;</span>

<span class="s0">63 14 get_class_type 0 4 92 30 CharacterJoint::get_class_type 0 1 17 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle CharacterJoint::get_class_type(void);</span>

<span class="s0">64 15 CharacterSlider 0 260 94 32 CharacterSlider::CharacterSlider 0 2 18 19 69</span>
<span class="s0">/**</span>
 <span class="s0">* For internal use only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">207</span>
<span class="s0">explicit CharacterSlider::CharacterSlider(PartGroup *parent, std::string const &amp;name);</span>
<span class="s0">explicit CharacterSlider::CharacterSlider(PartGroup *parent, std::string const &amp;name, PN_stdfloat const &amp;default_value);</span>

<span class="s0">65 14 get_class_type 0 4 94 31 CharacterSlider::get_class_type 0 1 20 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle CharacterSlider::get_class_type(void);</span>

<span class="s0">66 21 CharacterVertexSlider 0 260 96 44 CharacterVertexSlider::CharacterVertexSlider 0 1 21 216</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an invalid object; used only by the bam loader.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new object that converts vertices from the indicated joint's</span>
 <span class="s0">* coordinate space, into the other indicated joint's space.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">CharacterVertexSlider::CharacterVertexSlider(CharacterSlider *char_slider);</span>

<span class="s0">67 15 get_char_slider 0 4 96 38 CharacterVertexSlider::get_char_slider 0 1 22 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CharacterSlider object for which this object returns the slider</span>
 <span class="s0">* value.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline CharacterSlider const *CharacterVertexSlider::get_char_slider(void) const;</span>

<span class="s0">68 14 get_class_type 0 4 96 37 CharacterVertexSlider::get_class_type 0 1 23 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle CharacterVertexSlider::get_class_type(void);</span>

<span class="s0">69 20 JointVertexTransform 0 260 98 42 JointVertexTransform::JointVertexTransform 0 1 24 216</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an invalid object; used only by the bam loader.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new object that converts vertices from the indicated joint's</span>
 <span class="s0">* coordinate space, into the other indicated joint's space.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">JointVertexTransform::JointVertexTransform(CharacterJoint *joint);</span>

<span class="s0">70 9 get_joint 0 4 98 31 JointVertexTransform::get_joint 0 1 25 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the joint for which this object returns the transform.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline CharacterJoint const *JointVertexTransform::get_joint(void) const;</span>

<span class="s0">71 14 get_class_type 0 4 98 36 JointVertexTransform::get_class_type 0 1 26 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle JointVertexTransform::get_class_type(void);</span>

<span class="s0">72 9 Character 0 260 100 20 Character::Character 0 2 27 28 78</span>
<span class="s0">/**</span>
 <span class="s0">* Use make_copy() or copy_subgraph() to copy a Character.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">explicit Character::Character(std::string const &amp;name);</span>
<span class="s0">inline Character::Character(Character const &amp;) = default;</span>

<span class="s0">73 10 get_bundle 0 4 100 21 Character::get_bundle 0 1 29 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline CharacterJointBundle *Character::get_bundle(int i) const;</span>

<span class="s0">74 13 merge_bundles 0 4 100 24 Character::merge_bundles 0 2 30 31 1309</span>
<span class="s0">/**</span>
 <span class="s0">* Merges old_bundle with new_bundle.  old_bundle must be one of the</span>
 <span class="s0">* PartBundles within this node.  At the end of this call, the old_bundle</span>
 <span class="s0">* pointer within this node will be replaced with the new_bundle pointer, and</span>
 <span class="s0">* all geometry within this node will be updated to reference new_bundle.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use the newer version of this method, below.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Merges old_bundle_handle-&gt;get_bundle() with new_bundle.  old_bundle_handle</span>
 <span class="s0">* must be one of the PartBundleHandle within this node.  At the end of this</span>
 <span class="s0">* call, the bundle pointer within the old_bundle_handle will be replaced with</span>
 <span class="s0">* that within the new_bundle_handle pointer, and all geometry within this</span>
 <span class="s0">* node will be updated to reference new_bundle.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is called when the two bundles have the same, or nearly the</span>
 <span class="s0">* same, hierarchies.  In this case, new_bundle will simply be assigned over</span>
 <span class="s0">* the old_bundle position.  However, if any joints are present in one bundle</span>
 <span class="s0">* or the other, new_bundle will be modified to contain the union of all</span>
 <span class="s0">* joints.</span>
 <span class="s0">*</span>
 <span class="s0">* The geometry below this node is also updated to reference new_bundle,</span>
 <span class="s0">* instead of the original old_bundle.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended to unify two different models that share a common</span>
 <span class="s0">* skeleton, for instance, different LOD's of the same model.</span>
 <span class="s0">*/</span>
<span class="s0">187</span>
<span class="s0">void Character::merge_bundles(PartBundle *old_bundle, PartBundle *other_bundle);</span>
<span class="s0">void Character::merge_bundles(PartBundleHandle *old_bundle_handle, PartBundleHandle *other_bundle_handle);</span>

<span class="s0">75 17 set_lod_animation 0 4 100 28 Character::set_lod_animation 0 1 32 1171</span>
<span class="s0">/**</span>
 <span class="s0">* Activates a special mode in which the character animates less frequently as</span>
 <span class="s0">* it gets further from the camera.  This is intended as a simple optimization</span>
 <span class="s0">* to minimize the effort of computing animation for lots of characters that</span>
 <span class="s0">* may not necessarily be very important to animate every frame.</span>
 <span class="s0">*</span>
 <span class="s0">* If the character is closer to the camera than near_distance, then it is</span>
 <span class="s0">* animated its normal rate, every frame.  If the character is exactly</span>
 <span class="s0">* far_distance away, it is animated only every delay_factor seconds (which</span>
 <span class="s0">* should be a number greater than 0).  If the character is between</span>
 <span class="s0">* near_distance and far_distance, its animation rate is linearly interpolated</span>
 <span class="s0">* according to its distance between the two.  The interpolation function</span>
 <span class="s0">* continues beyond far_distance, so that the character is animated</span>
 <span class="s0">* increasingly less frequently as it gets farther away.</span>
 <span class="s0">*</span>
 <span class="s0">* The distance calculations are made from center, which is a fixed point</span>
 <span class="s0">* relative to the character node, to the camera's lod center or cull center</span>
 <span class="s0">* node (or to the camera node itself).</span>
 <span class="s0">*</span>
 <span class="s0">* If multiple cameras are viewing the character in any given frame, the</span>
 <span class="s0">* closest one counts.</span>
 <span class="s0">*/</span>
<span class="s0">136</span>
<span class="s0">void Character::set_lod_animation(LPoint3 const &amp;center, PN_stdfloat far_distance, PN_stdfloat near_distance, PN_stdfloat delay_factor);</span>

<span class="s0">76 19 clear_lod_animation 0 4 100 30 Character::clear_lod_animation 0 1 33 172</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of a recent call to set_lod_animation().  Henceforth, the</span>
 <span class="s0">* character will animate every frame, regardless of its distance from the</span>
 <span class="s0">* camera.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void Character::clear_lod_animation(void);</span>

<span class="s0">77 10 find_joint 0 4 100 21 Character::find_joint 0 1 34 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the joint with the given name, if there is such a</span>
 <span class="s0">* joint, or NULL if there is no such joint.  This will not return a pointer</span>
 <span class="s0">* to a slider.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">CharacterJoint *Character::find_joint(std::string const &amp;name) const;</span>

<span class="s0">78 11 find_slider 0 4 100 22 Character::find_slider 0 1 35 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the slider with the given name, if there is such a</span>
 <span class="s0">* slider, or NULL if there is no such slider.  This will not return a pointer</span>
 <span class="s0">* to a joint.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">CharacterSlider *Character::find_slider(std::string const &amp;name) const;</span>

<span class="s0">79 11 write_parts 0 4 100 22 Character::write_parts 0 1 36 129</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a list of the Character's joints and sliders, in their hierchical</span>
 <span class="s0">* structure, to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void Character::write_parts(std::ostream &amp;out) const;</span>

<span class="s0">80 17 write_part_values 0 4 100 28 Character::write_part_values 0 1 37 166</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a list of the Character's joints and sliders, along with each</span>
 <span class="s0">* current position, in their hierchical structure, to the indicated output</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void Character::write_part_values(std::ostream &amp;out) const;</span>

<span class="s0">81 13 update_to_now 0 4 100 24 Character::update_to_now 0 1 38 310</span>
<span class="s0">/**</span>
 <span class="s0">* Advances the character's frame to the current time, and then calls</span>
 <span class="s0">* update().  This can be used by show code to force an update of the</span>
 <span class="s0">* character's position to the current frame, regardless of whether the</span>
 <span class="s0">* character is currently onscreen and animating.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Call update() instead.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void Character::update_to_now(void);</span>

<span class="s0">82 6 update 0 4 100 17 Character::update 0 1 39 182</span>
<span class="s0">/**</span>
 <span class="s0">* Recalculates the Character's joints and vertices for the current frame.</span>
 <span class="s0">* Normally this is performed automatically during the render and need not be</span>
 <span class="s0">* called explicitly.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">void Character::update(void);</span>

<span class="s0">83 12 force_update 0 4 100 23 Character::force_update 0 1 40 74</span>
<span class="s0">/**</span>
 <span class="s0">* Recalculates the character even if we think it doesn't need it.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">void Character::force_update(void);</span>

<span class="s0">84 14 get_class_type 0 4 100 25 Character::get_class_type 0 1 41 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle Character::get_class_type(void);</span>

<span class="s0">85 20 CharacterJointBundle 0 260 102 42 CharacterJointBundle::CharacterJointBundle 0 1 42 232</span>
<span class="s0">/**</span>
 <span class="s0">* Normally, you'd use make_copy() or copy_subgraph() to make a copy of this.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Normally, there is no need to create a CharacterJointBundle directly.  The</span>
 <span class="s0">* Character node will automatically create one for itself.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">explicit CharacterJointBundle::CharacterJointBundle(std::string const &amp;name = &quot;&quot;);</span>

<span class="s0">86 8 get_node 0 4 102 30 CharacterJointBundle::get_node 0 1 43 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth Character associated with this PartBundle.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline Character *CharacterJointBundle::get_node(int n) const;</span>

<span class="s0">87 14 get_class_type 0 4 102 36 CharacterJointBundle::get_class_type 0 1 44 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle CharacterJointBundle::get_class_type(void);</span>

<span class="s0">88 4 make 0 4 104 26 CharacterJointEffect::make 0 1 45 251</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new CharacterJointEffect object that references the indicated</span>
 <span class="s0">* character.  When a relative get_transform() is called on the node that</span>
 <span class="s0">* contains the CharacterJointEffect, it will implicitly call</span>
 <span class="s0">* character-&gt;update() first.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; CharacterJointEffect::make(Character *character);</span>

<span class="s0">89 13 get_character 0 4 104 35 CharacterJointEffect::get_character 0 1 46 158</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Character that will get update() called on it when this node's</span>
 <span class="s0">* relative transform is queried, or NULL if there is no such character.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline PointerTo&lt; Character &gt; CharacterJointEffect::get_character(void) const;</span>

<span class="s0">90 14 get_class_type 0 4 104 36 CharacterJointEffect::get_class_type 0 1 47 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle CharacterJointEffect::get_class_type(void);</span>

<span class="s0">91 21 ~CharacterJointEffect 0 516 104 43 CharacterJointEffect::~CharacterJointEffect 0 0 0</span>
<span class="s0">50</span>
<span class="s0">CharacterJointEffect::~CharacterJointEffect(void);</span>

<span class="s0">47</span>
<span class="s0">1 0 0 7 3 115 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 9 character 1 106  4 root 1 107  6 parent 1 108  4 name 1 110  13 default_value 1 111  </span>
<span class="s0">2 0 0 6 4 118 0 0 334 /**</span>
 <span class="s0">* Adds the indicated node to the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's net transform from the root.  Returns true if the</span>
 <span class="s0">* node is successfully added, false if it had already been added.</span>
 <span class="s0">*</span>
 <span class="s0">* A CharacterJointEffect for this joint's Character will automatically be</span>
 <span class="s0">* added to the specified node.</span>
 <span class="s0">*/ 2 4 this 3 115  4 node 1 116  </span>
<span class="s0">3 0 0 6 5 118 0 0 333 /**</span>
 <span class="s0">* Removes the indicated node from the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's net transform from the root.  Returns true if the</span>
 <span class="s0">* node is successfully removed, false if it was not on the list.</span>
 <span class="s0">*</span>
 <span class="s0">* If the node has a CharacterJointEffect that matches this joint's Character,</span>
 <span class="s0">* it will be cleared.</span>
 <span class="s0">*/ 2 4 this 3 115  4 node 1 116  </span>
<span class="s0">4 0 0 6 6 118 0 0 157 /**</span>
 <span class="s0">* Returns true if the node is on the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's net transform from the root, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 119  4 node 1 116  </span>
<span class="s0">5 0 0 4 7 121 0 0 132 /**</span>
 <span class="s0">* Removes all nodes from the list of nodes that will be updated each frame</span>
 <span class="s0">* with the joint's net transform from the root.</span>
 <span class="s0">*/ 1 4 this 3 115  </span>
<span class="s0">6 0 0 7 8 123 0 0 183 /**</span>
 <span class="s0">* Returns a list of the net transforms set for this node.  Note that this</span>
 <span class="s0">* returns a list of NodePaths, even though the net transforms are actually a</span>
 <span class="s0">* list of PandaNodes.</span>
 <span class="s0">*/ 1 4 this 3 115  </span>
<span class="s0">7 0 0 6 9 118 0 0 539 /**</span>
 <span class="s0">* Adds the indicated node to the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's local transform from its parent.  Returns true if</span>
 <span class="s0">* the node is successfully added, false if it had already been added.</span>
 <span class="s0">*</span>
 <span class="s0">* The Character pointer should be the Character object that owns this joint;</span>
 <span class="s0">* this will be used to create a CharacterJointEffect for this node.  If it is</span>
 <span class="s0">* NULL, no such effect will be created.</span>
 <span class="s0">*</span>
 <span class="s0">* A CharacterJointEffect for this joint's Character will automatically be</span>
 <span class="s0">* added to the specified node.</span>
 <span class="s0">*/ 2 4 this 3 115  4 node 1 116  </span>
<span class="s0">8 0 0 6 10 118 0 0 337 /**</span>
 <span class="s0">* Removes the indicated node from the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's local transform from its parent.  Returns true if</span>
 <span class="s0">* the node is successfully removed, false if it was not on the list.</span>
 <span class="s0">*</span>
 <span class="s0">* If the node has a CharacterJointEffect that matches this joint's Character,</span>
 <span class="s0">* it will be cleared.</span>
 <span class="s0">*/ 2 4 this 3 115  4 node 1 116  </span>
<span class="s0">9 0 0 6 11 118 0 0 161 /**</span>
 <span class="s0">* Returns true if the node is on the list of nodes that will be updated each</span>
 <span class="s0">* frame with the joint's local transform from its parent, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 119  4 node 1 116  </span>
<span class="s0">10 0 0 4 12 121 0 0 136 /**</span>
 <span class="s0">* Removes all nodes from the list of nodes that will be updated each frame</span>
 <span class="s0">* with the joint's local transform from its parent.</span>
 <span class="s0">*/ 1 4 this 3 115  </span>
<span class="s0">11 0 0 7 13 123 0 0 187 /**</span>
 <span class="s0">* Returns a list of the local transforms set for this node.  Note that this</span>
 <span class="s0">* returns a list of NodePaths, even though the local transforms are actually</span>
 <span class="s0">* a list of PandaNodes.</span>
 <span class="s0">*/ 1 4 this 3 115  </span>
<span class="s0">12 0 0 6 14 111 0 0 52 /**</span>
 <span class="s0">* Returns the transform matrix of the joint</span>
 <span class="s0">*/ 1 4 this 3 119  </span>
<span class="s0">13 0 0 4 14 121 0 0 74 /**</span>
 <span class="s0">* Copies the joint's current transform into the indicated matrix.</span>
 <span class="s0">*/ 2 4 this 3 119  9 transform 1 124  </span>
<span class="s0">14 0 0 7 15 127 0 0 0 1 4 this 3 119  </span>
<span class="s0">15 0 0 4 16 121 0 0 139 /**</span>
 <span class="s0">* Copies the joint's current net transform (composed from the root of the</span>
 <span class="s0">* character joint hierarchy) into the indicated matrix.</span>
 <span class="s0">*/ 2 4 this 3 119  9 transform 1 124  </span>
<span class="s0">16 0 0 7 17 106 0 0 54 /**</span>
 <span class="s0">* Returns the Character that owns this joint.</span>
 <span class="s0">*/ 1 4 this 3 119  </span>
<span class="s0">17 0 0 7 18 129 0 0 0 0 </span>
<span class="s0">18 0 0 7 21 130 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 parent 1 108  4 name 1 110  </span>
<span class="s0">19 0 0 7 21 130 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 6 parent 1 108  4 name 1 110  13 default_value 1 131  </span>
<span class="s0">20 0 0 7 22 129 0 0 0 0 </span>
<span class="s0">21 0 0 23 25 133 0 0 145 /**</span>
 <span class="s0">* Constructs a new object that converts vertices from the indicated joint's</span>
 <span class="s0">* coordinate space, into the other indicated joint's space.</span>
 <span class="s0">*/ 1 11 char_slider 1 130  </span>
<span class="s0">22 0 0 7 26 137 0 0 96 /**</span>
 <span class="s0">* Returns the CharacterSlider object for which this object returns the slider</span>
 <span class="s0">* value.</span>
 <span class="s0">*/ 1 4 this 3 135  </span>
<span class="s0">23 0 0 7 27 129 0 0 0 0 </span>
<span class="s0">24 0 0 23 30 138 0 0 145 /**</span>
 <span class="s0">* Constructs a new object that converts vertices from the indicated joint's</span>
 <span class="s0">* coordinate space, into the other indicated joint's space.</span>
 <span class="s0">*/ 1 5 joint 1 115  </span>
<span class="s0">25 0 0 7 31 119 0 0 73 /**</span>
 <span class="s0">* Returns the joint for which this object returns the transform.</span>
 <span class="s0">*/ 1 4 this 3 139  </span>
<span class="s0">26 0 0 7 32 129 0 0 0 0 </span>
<span class="s0">27 0 0 15 35 106 0 0 0 1 6 param0 0 141  </span>
<span class="s0">28 0 0 7 35 106 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 110  </span>
<span class="s0">29 0 0 7 36 144 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 141  1 i 1 143  </span>
<span class="s0">30 0 0 4 37 121 0 0 365 /**</span>
 <span class="s0">* Merges old_bundle with new_bundle.  old_bundle must be one of the</span>
 <span class="s0">* PartBundles within this node.  At the end of this call, the old_bundle</span>
 <span class="s0">* pointer within this node will be replaced with the new_bundle pointer, and</span>
 <span class="s0">* all geometry within this node will be updated to reference new_bundle.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use the newer version of this method, below.</span>
 <span class="s0">*/ 3 4 this 3 106  10 old_bundle 1 107  12 other_bundle 1 107  </span>
<span class="s0">31 0 0 4 37 121 0 0 942 /**</span>
 <span class="s0">* Merges old_bundle_handle-&gt;get_bundle() with new_bundle.  old_bundle_handle</span>
 <span class="s0">* must be one of the PartBundleHandle within this node.  At the end of this</span>
 <span class="s0">* call, the bundle pointer within the old_bundle_handle will be replaced with</span>
 <span class="s0">* that within the new_bundle_handle pointer, and all geometry within this</span>
 <span class="s0">* node will be updated to reference new_bundle.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is called when the two bundles have the same, or nearly the</span>
 <span class="s0">* same, hierarchies.  In this case, new_bundle will simply be assigned over</span>
 <span class="s0">* the old_bundle position.  However, if any joints are present in one bundle</span>
 <span class="s0">* or the other, new_bundle will be modified to contain the union of all</span>
 <span class="s0">* joints.</span>
 <span class="s0">*</span>
 <span class="s0">* The geometry below this node is also updated to reference new_bundle,</span>
 <span class="s0">* instead of the original old_bundle.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended to unify two different models that share a common</span>
 <span class="s0">* skeleton, for instance, different LOD's of the same model.</span>
 <span class="s0">*/ 3 4 this 3 106  17 old_bundle_handle 1 145  19 other_bundle_handle 1 145  </span>
<span class="s0">32 0 0 4 38 121 0 0 1171 /**</span>
 <span class="s0">* Activates a special mode in which the character animates less frequently as</span>
 <span class="s0">* it gets further from the camera.  This is intended as a simple optimization</span>
 <span class="s0">* to minimize the effort of computing animation for lots of characters that</span>
 <span class="s0">* may not necessarily be very important to animate every frame.</span>
 <span class="s0">*</span>
 <span class="s0">* If the character is closer to the camera than near_distance, then it is</span>
 <span class="s0">* animated its normal rate, every frame.  If the character is exactly</span>
 <span class="s0">* far_distance away, it is animated only every delay_factor seconds (which</span>
 <span class="s0">* should be a number greater than 0).  If the character is between</span>
 <span class="s0">* near_distance and far_distance, its animation rate is linearly interpolated</span>
 <span class="s0">* according to its distance between the two.  The interpolation function</span>
 <span class="s0">* continues beyond far_distance, so that the character is animated</span>
 <span class="s0">* increasingly less frequently as it gets farther away.</span>
 <span class="s0">*</span>
 <span class="s0">* The distance calculations are made from center, which is a fixed point</span>
 <span class="s0">* relative to the character node, to the camera's lod center or cull center</span>
 <span class="s0">* node (or to the camera node itself).</span>
 <span class="s0">*</span>
 <span class="s0">* If multiple cameras are viewing the character in any given frame, the</span>
 <span class="s0">* closest one counts.</span>
 <span class="s0">*/ 5 4 this 3 106  6 center 1 147  12 far_distance 1 131  13 near_distance 1 131  12 delay_factor 1 131  </span>
<span class="s0">33 0 0 4 39 121 0 0 172 /**</span>
 <span class="s0">* Undoes the effect of a recent call to set_lod_animation().  Henceforth, the</span>
 <span class="s0">* character will animate every frame, regardless of its distance from the</span>
 <span class="s0">* camera.</span>
 <span class="s0">*/ 1 4 this 3 106  </span>
<span class="s0">34 0 0 7 40 115 0 0 174 /**</span>
 <span class="s0">* Returns a pointer to the joint with the given name, if there is such a</span>
 <span class="s0">* joint, or NULL if there is no such joint.  This will not return a pointer</span>
 <span class="s0">* to a slider.</span>
 <span class="s0">*/ 2 4 this 3 141  4 name 1 110  </span>
<span class="s0">35 0 0 7 41 130 0 0 176 /**</span>
 <span class="s0">* Returns a pointer to the slider with the given name, if there is such a</span>
 <span class="s0">* slider, or NULL if there is no such slider.  This will not return a pointer</span>
 <span class="s0">* to a joint.</span>
 <span class="s0">*/ 2 4 this 3 141  4 name 1 110  </span>
<span class="s0">36 0 0 4 42 121 0 0 129 /**</span>
 <span class="s0">* Writes a list of the Character's joints and sliders, in their hierchical</span>
 <span class="s0">* structure, to the indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 141  3 out 1 151  </span>
<span class="s0">37 0 0 4 43 121 0 0 166 /**</span>
 <span class="s0">* Writes a list of the Character's joints and sliders, along with each</span>
 <span class="s0">* current position, in their hierchical structure, to the indicated output</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/ 2 4 this 3 141  3 out 1 151  </span>
<span class="s0">38 0 0 4 44 121 0 0 310 /**</span>
 <span class="s0">* Advances the character's frame to the current time, and then calls</span>
 <span class="s0">* update().  This can be used by show code to force an update of the</span>
 <span class="s0">* character's position to the current frame, regardless of whether the</span>
 <span class="s0">* character is currently onscreen and animating.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Call update() instead.</span>
 <span class="s0">*/ 1 4 this 3 106  </span>
<span class="s0">39 0 0 4 45 121 0 0 182 /**</span>
 <span class="s0">* Recalculates the Character's joints and vertices for the current frame.</span>
 <span class="s0">* Normally this is performed automatically during the render and need not be</span>
 <span class="s0">* called explicitly.</span>
 <span class="s0">*/ 1 4 this 3 106  </span>
<span class="s0">40 0 0 4 46 121 0 0 74 /**</span>
 <span class="s0">* Recalculates the character even if we think it doesn't need it.</span>
 <span class="s0">*/ 1 4 this 3 106  </span>
<span class="s0">41 0 0 7 47 129 0 0 0 0 </span>
<span class="s0">42 0 0 7 50 144 0 0 145 /**</span>
 <span class="s0">* Normally, there is no need to create a CharacterJointBundle directly.  The</span>
 <span class="s0">* Character node will automatically create one for itself.</span>
 <span class="s0">*/ 1 4 name 5 110  </span>
<span class="s0">43 0 0 7 51 106 0 0 69 /**</span>
 <span class="s0">* Returns the nth Character associated with this PartBundle.</span>
 <span class="s0">*/ 2 4 this 3 153  1 n 1 143  </span>
<span class="s0">44 0 0 7 52 129 0 0 0 0 </span>
<span class="s0">45 0 0 23 55 156 0 0 251 /**</span>
 <span class="s0">* Constructs a new CharacterJointEffect object that references the indicated</span>
 <span class="s0">* character.  When a relative get_transform() is called on the node that</span>
 <span class="s0">* contains the CharacterJointEffect, it will implicitly call</span>
 <span class="s0">* character-&gt;update() first.</span>
 <span class="s0">*/ 1 9 character 1 106  </span>
<span class="s0">46 0 0 7 56 106 0 0 158 /**</span>
 <span class="s0">* Returns the Character that will get update() called on it when this node's</span>
 <span class="s0">* relative transform is queried, or NULL if there is no such character.</span>
 <span class="s0">*/ 1 4 this 3 157  </span>
<span class="s0">47 0 0 7 57 129 0 0 0 0 </span>
<span class="s0">67</span>
<span class="s0">92 14 CharacterJoint 0 75777 14 CharacterJoint 14 CharacterJoint 0 0 0 1 48 0 0 15 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 0 0 1 0 93 0 0 0 0 111</span>
<span class="s0">/**</span>
 <span class="s0">* This represents one joint of the character's animation, containing an</span>
 <span class="s0">* animating transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">93 16 MovingPartMatrix 0 2048 16 MovingPartMatrix 16 MovingPartMatrix 0 0 0 0 0 0 0 0 0 0 0 0 84</span>
<span class="s0">/**</span>
 <span class="s0">* This is a particular kind of MovingPart that accepts a matrix each frame.</span>
 <span class="s0">*/</span>

<span class="s0">94 15 CharacterSlider 0 75777 15 CharacterSlider 15 CharacterSlider 0 0 0 1 64 0 0 1 65 0 0 1 0 95 0 0 0 0 215</span>
<span class="s0">/**</span>
 <span class="s0">* This is a morph slider within the character.  It's simply a single</span>
 <span class="s0">* floating-point value that animates generally between 0 and 1, that controls</span>
 <span class="s0">* the effects of one or more morphs within the character.</span>
 <span class="s0">*/</span>

<span class="s0">95 16 MovingPartScalar 0 2048 16 MovingPartScalar 16 MovingPartScalar 0 0 0 0 0 0 0 0 0 0 0 0 84</span>
<span class="s0">/**</span>
 <span class="s0">* This is a particular kind of MovingPart that accepts a scalar each frame.</span>
 <span class="s0">*/</span>

<span class="s0">96 21 CharacterVertexSlider 0 75777 21 CharacterVertexSlider 21 CharacterVertexSlider 0 0 0 1 66 0 0 2 67 68 0 0 1 0 97 0 0 0 0 137</span>
<span class="s0">/**</span>
 <span class="s0">* This is a specialization on VertexSlider that returns the slider value</span>
 <span class="s0">* associated with a particular CharacterSlider object.</span>
 <span class="s0">*/</span>

<span class="s0">97 12 VertexSlider 0 2048 12 VertexSlider 12 VertexSlider 0 0 0 0 0 0 0 0 0 0 0 0 343</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class that retains some slider value, which is a</span>
 <span class="s0">* linear value that typically ranges from 0.0 to 1.0, and is used to control</span>
 <span class="s0">* the animation of morphs (blend shapes).</span>
 <span class="s0">*</span>
 <span class="s0">* It is similar to VertexTransform, which keeps a full 4x4 transform matrix,</span>
 <span class="s0">* but the VertexSlider only keeps a single float value.</span>
 <span class="s0">*/</span>

<span class="s0">98 20 JointVertexTransform 0 75777 20 JointVertexTransform 20 JointVertexTransform 0 0 0 1 69 0 0 2 70 71 0 0 1 0 99 0 0 0 0 486</span>
<span class="s0">/**</span>
 <span class="s0">* This is a specialization on VertexTransform that returns the transform</span>
 <span class="s0">* necessary to move vertices as if they were assigned to the indicated joint.</span>
 <span class="s0">* The geometry itself should be parented to the scene graph at the level of</span>
 <span class="s0">* the character's root joint; that is, it should not be parented under a node</span>
 <span class="s0">* directly animated by any joints.</span>
 <span class="s0">*</span>
 <span class="s0">* Multiple combinations of these with different weights are used to implement</span>
 <span class="s0">* soft-skinned vertices for an animated character.</span>
 <span class="s0">*/</span>

<span class="s0">99 15 VertexTransform 0 2048 15 VertexTransform 15 VertexTransform 0 0 0 0 0 0 0 0 0 0 0 0 305</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class that holds a pointer to some transform,</span>
 <span class="s0">* computed in some arbitrary way, that is to be applied to vertices during</span>
 <span class="s0">* rendering.  This is used to implement soft-skinned and animated vertices.</span>
 <span class="s0">* Derived classes will define how the transform is actually computed.</span>
 <span class="s0">*/</span>

<span class="s0">100 9 Character 0 75777 9 Character 9 Character 0 0 0 1 72 0 0 12 73 74 75 76 77 78 79 80 81 82 83 84 0 0 1 0 101 0 0 0 0 117</span>
<span class="s0">/**</span>
 <span class="s0">* An animated character, with skeleton-morph animation and either soft-</span>
 <span class="s0">* skinned or hard-skinned vertices.</span>
 <span class="s0">*/</span>

<span class="s0">101 14 PartBundleNode 0 2048 14 PartBundleNode 14 PartBundleNode 0 0 0 0 0 0 0 0 0 0 0 0 342</span>
<span class="s0">/**</span>
 <span class="s0">* This is a node that contains a pointer to an PartBundle.  Like</span>
 <span class="s0">* AnimBundleNode, it exists to make it easy to store PartBundles in the scene</span>
 <span class="s0">* graph.</span>
 <span class="s0">*</span>
 <span class="s0">* (Unlike AnimBundleNode, however, PartBundleNode has an additional function:</span>
 <span class="s0">* it is also the base class of the Character node type, which adds additional</span>
 <span class="s0">* functionality.)</span>
 <span class="s0">*/</span>

<span class="s0">102 20 CharacterJointBundle 0 75777 20 CharacterJointBundle 20 CharacterJointBundle 0 0 0 1 85 0 0 2 86 87 0 0 1 0 103 0 0 0 0 73</span>
<span class="s0">/**</span>
 <span class="s0">* The collection of all the joints and sliders in the character.</span>
 <span class="s0">*/</span>

<span class="s0">103 10 PartBundle 0 2048 10 PartBundle 10 PartBundle 0 0 0 0 0 0 0 0 0 0 0 0 134</span>
<span class="s0">/**</span>
 <span class="s0">* This is the root of a MovingPart hierarchy.  It defines the hierarchy of</span>
 <span class="s0">* moving parts that make up an animatable object.</span>
 <span class="s0">*/</span>

<span class="s0">104 20 CharacterJointEffect 0 141313 20 CharacterJointEffect 20 CharacterJointEffect 0 0 0 0 91 0 3 88 89 90 0 0 1 0 105 0 0 0 0 340</span>
<span class="s0">/**</span>
 <span class="s0">* This effect will be added automatically to a node by</span>
 <span class="s0">* CharacterJoint::add_net_transform() and</span>
 <span class="s0">* CharacterJoint::add_local_transform().</span>
 <span class="s0">*</span>
 <span class="s0">* The effect binds the node back to the character, so that querying the</span>
 <span class="s0">* relative transform of the affected node will automatically force the</span>
 <span class="s0">* indicated character to be updated first.</span>
 <span class="s0">*/</span>

<span class="s0">105 12 RenderEffect 0 2048 12 RenderEffect 12 RenderEffect 0 0 0 0 0 0 0 0 0 0 0 0 901</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for a number of special render effects that may be</span>
 <span class="s0">* set on scene graph nodes to change the way they render.  This includes</span>
 <span class="s0">* BillboardEffect, DecalEffect, etc.</span>
 <span class="s0">*</span>
 <span class="s0">* RenderEffect represents render properties that must be applied as soon as</span>
 <span class="s0">* they are encountered in the scene graph, rather than propagating down to</span>
 <span class="s0">* the leaves.  This is different from RenderAttrib, which represents</span>
 <span class="s0">* properties like color and texture that don't do anything until they</span>
 <span class="s0">* propagate down to a GeomNode.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a RenderEffect directly;</span>
 <span class="s0">* instead, use the make() method of the appropriate kind of effect you want.</span>
 <span class="s0">* This will allocate and return a new RenderEffect of the appropriate type,</span>
 <span class="s0">* and it may share pointers if possible.  Do not modify the new RenderEffect</span>
 <span class="s0">* if you wish to change its properties; instead, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">106 11 Character * 0 8576 11 Character * 11 Character * 0 0 100 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">107 12 PartBundle * 0 8576 12 PartBundle * 12 PartBundle * 0 0 103 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">108 11 PartGroup * 0 8576 11 PartGroup * 11 PartGroup * 0 0 109 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">109 9 PartGroup 0 2048 9 PartGroup 9 PartGroup 0 0 0 0 0 0 0 0 0 0 0 0 105</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for PartRoot and MovingPart.  It defines a hierarchy</span>
 <span class="s0">* of MovingParts.</span>
 <span class="s0">*/</span>

<span class="s0">110 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">111 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 112 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">112 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 113 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">113 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 114 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">114 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">115 16 CharacterJoint * 0 8576 16 CharacterJoint * 16 CharacterJoint * 0 0 92 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">116 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 117 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">117 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A basic node of the scene graph or data graph.  This is the base class of</span>
 <span class="s0">* all specialized nodes, and also serves as a generic node with no special</span>
 <span class="s0">* properties.</span>
 <span class="s0">*/</span>

<span class="s0">118 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">119 22 CharacterJoint const * 0 8576 22 CharacterJoint const * 22 CharacterJoint const * 0 0 120 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">120 20 CharacterJoint const 0 8832 20 CharacterJoint const 20 CharacterJoint const 0 0 92 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">121 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">122 18 NodePathCollection 0 2048 18 NodePathCollection 18 NodePathCollection 0 0 0 0 0 0 0 0 0 0 0 0 178</span>
<span class="s0">/**</span>
 <span class="s0">* This is a set of zero or more NodePaths.  It's handy for returning from</span>
 <span class="s0">* functions that need to return multiple NodePaths (for instance,</span>
 <span class="s0">* NodePaths::get_children).</span>
 <span class="s0">*/</span>

<span class="s0">123 20 NodePathCollection * 0 8576 20 NodePathCollection * 20 NodePathCollection * 0 0 122 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">124 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 113 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">125 20 TransformState const 0 8832 20 TransformState const 20 TransformState const 0 0 126 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">126 14 TransformState 0 16779264 14 TransformState 14 TransformState 0 0 0 0 0 0 0 0 0 0 0 0 734</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates a coordinate-system transform on vertices.  TransformStates are</span>
 <span class="s0">* the primary means for storing transformations on the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* Transforms may be specified in one of two ways: componentwise, with a pos-</span>
 <span class="s0">* hpr-scale, or with an arbitrary transform matrix.  If you specify a</span>
 <span class="s0">* transform componentwise, it will remember its original components.</span>
 <span class="s0">*</span>
 <span class="s0">* TransformState objects are managed very much like RenderState objects.</span>
 <span class="s0">* They are immutable and reference-counted automatically.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a TransformState object</span>
 <span class="s0">* directly.  Instead, call one of the make() functions to create one for you.</span>
 <span class="s0">* And instead of modifying a TransformState object, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">127 22 TransformState const * 0 8576 22 TransformState const * 22 TransformState const * 0 0 125 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">128 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">129 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 128 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">130 17 CharacterSlider * 0 8576 17 CharacterSlider * 17 CharacterSlider * 0 0 94 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">131 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 132 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">132 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">133 23 CharacterVertexSlider * 0 8576 23 CharacterVertexSlider * 23 CharacterVertexSlider * 0 0 96 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">134 21 CharacterSlider const 0 8832 21 CharacterSlider const 21 CharacterSlider const 0 0 94 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">135 29 CharacterVertexSlider const * 0 8576 29 CharacterVertexSlider const * 29 CharacterVertexSlider const * 0 0 136 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">136 27 CharacterVertexSlider const 0 8832 27 CharacterVertexSlider const 27 CharacterVertexSlider const 0 0 96 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">137 23 CharacterSlider const * 0 8576 23 CharacterSlider const * 23 CharacterSlider const * 0 0 134 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">138 22 JointVertexTransform * 0 8576 22 JointVertexTransform * 22 JointVertexTransform * 0 0 98 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">139 28 JointVertexTransform const * 0 8576 28 JointVertexTransform const * 28 JointVertexTransform const * 0 0 140 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">140 26 JointVertexTransform const 0 8832 26 JointVertexTransform const 26 JointVertexTransform const 0 0 98 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">141 17 Character const * 0 8576 17 Character const * 17 Character const * 0 0 142 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">142 15 Character const 0 8832 15 Character const 15 Character const 0 0 100 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">143 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">144 22 CharacterJointBundle * 0 8576 22 CharacterJointBundle * 22 CharacterJointBundle * 0 0 102 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">145 18 PartBundleHandle * 0 8576 18 PartBundleHandle * 18 PartBundleHandle * 0 0 146 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">146 16 PartBundleHandle 0 2048 16 PartBundleHandle 16 PartBundleHandle 0 0 0 0 0 0 0 0 0 0 0 0 546</span>
<span class="s0">/**</span>
 <span class="s0">* This is a trivial class returned by PartBundleNode::get_bundle().  Its</span>
 <span class="s0">* purpose is to hold the actual PartBundle pointer contained within the</span>
 <span class="s0">* PartBundleNode, so that scene graph flatten operations can safely combine</span>
 <span class="s0">* or duplicate PartBundles as necessary without affecting high-level bundle</span>
 <span class="s0">* operations.</span>
 <span class="s0">*</span>
 <span class="s0">* The high-level Actor class defined in direct/src/actor, for instance, will</span>
 <span class="s0">* store a list of PartBundleHandles instead of on actual PartBundles, so that</span>
 <span class="s0">* it will be immune to changes from these flatten operations.</span>
 <span class="s0">*/</span>

<span class="s0">147 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 148 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">148 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 149 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">149 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 150 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">150 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">151 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 152 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">152 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">153 28 CharacterJointBundle const * 0 8576 28 CharacterJointBundle const * 28 CharacterJointBundle const * 0 0 154 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">154 26 CharacterJointBundle const 0 8832 26 CharacterJointBundle const 26 CharacterJointBundle const 0 0 102 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">155 18 RenderEffect const 0 8832 18 RenderEffect const 18 RenderEffect const 0 0 105 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">156 20 RenderEffect const * 0 8576 20 RenderEffect const * 20 RenderEffect const * 0 0 155 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">157 28 CharacterJointEffect const * 0 8576 28 CharacterJointEffect const * 28 CharacterJointEffect const * 0 0 158 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">158 26 CharacterJointEffect const 0 8832 26 CharacterJointEffect const 26 CharacterJointEffect const 0 0 104 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">0</span>
<span class="s0">0</span>
</pre>
</body>
</html>