<html>
<head>
<title>libp3movies.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3movies.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">11 libp3movies 4 Aas2 12 panda3d.core </span>
<span class="s0">92</span>
<span class="s0">104 37 upcast_to_TypedWritableReferenceCount 0 12 196 49 MovieAudio::upcast_to_TypedWritableReferenceCount 0 1 7 53</span>
<span class="s0">upcast from MovieAudio to TypedWritableReferenceCount</span>
<span class="s0">85</span>
<span class="s0">TypedWritableReferenceCount *MovieAudio::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">105 22 downcast_to_MovieAudio 0 12 197 51 TypedWritableReferenceCount::downcast_to_MovieAudio 0 0 55</span>
<span class="s0">downcast from TypedWritableReferenceCount to MovieAudio</span>
<span class="s0">70</span>
<span class="s0">MovieAudio *TypedWritableReferenceCount::downcast_to_MovieAudio(void);</span>

<span class="s0">106 17 upcast_to_Namable 0 12 196 29 MovieAudio::upcast_to_Namable 0 1 8 33</span>
<span class="s0">upcast from MovieAudio to Namable</span>
<span class="s0">45</span>
<span class="s0">Namable *MovieAudio::upcast_to_Namable(void);</span>

<span class="s0">107 22 downcast_to_MovieAudio 0 12 198 31 Namable::downcast_to_MovieAudio 0 0 35</span>
<span class="s0">downcast from Namable to MovieAudio</span>
<span class="s0">50</span>
<span class="s0">MovieAudio *Namable::downcast_to_MovieAudio(void);</span>

<span class="s0">108 10 MovieAudio 0 260 196 22 MovieAudio::MovieAudio 0 2 1 2 200</span>
<span class="s0">/**</span>
 <span class="s0">* This constructor returns a null audio stream --- a stream of total silence,</span>
 <span class="s0">* at 8000 samples per second.  To get more interesting audio, you need to</span>
 <span class="s0">* construct a subclass of this class.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">explicit MovieAudio::MovieAudio(std::string const &amp;name = &quot;Blank Audio&quot;);</span>
<span class="s0">inline MovieAudio::MovieAudio(MovieAudio const &amp;) = default;</span>

<span class="s0">109 11 ~MovieAudio 0 518 196 23 MovieAudio::~MovieAudio 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">virtual MovieAudio::~MovieAudio(void);</span>

<span class="s0">110 4 open 0 6 196 16 MovieAudio::open 0 1 3 56</span>
<span class="s0">/**</span>
 <span class="s0">* Open this audio, returning a MovieAudioCursor</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual PointerTo&lt; MovieAudioCursor &gt; MovieAudio::open(void);</span>

<span class="s0">111 3 get 0 4 196 15 MovieAudio::get 0 1 4 103</span>
<span class="s0">/**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.  Just calls</span>
 <span class="s0">* MovieTypeRegistry::make_audio().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static PointerTo&lt; MovieAudio &gt; MovieAudio::get(Filename const &amp;name);</span>

<span class="s0">112 12 get_filename 0 4 196 24 MovieAudio::get_filename 0 1 5 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the movie's filename.  A movie is not guaranteed to have a</span>
 <span class="s0">* filename, if not, then this function returns a null filename.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline Filename const &amp;MovieAudio::get_filename(void) const;</span>

<span class="s0">113 14 get_class_type 0 4 196 26 MovieAudio::get_class_type 0 1 6 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle MovieAudio::get_class_type(void);</span>

<span class="s0">114 9 FlacAudio 0 260 201 20 FlacAudio::FlacAudio 0 2 9 10 14</span>
<span class="s0">/**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">FlacAudio::FlacAudio(Filename const &amp;name);</span>
<span class="s0">inline FlacAudio::FlacAudio(FlacAudio const &amp;) = default;</span>

<span class="s0">115 4 make 0 4 201 15 FlacAudio::make 0 1 11 55</span>
<span class="s0">/**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static PointerTo&lt; MovieAudio &gt; FlacAudio::make(Filename const &amp;name);</span>

<span class="s0">116 14 get_class_type 0 4 201 25 FlacAudio::get_class_type 0 1 12 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle FlacAudio::get_class_type(void);</span>

<span class="s0">117 16 MovieAudioCursor 0 260 202 34 MovieAudioCursor::MovieAudioCursor 0 2 13 14 200</span>
<span class="s0">/**</span>
 <span class="s0">* This constructor returns a null audio stream --- a stream of total silence,</span>
 <span class="s0">* at 8000 samples per second.  To get more interesting audio, you need to</span>
 <span class="s0">* construct a subclass of this class.</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">MovieAudioCursor::MovieAudioCursor(MovieAudio *src);</span>
<span class="s0">inline MovieAudioCursor::MovieAudioCursor(MovieAudioCursor const &amp;) = default;</span>

<span class="s0">118 10 get_source 0 4 202 28 MovieAudioCursor::get_source 0 1 15 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the MovieAudio which this cursor references.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline PointerTo&lt; MovieAudio &gt; MovieAudioCursor::get_source(void) const;</span>

<span class="s0">119 10 audio_rate 0 4 202 28 MovieAudioCursor::audio_rate 0 1 16 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the audio sample rate.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int MovieAudioCursor::audio_rate(void) const;</span>

<span class="s0">120 14 audio_channels 0 4 202 32 MovieAudioCursor::audio_channels 0 1 17 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of audio channels (ie, two for stereo, one for mono).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int MovieAudioCursor::audio_channels(void) const;</span>

<span class="s0">121 6 length 0 4 202 24 MovieAudioCursor::length 0 1 18 742</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the movie.  Attempting to read audio samples beyond</span>
 <span class="s0">* the specified length will produce silent samples.</span>
 <span class="s0">*</span>
 <span class="s0">* Some kinds of Movie, such as internet TV station, might not have a</span>
 <span class="s0">* predictable length.  In that case, the length will be set to a very large</span>
 <span class="s0">* number: 1.0E10.</span>
 <span class="s0">*</span>
 <span class="s0">* Some AVI files have incorrect length values encoded into them - they may be</span>
 <span class="s0">* a second or two long or short.  When playing such an AVI using the Movie</span>
 <span class="s0">* class, you may see a slightly truncated video, or a slightly elongated</span>
 <span class="s0">* video (padded with black frames).  There are utilities out there to fix the</span>
 <span class="s0">* length values in AVI files.</span>
 <span class="s0">*</span>
 <span class="s0">* An audio consumer needs to check the length, the ready status, and the</span>
 <span class="s0">* aborted flag.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline double MovieAudioCursor::length(void) const;</span>

<span class="s0">122 8 can_seek 0 4 202 26 MovieAudioCursor::can_seek 0 1 19 429</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the movie can seek.  If this is true, seeking is still not</span>
 <span class="s0">* guaranteed to be fast: for some movies, seeking is implemented by rewinding</span>
 <span class="s0">* to the beginning and then fast-forwarding to the desired location.  Even if</span>
 <span class="s0">* the movie cannot seek, the seek method can still advance to an arbitrary</span>
 <span class="s0">* location by reading samples and discarding them.  However, to move</span>
 <span class="s0">* backward, can_seek must return true.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool MovieAudioCursor::can_seek(void) const;</span>

<span class="s0">123 13 can_seek_fast 0 4 202 31 MovieAudioCursor::can_seek_fast 0 1 20 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if seek operations are constant time.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool MovieAudioCursor::can_seek_fast(void) const;</span>

<span class="s0">124 4 tell 0 4 202 22 MovieAudioCursor::tell 0 1 21 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current offset within the file.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline double MovieAudioCursor::tell(void) const;</span>

<span class="s0">125 12 skip_samples 0 4 202 30 MovieAudioCursor::skip_samples 0 1 22 86</span>
<span class="s0">/**</span>
 <span class="s0">* Skip audio samples from the stream.  This is mostly for debugging purposes.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void MovieAudioCursor::skip_samples(int n);</span>

<span class="s0">126 7 aborted 0 4 202 25 MovieAudioCursor::aborted 0 1 23 138</span>
<span class="s0">/**</span>
 <span class="s0">* If aborted is true, it means that the &quot;ready&quot; samples are not being</span>
 <span class="s0">* replenished.  See the method &quot;ready&quot; for an explanation.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool MovieAudioCursor::aborted(void) const;</span>

<span class="s0">127 5 ready 0 6 202 23 MovieAudioCursor::ready 0 1 24 1120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of audio samples that are ready to read.  This is</span>
 <span class="s0">* primarily relevant for sources like microphones which produce samples at a</span>
 <span class="s0">* fixed rate.  If you try to read more samples than are ready, the result</span>
 <span class="s0">* will be silent samples.</span>
 <span class="s0">*</span>
 <span class="s0">* Some audio streams do not have a limit on how fast they can produce</span>
 <span class="s0">* samples.  Such streams will always return 0x40000000 as the ready-count.</span>
 <span class="s0">* This may well exceed the length of the audio stream.  You therefore need to</span>
 <span class="s0">* check length separately.</span>
 <span class="s0">*</span>
 <span class="s0">* If the aborted flag is set, that means the ready count is no longer being</span>
 <span class="s0">* replenished.  For example, a MovieAudioCursor might be reading from an</span>
 <span class="s0">* internet radio station, and it might buffer data to avoid underruns.  If it</span>
 <span class="s0">* loses connection to the radio station, it will set the aborted flag to</span>
 <span class="s0">* indicate that the buffer is no longer being replenished.  But it is still</span>
 <span class="s0">* ok to read the samples that are in the buffer, at least until they run out.</span>
 <span class="s0">* Once those are gone, there will be no more.</span>
 <span class="s0">*</span>
 <span class="s0">* An audio consumer needs to check the length, the ready status, and the</span>
 <span class="s0">* aborted flag.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">virtual int MovieAudioCursor::ready(void) const;</span>

<span class="s0">128 4 seek 0 6 202 22 MovieAudioCursor::seek 0 1 25 746</span>
<span class="s0">/**</span>
 <span class="s0">* Skips to the specified offset within the file.</span>
 <span class="s0">*</span>
 <span class="s0">* If the movie reports that it cannot seek, then this method can still</span>
 <span class="s0">* advance by reading samples and discarding them.  However, to move backward,</span>
 <span class="s0">* can_seek must be true.</span>
 <span class="s0">*</span>
 <span class="s0">* If the movie reports that it can_seek, it doesn't mean that it can do so</span>
 <span class="s0">* quickly.  It may have to rewind the movie and then fast forward to the</span>
 <span class="s0">* desired location.  Only if can_seek_fast returns true can seek operations</span>
 <span class="s0">* be done in constant time.</span>
 <span class="s0">*</span>
 <span class="s0">* Seeking may not be precise, because AVI files often have inaccurate</span>
 <span class="s0">* indices.  After seeking, tell will indicate that the cursor is at the</span>
 <span class="s0">* target location.  However, in truth, the data you read may come from a</span>
 <span class="s0">* slightly offset location.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">virtual void MovieAudioCursor::seek(double offset);</span>

<span class="s0">129 12 read_samples 0 4 202 30 MovieAudioCursor::read_samples 0 2 26 27 798</span>
<span class="s0">/**</span>
 <span class="s0">* Read audio samples from the stream.  N is the number of samples you wish to</span>
 <span class="s0">* read.  Your buffer must be equal in size to N * channels.  Multiple-channel</span>
 <span class="s0">* audio will be interleaved.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Read audio samples from the stream into a Datagram.  N is the number of</span>
 <span class="s0">* samples you wish to read.  Multiple-channel audio will be interleaved.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not particularly efficient, but it may be a convenient way to</span>
 <span class="s0">* manipulate samples in python.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Read audio samples from the stream and returns them as a string.  The</span>
 <span class="s0">* samples are stored little-endian in the string.  N is the number of samples</span>
 <span class="s0">* you wish to read.  Multiple-channel audio will be interleaved.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not particularly efficient, but it may be a convenient way to</span>
 <span class="s0">* manipulate samples in python.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">void MovieAudioCursor::read_samples(int n, Datagram *dg);</span>
<span class="s0">std::string MovieAudioCursor::read_samples(int n);</span>

<span class="s0">130 14 get_class_type 0 4 202 32 MovieAudioCursor::get_class_type 0 1 28 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle MovieAudioCursor::get_class_type(void);</span>

<span class="s0">131 15 FlacAudioCursor 0 260 203 32 FlacAudioCursor::FlacAudioCursor 0 2 29 30 129</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the .wav header from the indicated stream.  This leaves the read</span>
 <span class="s0">* pointer positioned at the start of the data.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">explicit FlacAudioCursor::FlacAudioCursor(FlacAudio *src, std::istream *stream);</span>
<span class="s0">inline FlacAudioCursor::FlacAudioCursor(FlacAudioCursor const &amp;) = default;</span>

<span class="s0">132 14 get_class_type 0 4 203 31 FlacAudioCursor::get_class_type 0 1 31 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle FlacAudioCursor::get_class_type(void);</span>

<span class="s0">133 37 upcast_to_TypedWritableReferenceCount 0 12 204 49 MovieVideo::upcast_to_TypedWritableReferenceCount 0 1 39 53</span>
<span class="s0">upcast from MovieVideo to TypedWritableReferenceCount</span>
<span class="s0">85</span>
<span class="s0">TypedWritableReferenceCount *MovieVideo::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">134 22 downcast_to_MovieVideo 0 12 197 51 TypedWritableReferenceCount::downcast_to_MovieVideo 0 0 55</span>
<span class="s0">downcast from TypedWritableReferenceCount to MovieVideo</span>
<span class="s0">70</span>
<span class="s0">MovieVideo *TypedWritableReferenceCount::downcast_to_MovieVideo(void);</span>

<span class="s0">135 17 upcast_to_Namable 0 12 204 29 MovieVideo::upcast_to_Namable 0 1 40 33</span>
<span class="s0">upcast from MovieVideo to Namable</span>
<span class="s0">45</span>
<span class="s0">Namable *MovieVideo::upcast_to_Namable(void);</span>

<span class="s0">136 22 downcast_to_MovieVideo 0 12 198 31 Namable::downcast_to_MovieVideo 0 0 35</span>
<span class="s0">downcast from Namable to MovieVideo</span>
<span class="s0">50</span>
<span class="s0">MovieVideo *Namable::downcast_to_MovieVideo(void);</span>

<span class="s0">137 10 MovieVideo 0 260 204 22 MovieVideo::MovieVideo 0 2 32 33 212</span>
<span class="s0">/**</span>
 <span class="s0">* This constructor returns a null video stream --- a stream of plain blue and</span>
 <span class="s0">* white frames that last one second each.  To get more interesting video, you</span>
 <span class="s0">* need to construct a subclass of this class.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">MovieVideo::MovieVideo(std::string const &amp;name = &quot;Blank Video&quot;);</span>
<span class="s0">inline MovieVideo::MovieVideo(MovieVideo const &amp;) = default;</span>

<span class="s0">138 11 ~MovieVideo 0 518 204 23 MovieVideo::~MovieVideo 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">virtual MovieVideo::~MovieVideo(void);</span>

<span class="s0">139 4 open 0 6 204 16 MovieVideo::open 0 1 34 107</span>
<span class="s0">/**</span>
 <span class="s0">* Open this video, returning a MovieVideoCursor of the appropriate type.</span>
 <span class="s0">* Returns NULL on error.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual PointerTo&lt; MovieVideoCursor &gt; MovieVideo::open(void);</span>

<span class="s0">140 3 get 0 4 204 15 MovieVideo::get 0 1 35 103</span>
<span class="s0">/**</span>
 <span class="s0">* Obtains a MovieVideo that references a file.  Just calls</span>
 <span class="s0">* MovieTypeRegistry::make_video().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static PointerTo&lt; MovieVideo &gt; MovieVideo::get(Filename const &amp;name);</span>

<span class="s0">141 12 get_filename 0 4 204 24 MovieVideo::get_filename 0 1 36 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the movie's filename.  A movie is not guaranteed to have a</span>
 <span class="s0">* filename, if not, then this function returns an empty filename.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline Filename const &amp;MovieVideo::get_filename(void) const;</span>

<span class="s0">142 16 get_subfile_info 0 4 204 28 MovieVideo::get_subfile_info 0 1 37 150</span>
<span class="s0">/**</span>
 <span class="s0">* If the movie is to be loaded from a subfile on disk, this returns the</span>
 <span class="s0">* subfile info.  Check info.is_empty() to see if this is valid data.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline SubfileInfo const &amp;MovieVideo::get_subfile_info(void) const;</span>

<span class="s0">143 14 get_class_type 0 4 204 26 MovieVideo::get_class_type 0 1 38 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle MovieVideo::get_class_type(void);</span>

<span class="s0">144 12 InkblotVideo 0 260 207 26 InkblotVideo::InkblotVideo 0 2 41 42 14</span>
<span class="s0">/**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">explicit InkblotVideo::InkblotVideo(int x, int y, int fps);</span>
<span class="s0">inline InkblotVideo::InkblotVideo(InkblotVideo const &amp;) = default;</span>

<span class="s0">145 14 get_class_type 0 4 207 28 InkblotVideo::get_class_type 0 1 43 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle InkblotVideo::get_class_type(void);</span>

<span class="s0">146 10 get_source 0 4 208 28 MovieVideoCursor::get_source 0 1 45 59</span>
<span class="s0">/**</span>
 <span class="s0">* Get the MovieVideo which this cursor references.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">PointerTo&lt; MovieVideo &gt; MovieVideoCursor::get_source(void) const;</span>

<span class="s0">147 6 size_x 0 4 208 24 MovieVideoCursor::size_x 0 1 46 48</span>
<span class="s0">/**</span>
 <span class="s0">* Get the horizontal size of the movie.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int MovieVideoCursor::size_x(void) const;</span>

<span class="s0">148 6 size_y 0 4 208 24 MovieVideoCursor::size_y 0 1 47 46</span>
<span class="s0">/**</span>
 <span class="s0">* Get the vertical size of the movie.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int MovieVideoCursor::size_y(void) const;</span>

<span class="s0">149 18 get_num_components 0 4 208 36 MovieVideoCursor::get_num_components 0 1 48 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 4 if the movie has an alpha channel, 3 otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int MovieVideoCursor::get_num_components(void) const;</span>

<span class="s0">150 6 length 0 4 208 24 MovieVideoCursor::length 0 1 49 1170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the movie.</span>
 <span class="s0">*</span>
 <span class="s0">* Some kinds of Movie, such as internet TV station, might not have a</span>
 <span class="s0">* predictable length.  In that case, the length will be set to a very large</span>
 <span class="s0">* number: 1.0E10. If the internet TV station goes offline, the video or audio</span>
 <span class="s0">* stream will set its abort flag.  Reaching the end of the movie (ie, the</span>
 <span class="s0">* specified length) normally does not cause the abort flag to be set.</span>
 <span class="s0">*</span>
 <span class="s0">* The video and audio streams produced by get_video and get_audio are always</span>
 <span class="s0">* of unlimited duration - you can always read another video frame or another</span>
 <span class="s0">* audio sample.  This is true even if the specified length is reached, or an</span>
 <span class="s0">* abort is flagged.  If either stream runs out of data, it will synthesize</span>
 <span class="s0">* blank video frames and silent audio samples as necessary to satisfy read</span>
 <span class="s0">* requests.</span>
 <span class="s0">*</span>
 <span class="s0">* Some AVI files have incorrect length values encoded into them - usually,</span>
 <span class="s0">* they're a second or two long or short.  When playing such an AVI using the</span>
 <span class="s0">* Movie class, you may see a slightly truncated video, or a slightly</span>
 <span class="s0">* elongated video (padded with black frames).  There are utilities out there</span>
 <span class="s0">* to fix the length values in AVI files.</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline double MovieVideoCursor::length(void) const;</span>

<span class="s0">151 8 can_seek 0 4 208 26 MovieVideoCursor::can_seek 0 1 50 430</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the movie can seek.  If this is true, seeking is still not</span>
 <span class="s0">* guaranteed to be fast: for some movies, seeking is implemented by rewinding</span>
 <span class="s0">* to the beginning and then fast-forwarding to the desired location.  Even if</span>
 <span class="s0">* the movie cannot seek, the fetch methods can still advance to an arbitrary</span>
 <span class="s0">* location by reading frames and discarding them.  However, to move backward,</span>
 <span class="s0">* can_seek must return true.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool MovieVideoCursor::can_seek(void) const;</span>

<span class="s0">152 13 can_seek_fast 0 4 208 31 MovieVideoCursor::can_seek_fast 0 1 51 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if seek operations are constant time.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool MovieVideoCursor::can_seek_fast(void) const;</span>

<span class="s0">153 7 aborted 0 4 208 25 MovieVideoCursor::aborted 0 1 52 260</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the video has aborted prematurely.  For example, this could</span>
 <span class="s0">* occur if the Movie was actually an internet TV station, and the connection</span>
 <span class="s0">* was lost.  Reaching the normal end of the video does not constitute an</span>
 <span class="s0">* 'abort' condition.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool MovieVideoCursor::aborted(void) const;</span>

<span class="s0">154 5 ready 0 4 208 23 MovieVideoCursor::ready 0 1 53 156</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the cursor is a streaming source, and if a video frame is</span>
 <span class="s0">* ready to be read.  For non- streaming sources, this is always false.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool MovieVideoCursor::ready(void) const;</span>

<span class="s0">155 9 streaming 0 4 208 27 MovieVideoCursor::streaming 0 1 54 528</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the video frames are being &quot;pushed&quot; at us by something that</span>
 <span class="s0">* operates at its own speed - for example, a webcam.  In this case, the</span>
 <span class="s0">* frames come when they're ready to come.  Attempting to read too soon will</span>
 <span class="s0">* produce nothing, reading too late will cause frames to be dropped.  In this</span>
 <span class="s0">* case, the ready flag can be used to determine whether or not a frame is</span>
 <span class="s0">* ready for reading.</span>
 <span class="s0">*</span>
 <span class="s0">* When streaming, you should still pay attention to last_start, but the value</span>
 <span class="s0">* of next_start is only a guess.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool MovieVideoCursor::streaming(void) const;</span>

<span class="s0">156 13 setup_texture 0 4 208 31 MovieVideoCursor::setup_texture 0 1 55 130</span>
<span class="s0">/**</span>
 <span class="s0">* Set up the specified Texture object to contain content from this movie.</span>
 <span class="s0">* This should be called once, not every frame.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void MovieVideoCursor::setup_texture(Texture *tex) const;</span>

<span class="s0">157 8 set_time 0 6 208 26 MovieVideoCursor::set_time 0 1 56 850</span>
<span class="s0">/**</span>
 <span class="s0">* Updates the cursor to the indicated time.  If loop_count &gt;= 1, the time is</span>
 <span class="s0">* clamped to the movie's length * loop_count.  If loop_count &lt;= 0, the time</span>
 <span class="s0">* is understood to be modulo the movie's length.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if a new frame is now available, false otherwise.  If this</span>
 <span class="s0">* returns true, you should immediately follow this with exactly *one* call to</span>
 <span class="s0">* fetch_buffer().</span>
 <span class="s0">*</span>
 <span class="s0">* If the movie reports that it can_seek, you may also specify a time value</span>
 <span class="s0">* less than the previous value you passed to set_time().  Otherwise, you may</span>
 <span class="s0">* only specify a time value greater than or equal to the previous value.</span>
 <span class="s0">*</span>
 <span class="s0">* If the movie reports that it can_seek, it doesn't mean that it can do so</span>
 <span class="s0">* quickly.  It may have to rewind the movie and then fast forward to the</span>
 <span class="s0">* desired location.  Only if can_seek_fast returns true can it seek rapidly.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">virtual bool MovieVideoCursor::set_time(double timestamp, int loop_count);</span>

<span class="s0">158 17 compare_timestamp 0 6 209 43 MovieVideoCursor::Buffer::compare_timestamp 0 1 63 335</span>
<span class="s0">/**</span>
 <span class="s0">* Used to sort different buffers to ensure they correspond to the same source</span>
 <span class="s0">* frame, particularly important when synchronizing the different pages of a</span>
 <span class="s0">* multi-page texture.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns 0 if the two buffers are of the same frame, &lt;0 if this one comes</span>
 <span class="s0">* earlier than the other one, and &gt;0 if the other one comes earlier.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">virtual int MovieVideoCursor::Buffer::compare_timestamp(MovieVideoCursor::Buffer const *other) const;</span>

<span class="s0">159 13 get_timestamp 0 6 209 39 MovieVideoCursor::Buffer::get_timestamp 0 1 64 236</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nearest timestamp value of this particular buffer.  Ideally,</span>
 <span class="s0">* MovieVideoCursor::set_time() for this timestamp would return this buffer</span>
 <span class="s0">* again.  This need be defined only if compare_timestamp() is also defined.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">virtual double MovieVideoCursor::Buffer::get_timestamp(void) const;</span>

<span class="s0">160 14 get_class_type 0 4 209 40 MovieVideoCursor::Buffer::get_class_type 0 1 65 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle MovieVideoCursor::Buffer::get_class_type(void);</span>

<span class="s0">161 6 Buffer 0 260 209 32 MovieVideoCursor::Buffer::Buffer 0 1 62 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline MovieVideoCursor::Buffer::Buffer(MovieVideoCursor::Buffer const &amp;) = default;</span>

<span class="s0">162 12 fetch_buffer 0 6 208 30 MovieVideoCursor::fetch_buffer 0 1 57 331</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the current video frame (as specified by set_time()) from the movie</span>
 <span class="s0">* and returns it in a pre-allocated buffer.  You may simply let the buffer</span>
 <span class="s0">* dereference and delete itself when you are done with it.</span>
 <span class="s0">*</span>
 <span class="s0">* This may return NULL (even if set_time() returned true) if the frame is not</span>
 <span class="s0">* available for some reason.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">virtual PointerTo&lt; MovieVideoCursor::Buffer &gt; MovieVideoCursor::fetch_buffer(void);</span>

<span class="s0">163 16 apply_to_texture 0 6 208 34 MovieVideoCursor::apply_to_texture 0 1 58 66</span>
<span class="s0">/**</span>
 <span class="s0">* Stores this buffer's contents in the indicated texture.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">virtual void MovieVideoCursor::apply_to_texture(MovieVideoCursor::Buffer const *buffer, Texture *t, int page);</span>

<span class="s0">164 20 apply_to_texture_rgb 0 6 208 38 MovieVideoCursor::apply_to_texture_rgb 0 1 59 140</span>
<span class="s0">/**</span>
 <span class="s0">* Copies this buffer's contents into the RGB channels of the supplied</span>
 <span class="s0">* texture.  The alpha channel of the texture is not touched.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">virtual void MovieVideoCursor::apply_to_texture_rgb(MovieVideoCursor::Buffer const *buffer, Texture *t, int page);</span>

<span class="s0">165 22 apply_to_texture_alpha 0 6 208 40 MovieVideoCursor::apply_to_texture_alpha 0 1 60 141</span>
<span class="s0">/**</span>
 <span class="s0">* Copies this buffer's contents into the alpha channel of the supplied</span>
 <span class="s0">* texture.  The RGB channels of the texture are not touched.</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">virtual void MovieVideoCursor::apply_to_texture_alpha(MovieVideoCursor::Buffer const *buffer, Texture *t, int page, int alpha_src);</span>

<span class="s0">166 14 get_class_type 0 4 208 32 MovieVideoCursor::get_class_type 0 1 61 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle MovieVideoCursor::get_class_type(void);</span>

<span class="s0">167 16 MovieVideoCursor 0 260 208 34 MovieVideoCursor::MovieVideoCursor 0 1 44 121</span>
<span class="s0">/**</span>
 <span class="s0">* This is a virtual base class and should not be created directly.  Instead,</span>
 <span class="s0">* create a more specialized class.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline MovieVideoCursor::MovieVideoCursor(MovieVideoCursor const &amp;) = default;</span>

<span class="s0">168 18 InkblotVideoCursor 0 260 211 38 InkblotVideoCursor::InkblotVideoCursor 0 2 66 67 14</span>
<span class="s0">/**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src);</span>
<span class="s0">inline InkblotVideoCursor::InkblotVideoCursor(InkblotVideoCursor const &amp;) = default;</span>

<span class="s0">169 14 get_class_type 0 4 211 34 InkblotVideoCursor::get_class_type 0 1 68 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle InkblotVideoCursor::get_class_type(void);</span>

<span class="s0">170 15 get_num_options 0 4 212 32 MicrophoneAudio::get_num_options 0 1 69 218</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of microphone options.  An &quot;option&quot; consists of a device</span>
 <span class="s0">* plus a set of configuration parameters.  For example, &quot;Soundblaster Audigy</span>
 <span class="s0">* Line in at 44,100 samples/sec&quot; would be an option.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static int MicrophoneAudio::get_num_options(void);</span>

<span class="s0">171 10 get_option 0 4 212 27 MicrophoneAudio::get_option 0 1 70 45</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth microphone option.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static PointerTo&lt; MicrophoneAudio &gt; MicrophoneAudio::get_option(int n);</span>

<span class="s0">172 12 get_channels 0 4 212 29 MicrophoneAudio::get_channels 0 1 71 42</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of channels.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int MicrophoneAudio::get_channels(void) const;</span>

<span class="s0">173 8 get_rate 0 4 212 25 MicrophoneAudio::get_rate 0 1 72 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sample rate.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int MicrophoneAudio::get_rate(void) const;</span>

<span class="s0">174 14 get_class_type 0 4 212 31 MicrophoneAudio::get_class_type 0 1 73 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle MicrophoneAudio::get_class_type(void);</span>

<span class="s0">175 9 OpusAudio 0 260 215 20 OpusAudio::OpusAudio 0 2 74 75 14</span>
<span class="s0">/**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">OpusAudio::OpusAudio(Filename const &amp;name);</span>
<span class="s0">inline OpusAudio::OpusAudio(OpusAudio const &amp;) = default;</span>

<span class="s0">176 4 make 0 4 215 15 OpusAudio::make 0 1 76 55</span>
<span class="s0">/**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static PointerTo&lt; MovieAudio &gt; OpusAudio::make(Filename const &amp;name);</span>

<span class="s0">177 14 get_class_type 0 4 215 25 OpusAudio::get_class_type 0 1 77 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle OpusAudio::get_class_type(void);</span>

<span class="s0">178 15 OpusAudioCursor 0 260 216 32 OpusAudioCursor::OpusAudioCursor 0 2 78 79 129</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the .wav header from the indicated stream.  This leaves the read</span>
 <span class="s0">* pointer positioned at the start of the data.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">explicit OpusAudioCursor::OpusAudioCursor(OpusAudio *src, std::istream *stream);</span>
<span class="s0">inline OpusAudioCursor::OpusAudioCursor(OpusAudioCursor const &amp;) = default;</span>

<span class="s0">179 14 get_class_type 0 4 216 31 OpusAudioCursor::get_class_type 0 1 80 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle OpusAudioCursor::get_class_type(void);</span>

<span class="s0">180 13 UserDataAudio 0 260 217 28 UserDataAudio::UserDataAudio 0 2 81 82 104</span>
<span class="s0">/**</span>
 <span class="s0">* This constructor returns a UserDataAudio --- a means to supply raw audio</span>
 <span class="s0">* samples manually.</span>
 <span class="s0">*/</span>
<span class="s0">154</span>
<span class="s0">UserDataAudio::UserDataAudio(int rate, int channels, bool remove_after_read = true);</span>
<span class="s0">inline UserDataAudio::UserDataAudio(UserDataAudio const &amp;) = default;</span>

<span class="s0">181 6 append 0 4 217 21 UserDataAudio::append 0 2 83 84 413</span>
<span class="s0">/**</span>
 <span class="s0">* Appends audio samples to the buffer.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Appends audio samples to the buffer from a datagram.  This is intended to</span>
 <span class="s0">* make it easy to send streaming raw audio over a network.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Appends audio samples to the buffer from a string.  The samples must be</span>
 <span class="s0">* stored little-endian in the string.  This is not particularly efficient,</span>
 <span class="s0">* but it may be convenient to deal with samples in python.</span>
 <span class="s0">*/</span>
<span class="s0">174</span>
<span class="s0">void UserDataAudio::append(int16_t *data, int n);</span>
<span class="s0">void UserDataAudio::append(DatagramIterator *src, int len = 1073741824);</span>
<span class="s0">void UserDataAudio::append(std::string const &amp;str);</span>

<span class="s0">182 4 done 0 4 217 19 UserDataAudio::done 0 1 85 143</span>
<span class="s0">// A promise not to write any more samples.</span>

<span class="s0">/**</span>
 <span class="s0">* Promises not to append any more samples, ie, this marks the end of the</span>
 <span class="s0">* audio stream.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void UserDataAudio::done(void);</span>

<span class="s0">183 14 get_class_type 0 4 217 29 UserDataAudio::get_class_type 0 1 86 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle UserDataAudio::get_class_type(void);</span>

<span class="s0">184 19 UserDataAudioCursor 0 260 218 40 UserDataAudioCursor::UserDataAudioCursor 0 2 87 88 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src);</span>
<span class="s0">inline UserDataAudioCursor::UserDataAudioCursor(UserDataAudioCursor const &amp;) = default;</span>

<span class="s0">185 14 get_class_type 0 4 218 35 UserDataAudioCursor::get_class_type 0 1 89 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle UserDataAudioCursor::get_class_type(void);</span>

<span class="s0">186 11 VorbisAudio 0 260 219 24 VorbisAudio::VorbisAudio 0 2 90 91 14</span>
<span class="s0">/**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">VorbisAudio::VorbisAudio(Filename const &amp;name);</span>
<span class="s0">inline VorbisAudio::VorbisAudio(VorbisAudio const &amp;) = default;</span>

<span class="s0">187 4 make 0 4 219 17 VorbisAudio::make 0 1 92 55</span>
<span class="s0">/**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static PointerTo&lt; MovieAudio &gt; VorbisAudio::make(Filename const &amp;name);</span>

<span class="s0">188 14 get_class_type 0 4 219 27 VorbisAudio::get_class_type 0 1 93 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle VorbisAudio::get_class_type(void);</span>

<span class="s0">189 17 VorbisAudioCursor 0 260 220 36 VorbisAudioCursor::VorbisAudioCursor 0 2 94 95 129</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the .wav header from the indicated stream.  This leaves the read</span>
 <span class="s0">* pointer positioned at the start of the data.</span>
 <span class="s0">*/</span>
<span class="s0">168</span>
<span class="s0">explicit VorbisAudioCursor::VorbisAudioCursor(VorbisAudio *src, std::istream *stream);</span>
<span class="s0">inline VorbisAudioCursor::VorbisAudioCursor(VorbisAudioCursor const &amp;) = default;</span>

<span class="s0">190 14 get_class_type 0 4 220 33 VorbisAudioCursor::get_class_type 0 1 96 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle VorbisAudioCursor::get_class_type(void);</span>

<span class="s0">191 8 WavAudio 0 260 221 18 WavAudio::WavAudio 0 2 97 98 14</span>
<span class="s0">/**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">WavAudio::WavAudio(Filename const &amp;name);</span>
<span class="s0">inline WavAudio::WavAudio(WavAudio const &amp;) = default;</span>

<span class="s0">192 4 make 0 4 221 14 WavAudio::make 0 1 99 55</span>
<span class="s0">/**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static PointerTo&lt; MovieAudio &gt; WavAudio::make(Filename const &amp;name);</span>

<span class="s0">193 14 get_class_type 0 4 221 24 WavAudio::get_class_type 0 1 100 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle WavAudio::get_class_type(void);</span>

<span class="s0">194 14 WavAudioCursor 0 260 222 30 WavAudioCursor::WavAudioCursor 0 2 101 102 129</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the .wav header from the indicated stream.  This leaves the read</span>
 <span class="s0">* pointer positioned at the start of the data.</span>
 <span class="s0">*/</span>
<span class="s0">150</span>
<span class="s0">explicit WavAudioCursor::WavAudioCursor(WavAudio *src, std::istream *stream);</span>
<span class="s0">inline WavAudioCursor::WavAudioCursor(WavAudioCursor const &amp;) = default;</span>

<span class="s0">195 14 get_class_type 0 4 222 30 WavAudioCursor::get_class_type 0 1 103 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle WavAudioCursor::get_class_type(void);</span>

<span class="s0">103</span>
<span class="s0">1 0 0 15 8 225 109 0 0 1 6 param0 0 223  </span>
<span class="s0">2 0 0 7 8 225 109 0 200 /**</span>
 <span class="s0">* This constructor returns a null audio stream --- a stream of total silence,</span>
 <span class="s0">* at 8000 samples per second.  To get more interesting audio, you need to</span>
 <span class="s0">* construct a subclass of this class.</span>
 <span class="s0">*/ 1 4 name 5 226  </span>
<span class="s0">3 0 0 7 10 227 0 0 56 /**</span>
 <span class="s0">* Open this audio, returning a MovieAudioCursor</span>
 <span class="s0">*/ 1 4 this 3 225  </span>
<span class="s0">4 0 0 7 11 225 109 0 103 /**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.  Just calls</span>
 <span class="s0">* MovieTypeRegistry::make_audio().</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">5 0 0 6 12 228 0 0 142 /**</span>
 <span class="s0">* Returns the movie's filename.  A movie is not guaranteed to have a</span>
 <span class="s0">* filename, if not, then this function returns a null filename.</span>
 <span class="s0">*/ 1 4 this 3 223  </span>
<span class="s0">6 0 0 7 16 230 0 0 0 0 </span>
<span class="s0">7 0 0 7 3 231 0 0 0 1 4 this 3 225  </span>
<span class="s0">8 0 0 6 6 232 0 0 0 1 4 this 3 225  </span>
<span class="s0">9 0 0 23 18 233 109 0 14 /**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">10 0 0 15 18 233 109 0 0 1 6 param0 0 234  </span>
<span class="s0">11 0 0 23 19 225 109 0 55 /**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">12 0 0 7 20 230 0 0 0 0 </span>
<span class="s0">13 0 0 23 22 227 0 0 200 /**</span>
 <span class="s0">* This constructor returns a null audio stream --- a stream of total silence,</span>
 <span class="s0">* at 8000 samples per second.  To get more interesting audio, you need to</span>
 <span class="s0">* construct a subclass of this class.</span>
 <span class="s0">*/ 1 3 src 1 225  </span>
<span class="s0">14 0 0 15 22 227 0 0 0 1 6 param0 0 236  </span>
<span class="s0">15 0 0 7 23 225 109 0 63 /**</span>
 <span class="s0">* Returns the MovieAudio which this cursor references.</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">16 0 0 6 24 214 0 0 41 /**</span>
 <span class="s0">* Returns the audio sample rate.</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">17 0 0 6 25 214 0 0 83 /**</span>
 <span class="s0">* Returns the number of audio channels (ie, two for stereo, one for mono).</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">18 0 0 6 26 238 0 0 742 /**</span>
 <span class="s0">* Returns the length of the movie.  Attempting to read audio samples beyond</span>
 <span class="s0">* the specified length will produce silent samples.</span>
 <span class="s0">*</span>
 <span class="s0">* Some kinds of Movie, such as internet TV station, might not have a</span>
 <span class="s0">* predictable length.  In that case, the length will be set to a very large</span>
 <span class="s0">* number: 1.0E10.</span>
 <span class="s0">*</span>
 <span class="s0">* Some AVI files have incorrect length values encoded into them - they may be</span>
 <span class="s0">* a second or two long or short.  When playing such an AVI using the Movie</span>
 <span class="s0">* class, you may see a slightly truncated video, or a slightly elongated</span>
 <span class="s0">* video (padded with black frames).  There are utilities out there to fix the</span>
 <span class="s0">* length values in AVI files.</span>
 <span class="s0">*</span>
 <span class="s0">* An audio consumer needs to check the length, the ready status, and the</span>
 <span class="s0">* aborted flag.</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">19 0 0 6 27 239 0 0 429 /**</span>
 <span class="s0">* Returns true if the movie can seek.  If this is true, seeking is still not</span>
 <span class="s0">* guaranteed to be fast: for some movies, seeking is implemented by rewinding</span>
 <span class="s0">* to the beginning and then fast-forwarding to the desired location.  Even if</span>
 <span class="s0">* the movie cannot seek, the seek method can still advance to an arbitrary</span>
 <span class="s0">* location by reading samples and discarding them.  However, to move</span>
 <span class="s0">* backward, can_seek must return true.</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">20 0 0 6 28 239 0 0 61 /**</span>
 <span class="s0">* Returns true if seek operations are constant time.</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">21 0 0 6 29 238 0 0 54 /**</span>
 <span class="s0">* Returns the current offset within the file.</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">22 0 0 4 30 240 0 0 86 /**</span>
 <span class="s0">* Skip audio samples from the stream.  This is mostly for debugging purposes.</span>
 <span class="s0">*/ 2 4 this 3 227  1 n 1 214  </span>
<span class="s0">23 0 0 6 31 239 0 0 138 /**</span>
 <span class="s0">* If aborted is true, it means that the &quot;ready&quot; samples are not being</span>
 <span class="s0">* replenished.  See the method &quot;ready&quot; for an explanation.</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">24 0 0 6 32 214 0 0 1120 /**</span>
 <span class="s0">* Returns the number of audio samples that are ready to read.  This is</span>
 <span class="s0">* primarily relevant for sources like microphones which produce samples at a</span>
 <span class="s0">* fixed rate.  If you try to read more samples than are ready, the result</span>
 <span class="s0">* will be silent samples.</span>
 <span class="s0">*</span>
 <span class="s0">* Some audio streams do not have a limit on how fast they can produce</span>
 <span class="s0">* samples.  Such streams will always return 0x40000000 as the ready-count.</span>
 <span class="s0">* This may well exceed the length of the audio stream.  You therefore need to</span>
 <span class="s0">* check length separately.</span>
 <span class="s0">*</span>
 <span class="s0">* If the aborted flag is set, that means the ready count is no longer being</span>
 <span class="s0">* replenished.  For example, a MovieAudioCursor might be reading from an</span>
 <span class="s0">* internet radio station, and it might buffer data to avoid underruns.  If it</span>
 <span class="s0">* loses connection to the radio station, it will set the aborted flag to</span>
 <span class="s0">* indicate that the buffer is no longer being replenished.  But it is still</span>
 <span class="s0">* ok to read the samples that are in the buffer, at least until they run out.</span>
 <span class="s0">* Once those are gone, there will be no more.</span>
 <span class="s0">*</span>
 <span class="s0">* An audio consumer needs to check the length, the ready status, and the</span>
 <span class="s0">* aborted flag.</span>
 <span class="s0">*/ 1 4 this 3 236  </span>
<span class="s0">25 0 0 4 33 240 0 0 746 /**</span>
 <span class="s0">* Skips to the specified offset within the file.</span>
 <span class="s0">*</span>
 <span class="s0">* If the movie reports that it cannot seek, then this method can still</span>
 <span class="s0">* advance by reading samples and discarding them.  However, to move backward,</span>
 <span class="s0">* can_seek must be true.</span>
 <span class="s0">*</span>
 <span class="s0">* If the movie reports that it can_seek, it doesn't mean that it can do so</span>
 <span class="s0">* quickly.  It may have to rewind the movie and then fast forward to the</span>
 <span class="s0">* desired location.  Only if can_seek_fast returns true can seek operations</span>
 <span class="s0">* be done in constant time.</span>
 <span class="s0">*</span>
 <span class="s0">* Seeking may not be precise, because AVI files often have inaccurate</span>
 <span class="s0">* indices.  After seeking, tell will indicate that the cursor is at the</span>
 <span class="s0">* target location.  However, in truth, the data you read may come from a</span>
 <span class="s0">* slightly offset location.</span>
 <span class="s0">*/ 2 4 this 3 227  6 offset 1 238  </span>
<span class="s0">26 0 0 6 34 226 0 0 334 /**</span>
 <span class="s0">* Read audio samples from the stream and returns them as a string.  The</span>
 <span class="s0">* samples are stored little-endian in the string.  N is the number of samples</span>
 <span class="s0">* you wish to read.  Multiple-channel audio will be interleaved.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not particularly efficient, but it may be a convenient way to</span>
 <span class="s0">* manipulate samples in python.</span>
 <span class="s0">*/ 2 4 this 3 227  1 n 1 214  </span>
<span class="s0">27 0 0 4 34 240 0 0 265 /**</span>
 <span class="s0">* Read audio samples from the stream into a Datagram.  N is the number of</span>
 <span class="s0">* samples you wish to read.  Multiple-channel audio will be interleaved.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not particularly efficient, but it may be a convenient way to</span>
 <span class="s0">* manipulate samples in python.</span>
 <span class="s0">*/ 3 4 this 3 227  1 n 1 214  2 dg 1 241  </span>
<span class="s0">28 0 0 7 35 230 0 0 0 0 </span>
<span class="s0">29 0 0 7 37 245 0 0 129 /**</span>
 <span class="s0">* Reads the .wav header from the indicated stream.  This leaves the read</span>
 <span class="s0">* pointer positioned at the start of the data.</span>
 <span class="s0">*/ 2 3 src 1 233  6 stream 1 243  </span>
<span class="s0">30 0 0 15 37 245 0 0 0 1 6 param0 0 246  </span>
<span class="s0">31 0 0 7 38 230 0 0 0 0 </span>
<span class="s0">32 0 0 15 44 250 138 0 0 1 6 param0 0 248  </span>
<span class="s0">33 0 0 23 44 250 138 0 212 /**</span>
 <span class="s0">* This constructor returns a null video stream --- a stream of plain blue and</span>
 <span class="s0">* white frames that last one second each.  To get more interesting video, you</span>
 <span class="s0">* need to construct a subclass of this class.</span>
 <span class="s0">*/ 1 4 name 5 226  </span>
<span class="s0">34 0 0 7 46 251 0 0 107 /**</span>
 <span class="s0">* Open this video, returning a MovieVideoCursor of the appropriate type.</span>
 <span class="s0">* Returns NULL on error.</span>
 <span class="s0">*/ 1 4 this 3 250  </span>
<span class="s0">35 0 0 7 47 250 138 0 103 /**</span>
 <span class="s0">* Obtains a MovieVideo that references a file.  Just calls</span>
 <span class="s0">* MovieTypeRegistry::make_video().</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">36 0 0 6 48 228 0 0 144 /**</span>
 <span class="s0">* Returns the movie's filename.  A movie is not guaranteed to have a</span>
 <span class="s0">* filename, if not, then this function returns an empty filename.</span>
 <span class="s0">*/ 1 4 this 3 248  </span>
<span class="s0">37 0 0 6 49 252 0 0 150 /**</span>
 <span class="s0">* If the movie is to be loaded from a subfile on disk, this returns the</span>
 <span class="s0">* subfile info.  Check info.is_empty() to see if this is valid data.</span>
 <span class="s0">*/ 1 4 this 3 248  </span>
<span class="s0">38 0 0 7 54 230 0 0 0 0 </span>
<span class="s0">39 0 0 7 40 231 0 0 0 1 4 this 3 250  </span>
<span class="s0">40 0 0 6 42 232 0 0 0 1 4 this 3 250  </span>
<span class="s0">41 0 0 15 56 255 138 0 0 1 6 param0 0 253  </span>
<span class="s0">42 0 0 7 56 255 138 0 14 /**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/ 3 1 x 1 214  1 y 1 214  3 fps 1 214  </span>
<span class="s0">43 0 0 7 57 230 0 0 0 0 </span>
<span class="s0">44 0 0 15 82 251 0 0 0 1 6 param0 0 256  </span>
<span class="s0">45 0 0 7 59 250 138 0 59 /**</span>
 <span class="s0">* Get the MovieVideo which this cursor references.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">46 0 0 6 60 214 0 0 48 /**</span>
 <span class="s0">* Get the horizontal size of the movie.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">47 0 0 6 61 214 0 0 46 /**</span>
 <span class="s0">* Get the vertical size of the movie.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">48 0 0 6 62 214 0 0 68 /**</span>
 <span class="s0">* Returns 4 if the movie has an alpha channel, 3 otherwise.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">49 0 0 6 63 238 0 0 1170 /**</span>
 <span class="s0">* Returns the length of the movie.</span>
 <span class="s0">*</span>
 <span class="s0">* Some kinds of Movie, such as internet TV station, might not have a</span>
 <span class="s0">* predictable length.  In that case, the length will be set to a very large</span>
 <span class="s0">* number: 1.0E10. If the internet TV station goes offline, the video or audio</span>
 <span class="s0">* stream will set its abort flag.  Reaching the end of the movie (ie, the</span>
 <span class="s0">* specified length) normally does not cause the abort flag to be set.</span>
 <span class="s0">*</span>
 <span class="s0">* The video and audio streams produced by get_video and get_audio are always</span>
 <span class="s0">* of unlimited duration - you can always read another video frame or another</span>
 <span class="s0">* audio sample.  This is true even if the specified length is reached, or an</span>
 <span class="s0">* abort is flagged.  If either stream runs out of data, it will synthesize</span>
 <span class="s0">* blank video frames and silent audio samples as necessary to satisfy read</span>
 <span class="s0">* requests.</span>
 <span class="s0">*</span>
 <span class="s0">* Some AVI files have incorrect length values encoded into them - usually,</span>
 <span class="s0">* they're a second or two long or short.  When playing such an AVI using the</span>
 <span class="s0">* Movie class, you may see a slightly truncated video, or a slightly</span>
 <span class="s0">* elongated video (padded with black frames).  There are utilities out there</span>
 <span class="s0">* to fix the length values in AVI files.</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">50 0 0 6 64 239 0 0 430 /**</span>
 <span class="s0">* Returns true if the movie can seek.  If this is true, seeking is still not</span>
 <span class="s0">* guaranteed to be fast: for some movies, seeking is implemented by rewinding</span>
 <span class="s0">* to the beginning and then fast-forwarding to the desired location.  Even if</span>
 <span class="s0">* the movie cannot seek, the fetch methods can still advance to an arbitrary</span>
 <span class="s0">* location by reading frames and discarding them.  However, to move backward,</span>
 <span class="s0">* can_seek must return true.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">51 0 0 6 65 239 0 0 61 /**</span>
 <span class="s0">* Returns true if seek operations are constant time.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">52 0 0 6 66 239 0 0 260 /**</span>
 <span class="s0">* Returns true if the video has aborted prematurely.  For example, this could</span>
 <span class="s0">* occur if the Movie was actually an internet TV station, and the connection</span>
 <span class="s0">* was lost.  Reaching the normal end of the video does not constitute an</span>
 <span class="s0">* 'abort' condition.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">53 0 0 6 67 239 0 0 156 /**</span>
 <span class="s0">* Returns true if the cursor is a streaming source, and if a video frame is</span>
 <span class="s0">* ready to be read.  For non- streaming sources, this is always false.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">54 0 0 6 68 239 0 0 528 /**</span>
 <span class="s0">* Returns true if the video frames are being &quot;pushed&quot; at us by something that</span>
 <span class="s0">* operates at its own speed - for example, a webcam.  In this case, the</span>
 <span class="s0">* frames come when they're ready to come.  Attempting to read too soon will</span>
 <span class="s0">* produce nothing, reading too late will cause frames to be dropped.  In this</span>
 <span class="s0">* case, the ready flag can be used to determine whether or not a frame is</span>
 <span class="s0">* ready for reading.</span>
 <span class="s0">*</span>
 <span class="s0">* When streaming, you should still pay attention to last_start, but the value</span>
 <span class="s0">* of next_start is only a guess.</span>
 <span class="s0">*/ 1 4 this 3 256  </span>
<span class="s0">55 0 0 4 69 240 0 0 130 /**</span>
 <span class="s0">* Set up the specified Texture object to contain content from this movie.</span>
 <span class="s0">* This should be called once, not every frame.</span>
 <span class="s0">*/ 2 4 this 3 256  3 tex 1 258  </span>
<span class="s0">56 0 0 6 70 239 0 0 850 /**</span>
 <span class="s0">* Updates the cursor to the indicated time.  If loop_count &gt;= 1, the time is</span>
 <span class="s0">* clamped to the movie's length * loop_count.  If loop_count &lt;= 0, the time</span>
 <span class="s0">* is understood to be modulo the movie's length.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if a new frame is now available, false otherwise.  If this</span>
 <span class="s0">* returns true, you should immediately follow this with exactly *one* call to</span>
 <span class="s0">* fetch_buffer().</span>
 <span class="s0">*</span>
 <span class="s0">* If the movie reports that it can_seek, you may also specify a time value</span>
 <span class="s0">* less than the previous value you passed to set_time().  Otherwise, you may</span>
 <span class="s0">* only specify a time value greater than or equal to the previous value.</span>
 <span class="s0">*</span>
 <span class="s0">* If the movie reports that it can_seek, it doesn't mean that it can do so</span>
 <span class="s0">* quickly.  It may have to rewind the movie and then fast forward to the</span>
 <span class="s0">* desired location.  Only if can_seek_fast returns true can it seek rapidly.</span>
 <span class="s0">*/ 3 4 this 3 251  9 timestamp 1 238  10 loop_count 1 214  </span>
<span class="s0">57 0 0 7 77 260 0 0 331 /**</span>
 <span class="s0">* Gets the current video frame (as specified by set_time()) from the movie</span>
 <span class="s0">* and returns it in a pre-allocated buffer.  You may simply let the buffer</span>
 <span class="s0">* dereference and delete itself when you are done with it.</span>
 <span class="s0">*</span>
 <span class="s0">* This may return NULL (even if set_time() returned true) if the frame is not</span>
 <span class="s0">* available for some reason.</span>
 <span class="s0">*/ 1 4 this 3 251  </span>
<span class="s0">58 0 0 4 78 240 0 0 66 /**</span>
 <span class="s0">* Stores this buffer's contents in the indicated texture.</span>
 <span class="s0">*/ 4 4 this 3 251  6 buffer 1 261  1 t 1 258  4 page 1 214  </span>
<span class="s0">59 0 0 4 79 240 0 0 140 /**</span>
 <span class="s0">* Copies this buffer's contents into the RGB channels of the supplied</span>
 <span class="s0">* texture.  The alpha channel of the texture is not touched.</span>
 <span class="s0">*/ 4 4 this 3 251  6 buffer 1 261  1 t 1 258  4 page 1 214  </span>
<span class="s0">60 0 0 4 80 240 0 0 141 /**</span>
 <span class="s0">* Copies this buffer's contents into the alpha channel of the supplied</span>
 <span class="s0">* texture.  The RGB channels of the texture are not touched.</span>
 <span class="s0">*/ 5 4 this 3 251  6 buffer 1 261  1 t 1 258  4 page 1 214  9 alpha_src 1 214  </span>
<span class="s0">61 0 0 7 81 230 0 0 0 0 </span>
<span class="s0">62 0 0 15 76 260 0 0 0 1 6 param0 0 261  </span>
<span class="s0">63 0 0 6 73 214 0 0 335 /**</span>
 <span class="s0">* Used to sort different buffers to ensure they correspond to the same source</span>
 <span class="s0">* frame, particularly important when synchronizing the different pages of a</span>
 <span class="s0">* multi-page texture.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns 0 if the two buffers are of the same frame, &lt;0 if this one comes</span>
 <span class="s0">* earlier than the other one, and &gt;0 if the other one comes earlier.</span>
 <span class="s0">*/ 2 4 this 3 261  5 other 1 261  </span>
<span class="s0">64 0 0 6 74 238 0 0 236 /**</span>
 <span class="s0">* Returns the nearest timestamp value of this particular buffer.  Ideally,</span>
 <span class="s0">* MovieVideoCursor::set_time() for this timestamp would return this buffer</span>
 <span class="s0">* again.  This need be defined only if compare_timestamp() is also defined.</span>
 <span class="s0">*/ 1 4 this 3 261  </span>
<span class="s0">65 0 0 7 75 230 0 0 0 0 </span>
<span class="s0">66 0 0 23 84 263 0 0 14 /**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/ 1 3 src 1 255  </span>
<span class="s0">67 0 0 15 84 263 0 0 0 1 6 param0 0 264  </span>
<span class="s0">68 0 0 7 85 230 0 0 0 0 </span>
<span class="s0">69 0 0 6 87 214 0 0 218 /**</span>
 <span class="s0">* Returns the number of microphone options.  An &quot;option&quot; consists of a device</span>
 <span class="s0">* plus a set of configuration parameters.  For example, &quot;Soundblaster Audigy</span>
 <span class="s0">* Line in at 44,100 samples/sec&quot; would be an option.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">70 0 0 7 88 266 109 0 45 /**</span>
 <span class="s0">* Returns the nth microphone option.</span>
 <span class="s0">*/ 1 1 n 1 214  </span>
<span class="s0">71 0 0 6 90 214 0 0 42 /**</span>
 <span class="s0">* Returns the number of channels.</span>
 <span class="s0">*/ 1 4 this 3 267  </span>
<span class="s0">72 0 0 6 91 214 0 0 35 /**</span>
 <span class="s0">* Returns the sample rate.</span>
 <span class="s0">*/ 1 4 this 3 267  </span>
<span class="s0">73 0 0 7 97 230 0 0 0 0 </span>
<span class="s0">74 0 0 23 99 269 109 0 14 /**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">75 0 0 15 99 269 109 0 0 1 6 param0 0 270  </span>
<span class="s0">76 0 0 23 100 225 109 0 55 /**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">77 0 0 7 101 230 0 0 0 0 </span>
<span class="s0">78 0 0 7 103 272 0 0 129 /**</span>
 <span class="s0">* Reads the .wav header from the indicated stream.  This leaves the read</span>
 <span class="s0">* pointer positioned at the start of the data.</span>
 <span class="s0">*/ 2 3 src 1 269  6 stream 1 243  </span>
<span class="s0">79 0 0 15 103 272 0 0 0 1 6 param0 0 273  </span>
<span class="s0">80 0 0 7 104 230 0 0 0 0 </span>
<span class="s0">81 0 0 15 106 277 109 0 0 1 6 param0 0 275  </span>
<span class="s0">82 0 0 23 106 277 109 0 104 /**</span>
 <span class="s0">* This constructor returns a UserDataAudio --- a means to supply raw audio</span>
 <span class="s0">* samples manually.</span>
 <span class="s0">*/ 3 4 rate 1 214  8 channels 1 214  17 remove_after_read 5 239  </span>
<span class="s0">83 0 0 4 107 240 0 0 144 /**</span>
 <span class="s0">* Appends audio samples to the buffer from a datagram.  This is intended to</span>
 <span class="s0">* make it easy to send streaming raw audio over a network.</span>
 <span class="s0">*/ 3 4 this 3 277  3 src 1 278  3 len 5 214  </span>
<span class="s0">84 0 0 4 107 240 0 0 218 /**</span>
 <span class="s0">* Appends audio samples to the buffer from a string.  The samples must be</span>
 <span class="s0">* stored little-endian in the string.  This is not particularly efficient,</span>
 <span class="s0">* but it may be convenient to deal with samples in python.</span>
 <span class="s0">*/ 2 4 this 3 277  3 str 1 226  </span>
<span class="s0">85 0 0 4 108 240 0 0 98 /**</span>
 <span class="s0">* Promises not to append any more samples, ie, this marks the end of the</span>
 <span class="s0">* audio stream.</span>
 <span class="s0">*/ 1 4 this 3 277  </span>
<span class="s0">86 0 0 7 109 230 0 0 0 0 </span>
<span class="s0">87 0 0 23 111 280 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 3 src 1 277  </span>
<span class="s0">88 0 0 15 111 280 0 0 0 1 6 param0 0 281  </span>
<span class="s0">89 0 0 7 112 230 0 0 0 0 </span>
<span class="s0">90 0 0 23 114 283 109 0 14 /**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">91 0 0 15 114 283 109 0 0 1 6 param0 0 284  </span>
<span class="s0">92 0 0 23 115 225 109 0 55 /**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">93 0 0 7 116 230 0 0 0 0 </span>
<span class="s0">94 0 0 7 118 286 0 0 129 /**</span>
 <span class="s0">* Reads the .wav header from the indicated stream.  This leaves the read</span>
 <span class="s0">* pointer positioned at the start of the data.</span>
 <span class="s0">*/ 2 3 src 1 283  6 stream 1 243  </span>
<span class="s0">95 0 0 15 118 286 0 0 0 1 6 param0 0 287  </span>
<span class="s0">96 0 0 7 119 230 0 0 0 0 </span>
<span class="s0">97 0 0 23 121 289 109 0 14 /**</span>
 <span class="s0">* xxx</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">98 0 0 15 121 289 109 0 0 1 6 param0 0 290  </span>
<span class="s0">99 0 0 23 122 225 109 0 55 /**</span>
 <span class="s0">* Obtains a MovieAudio that references a file.</span>
 <span class="s0">*/ 1 4 name 1 228  </span>
<span class="s0">100 0 0 7 123 230 0 0 0 0 </span>
<span class="s0">101 0 0 7 125 292 0 0 129 /**</span>
 <span class="s0">* Reads the .wav header from the indicated stream.  This leaves the read</span>
 <span class="s0">* pointer positioned at the start of the data.</span>
 <span class="s0">*/ 2 3 src 1 289  6 stream 1 243  </span>
<span class="s0">102 0 0 15 125 292 0 0 0 1 6 param0 0 293  </span>
<span class="s0">103 0 0 7 126 230 0 0 0 0 </span>
<span class="s0">99</span>
<span class="s0">196 10 MovieAudio 0 26625 10 MovieAudio 10 MovieAudio 0 0 0 1 108 109 1 295 4 110 111 112 113 0 0 2 3 197 104 105 3 198 106 107 0 0 397</span>
<span class="s0">/**</span>
 <span class="s0">* A MovieAudio is actually any source that provides a sequence of audio</span>
 <span class="s0">* samples.  That could include an AVI file, a microphone, or an internet TV</span>
 <span class="s0">* station.</span>
 <span class="s0">*</span>
 <span class="s0">* The difference between a MovieAudio and a MovieAudioCursor is like the</span>
 <span class="s0">* difference between a filename and a file handle.  The MovieAudio just</span>
 <span class="s0">* indicates a particular movie.  The MovieAudioCursor is what allows access.</span>
 <span class="s0">*/</span>

<span class="s0">197 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedWritable and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedWritables and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">198 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">199 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 200 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">200 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">201 9 FlacAudio 0 75777 9 FlacAudio 9 FlacAudio 0 0 0 1 114 109 0 2 115 116 0 0 1 0 196 0 0 0 0 102</span>
<span class="s0">/**</span>
 <span class="s0">* Reads FLAC audio files.  Ogg-encapsulated FLAC files are not supported.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">202 16 MovieAudioCursor 0 75777 16 MovieAudioCursor 16 MovieAudioCursor 0 0 0 1 117 0 0 13 118 119 120 121 122 123 124 125 126 127 128 129 130 0 0 1 0 197 0 0 0 0 501</span>
<span class="s0">/**</span>
 <span class="s0">* A MovieAudio is actually any source that provides a sequence of audio</span>
 <span class="s0">* samples.  That could include an AVI file, a microphone, or an internet TV</span>
 <span class="s0">* station.  A MovieAudioCursor is a handle that lets you read data</span>
 <span class="s0">* sequentially from a MovieAudio.</span>
 <span class="s0">*</span>
 <span class="s0">* Thread safety: each individual MovieAudioCursor must be owned and accessed</span>
 <span class="s0">* by a single thread.  It is OK for two different threads to open the same</span>
 <span class="s0">* file at the same time, as long as they use separate MovieAudioCursor</span>
 <span class="s0">* objects.</span>
 <span class="s0">*/</span>

<span class="s0">203 15 FlacAudioCursor 0 75777 15 FlacAudioCursor 15 FlacAudioCursor 0 0 0 1 131 0 0 1 132 0 0 1 0 202 0 0 0 0 89</span>
<span class="s0">/**</span>
 <span class="s0">* Implements decoding of FLAC audio files.</span>
 <span class="s0">*</span>
 <span class="s0">* @see FlacAudio</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">204 10 MovieVideo 0 26625 10 MovieVideo 10 MovieVideo 0 0 0 1 137 138 2 296 297 5 139 140 141 142 143 0 0 2 3 197 133 134 3 198 135 136 0 0 400</span>
<span class="s0">/**</span>
 <span class="s0">* A MovieVideo is actually any source that provides a sequence of video</span>
 <span class="s0">* frames.  That could include an AVI file, a digital camera, or an internet</span>
 <span class="s0">* TV station.</span>
 <span class="s0">*</span>
 <span class="s0">* The difference between a MovieVideo and a MovieVideoCursor is like the</span>
 <span class="s0">* difference between a filename and a file handle.  The MovieVideo just</span>
 <span class="s0">* indicates a particular movie.  The MovieVideoCursor is what allows access.</span>
 <span class="s0">*/</span>

<span class="s0">205 17 SubfileInfo const 0 8832 17 SubfileInfo const 17 SubfileInfo const 0 0 206 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">206 11 SubfileInfo 0 2048 11 SubfileInfo 11 SubfileInfo 0 0 0 0 0 0 0 0 0 0 0 0 200</span>
<span class="s0">/**</span>
 <span class="s0">* This class records a particular byte sub-range within an existing file on</span>
 <span class="s0">* disk.  Generally, the filename is understood as a physical file on disk,</span>
 <span class="s0">* and not to be looked up via the vfs.</span>
 <span class="s0">*/</span>

<span class="s0">207 12 InkblotVideo 0 75777 12 InkblotVideo 12 InkblotVideo 0 0 0 1 144 138 0 1 145 0 0 1 0 204 0 0 0 0 85</span>
<span class="s0">/**</span>
 <span class="s0">* A cellular automaton that generates an amusing pattern of swirling colors.</span>
 <span class="s0">*/</span>

<span class="s0">208 16 MovieVideoCursor 0 75777 16 MovieVideoCursor 16 MovieVideoCursor 0 0 0 1 167 0 0 17 146 147 148 149 150 151 152 153 154 155 156 157 162 163 164 165 166 0 0 1 0 197 0 0 0 1 209 504</span>
<span class="s0">/**</span>
 <span class="s0">* A MovieVideo is actually any source that provides a sequence of video</span>
 <span class="s0">* frames.  That could include an AVI file, a digital camera, or an internet</span>
 <span class="s0">* TV station.  A MovieVideoCursor is a handle that lets you read data</span>
 <span class="s0">* sequentially from a MovieVideo.</span>
 <span class="s0">*</span>
 <span class="s0">* Thread safety: each individual MovieVideoCursor must be owned and accessed</span>
 <span class="s0">* by a single thread.  It is OK for two different threads to open the same</span>
 <span class="s0">* file at the same time, as long as they use separate MovieVideoCursor</span>
 <span class="s0">* objects.</span>
 <span class="s0">*/</span>

<span class="s0">209 6 Buffer 0 337921 24 MovieVideoCursor::Buffer 24 MovieVideoCursor::Buffer 208 0 0 1 161 0 0 3 158 159 160 0 0 1 0 210 0 0 0 0 0</span>

<span class="s0">210 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">211 18 InkblotVideoCursor 0 75777 18 InkblotVideoCursor 18 InkblotVideoCursor 0 0 0 1 168 0 0 1 169 0 0 1 0 208 0 0 0 0 85</span>
<span class="s0">/**</span>
 <span class="s0">* A cellular automaton that generates an amusing pattern of swirling colors.</span>
 <span class="s0">*/</span>

<span class="s0">212 15 MicrophoneAudio 0 75777 15 MicrophoneAudio 15 MicrophoneAudio 0 0 0 0 109 3 298 299 300 5 170 171 172 173 174 1 301 0 1 0 196 0 0 0 0 99</span>
<span class="s0">/**</span>
 <span class="s0">* Class MicrophoneAudio provides the means to read raw audio samples from a</span>
 <span class="s0">* microphone.</span>
 <span class="s0">*/</span>

<span class="s0">213 28 PointerTo&lt; MicrophoneAudio &gt; 0 2048 28 PointerTo&lt; MicrophoneAudio &gt; 28 PointerTo&lt; MicrophoneAudio &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">214 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">215 9 OpusAudio 0 75777 9 OpusAudio 9 OpusAudio 0 0 0 1 175 109 0 2 176 177 0 0 1 0 196 0 0 0 0 116</span>
<span class="s0">/**</span>
 <span class="s0">* Interfaces with the libopusfile library to implement decoding of Opus</span>
 <span class="s0">* audio files.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">216 15 OpusAudioCursor 0 75777 15 OpusAudioCursor 15 OpusAudioCursor 0 0 0 1 178 0 0 1 179 0 0 1 0 202 0 0 0 0 134</span>
<span class="s0">/**</span>
 <span class="s0">* Interfaces with the libopusfile library to implement decoding of Opus</span>
 <span class="s0">* audio files.</span>
 <span class="s0">*</span>
 <span class="s0">* @see OpusAudio</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">217 13 UserDataAudio 0 75777 13 UserDataAudio 13 UserDataAudio 0 0 0 1 180 109 0 3 181 182 183 0 0 1 0 196 0 0 0 0 358</span>
<span class="s0">/**</span>
 <span class="s0">* A UserDataAudio is a way for the user to manually supply raw audio samples.</span>
 <span class="s0">* remove_after_read means the data will be removed if read once.  Else data</span>
 <span class="s0">* will be stored (enable looping and seeking). Expects data as 16 bit signed</span>
 <span class="s0">* (word); Example for stereo: 1.word = 1.channel,2.word = 2.channel, 3.word =</span>
 <span class="s0">* 1.channel,4.word = 2.channel, etc.</span>
 <span class="s0">*/</span>

<span class="s0">218 19 UserDataAudioCursor 0 75777 19 UserDataAudioCursor 19 UserDataAudioCursor 0 0 0 1 184 0 0 1 185 0 0 1 0 202 0 0 0 0 98</span>
<span class="s0">/**</span>
 <span class="s0">* A UserDataAudioCursor is a means to manually supply a sequence of raw audio</span>
 <span class="s0">* samples.</span>
 <span class="s0">*/</span>

<span class="s0">219 11 VorbisAudio 0 75777 11 VorbisAudio 11 VorbisAudio 0 0 0 1 186 109 0 2 187 188 0 0 1 0 196 0 0 0 0 104</span>
<span class="s0">/**</span>
 <span class="s0">* Interfaces with the libvorbisfile library to implement decoding of Ogg</span>
 <span class="s0">* Vorbis audio files.</span>
 <span class="s0">*/</span>

<span class="s0">220 17 VorbisAudioCursor 0 75777 17 VorbisAudioCursor 17 VorbisAudioCursor 0 0 0 1 189 0 0 1 190 0 0 1 0 202 0 0 0 0 104</span>
<span class="s0">/**</span>
 <span class="s0">* Interfaces with the libvorbisfile library to implement decoding of Ogg</span>
 <span class="s0">* Vorbis audio files.</span>
 <span class="s0">*/</span>

<span class="s0">221 8 WavAudio 0 75777 8 WavAudio 8 WavAudio 0 0 0 1 191 109 0 2 192 193 0 0 1 0 196 0 0 0 0 104</span>
<span class="s0">/**</span>
 <span class="s0">* A native PCM .wav loader.  Supported formats are linear PCM, IEEE float,</span>
 <span class="s0">* A-law and mu-law.</span>
 <span class="s0">*/</span>

<span class="s0">222 14 WavAudioCursor 0 75777 14 WavAudioCursor 14 WavAudioCursor 0 0 0 1 194 0 0 1 195 0 0 1 0 202 0 0 0 0 111</span>
<span class="s0">/**</span>
 <span class="s0">* Used for reading PCM .wav files.  Supported formats are linear PCM, IEEE</span>
 <span class="s0">* float, A-law and mu-law.</span>
 <span class="s0">*/</span>

<span class="s0">223 18 MovieAudio const * 0 8576 18 MovieAudio const * 18 MovieAudio const * 0 0 224 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">224 16 MovieAudio const 0 8832 16 MovieAudio const 16 MovieAudio const 0 0 196 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">225 12 MovieAudio * 0 8576 12 MovieAudio * 12 MovieAudio * 0 0 196 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">226 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">227 18 MovieAudioCursor * 0 8576 18 MovieAudioCursor * 18 MovieAudioCursor * 0 0 202 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">228 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 199 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">229 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">230 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 229 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">231 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 197 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">232 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 198 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">233 11 FlacAudio * 0 8576 11 FlacAudio * 11 FlacAudio * 0 0 201 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">234 17 FlacAudio const * 0 8576 17 FlacAudio const * 17 FlacAudio const * 0 0 235 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">235 15 FlacAudio const 0 8832 15 FlacAudio const 15 FlacAudio const 0 0 201 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">236 24 MovieAudioCursor const * 0 8576 24 MovieAudioCursor const * 24 MovieAudioCursor const * 0 0 237 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">237 22 MovieAudioCursor const 0 8832 22 MovieAudioCursor const 22 MovieAudioCursor const 0 0 202 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">238 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">239 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">240 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">241 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 242 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">242 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">243 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 244 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">244 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">245 17 FlacAudioCursor * 0 8576 17 FlacAudioCursor * 17 FlacAudioCursor * 0 0 203 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">246 23 FlacAudioCursor const * 0 8576 23 FlacAudioCursor const * 23 FlacAudioCursor const * 0 0 247 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">247 21 FlacAudioCursor const 0 8832 21 FlacAudioCursor const 21 FlacAudioCursor const 0 0 203 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">248 18 MovieVideo const * 0 8576 18 MovieVideo const * 18 MovieVideo const * 0 0 249 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">249 16 MovieVideo const 0 8832 16 MovieVideo const 16 MovieVideo const 0 0 204 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">250 12 MovieVideo * 0 8576 12 MovieVideo * 12 MovieVideo * 0 0 204 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">251 18 MovieVideoCursor * 0 8576 18 MovieVideoCursor * 18 MovieVideoCursor * 0 0 208 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">252 19 SubfileInfo const * 0 8576 19 SubfileInfo const * 19 SubfileInfo const * 0 0 205 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">253 20 InkblotVideo const * 0 8576 20 InkblotVideo const * 20 InkblotVideo const * 0 0 254 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">254 18 InkblotVideo const 0 8832 18 InkblotVideo const 18 InkblotVideo const 0 0 207 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">255 14 InkblotVideo * 0 8576 14 InkblotVideo * 14 InkblotVideo * 0 0 207 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">256 24 MovieVideoCursor const * 0 8576 24 MovieVideoCursor const * 24 MovieVideoCursor const * 0 0 257 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">257 22 MovieVideoCursor const 0 8832 22 MovieVideoCursor const 22 MovieVideoCursor const 0 0 208 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">258 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 259 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">259 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a texture object, which is typically a single 2-d image but may</span>
 <span class="s0">* also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube</span>
 <span class="s0">* map texture.</span>
 <span class="s0">*</span>
 <span class="s0">* A texture's image data might be stored in system RAM (see get_ram_image())</span>
 <span class="s0">* or its image may be represented in texture memory on one or more</span>
 <span class="s0">* GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern</span>
 <span class="s0">* is that a texture is loaded from an image file on disk, which copies its</span>
 <span class="s0">* image data into system RAM; then the first time the texture is rendered its</span>
 <span class="s0">* image data is copied to texture memory (actually, to the graphics API), and</span>
 <span class="s0">* the system RAM image is automatically freed.</span>
 <span class="s0">*/</span>

<span class="s0">260 8 Buffer * 0 8576 26 MovieVideoCursor::Buffer * 26 MovieVideoCursor::Buffer * 0 0 209 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">261 14 Buffer const * 0 8576 32 MovieVideoCursor::Buffer const * 32 MovieVideoCursor::Buffer const * 0 0 262 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">262 12 Buffer const 0 8832 30 MovieVideoCursor::Buffer const 30 MovieVideoCursor::Buffer const 0 0 209 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">263 20 InkblotVideoCursor * 0 8576 20 InkblotVideoCursor * 20 InkblotVideoCursor * 0 0 211 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">264 26 InkblotVideoCursor const * 0 8576 26 InkblotVideoCursor const * 26 InkblotVideoCursor const * 0 0 265 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">265 24 InkblotVideoCursor const 0 8832 24 InkblotVideoCursor const 24 InkblotVideoCursor const 0 0 211 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">266 17 MicrophoneAudio * 0 8576 17 MicrophoneAudio * 17 MicrophoneAudio * 0 0 212 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">267 23 MicrophoneAudio const * 0 8576 23 MicrophoneAudio const * 23 MicrophoneAudio const * 0 0 268 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">268 21 MicrophoneAudio const 0 8832 21 MicrophoneAudio const 21 MicrophoneAudio const 0 0 212 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">269 11 OpusAudio * 0 8576 11 OpusAudio * 11 OpusAudio * 0 0 215 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">270 17 OpusAudio const * 0 8576 17 OpusAudio const * 17 OpusAudio const * 0 0 271 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">271 15 OpusAudio const 0 8832 15 OpusAudio const 15 OpusAudio const 0 0 215 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">272 17 OpusAudioCursor * 0 8576 17 OpusAudioCursor * 17 OpusAudioCursor * 0 0 216 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">273 23 OpusAudioCursor const * 0 8576 23 OpusAudioCursor const * 23 OpusAudioCursor const * 0 0 274 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">274 21 OpusAudioCursor const 0 8832 21 OpusAudioCursor const 21 OpusAudioCursor const 0 0 216 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">275 21 UserDataAudio const * 0 8576 21 UserDataAudio const * 21 UserDataAudio const * 0 0 276 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">276 19 UserDataAudio const 0 8832 19 UserDataAudio const 19 UserDataAudio const 0 0 217 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">277 15 UserDataAudio * 0 8576 15 UserDataAudio * 15 UserDataAudio * 0 0 217 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">278 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 279 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">279 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 365</span>
<span class="s0">/**</span>
 <span class="s0">* A class to retrieve the individual data elements previously stored in a</span>
 <span class="s0">* Datagram.  Elements may be retrieved one at a time; it is up to the caller</span>
 <span class="s0">* to know the correct type and order of each element.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that it is the responsibility of the caller to ensure that the datagram</span>
 <span class="s0">* object is not destructed while this DatagramIterator is in use.</span>
 <span class="s0">*/</span>

<span class="s0">280 21 UserDataAudioCursor * 0 8576 21 UserDataAudioCursor * 21 UserDataAudioCursor * 0 0 218 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">281 27 UserDataAudioCursor const * 0 8576 27 UserDataAudioCursor const * 27 UserDataAudioCursor const * 0 0 282 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">282 25 UserDataAudioCursor const 0 8832 25 UserDataAudioCursor const 25 UserDataAudioCursor const 0 0 218 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">283 13 VorbisAudio * 0 8576 13 VorbisAudio * 13 VorbisAudio * 0 0 219 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">284 19 VorbisAudio const * 0 8576 19 VorbisAudio const * 19 VorbisAudio const * 0 0 285 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">285 17 VorbisAudio const 0 8832 17 VorbisAudio const 17 VorbisAudio const 0 0 219 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">286 19 VorbisAudioCursor * 0 8576 19 VorbisAudioCursor * 19 VorbisAudioCursor * 0 0 220 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">287 25 VorbisAudioCursor const * 0 8576 25 VorbisAudioCursor const * 25 VorbisAudioCursor const * 0 0 288 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">288 23 VorbisAudioCursor const 0 8832 23 VorbisAudioCursor const 23 VorbisAudioCursor const 0 0 220 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">289 10 WavAudio * 0 8576 10 WavAudio * 10 WavAudio * 0 0 221 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">290 16 WavAudio const * 0 8576 16 WavAudio const * 16 WavAudio const * 0 0 291 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">291 14 WavAudio const 0 8832 14 WavAudio const 14 WavAudio const 0 0 221 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">292 16 WavAudioCursor * 0 8576 16 WavAudioCursor * 16 WavAudioCursor * 0 0 222 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">293 22 WavAudioCursor const * 0 8576 22 WavAudioCursor const * 22 WavAudioCursor const * 0 0 294 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">294 20 WavAudioCursor const 0 8832 20 WavAudioCursor const 20 WavAudioCursor const 0 0 222 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">6</span>
<span class="s0">295 8 filename 0 2 199 112 0 0 0 0 0 0 0 20 MovieAudio::filename 0</span>

<span class="s0">296 8 filename 0 2 199 141 0 0 0 0 0 0 0 20 MovieVideo::filename 0</span>

<span class="s0">297 12 subfile_info 0 2 205 142 0 0 0 0 0 0 0 24 MovieVideo::subfile_info 0</span>

<span class="s0">298 7 options 0 66 213 171 0 0 0 0 170 0 0 24 MicrophoneAudio::options 0</span>

<span class="s0">299 8 channels 0 2 214 172 0 0 0 0 0 0 0 25 MicrophoneAudio::channels 0</span>

<span class="s0">300 4 rate 0 2 214 173 0 0 0 0 0 0 0 21 MicrophoneAudio::rate 0</span>

<span class="s0">1</span>
<span class="s0">301 11 get_options 0 170 171 28 MicrophoneAudio::get_options 0</span>

</pre>
</body>
</html>