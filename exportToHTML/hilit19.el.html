<html>
<head>
<title>hilit19.el</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hilit19.el</font>
</center></td></tr></table>
<pre><span class="s0">;;; hilit19.el --- customizable highlighting for Emacs 19</span>

<span class="s0">;; Copyright (C) 1993, 1994, 2001, 2002, 2003, 2004,</span>
<span class="s0">;;   2005, 2006, 2007, 2008 Free Software Foundation, Inc.</span>

<span class="s0">;; Author:   Jonathan Stigelman &lt;stig@hackvan.com&gt;</span>
<span class="s0">;; Maintainer: FSF</span>
<span class="s0">;;	(actually no longer maintained)</span>
<span class="s0">;; Keywords: faces</span>

<span class="s0">;; This file is part of GNU Emacs.</span>

<span class="s0">;; GNU Emacs is free software; you can redistribute it and/or modify</span>
<span class="s0">;; it under the terms of the GNU General Public License as published by</span>
<span class="s0">;; the Free Software Foundation; either version 3, or (at your option)</span>
<span class="s0">;; any later version.</span>

<span class="s0">;; GNU Emacs is distributed in the hope that it will be useful,</span>
<span class="s0">;; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s0">;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="s0">;; GNU General Public License for more details.</span>

<span class="s0">;; You should have received a copy of the GNU General Public License</span>
<span class="s0">;; along with GNU Emacs; see the file COPYING.  If not, write to the</span>
<span class="s0">;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,</span>
<span class="s0">;; Boston, MA 02110-1301, USA.</span>

<span class="s0">;;; Commentary:</span>

<span class="s0">;; Hilit19.el is a customizable highlighting package for Emacs 19.  It supports</span>
<span class="s0">;; not only source code highlighting, but also Info, RMAIL, VM, gnus...</span>
<span class="s0">;; Hilit19 knows (or thinks it knows) how to highlight emacs buffers in</span>
<span class="s0">;; about 25 different modes.</span>
<span class="s0">;;</span>
<span class="s0">;; WHERE TO GET THE LATEST VERSIONS OF HILIT19.EL (beta and release):</span>
<span class="s0">;;</span>
<span class="s0">;;      http://hackvan.com/pub/stig/src/elisp/</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; TO SUBMIT BUG REPORTS (or feedback of any sort)...</span>
<span class="s0">;;</span>
<span class="s0">;;    M-x hilit-submit-feedback RET</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; hilit19.el,v 2.19 1993/09/08 18:44:10 stig Release</span>
<span class="s0">;;</span>
<span class="s0">;; LCD Archive Entry:</span>
<span class="s0">;; hilit19|Jonathan Stigelman|stig@hackvan.com|</span>
<span class="s0">;; Comprehensive (and comparatively fast) regex-based highlighting for Emacs 19|</span>
<span class="s0">;; 1993/09/08 18:44:10|Release 2.19|~/packages/hilit19.el.Z|</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; GENERAL OVERVIEW</span>
<span class="s0">;;</span>
<span class="s0">;;      This package installs numerous hooks to colorfully highlight your</span>
<span class="s0">;;      source code buffers as well as mail and news buffers.  Most</span>
<span class="s0">;;      programming languages have predefined highlighting patterns.</span>
<span class="s0">;;	Just load hilit19 and files will be automatically highlighted as</span>
<span class="s0">;;      they're loaded.</span>
<span class="s0">;;</span>
<span class="s0">;;      Rehighlight a buffer by typing C-S-l (control-shift-lowercase-L).</span>
<span class="s0">;;</span>
<span class="s0">;;      If, when you edit the buffer, the coloring gets messed up, just</span>
<span class="s0">;;      redraw and the coloring will be adjusted.  If automatic highlighting</span>
<span class="s0">;;      in the current buffer has been turned off, then typing C-u C-S-l will</span>
<span class="s0">;;	force a rehighlight of the entire buffer.</span>
<span class="s0">;;</span>
<span class="s0">;;      Hilit19 can build faces by examining the names that you give to them</span>
<span class="s0">;;	For example, green/black-bold-italic-underline would be created as</span>
<span class="s0">;;	a face with a green foreground, and a black background, using a</span>
<span class="s0">;;	bold-italic font...with underlining for good measure.</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; SETUP -- In your .emacs:</span>
<span class="s0">;;</span>
<span class="s0">;;</span>
<span class="s0">;; (cond (window-system</span>
<span class="s0">;;        (setq hilit-mode-enable-list  '(not text-mode)</span>
<span class="s0">;;              hilit-background-mode   'light</span>
<span class="s0">;;              hilit-inhibit-hooks     nil</span>
<span class="s0">;;              hilit-inhibit-rebinding nil)</span>
<span class="s0">;;</span>
<span class="s0">;;        (require 'hilit19)</span>
<span class="s0">;;        ))</span>
<span class="s0">;;</span>
<span class="s0">;; If you like font-lock-mode and want to use both packages, then you can</span>
<span class="s0">;; disable hilit for the modes in which you want to use font-lock by listing</span>
<span class="s0">;; said modes in hilit-mode-enable-list.</span>
<span class="s0">;;</span>
<span class="s0">;;      (hilit-translate type     'RoyalBlue   ; enable highlighting in C/C++</span>
<span class="s0">;;			 string	  nil)         ; disable string highlighting</span>
<span class="s0">;;</span>
<span class="s0">;; To get 100% of the utility of hilit19, you may also have to apply the</span>
<span class="s0">;; patches below for info.el and vm5.33L_19/vm-summary.el</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; SETUP -- Are you using the right font for Emacs?</span>
<span class="s0">;;</span>
<span class="s0">;; Emacs cannot properly find bold and italic fonts unless you specify a</span>
<span class="s0">;; verbose X11 font name.  If you specify a font for emacs in your</span>
<span class="s0">;; .Xdefaults, it *MUST* be specified using the long form of the font name.</span>
<span class="s0">;; Here's a good font menu:</span>
<span class="s0">;;</span>
<span class="s0">;; (setq</span>
<span class="s0">;;  x-fixed-font-alist</span>
<span class="s0">;;  '(&quot;Font Menu&quot;</span>
<span class="s0">;;    (&quot;Misc&quot;</span>
<span class="s0">;;     (&quot;6x12&quot; &quot;-misc-fixed-medium-r-semicondensed--12-110-75-75-c-60-*-1&quot;)</span>
<span class="s0">;;     (&quot;6x13&quot; &quot;-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-*-1&quot;)</span>
<span class="s0">;;     (&quot;lucida 13&quot;</span>
<span class="s0">;;      &quot;-b&amp;h-lucidatypewriter-medium-r-normal-sans-0-0-0-0-m-0-*-1&quot;)</span>
<span class="s0">;;     (&quot;7x13&quot; &quot;-misc-fixed-medium-r-normal--13-120-75-75-c-70-*-1&quot;)</span>
<span class="s0">;;     (&quot;7x14&quot; &quot;-misc-fixed-medium-r-normal--14-130-75-75-c-70-*-1&quot;)</span>
<span class="s0">;;     (&quot;9x15&quot; &quot;-misc-fixed-medium-r-normal--15-140-*-*-c-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;&quot;)</span>
<span class="s0">;;     (&quot;clean 8x8&quot; &quot;-schumacher-clean-medium-r-normal--*-80-*-*-c-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;clean 8x14&quot; &quot;-schumacher-clean-medium-r-normal--*-140-*-*-c-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;clean 8x10&quot; &quot;-schumacher-clean-medium-r-normal--*-100-*-*-c-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;clean 8x16&quot; &quot;-schumacher-clean-medium-r-normal--*-160-*-*-c-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;&quot;)</span>
<span class="s0">;;     (&quot;sony 8x16&quot; &quot;-sony-fixed-medium-r-normal--16-120-100-100-c-80-*-1&quot;)</span>
<span class="s0">;;     (&quot;&quot;)</span>
<span class="s0">;;     (&quot;-- Courier --&quot;)</span>
<span class="s0">;;     (&quot;Courier 10&quot; &quot;-adobe-courier-medium-r-normal--*-100-*-*-m-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;Courier 12&quot; &quot;-adobe-courier-medium-r-normal--*-120-*-*-m-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;Courier 14&quot; &quot;-adobe-courier-medium-r-normal--*-140-*-*-m-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;Courier 18&quot; &quot;-adobe-courier-medium-r-normal--*-180-*-*-m-*-*-1&quot;)</span>
<span class="s0">;;     (&quot;Courier 18-b&quot; &quot;-adobe-courier-bold-r-normal--*-180-*-*-m-*-*-1&quot;)</span>
<span class="s0">;;     )))</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; KNOWN BUGS/TO DO LIST/HELP WANTED/APPLY WITHIN</span>
<span class="s0">;;</span>
<span class="s0">;; * unbalanced, unescaped double quote characters can confuse hilit19.</span>
<span class="s0">;;   This will be fixed someday, so don't bug me about it.</span>
<span class="s0">;;</span>
<span class="s0">;; * ALTHOUGH HILIT19 IS FASTER THAN FONT-LOCK-MODE...</span>
<span class="s0">;;   For various reasons, the speed of the package could still stand to be</span>
<span class="s0">;;   improved.  If you care to do a little profiling and make things tighter...</span>
<span class="s0">;;</span>
<span class="s0">;; * hilit-toggle-highlight is flaky when auto-rehighlight is neither t nor nil.</span>
<span class="s0">;;   Does anyone actually USE this?  I think I might just remove it.</span>
<span class="s0">;;</span>
<span class="s0">;; PROJECTS THAT YOU CAN TAKE OVER BECAUSE I DON'T MUCH CARE ABOUT THEM...</span>
<span class="s0">;;</span>
<span class="s0">;; * Moved hilit-wysiwyg-replace here from my version of man.el, this is not</span>
<span class="s0">;;   a bug.  The bug is that I don't have a reverse operation yet...just a</span>
<span class="s0">;;   stub Wysiwyg-anything really belongs in a package of its own.</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; Thanks to the following people for their input:</span>
<span class="s0">;;    ebert@enpc.enpc.fr (Rolf EBERT), ada, LaTeX &amp; bibtex highlights</span>
<span class="s0">;;    Vivek Khera &lt;khera@cs.duke.edu&gt;, gnus hooks + random advice &amp; patches</span>
<span class="s0">;;    brian@athe.WUstl.EDU (Brian Dunford-Shore), prolog highlights</span>
<span class="s0">;;    John Ladwig &lt;jladwig@soils.umn.edu&gt;, 1st pass nroff highlights</span>
<span class="s0">;;    campo@sunthpi3.difi.unipi.it (Massimo Campostrini), fortran highlights</span>
<span class="s0">;;    jayb@laplace.MATH.ColoState.EDU (Jay Bourland), 1st pass dired</span>
<span class="s0">;;    Yoshio Turner &lt;yoshio@CS.UCLA.EDU&gt;, modula 2 highlights</span>
<span class="s0">;;    Fritz Knabe &lt;knabe@ecrc.de&gt;, advice &amp; patches</span>
<span class="s0">;;    Alon Albert &lt;alon@milcse.rtsg.mot.com&gt;, advice &amp; patches</span>
<span class="s0">;;    dana@thumper.bellcore.com (Dana A. Chee), working on the multi-frame bug</span>
<span class="s0">;;    derway@ndc.com (Don Erway), for breaking it...</span>
<span class="s0">;;    moss_r@summer.chem.su.oz.au (Richard Moss), first pass at add-pattern</span>
<span class="s0">;;    Olivier Lecarme &lt;ol@aiguemarine.unice.fr&gt;, Pascal &amp; Icon patterns</span>
<span class="s0">;;</span>
<span class="s0">;; With suggestions and minor regex patches from numerous others...</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; hilit19.el,v</span>
<span class="s0">;; Revision 2.19  1993/09/08  18:44:10  stig</span>
<span class="s0">;; installed patch for elusive bug in hilit-rehighlight-region that caused</span>
<span class="s0">;; hilit-unhighlight-region to hang in an infinite loop.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.18  1993/08/27  03:51:00  stig</span>
<span class="s0">;; minor mods to lisp-mode and c/c++ mode patterns</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.17  1993/08/25  02:19:17  stig</span>
<span class="s0">;; work-around for bug in next-overlay-change that caused dired and jargon-mode</span>
<span class="s0">;; to hang in an endless loop.  Perhaps other modes were doing this too.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.16  1993/08/22  19:46:00  stig</span>
<span class="s0">;; bug fix for next-overlay-change and accompanying change to</span>
<span class="s0">;; hilit-unhighlight-region</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.15  1993/08/20  12:16:22  stig</span>
<span class="s0">;; minor change to fortran patterns</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.14  1993/08/17  14:12:10  stig</span>
<span class="s0">;; added default face mapping for 'formula' which is needed for new latex</span>
<span class="s0">;; patterns.</span>
<span class="s0">;;</span>
<span class="s0">;; twiddled the calendar-mode patterns a bit.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.13  1993/08/16  04:33:54  stig</span>
<span class="s0">;; hilit-set-mode-patterns was screwing up two part patterns.  it doesn't now.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.12  1993/08/16  00:16:41  stig</span>
<span class="s0">;; changed references to default-bold-italic to just bold-italic because the</span>
<span class="s0">;;   font for that face is maintained by emacs.</span>
<span class="s0">;;</span>
<span class="s0">;; the pattern matcher now starts its searches from the end of the most</span>
<span class="s0">;;   recently highlighted region (which is not necessarily the end of the most</span>
<span class="s0">;;   recently matched regex).</span>
<span class="s0">;;</span>
<span class="s0">;; multiple errors in pattern matcher now just give an error instead of lots of</span>
<span class="s0">;;   annoying messages and dings.</span>
<span class="s0">;;</span>
<span class="s0">;; no longer use vm-summary-mode-hooks.</span>
<span class="s0">;;</span>
<span class="s0">;; some code moved from hilit-highlight-region to hilit-set-mode-patterns.</span>
<span class="s0">;;   This will affect you if you pass your patterns directly to</span>
<span class="s0">;;   hilit-highlight-region....use a pseudo-mode instead.</span>
<span class="s0">;;</span>
<span class="s0">;; pattern changes to C/C++, latex, texinfo, fortran, nroff, etc.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.11  1993/08/13  12:12:37  stig</span>
<span class="s0">;; removed some crufty commented-out code</span>
<span class="s0">;;</span>
<span class="s0">;; diverged lisp-mode and emacs-lisp-mode...also added lisp keywords.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.10  1993/08/13  09:47:06  stig</span>
<span class="s0">;; added calendar-mode, icon-mode and pascal-mode patterns</span>
<span class="s0">;;</span>
<span class="s0">;; commented out hilit-toggle-highlight because I want to phase it out entirely</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.9  1993/08/13  08:44:22  stig</span>
<span class="s0">;; added optional case-fold argument to hilit-set-mode-patterns, this case-fold</span>
<span class="s0">;; parameter is now stored in hilit-patterns-alist.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.8  1993/08/12  22:05:03  stig</span>
<span class="s0">;; fixed some typos in documentation</span>
<span class="s0">;;</span>
<span class="s0">;; twiddled some of the color defaults for dark backgrounds</span>
<span class="s0">;;</span>
<span class="s0">;; always get 'mono color defaults if (not (x-display-color-p))</span>
<span class="s0">;;</span>
<span class="s0">;; added hilit-rehighlight-buffer-quietly to dired-after-readin-hook</span>
<span class="s0">;;</span>
<span class="s0">;; fixed bug in hilit-string-find that mishandled strings of the form: &quot;\\&quot;</span>
<span class="s0">;;</span>
<span class="s0">;; NEW FUNCTION: hilit-add-mode-pattern...  kinda like add-hook for patterns</span>
<span class="s0">;;</span>
<span class="s0">;; fixed minor pattern bugs for latex-mode and emacs-lisp-mode</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.7  1993/07/30  02:43:01  stig</span>
<span class="s0">;; added const to the list of modifiers for C/C++ types</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.6  1993/07/30  00:30:54  stig</span>
<span class="s0">;; now permit selection of arbitrary subexpressions for highlighting...</span>
<span class="s0">;; fixed keyword patterns for C/C++ using this technique.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.5  1993/07/28  05:02:56  stig</span>
<span class="s0">;; improvements to makefile regular expressions</span>
<span class="s0">;; removed about 130 lines just by compacting the big defconst for</span>
<span class="s0">;;   hilit-face-translation-table into a mapcar and defining a separate table</span>
<span class="s0">;;   of default faces.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.4  1993/07/27  14:09:05  stig</span>
<span class="s0">;; documented another &quot;known problem&quot; to &quot;head off gripe mail at the pass.&quot;</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.3  1993/07/27  02:15:49  stig</span>
<span class="s0">;; (hilit-lookup-face-create) incorporated patch which improves its behavior</span>
<span class="s0">;; with more than one frame...  Still can't have bold on the same face in two</span>
<span class="s0">;; different fonts sizes at the same time...</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.2  1993/07/27  02:02:59  stig</span>
<span class="s0">;; vastly improved the makefile patterns</span>
<span class="s0">;; added hook for mh-show-mode</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.1  1993/07/24  17:46:21  stig</span>
<span class="s0">;; Phasing out Info-select-hook...  Version 19.18 will use Info-selection-hook.</span>
<span class="s0">;;</span>
<span class="s0">;; Revision 2.0  1993/07/24  13:50:10  stig</span>
<span class="s0">;; better documentation and added the function hilit-submit-feedback.</span>
<span class="s0">;; C-S-l (control shift l) repaints the buffer.  Other bindings are optional.</span>
<span class="s0">;; multi-line highlights no longer cause problems when</span>
<span class="s0">;;   hilit-auto-rehighlight is 'visible</span>
<span class="s0">;; added hilit-predefined-face-list...</span>
<span class="s0">;; changed name of hilit-mode-alist to hilit-patterns-alist</span>
<span class="s0">;; added hilit-message-quietly to mail-setup-hook</span>
<span class="s0">;; added hilit-parser-alist which can be used to apply different patterns to</span>
<span class="s0">;;   different parts of a buffer.  This could be integrated in a far more</span>
<span class="s0">;;   elegant manner, but it presently serves the purpose of not applying</span>
<span class="s0">;;   message header patterns to message bodies in mail-mode and its kin.</span>
<span class="s0">;; hilit-set-mode-patterns now takes a list of modes and an optional parse-fn</span>
<span class="s0">;;</span>

<span class="s0">;;;;;; AND THIS CAN BE APPLIED TO VM 5.33L_19</span>
<span class="s0">;;</span>
<span class="s0">;; *** ../site/vm5.33L_19/vm-summary.el    Fri Jun  4 22:17:11 1993</span>
<span class="s0">;; --- ./vm-summary.el     Tue Jun 22 16:39:30 1993</span>
<span class="s0">;; ***************</span>
<span class="s0">;; *** 152,158 ****</span>
<span class="s0">;;                   (insert &quot;-&gt;&quot;)</span>
<span class="s0">;;                   (delete-char 2)</span>
<span class="s0">;;                   (forward-char -2)</span>
<span class="s0">;; !                 (and w vm-auto-center-summary (vm-auto-center-summary))))</span>
<span class="s0">;;             (and old-window (select-window old-window)))))))</span>
<span class="s0">;;</span>
<span class="s0">;;   (defun vm-mark-for-display-update (message)</span>
<span class="s0">;; --- 152,159 ----</span>
<span class="s0">;;                   (insert &quot;-&gt;&quot;)</span>
<span class="s0">;;                   (delete-char 2)</span>
<span class="s0">;;                   (forward-char -2)</span>
<span class="s0">;; !                 (and w vm-auto-center-summary (vm-auto-center-summary))</span>
<span class="s0">;; !                 (run-hooks 'vm-summary-pointer-hook)))</span>
<span class="s0">;;             (and old-window (select-window old-window)))))))</span>
<span class="s0">;;</span>
<span class="s0">;;   (defun vm-mark-for-display-update (message)</span>
<span class="s0">;;</span>
<span class="s0">;;;;;;</span>

<span class="s0">;;; Code:</span>

<span class="s0">;; User Options:</span>

<span class="s0">(defvar hilit-quietly nil</span>
  <span class="s0">&quot;* If non-nil, this inhibits progress indicators during highlighting&quot;)</span>

<span class="s0">(defvar hilit-auto-highlight t</span>
  <span class="s0">&quot;* t if we should highlight all buffers as we find 'em, nil to disable</span>
  <span class="s0">automatic highlighting by the find-file hook.&quot;)</span>

<span class="s0">(defvar hilit-auto-highlight-maxout 60000 ; hilit19 keeps getting bigger...</span>
  <span class="s0">&quot;* auto-highlight is disabled in buffers larger than this&quot;)</span>

<span class="s0">(defvar hilit-auto-rehighlight t</span>
  <span class="s0">&quot;* If this is non-nil, then hilit-redraw and hilit-recenter will also</span>
  <span class="s0">rehighlight part or all of the current buffer.  t will rehighlight the</span>
  <span class="s0">whole buffer, a NUMBER will rehighlight that many lines before and after</span>
  <span class="s0">the cursor, and the symbol 'visible' will rehighlight only the visible</span>
  <span class="s0">portion of the current buffer.  This variable is buffer-local.&quot;)</span>

<span class="s0">(make-variable-buffer-local 'hilit-auto-rehighlight)</span>

<span class="s0">(defvar hilit-auto-rehighlight-fallback '(20000 . 100)</span>
  <span class="s0">&quot;* Cons of the form (THRESHOLD . FALLBACK), where FALLBACK is assigned to</span>
  <span class="s0">hilit-auto-rehighlight if the size of a newly opened buffer is larger than</span>
  <span class="s0">THRESHOLD.&quot;)</span>

<span class="s0">(defvar hilit-face-check t</span>
  <span class="s0">&quot;* t slows down highlighting but permits the user to change fonts without</span>
  <span class="s0">losing bold and italic faces...  t causes hilit-lookup-face-create to dig</span>
  <span class="s0">through the frame parameters for the current window every time it's called.</span>
  <span class="s0">If you never change fonts in emacs, set this to nil.&quot;)</span>

<span class="s0">;; Variables which must be set before loading hilit19.</span>

<span class="s0">(defvar hilit-inhibit-rebinding nil</span>
  <span class="s0">&quot;If non-nil, this inhibits replacement of recenter, yank, and yank-pop.&quot;)</span>

<span class="s0">(defvar hilit-inhibit-hooks nil</span>
  <span class="s0">&quot;If non-nil, this inhibits installation of hooks for Info, gnus, &amp; vm.&quot;)</span>

<span class="s0">(defvar hilit-background-mode 'light</span>
  <span class="s0">&quot;'mono inhibits color, 'dark or 'light indicate the background brightness.&quot;)</span>

<span class="s0">(defvar hilit-mode-enable-list nil</span>
  <span class="s0">&quot;If a list of modes to exclusively enable or specifically disable.</span>
<span class="s0">The sense of the list is negated if it begins with the symbol 'not'.</span>
<span class="s0">Set this variable before you load hilit19.</span>

<span class="s0">Ex:  (perl-mode jargon-mode c-mode)	; just perl, C, and jargon modes</span>
     <span class="s0">(not text-mode)			; all modes except text mode&quot;)</span>

<span class="s0">;; Variables that are not generally modified directly</span>

<span class="s0">(defvar hilit-parser-alist nil</span>
  <span class="s0">&quot;alist of major-mode values and parsers called by hilit-rehighlight-buffer.</span>

<span class="s0">Parsers for a given mode are IGNORED for partial rehighlights...maybe you'd</span>
<span class="s0">like to make this more universal?&quot;)</span>

<span class="s0">(defvar hilit-patterns-alist nil</span>
  <span class="s0">&quot;alist of major-mode values and default highlighting patterns</span>

<span class="s0">A highlighting pattern is a list of the form (start end face), where</span>
<span class="s0">start is a regex, end is either a regex or a match number for start, and face</span>
<span class="s0">is the name of an entry in hilit-face-translation-table, the name of a face,</span>
<span class="s0">or nil (which disables the pattern).</span>

<span class="s0">Each entry in the alist is of the form:</span>
	<span class="s0">(mode . (case-fold pattern [pattern ...]))</span>

<span class="s0">See the hilit-lookup-face-create documentation for valid face names.&quot;)</span>

<span class="s0">(defvar hilit-predefined-face-list (face-list)</span>
  <span class="s0">&quot;List of faces with which hilit-lookup-face-create will NOT tamper.</span>

<span class="s0">If hilit19 is dumped into emacs at your site, you may have to set this in</span>
<span class="s0">your init file.&quot;)</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; Use this to report bugs:</span>

<span class="s0">(eval-when-compile (require 'reporter))	; no compilation gripes</span>

<span class="s0">(defun hilit-submit-feedback ()</span>
  <span class="s0">&quot;Submit feedback on hilit19 to hilit@hackvan.com&quot;</span>
  <span class="s0">(interactive)</span>
  <span class="s0">(require 'reporter)</span>
  <span class="s0">(and (y-or-n-p &quot;Do you really want to submit a report on hilit19? &quot;)</span>
       <span class="s0">(reporter-submit-bug-report</span>
	<span class="s0">&quot;Jonathan Stigelman &lt;hilit@hackvan.com&gt;&quot;</span>
	<span class="s0">&quot;hilit19.el (Release 2.19)&quot;</span>
	<span class="s0">(and (y-or-n-p &quot;Do you need to include a dump hilit variables? &quot;)</span>
	     <span class="s0">(append</span>
	      <span class="s0">'(</span>
		<span class="s0">hilit-quietly    		hilit-inhibit-hooks</span>
		<span class="s0">hilit-background-mode		hilit-mode-enable-list</span>
		<span class="s0">hilit-auto-highlight		hilit-auto-highlight-maxout</span>
		<span class="s0">hilit-auto-rehighlight		hilit-auto-rehighlight-fallback</span>
		<span class="s0">hilit-face-check</span>
		<span class="s0">)</span>
	      <span class="s0">(and (y-or-n-p &quot;Have you modified the standard patterns? &quot;)</span>
		   <span class="s0">(yes-or-no-p &quot;Are your patterns *REALLY* relevant? &quot;)</span>
		   <span class="s0">'(hilit-parser-alist</span>
		     <span class="s0">hilit-patterns-alist</span>
		     <span class="s0">hilit-predefined-face-list</span>
		     <span class="s0">))))</span>
	 <span class="s0">(function</span>
	  <span class="s0">(lambda ()</span>
	    <span class="s0">(and (y-or-n-p &quot;Is this a problem with font display? &quot;)</span>
		 <span class="s0">(insert &quot;\nFrame Configuration:\n====================\n&quot;</span>
			 <span class="s0">(prin1-to-string (frame-configuration-to-register ?F))</span>
			 <span class="s0">&quot;\n&quot;</span>
			 <span class="s0">))))</span>
	 <span class="s0">nil</span>
	 <span class="s0">(concat</span>
	  <span class="s0">&quot;This is (check all that apply, and delete what's irrelevant):\n&quot;</span>
	  <span class="s0">&quot;  [ ] a _MASSIVE_THANK_YOU_ for writing hilit19.el\n&quot;</span>
	  <span class="s0">&quot;  [ ] An invitation to attend the next Hackers Conference\n&quot;</span>
	  <span class="s0">&quot;  [ ] You're a RIGHTEOUS HACKER, what are your rates?\n&quot;</span>
	  <span class="s0">&quot;  [ ] I've used the force and read the source, but I'M CONFUSED\n&quot;</span>
	  <span class="s0">&quot;  [ ] a PATCH. (output of 'diff -uw old.el new.el' or 'diff -cw')\n&quot;</span>
	  <span class="s0">&quot;  [ ] a SERIOUS AND REPRODUCIBLE BUG that is not an EMACS bug\n&quot;</span>
	  <span class="s0">&quot;     - I *swear* that it's not already mentioned in the KNOWN BUGS\n&quot;</span>
	  <span class="s0">&quot;     - I HAVE CHECKED ftp.hackvan.com:/pub/stig/src/elisp/hilit19.el.gz\n&quot;</span>
	  <span class="s0">&quot;       for a newer release that fixes the problem.\n&quot;</span>
	  <span class="s0">&quot;    &gt;&gt; I HAVE ALSO CHECKED ftp.hackvan.com:/pub/stig/src/elisp/hl319.el.gz\n&quot;</span>
	  <span class="s0">&quot;       This is the alpha version...what will become hilit19 (Beta 3.0).\n&quot;</span>
	  <span class="s0">&quot;\n&quot;</span>
	  <span class="s0">&quot;Hey Stig, I *know* you're busy but...\n&quot;))))</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; These faces are either a valid face name, or nil</span>
<span class="s0">;; if you want to change them, you must do so AFTER hilit19 is loaded</span>

<span class="s0">(defconst hilit-default-face-table</span>
  <span class="s0">'(</span>
    <span class="s0">;; used for C/C++ and Emacs Lisp and perl</span>
    <span class="s0">(comment	firebrick-italic    moccasin           italic)</span>
    <span class="s0">(include	purple		    Plum1	       bold-italic)</span>
    <span class="s0">(define	ForestGreen-bold    green	       bold)</span>
    <span class="s0">(defun	blue-bold	    cyan-bold	       bold-italic)</span>
    <span class="s0">(decl	RoyalBlue	    cyan	       bold)</span>
    <span class="s0">(type	nil		    yellow	       nil)</span>
    <span class="s0">(keyword	RoyalBlue	    cyan	       bold-italic)</span>
    <span class="s0">(label	red-underline	    orange-underlined  underline)</span>
    <span class="s0">(string	grey40		    orange	       underline)</span>

    <span class="s0">;; some further faces for Ada</span>
    <span class="s0">(struct	  black-bold        white-bold	       bold)</span>
    <span class="s0">(glob-struct  magenta	    Plum1	       default-bold-underline)</span>
    <span class="s0">(named-param  DarkGoldenrod	    Goldenrod	       underline)</span>

    <span class="s0">;; and another one for LaTeX</span>
    <span class="s0">(crossref	  DarkGoldenrod	    Goldenrod	       underline)</span>
    <span class="s0">(formula	  Goldenrod	    DarkGoldenrod      underline)</span>

    <span class="s0">;; compilation buffers</span>
    <span class="s0">(active-error default/pink-bold  default/DeepPink-bold  default-underline)</span>
    <span class="s0">(error	  red-bold           yellow	       bold)</span>
    <span class="s0">(warning	  blue-italic	     green	       italic)</span>

    <span class="s0">;; Makefiles (some faces borrowed from C/C++ too)</span>
    <span class="s0">(rule	  blue-bold-underline cyan-underline   default-bold-underline)</span>

    <span class="s0">;; VM, GNUS and Text mode</span>
    <span class="s0">(msg-subject    blue-bold       yellow             bold)</span>
    <span class="s0">(msg-from	    purple-bold	    green	       bold)</span>
    <span class="s0">(msg-header	    firebrick-bold  cyan	       italic)</span>
    <span class="s0">(msg-separator  black/tan-bold  black/lightblue    nil)</span>
    <span class="s0">(msg-quote	    ForestGreen	    pink	       italic)</span>

    <span class="s0">(summary-seen     grey40	    white	       nil)</span>
    <span class="s0">(summary-killed   grey50	    white	       nil)</span>
    <span class="s0">(summary-Xed      OliveDrab2    green	       nil)</span>
    <span class="s0">(summary-deleted  firebrick	    white	       italic)</span>
    <span class="s0">(summary-unread   RoyalBlue	    yellow	       bold)</span>
    <span class="s0">(summary-new      blue-bold	    yellow-bold	       bold-italic)</span>
    <span class="s0">(summary-current  default/skyblue-bold green/dimgrey-bold reverse-default)</span>

    <span class="s0">(gnus-group-unsubscribed grey50		white	    nil)</span>
    <span class="s0">(gnus-group-empty	     nil		nil	    nil)</span>
    <span class="s0">(gnus-group-full	     ForestGreen	green	    italic)</span>
    <span class="s0">(gnus-group-overflowing  firebrick		red	    bold-italic)</span>

    <span class="s0">;; dired mode</span>
    <span class="s0">(dired-directory blue-bold         cyan            bold)</span>
    <span class="s0">(dired-link	     firebrick-italic  green	       italic)</span>
    <span class="s0">(dired-ignored   ForestGreen       moccasin	       nil)</span>
    <span class="s0">(dired-deleted   red-bold-italic   orange	       bold-italic)</span>
    <span class="s0">(dired-marked    purple	       Plum1	       nil)</span>

    <span class="s0">;; Info-mode, and jargon-mode.el and prep.ai.mit.edu:/pub/gnu/jargon*</span>
    <span class="s0">(jargon-entry    blue-bold	       cyan            bold)</span>
    <span class="s0">(jargon-xref     purple-bold       Plum1	       italic)</span>
    <span class="s0">(jargon-keyword  firebrick-underline yellow	       underline)</span>
    <span class="s0">)</span>
  <span class="s0">&quot;alist of default faces (face . (light-default dark-default mono-default))</span>

<span class="s0">There is no way for the user to modify this table such that it will have any</span>
<span class="s0">effect upon the translations used by hilit19.  Instead, use the function</span>
<span class="s0">hilit-translate AFTER hilit19 has been loaded.</span>

<span class="s0">See also the documentation for hilit-lookup-face-create.&quot;)</span>

<span class="s0">(defconst hilit-face-translation-table</span>
  <span class="s0">(let ((index (or (and (x-display-color-p)</span>
			<span class="s0">(cdr (assq hilit-background-mode</span>
				   <span class="s0">'((light . 1) (dark . 2)))))</span>
		   <span class="s0">3)))</span>
    <span class="s0">(mapcar (function (lambda (x) (cons (car x) (nth index x))))</span>
	    <span class="s0">hilit-default-face-table))</span>
  <span class="s0">&quot;alist that maps symbolic face-names to real face names&quot;)</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; To translate one face to another...</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="s0">(defmacro hilit-translate (&amp;rest args)</span>
  <span class="s0">&quot;(hilit-translate FROM TO FROM TO ...): translate each face FROM to the</span>
<span class="s0">value of its TO face.  This is like setq for faces.</span>

<span class="s0">The function hilit-lookup-face-create will repeatedly translate until no more</span>
<span class="s0">translations for the face exist in the translation table.</span>

<span class="s0">See the documentation for hilit-lookup-face-create for names of valid faces.&quot;</span>
  <span class="s0">(or (zerop (% (length args) 2))</span>
      <span class="s0">(error &quot;wrong number of args&quot;))</span>
  <span class="s0">(let (cmdl from to)</span>
    <span class="s0">(while args</span>
      <span class="s0">(setq from (car args) to (nth 1 args) args (nthcdr 2 args)</span>
	    <span class="s0">cmdl (cons (list 'hilit-associate ''hilit-face-translation-table</span>
			     <span class="s0">(list 'quote from) to)</span>
		       <span class="s0">cmdl)))</span>
    <span class="s0">(cons 'progn cmdl)))</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; This function actually translates and then creates the faces...</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="s0">(defun hilit-lookup-face-create (face &amp;optional force)</span>
  <span class="s0">&quot;Get a FACE, or create it if it doesn't exist.  In order for it to</span>
<span class="s0">properly create the face, the following naming convention must be used:</span>
    <span class="s0">[reverse-](fgcolor[/bgcolor])[-bold][-italic][-underline]</span>
<span class="s0">Example: (hilit-lookup-face-create 'comment-face) might create and return 'red</span>

<span class="s0">Each color is either the name of an X color (see .../X11/lib/X11/rgb.txt),</span>
<span class="s0">a hexadecimal specification of the form \&quot;hex-[0-9A-Fa-f]+\&quot;, or \&quot;default\&quot;.</span>

<span class="s0">An optional argument, FORCE, will cause the face to be recopied from the</span>
<span class="s0">default...which is probably of use only if you've changed fonts.</span>

<span class="s0">See the documentation for hilit-translate and hilit-face-translation-table.&quot;</span>

<span class="s0">;; translate the face ...</span>
  <span class="s0">(let ((trec t) visited)</span>
    <span class="s0">(while trec</span>
      <span class="s0">(cond ((memq face visited) (error &quot;face translation loop: %S&quot; visited))</span>
	    <span class="s0">(t (setq visited (cons face visited)</span>
		     <span class="s0">trec (assq face hilit-face-translation-table))</span>
	       <span class="s0">(and trec (setq face (cdr trec)))))))</span>

  <span class="s0">;; make the face if we need to...</span>
  <span class="s0">(let* ((fn (symbol-name face))</span>
	 <span class="s0">(frame (selected-frame))</span>
	 <span class="s0">(basefont (cdr (assq 'font (frame-parameters frame))))</span>
	 <span class="s0">error fgcolor bgcolor)</span>
    <span class="s0">(cond</span>
     <span class="s0">((or (null face)</span>
	  <span class="s0">(memq face hilit-predefined-face-list))</span>
      <span class="s0">;; do nothing if the face is nil or if it's predefined.</span>
      <span class="s0">)</span>
     <span class="s0">((or force</span>
	  <span class="s0">(not (memq face (face-list)))</span>
	  <span class="s0">(and hilit-face-check</span>
	       <span class="s0">(not (string= (get face 'basefont) basefont))))</span>
      <span class="s0">(copy-face 'default 'scratch-face)</span>
      <span class="s0">(if (string-match &quot;^reverse-?&quot; fn)</span>
	  <span class="s0">(progn (invert-face 'scratch-face)</span>
		 <span class="s0">(setq fn (substring fn (match-end 0)))))</span>

      <span class="s0">;; parse foreground color</span>
      <span class="s0">(if (string-match &quot;^\\(hex-\\)?\\([A-Za-z0-9]+\\)&quot; fn)</span>
	  <span class="s0">(setq fgcolor (concat</span>
			 <span class="s0">(if (match-beginning 1) &quot;#&quot;)</span>
			 <span class="s0">(substring fn (match-beginning 2) (match-end 2)))</span>
		<span class="s0">fn (substring fn (match-end 0)))</span>
	<span class="s0">(error &quot;bad face name %S&quot; face))</span>

      <span class="s0">;; parse background color</span>
      <span class="s0">(if (string-match &quot;^/\\(hex-\\)?\\([A-Za-z0-9]+\\)&quot; fn)</span>
	  <span class="s0">(setq bgcolor (concat</span>
			 <span class="s0">(and (match-beginning 1) &quot;#&quot;)</span>
			 <span class="s0">(substring fn (match-beginning 2) (match-end 2)))</span>
		<span class="s0">fn (substring fn (match-end 0))))</span>

      <span class="s0">(and (string= &quot;default&quot; fgcolor) (setq fgcolor nil))</span>
      <span class="s0">(and (string= &quot;default&quot; bgcolor) (setq bgcolor nil))</span>

      <span class="s0">;; catch errors if we can't allocate the color(s)</span>
      <span class="s0">(condition-case nil</span>
	  <span class="s0">(progn (and fgcolor (set-face-foreground 'scratch-face fgcolor))</span>
		 <span class="s0">(and bgcolor (set-face-background 'scratch-face bgcolor))</span>
		 <span class="s0">(copy-face 'scratch-face face)</span>
		 <span class="s0">(put face 'basefont basefont))</span>
	<span class="s0">(error (message &quot;couldn't allocate color for '%s'&quot;</span>
			<span class="s0">(symbol-name face))</span>
	       <span class="s0">(setq face 'default)</span>
	       <span class="s0">(setq error t)))</span>
      <span class="s0">(or error</span>
	  <span class="s0">;; don't bother w/ bold or italic if we didn't get the color</span>
	  <span class="s0">;; we wanted, but ignore errors making the face bold or italic</span>
	  <span class="s0">;; if the font isn't available, there's nothing to do about it...</span>
	  <span class="s0">(progn</span>
	    <span class="s0">(when (display-graphic-p frame)</span>
	      <span class="s0">(set-face-font face basefont frame))</span>
	    <span class="s0">(set-face-underline-p face (string-match &quot;underline&quot; fn))</span>
	    <span class="s0">(if (string-match &quot;.*bold&quot; fn)</span>
		<span class="s0">;; make face bold in all frames</span>
		<span class="s0">(make-face-bold face nil 'noerr))</span>
	    <span class="s0">(if (string-match &quot;.*italic&quot; fn)</span>
		<span class="s0">;; make face italic in all frames</span>
		<span class="s0">(make-face-italic face nil 'noerr))</span>
	    <span class="s0">))</span>
      <span class="s0">)))</span>
  <span class="s0">face)</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; Region Highlight/Unhighlight code (Both overlay and text-property versions)</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="s0">(defsubst hilit-region-set-face (start end face-name &amp;optional prio prop)</span>
  <span class="s0">&quot;Highlight region from START to END using FACE and, optionally, PRIO.</span>
<span class="s0">The optional 5th arg, PROP is a property to set instead of 'hilit.&quot;</span>
  <span class="s0">(let ((overlay (make-overlay start end)))</span>
    <span class="s0">(overlay-put overlay 'face face-name)</span>
    <span class="s0">(overlay-put overlay (or prop 'hilit) t)</span>
    <span class="s0">(and prio (overlay-put overlay 'priority prio))))</span>

<span class="s0">(defun hilit-unhighlight-region (start end &amp;optional quietly)</span>
  <span class="s0">&quot;Unhighlights the region from START to END, optionally in a QUIET way&quot;</span>
  <span class="s0">(interactive &quot;r&quot;)</span>
  <span class="s0">(or quietly hilit-quietly (message &quot;Unhighlighting&quot;))</span>
  <span class="s0">(let ((lstart 0))</span>
    <span class="s0">(while (and start (&gt; start lstart) (&lt; start end))</span>
      <span class="s0">(mapcar (function (lambda (ovr)</span>
			  <span class="s0">(and (overlay-get ovr 'hilit) (delete-overlay ovr))))</span>
	      <span class="s0">(overlays-at start))</span>
      <span class="s0">(setq lstart start start (next-overlay-change start))))</span>
  <span class="s0">(or quietly hilit-quietly (message &quot;Done unhighlighting&quot;)))</span>

<span class="s0">;;;; These functions use text properties instead of overlays.  Text properties</span>
<span class="s0">;;;; are copied through kill and yank...which might be convenient, but is not</span>
<span class="s0">;;;; terribly efficient as of 19.12, ERGO it's been disabled</span>
<span class="s0">;;</span>
<span class="s0">;;(defsubst hilit-region-set-face (start end face-name &amp;optional prio prop)</span>
<span class="s0">;;  &quot;Highlight region from START to END using FACE and, optionally, PRIO.</span>
<span class="s0">;;The optional 5th arg, PROP is a property to set instead of 'hilit.&quot;</span>
<span class="s0">;;    (put-text-property start end 'face face-name)</span>
<span class="s0">;;    )</span>
<span class="s0">;;</span>
<span class="s0">;;(defun hilit-unhighlight-region (start end &amp;optional quietly)</span>
<span class="s0">;;  &quot;Unhighlights the region from START to END, optionally in a QUIET way&quot;</span>
<span class="s0">;;  (interactive &quot;r&quot;)</span>
<span class="s0">;;  (let ((buffer-read-only nil)</span>
<span class="s0">;;	(bm (buffer-modified-p)))</span>
<span class="s0">;;    (remove-text-properties start end '(face))</span>
<span class="s0">;;    (set-buffer-modified-p bm)))</span>
<span class="s0">;;;;</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; Pattern Application code and user functions</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="s0">(defun hilit-highlight-region (start end &amp;optional patterns quietly)</span>
  <span class="s0">&quot;Highlights the area of the buffer between START and END (the region when</span>
<span class="s0">interactive).  Without the optional PATTERNS argument, the pattern for</span>
<span class="s0">major-mode is used.  If PATTERNS is a symbol, then the patterns associated</span>
<span class="s0">with that symbol are used.  QUIETLY suppresses progress messages if</span>
<span class="s0">non-nil.&quot;</span>
  <span class="s0">(interactive &quot;r&quot;)</span>
  <span class="s0">(cond ((null patterns)</span>
	 <span class="s0">(setq patterns (cdr (assq major-mode hilit-patterns-alist))))</span>
	<span class="s0">((symbolp patterns)</span>
	 <span class="s0">(setq patterns (cdr (assq patterns hilit-patterns-alist)))))</span>
  <span class="s0">;; txt prop: (setq patterns (reverse patterns))</span>
  <span class="s0">(let ((case-fold-search (car patterns))</span>
	<span class="s0">(prio (1- (length patterns)))</span>
	<span class="s0">;; txt prop: (buffer-read-only nil)</span>
	<span class="s0">;; txt prop: (bm (buffer-modified-p))</span>
	<span class="s0">p pstart pend face mstart (puke-count 0))</span>
    <span class="s0">;; txt prop: (unwind-protect</span>
    <span class="s0">(setq patterns (cdr patterns))	; remove case-fold from head of pattern</span>
    <span class="s0">(save-excursion</span>
      <span class="s0">(save-restriction</span>
	<span class="s0">(narrow-to-region start end)</span>
	<span class="s0">(while patterns</span>
	  <span class="s0">(setq p (car patterns))</span>
	  <span class="s0">(setq pstart (car p)</span>
		<span class="s0">pend (nth 1 p)</span>
		<span class="s0">face (hilit-lookup-face-create (nth 2 p)))</span>
	  <span class="s0">(if (not face)		; skipped if nil</span>
	      <span class="s0">nil</span>
	    <span class="s0">(or quietly hilit-quietly</span>
		<span class="s0">(message &quot;highlighting %d: %s%s&quot; prio pstart</span>
			 <span class="s0">(if (stringp pend) (concat &quot; ... &quot; pend) &quot;&quot;)))</span>
	    <span class="s0">(goto-char (point-min))</span>
	    <span class="s0">(condition-case msg</span>
		<span class="s0">(cond</span>
		      <span class="s0">((symbolp pstart)</span>
		       <span class="s0">;; inner loop -- special function to find pattern</span>
		       <span class="s0">(let (region)</span>
			 <span class="s0">(while (setq region (funcall pstart pend))</span>
			   <span class="s0">(hilit-region-set-face (car region) (cdr region)</span>
						  <span class="s0">face prio))))</span>
		      <span class="s0">((stringp pend)</span>
		       <span class="s0">;; inner loop -- regex-start ... regex-end</span>
		       <span class="s0">(while (re-search-forward pstart nil t nil)</span>
			 <span class="s0">(goto-char (setq mstart (match-beginning 0)))</span>
			 <span class="s0">(if (re-search-forward pend nil t nil)</span>
			     <span class="s0">(hilit-region-set-face mstart (match-end 0)</span>
						    <span class="s0">face prio)</span>
			   <span class="s0">(forward-char 1))))</span>
		      <span class="s0">((numberp pend)</span>
		       <span class="s0">;; inner loop -- just one regex to match whole pattern</span>
		       <span class="s0">(while (re-search-forward pstart nil t nil)</span>
			 <span class="s0">(goto-char (match-end pend))</span>
			 <span class="s0">(hilit-region-set-face  (match-beginning pend)</span>
						 <span class="s0">(match-end pend) face prio)))</span>
		      <span class="s0">(t (error &quot;malformed pattern&quot;)))</span>
	      <span class="s0">(error (if (&gt; (setq puke-count (1+ puke-count)) 1)</span>
			 <span class="s0">(error msg)</span>
		       <span class="s0">(message &quot;Error: '%s'&quot; msg)</span>
		       <span class="s0">(ding) (sit-for 4)))))</span>
	  <span class="s0">(setq prio (1- prio)</span>
		<span class="s0">patterns (cdr patterns)))</span>
	<span class="s0">))</span>
    <span class="s0">(or quietly hilit-quietly (message &quot;&quot;)) ; &quot;Done highlighting&quot;</span>
    <span class="s0">;; txt prop: (set-buffer-modified-p bm)) ; unwind protection</span>
    <span class="s0">))</span>

<span class="s0">(defun hilit-rehighlight-region (start end &amp;optional quietly)</span>
  <span class="s0">&quot;Re-highlights the region, optionally in a QUIET way&quot;</span>
  <span class="s0">(interactive &quot;r&quot;)</span>
  <span class="s0">(save-restriction</span>
    <span class="s0">(widen)</span>
    <span class="s0">(setq start (apply 'min start (mapcar 'overlay-start (overlays-at start)))</span>
	  <span class="s0">end (apply 'max end (mapcar 'overlay-end (overlays-at end))))</span>
    <span class="s0">(hilit-unhighlight-region start end quietly)</span>
    <span class="s0">(hilit-highlight-region   start end nil quietly)))</span>

<span class="s0">(defun hilit-rehighlight-buffer (&amp;optional quietly)</span>
  <span class="s0">&quot;Re-highlights the buffer, optionally in a QUIET way&quot;</span>
  <span class="s0">(interactive &quot;&quot;)</span>
  <span class="s0">(let ((parse-fn (cdr (assq major-mode hilit-parser-alist))))</span>
    <span class="s0">(if parse-fn</span>
	<span class="s0">(funcall parse-fn quietly)</span>
      <span class="s0">(hilit-rehighlight-region (point-min) (point-max) quietly)))</span>
  <span class="s0">nil)</span>

<span class="s0">(defun hilit-rehighlight-buffer-quietly ()</span>
  <span class="s0">(hilit-rehighlight-buffer t))</span>

<span class="s0">(defun hilit-rehighlight-message (quietly)</span>
  <span class="s0">&quot;Highlight a buffer containing a news article or mail message.&quot;</span>
  <span class="s0">(save-excursion</span>
    <span class="s0">(goto-char (point-min))</span>
    <span class="s0">;; find separation between headers and body (either a blank line or</span>
    <span class="s0">;; the message separator line in mail-mode)</span>
    <span class="s0">(re-search-forward &quot;^\\(\\|--text follows this line--\\)$&quot; nil 'noerr)</span>
    <span class="s0">(hilit-unhighlight-region (point-min) (point-max) quietly)</span>
    <span class="s0">(hilit-highlight-region (point-min) (point) 'msg-header quietly)</span>
    <span class="s0">(hilit-highlight-region (point) (point-max) 'msg-body quietly)))</span>

<span class="s0">(defalias 'hilit-highlight-buffer 'hilit-rehighlight-buffer)</span>

<span class="s0">;; Well, I want to remove this function...there's one sure way to find out if</span>
<span class="s0">;; anyone uses it or not...and that's to comment it out.</span>
<span class="s0">;;</span>
<span class="s0">;; (defun hilit-toggle-highlight (arg)</span>
<span class="s0">;;   &quot;Locally toggle highlighting.  With arg, forces highlighting off.&quot;</span>
<span class="s0">;;   (interactive &quot;P&quot;)</span>
<span class="s0">;;   ;; FIXME -- this loses numeric information in hilit-auto-rehighlight</span>
<span class="s0">;;   (setq hilit-auto-rehighlight</span>
<span class="s0">;;         (and (not arg) (not hilit-auto-rehighlight)))</span>
<span class="s0">;;   (if hilit-auto-rehighlight</span>
<span class="s0">;;       (hilit-rehighlight-buffer)</span>
<span class="s0">;;     (hilit-unhighlight-region (point-min) (point-max)))</span>
<span class="s0">;;   (message &quot;Rehighlighting is set to %s&quot; hilit-auto-rehighlight))</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; HOOKS</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="s0">(defun hilit-find-file-hook ()</span>
  <span class="s0">&quot;Find-file hook for hilit package.  See the variable hilit-auto-highlight.&quot;</span>
  <span class="s0">(cond ((and hilit-auto-highlight</span>
	      <span class="s0">(assq major-mode hilit-patterns-alist))</span>
	 <span class="s0">(if (&gt; buffer-saved-size (car hilit-auto-rehighlight-fallback))</span>
	     <span class="s0">(setq hilit-auto-rehighlight</span>
		   <span class="s0">(cdr hilit-auto-rehighlight-fallback)))</span>
	 <span class="s0">(if (&gt; buffer-saved-size hilit-auto-highlight-maxout)</span>
	     <span class="s0">nil</span>
	   <span class="s0">(let ((bm (buffer-modified-p)))</span>
	     <span class="s0">(hilit-rehighlight-buffer)</span>
	     <span class="s0">(set-buffer-modified-p bm))))))</span>

<span class="s0">(defun hilit-repaint-command (arg)</span>
  <span class="s0">&quot;Rehighlights according to the value of hilit-auto-rehighlight, or the</span>
<span class="s0">prefix argument if that is specified.</span>
<span class="s0">\t\\[hilit-repaint-command]\t\trepaint according to hilit-auto-rehighlight</span>
<span class="s0">\t^U \\[hilit-repaint-command]\trepaint entire buffer</span>
<span class="s0">\t^U - \\[hilit-repaint-command]\trepaint visible portion of buffer</span>
<span class="s0">\t^U n \\[hilit-repaint-command]\trepaint n lines to either side of point&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(let (st en quietly)</span>
    <span class="s0">(or arg (setq arg hilit-auto-rehighlight))</span>
    <span class="s0">(cond ((or (eq  arg 'visible) (eq arg '-))</span>
	   <span class="s0">(setq st (window-start) en (window-end) quietly t))</span>
	  <span class="s0">((numberp arg)</span>
	   <span class="s0">(setq st (save-excursion (forward-line (- arg)) (point))</span>
		 <span class="s0">en (save-excursion (forward-line arg) (point))))</span>
	  <span class="s0">(arg</span>
	   <span class="s0">(hilit-rehighlight-buffer)))</span>
    <span class="s0">(if st</span>
	  <span class="s0">(hilit-rehighlight-region st en quietly))))</span>

<span class="s0">(defun hilit-recenter (arg)</span>
  <span class="s0">&quot;Recenter, then rehighlight according to hilit-auto-rehighlight.  If called</span>
<span class="s0">with an unspecified prefix argument (^U but no number), then a rehighlight of</span>
<span class="s0">the entire buffer is forced.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>
  <span class="s0">(recenter arg)</span>
  <span class="s0">;; force display update</span>
  <span class="s0">(sit-for 0)</span>
  <span class="s0">(hilit-repaint-command (consp arg)))</span>

<span class="s0">(defun hilit-yank (arg)</span>
  <span class="s0">&quot;Yank with rehighlighting&quot;</span>
  <span class="s0">(interactive &quot;*P&quot;)</span>
  <span class="s0">(let ((transient-mark-mode nil))</span>
    <span class="s0">(yank arg)</span>
    <span class="s0">(and hilit-auto-rehighlight</span>
	 <span class="s0">(hilit-rehighlight-region (region-beginning) (region-end) t))</span>
    <span class="s0">(setq this-command 'yank)))</span>

<span class="s0">(defun hilit-yank-pop (arg)</span>
  <span class="s0">&quot;Yank-pop with rehighlighting&quot;</span>
  <span class="s0">(interactive &quot;*p&quot;)</span>
  <span class="s0">(let ((transient-mark-mode nil))</span>
    <span class="s0">(yank-pop arg)</span>
    <span class="s0">(and hilit-auto-rehighlight</span>
	 <span class="s0">(hilit-rehighlight-region (region-beginning) (region-end) t))</span>
    <span class="s0">(setq this-command 'yank)))</span>

<span class="s0">;;; this line highlighting stuff is untested.  play with it only if you feel</span>
<span class="s0">;;; adventurous...don't ask me to fix it...though you're welcome to.  -- Stig</span>
<span class="s0">;;</span>
<span class="s0">;; (defun hilit-rehighlight-line-quietly (&amp;rest args)</span>
<span class="s0">;;   &quot;Quietly rehighlight just this line.</span>
<span class="s0">;; Useful as an after change hook in VM/gnus summary buffers and dired buffers.</span>
<span class="s0">;; If only there were an after-change-function, that is...&quot;</span>
<span class="s0">;;   (save-excursion</span>
<span class="s0">;;     (push-mark nil t)</span>
<span class="s0">;;     (hilit-rehighlight-yank-region)</span>
<span class="s0">;;     (and orig-achange-function (apply orig-achange-function args))))</span>
<span class="s0">;;</span>
<span class="s0">;; (defun hilit-install-line-hooks ()</span>
<span class="s0">;;   (make-variable-buffer-local 'after-change-function)</span>
<span class="s0">;;   (make-local-variable 'orig-achange-function)</span>
<span class="s0">;;   (setq orig-achange-function after-change-function)</span>
<span class="s0">;;   (setq after-change-function 'hilit-rehighlight-line-quietly))</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; Wysiwyg Stuff...  take it away and build a whole package around it!</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;;</span>
<span class="s0">;; ; For the Jargon-impaired, WYSIWYG === What You See Is What You Get</span>
<span class="s0">;; ; Sure, it sucks to type.  Oh, well.</span>
<span class="s0">;; (defun hilit-wysiwyg-replace ()</span>
<span class="s0">;;   &quot;Replace overstruck text with normal text that's been overlaid with the</span>
<span class="s0">;; appropriate text attribute.  Suitable for a find-file hook.&quot;</span>
<span class="s0">;;   (save-excursion</span>
<span class="s0">;;     (goto-char (point-min))</span>
<span class="s0">;;     (let ((wysb (hilit-lookup-face-create 'wysiwyg-bold))</span>
<span class="s0">;; 	  (wysu (hilit-lookup-face-create 'wysiwyg-underline))</span>
<span class="s0">;; 	  (bmod (buffer-modified-p)))</span>
<span class="s0">;;       (while (re-search-forward &quot;\\(.\b.\\)+&quot; nil t)</span>
<span class="s0">;; 	(let ((st (match-beginning 0)) (en (match-end 0)))</span>
<span class="s0">;; 	  (goto-char st)</span>
<span class="s0">;; 	  (if (looking-at &quot;_&quot;)</span>
<span class="s0">;; 	      (hilit-region-set-face st en wysu 100 'wysiwyg)</span>
<span class="s0">;; 	    (hilit-region-set-face st en wysb 100 'wysiwyg))</span>
<span class="s0">;; 	  (while (and (&lt; (point) en) (looking-at &quot;.\b&quot;))</span>
<span class="s0">;; 	    (replace-match &quot;&quot;) (forward-char))</span>
<span class="s0">;; 	  ))</span>
<span class="s0">;;       (set-buffer-modified-p bmod))))</span>
<span class="s0">;;</span>
<span class="s0">;; ; is this more appropriate as a write-file-hook or a write-contents-hook?</span>
<span class="s0">;; (defun hilit-wysiwyg-write-repair ()</span>
<span class="s0">;;   &quot;Replace wysiwyg overlays with overstrike text.&quot;</span>
<span class="s0">;;   (message &quot;*sigh* hilit-wysiwyg-write-repair not implemented yet&quot;)</span>
<span class="s0">;;</span>
<span class="s0">;; For efficiency, this hook should copy the current buffer to a scratch</span>
<span class="s0">;; buffer and do its overstriking there.  Overlays are not copied, so it'll</span>
<span class="s0">;; be necessary to hop back and forth.  This is OK since you're not fiddling</span>
<span class="s0">;; with--making or deleting--any overlays.  THEN write the new buffer,</span>
<span class="s0">;; delete it, and RETURN T. &lt;&lt; important</span>
<span class="s0">;;</span>
<span class="s0">;; Just so you know...there is already an emacs function called</span>
<span class="s0">;; underline-region that does underlining.  I think that the thing to do is</span>
<span class="s0">;; extend that to do overstriking as well.</span>
<span class="s0">;;</span>
<span class="s0">;;  (while (&lt; start end)</span>
<span class="s0">;;    (mapcar (function (lambda (ovr)</span>
<span class="s0">;;			  (and (overlay-get ovr 'hilit) (delete-overlay ovr))))</span>
<span class="s0">;;	    (overlays-at start))</span>
<span class="s0">;;    (setq start (next-overlay-change start)))</span>
<span class="s0">;;  nil)</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; Initialization.</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="s0">(define-minor-mode hilit-mode</span>
  <span class="s0">&quot;Obsolete minor mode.  Use `global-font-lock-mode' instead.&quot;</span>
  <span class="s0">:global t</span>

  <span class="s0">(unless (and hilit-inhibit-rebinding hilit-mode)</span>
    <span class="s0">(substitute-key-definition</span>
     <span class="s0">(if hilit-mode 'yank 'hilit-yank)</span>
     <span class="s0">(if hilit-mode 'hilit-yank 'yank)</span>
     <span class="s0">(current-global-map))</span>
    <span class="s0">(substitute-key-definition</span>
     <span class="s0">(if hilit-mode 'yank-pop 'hilit-yank-pop)</span>
     <span class="s0">(if hilit-mode 'hilit-yank-pop 'yank-pop)</span>
     <span class="s0">(current-global-map))</span>
    <span class="s0">(substitute-key-definition</span>
     <span class="s0">(if hilit-mode 'recenter 'hilit-recenter)</span>
     <span class="s0">(if hilit-mode 'hilit-recenter 'recenter)</span>
     <span class="s0">(current-global-map)))</span>

  <span class="s0">(if hilit-mode</span>
      <span class="s0">(global-set-key [?\C-\S-l] 'hilit-repaint-command)</span>
    <span class="s0">(global-unset-key [?\C-\S-l]))</span>

  <span class="s0">(if hilit-mode</span>
      <span class="s0">(add-hook 'find-file-hook 'hilit-find-file-hook t)</span>
    <span class="s0">(remove-hook 'find-file-hook 'hilit-find-file-hook))</span>

  <span class="s0">(unless (and hilit-inhibit-hooks hilit-mode)</span>
    <span class="s0">(condition-case c</span>
	<span class="s0">(progn</span>

	  <span class="s0">;; BUFFER highlights...</span>
	  <span class="s0">(mapcar (lambda (hook)</span>
		    <span class="s0">(if hilit-mode</span>
			<span class="s0">(add-hook hook 'hilit-rehighlight-buffer-quietly)</span>
		      <span class="s0">(remove-hook hook 'hilit-rehighlight-buffer-quietly)))</span>
		  <span class="s0">'(</span>
		    <span class="s0">Info-selection-hook</span>

		    <span class="s0">;; runs too early		     vm-summary-mode-hooks</span>
		    <span class="s0">vm-summary-pointer-hook</span>
		    <span class="s0">vm-preview-message-hook</span>
		    <span class="s0">vm-show-message-hook</span>

		    <span class="s0">rmail-show-message-hook</span>
		    <span class="s0">mail-setup-hook</span>
		    <span class="s0">mh-show-mode-hook</span>

		    <span class="s0">dired-after-readin-hook</span>
		    <span class="s0">))</span>
	  <span class="s0">)</span>
      <span class="s0">(error (message &quot;Error loading highlight hooks: %s&quot; c)</span>
	     <span class="s0">(ding) (sit-for 1)))))</span>

<span class="s0">(eval-when-compile (require 'gnus))	; no compilation gripes</span>

<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
<span class="s0">;; Default patterns for various modes.</span>
<span class="s0">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>

<span class="s0">;;; do I need this?  I changed the defconst to a defvar because defconst is</span>
<span class="s0">;;; inappropriate, but I don't know why I wanted hilit-patterns-alist to be</span>
<span class="s0">;;; reset on every reload...</span>

<span class="s0">(setq hilit-patterns-alist nil)</span>

<span class="s0">(defun hilit-associate (alist key val)</span>
  <span class="s0">&quot;creates, or destructively replaces, the pair (key . val) in alist&quot;</span>
  <span class="s0">(let ((oldentry (assq key (eval alist))))</span>
    <span class="s0">(if oldentry</span>
	<span class="s0">(setcdr oldentry val)</span>
      <span class="s0">(set alist (cons (cons key val) (eval alist))))))</span>

<span class="s0">(defun hilit-set-mode-patterns (modelist patterns</span>
					 <span class="s0">&amp;optional parse-fn case-fold)</span>
  <span class="s0">&quot;Sets the default highlighting patterns for MODE to PATTERNS.</span>
<span class="s0">See the variable hilit-mode-enable-list.</span>

<span class="s0">Takes optional arguments PARSE-FN and CASE-FOLD.&quot;</span>
  <span class="s0">;; change pattern</span>
  <span class="s0">(mapcar (function (lambda (p)</span>
		      <span class="s0">(and (stringp (car p))</span>
			   <span class="s0">(null (nth 1 p))</span>
			   <span class="s0">(setcar (cdr p) 0))))</span>
	  <span class="s0">patterns)</span>
  <span class="s0">(setq patterns (cons case-fold patterns))</span>

  <span class="s0">(or (consp modelist) (setq modelist (list modelist)))</span>
  <span class="s0">(let (ok (flip (eq (car hilit-mode-enable-list) 'not)))</span>
    <span class="s0">(mapcar (function</span>
	     <span class="s0">(lambda (m)</span>
	       <span class="s0">(setq ok (or (null hilit-mode-enable-list)</span>
			    <span class="s0">(memq m hilit-mode-enable-list)))</span>
	       <span class="s0">(and flip (setq ok (not ok)))</span>
	       <span class="s0">(and ok</span>
		    <span class="s0">(progn</span>
		      <span class="s0">(and parse-fn</span>
			   <span class="s0">(hilit-associate 'hilit-parser-alist m parse-fn))</span>
		      <span class="s0">(hilit-associate 'hilit-patterns-alist m patterns)))))</span>
	    <span class="s0">modelist)))</span>

<span class="s0">(defun hilit-add-pattern (pstart pend face &amp;optional mode first)</span>
  <span class="s0">&quot;Highlight pstart with face for the current major-mode.</span>
<span class="s0">Optionally, place the new pattern first in the pattern list&quot;</span>
  <span class="s0">(interactive &quot;sPattern start regex: \nsPattern end regex (default none): \nxFace: &quot;)</span>

  <span class="s0">(and (equal pstart &quot;&quot;) (error &quot;Must specify starting regex&quot;))</span>
  <span class="s0">(cond ((equal pend &quot;&quot;) (setq pend 0))</span>
	<span class="s0">((string-match &quot;^[0-9]+$&quot; pend) (setq pend (string-to-number pend))))</span>
  <span class="s0">(or mode (setq mode major-mode))</span>
  <span class="s0">(let ((old-patterns (cdr (assq mode hilit-patterns-alist)))</span>
	<span class="s0">(new-pat (list pstart pend face)))</span>
    <span class="s0">(cond ((not old-patterns)</span>
	   <span class="s0">(hilit-set-mode-patterns mode (list new-pat)))</span>
	  <span class="s0">(first</span>
	   <span class="s0">(setcdr old-patterns (cons new-pat (cdr old-patterns))))</span>
	  <span class="s0">(t</span>
	   <span class="s0">(nconc old-patterns (list new-pat)))))</span>
  <span class="s0">(and (interactive-p) (hilit-rehighlight-buffer)))</span>

<span class="s0">(defun hilit-string-find (qchar)</span>
  <span class="s0">&quot;Looks for a string and returns (start . end) or nil.  The argument QCHAR</span>
<span class="s0">is the character that would precede a character constant double quote.</span>
<span class="s0">Finds strings delimited by double quotes.  The first double quote may not be</span>
<span class="s0">preceded by QCHAR and the closing double quote may not be preceded by an odd</span>
<span class="s0">number of backslashes.&quot;</span>
  <span class="s0">(let (st en)</span>
    <span class="s0">(while (and (search-forward &quot;\&quot;&quot; nil t)</span>
		<span class="s0">(eq qchar (char-after (1- (setq st (match-beginning 0)))))))</span>
    <span class="s0">(while (and (search-forward &quot;\&quot;&quot; nil t)</span>
		<span class="s0">(save-excursion</span>
		  <span class="s0">(setq en (point))</span>
		  <span class="s0">(forward-char -1)</span>
		  <span class="s0">(skip-chars-backward &quot;\\\\&quot;)</span>
		  <span class="s0">(forward-char 1)</span>
		  <span class="s0">(not (zerop (% (- en (point)) 2))))))</span>
    <span class="s0">(and en (cons st en))))</span>

<span class="s0">;; return types on same line...</span>
<span class="s0">;; (&quot;^[a-zA-z].*\\(\\w\\|[$_]\\)+\\s *\\(\\(\\w\\|[$_]\\)+\\s *((\\|(\\)[^)]*)+&quot; nil defun)</span>

<span class="s0">;; On another note, a working pattern for grabbing function definitions for C is</span>
<span class="s0">;;</span>
<span class="s0">;; (&quot;^[a-zA-Z_]+.*[;{]$&quot; nil ForestGreen)  ; global defns ( start at col 1 )</span>
<span class="s0">;; (&quot;^[a-zA-Z_]+.*(&quot; &quot;)&quot; defun)</span>
<span class="s0">;; ; defuns assumed to start at col 1, not with # or {</span>
<span class="s0">;;</span>
<span class="s0">;; this will make external declarations/definitions green, and function</span>
<span class="s0">;; definitions the defun face.  Hmmm - seems to work for me anyway.</span>

<span class="s0">(let ((comments     '((&quot;/\\*&quot; &quot;\\*/&quot; comment)))</span>
      <span class="s0">(c++-comments '((&quot;//.*$&quot; nil comment)</span>
		      <span class="s0">(&quot;^/.*$&quot; nil comment)))</span>
      <span class="s0">(strings      '((hilit-string-find ?' string)))</span>
      <span class="s0">(preprocessor '((&quot;^#[ \t]*\\(undef\\|define\\).*$&quot; &quot;[^\\]$&quot; define)</span>
		      <span class="s0">(&quot;^#.*$&quot; nil include))))</span>

  <span class="s0">(hilit-set-mode-patterns</span>
   <span class="s0">'(c-mode c++-c-mode elec-c-mode)</span>
   <span class="s0">(append</span>
    <span class="s0">comments strings preprocessor</span>
    <span class="s0">'(</span>
      <span class="s0">;; function decls are expected to have types on the previous line</span>
      <span class="s0">(&quot;^\\(\\w\\|[$_]\\)+\\s *\\(\\(\\w\\|[$_]\\)+\\s *((\\|(\\)[^)]*)+&quot; nil defun)</span>
      <span class="s0">(&quot;^\\(typedef\\|struct\\|union\\|enum\\).*$&quot; nil decl)</span>
      <span class="s0">;; datatype -- black magic regular expression</span>
      <span class="s0">(&quot;[ \n\t({]\\(\\(const\\|register\\|volatile\\|unsigned\\|extern\\|static\\)\\s +\\)*\\(\\(\\w\\|[$_]\\)+_t\\|float\\|double\\|void\\|char\\|short\\|int\\|long\\|FILE\\|\\(\\(struct\\|union\\|enum\\)\\([ \t]+\\(\\w\\|[$_]\\)*\\)\\)\\)\\(\\s +\\*+)?\\|[ \n\t;()]\\)&quot; nil type)</span>
      <span class="s0">;; key words</span>
      <span class="s0">(&quot;[^_]\\&lt;\\(return\\|goto\\|if\\|else\\|case\\|default\\|switch\\|break\\|continue\\|while\\|do\\|for\\)\\&gt;[^_]&quot; 1 keyword)</span>
      <span class="s0">)))</span>

  <span class="s0">(hilit-set-mode-patterns</span>
   <span class="s0">'c++-mode</span>
   <span class="s0">(append</span>
    <span class="s0">comments c++-comments strings preprocessor</span>
    <span class="s0">'(</span>
      <span class="s0">;; function decls are expected to have types on the previous line</span>
      <span class="s0">(&quot;^\\(\\(\\w\\|[$_]\\)+::\\)?\\(\\w\\|[$_]\\)+\\s *\\(\\(\\w\\|[$_]\\)+\\s *((\\|(\\)[^)]*)+&quot; nil defun)</span>
      <span class="s0">(&quot;^\\(\\(\\w\\|[$_]\\)+[ \t]*::[ \t]*\\)?\\(\\(\\w\\|[$_]\\)+\\|operator.*\\)\\s *\\(\\(\\w\\|[$_]\\)+\\s *((\\|(\\)[^)]*)+&quot; nil defun)</span>
      <span class="s0">(&quot;^\\(template\\|typedef\\|struct\\|union\\|class\\|enum\\|public\\|private\\|protected\\).*$&quot; nil decl)</span>
      <span class="s0">;; datatype -- black magic regular expression</span>
      <span class="s0">(&quot;[ \n\t({]\\(\\(const\\|register\\|volatile\\|unsigned\\|extern\\|static\\)\\s +\\)*\\(\\(\\w\\|[$_]\\)+_t\\|float\\|double\\|void\\|char\\|short\\|int\\|long\\|FILE\\|\\(\\(struct\\|union\\|enum\\|class\\)\\([ \t]+\\(\\w\\|[$_]\\)*\\)\\)\\)\\(\\s +\\*+)?\\|[ \n\t;()]\\)&quot; nil type)</span>
      <span class="s0">;; key words</span>
      <span class="s0">(&quot;[^_]\\&lt;\\(return\\|goto\\|if\\|else\\|case\\|default\\|switch\\|break\\|continue\\|while\\|do\\|for\\|public\\|protected\\|private\\|delete\\|new\\)\\&gt;[^_]&quot;</span>
       <span class="s0">1 keyword))))</span>

  <span class="s0">(hilit-set-mode-patterns</span>
   <span class="s0">'(objc-mode objective-C-mode)</span>
   <span class="s0">(append</span>
    <span class="s0">comments c++-comments strings preprocessor</span>
    <span class="s0">'(</span>
      <span class="s0">;; function decls are expected to have types on the previous line</span>
      <span class="s0">(&quot;^\\(\\(\\w\\|[$_]\\)+::\\)?\\(\\w\\|[$_]\\)+\\s *\\(\\(\\w\\|[$_]\\)+\\s *((\\|(\\)[^)]*)+&quot; nil defun)</span>
      <span class="s0">(&quot;^\\(\\(\\w\\|[$_]\\)+[ \t]*::[ \t]*\\)?\\(\\(\\w\\|[$_]\\)+\\|operator.*\\)\\s *\\(\\(\\w\\|[$_]\\)+\\s *((\\|(\\)[^)]*)+&quot; nil defun)</span>

      <span class="s0">(&quot;^\\(template\\|typedef\\|struct\\|union\\|class\\|enum\\|public\\|private\\|protected\\).*$&quot; nil decl)</span>
      <span class="s0">;; datatype -- black magic regular expression</span>
      <span class="s0">(&quot;[ \n\t({]\\(\\(const\\|register\\|volatile\\|unsigned\\|extern\\|static\\)\\s +\\)*\\(\\(\\w\\|[$_]\\)+_t\\|float\\|double\\|void\\|char\\|short\\|int\\|long\\|FILE\\|\\(\\(struct\\|union\\|enum\\|class\\)\\([ \t]+\\(\\w\\|[$_]\\)*\\)\\)\\)\\(\\s +\\*+)?\\|[ \n\t;()]\\)&quot; nil type)</span>
      <span class="s0">;; key words</span>
      <span class="s0">(&quot;[^_]\\&lt;\\(return\\|goto\\|if\\|else\\|case\\|default\\|switch\\|break\\|continue\\|while\\|do\\|for\\|public\\|protected\\|private\\|interface\\|implementation\\|end\\|super\\|self\\)\\&gt;[^_]&quot;</span>
       <span class="s0">1 keyword))))</span>
  <span class="s0">)</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'perl-mode</span>
 <span class="s0">'((&quot;\\s #.*$&quot; nil comment)</span>
   <span class="s0">(&quot;^#.*$&quot; nil comment)</span>
   <span class="s0">(&quot;\&quot;[^\\\&quot;]*\\(\\\\\\(.\\|\n\\)[^\\\&quot;]*\\)*\&quot;&quot; nil string)</span>
   <span class="s0">(&quot;^\\(__....?__\\|\\s *\\sw+:\\)&quot; nil label)</span>
   <span class="s0">(&quot;^require.*$&quot; nil include)</span>
   <span class="s0">(&quot;^package.*$&quot; nil decl)</span>
   <span class="s0">(&quot;^\\s *sub\\s +\\(\\w\\|[_']\\)+&quot; nil defun)</span>
   <span class="s0">(&quot;\\b\\(do\\|if\\|unless\\|while\\|until\\|else\\|elsif\\|for\\|foreach\\|continue\\|next\\|redo\\|last\\|goto\\|return\\|die\\|exit\\)\\b&quot; nil keyword)))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'ada-mode</span>
 <span class="s0">'(;; comments</span>
   <span class="s0">(&quot;--.*$&quot; nil comment)</span>
   <span class="s0">;; main structure</span>
   <span class="s0">(&quot;[ \t\n]procedure[ \t]&quot; &quot;\\([ \t]\\(is\\|renames\\)\\|);\\)&quot; glob-struct)</span>
   <span class="s0">(&quot;[ \t\n]task[ \t]&quot; &quot;[ \t]is&quot; glob-struct)</span>
   <span class="s0">(&quot;[ \t\n]function[ \t]&quot; &quot;return[ \t]+[A-Za-z_0-9]+[ \t]*\\(is\\|;\\|renames\\)&quot; glob-struct)</span>
   <span class="s0">(&quot;[ \t\n]package[ \t]&quot; &quot;[ \t]\\(is\\|renames\\)&quot; glob-struct)</span>
   <span class="s0">;; if there is nothing before &quot;private&quot;, it is part of the structure</span>
   <span class="s0">(&quot;^[ \t]*private[ \t\n]&quot; nil glob-struct)</span>
   <span class="s0">;; if there is no indentation before the &quot;end&quot;, then it is most</span>
   <span class="s0">;; probably the end of the package</span>
   <span class="s0">(&quot;^end.*$&quot; &quot;;&quot; glob-struct)</span>
   <span class="s0">;; program structure -- &quot;null&quot;, &quot;delay&quot; and &quot;terminate&quot; omitted</span>
   <span class="s0">(&quot;[ \n\t]\\(in\\|out\\|select\\|if\\|else\\|case\\|when\\|and\\|or\\|not\\|accept\\|loop\\|do\\|then\\|elsif\\|else\\|for\\|while\\|exit\\)[ \n\t;]&quot; nil struct)</span>
   <span class="s0">;; block structure</span>
   <span class="s0">(&quot;[ \n\t]\\(begin\\|end\\|declare\\|exception\\|generic\\|raise\\|return\\|package\\|body\\)[ \n\t;]&quot; nil struct)</span>
   <span class="s0">;; type declaration</span>
   <span class="s0">(&quot;^[ \t]*\\(type\\|subtype\\).*$&quot; &quot;;&quot; decl)</span>
   <span class="s0">(&quot;[ \t]+is record.*$&quot; &quot;end record;&quot; decl)</span>
   <span class="s0">;; &quot;pragma&quot;, &quot;with&quot;, and &quot;use&quot; are close to C cpp directives</span>
   <span class="s0">(&quot;^[ \t]*\\(with\\|pragma\\|use\\)&quot; &quot;;&quot; include)</span>
   <span class="s0">;; nice for named parameters, but not so beautiful in case statements</span>
   <span class="s0">(&quot;[A-Za-z_0-9.]+[ \t]*=&gt;&quot;   nil named-param)</span>
   <span class="s0">;; string constants probably not everybody likes this one</span>
   <span class="s0">(&quot;\&quot;&quot; &quot;.*\&quot;&quot; string)))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'fortran-mode</span>
 <span class="s0">'((&quot;^[*Cc].*$&quot; nil comment)</span>
   <span class="s0">(&quot;'[^'\n]*'&quot; nil string)</span>
   <span class="s0">(&quot;\\(^[ \t]*[0-9]+\\|[ \t]continue[ \t\n]\\|format\\)&quot; nil define)</span>
   <span class="s0">(&quot;[ \t]\\(do\\|do[ \t]*[0-9]+\\|go[ \t]*to[ \t]*[0-9]+\\|end[ \t]*do\\|if\\|else[ \t]*if\\|then\\|else\\|end[ \t]*if\\)[ \t\n(]&quot; nil define)</span>
   <span class="s0">(&quot;[ \t]\\(call\\|program\\|subroutine\\|function\\|stop\\|return\\|end\\|include\\)[ \t\n]&quot; nil include)</span>
   <span class="s0">(&quot;[ \t]\\(parameter[\t\n ]*([^)]*)\\|data\\|save\\|common[ \t\n]*/[^/]*/\\)&quot;</span>
    <span class="s0">nil decl)</span>
   <span class="s0">(&quot;^     .&quot; nil type)</span>
   <span class="s0">(&quot;implicit[ \t]*none&quot; nil decl)</span>
   <span class="s0">(&quot;\\([ \t]\\|implicit[ \t]*\\)\\(dimension\\|integer\\|real\\|double[ \t]*precision\\|character\\|logical\\|complex\\|double[ \t]*complex\\)\\([*][0-9]*\\|[ \t\n]\\)&quot; nil keyword)</span>
   <span class="s0">)</span>
 <span class="s0">nil 'case-insensitive)</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'(m2-mode modula-2-mode)</span>
 <span class="s0">'((&quot;(\\*&quot; &quot;\\*)&quot; comment)</span>
   <span class="s0">(hilit-string-find ?\\ string)</span>
   <span class="s0">(&quot;^[ \t]*PROCEDURE[ \t]+\\w+[^ \t(;]*&quot; nil defun)</span>
   <span class="s0">(&quot;\\&lt;\\(RECORD\\|ARRAY\\|OF\\|POINTER\\|TO\\|BEGIN\\|END\\|FOR\\|IF\\|THEN\\|ELSE\\|ELSIF\\|CASE\\|WHILE\\|DO\\|MODULE\\|FROM\\|RETURN\\|IMPORT\\|EXPORT\\|VAR\\|LOOP\\|UNTIL\\|\\DEFINITION\\|IMPLEMENTATION\\|AND\\|OR\\|NOT\\|CONST\\|TYPE\\|QUALIFIED\\)\\&gt;&quot; nil keyword)</span>
   <span class="s0">)</span>
 <span class="s0">nil 'case-insensitive)</span>

<span class="s0">(hilit-set-mode-patterns 'prolog-mode</span>
 <span class="s0">'((&quot;/\\*&quot; &quot;\\*/&quot; comment)</span>
   <span class="s0">(&quot;%.*$&quot; nil comment)</span>
   <span class="s0">(&quot;:-&quot; nil defun)</span>
   <span class="s0">(&quot;!&quot; nil label)</span>
   <span class="s0">(&quot;\&quot;[^\\\&quot;]*\\(\\\\\\(.\\|\n\\)[^\\\&quot;]*\\)*\&quot;&quot; nil string)</span>
   <span class="s0">(&quot;\\b\\(is\\|mod\\)\\b&quot; nil keyword)</span>
   <span class="s0">(&quot;\\(-&gt;\\|--&gt;\\|;\\|==\\|\\\\==\\|=&lt;\\|&gt;=\\|&lt;\\|&gt;\\|=\\|\\\\=\\|=:=\\|=\\\.\\\.\\|\\\\\\\+\\)&quot; nil decl)</span>
   <span class="s0">(&quot;\\(\\\[\\||\\|\\\]\\)&quot; nil include)))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'(</span>
   <span class="s0">LaTeX-mode japanese-LaTeX-mode SliTeX-mode</span>
   <span class="s0">japanese-SliTeX-mode FoilTeX-mode latex-mode</span>
   <span class="s0">)</span>
 <span class="s0">'(</span>
   <span class="s0">;; comments</span>
   <span class="s0">(&quot;[^\\]%.*$&quot; nil comment)</span>

   <span class="s0">;; the following two match \foo[xx]{xx} or \foo*{xx} or \foo{xx}</span>
   <span class="s0">(&quot;\\\\\\(sub\\)*\\(paragraph\\|section\\)\\(\*\\|\\[.*\\]\\)?{&quot; &quot;}&quot;</span>
    <span class="s0">keyword)</span>
   <span class="s0">(&quot;\\\\\\(chapter\\|part\\)\\(\*\\|\\[.*\\]\\)?{&quot; &quot;}&quot; keyword)</span>
   <span class="s0">(&quot;\\\\footnote\\(mark\\|text\\)?{&quot; &quot;}&quot; keyword)</span>
   <span class="s0">(&quot;\\\\[a-z]+box&quot; nil keyword)</span>
   <span class="s0">(&quot;\\\\\\(v\\|h\\)space\\(\*\\)?{&quot; &quot;}&quot; keyword)</span>

   <span class="s0">;; (re-)define new commands/environments/counters</span>
   <span class="s0">(&quot;\\\\\\(re\\)?new\\(environment\\|command\\){&quot; &quot;}&quot; defun)</span>
   <span class="s0">(&quot;\\\\new\\(length\\|theorem\\|counter\\){&quot; &quot;}&quot; defun)</span>

   <span class="s0">;; various declarations/definitions</span>
   <span class="s0">(&quot;\\\\\\(setlength\\|settowidth\\|addtolength\\|setcounter\\|addtocounter\\)&quot; nil define)</span>
   <span class="s0">(&quot;\\\\\\(title\\|author\\|date\\|thanks\\){&quot; &quot;}&quot; define)</span>

   <span class="s0">(&quot;\\\\documentstyle\\(\\[.*\\]\\)?{&quot; &quot;}&quot; decl)</span>
   <span class="s0">(&quot;\\\\\\(begin\\|end\\|nofiles\\|includeonly\\){&quot; &quot;}&quot; decl)</span>
   <span class="s0">(&quot;\\\\\\(raggedright\\|makeindex\\|makeglossary\\|maketitle\\)\\b&quot; nil</span>
    <span class="s0">decl)</span>
   <span class="s0">(&quot;\\\\\\(pagestyle\\|thispagestyle\\|pagenumbering\\){&quot; &quot;}&quot; decl)</span>
   <span class="s0">(&quot;\\\\\\(normalsize\\|small\\|footnotesize\\|scriptsize\\|tiny\\|large\\|Large\\|LARGE\\|huge\\|Huge\\)\\b&quot; nil decl)</span>
   <span class="s0">(&quot;\\\\\\(appendix\\|tableofcontents\\|listoffigures\\|listoftables\\)\\b&quot;</span>
    <span class="s0">nil decl)</span>
   <span class="s0">(&quot;\\\\\\(bf\\|em\\|it\\|rm\\|sf\\|sl\\|ss\\|tt\\)\\b&quot; nil decl)</span>

   <span class="s0">;; label-like things</span>
   <span class="s0">(&quot;\\\\item\\(\\[[^]]*\\]\\)?&quot; nil label)</span>
   <span class="s0">(&quot;\\\\caption\\(\\[[^]]*\\]\\)?{&quot; &quot;}&quot; label)</span>

   <span class="s0">;; formulas</span>
   <span class="s0">(&quot;[^\\]\\\\(&quot;  &quot;\\\\)&quot; formula)                   ; \( \)</span>
   <span class="s0">(&quot;[^\\]\\\\\\[&quot; &quot;\\\\\\]&quot; formula)                ; \[ \]</span>
   <span class="s0">(&quot;[^\\$]\\(\\$\\(\\$[^$]*\\$\\|[^$]*\\)\\$\\)&quot; 1 formula) ; '$...$' or '$$...$$'</span>

   <span class="s0">;; things that bring in external files</span>
   <span class="s0">(&quot;\\\\\\(include\\|input\\|bibliography\\){&quot; &quot;}&quot; include)</span>

   <span class="s0">;; &quot;wysiwyg&quot; emphasis -- these don't work with nested expressions</span>
   <span class="s0">;; (&quot;{\\\\\\(em\\|it\\|sl\\)&quot; &quot;}&quot; italic)</span>
   <span class="s0">;; (&quot;{\\\\bf&quot; &quot;}&quot; bold)</span>

   <span class="s0">(&quot;``&quot; &quot;''&quot; string)</span>

   <span class="s0">;; things that do some sort of cross-reference</span>
   <span class="s0">(&quot;\\\\\\(\\(no\\)?cite\\|\\(page\\)?ref\\|label\\|index\\|glossary\\){&quot; &quot;}&quot; crossref)</span>
   <span class="s0">))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'bibtex-mode</span>
 <span class="s0">'(;;(&quot;;.*$&quot;			nil	comment)</span>
   <span class="s0">(&quot;%.*$&quot;			nil	comment)</span>
   <span class="s0">(&quot;@[a-zA-Z]+&quot;		nil	keyword)</span>
   <span class="s0">(&quot;{[ \t]*[-a-z:_A-Z0-9]+,&quot;	nil	label) ; is wrong sometimes</span>
   <span class="s0">(&quot;^[ \t]*[a-zA-Z]+[ \t]*=&quot;	nil	define)))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'compilation-mode</span>
 <span class="s0">'(</span>
   <span class="s0">(&quot;^[-_.\&quot;A-Za-z0-9]+\\(:\\|, line \\)[0-9]+: warning:.*$&quot; nil warning)</span>
   <span class="s0">(&quot;^[-_.\&quot;A-Za-z0-9]+\\(:\\|, line \\)[0-9]+:.*$&quot; nil error)</span>
   <span class="s0">))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'makefile-mode</span>
 <span class="s0">'((&quot;^#.*$&quot; nil comment)</span>
   <span class="s0">(&quot;[^$]#.*$&quot; nil comment)</span>
   <span class="s0">;; rules</span>
   <span class="s0">(&quot;^[^ \t\n]*%[^ \t\n]*[ \t]*::?[ \t]*[^ \t\n]*[ \t]*\\(#.*\\)?$&quot; nil rule)</span>
   <span class="s0">(&quot;^[.][A-Za-z][A-Za-z]?\..*$&quot; nil rule)</span>
   <span class="s0">;; variable definition</span>
   <span class="s0">(&quot;^[_A-Za-z0-9]+[ \t]*\+?=&quot; nil define)</span>
   <span class="s0">(&quot;\\( \\|:=\\)[_A-Za-z0-9]+[ \t]*\\+=&quot; nil define)</span>
   <span class="s0">;; variable references</span>
   <span class="s0">(&quot;\\$\\([^ \t\n{(]\\|[{(]@?[_A-Za-z0-9:.,%/=]+[)}]\\)&quot; nil keyword)</span>
   <span class="s0">(&quot;^[A-Za-z0-9.,/_-]+[ \t]*:.*$&quot; nil defun)</span>
   <span class="s0">(&quot;^include &quot; nil include)))</span>

<span class="s0">(let* ((header-patterns '((&quot;^Subject:.*$&quot; nil msg-subject)</span>
			  <span class="s0">(&quot;^From:.*$&quot; nil msg-from)</span>
			  <span class="s0">(&quot;^--text follows this line--$&quot; nil msg-separator)</span>
			  <span class="s0">(&quot;^[A-Za-z][A-Za-z0-9-]+:&quot; nil msg-header)))</span>
       <span class="s0">(body-patterns '((&quot;^\\(In article\\|[ \t]*\\w*[]&lt;&gt;}|]\\).*$&quot;</span>
			 <span class="s0">nil msg-quote)))</span>
       <span class="s0">(message-patterns (append header-patterns body-patterns)))</span>
  <span class="s0">(hilit-set-mode-patterns 'msg-header header-patterns)</span>
  <span class="s0">(hilit-set-mode-patterns 'msg-body body-patterns)</span>
  <span class="s0">(hilit-set-mode-patterns '(vm-mode text-mode mail-mode rmail-mode</span>
			     <span class="s0">gnus-article-mode news-reply-mode mh-show-mode)</span>
			   <span class="s0">message-patterns</span>
			   <span class="s0">'hilit-rehighlight-message))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'gnus-group-mode</span>
 <span class="s0">'((&quot;^ U.*$&quot; nil gnus-group-unsubscribed)</span>
   <span class="s0">(&quot;^\\*? +[01]?[0-9]:.*$&quot; nil gnus-group-empty)</span>
   <span class="s0">(&quot;^ +[2-9][0-9]:.*$&quot; nil gnus-group-full)</span>
   <span class="s0">(&quot;^ +[0-9][0-9][0-9]+:.*$&quot; nil gnus-group-overflowing)))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'vm-summary-mode</span>
 <span class="s0">'((&quot;^   .*$&quot; nil summary-seen)</span>
   <span class="s0">(&quot;^-&gt;.*$&quot; nil  summary-current)</span>
   <span class="s0">(&quot;^  D.*$&quot; nil summary-deleted)</span>
   <span class="s0">(&quot;^  U.*$&quot; nil summary-unread)</span>
   <span class="s0">(&quot;^  N.*$&quot; nil summary-new)))</span>


<span class="s0">;;; this will match only comments w/ an even (zero is even) number of quotes...</span>
<span class="s0">;;; which is still inadequate because it matches comments in multi-line strings</span>
<span class="s0">;;; how anal do you want to get about never highlighting comments in strings?</span>
<span class="s0">;;; I could twiddle with this forever and still it wouldn't be perfect.</span>
<span class="s0">;;;   (&quot;;\\([^\&quot;\n]*\&quot;[^\&quot;\n]*\&quot;\\)*[^\&quot;\n]*$&quot; nil comment)</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'(emacs-lisp-mode lisp-interaction-mode)</span>
 <span class="s0">'(</span>
   <span class="s0">(&quot;;.*&quot; nil comment)</span>

<span class="s0">;;; This almost works...but I think I'll stick with the parser function</span>
<span class="s0">;;;(&quot;[^?]\\(\&quot;\\(\&quot;\\||\\([^\&quot;]+\\|[\\]\\([\\][\\]\\)*\&quot;\\)*\&quot;\\)\\)&quot; 1 string)</span>
   <span class="s0">(hilit-string-find ?\\ string)</span>

   <span class="s0">(&quot;^\\s *(def\\(un\\|macro\\|advice\\|alias\\|subst\\)[ \t\n]&quot;</span>
    <span class="s0">&quot;\\()\\|nil\\)&quot; defun)</span>
   <span class="s0">(&quot;^\\s *(defvar\\s +\\S +&quot; nil decl)</span>
   <span class="s0">(&quot;^\\s *(defconst\\s +\\S +&quot; nil define)</span>
   <span class="s0">(&quot;^\\s *(\\(provide\\|require\\|\\(auto\\)?load\\).*$&quot; nil include)</span>
   <span class="s0">(&quot;\\s *\\&amp;\\(rest\\|optional\\)\\s *&quot; nil keyword)</span>
   <span class="s0">(&quot;(\\(let\\*?\\|cond\\|if\\|or\\|and\\|map\\(car\\|concat\\)\\|prog[n1*]?\\|while\\|lambda\\|function\\|set\\([qf]\\|car\\|cdr\\)?\\|nconc\\|eval-when-compile\\|condition-case\\|unwind-protect\\|catch\\|throw\\|error\\)[ \t\n]&quot; 1 keyword)</span>
   <span class="s0">))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'(lisp-mode ilisp-mode)</span>
 <span class="s0">'(</span>
   <span class="s0">(&quot;;.*&quot; nil comment)</span>
   <span class="s0">(&quot;#|&quot; &quot;|#&quot; comment)</span>
<span class="s0">;;; This almost works...but I think I'll stick with the parser function</span>
<span class="s0">;;;(&quot;[^?]\\(\&quot;\\(\&quot;\\||\\([^\&quot;]+\\|[\\]\\([\\][\\]\\)*\&quot;\\)*\&quot;\\)\\)&quot; 1 string)</span>
   <span class="s0">(hilit-string-find ?\\ string)</span>

   <span class="s0">;; this is waaaaaaaay too slow</span>
   <span class="s0">;;   (&quot;^\\s *(def\\(un\\|macro\\|advice\\|alias\\|method\\|subst\\)\\s \\S +[ \t\n]+\\(nil\\|(\\(([^()]*)\\|[^()]+\\)*)\\)&quot; nil defun)</span>
   <span class="s0">(&quot;^\\s *(def\\(un\\|macro\\|advice\\|subst\\|method\\)\\s &quot; &quot;\\()\\|nil\\)&quot; defun)</span>

   <span class="s0">(&quot;^\\s *(\\(def\\(var\\|type\\|parameter\\)\\|declare\\)\\s +\\S +&quot; nil decl)</span>
   <span class="s0">(&quot;^\\s *(def\\(const\\(ant\\)?\\|class\\|struct\\)\\s \\S +[ \t\n]+&quot; nil define)</span>
   <span class="s0">(&quot;^\\s *(\\(provide\\|require\\|\\(auto\\)?load\\).*$&quot; nil include)</span>
   <span class="s0">(&quot;[ \t]\\&amp;\\(key\\|rest\\|optional\\|aux\\)\\s *&quot; nil keyword)</span>
   <span class="s0">(&quot;(\\(let\\*?\\|locally\\|cond\\|if\\*?\\|or\\|and\\|map\\(car\\|c[ao]n\\)?\\|prog[nv1*]?\\|while\\|when\\|unless\\|do\\(\\*\\|list\\|times\\)\\|list\\|lambda\\|function\\|values\\|set\\([qf]\\|car\\|cdr\\)?\\|rplac[ad]\\|nconc\\|block\\|go\\|return\\(-from\\)?\\|[ec]?\\(type\\)?case\\|multiple-value-\\(bind\\|setq\\|list\\|call\\|prog1\\)\\|unwind-protect\\|handler-case\\|catch\\|throw\\|eval-when\\(-compile\\)?\\)[ \t\n]&quot; 1 keyword)</span>
   <span class="s0">))</span>


<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'plain-tex-mode</span>
 <span class="s0">'((&quot;^%%.*$&quot; nil comment)</span>
   <span class="s0">(&quot;{\\\\em\\([^}]+\\)}&quot; nil comment)</span>
   <span class="s0">(&quot;\\(\\\\\\w+\\)&quot; nil keyword)</span>
   <span class="s0">(&quot;{\\\\bf\\([^}]+\\)}&quot; nil keyword)</span>
   <span class="s0">(&quot;^[ \t\n]*\\\\def[\\\\@]\\(\\w+\\)&quot; nil defun)</span>
   <span class="s0">(&quot;\\\\\\(begin\\|end\\){\\([A-Za-z0-9\\*]+\\)}&quot; nil defun)</span>
   <span class="s0">;; (&quot;[^\\\\]\\$\\([^$]*\\)\\$&quot; nil string)</span>
   <span class="s0">(&quot;\\$\\([^$]*\\)\\$&quot; nil string)</span>
   <span class="s0">))</span>

<span class="s0">;; Reasonable extensions would include smarter parameter handling for such</span>
<span class="s0">;; things as the .IX and .I macros, which alternate the handling of following</span>
<span class="s0">;; arguments.</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'nroff-mode</span>
 <span class="s0">'((&quot;^\\.[\\\][\\\&quot;].*$&quot; nil comment)</span>
   <span class="s0">(&quot;^\\.so .*$&quot; nil include)</span>
   <span class="s0">(&quot;^\\.[ST]H.*$&quot; nil defun)</span>
<span class="s0">;;   (&quot;^[^\\.].*\&quot;[^\\\&quot;]*\\(\\\\\\(.\\)[^\\\&quot;]*\\)*\&quot;&quot; nil string)</span>
   <span class="s0">(&quot;\&quot;&quot; &quot;[^\\]\&quot;&quot; string)</span>
   <span class="s0">(&quot;^\\.[A-Z12\\\\].*$&quot; nil define)</span>
   <span class="s0">(&quot;\\([\\\][^ ]*\\)&quot; nil keyword)</span>
   <span class="s0">(&quot;^\\.[A-Z].*$&quot; nil keyword))</span>
 <span class="s0">nil 'case-insensitive)</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'texinfo-mode</span>
 <span class="s0">'((&quot;^\\(@c\\|@comment\\)\\&gt;.*$&quot; nil comment)</span>
   <span class="s0">(&quot;@\\(emph\\|strong\\|b\\|i\\){[^}]+}&quot; nil comment)</span>
<span class="s0">;; seems broken</span>
<span class="s0">;; (&quot;\\$[^$]*\\$&quot; nil string)</span>
   <span class="s0">(&quot;@\\(file\\|kbd\\|key\\){[^}]+}&quot; nil string)</span>
   <span class="s0">(&quot;^\\*.*$&quot; nil defun)</span>
   <span class="s0">(&quot;@\\(if\\w+\\|format\\|item\\)\\b.*$&quot; nil defun)</span>
   <span class="s0">(&quot;@end +[A-Za-z0-9]+[ \t]*$&quot; nil defun)</span>
   <span class="s0">(&quot;@\\(samp\\|code\\|var\\){[^}]+}&quot; nil defun)</span>
   <span class="s0">(&quot;@\\w+\\({[^}]+}\\)?&quot; nil keyword)</span>
   <span class="s0">))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'dired-mode</span>
 <span class="s0">(append</span>
  <span class="s0">'((&quot;^D.*$&quot;  nil dired-deleted)</span>
   <span class="s0">(&quot;^\\*.*$&quot; nil dired-marked)</span>
   <span class="s0">(&quot;^  d.*$&quot; nil dired-directory)</span>
   <span class="s0">(&quot;^  l.*$&quot; nil dired-link)</span>
   <span class="s0">(&quot;^  -.*#.*#$&quot; nil dired-ignored))</span>
  <span class="s0">(list (cons</span>
	 <span class="s0">(concat &quot;^  .*\\(&quot;</span>
		 <span class="s0">(mapconcat 'regexp-quote completion-ignored-extensions &quot;\\|&quot;)</span>
		 <span class="s0">&quot;\\)$&quot;)</span>
	 <span class="s0">'(nil dired-ignored)))))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'jargon-mode</span>
 <span class="s0">'((&quot;^:[^:]*:&quot; nil jargon-entry)</span>
   <span class="s0">(&quot;{[^}]*}+&quot; nil jargon-xref)))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'Info-mode</span>
 <span class="s0">'((&quot;^\\* [^:]+:+&quot; nil jargon-entry)</span>
   <span class="s0">(&quot;\\*[Nn]ote\\b[^:]+:+&quot; nil jargon-xref)</span>
   <span class="s0">(&quot;  \\(Next\\|Prev\\|Up\\):&quot; nil jargon-xref)</span>
   <span class="s0">(&quot;- \\(Variable\\|Function\\|Macro\\|Command\\|Special Form\\|User Option\\):.*$&quot;</span>
    <span class="s0">nil jargon-keyword)))	; lisp manual</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'calendar-mode</span>
 <span class="s0">'((&quot;[A-Z][a-z]+ [0-9]+&quot; nil define)	; month and year</span>
   <span class="s0">(&quot;S  M Tu  W Th  F  S&quot; nil label)))	; week days</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'asm-mode</span>
 <span class="s0">'((&quot;/\\*&quot; &quot;\\*/&quot; comment)</span>
   <span class="s0">(&quot;^#[ \t]*\\(undef\\|define\\).*$&quot; &quot;[^\\]$&quot; define)</span>
   <span class="s0">(&quot;^#.*$&quot; nil include)</span>
   <span class="s0">;; labels</span>
   <span class="s0">(&quot;^.+:&quot; nil defun)</span>
   <span class="s0">;; assembler directives</span>
   <span class="s0">(&quot;^[ \t]*\\..*$&quot; nil decl)</span>
   <span class="s0">;; register names</span>
   <span class="s0">(&quot;\\$[a-z0-9]+&quot; nil string)</span>
   <span class="s0">;; mnemonics</span>
   <span class="s0">(&quot;^[ \t]*[a-z]+&quot; nil struct)))</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'pascal-mode</span>
 <span class="s0">'((&quot;(\\*&quot; &quot;\\*)&quot; comment)</span>
   <span class="s0">(&quot;{&quot; &quot;}&quot; comment)</span>
   <span class="s0">;; Doesn't work when there are strings in comments....</span>
   <span class="s0">;; (&quot;'[^']*'&quot; nil string)</span>
   <span class="s0">(&quot;^#.*$&quot; nil include)</span>
   <span class="s0">(&quot;^[ \t]*\\(procedure\\|function\\)[ \t]+\\w+[^ \t(;]*&quot; nil defun)</span>
   <span class="s0">(&quot;\\&lt;\\(program\\|begin\\|end\\)\\&gt;&quot; nil defun)</span>
   <span class="s0">(&quot;\\&lt;\\(external\\|forward\\)\\&gt;&quot; nil include)</span>
   <span class="s0">(&quot;\\&lt;\\(label\\|const\\|type\\|var\\)\\&gt;&quot; nil define)</span>
   <span class="s0">(&quot;\\&lt;\\(record\\|array\\|file\\)\\&gt;&quot; nil type)</span>
   <span class="s0">(&quot;\\&lt;\\(of\\|to\\|for\\|if\\|then\\|else\\|case\\|while\\|do\\|until\\|and\\|or\\|not\\|with\\|repeat\\)\\&gt;&quot; nil keyword)</span>
   <span class="s0">)</span>
 <span class="s0">nil 'case-insensitive)</span>

<span class="s0">(hilit-set-mode-patterns</span>
 <span class="s0">'icon-mode</span>
 <span class="s0">'((&quot;#.*$&quot; nil comment)</span>
   <span class="s0">(&quot;\&quot;[^\\\&quot;]*\\(\\\\.[^\\\&quot;]*\\)*\&quot;&quot; nil string)</span>
   <span class="s0">;; charsets: these do not work because of a conflict with strings</span>
   <span class="s0">;; (&quot;'[^\\']*\\(\\\\.[^\\']*\\)*'&quot; nil string)</span>
   <span class="s0">(&quot;^[ \t]*procedure[ \t]+\\w+[ \t]*(&quot; &quot;)&quot; defun)</span>
   <span class="s0">(&quot;^[ \t]*record.*(&quot; &quot;)&quot; include)</span>
   <span class="s0">(&quot;^[ \t]*\\(global\\|link\\)[ \t\n]+[A-Za-z_0-9]+\\([ \t\n]*,[ \t\n]*[A-Za-z_0-9]+\\)*&quot; nil include)</span>
   <span class="s0">(&quot;^[ \t]*\\(local\\|static\\)[ \t\n]+[A-Za-z_0-9]+\\([ \t\n]*,[ \t\n]*[A-Za-z_0-9]+\\)*&quot; nil decl)</span>
   <span class="s0">(&quot;\\&lt;\\(initial\\|end\\)\\&gt;&quot; nil glob-struct)</span>
   <span class="s0">(&quot;\\&lt;\\(while\\|until\\|return\\|every\\|if\\|then\\|else\\|to\\|case\\|of\\|suspend\\|create\\|do\\|repeat\\|break\\)\\&gt;&quot; nil keyword)</span>
   <span class="s0">))</span>

<span class="s0">;; as you can see, I had two similar problems for Pascal and Icon. In</span>
<span class="s0">;; Pascal, strings are delimited with ' and an embedded quote is doubled,</span>
<span class="s0">;; thus string syntax would be extremely simple. However, if a string</span>
<span class="s0">;; occurs within a comment, the following text is considered a string.</span>
<span class="s0">;;</span>
<span class="s0">;; In Icon, strings are similar to C ones, but there are also charsets,</span>
<span class="s0">;; delimited with simple quotes. I could not manage to use both regexps at</span>
<span class="s0">;; the same time.</span>

<span class="s0">;; The problem I have with my patterns for Icon is that this language has a</span>
<span class="s0">;; string similar constant to the C one (but a string can be cut on several</span>
<span class="s0">;; lines, if terminated by a dash and continued with initial blanks, like</span>
<span class="s0">;; this:</span>
<span class="s0">;;         &quot;This is a somewhat long -</span>
<span class="s0">;;          string, written on three -</span>
<span class="s0">;;          successive lines&quot;</span>
<span class="s0">;; in order to insert a double quote in a string, you have to escape it</span>
<span class="s0">;; with a \), bu also a character set constant (named a charset), which</span>
<span class="s0">;; uses single quotes instead of double ones. It would seem intuitive to</span>
<span class="s0">;; highlight both constants in the same way.</span>


<span class="s0">(provide 'hilit19)</span>

<span class="s0">;; arch-tag: db99739a-4837-41ee-ad02-3baced8ae71d</span>
<span class="s0">;;; hilit19.el ends here</span>
</pre>
</body>
</html>