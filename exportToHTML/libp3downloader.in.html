<html>
<head>
<title>libp3downloader.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3downloader.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">15 libp3downloader 4 _Rn_ 12 panda3d.core </span>
<span class="s0">393</span>
<span class="s0">399 9 ~SSReader 0 518 792 19 SSReader::~SSReader 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">virtual SSReader::~SSReader(void);</span>

<span class="s0">400 16 receive_datagram 0 4 792 26 SSReader::receive_datagram 0 1 1 253</span>
<span class="s0">/**</span>
 <span class="s0">* Receives a datagram over the socket by expecting a little-endian 16-bit</span>
 <span class="s0">* byte count as a prefix.  If the socket stream is non-blocking, may return</span>
 <span class="s0">* false if the data is not available; otherwise, returns false only if the</span>
 <span class="s0">* socket closes.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool SSReader::receive_datagram(Datagram &amp;dg);</span>

<span class="s0">401 9 is_closed 0 6 792 19 SSReader::is_closed 0 1 2 0</span>
<span class="s0">43</span>
<span class="s0">virtual bool SSReader::is_closed(void) = 0;</span>

<span class="s0">402 5 close 0 6 792 15 SSReader::close 0 1 3 0</span>
<span class="s0">39</span>
<span class="s0">virtual void SSReader::close(void) = 0;</span>

<span class="s0">403 19 set_tcp_header_size 0 4 792 29 SSReader::set_tcp_header_size 0 1 4 269</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the header size for datagrams.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void SSReader::set_tcp_header_size(int tcp_header_size);</span>

<span class="s0">404 19 get_tcp_header_size 0 4 792 29 SSReader::get_tcp_header_size 0 1 5 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the header size for datagrams.  See set_tcp_header_size().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int SSReader::get_tcp_header_size(void) const;</span>

<span class="s0">405 9 ~SSWriter 0 518 793 19 SSWriter::~SSWriter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">virtual SSWriter::~SSWriter(void);</span>

<span class="s0">406 13 send_datagram 0 4 793 23 SSWriter::send_datagram 0 1 6 234</span>
<span class="s0">/**</span>
 <span class="s0">* Transmits the indicated datagram over the socket by prepending it with a</span>
 <span class="s0">* little-endian 16-bit byte count.  Does not return until the data is sent or</span>
 <span class="s0">* the connection is closed, even if the socket stream is non-blocking.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">bool SSWriter::send_datagram(Datagram const &amp;dg);</span>

<span class="s0">407 9 is_closed 0 6 793 19 SSWriter::is_closed 0 1 7 0</span>
<span class="s0">43</span>
<span class="s0">virtual bool SSWriter::is_closed(void) = 0;</span>

<span class="s0">408 5 close 0 6 793 15 SSWriter::close 0 1 8 0</span>
<span class="s0">39</span>
<span class="s0">virtual void SSWriter::close(void) = 0;</span>

<span class="s0">409 15 set_collect_tcp 0 4 793 25 SSWriter::set_collect_tcp 0 1 9 719</span>
<span class="s0">/**</span>
 <span class="s0">* Enables or disables &quot;collect-tcp&quot; mode.  In this mode, individual TCP</span>
 <span class="s0">* packets are not sent immediately, but rather they are collected together</span>
 <span class="s0">* and accumulated to be sent periodically as one larger TCP packet.  This</span>
 <span class="s0">* cuts down on overhead from the TCP/IP protocol, especially if many small</span>
 <span class="s0">* packets need to be sent on the same connection, but it introduces</span>
 <span class="s0">* additional latency (since packets must be held before they can be sent).</span>
 <span class="s0">*</span>
 <span class="s0">* See set_collect_tcp_interval() to specify the interval of time for which to</span>
 <span class="s0">* hold packets before sending them.</span>
 <span class="s0">*</span>
 <span class="s0">* If you enable this mode, you may also need to periodically call</span>
 <span class="s0">* consider_flush() to flush the queue if no packets have been sent recently.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void SSWriter::set_collect_tcp(bool collect_tcp);</span>

<span class="s0">410 15 get_collect_tcp 0 4 793 25 SSWriter::get_collect_tcp 0 1 10 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of &quot;collect-tcp&quot; mode.  See set_collect_tcp().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool SSWriter::get_collect_tcp(void) const;</span>

<span class="s0">411 24 set_collect_tcp_interval 0 4 793 34 SSWriter::set_collect_tcp_interval 0 1 11 231</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the interval in time, in seconds, for which to hold TCP packets</span>
 <span class="s0">* before sending all of the recently received packets at once.  This only has</span>
 <span class="s0">* meaning if &quot;collect-tcp&quot; mode is enabled; see set_collect_tcp().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void SSWriter::set_collect_tcp_interval(double interval);</span>

<span class="s0">412 24 get_collect_tcp_interval 0 4 793 34 SSWriter::get_collect_tcp_interval 0 1 12 229</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the interval in time, in seconds, for which to hold TCP packets</span>
 <span class="s0">* before sending all of the recently received packets at once.  This only has</span>
 <span class="s0">* meaning if &quot;collect-tcp&quot; mode is enabled; see set_collect_tcp().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline double SSWriter::get_collect_tcp_interval(void) const;</span>

<span class="s0">413 19 set_tcp_header_size 0 4 793 29 SSWriter::set_tcp_header_size 0 1 13 269</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the header size for datagrams.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void SSWriter::set_tcp_header_size(int tcp_header_size);</span>

<span class="s0">414 19 get_tcp_header_size 0 4 793 29 SSWriter::get_tcp_header_size 0 1 14 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the header size for datagrams.  See set_tcp_header_size().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int SSWriter::get_tcp_header_size(void) const;</span>

<span class="s0">415 14 consider_flush 0 4 793 24 SSWriter::consider_flush 0 1 15 143</span>
<span class="s0">/**</span>
 <span class="s0">* Sends the most recently queued data if enough time has elapsed.  This only</span>
 <span class="s0">* has meaning if set_collect_tcp() has been set to true.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool SSWriter::consider_flush(void);</span>

<span class="s0">416 5 flush 0 4 793 15 SSWriter::flush 0 1 16 120</span>
<span class="s0">/**</span>
 <span class="s0">* Sends the most recently queued data now.  This only has meaning if</span>
 <span class="s0">* set_collect_tcp() has been set to true.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">inline bool SSWriter::flush(void);</span>

<span class="s0">417 17 upcast_to_istream 0 12 794 32 ISocketStream::upcast_to_istream 0 1 20 36</span>
<span class="s0">upcast from ISocketStream to istream</span>
<span class="s0">53</span>
<span class="s0">std::istream *ISocketStream::upcast_to_istream(void);</span>

<span class="s0">418 25 downcast_to_ISocketStream 0 12 795 39 std::istream::downcast_to_ISocketStream 0 0 38</span>
<span class="s0">downcast from istream to ISocketStream</span>
<span class="s0">61</span>
<span class="s0">ISocketStream *std::istream::downcast_to_ISocketStream(void);</span>

<span class="s0">419 18 upcast_to_SSReader 0 12 794 33 ISocketStream::upcast_to_SSReader 0 1 21 37</span>
<span class="s0">upcast from ISocketStream to SSReader</span>
<span class="s0">50</span>
<span class="s0">SSReader *ISocketStream::upcast_to_SSReader(void);</span>

<span class="s0">420 25 downcast_to_ISocketStream 0 12 792 35 SSReader::downcast_to_ISocketStream 0 0 39</span>
<span class="s0">downcast from SSReader to ISocketStream</span>
<span class="s0">57</span>
<span class="s0">ISocketStream *SSReader::downcast_to_ISocketStream(void);</span>

<span class="s0">421 14 ~ISocketStream 0 518 794 29 ISocketStream::~ISocketStream 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual ISocketStream::~ISocketStream(void);</span>

<span class="s0">422 9 is_closed 0 6 794 24 ISocketStream::is_closed 0 1 17 0</span>
<span class="s0">48</span>
<span class="s0">virtual bool ISocketStream::is_closed(void) = 0;</span>

<span class="s0">423 5 close 0 6 794 20 ISocketStream::close 0 1 18 0</span>
<span class="s0">44</span>
<span class="s0">virtual void ISocketStream::close(void) = 0;</span>

<span class="s0">424 14 get_read_state 0 6 794 29 ISocketStream::get_read_state 0 1 19 0</span>
<span class="s0">73</span>
<span class="s0">virtual ISocketStream::ReadState ISocketStream::get_read_state(void) = 0;</span>

<span class="s0">425 17 upcast_to_ostream 0 12 797 32 OSocketStream::upcast_to_ostream 0 1 25 36</span>
<span class="s0">upcast from OSocketStream to ostream</span>
<span class="s0">53</span>
<span class="s0">std::ostream *OSocketStream::upcast_to_ostream(void);</span>

<span class="s0">426 25 downcast_to_OSocketStream 0 12 798 39 std::ostream::downcast_to_OSocketStream 0 0 38</span>
<span class="s0">downcast from ostream to OSocketStream</span>
<span class="s0">61</span>
<span class="s0">OSocketStream *std::ostream::downcast_to_OSocketStream(void);</span>

<span class="s0">427 18 upcast_to_SSWriter 0 12 797 33 OSocketStream::upcast_to_SSWriter 0 1 26 37</span>
<span class="s0">upcast from OSocketStream to SSWriter</span>
<span class="s0">50</span>
<span class="s0">SSWriter *OSocketStream::upcast_to_SSWriter(void);</span>

<span class="s0">428 25 downcast_to_OSocketStream 0 12 793 35 SSWriter::downcast_to_OSocketStream 0 0 39</span>
<span class="s0">downcast from SSWriter to OSocketStream</span>
<span class="s0">57</span>
<span class="s0">OSocketStream *SSWriter::downcast_to_OSocketStream(void);</span>

<span class="s0">429 9 is_closed 0 6 797 24 OSocketStream::is_closed 0 1 22 0</span>
<span class="s0">48</span>
<span class="s0">virtual bool OSocketStream::is_closed(void) = 0;</span>

<span class="s0">430 5 close 0 6 797 20 OSocketStream::close 0 1 23 0</span>
<span class="s0">44</span>
<span class="s0">virtual void OSocketStream::close(void) = 0;</span>

<span class="s0">431 5 flush 0 4 797 20 OSocketStream::flush 0 1 24 120</span>
<span class="s0">/**</span>
 <span class="s0">* Sends the most recently queued data now.  This only has meaning if</span>
 <span class="s0">* set_collect_tcp() has been set to true.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline bool OSocketStream::flush(void);</span>

<span class="s0">432 14 ~OSocketStream 0 516 797 29 OSocketStream::~OSocketStream 0 0 0</span>
<span class="s0">36</span>
<span class="s0">OSocketStream::~OSocketStream(void);</span>

<span class="s0">433 18 upcast_to_iostream 0 12 799 32 SocketStream::upcast_to_iostream 0 1 32 36</span>
<span class="s0">upcast from SocketStream to iostream</span>
<span class="s0">54</span>
<span class="s0">std::iostream *SocketStream::upcast_to_iostream(void);</span>

<span class="s0">434 24 downcast_to_SocketStream 0 12 800 39 std::iostream::downcast_to_SocketStream 0 0 38</span>
<span class="s0">downcast from iostream to SocketStream</span>
<span class="s0">60</span>
<span class="s0">SocketStream *std::iostream::downcast_to_SocketStream(void);</span>

<span class="s0">435 18 upcast_to_SSReader 0 12 799 32 SocketStream::upcast_to_SSReader 0 1 33 36</span>
<span class="s0">upcast from SocketStream to SSReader</span>
<span class="s0">49</span>
<span class="s0">SSReader *SocketStream::upcast_to_SSReader(void);</span>

<span class="s0">436 24 downcast_to_SocketStream 0 12 792 34 SSReader::downcast_to_SocketStream 0 0 38</span>
<span class="s0">downcast from SSReader to SocketStream</span>
<span class="s0">55</span>
<span class="s0">SocketStream *SSReader::downcast_to_SocketStream(void);</span>

<span class="s0">437 18 upcast_to_SSWriter 0 12 799 32 SocketStream::upcast_to_SSWriter 0 1 34 36</span>
<span class="s0">upcast from SocketStream to SSWriter</span>
<span class="s0">49</span>
<span class="s0">SSWriter *SocketStream::upcast_to_SSWriter(void);</span>

<span class="s0">438 24 downcast_to_SocketStream 0 12 793 34 SSWriter::downcast_to_SocketStream 0 0 38</span>
<span class="s0">downcast from SSWriter to SocketStream</span>
<span class="s0">55</span>
<span class="s0">SocketStream *SSWriter::downcast_to_SocketStream(void);</span>

<span class="s0">439 9 is_closed 0 6 799 23 SocketStream::is_closed 0 1 27 0</span>
<span class="s0">47</span>
<span class="s0">virtual bool SocketStream::is_closed(void) = 0;</span>

<span class="s0">440 5 close 0 6 799 19 SocketStream::close 0 1 28 0</span>
<span class="s0">43</span>
<span class="s0">virtual void SocketStream::close(void) = 0;</span>

<span class="s0">441 19 set_tcp_header_size 0 4 799 33 SocketStream::set_tcp_header_size 0 1 29 269</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the header size for datagrams.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void SocketStream::set_tcp_header_size(int tcp_header_size);</span>

<span class="s0">442 19 get_tcp_header_size 0 4 799 33 SocketStream::get_tcp_header_size 0 1 30 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the header size for datagrams.  See set_tcp_header_size().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int SocketStream::get_tcp_header_size(void) const;</span>

<span class="s0">443 5 flush 0 4 799 19 SocketStream::flush 0 1 31 120</span>
<span class="s0">/**</span>
 <span class="s0">* Sends the most recently queued data now.  This only has meaning if</span>
 <span class="s0">* set_collect_tcp() has been set to true.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline bool SocketStream::flush(void);</span>

<span class="s0">444 13 ~SocketStream 0 516 799 27 SocketStream::~SocketStream 0 0 0</span>
<span class="s0">34</span>
<span class="s0">SocketStream::~SocketStream(void);</span>

<span class="s0">445 7 URLSpec 0 260 801 16 URLSpec::URLSpec 0 4 35 36 37 38 159</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a URLSpec by appending a path to the end of the old URLSpec,</span>
 <span class="s0">* inserting an intervening forward slash if necessary.</span>
 <span class="s0">*/</span>
<span class="s0">219</span>
<span class="s0">URLSpec::URLSpec(void);</span>
<span class="s0">inline URLSpec::URLSpec(std::string const &amp;url, bool server_name_expected = false);</span>
<span class="s0">URLSpec::URLSpec(URLSpec const &amp;url, Filename const &amp;path);</span>
<span class="s0">inline URLSpec::URLSpec(URLSpec const &amp;) = default;</span>

<span class="s0">446 10 operator = 0 4 801 19 URLSpec::operator = 0 1 39 0</span>
<span class="s0">56</span>
<span class="s0">inline void URLSpec::operator =(std::string const &amp;url);</span>

<span class="s0">447 11 operator == 0 4 801 20 URLSpec::operator == 0 1 40 0</span>
<span class="s0">61</span>
<span class="s0">inline bool URLSpec::operator ==(URLSpec const &amp;other) const;</span>

<span class="s0">448 11 operator != 0 4 801 20 URLSpec::operator != 0 1 41 0</span>
<span class="s0">61</span>
<span class="s0">inline bool URLSpec::operator !=(URLSpec const &amp;other) const;</span>

<span class="s0">449 10 operator &lt; 0 4 801 19 URLSpec::operator &lt; 0 1 42 0</span>
<span class="s0">60</span>
<span class="s0">inline bool URLSpec::operator &lt;(URLSpec const &amp;other) const;</span>

<span class="s0">450 10 compare_to 0 4 801 19 URLSpec::compare_to 0 1 43 158</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this URLSpec sorts before the other one,</span>
 <span class="s0">* greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">int URLSpec::compare_to(URLSpec const &amp;other) const;</span>

<span class="s0">451 8 get_hash 0 4 801 17 URLSpec::get_hash 0 1 44 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">std::size_t URLSpec::get_hash(void) const;</span>

<span class="s0">452 10 has_scheme 0 4 801 19 URLSpec::has_scheme 0 1 45 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the URL specifies a scheme (e.g.  &quot;http:&quot;), false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool URLSpec::has_scheme(void) const;</span>

<span class="s0">453 13 has_authority 0 4 801 22 URLSpec::has_authority 0 1 46 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the URL specifies an authority (this includes username,</span>
 <span class="s0">* server, and/or port), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool URLSpec::has_authority(void) const;</span>

<span class="s0">454 12 has_username 0 4 801 21 URLSpec::has_username 0 1 47 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the URL specifies a username (and/or password), false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool URLSpec::has_username(void) const;</span>

<span class="s0">455 10 has_server 0 4 801 19 URLSpec::has_server 0 1 48 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the URL specifies a server name, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool URLSpec::has_server(void) const;</span>

<span class="s0">456 8 has_port 0 4 801 17 URLSpec::has_port 0 1 49 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the URL specifies a port number, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool URLSpec::has_port(void) const;</span>

<span class="s0">457 8 has_path 0 4 801 17 URLSpec::has_path 0 1 50 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the URL includes a path specification (that is, the</span>
 <span class="s0">* particular filename on the server to retrieve), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool URLSpec::has_path(void) const;</span>

<span class="s0">458 9 has_query 0 4 801 18 URLSpec::has_query 0 1 51 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the URL includes a query specification, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool URLSpec::has_query(void) const;</span>

<span class="s0">459 10 get_scheme 0 4 801 19 URLSpec::get_scheme 0 1 52 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scheme specified by the URL, or empty string if no scheme is</span>
 <span class="s0">* specified.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">std::string URLSpec::get_scheme(void) const;</span>

<span class="s0">460 13 get_authority 0 4 801 22 URLSpec::get_authority 0 1 53 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the authority specified by the URL (this includes username, server,</span>
 <span class="s0">* and/or port), or empty string if no authority is specified.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline std::string URLSpec::get_authority(void) const;</span>

<span class="s0">461 12 get_username 0 4 801 21 URLSpec::get_username 0 1 54 194</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the username specified by the URL, if any.  This might also include</span>
 <span class="s0">* a password, e.g.  &quot;username:password&quot;, although putting a password on the</span>
 <span class="s0">* URL is probably a bad idea.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::string URLSpec::get_username(void) const;</span>

<span class="s0">462 10 get_server 0 4 801 19 URLSpec::get_server 0 1 55 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the server name specified by the URL, if any.  In case of an IPv6</span>
 <span class="s0">* address, does not include the enclosing brackets.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline std::string URLSpec::get_server(void) const;</span>

<span class="s0">463 12 get_port_str 0 4 801 21 URLSpec::get_port_str 0 1 56 204</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the port specified by the URL as a string, or the empty string if</span>
 <span class="s0">* no port is specified.  Compare this with get_port(), which returns a</span>
 <span class="s0">* default port number if no port is specified.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::string URLSpec::get_port_str(void) const;</span>

<span class="s0">464 8 get_port 0 4 801 17 URLSpec::get_port 0 1 57 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the port number specified by the URL, or the default port if not</span>
 <span class="s0">* specified.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">uint16_t URLSpec::get_port(void) const;</span>

<span class="s0">465 19 get_server_and_port 0 4 801 28 URLSpec::get_server_and_port 0 1 58 298</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string consisting of the server name, followed by a colon,</span>
 <span class="s0">* followed by the port number.  If the port number is not explicitly given in</span>
 <span class="s0">* the URL, this string will include the implicit port number.</span>
 <span class="s0">* If the server is an IPv6 address, it will be enclosed in square brackets.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">std::string URLSpec::get_server_and_port(void) const;</span>

<span class="s0">466 15 is_default_port 0 4 801 24 URLSpec::is_default_port 0 1 59 181</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the port number encoded in this URL is the default port</span>
 <span class="s0">* number for the scheme (or if there is no port number), or false if it is a</span>
 <span class="s0">* nonstandard port.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">bool URLSpec::is_default_port(void) const;</span>

<span class="s0">467 27 get_default_port_for_scheme 0 4 801 36 URLSpec::get_default_port_for_scheme 0 1 60 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default port number for the indicated scheme, or 0 if there is</span>
 <span class="s0">* no known default.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static int URLSpec::get_default_port_for_scheme(std::string const &amp;scheme);</span>

<span class="s0">468 8 get_path 0 4 801 17 URLSpec::get_path 0 1 61 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the path specified by the URL, or &quot;/&quot; if no path is specified.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">std::string URLSpec::get_path(void) const;</span>

<span class="s0">469 9 get_query 0 4 801 18 URLSpec::get_query 0 1 62 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the query specified by the URL, or empty string if no query is</span>
 <span class="s0">* specified.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline std::string URLSpec::get_query(void) const;</span>

<span class="s0">470 18 get_path_and_query 0 4 801 27 URLSpec::get_path_and_query 0 1 63 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the path (or &quot;/&quot; if no path is specified), followed by the query if</span>
 <span class="s0">* it is specified.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">std::string URLSpec::get_path_and_query(void) const;</span>

<span class="s0">471 6 is_ssl 0 4 801 15 URLSpec::is_ssl 0 1 64 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the URL's scheme specifies an SSL-secured protocol such as</span>
 <span class="s0">* https, or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool URLSpec::is_ssl(void) const;</span>

<span class="s0">472 7 get_url 0 4 801 16 URLSpec::get_url 0 1 65 50</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete URL specification.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline std::string const &amp;URLSpec::get_url(void) const;</span>

<span class="s0">473 10 set_scheme 0 4 801 19 URLSpec::set_scheme 0 1 66 61</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the scheme part of the URL specification.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void URLSpec::set_scheme(std::string const &amp;scheme);</span>

<span class="s0">474 13 set_authority 0 4 801 22 URLSpec::set_authority 0 1 67 114</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the authority part of the URL specification.  This includes the</span>
 <span class="s0">* username, server, and port.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void URLSpec::set_authority(std::string const &amp;authority);</span>

<span class="s0">475 12 set_username 0 4 801 21 URLSpec::set_username 0 1 68 63</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the username part of the URL specification.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void URLSpec::set_username(std::string const &amp;username);</span>

<span class="s0">476 10 set_server 0 4 801 19 URLSpec::set_server 0 1 69 174</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the server part of the URL specification.</span>
 <span class="s0">* Unlike set_server_and_port, this method does not require IPv6 addresses to</span>
 <span class="s0">* be enclosed in square brackets.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void URLSpec::set_server(std::string const &amp;server);</span>

<span class="s0">477 8 set_port 0 4 801 17 URLSpec::set_port 0 2 70 71 152</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the port part of the URL specification.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the port part of the URL specification, given a numeric port</span>
 <span class="s0">* number.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">void URLSpec::set_port(std::string const &amp;port);</span>
<span class="s0">void URLSpec::set_port(uint16_t port);</span>

<span class="s0">478 19 set_server_and_port 0 4 801 28 URLSpec::set_server_and_port 0 1 72 254</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the server and port parts of the URL specification simultaneously.</span>
 <span class="s0">* The input string should be of the form &quot;server:port&quot;, or just &quot;server&quot; to</span>
 <span class="s0">* make the port number implicit.</span>
 <span class="s0">* Any IPv6 address must be enclosed in square brackets.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void URLSpec::set_server_and_port(std::string const &amp;server_and_port);</span>

<span class="s0">479 8 set_path 0 4 801 17 URLSpec::set_path 0 1 73 59</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the path part of the URL specification.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void URLSpec::set_path(std::string const &amp;path);</span>

<span class="s0">480 9 set_query 0 4 801 18 URLSpec::set_query 0 1 74 60</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the query part of the URL specification.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void URLSpec::set_query(std::string const &amp;query);</span>

<span class="s0">481 7 set_url 0 4 801 16 URLSpec::set_url 0 1 75 191</span>
<span class="s0">/**</span>
 <span class="s0">* Completely replaces the URL with the indicated string.  If</span>
 <span class="s0">* server_name_expected is true, it is a hint that an undecorated URL is</span>
 <span class="s0">* probably a server name, not a local filename.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">void URLSpec::set_url(std::string const &amp;url, bool server_name_expected = false);</span>

<span class="s0">482 17 operator typecast 0 132 801 26 URLSpec::operator typecast 0 1 87 0</span>
<span class="s0">48</span>
<span class="s0">inline operator std::string const &amp;(void) const;</span>

<span class="s0">483 5 c_str 0 4 801 14 URLSpec::c_str 0 1 76 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline char const *URLSpec::c_str(void) const;</span>

<span class="s0">484 5 empty 0 4 801 14 URLSpec::empty 0 1 77 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns false if the URLSpec is valid (not empty), or true if it is an</span>
 <span class="s0">* empty string.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline bool URLSpec::empty(void) const;</span>

<span class="s0">485 22 operator typecast bool 0 132 801 31 URLSpec::operator typecast bool 0 1 88 0</span>
<span class="s0">34</span>
<span class="s0">inline operator bool (void) const;</span>

<span class="s0">486 6 length 0 4 801 15 URLSpec::length 0 1 78 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline std::size_t URLSpec::length(void) const;</span>

<span class="s0">487 4 size 0 4 801 13 URLSpec::size 0 1 79 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline std::size_t URLSpec::size(void) const;</span>

<span class="s0">488 11 operator [] 0 4 801 20 URLSpec::operator [] 0 1 80 0</span>
<span class="s0">54</span>
<span class="s0">inline char URLSpec::operator [](std::size_t n) const;</span>

<span class="s0">489 5 input 0 4 801 14 URLSpec::input 0 1 81 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">bool URLSpec::input(std::istream &amp;in);</span>

<span class="s0">490 6 output 0 4 801 15 URLSpec::output 0 1 82 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void URLSpec::output(std::ostream &amp;out) const;</span>

<span class="s0">491 5 quote 0 4 801 14 URLSpec::quote 0 1 83 313</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the source string with all &quot;unsafe&quot; characters quoted, making a</span>
 <span class="s0">* string suitable for placing in a URL.  Letters, digits, and the underscore,</span>
 <span class="s0">* comma, period, and hyphen characters, as well as any included in the safe</span>
 <span class="s0">* string, are left alone; all others are converted to hex representation.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">static std::string URLSpec::quote(std::string const &amp;source, std::string const &amp;safe = &quot;/&quot;);</span>

<span class="s0">492 10 quote_plus 0 4 801 19 URLSpec::quote_plus 0 1 84 100</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like quote() with the additional behavior of replacing spaces with</span>
 <span class="s0">* plus signs.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">static std::string URLSpec::quote_plus(std::string const &amp;source, std::string const &amp;safe = &quot;/&quot;);</span>

<span class="s0">493 7 unquote 0 4 801 16 URLSpec::unquote 0 1 85 121</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses the operation of quote(): converts escaped characters of the form</span>
 <span class="s0">* &quot;%xx&quot; to their ascii equivalent.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static std::string URLSpec::unquote(std::string const &amp;source);</span>

<span class="s0">494 12 unquote_plus 0 4 801 21 URLSpec::unquote_plus 0 1 86 169</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses the operation of quote_plus(): converts escaped characters of the</span>
 <span class="s0">* form &quot;%xx&quot; to their ascii equivalent, and also converts plus signs to</span>
 <span class="s0">* spaces.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static std::string URLSpec::unquote_plus(std::string const &amp;source);</span>

<span class="s0">495 8 ~URLSpec 0 516 801 17 URLSpec::~URLSpec 0 0 0</span>
<span class="s0">24</span>
<span class="s0">URLSpec::~URLSpec(void);</span>

<span class="s0">496 8 HTTPEnum 0 260 807 18 HTTPEnum::HTTPEnum 0 2 89 90 0</span>
<span class="s0">97</span>
<span class="s0">inline HTTPEnum::HTTPEnum(void) = default;</span>
<span class="s0">inline HTTPEnum::HTTPEnum(HTTPEnum const &amp;) = default;</span>

<span class="s0">497 9 ~HTTPEnum 0 516 807 19 HTTPEnum::~HTTPEnum 0 0 0</span>
<span class="s0">26</span>
<span class="s0">HTTPEnum::~HTTPEnum(void);</span>

<span class="s0">498 8 HTTPDate 0 260 810 18 HTTPDate::HTTPDate 0 4 91 92 93 94 158</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Decodes the string into a sensible date.  Returns 0 (!is_valid()) if the</span>
 <span class="s0">* string cannot be correctly decoded.</span>
 <span class="s0">*/</span>
<span class="s0">168</span>
<span class="s0">inline HTTPDate::HTTPDate(void);</span>
<span class="s0">inline HTTPDate::HTTPDate(time_t time);</span>
<span class="s0">HTTPDate::HTTPDate(std::string const &amp;format);</span>
<span class="s0">inline HTTPDate::HTTPDate(HTTPDate const &amp;copy);</span>

<span class="s0">499 10 operator = 0 4 810 20 HTTPDate::operator = 0 1 95 0</span>
<span class="s0">55</span>
<span class="s0">inline void HTTPDate::operator =(HTTPDate const &amp;copy);</span>

<span class="s0">500 3 now 0 4 810 13 HTTPDate::now 0 1 96 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an HTTPDate that represents the current time and date.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">static inline HTTPDate HTTPDate::now(void);</span>

<span class="s0">501 8 is_valid 0 4 810 18 HTTPDate::is_valid 0 1 97 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the date is meaningful, or false if it is -1 (which</span>
 <span class="s0">* generally indicates the source string could not be parsed.)</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool HTTPDate::is_valid(void) const;</span>

<span class="s0">502 10 get_string 0 4 810 20 HTTPDate::get_string 0 1 98 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">std::string HTTPDate::get_string(void) const;</span>

<span class="s0">503 8 get_time 0 4 810 18 HTTPDate::get_time 0 1 99 48</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the date as a C time_t value.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline time_t HTTPDate::get_time(void) const;</span>

<span class="s0">504 11 operator == 0 4 810 21 HTTPDate::operator == 0 1 100 0</span>
<span class="s0">63</span>
<span class="s0">inline bool HTTPDate::operator ==(HTTPDate const &amp;other) const;</span>

<span class="s0">505 11 operator != 0 4 810 21 HTTPDate::operator != 0 1 101 0</span>
<span class="s0">63</span>
<span class="s0">inline bool HTTPDate::operator !=(HTTPDate const &amp;other) const;</span>

<span class="s0">506 10 operator &lt; 0 4 810 20 HTTPDate::operator &lt; 0 1 102 0</span>
<span class="s0">62</span>
<span class="s0">inline bool HTTPDate::operator &lt;(HTTPDate const &amp;other) const;</span>

<span class="s0">507 10 operator &gt; 0 4 810 20 HTTPDate::operator &gt; 0 1 103 0</span>
<span class="s0">62</span>
<span class="s0">inline bool HTTPDate::operator &gt;(HTTPDate const &amp;other) const;</span>

<span class="s0">508 10 compare_to 0 4 810 20 HTTPDate::compare_to 0 1 104 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this HTTPDate sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int HTTPDate::compare_to(HTTPDate const &amp;other) const;</span>

<span class="s0">509 11 operator += 0 4 810 21 HTTPDate::operator += 0 1 105 0</span>
<span class="s0">47</span>
<span class="s0">inline void HTTPDate::operator +=(int seconds);</span>

<span class="s0">510 11 operator -= 0 4 810 21 HTTPDate::operator -= 0 1 106 0</span>
<span class="s0">47</span>
<span class="s0">inline void HTTPDate::operator -=(int seconds);</span>

<span class="s0">511 10 operator + 0 4 810 20 HTTPDate::operator + 0 1 107 0</span>
<span class="s0">56</span>
<span class="s0">inline HTTPDate HTTPDate::operator +(int seconds) const;</span>

<span class="s0">512 10 operator - 0 4 810 20 HTTPDate::operator - 0 2 108 109 0</span>
<span class="s0">118</span>
<span class="s0">inline HTTPDate HTTPDate::operator -(int seconds) const;</span>
<span class="s0">inline int HTTPDate::operator -(HTTPDate const &amp;other) const;</span>

<span class="s0">513 5 input 0 4 810 15 HTTPDate::input 0 1 110 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">bool HTTPDate::input(std::istream &amp;in);</span>

<span class="s0">514 6 output 0 4 810 16 HTTPDate::output 0 1 111 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void HTTPDate::output(std::ostream &amp;out) const;</span>

<span class="s0">515 9 ~HTTPDate 0 516 810 19 HTTPDate::~HTTPDate 0 0 0</span>
<span class="s0">26</span>
<span class="s0">HTTPDate::~HTTPDate(void);</span>

<span class="s0">516 10 HTTPCookie 0 260 811 22 HTTPCookie::HTTPCookie 0 4 112 113 114 115 418</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an empty cookie.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a cookie according to the indicated string, presumably the tag</span>
 <span class="s0">* of a Set-Cookie header.  There is no way to detect a formatting error in</span>
 <span class="s0">* the string with this constructor.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a cookie with the indicated name, path, and domain values, but</span>
 <span class="s0">* no other data.  This is most useful for looking up an existing cookie in</span>
 <span class="s0">* the HTTPClient.</span>
 <span class="s0">*/</span>
<span class="s0">301</span>
<span class="s0">inline HTTPCookie::HTTPCookie(void);</span>
<span class="s0">inline explicit HTTPCookie::HTTPCookie(std::string const &amp;format, URLSpec const &amp;url);</span>
<span class="s0">inline explicit HTTPCookie::HTTPCookie(std::string const &amp;name, std::string const &amp;path, std::string const &amp;domain);</span>
<span class="s0">inline HTTPCookie::HTTPCookie(HTTPCookie const &amp;) = default;</span>

<span class="s0">517 11 ~HTTPCookie 0 516 811 23 HTTPCookie::~HTTPCookie 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline HTTPCookie::~HTTPCookie(void);</span>

<span class="s0">518 8 set_name 0 4 811 20 HTTPCookie::set_name 0 1 116 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void HTTPCookie::set_name(std::string const &amp;name);</span>

<span class="s0">519 8 get_name 0 4 811 20 HTTPCookie::get_name 0 1 117 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the cookie.  This is the key value specified by the</span>
 <span class="s0">* server.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::string const &amp;HTTPCookie::get_name(void) const;</span>

<span class="s0">520 9 set_value 0 4 811 21 HTTPCookie::set_value 0 1 118 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void HTTPCookie::set_value(std::string const &amp;value);</span>

<span class="s0">521 9 get_value 0 4 811 21 HTTPCookie::get_value 0 1 119 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value of the cookie.  This is the arbitrary string associated</span>
 <span class="s0">* with the cookie's name, as specified by the server.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline std::string const &amp;HTTPCookie::get_value(void) const;</span>

<span class="s0">522 10 set_domain 0 4 811 22 HTTPCookie::set_domain 0 1 120 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void HTTPCookie::set_domain(std::string const &amp;domain);</span>

<span class="s0">523 10 get_domain 0 4 811 22 HTTPCookie::get_domain 0 1 121 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::string const &amp;HTTPCookie::get_domain(void) const;</span>

<span class="s0">524 8 set_path 0 4 811 20 HTTPCookie::set_path 0 1 122 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void HTTPCookie::set_path(std::string const &amp;path);</span>

<span class="s0">525 8 get_path 0 4 811 20 HTTPCookie::get_path 0 1 123 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the prefix of the URL paths on the server for which this cookie</span>
 <span class="s0">* will be sent.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::string const &amp;HTTPCookie::get_path(void) const;</span>

<span class="s0">526 11 set_expires 0 4 811 23 HTTPCookie::set_expires 0 1 124 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void HTTPCookie::set_expires(HTTPDate const &amp;expires);</span>

<span class="s0">527 13 clear_expires 0 4 811 25 HTTPCookie::clear_expires 0 1 125 53</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the expiration date on the cookie.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void HTTPCookie::clear_expires(void);</span>

<span class="s0">528 11 has_expires 0 4 811 23 HTTPCookie::has_expires 0 1 126 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the cookie has an expiration date, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool HTTPCookie::has_expires(void) const;</span>

<span class="s0">529 11 get_expires 0 4 811 23 HTTPCookie::get_expires 0 1 127 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the expiration date of the cookie if it is set, or an invalid date</span>
 <span class="s0">* if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline HTTPDate HTTPCookie::get_expires(void) const;</span>

<span class="s0">530 10 set_secure 0 4 811 22 HTTPCookie::set_secure 0 1 128 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void HTTPCookie::set_secure(bool flag);</span>

<span class="s0">531 10 get_secure 0 4 811 22 HTTPCookie::get_secure 0 1 129 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the server has indicated this is a &quot;secure&quot; cookie which</span>
 <span class="s0">* should only be sent over an HTTPS channel.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool HTTPCookie::get_secure(void) const;</span>

<span class="s0">532 10 operator &lt; 0 4 811 22 HTTPCookie::operator &lt; 0 1 130 0</span>
<span class="s0">59</span>
<span class="s0">bool HTTPCookie::operator &lt;(HTTPCookie const &amp;other) const;</span>

<span class="s0">533 11 update_from 0 4 811 23 HTTPCookie::update_from 0 1 131 358</span>
<span class="s0">/**</span>
 <span class="s0">* Assuming the operator &lt; method, above, has already evaluated these two</span>
 <span class="s0">* cookies as equal, then assign the remaining values (value, expiration date,</span>
 <span class="s0">* secure flag) from the indicated cookie.  This is guaranteed not to change</span>
 <span class="s0">* the ordering of the cookie in a set, and so can be used to update an</span>
 <span class="s0">* existing cookie within a set with new values.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void HTTPCookie::update_from(HTTPCookie const &amp;other);</span>

<span class="s0">534 16 parse_set_cookie 0 4 811 28 HTTPCookie::parse_set_cookie 0 1 132 218</span>
<span class="s0">/**</span>
 <span class="s0">* Separates out the parameter/value pairs of the Set-Cookie header and</span>
 <span class="s0">* assigns the values of the cookie appropriate.  Returns true if the header</span>
 <span class="s0">* is parsed correctly, false if something is not understood.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">bool HTTPCookie::parse_set_cookie(std::string const &amp;format, URLSpec const &amp;url);</span>

<span class="s0">535 10 is_expired 0 4 811 22 HTTPCookie::is_expired 0 1 133 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the cookie's expiration date is before the indicated date,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline bool HTTPCookie::is_expired(HTTPDate const &amp;now = HTTPDate::now()) const;</span>

<span class="s0">536 11 matches_url 0 4 811 23 HTTPCookie::matches_url 0 1 134 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the cookie is appropriate to send with the indicated URL</span>
 <span class="s0">* request, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool HTTPCookie::matches_url(URLSpec const &amp;url) const;</span>

<span class="s0">537 6 output 0 4 811 18 HTTPCookie::output 0 1 135 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void HTTPCookie::output(std::ostream &amp;out) const;</span>

<span class="s0">538 10 HTTPClient 0 260 813 22 HTTPClient::HTTPClient 0 2 136 137 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">HTTPClient::HTTPClient(void);</span>
<span class="s0">HTTPClient::HTTPClient(HTTPClient const &amp;copy);</span>

<span class="s0">539 10 operator = 0 4 813 22 HTTPClient::operator = 0 1 138 0</span>
<span class="s0">52</span>
<span class="s0">void HTTPClient::operator =(HTTPClient const &amp;copy);</span>

<span class="s0">540 16 init_random_seed 0 4 813 28 HTTPClient::init_random_seed 0 1 139 561</span>
<span class="s0">/**</span>
 <span class="s0">* This may be called once, presumably at the beginning of an application, to</span>
 <span class="s0">* initialize OpenSSL's random seed.  On Windows, it is particularly important</span>
 <span class="s0">* to call this at startup if you are going to be performing any https</span>
 <span class="s0">* operations or otherwise use encryption, since the Windows algorithm for</span>
 <span class="s0">* getting a random seed takes 2-3 seconds at startup, but can take 30 seconds</span>
 <span class="s0">* or more after you have opened a 3-D graphics window and started rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* There is no harm in calling this method multiple times, or in not calling</span>
 <span class="s0">* it at all.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static void HTTPClient::init_random_seed(void);</span>

<span class="s0">541 14 set_proxy_spec 0 4 813 26 HTTPClient::set_proxy_spec 0 1 140 511</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the complete set of proxies to use for all schemes.  This is</span>
 <span class="s0">* either a semicolon-delimited set of hostname:ports, or a semicolon-</span>
 <span class="s0">* delimited set of pairs of the form &quot;scheme=hostname:port&quot;, or a</span>
 <span class="s0">* combination.  Use the keyword DIRECT, or an empty string, to represent a</span>
 <span class="s0">* direct connection.  A particular scheme and/or proxy host may be listed</span>
 <span class="s0">* more than once.  This is a convenience function that can be used in place</span>
 <span class="s0">* of explicit calls to add_proxy() for each scheme/proxy pair.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void HTTPClient::set_proxy_spec(std::string const &amp;proxy_spec);</span>

<span class="s0">542 14 get_proxy_spec 0 4 813 26 HTTPClient::get_proxy_spec 0 1 141 371</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete set of proxies to use for all schemes.  This is a</span>
 <span class="s0">* string of the form specified by set_proxy_spec(), above.  Note that the</span>
 <span class="s0">* string returned by this function may not be exactly the same as the string</span>
 <span class="s0">* passed into set_proxy_spec(), since the string is regenerated from the</span>
 <span class="s0">* internal storage structures and may therefore be reordered.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">std::string HTTPClient::get_proxy_spec(void) const;</span>

<span class="s0">543 20 set_direct_host_spec 0 4 813 32 HTTPClient::set_direct_host_spec 0 1 142 197</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the set of hosts that should be connected to directly, without</span>
 <span class="s0">* using a proxy.  This is a semicolon-separated list of hostnames that may</span>
 <span class="s0">* contain wildcard characters (&quot;*&quot;).</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void HTTPClient::set_direct_host_spec(std::string const &amp;direct_host_spec);</span>

<span class="s0">544 20 get_direct_host_spec 0 4 813 32 HTTPClient::get_direct_host_spec 0 1 143 189</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of hosts that should be connected to directly, without</span>
 <span class="s0">* using a proxy, as a semicolon-separated list of hostnames that may contain</span>
 <span class="s0">* wildcard characters (&quot;*&quot;).</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">std::string HTTPClient::get_direct_host_spec(void) const;</span>

<span class="s0">545 18 set_try_all_direct 0 4 813 30 HTTPClient::set_try_all_direct 0 1 144 306</span>
<span class="s0">/**</span>
 <span class="s0">* If this is set true, then after a connection attempt through a proxy fails,</span>
 <span class="s0">* we always try a direct connection, regardless of whether the host is listed</span>
 <span class="s0">* on the direct_host_spec list.  If this is false, a direct attempt is not</span>
 <span class="s0">* made when we have a proxy in effect, even if the proxy fails.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void HTTPClient::set_try_all_direct(bool try_all_direct);</span>

<span class="s0">546 18 get_try_all_direct 0 4 813 30 HTTPClient::get_try_all_direct 0 1 145 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether a failed connection through a proxy will be followed up by</span>
 <span class="s0">* a direct connection attempt, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool HTTPClient::get_try_all_direct(void) const;</span>

<span class="s0">547 11 clear_proxy 0 4 813 23 HTTPClient::clear_proxy 0 1 146 128</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the proxy spec to empty.  Subsequent calls to add_proxy() may be</span>
 <span class="s0">* made to build up the set of proxy servers.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">void HTTPClient::clear_proxy(void);</span>

<span class="s0">548 9 add_proxy 0 4 813 21 HTTPClient::add_proxy 0 1 147 271</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated proxy host as a proxy for communications on the given</span>
 <span class="s0">* scheme.  Usually the scheme is &quot;http&quot; or &quot;https&quot;.  It may be the empty</span>
 <span class="s0">* string to indicate a general proxy.  The proxy string may be the empty URL</span>
 <span class="s0">* to indicate a direct connection.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void HTTPClient::add_proxy(std::string const &amp;scheme, URLSpec const &amp;proxy);</span>

<span class="s0">549 17 clear_direct_host 0 4 813 29 HTTPClient::clear_direct_host 0 1 148 178</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the set of direct hosts to empty.  Subsequent calls to</span>
 <span class="s0">* add_direct_host() may be made to build up the list of hosts that do not</span>
 <span class="s0">* require a proxy connection.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void HTTPClient::clear_direct_host(void);</span>

<span class="s0">550 15 add_direct_host 0 4 813 27 HTTPClient::add_direct_host 0 1 149 223</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated name to the set of hostnames that are connected to</span>
 <span class="s0">* directly, without using a proxy.  This name may be either a DNS name or an</span>
 <span class="s0">* IP address, and it may include the * as a wildcard character.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void HTTPClient::add_direct_host(std::string const &amp;hostname);</span>

<span class="s0">551 19 get_proxies_for_url 0 4 813 31 HTTPClient::get_proxies_for_url 0 1 150 621</span>
<span class="s0">/**</span>
 <span class="s0">* Fills up the indicated vector with the list of URLSpec objects, in the</span>
 <span class="s0">* order in which they should be tried, that are appropriate proxies to try</span>
 <span class="s0">* for the indicated URL.  The empty URL is returned for a direct connection.</span>
 <span class="s0">*</span>
 <span class="s0">* It is the user's responsibility to empty this vector before calling this</span>
 <span class="s0">* method; otherwise, the proxy URL's will simply be appended to the existing</span>
 <span class="s0">* list.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a semicolon-delimited list of proxies, in the order in which they</span>
 <span class="s0">* should be tried, that are appropriate for the indicated URL.  The keyword</span>
 <span class="s0">* DIRECT indicates a direct connection should be tried.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">std::string HTTPClient::get_proxies_for_url(URLSpec const &amp;url) const;</span>

<span class="s0">552 12 set_username 0 4 813 24 HTTPClient::set_username 0 1 151 433</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the username:password string corresponding to a particular server</span>
 <span class="s0">* and/or realm, when demanded by the server.  Either or both of the server or</span>
 <span class="s0">* realm may be empty; if so, they match anything.  Also, the server may be</span>
 <span class="s0">* set to the special string `&quot;*proxy&quot;`, which will match any proxy server.</span>
 <span class="s0">*</span>
 <span class="s0">* If the username is set to the empty string, this clears the password for</span>
 <span class="s0">* the particular server/realm pair.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">void HTTPClient::set_username(std::string const &amp;server, std::string const &amp;realm, std::string const &amp;username);</span>

<span class="s0">553 12 get_username 0 4 813 24 HTTPClient::get_username 0 1 152 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the username:password string set for this server/realm pair, or</span>
 <span class="s0">* empty string if nothing has been set.  See set_username().</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">std::string HTTPClient::get_username(std::string const &amp;server, std::string const &amp;realm) const;</span>

<span class="s0">554 10 set_cookie 0 4 813 22 HTTPClient::set_cookie 0 1 153 116</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the indicated cookie in the client's list of cookies, as if it had</span>
 <span class="s0">* been received from a server.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void HTTPClient::set_cookie(HTTPCookie const &amp;cookie);</span>

<span class="s0">555 12 clear_cookie 0 4 813 24 HTTPClient::clear_cookie 0 1 154 175</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the cookie with the matching domain/path/name from the client's</span>
 <span class="s0">* list of cookies.  Returns true if it was removed, false if the cookie was</span>
 <span class="s0">* not matched.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">bool HTTPClient::clear_cookie(HTTPCookie const &amp;cookie);</span>

<span class="s0">556 17 clear_all_cookies 0 4 813 29 HTTPClient::clear_all_cookies 0 1 155 58</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the all stored cookies from the client.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void HTTPClient::clear_all_cookies(void);</span>

<span class="s0">557 10 has_cookie 0 4 813 22 HTTPClient::has_cookie 0 1 156 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a cookie in the client matching the given cookie's</span>
 <span class="s0">* domain/path/name, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool HTTPClient::has_cookie(HTTPCookie const &amp;cookie) const;</span>

<span class="s0">558 10 get_cookie 0 4 813 22 HTTPClient::get_cookie 0 1 157 163</span>
<span class="s0">/**</span>
 <span class="s0">* Looks up and returns the cookie in the client matching the given cookie's</span>
 <span class="s0">* domain/path/name.  If there is no matching cookie, returns an empty cookie.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">HTTPCookie HTTPClient::get_cookie(HTTPCookie const &amp;cookie) const;</span>

<span class="s0">559 17 copy_cookies_from 0 4 813 29 HTTPClient::copy_cookies_from 0 1 158 179</span>
<span class="s0">/**</span>
 <span class="s0">* Copies all the cookies from the indicated HTTPClient into this one.</span>
 <span class="s0">* Existing cookies in this client are not affected, unless they are shadowed</span>
 <span class="s0">* by the new cookies.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void HTTPClient::copy_cookies_from(HTTPClient const &amp;other);</span>

<span class="s0">560 13 write_cookies 0 4 813 25 HTTPClient::write_cookies 0 1 159 172</span>
<span class="s0">/**</span>
 <span class="s0">* Outputs the complete list of cookies stored on the client, for all domains,</span>
 <span class="s0">* including the expired cookies (which will normally not be sent back to a</span>
 <span class="s0">* host).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void HTTPClient::write_cookies(std::ostream &amp;out) const;</span>

<span class="s0">561 12 send_cookies 0 4 813 24 HTTPClient::send_cookies 0 1 160 192</span>
<span class="s0">/**</span>
 <span class="s0">* Writes to the indicated ostream a &quot;Cookie&quot; header line for sending the</span>
 <span class="s0">* cookies appropriate to the indicated URL along with an HTTP request.  This</span>
 <span class="s0">* also removes expired cookies.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void HTTPClient::send_cookies(std::ostream &amp;out, URLSpec const &amp;url);</span>

<span class="s0">562 31 set_client_certificate_filename 0 4 813 43 HTTPClient::set_client_certificate_filename 0 1 161 250</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the filename of the pem-formatted file that will be read for the</span>
 <span class="s0">* client public and private keys if an SSL server requests a certificate.</span>
 <span class="s0">* Either this or set_client_certificate_pem() may be used to specify a client</span>
 <span class="s0">* certificate.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline void HTTPClient::set_client_certificate_filename(Filename const &amp;filename);</span>

<span class="s0">563 26 set_client_certificate_pem 0 4 813 38 HTTPClient::set_client_certificate_pem 0 1 162 264</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the pem-formatted contents of the certificate that will be parsed for</span>
 <span class="s0">* the client public and private keys if an SSL server requests a certificate.</span>
 <span class="s0">* Either this or set_client_certificate_filename() may be used to specify a</span>
 <span class="s0">* client certificate.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void HTTPClient::set_client_certificate_pem(std::string const &amp;pem);</span>

<span class="s0">564 33 set_client_certificate_passphrase 0 4 813 45 HTTPClient::set_client_certificate_passphrase 0 1 163 160</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the passphrase used to decrypt the private key in the certificate</span>
 <span class="s0">* named by set_client_certificate_filename() or set_client_certificate_pem().</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline void HTTPClient::set_client_certificate_passphrase(std::string const &amp;passphrase);</span>

<span class="s0">565 23 load_client_certificate 0 4 813 35 HTTPClient::load_client_certificate 0 1 164 376</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to load the certificate named by set_client_certificate_filename()</span>
 <span class="s0">* immediately, and returns true if successful, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally this need not be explicitly called, since it will be called</span>
 <span class="s0">* automatically if the server requests a certificate, but it may be useful to</span>
 <span class="s0">* determine ahead of time if the certificate can be loaded correctly.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">bool HTTPClient::load_client_certificate(void);</span>

<span class="s0">566 43 add_preapproved_server_certificate_filename 0 4 813 55 HTTPClient::add_preapproved_server_certificate_filename 0 1 165 547</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the certificate defined in the indicated PEM filename as a &quot;pre-</span>
 <span class="s0">* approved&quot; certificate for the indicated server, defined by the hostname and</span>
 <span class="s0">* port (only) from the given URL.</span>
 <span class="s0">*</span>
 <span class="s0">* If the server offers this particular certificate on a secure connection, it</span>
 <span class="s0">* will be accepted without question.  This is particularly useful for</span>
 <span class="s0">* communicating with a server using a known self-signed certificate.</span>
 <span class="s0">*</span>
 <span class="s0">* See also the similar add_preapproved_server_certificate_pem(), and the</span>
 <span class="s0">* weaker add_preapproved_server_certificate_name().</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">bool HTTPClient::add_preapproved_server_certificate_filename(URLSpec const &amp;url, Filename const &amp;filename);</span>

<span class="s0">567 38 add_preapproved_server_certificate_pem 0 4 813 50 HTTPClient::add_preapproved_server_certificate_pem 0 1 166 577</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the certificate defined in the indicated data string, formatted as a</span>
 <span class="s0">* PEM block, as a &quot;pre-approved&quot; certificate for the indicated server,</span>
 <span class="s0">* defined by the hostname and port (only) from the given URL.</span>
 <span class="s0">*</span>
 <span class="s0">* If the server offers this particular certificate on a secure connection, it</span>
 <span class="s0">* will be accepted without question.  This is particularly useful for</span>
 <span class="s0">* communicating with a server using a known self-signed certificate.</span>
 <span class="s0">*</span>
 <span class="s0">* See also the similar add_preapproved_server_certificate_filename(), and the</span>
 <span class="s0">* weaker add_preapproved_server_certificate_name().</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">bool HTTPClient::add_preapproved_server_certificate_pem(URLSpec const &amp;url, std::string const &amp;pem);</span>

<span class="s0">568 39 add_preapproved_server_certificate_name 0 4 813 51 HTTPClient::add_preapproved_server_certificate_name 0 1 167 888</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the certificate *name* only, as a &quot;pre-approved&quot; certificate name for</span>
 <span class="s0">* the indicated server, defined by the hostname and port (only) from the</span>
 <span class="s0">* given URL.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a weaker function than</span>
 <span class="s0">* add_preapproved_server_certificate_filename().  This checks only the</span>
 <span class="s0">* subject name of the certificate, without checking for a particular</span>
 <span class="s0">* certificate by key.  This means that a variety of server certificates may</span>
 <span class="s0">* match the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* Because this is a weaker verification, it only applies to server</span>
 <span class="s0">* certificates that are signed by a recognized certificate authority.  Thus,</span>
 <span class="s0">* it cannot be used to pre-approve self-signed certificates, but it can be</span>
 <span class="s0">* used to accept a server certificate offered by a different hostname than</span>
 <span class="s0">* the one in the cert itself.</span>
 <span class="s0">*</span>
 <span class="s0">* The certificate name should be formatted in the form</span>
 <span class="s0">* type0=value0/type1=value1/type2=...</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">bool HTTPClient::add_preapproved_server_certificate_name(URLSpec const &amp;url, std::string const &amp;name);</span>

<span class="s0">569 37 clear_preapproved_server_certificates 0 4 813 49 HTTPClient::clear_preapproved_server_certificates 0 1 168 92</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all preapproved server certificates for the indicated server and</span>
 <span class="s0">* port.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void HTTPClient::clear_preapproved_server_certificates(URLSpec const &amp;url);</span>

<span class="s0">570 41 clear_all_preapproved_server_certificates 0 4 813 53 HTTPClient::clear_all_preapproved_server_certificates 0 1 169 71</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all preapproved server certificates for all servers.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">void HTTPClient::clear_all_preapproved_server_certificates(void);</span>

<span class="s0">571 16 set_http_version 0 4 813 28 HTTPClient::set_http_version 0 1 170 221</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the version of HTTP that the client uses to identify itself to</span>
 <span class="s0">* the server.  The default is HV_11, or HTTP 1.0; you can set this to HV_10</span>
 <span class="s0">* (HTTP 1.0) to request the server use the older interface.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void HTTPClient::set_http_version(HTTPEnum::HTTPVersion version);</span>

<span class="s0">572 16 get_http_version 0 4 813 28 HTTPClient::get_http_version 0 1 171 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the client's current setting for HTTP version.  See</span>
 <span class="s0">* set_http_version().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline HTTPEnum::HTTPVersion HTTPClient::get_http_version(void) const;</span>

<span class="s0">573 23 get_http_version_string 0 4 813 35 HTTPClient::get_http_version_string 0 1 172 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current HTTP version setting as a string, e.g.  &quot;HTTP/1.0&quot; or</span>
 <span class="s0">* &quot;HTTP/1.1&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">std::string HTTPClient::get_http_version_string(void) const;</span>

<span class="s0">574 25 parse_http_version_string 0 4 813 37 HTTPClient::parse_http_version_string 0 1 173 193</span>
<span class="s0">/**</span>
 <span class="s0">* Matches the string representing a particular HTTP version against any of</span>
 <span class="s0">* the known versions and returns the appropriate enumerated value, or</span>
 <span class="s0">* HV_other if the version is unknown.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">static HTTPEnum::HTTPVersion HTTPClient::parse_http_version_string(std::string const &amp;version);</span>

<span class="s0">575 17 load_certificates 0 4 813 29 HTTPClient::load_certificates 0 1 174 263</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the certificate(s) (delimited by -----BEGIN CERTIFICATE----- and</span>
 <span class="s0">* -----END CERTIFICATE-----) from the indicated file and makes them known as</span>
 <span class="s0">* trusted public keys for validating future connections.  Returns true on</span>
 <span class="s0">* success, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">bool HTTPClient::load_certificates(Filename const &amp;filename);</span>

<span class="s0">576 14 set_verify_ssl 0 4 813 26 HTTPClient::set_verify_ssl 0 1 175 263</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies whether the client will insist on verifying the identity of the</span>
 <span class="s0">* servers it connects to via SSL (that is, https).</span>
 <span class="s0">*</span>
 <span class="s0">* The parameter value is an enumerated type which indicates the level of</span>
 <span class="s0">* security to which the client will insist upon.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void HTTPClient::set_verify_ssl(HTTPClient::VerifySSL verify_ssl);</span>

<span class="s0">577 14 get_verify_ssl 0 4 813 26 HTTPClient::get_verify_ssl 0 1 176 157</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether the client will insist on verifying the identity of the</span>
 <span class="s0">* servers it connects to via SSL (that is, https).  See set_verify_ssl().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline HTTPClient::VerifySSL HTTPClient::get_verify_ssl(void) const;</span>

<span class="s0">578 15 set_cipher_list 0 4 813 27 HTTPClient::set_cipher_list 0 1 177 404</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the set of ciphers that are to be made available for SSL</span>
 <span class="s0">* connections.  This is a string as described in the ciphers(1) man page of</span>
 <span class="s0">* the OpenSSL documentation (or see</span>
 <span class="s0">* https://www.openssl.org/docs/man1.1.1/man1/ciphers.html ).  If this isn't</span>
 <span class="s0">* specified, the default is provided by the Config file.  You may also specify</span>
 <span class="s0">* &quot;DEFAULT&quot; to use the built-in OpenSSL default value.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void HTTPClient::set_cipher_list(std::string const &amp;cipher_list);</span>

<span class="s0">579 15 get_cipher_list 0 4 813 27 HTTPClient::get_cipher_list 0 1 178 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of ciphers as set by set_cipher_list().  See</span>
 <span class="s0">* set_cipher_list().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::string const &amp;HTTPClient::get_cipher_list(void) const;</span>

<span class="s0">580 12 make_channel 0 4 813 24 HTTPClient::make_channel 0 1 179 763</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new HTTPChannel object that may be used for reading multiple</span>
 <span class="s0">* documents using the same connection, for greater network efficiency than</span>
 <span class="s0">* calling HTTPClient::get_document() repeatedly (which would force a new</span>
 <span class="s0">* connection for each document).</span>
 <span class="s0">*</span>
 <span class="s0">* Also, HTTPChannel has some additional, less common interface methods than</span>
 <span class="s0">* the basic interface methods that exist on HTTPClient; if you wish to call</span>
 <span class="s0">* any of these methods you must first obtain an HTTPChannel.</span>
 <span class="s0">*</span>
 <span class="s0">* Pass true for persistent_connection to gain this network efficiency.  If,</span>
 <span class="s0">* on the other hand, your intention is to use the channel to retrieve only</span>
 <span class="s0">* one document, then pass false to inform the server that we will be dropping</span>
 <span class="s0">* the connection after the first document.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">PointerTo&lt; HTTPChannel &gt; HTTPClient::make_channel(bool persistent_connection);</span>

<span class="s0">581 9 post_form 0 4 813 21 HTTPClient::post_form 0 1 180 262</span>
<span class="s0">/**</span>
 <span class="s0">* Posts form data to a particular URL and retrieves the response.  Returns a</span>
 <span class="s0">* new HTTPChannel object whether the document is successfully read or not;</span>
 <span class="s0">* you can test is_valid() and get_return_code() to determine whether the</span>
 <span class="s0">* document was retrieved.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">PointerTo&lt; HTTPChannel &gt; HTTPClient::post_form(URLSpec const &amp;url, std::string const &amp;body);</span>

<span class="s0">582 12 get_document 0 4 813 24 HTTPClient::get_document 0 1 181 233</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the named document for reading.  Returns a new HTTPChannel object</span>
 <span class="s0">* whether the document is successfully read or not; you can test is_valid()</span>
 <span class="s0">* and get_return_code() to determine whether the document was retrieved.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">PointerTo&lt; HTTPChannel &gt; HTTPClient::get_document(URLSpec const &amp;url);</span>

<span class="s0">583 10 get_header 0 4 813 22 HTTPClient::get_header 0 1 182 252</span>
<span class="s0">/**</span>
 <span class="s0">* Like get_document(), except only the header associated with the document is</span>
 <span class="s0">* retrieved.  This may be used to test for existence of the document; it</span>
 <span class="s0">* might also return the size of the document (if the server gives us this</span>
 <span class="s0">* information).</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">PointerTo&lt; HTTPChannel &gt; HTTPClient::get_header(URLSpec const &amp;url);</span>

<span class="s0">584 13 base64_encode 0 4 813 25 HTTPClient::base64_encode 0 1 183 222</span>
<span class="s0">/**</span>
 <span class="s0">* Implements HTTPAuthorization::base64_encode().  This is provided here just</span>
 <span class="s0">* as a convenient place to publish it for access by the scripting language;</span>
 <span class="s0">* C++ code should probably use HTTPAuthorization directly.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline std::string HTTPClient::base64_encode(std::string const &amp;s);</span>

<span class="s0">585 13 base64_decode 0 4 813 25 HTTPClient::base64_decode 0 1 184 222</span>
<span class="s0">/**</span>
 <span class="s0">* Implements HTTPAuthorization::base64_decode().  This is provided here just</span>
 <span class="s0">* as a convenient place to publish it for access by the scripting language;</span>
 <span class="s0">* C++ code should probably use HTTPAuthorization directly.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline std::string HTTPClient::base64_decode(std::string const &amp;s);</span>

<span class="s0">586 14 get_global_ptr 0 4 813 26 HTTPClient::get_global_ptr 0 1 185 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default global HTTPClient.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static HTTPClient *HTTPClient::get_global_ptr(void);</span>

<span class="s0">587 13 HTTPEntityTag 0 260 816 28 HTTPEntityTag::HTTPEntityTag 0 4 186 187 188 189 259</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This constructor accepts an explicit weak flag and a literal (not quoted)</span>
 <span class="s0">* tag string.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This constructor accepts a string as formatted from an HTTP server (e.g.</span>
 <span class="s0">* the tag is quoted, with an optional W/ prefix.)</span>
 <span class="s0">*/</span>
<span class="s0">233</span>
<span class="s0">inline HTTPEntityTag::HTTPEntityTag(void);</span>
<span class="s0">HTTPEntityTag::HTTPEntityTag(std::string const &amp;text);</span>
<span class="s0">inline HTTPEntityTag::HTTPEntityTag(bool weak, std::string const &amp;tag);</span>
<span class="s0">inline HTTPEntityTag::HTTPEntityTag(HTTPEntityTag const &amp;copy);</span>

<span class="s0">588 10 operator = 0 4 816 25 HTTPEntityTag::operator = 0 1 190 0</span>
<span class="s0">65</span>
<span class="s0">inline void HTTPEntityTag::operator =(HTTPEntityTag const &amp;copy);</span>

<span class="s0">589 7 is_weak 0 4 816 22 HTTPEntityTag::is_weak 0 1 191 255</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the entity tag is marked as &quot;weak&quot;. A consistent weak</span>
 <span class="s0">* entity tag does not guarantee that its resource has not changed in any way,</span>
 <span class="s0">* but it does promise that the resource has not changed in any semantically</span>
 <span class="s0">* meaningful way.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool HTTPEntityTag::is_weak(void) const;</span>

<span class="s0">590 7 get_tag 0 4 816 22 HTTPEntityTag::get_tag 0 1 192 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the tag as a literal string.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::string const &amp;HTTPEntityTag::get_tag(void) const;</span>

<span class="s0">591 10 get_string 0 4 816 25 HTTPEntityTag::get_string 0 1 193 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the entity tag formatted for sending to an HTTP server (the tag is</span>
 <span class="s0">* quoted, with a conditional W prefix).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">std::string HTTPEntityTag::get_string(void) const;</span>

<span class="s0">592 12 strong_equiv 0 4 816 27 HTTPEntityTag::strong_equiv 0 1 194 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the two tags have &quot;strong&quot; equivalence: they are the same</span>
 <span class="s0">* tag, and both are &quot;strong&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline bool HTTPEntityTag::strong_equiv(HTTPEntityTag const &amp;other) const;</span>

<span class="s0">593 10 weak_equiv 0 4 816 25 HTTPEntityTag::weak_equiv 0 1 195 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the two tags have &quot;weak&quot; equivalence: they are the same</span>
 <span class="s0">* tag, and one or both may be &quot;weak&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline bool HTTPEntityTag::weak_equiv(HTTPEntityTag const &amp;other) const;</span>

<span class="s0">594 11 operator == 0 4 816 26 HTTPEntityTag::operator == 0 1 196 0</span>
<span class="s0">73</span>
<span class="s0">inline bool HTTPEntityTag::operator ==(HTTPEntityTag const &amp;other) const;</span>

<span class="s0">595 11 operator != 0 4 816 26 HTTPEntityTag::operator != 0 1 197 0</span>
<span class="s0">73</span>
<span class="s0">inline bool HTTPEntityTag::operator !=(HTTPEntityTag const &amp;other) const;</span>

<span class="s0">596 10 operator &lt; 0 4 816 25 HTTPEntityTag::operator &lt; 0 1 198 0</span>
<span class="s0">72</span>
<span class="s0">inline bool HTTPEntityTag::operator &lt;(HTTPEntityTag const &amp;other) const;</span>

<span class="s0">597 10 compare_to 0 4 816 25 HTTPEntityTag::compare_to 0 1 199 167</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this HTTPEntityTag sorts before the</span>
 <span class="s0">* other one, greater than zero if it sorts after, or zero if they are</span>
 <span class="s0">* equivalent.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline int HTTPEntityTag::compare_to(HTTPEntityTag const &amp;other) const;</span>

<span class="s0">598 6 output 0 4 816 21 HTTPEntityTag::output 0 1 200 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void HTTPEntityTag::output(std::ostream &amp;out) const;</span>

<span class="s0">599 14 ~HTTPEntityTag 0 516 816 29 HTTPEntityTag::~HTTPEntityTag 0 0 0</span>
<span class="s0">36</span>
<span class="s0">HTTPEntityTag::~HTTPEntityTag(void);</span>

<span class="s0">600 12 DocumentSpec 0 260 817 26 DocumentSpec::DocumentSpec 0 4 201 202 203 204 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">215</span>
<span class="s0">inline DocumentSpec::DocumentSpec(void);</span>
<span class="s0">inline DocumentSpec::DocumentSpec(std::string const &amp;url);</span>
<span class="s0">inline DocumentSpec::DocumentSpec(URLSpec const &amp;url);</span>
<span class="s0">inline DocumentSpec::DocumentSpec(DocumentSpec const &amp;copy);</span>

<span class="s0">601 10 operator = 0 4 817 24 DocumentSpec::operator = 0 1 205 0</span>
<span class="s0">63</span>
<span class="s0">inline void DocumentSpec::operator =(DocumentSpec const &amp;copy);</span>

<span class="s0">602 11 operator == 0 4 817 25 DocumentSpec::operator == 0 1 206 0</span>
<span class="s0">71</span>
<span class="s0">inline bool DocumentSpec::operator ==(DocumentSpec const &amp;other) const;</span>

<span class="s0">603 11 operator != 0 4 817 25 DocumentSpec::operator != 0 1 207 0</span>
<span class="s0">71</span>
<span class="s0">inline bool DocumentSpec::operator !=(DocumentSpec const &amp;other) const;</span>

<span class="s0">604 10 operator &lt; 0 4 817 24 DocumentSpec::operator &lt; 0 1 208 0</span>
<span class="s0">70</span>
<span class="s0">inline bool DocumentSpec::operator &lt;(DocumentSpec const &amp;other) const;</span>

<span class="s0">605 10 compare_to 0 4 817 24 DocumentSpec::compare_to 0 1 209 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">int DocumentSpec::compare_to(DocumentSpec const &amp;other) const;</span>

<span class="s0">606 7 set_url 0 4 817 21 DocumentSpec::set_url 0 1 210 311</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the URL of the DocumentSpec without modifying its other properties.</span>
 <span class="s0">* Normally this would be a strange thing to do, because the tag and date are</span>
 <span class="s0">* usually strongly associated with the URL.  To get a DocumentSpec pointing</span>
 <span class="s0">* to a new URL, you would normally create a new DocumentSpec object.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void DocumentSpec::set_url(URLSpec const &amp;url);</span>

<span class="s0">607 7 get_url 0 4 817 21 DocumentSpec::get_url 0 1 211 49</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the URL of the DocumentSpec.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline URLSpec const &amp;DocumentSpec::get_url(void) const;</span>

<span class="s0">608 7 set_tag 0 4 817 21 DocumentSpec::set_tag 0 1 212 69</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the identity tag associated with the DocumentSpec.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void DocumentSpec::set_tag(HTTPEntityTag const &amp;tag);</span>

<span class="s0">609 7 has_tag 0 4 817 21 DocumentSpec::has_tag 0 1 213 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if an identity tag is associated with the DocumentSpec.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool DocumentSpec::has_tag(void) const;</span>

<span class="s0">610 7 get_tag 0 4 817 21 DocumentSpec::get_tag 0 1 214 254</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the identity tag associated with the DocumentSpec, if there is one.</span>
 <span class="s0">* It is an error to call this if has_tag() returns false.</span>
 <span class="s0">*</span>
 <span class="s0">* The identity tag is set by the HTTP server to uniquely refer to a</span>
 <span class="s0">* particular version of a document.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline HTTPEntityTag const &amp;DocumentSpec::get_tag(void) const;</span>

<span class="s0">611 9 clear_tag 0 4 817 23 DocumentSpec::clear_tag 0 1 215 86</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the identity tag associated with the DocumentSpec, if there is one.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void DocumentSpec::clear_tag(void);</span>

<span class="s0">612 8 set_date 0 4 817 22 DocumentSpec::set_date 0 1 216 75</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the last-modified date associated with the DocumentSpec.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void DocumentSpec::set_date(HTTPDate const &amp;date);</span>

<span class="s0">613 8 has_date 0 4 817 22 DocumentSpec::has_date 0 1 217 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a last-modified date is associated with the DocumentSpec.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool DocumentSpec::has_date(void) const;</span>

<span class="s0">614 8 get_date 0 4 817 22 DocumentSpec::get_date 0 1 218 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the last-modified date associated with the DocumentSpec, if there</span>
 <span class="s0">* is one.  It is an error to call this if has_date() returns false.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline HTTPDate const &amp;DocumentSpec::get_date(void) const;</span>

<span class="s0">615 10 clear_date 0 4 817 24 DocumentSpec::clear_date 0 1 219 95</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the last-modified date associated with the DocumentSpec, if there</span>
 <span class="s0">* is one.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void DocumentSpec::clear_date(void);</span>

<span class="s0">616 16 set_request_mode 0 4 817 30 DocumentSpec::set_request_mode 0 1 220 1335</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the request mode of this DocumentSpec.  This is only relevant when</span>
 <span class="s0">* using the DocumentSpec to generate a request (for instance, in</span>
 <span class="s0">* HTTPChannel).  This specifies whether the document request will ask the</span>
 <span class="s0">* server for a newer version than the indicated version, or the exact</span>
 <span class="s0">* version, neither, or either.</span>
 <span class="s0">*</span>
 <span class="s0">* The possible values are:</span>
 <span class="s0">*</span>
 <span class="s0">* RM_any: ignore date and tag (if specified), and retrieve any document that</span>
 <span class="s0">* matches the URL.  For a subrange request, if the document matches the</span>
 <span class="s0">* version indicated exactly, retrieve the subrange only; otherwise, retrieve</span>
 <span class="s0">* the entire document.</span>
 <span class="s0">*</span>
 <span class="s0">* RM_equal: request only the precise version of the document that matches the</span>
 <span class="s0">* particular date and/or tag exactly, if specified; fail if this version is</span>
 <span class="s0">* not available.</span>
 <span class="s0">*</span>
 <span class="s0">* RM_newer: request any document that is newer than the version indicated by</span>
 <span class="s0">* the particular date and/or tag; fail if only that version (or older</span>
 <span class="s0">* versions) are available.</span>
 <span class="s0">*</span>
 <span class="s0">* RM_newer_or_equal: request any document that matches the version indicated</span>
 <span class="s0">* by the particular date and/or tag, or is a newer version; fail if only</span>
 <span class="s0">* older versions are available.</span>
 <span class="s0">*</span>
 <span class="s0">* In any of the above, you may specify either or both of the last-modified</span>
 <span class="s0">* date and the identity tag, whichever is known to the client.</span>
 <span class="s0">*</span>
 <span class="s0">* The default mode is RM_any.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void DocumentSpec::set_request_mode(DocumentSpec::RequestMode request_mode);</span>

<span class="s0">617 16 get_request_mode 0 4 817 30 DocumentSpec::get_request_mode 0 1 221 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the request mode of this DocumentSpec.  See set_request_mode().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline DocumentSpec::RequestMode DocumentSpec::get_request_mode(void) const;</span>

<span class="s0">618 17 set_cache_control 0 4 817 31 DocumentSpec::set_cache_control 0 1 222 642</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies what kind of cached value is acceptable for this document.</span>
 <span class="s0">* Warning: some HTTP proxies may not respect this setting and may return a</span>
 <span class="s0">* cached result anyway.</span>
 <span class="s0">*</span>
 <span class="s0">* CC_allow_cache: the normal HTTP behavior; the server may return a cached</span>
 <span class="s0">* value if it believes it is valid.</span>
 <span class="s0">*</span>
 <span class="s0">* CC_revalidate: a proxy is forced to contact the origin server and verify</span>
 <span class="s0">* that is cached value is in fact still valid before it returns it.</span>
 <span class="s0">*</span>
 <span class="s0">* CC_no_cache: a proxy must not return its cached value at all, but is forced</span>
 <span class="s0">* to go all the way back to the origin server for the official document.</span>
 <span class="s0">*</span>
 <span class="s0">* The default mode is CC_allow_cache.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void DocumentSpec::set_cache_control(DocumentSpec::CacheControl cache_control);</span>

<span class="s0">619 17 get_cache_control 0 4 817 31 DocumentSpec::get_cache_control 0 1 223 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the request mode of this DocumentSpec.  See set_cache_control().</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline DocumentSpec::CacheControl DocumentSpec::get_cache_control(void) const;</span>

<span class="s0">620 5 input 0 4 817 19 DocumentSpec::input 0 1 224 152</span>
<span class="s0">/**</span>
 <span class="s0">* Can be used to read in the DocumentSpec from a stream generated either by</span>
 <span class="s0">* output() or write().  Returns true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">bool DocumentSpec::input(std::istream &amp;in);</span>

<span class="s0">621 6 output 0 4 817 20 DocumentSpec::output 0 1 225 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void DocumentSpec::output(std::ostream &amp;out) const;</span>

<span class="s0">622 5 write 0 4 817 19 DocumentSpec::write 0 1 226 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void DocumentSpec::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">623 13 ~DocumentSpec 0 516 817 27 DocumentSpec::~DocumentSpec 0 0 0</span>
<span class="s0">34</span>
<span class="s0">DocumentSpec::~DocumentSpec(void);</span>

<span class="s0">624 10 get_client 0 4 823 23 HTTPChannel::get_client 0 1 228 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HTTPClient object that owns this channel.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline HTTPClient *HTTPChannel::get_client(void) const;</span>

<span class="s0">625 8 is_valid 0 4 823 21 HTTPChannel::is_valid 0 1 229 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the last-requested document was successfully retrieved and</span>
 <span class="s0">* is ready to be read, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool HTTPChannel::is_valid(void) const;</span>

<span class="s0">626 19 is_connection_ready 0 4 823 32 HTTPChannel::is_connection_ready 0 1 230 158</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a connection has been established to the named server in a</span>
 <span class="s0">* previous call to connect_to() or begin_connect_to(), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool HTTPChannel::is_connection_ready(void) const;</span>

<span class="s0">627 7 get_url 0 4 823 20 HTTPChannel::get_url 0 1 231 287</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the URL that was used to retrieve the most recent document:</span>
 <span class="s0">* whatever URL was last passed to get_document() or get_header().  If a</span>
 <span class="s0">* redirect has transparently occurred, this will return the new, redirected</span>
 <span class="s0">* URL (the actual URL at which the document was located).</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline URLSpec const &amp;HTTPChannel::get_url(void) const;</span>

<span class="s0">628 17 get_document_spec 0 4 823 30 HTTPChannel::get_document_spec 0 1 232 380</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DocumentSpec associated with the most recent document.  This</span>
 <span class="s0">* includes its actual URL (following redirects) along with the identity tag</span>
 <span class="s0">* and last-modified date, if supplied by the server.</span>
 <span class="s0">*</span>
 <span class="s0">* This structure may be saved and used to retrieve the same version of the</span>
 <span class="s0">* document later, or to conditionally retrieve a newer version if it is</span>
 <span class="s0">* available.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline DocumentSpec const &amp;HTTPChannel::get_document_spec(void) const;</span>

<span class="s0">629 16 get_http_version 0 4 823 29 HTTPChannel::get_http_version 0 1 233 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HTTP version number returned by the server, as one of the</span>
 <span class="s0">* HTTPClient enumerated types, e.g.  HTTPClient::HV_11.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline HTTPEnum::HTTPVersion HTTPChannel::get_http_version(void) const;</span>

<span class="s0">630 23 get_http_version_string 0 4 823 36 HTTPChannel::get_http_version_string 0 1 234 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HTTP version number returned by the server, formatted as a</span>
 <span class="s0">* string, e.g.  &quot;HTTP/1.1&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline std::string const &amp;HTTPChannel::get_http_version_string(void) const;</span>

<span class="s0">631 15 get_status_code 0 4 823 28 HTTPChannel::get_status_code 0 1 235 501</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HTML return code from the document retrieval request.  This</span>
 <span class="s0">* will be in the 200 range if the document is successfully retrieved, or some</span>
 <span class="s0">* other value in the case of an error.</span>
 <span class="s0">*</span>
 <span class="s0">* Some proxy errors during an https-over-proxy request would return the same</span>
 <span class="s0">* status code as a different error that occurred on the host server.  To</span>
 <span class="s0">* differentiate these cases, status codes that are returned by the proxy</span>
 <span class="s0">* during the CONNECT phase (except code 407) are incremented by 1000.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int HTTPChannel::get_status_code(void) const;</span>

<span class="s0">632 17 get_status_string 0 4 823 30 HTTPChannel::get_status_string 0 1 236 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string as returned by the server describing the status code for</span>
 <span class="s0">* humans.  This may or may not be meaningful.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">std::string HTTPChannel::get_status_string(void) const;</span>

<span class="s0">633 13 get_www_realm 0 4 823 26 HTTPChannel::get_www_realm 0 1 237 363</span>
<span class="s0">/**</span>
 <span class="s0">* If the document failed to connect because of a 401 (Authorization</span>
 <span class="s0">* required), this method will return the &quot;realm&quot; returned by the server in</span>
 <span class="s0">* which the requested document must be authenticated.  This string may be</span>
 <span class="s0">* presented to the user to request an associated username and password (which</span>
 <span class="s0">* then should be stored in HTTPClient::set_username()).</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline std::string const &amp;HTTPChannel::get_www_realm(void) const;</span>

<span class="s0">634 15 get_proxy_realm 0 4 823 28 HTTPChannel::get_proxy_realm 0 1 238 311</span>
<span class="s0">/**</span>
 <span class="s0">* If the document failed to connect because of a 407 (Proxy authorization</span>
 <span class="s0">* required), this method will return the &quot;realm&quot; returned by the proxy.  This</span>
 <span class="s0">* string may be presented to the user to request an associated username and</span>
 <span class="s0">* password (which then should be stored in HTTPClient::set_username()).</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline std::string const &amp;HTTPChannel::get_proxy_realm(void) const;</span>

<span class="s0">635 12 get_redirect 0 4 823 25 HTTPChannel::get_redirect 0 1 239 366</span>
<span class="s0">/**</span>
 <span class="s0">* If the document failed with a redirect code (300 series), this will</span>
 <span class="s0">* generally contain the new URL the server wants us to try.  In many cases,</span>
 <span class="s0">* the client will automatically follow redirects; if these are successful the</span>
 <span class="s0">* client will return a successful code and get_redirect() will return empty,</span>
 <span class="s0">* but get_url() will return the new, redirected URL.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline URLSpec const &amp;HTTPChannel::get_redirect(void) const;</span>

<span class="s0">636 16 get_header_value 0 4 823 29 HTTPChannel::get_header_value 0 1 240 160</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HTML header value associated with the indicated key, or empty</span>
 <span class="s0">* string if the key was not defined in the message returned by the server.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">std::string HTTPChannel::get_header_value(std::string const &amp;key) const;</span>

<span class="s0">637 22 get_num_redirect_steps 0 4 823 35 HTTPChannel::get_num_redirect_steps 0 1 241 212</span>
<span class="s0">/**</span>
 <span class="s0">* If the document automatically followed one or more redirects, this will</span>
 <span class="s0">* return the number of redirects that were automatically followed.  Use</span>
 <span class="s0">* get_redirect_step() to retrieve each URL in sequence.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int HTTPChannel::get_num_redirect_steps(void) const;</span>

<span class="s0">638 17 get_redirect_step 0 4 823 30 HTTPChannel::get_redirect_step 0 1 242 182</span>
<span class="s0">/**</span>
 <span class="s0">* Use in conjunction with get_num_redirect_steps() to extract the chain of</span>
 <span class="s0">* URL's that the channel was automatically redirected through to arrive at</span>
 <span class="s0">* the final document.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline URLSpec const &amp;HTTPChannel::get_redirect_step(int n) const;</span>

<span class="s0">639 25 set_persistent_connection 0 4 823 38 HTTPChannel::set_persistent_connection 0 1 243 532</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates whether the HTTPChannel should try to keep the connection to the</span>
 <span class="s0">* server open and reuse that connection for multiple documents, or whether it</span>
 <span class="s0">* should close the connection and open a new one for each request.  Set this</span>
 <span class="s0">* true to keep the connections around when possible, false to recycle them.</span>
 <span class="s0">*</span>
 <span class="s0">* It makes most sense to set this false when the HTTPChannel will be used</span>
 <span class="s0">* only once to retrieve a single document, true when you will be using the</span>
 <span class="s0">* same HTTPChannel object to retrieve multiple documents.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline void HTTPChannel::set_persistent_connection(bool persistent_connection);</span>

<span class="s0">640 25 get_persistent_connection 0 4 823 38 HTTPChannel::get_persistent_connection 0 1 244 267</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether the HTTPChannel should try to keep the connection to the</span>
 <span class="s0">* server open and reuse that connection for multiple documents, or whether it</span>
 <span class="s0">* should close the connection and open a new one for each request.  See</span>
 <span class="s0">* set_persistent_connection().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline bool HTTPChannel::get_persistent_connection(void) const;</span>

<span class="s0">641 21 will_close_connection 0 4 823 34 HTTPChannel::will_close_connection 0 1 245 217</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the server has indicated it will close the connection after</span>
 <span class="s0">* this document has been read, or false if it will remain open (and future</span>
 <span class="s0">* documents may be requested on the same connection).</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">bool HTTPChannel::will_close_connection(void) const;</span>

<span class="s0">642 15 set_allow_proxy 0 4 823 28 HTTPChannel::set_allow_proxy 0 1 246 325</span>
<span class="s0">/**</span>
 <span class="s0">* If this is true (the normal case), the HTTPClient will be consulted for</span>
 <span class="s0">* information about the proxy to be used for each connection via this</span>
 <span class="s0">* HTTPChannel.  If this has been set to false by the user, then all</span>
 <span class="s0">* connections will be made directly, regardless of the proxy settings</span>
 <span class="s0">* indicated on the HTTPClient.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void HTTPChannel::set_allow_proxy(bool allow_proxy);</span>

<span class="s0">643 15 get_allow_proxy 0 4 823 28 HTTPChannel::get_allow_proxy 0 1 247 325</span>
<span class="s0">/**</span>
 <span class="s0">* If this is true (the normal case), the HTTPClient will be consulted for</span>
 <span class="s0">* information about the proxy to be used for each connection via this</span>
 <span class="s0">* HTTPChannel.  If this has been set to false by the user, then all</span>
 <span class="s0">* connections will be made directly, regardless of the proxy settings</span>
 <span class="s0">* indicated on the HTTPClient.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool HTTPChannel::get_allow_proxy(void) const;</span>

<span class="s0">644 16 set_proxy_tunnel 0 4 823 29 HTTPChannel::set_proxy_tunnel 0 1 248 795</span>
<span class="s0">/**</span>
 <span class="s0">* Normally, a proxy is itself asked for ordinary URL's, and the proxy decides</span>
 <span class="s0">* whether to hand the client a cached version of the document or to contact</span>
 <span class="s0">* the server for a fresh version.  The proxy may also modify the headers and</span>
 <span class="s0">* transfer encoding on the way.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is set to true, then instead of asking for URL's from the proxy, we</span>
 <span class="s0">* will ask the proxy to open a connection to the server (for instance, on</span>
 <span class="s0">* port 80); if the proxy honors this request, then we contact the server</span>
 <span class="s0">* directly through this connection to retrieve the document.  If the proxy</span>
 <span class="s0">* does not honor the connect request, then the retrieve operation fails.</span>
 <span class="s0">*</span>
 <span class="s0">* SSL connections (e.g.  https), and connections through a Socks proxy, are</span>
 <span class="s0">* always tunneled, regardless of the setting of this flag.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void HTTPChannel::set_proxy_tunnel(bool proxy_tunnel);</span>

<span class="s0">645 16 get_proxy_tunnel 0 4 823 29 HTTPChannel::get_proxy_tunnel 0 1 249 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if connections always tunnel through a proxy, or false (the</span>
 <span class="s0">* normal case) if we allow the proxy to serve up documents.  See</span>
 <span class="s0">* set_proxy_tunnel().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool HTTPChannel::get_proxy_tunnel(void) const;</span>

<span class="s0">646 19 set_connect_timeout 0 4 823 32 HTTPChannel::set_connect_timeout 0 1 250 322</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the maximum length of time, in seconds, that the channel will wait</span>
 <span class="s0">* before giving up on establishing a TCP connection.</span>
 <span class="s0">*</span>
 <span class="s0">* At present, this is used only for the nonblocking interfaces (e.g.</span>
 <span class="s0">* begin_get_document(), begin_connect_to()), but it is used whether</span>
 <span class="s0">* set_blocking_connect() is true or false.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void HTTPChannel::set_connect_timeout(double timeout_seconds);</span>

<span class="s0">647 19 get_connect_timeout 0 4 823 32 HTTPChannel::get_connect_timeout 0 1 251 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of time, in seconds, to wait for a new nonblocking</span>
 <span class="s0">* socket to connect.  See set_connect_timeout().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline double HTTPChannel::get_connect_timeout(void) const;</span>

<span class="s0">648 20 set_blocking_connect 0 4 823 33 HTTPChannel::set_blocking_connect 0 1 252 641</span>
<span class="s0">/**</span>
 <span class="s0">* If this flag is true, a socket connect will block even for nonblocking I/O</span>
 <span class="s0">* calls like begin_get_document(), begin_connect_to(), etc.  If false, a</span>
 <span class="s0">* socket connect will not block for nonblocking I/O calls, but will block for</span>
 <span class="s0">* blocking I/O calls (get_document(), connect_to(), etc.).</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this true is useful when you want to use non-blocking I/O once you</span>
 <span class="s0">* have established the connection, but you don't want to bother with polling</span>
 <span class="s0">* for the initial connection.  It's also useful when you don't particularly</span>
 <span class="s0">* care about non-blocking I/O, but you need to respect timeouts like</span>
 <span class="s0">* connect_timeout and http_timeout.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void HTTPChannel::set_blocking_connect(bool blocking_connect);</span>

<span class="s0">649 20 get_blocking_connect 0 4 823 33 HTTPChannel::get_blocking_connect 0 1 253 298</span>
<span class="s0">/**</span>
 <span class="s0">* If this flag is true, a socket connect will block even for nonblocking I/O</span>
 <span class="s0">* calls like begin_get_document(), begin_connect_to(), etc.  If false, a</span>
 <span class="s0">* socket connect will not block for nonblocking I/O calls, but will block for</span>
 <span class="s0">* blocking I/O calls (get_document(), connect_to(), etc.).</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool HTTPChannel::get_blocking_connect(void) const;</span>

<span class="s0">650 16 set_http_timeout 0 4 823 29 HTTPChannel::set_http_timeout 0 1 254 485</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the maximum length of time, in seconds, that the channel will wait for</span>
 <span class="s0">* the HTTP server to finish sending its response to our request.</span>
 <span class="s0">*</span>
 <span class="s0">* The timer starts counting after the TCP connection has been established</span>
 <span class="s0">* (see set_connect_timeout(), above) and the request has been sent.</span>
 <span class="s0">*</span>
 <span class="s0">* At present, this is used only for the nonblocking interfaces (e.g.</span>
 <span class="s0">* begin_get_document(), begin_connect_to()), but it is used whether</span>
 <span class="s0">* set_blocking_connect() is true or false.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void HTTPChannel::set_http_timeout(double timeout_seconds);</span>

<span class="s0">651 16 get_http_timeout 0 4 823 29 HTTPChannel::get_http_timeout 0 1 255 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of time, in seconds, to wait for the HTTP server to</span>
 <span class="s0">* respond to our request.  See set_http_timeout().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline double HTTPChannel::get_http_timeout(void) const;</span>

<span class="s0">652 18 set_skip_body_size 0 4 823 31 HTTPChannel::set_skip_body_size 0 1 256 632</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the maximum number of bytes in a received (but unwanted) body</span>
 <span class="s0">* that will be skipped past, in order to reset to a new request.</span>
 <span class="s0">*</span>
 <span class="s0">* That is, if this HTTPChannel requests a file via get_document(), but does</span>
 <span class="s0">* not call download_to_ram(), download_to_file(), or open_read_body(), and</span>
 <span class="s0">* instead immediately requests a new file, then the HTTPChannel has a choice</span>
 <span class="s0">* whether to skip past the unwanted document, or to close the connection and</span>
 <span class="s0">* open a new one.  If the number of bytes to skip is more than this</span>
 <span class="s0">* threshold, the connection will be closed; otherwise, the data will simply</span>
 <span class="s0">* be read and discarded.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void HTTPChannel::set_skip_body_size(std::size_t skip_body_size);</span>

<span class="s0">653 18 get_skip_body_size 0 4 823 31 HTTPChannel::get_skip_body_size 0 1 257 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum number of bytes in a received (but unwanted) body that</span>
 <span class="s0">* will be skipped past, in order to reset to a new request.  See</span>
 <span class="s0">* set_skip_body_size().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::size_t HTTPChannel::get_skip_body_size(void) const;</span>

<span class="s0">654 16 set_idle_timeout 0 4 823 29 HTTPChannel::set_idle_timeout 0 1 258 387</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the amount of time, in seconds, in which a previously-established</span>
 <span class="s0">* connection is allowed to remain open and unused.  If a previous connection</span>
 <span class="s0">* has remained unused for at least this number of seconds, it will be closed</span>
 <span class="s0">* and a new connection will be opened; otherwise, the same connection will be</span>
 <span class="s0">* reused for the next request (for this particular HTTPChannel).</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void HTTPChannel::set_idle_timeout(double idle_timeout);</span>

<span class="s0">655 16 get_idle_timeout 0 4 823 29 HTTPChannel::get_idle_timeout 0 1 259 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of time, in seconds, in which an previously-established</span>
 <span class="s0">* connection is allowed to remain open and unused.  See set_idle_timeout().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline double HTTPChannel::get_idle_timeout(void) const;</span>

<span class="s0">656 21 set_download_throttle 0 4 823 34 HTTPChannel::set_download_throttle 0 1 260 686</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies whether nonblocking downloads (via download_to_file() or</span>
 <span class="s0">* download_to_ram()) will be limited so as not to use all available</span>
 <span class="s0">* bandwidth.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is true, when a download has been started on this channel it will</span>
 <span class="s0">* be invoked no more frequently than get_max_updates_per_second(), and the</span>
 <span class="s0">* total bandwidth used by the download will be no more than</span>
 <span class="s0">* get_max_bytes_per_second().  If this is false, downloads will proceed as</span>
 <span class="s0">* fast as the server can send the data.</span>
 <span class="s0">*</span>
 <span class="s0">* This only has effect on the nonblocking I/O methods like</span>
 <span class="s0">* begin_get_document(), etc.  The blocking methods like get_document() always</span>
 <span class="s0">* use as much CPU and bandwidth as they can get.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void HTTPChannel::set_download_throttle(bool download_throttle);</span>

<span class="s0">657 21 get_download_throttle 0 4 823 34 HTTPChannel::get_download_throttle 0 1 261 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether the nonblocking downloads will be bandwidth-limited.  See</span>
 <span class="s0">* set_download_throttle().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool HTTPChannel::get_download_throttle(void) const;</span>

<span class="s0">658 24 set_max_bytes_per_second 0 4 823 37 HTTPChannel::set_max_bytes_per_second 0 1 262 178</span>
<span class="s0">/**</span>
 <span class="s0">* When bandwidth throttling is in effect (see set_download_throttle()), this</span>
 <span class="s0">* specifies the maximum number of bytes per second that may be consumed by</span>
 <span class="s0">* this channel.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline void HTTPChannel::set_max_bytes_per_second(double max_bytes_per_second);</span>

<span class="s0">659 24 get_max_bytes_per_second 0 4 823 37 HTTPChannel::get_max_bytes_per_second 0 1 263 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum number of bytes per second that may be consumed by this</span>
 <span class="s0">* channel when get_download_throttle() is true.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline double HTTPChannel::get_max_bytes_per_second(void) const;</span>

<span class="s0">660 26 set_max_updates_per_second 0 4 823 39 HTTPChannel::set_max_updates_per_second 0 1 264 194</span>
<span class="s0">/**</span>
 <span class="s0">* When bandwidth throttling is in effect (see set_download_throttle()), this</span>
 <span class="s0">* specifies the maximum number of times per second that run() will attempt to</span>
 <span class="s0">* do any downloading at all.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void HTTPChannel::set_max_updates_per_second(double max_updates_per_second);</span>

<span class="s0">661 26 get_max_updates_per_second 0 4 823 39 HTTPChannel::get_max_updates_per_second 0 1 265 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum number of times per second that run() will do anything</span>
 <span class="s0">* at all, when get_download_throttle() is true.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline double HTTPChannel::get_max_updates_per_second(void) const;</span>

<span class="s0">662 16 set_content_type 0 4 823 29 HTTPChannel::set_content_type 0 1 266 127</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the Content-Type header, useful for applications that require</span>
 <span class="s0">* different types of content, such as JSON.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void HTTPChannel::set_content_type(std::string content_type);</span>

<span class="s0">663 16 get_content_type 0 4 823 29 HTTPChannel::get_content_type 0 1 267 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value of the Content-Type header.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::string HTTPChannel::get_content_type(void) const;</span>

<span class="s0">664 22 set_expected_file_size 0 4 823 35 HTTPChannel::set_expected_file_size 0 1 268 320</span>
<span class="s0">/**</span>
 <span class="s0">* This may be called immediately after a call to get_document() or some</span>
 <span class="s0">* related function to specify the expected size of the document we are</span>
 <span class="s0">* retrieving, if we happen to know.  This is used as the return value to</span>
 <span class="s0">* get_file_size() only in the case that the server does not tell us the</span>
 <span class="s0">* actual file size.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void HTTPChannel::set_expected_file_size(std::size_t file_size);</span>

<span class="s0">665 13 get_file_size 0 4 823 26 HTTPChannel::get_file_size 0 1 269 506</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of the file, if it is known.  Returns the value set by</span>
 <span class="s0">* set_expected_file_size() if the file size is not known, or 0 if this value</span>
 <span class="s0">* was not set.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is dynamically generated, the size may not be available until a</span>
 <span class="s0">* read has started (e.g.  open_read_body() has been called); and even then it</span>
 <span class="s0">* may increase as more of the file is read due to the nature of HTTP/1.1</span>
 <span class="s0">* requests which can change their minds midstream about how much data they're</span>
 <span class="s0">* sending you.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">std::streamsize HTTPChannel::get_file_size(void) const;</span>

<span class="s0">666 18 is_file_size_known 0 4 823 31 HTTPChannel::is_file_size_known 0 1 270 327</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the size of the file we are currently retrieving was told</span>
 <span class="s0">* us by the server and thus is reliably known, or false if the size reported</span>
 <span class="s0">* by get_file_size() represents an educated guess (possibly as set by</span>
 <span class="s0">* set_expected_file_size(), or as inferred from a chunked transfer encoding</span>
 <span class="s0">* in progress).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool HTTPChannel::is_file_size_known(void) const;</span>

<span class="s0">667 24 get_first_byte_requested 0 4 823 37 HTTPChannel::get_first_byte_requested 0 1 271 289</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first byte of the file requested by the request.  This will</span>
 <span class="s0">* normally be 0 to indicate that the file is being requested from the</span>
 <span class="s0">* beginning, but if the file was requested via a get_subdocument() call, this</span>
 <span class="s0">* will contain the first_byte parameter from that call.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline std::size_t HTTPChannel::get_first_byte_requested(void) const;</span>

<span class="s0">668 23 get_last_byte_requested 0 4 823 36 HTTPChannel::get_last_byte_requested 0 1 272 285</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the last byte of the file requested by the request.  This will</span>
 <span class="s0">* normally be 0 to indicate that the file is being requested to its last</span>
 <span class="s0">* byte, but if the file was requested via a get_subdocument() call, this will</span>
 <span class="s0">* contain the last_byte parameter from that call.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline std::size_t HTTPChannel::get_last_byte_requested(void) const;</span>

<span class="s0">669 24 get_first_byte_delivered 0 4 823 37 HTTPChannel::get_first_byte_delivered 0 1 273 367</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first byte of the file (that will be) delivered by the server</span>
 <span class="s0">* in response to the current request.  Normally, this is the same as</span>
 <span class="s0">* get_first_byte_requested(), but some servers will ignore a subdocument</span>
 <span class="s0">* request and always return the whole file, in which case this value will be</span>
 <span class="s0">* 0, regardless of what was requested to get_subdocument().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline std::size_t HTTPChannel::get_first_byte_delivered(void) const;</span>

<span class="s0">670 23 get_last_byte_delivered 0 4 823 36 HTTPChannel::get_last_byte_delivered 0 1 274 365</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the last byte of the file (that will be) delivered by the server in</span>
 <span class="s0">* response to the current request.  Normally, this is the same as</span>
 <span class="s0">* get_last_byte_requested(), but some servers will ignore a subdocument</span>
 <span class="s0">* request and always return the whole file, in which case this value will be</span>
 <span class="s0">* 0, regardless of what was requested to get_subdocument().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline std::size_t HTTPChannel::get_last_byte_delivered(void) const;</span>

<span class="s0">671 13 write_headers 0 4 823 26 HTTPChannel::write_headers 0 1 275 97</span>
<span class="s0">/**</span>
 <span class="s0">* Outputs a list of all headers defined by the server to the indicated output</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void HTTPChannel::write_headers(std::ostream &amp;out) const;</span>

<span class="s0">672 5 reset 0 4 823 18 HTTPChannel::reset 0 1 276 538</span>
<span class="s0">/**</span>
 <span class="s0">* Stops whatever file transaction is currently in progress, closes the</span>
 <span class="s0">* connection, and resets to begin anew.  You shouldn't ever need to call</span>
 <span class="s0">* this, since the channel should be able to reset itself cleanly between</span>
 <span class="s0">* requests, but it is provided in case you are an especially nervous type.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this after every request unless you set</span>
 <span class="s0">* set_persistent_connection() to false, since calling reset() rudely closes</span>
 <span class="s0">* the connection regardless of whether we have told the server we intend to</span>
 <span class="s0">* keep it open or not.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline void HTTPChannel::reset(void);</span>

<span class="s0">673 15 preserve_status 0 4 823 28 HTTPChannel::preserve_status 0 1 277 487</span>
<span class="s0">/**</span>
 <span class="s0">* Preserves the previous status code (presumably a failure) from the previous</span>
 <span class="s0">* connection attempt.  If the subsequent connection attempt also fails, the</span>
 <span class="s0">* returned status code will be the better of the previous code and the</span>
 <span class="s0">* current code.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be called to daisy-chain subsequent attempts to download the same</span>
 <span class="s0">* document from different servers.  After all servers have been attempted,</span>
 <span class="s0">* the final status code will reflect the attempt that most nearly succeeded.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void HTTPChannel::preserve_status(void);</span>

<span class="s0">674 19 clear_extra_headers 0 4 823 32 HTTPChannel::clear_extra_headers 0 1 278 99</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the extra headers that were previously added via calls to</span>
 <span class="s0">* send_extra_header().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void HTTPChannel::clear_extra_headers(void);</span>

<span class="s0">675 17 send_extra_header 0 4 823 30 HTTPChannel::send_extra_header 0 1 279 352</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies an additional key: value pair that is added into the header sent</span>
 <span class="s0">* to the server with the next request.  This is passed along with no</span>
 <span class="s0">* interpretation by the HTTPChannel code.  You may call this repeatedly to</span>
 <span class="s0">* append multiple headers.</span>
 <span class="s0">*</span>
 <span class="s0">* This is persistent for one request only; it must be set again for each new</span>
 <span class="s0">* request.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline void HTTPChannel::send_extra_header(std::string const &amp;key, std::string const &amp;value);</span>

<span class="s0">676 12 get_document 0 4 823 25 HTTPChannel::get_document 0 1 280 111</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the named document for reading, if available.  Returns true if</span>
 <span class="s0">* successful, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline bool HTTPChannel::get_document(DocumentSpec const &amp;url);</span>

<span class="s0">677 15 get_subdocument 0 4 823 28 HTTPChannel::get_subdocument 0 1 281 313</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves only the specified byte range of the indicated document.  If</span>
 <span class="s0">* last_byte is 0, it stands for the last byte of the document.  When a</span>
 <span class="s0">* subdocument is requested, get_file_size() and get_bytes_downloaded() will</span>
 <span class="s0">* report the number of bytes of the subdocument, not of the complete</span>
 <span class="s0">* document.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">inline bool HTTPChannel::get_subdocument(DocumentSpec const &amp;url, std::size_t first_byte, std::size_t last_byte);</span>

<span class="s0">678 10 get_header 0 4 823 23 HTTPChannel::get_header 0 1 282 252</span>
<span class="s0">/**</span>
 <span class="s0">* Like get_document(), except only the header associated with the document is</span>
 <span class="s0">* retrieved.  This may be used to test for existence of the document; it</span>
 <span class="s0">* might also return the size of the document (if the server gives us this</span>
 <span class="s0">* information).</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool HTTPChannel::get_header(DocumentSpec const &amp;url);</span>

<span class="s0">679 9 post_form 0 4 823 22 HTTPChannel::post_form 0 1 283 74</span>
<span class="s0">/**</span>
 <span class="s0">* Posts form data to a particular URL and retrieves the response.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline bool HTTPChannel::post_form(DocumentSpec const &amp;url, std::string const &amp;body);</span>

<span class="s0">680 12 put_document 0 4 823 25 HTTPChannel::put_document 0 1 284 111</span>
<span class="s0">/**</span>
 <span class="s0">* Uploads the indicated body to the server to replace the indicated URL, if</span>
 <span class="s0">* the server allows this.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">inline bool HTTPChannel::put_document(DocumentSpec const &amp;url, std::string const &amp;body);</span>

<span class="s0">681 15 delete_document 0 4 823 28 HTTPChannel::delete_document 0 1 285 59</span>
<span class="s0">/**</span>
 <span class="s0">* Requests the server to remove the indicated URL.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline bool HTTPChannel::delete_document(DocumentSpec const &amp;url);</span>

<span class="s0">682 9 get_trace 0 4 823 22 HTTPChannel::get_trace 0 1 286 159</span>
<span class="s0">/**</span>
 <span class="s0">* Sends a TRACE message to the server, which should return back the same</span>
 <span class="s0">* message as the server received it, allowing inspection of proxy hops, etc.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool HTTPChannel::get_trace(DocumentSpec const &amp;url);</span>

<span class="s0">683 10 connect_to 0 4 823 23 HTTPChannel::connect_to 0 1 287 319</span>
<span class="s0">/**</span>
 <span class="s0">* Establish a direct connection to the server and port indicated by the URL,</span>
 <span class="s0">* but do not issue any HTTP requests.  If successful, the connection may then</span>
 <span class="s0">* be taken to use for whatever purposes you like by calling get_connection().</span>
 <span class="s0">*</span>
 <span class="s0">* This establishes a blocking I/O socket.  Also see begin_connect_to().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool HTTPChannel::connect_to(DocumentSpec const &amp;url);</span>

<span class="s0">684 11 get_options 0 4 823 24 HTTPChannel::get_options 0 1 288 136</span>
<span class="s0">/**</span>
 <span class="s0">* Sends an OPTIONS message to the server, which should query the available</span>
 <span class="s0">* options, possibly in relation to a specified URL.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool HTTPChannel::get_options(DocumentSpec const &amp;url);</span>

<span class="s0">685 18 begin_get_document 0 4 823 31 HTTPChannel::begin_get_document 0 1 289 445</span>
<span class="s0">/**</span>
 <span class="s0">* Begins a non-blocking request to retrieve a given document.  This method</span>
 <span class="s0">* will return immediately, even before a connection to the server has</span>
 <span class="s0">* necessarily been established; you must then call run() from time to time</span>
 <span class="s0">* until the return value of run() is false.  Then you may check is_valid()</span>
 <span class="s0">* and get_status_code() to determine the status of your request.</span>
 <span class="s0">*</span>
 <span class="s0">* If a previous request had been pending, that request is discarded.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void HTTPChannel::begin_get_document(DocumentSpec const &amp;url);</span>

<span class="s0">686 21 begin_get_subdocument 0 4 823 34 HTTPChannel::begin_get_subdocument 0 1 290 345</span>
<span class="s0">/**</span>
 <span class="s0">* Begins a non-blocking request to retrieve only the specified byte range of</span>
 <span class="s0">* the indicated document.  If last_byte is 0, it stands for the last byte of</span>
 <span class="s0">* the document.  When a subdocument is requested, get_file_size() and</span>
 <span class="s0">* get_bytes_downloaded() will report the number of bytes of the subdocument,</span>
 <span class="s0">* not of the complete document.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">inline void HTTPChannel::begin_get_subdocument(DocumentSpec const &amp;url, std::size_t first_byte, std::size_t last_byte);</span>

<span class="s0">687 16 begin_get_header 0 4 823 29 HTTPChannel::begin_get_header 0 1 291 115</span>
<span class="s0">/**</span>
 <span class="s0">* Begins a non-blocking request to retrieve a given header.  See</span>
 <span class="s0">* begin_get_document() and get_header().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void HTTPChannel::begin_get_header(DocumentSpec const &amp;url);</span>

<span class="s0">688 15 begin_post_form 0 4 823 28 HTTPChannel::begin_post_form 0 1 292 431</span>
<span class="s0">/**</span>
 <span class="s0">* Posts form data to a particular URL and retrieves the response, all using</span>
 <span class="s0">* non-blocking I/O.  See begin_get_document() and post_form().</span>
 <span class="s0">*</span>
 <span class="s0">* It is important to note that you *must* call run() repeatedly after calling</span>
 <span class="s0">* this method until run() returns false, and you may not call any other</span>
 <span class="s0">* document posting or retrieving methods using the HTTPChannel object in the</span>
 <span class="s0">* interim, or your form data may not get posted.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline void HTTPChannel::begin_post_form(DocumentSpec const &amp;url, std::string const &amp;body);</span>

<span class="s0">689 3 run 0 4 823 16 HTTPChannel::run 0 1 293 425</span>
<span class="s0">/**</span>
 <span class="s0">* This must be called from time to time when non-blocking I/O is in use.  It</span>
 <span class="s0">* checks for data coming in on the socket and writes data out to the socket</span>
 <span class="s0">* when possible, and does whatever processing is required towards completing</span>
 <span class="s0">* the current task.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the task is still pending (and run() will need</span>
 <span class="s0">* to be called again in the future), or false if the current task is</span>
 <span class="s0">* complete.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">bool HTTPChannel::run(void);</span>

<span class="s0">690 16 begin_connect_to 0 4 823 29 HTTPChannel::begin_connect_to 0 1 294 536</span>
<span class="s0">/**</span>
 <span class="s0">* Begins a non-blocking request to establish a direct connection to the</span>
 <span class="s0">* server and port indicated by the URL.  No HTTP requests will be issued</span>
 <span class="s0">* beyond what is necessary to establish the connection.  When run() has</span>
 <span class="s0">* finished, you may call is_connection_ready() to determine if the connection</span>
 <span class="s0">* was successfully established.</span>
 <span class="s0">*</span>
 <span class="s0">* If successful, the connection may then be taken to use for whatever</span>
 <span class="s0">* purposes you like by calling get_connection().</span>
 <span class="s0">*</span>
 <span class="s0">* This establishes a nonblocking I/O socket.  Also see connect_to().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void HTTPChannel::begin_connect_to(DocumentSpec const &amp;url);</span>

<span class="s0">691 14 open_read_body 0 4 823 27 HTTPChannel::open_read_body 0 1 295 569</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated istream suitable for reading the body of the</span>
 <span class="s0">* document.  This may only be called immediately after a call to</span>
 <span class="s0">* get_document() or post_form(), or after a call to run() has returned false.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that, in nonblocking mode, the returned stream may report an early</span>
 <span class="s0">* EOF, even before the actual end of file.  When this happens, you should</span>
 <span class="s0">* call stream-&gt;is_closed() to determine whether you should attempt to read</span>
 <span class="s0">* some more later.</span>
 <span class="s0">*</span>
 <span class="s0">* The user is responsible for passing the returned istream to</span>
 <span class="s0">* close_read_body() later.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">ISocketStream *HTTPChannel::open_read_body(void);</span>

<span class="s0">692 15 close_read_body 0 4 823 28 HTTPChannel::close_read_body 0 1 296 243</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_body().  This really</span>
 <span class="s0">* just deletes the istream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void HTTPChannel::close_read_body(std::istream *stream) const;</span>

<span class="s0">693 16 download_to_file 0 4 823 29 HTTPChannel::download_to_file 0 1 297 1345</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the name of a file to download the resulting document to.  This</span>
 <span class="s0">* should be called immediately after get_document() or begin_get_document()</span>
 <span class="s0">* or related functions.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of the blocking I/O methods like get_document(), this function</span>
 <span class="s0">* will download the entire document to the file and return true if it was</span>
 <span class="s0">* successfully downloaded, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of non-blocking I/O methods like begin_get_document(), this</span>
 <span class="s0">* function simply indicates an intention to download to the indicated file.</span>
 <span class="s0">* It returns true if the file can be opened for writing, false otherwise, but</span>
 <span class="s0">* the contents will not be completely downloaded until run() has returned</span>
 <span class="s0">* false.  At this time, it is possible that a communications error will have</span>
 <span class="s0">* left a partial file, so is_download_complete() may be called to test this.</span>
 <span class="s0">*</span>
 <span class="s0">* If subdocument_resumes is true and the document in question was previously</span>
 <span class="s0">* requested as a subdocument (i.e.  get_subdocument() with a first_byte value</span>
 <span class="s0">* greater than zero), this will automatically seek to the appropriate byte</span>
 <span class="s0">* within the file for writing the output.  In this case, the file must</span>
 <span class="s0">* already exist and must have at least first_byte bytes in it.  If</span>
 <span class="s0">* subdocument_resumes is false, a subdocument will always be downloaded</span>
 <span class="s0">* beginning at the first byte of the file.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">bool HTTPChannel::download_to_file(Filename const &amp;filename, bool subdocument_resumes = true);</span>

<span class="s0">694 15 download_to_ram 0 4 823 28 HTTPChannel::download_to_ram 0 1 298 1223</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a Ramfile object to download the resulting document to.  This</span>
 <span class="s0">* should be called immediately after get_document() or begin_get_document()</span>
 <span class="s0">* or related functions.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of the blocking I/O methods like get_document(), this function</span>
 <span class="s0">* will download the entire document to the Ramfile and return true if it was</span>
 <span class="s0">* successfully downloaded, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of non-blocking I/O methods like begin_get_document(), this</span>
 <span class="s0">* function simply indicates an intention to download to the indicated</span>
 <span class="s0">* Ramfile.  It returns true if the file can be opened for writing, false</span>
 <span class="s0">* otherwise, but the contents will not be completely downloaded until run()</span>
 <span class="s0">* has returned false.  At this time, it is possible that a communications</span>
 <span class="s0">* error will have left a partial file, so is_download_complete() may be</span>
 <span class="s0">* called to test this.</span>
 <span class="s0">*</span>
 <span class="s0">* If subdocument_resumes is true and the document in question was previously</span>
 <span class="s0">* requested as a subdocument (i.e.  get_subdocument() with a first_byte value</span>
 <span class="s0">* greater than zero), this will automatically seek to the appropriate byte</span>
 <span class="s0">* within the Ramfile for writing the output.  In this case, the Ramfile must</span>
 <span class="s0">* already have at least first_byte bytes in it.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">bool HTTPChannel::download_to_ram(Ramfile *ramfile, bool subdocument_resumes = true);</span>

<span class="s0">695 18 download_to_stream 0 4 823 31 HTTPChannel::download_to_stream 0 1 299 1348</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the name of an ostream to download the resulting document to.</span>
 <span class="s0">* This should be called immediately after get_document() or</span>
 <span class="s0">* begin_get_document() or related functions.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of the blocking I/O methods like get_document(), this function</span>
 <span class="s0">* will download the entire document to the file and return true if it was</span>
 <span class="s0">* successfully downloaded, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of non-blocking I/O methods like begin_get_document(), this</span>
 <span class="s0">* function simply indicates an intention to download to the indicated file.</span>
 <span class="s0">* It returns true if the file can be opened for writing, false otherwise, but</span>
 <span class="s0">* the contents will not be completely downloaded until run() has returned</span>
 <span class="s0">* false.  At this time, it is possible that a communications error will have</span>
 <span class="s0">* left a partial file, so is_download_complete() may be called to test this.</span>
 <span class="s0">*</span>
 <span class="s0">* If subdocument_resumes is true and the document in question was previously</span>
 <span class="s0">* requested as a subdocument (i.e.  get_subdocument() with a first_byte value</span>
 <span class="s0">* greater than zero), this will automatically seek to the appropriate byte</span>
 <span class="s0">* within the file for writing the output.  In this case, the file must</span>
 <span class="s0">* already exist and must have at least first_byte bytes in it.  If</span>
 <span class="s0">* subdocument_resumes is false, a subdocument will always be downloaded</span>
 <span class="s0">* beginning at the first byte of the file.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">bool HTTPChannel::download_to_stream(std::ostream *strm, bool subdocument_resumes = true);</span>

<span class="s0">696 14 get_connection 0 4 823 27 HTTPChannel::get_connection 0 1 300 351</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the connection that was established via a previous call to</span>
 <span class="s0">* connect_to() or begin_connect_to(), or NULL if the connection attempt</span>
 <span class="s0">* failed or if those methods have not recently been called.</span>
 <span class="s0">*</span>
 <span class="s0">* This stream has been allocated from the free store.  It is the user's</span>
 <span class="s0">* responsibility to delete this pointer when finished with it.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">SocketStream *HTTPChannel::get_connection(void);</span>

<span class="s0">697 20 get_bytes_downloaded 0 4 823 33 HTTPChannel::get_bytes_downloaded 0 1 301 331</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes downloaded during the last (or current)</span>
 <span class="s0">* download_to_file() or download_to_ram operation().  This can be used in</span>
 <span class="s0">* conjunction with get_file_size() to report the percent complete (but be</span>
 <span class="s0">* careful, since get_file_size() may return 0 if the server has not told us</span>
 <span class="s0">* the size of the file).</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline std::size_t HTTPChannel::get_bytes_downloaded(void) const;</span>

<span class="s0">698 19 get_bytes_requested 0 4 823 32 HTTPChannel::get_bytes_requested 0 1 302 658</span>
<span class="s0">/**</span>
 <span class="s0">* When download throttling is in effect (set_download_throttle() has been set</span>
 <span class="s0">* to true) and non-blocking I/O methods (like begin_get_document()) are used,</span>
 <span class="s0">* this returns the number of bytes &quot;requested&quot; from the server so far: that</span>
 <span class="s0">* is, the theoretical maximum value for get_bytes_downloaded(), if the server</span>
 <span class="s0">* has been keeping up with our demand.</span>
 <span class="s0">*</span>
 <span class="s0">* If this number is less than get_bytes_downloaded(), then the server has not</span>
 <span class="s0">* been supplying bytes fast enough to meet our own download throttle rate.</span>
 <span class="s0">*</span>
 <span class="s0">* When download throttling is not in effect, or when the blocking I/O methods</span>
 <span class="s0">* (like get_document(), etc.) are used, this returns 0.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t HTTPChannel::get_bytes_requested(void) const;</span>

<span class="s0">699 20 is_download_complete 0 4 823 33 HTTPChannel::is_download_complete 0 1 303 600</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true when a download_to() or download_to_ram() has executed and the</span>
 <span class="s0">* file has been fully downloaded.  If this still returns false after</span>
 <span class="s0">* processing has completed, there was an error in transmission.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simply testing is_download_complete() does not prove that the</span>
 <span class="s0">* requested document was successfully retrieved--you might have just</span>
 <span class="s0">* downloaded the &quot;404 not found&quot; stub (for instance) that a server would</span>
 <span class="s0">* provide in response to some error condition.  You should also check</span>
 <span class="s0">* is_valid() to prove that the file you expected has been successfully</span>
 <span class="s0">* retrieved.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool HTTPChannel::is_download_complete(void) const;</span>

<span class="s0">700 14 get_class_type 0 4 823 27 HTTPChannel::get_class_type 0 1 304 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle HTTPChannel::get_class_type(void);</span>

<span class="s0">701 11 HTTPChannel 0 260 823 24 HTTPChannel::HTTPChannel 0 1 227 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline HTTPChannel::HTTPChannel(HTTPChannel const &amp;) = default;</span>

<span class="s0">702 12 Decompressor 0 260 826 26 Decompressor::Decompressor 0 2 305 306 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">Decompressor::Decompressor(void);</span>
<span class="s0">inline Decompressor::Decompressor(Decompressor const &amp;) = default;</span>

<span class="s0">703 13 ~Decompressor 0 516 826 27 Decompressor::~Decompressor 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">Decompressor::~Decompressor(void);</span>

<span class="s0">704 8 initiate 0 4 826 22 Decompressor::initiate 0 2 307 308 365</span>
<span class="s0">/**</span>
 <span class="s0">* Begins a background decompression of the named file (whose filename must</span>
 <span class="s0">* end in &quot;.pz&quot;) to a new file without the .pz extension.  The source file is</span>
 <span class="s0">* removed after successful completion.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Begins a background decompression from the named source file to the named</span>
 <span class="s0">* destination file.  The source file is removed after successful completion.</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">int Decompressor::initiate(Filename const &amp;source_file);</span>
<span class="s0">int Decompressor::initiate(Filename const &amp;source_file, Filename const &amp;dest_file);</span>

<span class="s0">705 3 run 0 4 826 17 Decompressor::run 0 1 309 227</span>
<span class="s0">/**</span>
 <span class="s0">* Called each frame to do the next bit of work in the background task.</span>
 <span class="s0">* Returns EU_ok if a chunk is completed but there is more to go, or</span>
 <span class="s0">* EU_success when we're all done.  Any other return value indicates an error.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">int Decompressor::run(void);</span>

<span class="s0">706 10 decompress 0 4 826 24 Decompressor::decompress 0 2 310 311 275</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a foreground decompression of the named file; does not return</span>
 <span class="s0">* until the decompression is complete.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Does an in-memory decompression of the indicated Ramfile.  The decompressed</span>
 <span class="s0">* contents are written back into the same Ramfile on completion.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">bool Decompressor::decompress(Filename const &amp;source_file);</span>
<span class="s0">bool Decompressor::decompress(Ramfile &amp;source_and_dest_file);</span>

<span class="s0">707 12 get_progress 0 4 826 26 Decompressor::get_progress 0 1 312 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ratio through the decompression step in the background.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">PN_stdfloat Decompressor::get_progress(void) const;</span>

<span class="s0">708 10 DownloadDb 0 260 829 22 DownloadDb::DownloadDb 0 4 313 314 315 316 170</span>
<span class="s0">/**</span>
 <span class="s0">* Create a download db with these client and server dbs</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Create a download db with these client and server dbs</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Primarily used for testing.</span>
 <span class="s0">*/</span>
<span class="s0">247</span>
<span class="s0">DownloadDb::DownloadDb(void);</span>
<span class="s0">explicit DownloadDb::DownloadDb(Ramfile &amp;server_file, Filename &amp;client_file);</span>
<span class="s0">explicit DownloadDb::DownloadDb(Filename &amp;server_file, Filename &amp;client_file);</span>
<span class="s0">inline DownloadDb::DownloadDb(DownloadDb const &amp;) = default;</span>

<span class="s0">709 11 ~DownloadDb 0 516 829 23 DownloadDb::~DownloadDb 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">DownloadDb::~DownloadDb(void);</span>

<span class="s0">710 6 output 0 4 829 18 DownloadDb::output 0 1 317 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void DownloadDb::output(std::ostream &amp;out) const;</span>

<span class="s0">711 5 write 0 4 829 17 DownloadDb::write 0 1 318 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void DownloadDb::write(std::ostream &amp;out) const;</span>

<span class="s0">712 17 write_version_map 0 4 829 29 DownloadDb::write_version_map 0 1 319 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void DownloadDb::write_version_map(std::ostream &amp;out) const;</span>

<span class="s0">713 15 write_client_db 0 4 829 27 DownloadDb::write_client_db 0 1 320 36</span>
<span class="s0">// Write a database file</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">bool DownloadDb::write_client_db(Filename &amp;file);</span>

<span class="s0">714 15 write_server_db 0 4 829 27 DownloadDb::write_server_db 0 1 321 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">bool DownloadDb::write_server_db(Filename &amp;file);</span>

<span class="s0">715 25 get_client_num_multifiles 0 4 829 37 DownloadDb::get_client_num_multifiles 0 1 322 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int DownloadDb::get_client_num_multifiles(void) const;</span>

<span class="s0">716 25 get_server_num_multifiles 0 4 829 37 DownloadDb::get_server_num_multifiles 0 1 323 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int DownloadDb::get_server_num_multifiles(void) const;</span>

<span class="s0">717 25 get_client_multifile_name 0 4 829 37 DownloadDb::get_client_multifile_name 0 1 324 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline std::string DownloadDb::get_client_multifile_name(int index) const;</span>

<span class="s0">718 25 get_server_multifile_name 0 4 829 37 DownloadDb::get_server_multifile_name 0 1 325 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline std::string DownloadDb::get_server_multifile_name(int index) const;</span>

<span class="s0">719 25 get_client_multifile_size 0 4 829 37 DownloadDb::get_client_multifile_size 0 1 326 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline int DownloadDb::get_client_multifile_size(std::string mfname) const;</span>

<span class="s0">720 25 set_client_multifile_size 0 4 829 37 DownloadDb::set_client_multifile_size 0 1 327 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline void DownloadDb::set_client_multifile_size(std::string mfname, int size);</span>

<span class="s0">721 31 set_client_multifile_delta_size 0 4 829 43 DownloadDb::set_client_multifile_delta_size 0 1 328 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline int DownloadDb::set_client_multifile_delta_size(std::string mfname, int size);</span>

<span class="s0">722 25 get_server_multifile_size 0 4 829 37 DownloadDb::get_server_multifile_size 0 1 329 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline int DownloadDb::get_server_multifile_size(std::string mfname) const;</span>

<span class="s0">723 25 set_server_multifile_size 0 4 829 37 DownloadDb::set_server_multifile_size 0 1 330 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline void DownloadDb::set_server_multifile_size(std::string mfname, int size);</span>

<span class="s0">724 26 get_client_multifile_phase 0 4 829 38 DownloadDb::get_client_multifile_phase 0 1 331 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline Phase DownloadDb::get_client_multifile_phase(std::string mfname) const;</span>

<span class="s0">725 26 get_server_multifile_phase 0 4 829 38 DownloadDb::get_server_multifile_phase 0 1 332 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline Phase DownloadDb::get_server_multifile_phase(std::string mfname) const;</span>

<span class="s0">726 31 set_client_multifile_incomplete 0 4 829 43 DownloadDb::set_client_multifile_incomplete 0 1 333 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void DownloadDb::set_client_multifile_incomplete(std::string mfname);</span>

<span class="s0">727 29 set_client_multifile_complete 0 4 829 41 DownloadDb::set_client_multifile_complete 0 1 334 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void DownloadDb::set_client_multifile_complete(std::string mfname);</span>

<span class="s0">728 33 set_client_multifile_decompressed 0 4 829 45 DownloadDb::set_client_multifile_decompressed 0 1 335 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline void DownloadDb::set_client_multifile_decompressed(std::string mfname);</span>

<span class="s0">729 30 set_client_multifile_extracted 0 4 829 42 DownloadDb::set_client_multifile_extracted 0 1 336 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void DownloadDb::set_client_multifile_extracted(std::string mfname);</span>

<span class="s0">730 20 get_server_num_files 0 4 829 32 DownloadDb::get_server_num_files 0 1 337 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline int DownloadDb::get_server_num_files(std::string mfname) const;</span>

<span class="s0">731 20 get_server_file_name 0 4 829 32 DownloadDb::get_server_file_name 0 1 338 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline std::string DownloadDb::get_server_file_name(std::string mfname, int index) const;</span>

<span class="s0">732 23 client_multifile_exists 0 4 829 35 DownloadDb::client_multifile_exists 0 1 339 40</span>
<span class="s0">// Queries from the Launcher</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">bool DownloadDb::client_multifile_exists(std::string mfname) const;</span>

<span class="s0">733 25 client_multifile_complete 0 4 829 37 DownloadDb::client_multifile_complete 0 1 340 147</span>
<span class="s0">/**</span>
 <span class="s0">* A multifile is complete when it is completely downloaded.  Note: it may</span>
 <span class="s0">* already be decompressed or extracted and it is still complete</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool DownloadDb::client_multifile_complete(std::string mfname) const;</span>

<span class="s0">734 29 client_multifile_decompressed 0 4 829 41 DownloadDb::client_multifile_decompressed 0 1 341 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">bool DownloadDb::client_multifile_decompressed(std::string mfname) const;</span>

<span class="s0">735 26 client_multifile_extracted 0 4 829 38 DownloadDb::client_multifile_extracted 0 1 342 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">bool DownloadDb::client_multifile_extracted(std::string mfname) const;</span>

<span class="s0">736 25 get_client_multifile_hash 0 4 829 37 DownloadDb::get_client_multifile_hash 0 1 343 122</span>
<span class="s0">// Ask what version (told with the hash) this multifile is</span>

<span class="s0">/**</span>
 <span class="s0">* Return the hash value of the file we are working on</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">HashVal DownloadDb::get_client_multifile_hash(std::string mfname) const;</span>

<span class="s0">737 25 set_client_multifile_hash 0 4 829 37 DownloadDb::set_client_multifile_hash 0 1 344 55</span>
<span class="s0">/**</span>
 <span class="s0">* Set the hash value of file we are working on</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void DownloadDb::set_client_multifile_hash(std::string mfname, HashVal val);</span>

<span class="s0">738 25 get_server_multifile_hash 0 4 829 37 DownloadDb::get_server_multifile_hash 0 1 345 51</span>
<span class="s0">/**</span>
 <span class="s0">* Return the hash value of the server file</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">HashVal DownloadDb::get_server_multifile_hash(std::string mfname) const;</span>

<span class="s0">739 25 set_server_multifile_hash 0 4 829 37 DownloadDb::set_server_multifile_hash 0 1 346 55</span>
<span class="s0">/**</span>
 <span class="s0">* Set the hash value of file we are working on</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void DownloadDb::set_server_multifile_hash(std::string mfname, HashVal val);</span>

<span class="s0">740 23 delete_client_multifile 0 4 829 35 DownloadDb::delete_client_multifile 0 1 347 39</span>
<span class="s0">// Operations on multifiles</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void DownloadDb::delete_client_multifile(std::string mfname);</span>

<span class="s0">741 20 add_client_multifile 0 4 829 32 DownloadDb::add_client_multifile 0 1 348 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">void DownloadDb::add_client_multifile(std::string server_mfname);</span>

<span class="s0">742 23 expand_client_multifile 0 4 829 35 DownloadDb::expand_client_multifile 0 1 349 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void DownloadDb::expand_client_multifile(std::string mfname);</span>

<span class="s0">743 20 create_new_server_db 0 4 829 32 DownloadDb::create_new_server_db 0 1 350 131</span>
<span class="s0">// Server side operations to create multifile records</span>

<span class="s0">/**</span>
 <span class="s0">* Used on the server side makefiles to create a new clean server db</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void DownloadDb::create_new_server_db(void);</span>

<span class="s0">744 20 server_add_multifile 0 4 829 32 DownloadDb::server_add_multifile 0 1 351 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">void DownloadDb::server_add_multifile(std::string mfname, Phase phase, int size, int status);</span>

<span class="s0">745 15 server_add_file 0 4 829 27 DownloadDb::server_add_file 0 1 352 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void DownloadDb::server_add_file(std::string mfname, std::string fname);</span>

<span class="s0">746 7 read_db 0 4 829 19 DownloadDb::read_db 0 2 353 354 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">DownloadDb::Db DownloadDb::read_db(Filename &amp;file, bool want_server_info);</span>
<span class="s0">DownloadDb::Db DownloadDb::read_db(Ramfile &amp;file, bool want_server_info);</span>

<span class="s0">747 8 write_db 0 4 829 20 DownloadDb::write_db 0 1 355 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">bool DownloadDb::write_db(Filename &amp;file, DownloadDb::Db db, bool want_server_info);</span>

<span class="s0">748 11 add_version 0 4 829 23 DownloadDb::add_version 0 1 356 176</span>
<span class="s0">/**</span>
 <span class="s0">* Appends a new version of the file onto the end of the list, or changes the</span>
 <span class="s0">* hash associated with a version previously added.</span>
 <span class="s0">*</span>
 <span class="s0">* Note: version numbers start at 1</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">void DownloadDb::add_version(Filename const &amp;name, HashVal const &amp;hash, int version);</span>

<span class="s0">749 18 insert_new_version 0 4 829 30 DownloadDb::insert_new_version 0 1 357 97</span>
<span class="s0">/**</span>
 <span class="s0">* Inserts a new version 1 copy of the file, sliding all the other versions up</span>
 <span class="s0">* by one.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void DownloadDb::insert_new_version(Filename const &amp;name, HashVal const &amp;hash);</span>

<span class="s0">750 11 has_version 0 4 829 23 DownloadDb::has_version 0 1 358 164</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated file has version information, false</span>
 <span class="s0">* otherwise.  Some files recorded in the database may not bother to track</span>
 <span class="s0">* versions.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">bool DownloadDb::has_version(Filename const &amp;name) const;</span>

<span class="s0">751 16 get_num_versions 0 4 829 28 DownloadDb::get_num_versions 0 1 359 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of versions stored for the indicated file.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">int DownloadDb::get_num_versions(Filename const &amp;name) const;</span>

<span class="s0">752 16 set_num_versions 0 4 829 28 DownloadDb::set_num_versions 0 1 360 146</span>
<span class="s0">/**</span>
 <span class="s0">* Reduces the number of versions of a particular file stored in the ddb by</span>
 <span class="s0">* throwing away all versions higher than the indicated index.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void DownloadDb::set_num_versions(Filename const &amp;name, int num_versions);</span>

<span class="s0">753 11 get_version 0 4 829 23 DownloadDb::get_version 0 1 361 183</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the version number of this particular file, determined by looking</span>
 <span class="s0">* up the hash generated from the file.  Returns -1 if the version number</span>
 <span class="s0">* cannot be determined.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">int DownloadDb::get_version(Filename const &amp;name, HashVal const &amp;hash) const;</span>

<span class="s0">754 8 get_hash 0 4 829 20 DownloadDb::get_hash 0 1 362 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the MD5 hash associated with the indicated version of the indicated</span>
 <span class="s0">* file.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">HashVal const &amp;DownloadDb::get_hash(Filename const &amp;name, int version) const;</span>

<span class="s0">755 9 check_crc 0 1 0 9 check_crc 0 1 397 0</span>
<span class="s0">43</span>
<span class="s0">unsigned long int check_crc(Filename name);</span>

<span class="s0">756 11 check_adler 0 1 0 11 check_adler 0 1 398 0</span>
<span class="s0">45</span>
<span class="s0">unsigned long int check_adler(Filename name);</span>

<span class="s0">757 9 Extractor 0 260 831 20 Extractor::Extractor 0 1 363 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">27</span>
<span class="s0">Extractor::Extractor(void);</span>

<span class="s0">758 10 ~Extractor 0 516 831 21 Extractor::~Extractor 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">Extractor::~Extractor(void);</span>

<span class="s0">759 13 set_multifile 0 4 831 24 Extractor::set_multifile 0 1 364 147</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the filename of the Multifile that the Extractor will read.</span>
 <span class="s0">* Returns true on success, false if the mulifile name is invalid.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool Extractor::set_multifile(Filename const &amp;multifile_name);</span>

<span class="s0">760 15 set_extract_dir 0 4 831 26 Extractor::set_extract_dir 0 1 365 192</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the directory into which all extracted subfiles will be written.</span>
 <span class="s0">* Relative paths of subfiles within the Multifile will be written as relative</span>
 <span class="s0">* paths to this directory.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void Extractor::set_extract_dir(Filename const &amp;extract_dir);</span>

<span class="s0">761 5 reset 0 4 831 16 Extractor::reset 0 1 366 132</span>
<span class="s0">/**</span>
 <span class="s0">* Interrupts the Extractor in the middle of its business and makes it ready</span>
 <span class="s0">* to accept a new list of subfiles to extract.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">void Extractor::reset(void);</span>

<span class="s0">762 15 request_subfile 0 4 831 26 Extractor::request_subfile 0 1 367 145</span>
<span class="s0">/**</span>
 <span class="s0">* Requests a particular subfile to be extracted when step() or run() is</span>
 <span class="s0">* called.  Returns true if the subfile exists, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool Extractor::request_subfile(Filename const &amp;subfile_name);</span>

<span class="s0">763 20 request_all_subfiles 0 4 831 31 Extractor::request_all_subfiles 0 1 368 100</span>
<span class="s0">/**</span>
 <span class="s0">* Requests all subfiles in the Multifile to be extracted.  Returns the number</span>
 <span class="s0">* requested.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">int Extractor::request_all_subfiles(void);</span>

<span class="s0">764 4 step 0 4 831 15 Extractor::step 0 1 369 390</span>
<span class="s0">/**</span>
 <span class="s0">* After all of the requests have been made via request_file() or</span>
 <span class="s0">* request_all_subfiles(), call step() repeatedly until it stops returning</span>
 <span class="s0">* EU_ok.</span>
 <span class="s0">*</span>
 <span class="s0">* step() extracts the next small unit of data from the Multifile.  Returns</span>
 <span class="s0">* EU_ok if progress is continuing, EU_error_abort if there is a problem, or</span>
 <span class="s0">* EU_success when the last piece has been extracted.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see run().</span>
 <span class="s0">*/</span>
<span class="s0">26</span>
<span class="s0">int Extractor::step(void);</span>

<span class="s0">765 12 get_progress 0 4 831 23 Extractor::get_progress 0 1 370 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the fraction of the Multifile extracted so far.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">PN_stdfloat Extractor::get_progress(void) const;</span>

<span class="s0">766 3 run 0 4 831 14 Extractor::run 0 1 371 367</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to extract the Multifile all at once, when you don't</span>
 <span class="s0">* care about doing it in the background.</span>
 <span class="s0">*</span>
 <span class="s0">* First, call request_file() or request_all_files() to specify the files you</span>
 <span class="s0">* would like to extract, then call run() to do the extraction.  Also see</span>
 <span class="s0">* step() for when you would like the extraction to happen as a background</span>
 <span class="s0">* task.</span>
 <span class="s0">*/</span>
<span class="s0">26</span>
<span class="s0">bool Extractor::run(void);</span>

<span class="s0">767 15 MultiplexStream 0 260 832 32 MultiplexStream::MultiplexStream 0 1 372 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline MultiplexStream::MultiplexStream(void);</span>

<span class="s0">768 11 add_ostream 0 4 832 28 MultiplexStream::add_ostream 0 1 373 134</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated generic ostream to the multiplex output.  The ostream</span>
 <span class="s0">* will receive whatever data is sent to the pipe.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void MultiplexStream::add_ostream(std::ostream *out, bool delete_later = false);</span>

<span class="s0">769 14 add_stdio_file 0 4 832 31 MultiplexStream::add_stdio_file 0 1 374 104</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the given file, previously opened using the C stdio library, to the</span>
 <span class="s0">* multiplex output.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline bool MultiplexStream::add_stdio_file(FILE *file, bool close_when_done);</span>

<span class="s0">770 19 add_standard_output 0 4 832 36 MultiplexStream::add_standard_output 0 1 375 44</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the standard output channel.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void MultiplexStream::add_standard_output(void);</span>

<span class="s0">771 8 add_file 0 4 832 25 MultiplexStream::add_file 0 1 376 159</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the given file to the multiplex output.  The file is opened in append</span>
 <span class="s0">* mode with line buffering.  Returns false if the file cannot be opened.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool MultiplexStream::add_file(Filename file);</span>

<span class="s0">772 16 add_system_debug 0 4 832 33 MultiplexStream::add_system_debug 0 1 377 247</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the system debug output the the multiplex output.  This may map to a</span>
 <span class="s0">* syslog or some such os-specific output system.  It may do nothing on a</span>
 <span class="s0">* particular system.</span>
 <span class="s0">*</span>
 <span class="s0">* Presently, this maps only to OutputDebugString() on Windows.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void MultiplexStream::add_system_debug(void);</span>

<span class="s0">773 5 flush 0 4 832 22 MultiplexStream::flush 0 1 378 62</span>
<span class="s0">/**</span>
 <span class="s0">* Forces out all output that hasn't yet been written.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void MultiplexStream::flush(void);</span>

<span class="s0">774 16 ~MultiplexStream 0 516 832 33 MultiplexStream::~MultiplexStream 0 0 0</span>
<span class="s0">40</span>
<span class="s0">MultiplexStream::~MultiplexStream(void);</span>

<span class="s0">775 14 get_class_type 0 4 833 31 VirtualFileHTTP::get_class_type 0 1 379 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle VirtualFileHTTP::get_class_type(void);</span>

<span class="s0">776 20 VirtualFileMountHTTP 0 260 835 42 VirtualFileMountHTTP::VirtualFileMountHTTP 0 1 380 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">explicit VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &amp;root, HTTPClient *http = HTTPClient::get_global_ptr());</span>

<span class="s0">777 15 get_http_client 0 4 835 37 VirtualFileMountHTTP::get_http_client 0 1 381 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HTTPClient object that services this mount point.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline HTTPClient *VirtualFileMountHTTP::get_http_client(void) const;</span>

<span class="s0">778 8 get_root 0 4 835 30 VirtualFileMountHTTP::get_root 0 1 382 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the URL that represents the root of this mount point.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline URLSpec const &amp;VirtualFileMountHTTP::get_root(void) const;</span>

<span class="s0">779 20 reload_vfs_mount_url 0 4 835 42 VirtualFileMountHTTP::reload_vfs_mount_url 0 1 383 396</span>
<span class="s0">/**</span>
 <span class="s0">* Reads all of the vfs-mount-url lines in the Config.prc file and replaces</span>
 <span class="s0">* the mount settings to match them.</span>
 <span class="s0">*</span>
 <span class="s0">* This will mount any url's mentioned in the config file, and unmount and</span>
 <span class="s0">* unmount any url's no longer mentioned in the config file.  Normally, it is</span>
 <span class="s0">* called automatically at startup, and need not be called again, unless you</span>
 <span class="s0">* have fiddled with some config settings.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">static void VirtualFileMountHTTP::reload_vfs_mount_url(void);</span>

<span class="s0">780 14 get_class_type 0 4 835 36 VirtualFileMountHTTP::get_class_type 0 1 384 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle VirtualFileMountHTTP::get_class_type(void);</span>

<span class="s0">781 7 Patcher 0 260 837 16 Patcher::Patcher 0 3 385 386 387 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">130</span>
<span class="s0">Patcher::Patcher(void);</span>
<span class="s0">explicit Patcher::Patcher(PointerTo&lt; Buffer &gt; buffer);</span>
<span class="s0">inline Patcher::Patcher(Patcher const &amp;) = default;</span>

<span class="s0">782 8 ~Patcher 0 518 837 17 Patcher::~Patcher 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">virtual Patcher::~Patcher(void);</span>

<span class="s0">783 8 initiate 0 4 837 17 Patcher::initiate 0 1 388 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">int Patcher::initiate(Filename &amp;patch, Filename &amp;infile);</span>

<span class="s0">784 3 run 0 4 837 12 Patcher::run 0 1 389 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">23</span>
<span class="s0">int Patcher::run(void);</span>

<span class="s0">785 12 get_progress 0 4 837 21 Patcher::get_progress 0 1 390 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat Patcher::get_progress(void) const;</span>

<span class="s0">786 12 StringStream 0 260 838 26 StringStream::StringStream 0 2 391 392 102</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This version of the constructor preloads the buffer with the indicated</span>
 <span class="s0">* data.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">StringStream::StringStream(PyObject *source);</span>
<span class="s0">inline StringStream::StringStream(void);</span>

<span class="s0">787 10 clear_data 0 4 838 24 StringStream::clear_data 0 1 393 30</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the buffer.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void StringStream::clear_data(void);</span>

<span class="s0">788 13 get_data_size 0 4 838 27 StringStream::get_data_size 0 1 394 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of characters available to be read from the data stream.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::size_t StringStream::get_data_size(void);</span>

<span class="s0">789 8 get_data 0 4 838 22 StringStream::get_data 0 1 395 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the contents of the data stream as a string.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">PyObject *StringStream::get_data(void);</span>

<span class="s0">790 8 set_data 0 4 838 22 StringStream::set_data 0 1 396 168</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the contents of the data stream.  This implicitly reseeks to 0.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the contents of the data stream.  This implicitly reseeks to 0.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void StringStream::set_data(PyObject *data);</span>

<span class="s0">791 13 ~StringStream 0 516 838 27 StringStream::~StringStream 0 0 0</span>
<span class="s0">34</span>
<span class="s0">StringStream::~StringStream(void);</span>

<span class="s0">398</span>
<span class="s0">1 0 0 6 3 806 0 0 253 /**</span>
 <span class="s0">* Receives a datagram over the socket by expecting a little-endian 16-bit</span>
 <span class="s0">* byte count as a prefix.  If the socket stream is non-blocking, may return</span>
 <span class="s0">* false if the data is not available; otherwise, returns false only if the</span>
 <span class="s0">* socket closes.</span>
 <span class="s0">*/ 2 4 this 3 842  2 dg 1 843  </span>
<span class="s0">2 0 0 6 4 806 0 0 0 1 4 this 3 842  </span>
<span class="s0">3 0 0 4 5 845 0 0 0 1 4 this 3 842  </span>
<span class="s0">4 0 0 4 6 845 0 0 269 /**</span>
 <span class="s0">* Sets the header size for datagrams.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/ 2 4 this 3 842  15 tcp_header_size 1 846  </span>
<span class="s0">5 0 0 6 7 846 0 0 77 /**</span>
 <span class="s0">* Returns the header size for datagrams.  See set_tcp_header_size().</span>
 <span class="s0">*/ 1 4 this 3 847  </span>
<span class="s0">6 0 0 6 10 806 0 0 234 /**</span>
 <span class="s0">* Transmits the indicated datagram over the socket by prepending it with a</span>
 <span class="s0">* little-endian 16-bit byte count.  Does not return until the data is sent or</span>
 <span class="s0">* the connection is closed, even if the socket stream is non-blocking.</span>
 <span class="s0">*/ 2 4 this 3 849  2 dg 1 850  </span>
<span class="s0">7 0 0 6 11 806 0 0 0 1 4 this 3 849  </span>
<span class="s0">8 0 0 4 12 845 0 0 0 1 4 this 3 849  </span>
<span class="s0">9 0 0 4 13 845 0 0 719 /**</span>
 <span class="s0">* Enables or disables &quot;collect-tcp&quot; mode.  In this mode, individual TCP</span>
 <span class="s0">* packets are not sent immediately, but rather they are collected together</span>
 <span class="s0">* and accumulated to be sent periodically as one larger TCP packet.  This</span>
 <span class="s0">* cuts down on overhead from the TCP/IP protocol, especially if many small</span>
 <span class="s0">* packets need to be sent on the same connection, but it introduces</span>
 <span class="s0">* additional latency (since packets must be held before they can be sent).</span>
 <span class="s0">*</span>
 <span class="s0">* See set_collect_tcp_interval() to specify the interval of time for which to</span>
 <span class="s0">* hold packets before sending them.</span>
 <span class="s0">*</span>
 <span class="s0">* If you enable this mode, you may also need to periodically call</span>
 <span class="s0">* consider_flush() to flush the queue if no packets have been sent recently.</span>
 <span class="s0">*/ 2 4 this 3 849  11 collect_tcp 1 806  </span>
<span class="s0">10 0 0 6 14 806 0 0 85 /**</span>
 <span class="s0">* Returns the current setting of &quot;collect-tcp&quot; mode.  See set_collect_tcp().</span>
 <span class="s0">*/ 1 4 this 3 852  </span>
<span class="s0">11 0 0 4 15 845 0 0 231 /**</span>
 <span class="s0">* Specifies the interval in time, in seconds, for which to hold TCP packets</span>
 <span class="s0">* before sending all of the recently received packets at once.  This only has</span>
 <span class="s0">* meaning if &quot;collect-tcp&quot; mode is enabled; see set_collect_tcp().</span>
 <span class="s0">*/ 2 4 this 3 849  8 interval 1 854  </span>
<span class="s0">12 0 0 6 16 854 0 0 229 /**</span>
 <span class="s0">* Returns the interval in time, in seconds, for which to hold TCP packets</span>
 <span class="s0">* before sending all of the recently received packets at once.  This only has</span>
 <span class="s0">* meaning if &quot;collect-tcp&quot; mode is enabled; see set_collect_tcp().</span>
 <span class="s0">*/ 1 4 this 3 852  </span>
<span class="s0">13 0 0 4 17 845 0 0 269 /**</span>
 <span class="s0">* Sets the header size for datagrams.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/ 2 4 this 3 849  15 tcp_header_size 1 846  </span>
<span class="s0">14 0 0 6 18 846 0 0 77 /**</span>
 <span class="s0">* Returns the header size for datagrams.  See set_tcp_header_size().</span>
 <span class="s0">*/ 1 4 this 3 852  </span>
<span class="s0">15 0 0 6 19 806 0 0 143 /**</span>
 <span class="s0">* Sends the most recently queued data if enough time has elapsed.  This only</span>
 <span class="s0">* has meaning if set_collect_tcp() has been set to true.</span>
 <span class="s0">*/ 1 4 this 3 849  </span>
<span class="s0">16 0 0 6 20 806 0 0 120 /**</span>
 <span class="s0">* Sends the most recently queued data now.  This only has meaning if</span>
 <span class="s0">* set_collect_tcp() has been set to true.</span>
 <span class="s0">*/ 1 4 this 3 849  </span>
<span class="s0">17 0 0 6 29 806 0 0 0 1 4 this 3 855  </span>
<span class="s0">18 0 0 4 30 845 0 0 0 1 4 this 3 855  </span>
<span class="s0">19 0 0 6 31 796 0 0 0 1 4 this 3 855  </span>
<span class="s0">20 0 0 6 23 856 0 0 0 1 4 this 3 855  </span>
<span class="s0">21 0 0 6 25 842 0 0 0 1 4 this 3 855  </span>
<span class="s0">22 0 0 6 38 806 0 0 0 1 4 this 3 857  </span>
<span class="s0">23 0 0 4 39 845 0 0 0 1 4 this 3 857  </span>
<span class="s0">24 0 0 6 40 806 0 0 120 /**</span>
 <span class="s0">* Sends the most recently queued data now.  This only has meaning if</span>
 <span class="s0">* set_collect_tcp() has been set to true.</span>
 <span class="s0">*/ 1 4 this 3 857  </span>
<span class="s0">25 0 0 6 34 858 0 0 0 1 4 this 3 857  </span>
<span class="s0">26 0 0 6 36 849 0 0 0 1 4 this 3 857  </span>
<span class="s0">27 0 0 6 50 806 0 0 0 1 4 this 3 859  </span>
<span class="s0">28 0 0 4 51 845 0 0 0 1 4 this 3 859  </span>
<span class="s0">29 0 0 4 52 845 0 0 269 /**</span>
 <span class="s0">* Sets the header size for datagrams.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/ 2 4 this 3 859  15 tcp_header_size 1 846  </span>
<span class="s0">30 0 0 6 53 846 0 0 77 /**</span>
 <span class="s0">* Returns the header size for datagrams.  See set_tcp_header_size().</span>
 <span class="s0">*/ 1 4 this 3 860  </span>
<span class="s0">31 0 0 6 54 806 0 0 120 /**</span>
 <span class="s0">* Sends the most recently queued data now.  This only has meaning if</span>
 <span class="s0">* set_collect_tcp() has been set to true.</span>
 <span class="s0">*/ 1 4 this 3 859  </span>
<span class="s0">32 0 0 6 44 862 0 0 0 1 4 this 3 859  </span>
<span class="s0">33 0 0 6 46 842 0 0 0 1 4 this 3 859  </span>
<span class="s0">34 0 0 6 48 849 0 0 0 1 4 this 3 859  </span>
<span class="s0">35 0 0 7 57 863 495 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">36 0 0 15 57 863 495 0 0 1 6 param0 0 864  </span>
<span class="s0">37 0 0 23 57 863 495 0 135 /**</span>
 <span class="s0">* Creates a URLSpec by appending a path to the end of the old URLSpec,</span>
 <span class="s0">* inserting an intervening forward slash if necessary.</span>
 <span class="s0">*/ 2 3 url 1 864  4 path 1 865  </span>
<span class="s0">38 0 0 23 57 863 495 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 3 url 1 868  20 server_name_expected 5 806  </span>
<span class="s0">39 0 0 6 58 863 0 0 0 2 4 this 3 863  3 url 1 868  </span>
<span class="s0">40 0 0 6 59 806 0 0 0 2 4 this 3 864  5 other 1 864  </span>
<span class="s0">41 0 0 6 60 806 0 0 0 2 4 this 3 864  5 other 1 864  </span>
<span class="s0">42 0 0 6 61 806 0 0 0 2 4 this 3 864  5 other 1 864  </span>
<span class="s0">43 0 0 6 62 846 0 0 158 /**</span>
 <span class="s0">* Returns a number less than zero if this URLSpec sorts before the other one,</span>
 <span class="s0">* greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*/ 2 4 this 3 864  5 other 1 864  </span>
<span class="s0">44 0 0 6 63 869 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">45 0 0 6 64 806 0 0 90 /**</span>
 <span class="s0">* Returns true if the URL specifies a scheme (e.g.  &quot;http:&quot;), false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">46 0 0 6 65 806 0 0 124 /**</span>
 <span class="s0">* Returns true if the URL specifies an authority (this includes username,</span>
 <span class="s0">* server, and/or port), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">47 0 0 6 66 806 0 0 94 /**</span>
 <span class="s0">* Returns true if the URL specifies a username (and/or password), false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">48 0 0 6 67 806 0 0 76 /**</span>
 <span class="s0">* Returns true if the URL specifies a server name, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">49 0 0 6 68 806 0 0 76 /**</span>
 <span class="s0">* Returns true if the URL specifies a port number, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">50 0 0 6 69 806 0 0 146 /**</span>
 <span class="s0">* Returns true if the URL includes a path specification (that is, the</span>
 <span class="s0">* particular filename on the server to retrieve), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">51 0 0 6 70 806 0 0 83 /**</span>
 <span class="s0">* Returns true if the URL includes a query specification, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">52 0 0 6 71 868 0 0 97 /**</span>
 <span class="s0">* Returns the scheme specified by the URL, or empty string if no scheme is</span>
 <span class="s0">* specified.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">53 0 0 6 72 868 0 0 149 /**</span>
 <span class="s0">* Returns the authority specified by the URL (this includes username, server,</span>
 <span class="s0">* and/or port), or empty string if no authority is specified.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">54 0 0 6 73 868 0 0 194 /**</span>
 <span class="s0">* Returns the username specified by the URL, if any.  This might also include</span>
 <span class="s0">* a password, e.g.  &quot;username:password&quot;, although putting a password on the</span>
 <span class="s0">* URL is probably a bad idea.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">55 0 0 6 74 868 0 0 137 /**</span>
 <span class="s0">* Returns the server name specified by the URL, if any.  In case of an IPv6</span>
 <span class="s0">* address, does not include the enclosing brackets.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">56 0 0 6 75 868 0 0 204 /**</span>
 <span class="s0">* Returns the port specified by the URL as a string, or the empty string if</span>
 <span class="s0">* no port is specified.  Compare this with get_port(), which returns a</span>
 <span class="s0">* default port number if no port is specified.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">57 0 0 6 76 804 0 0 97 /**</span>
 <span class="s0">* Returns the port number specified by the URL, or the default port if not</span>
 <span class="s0">* specified.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">58 0 0 6 77 868 0 0 298 /**</span>
 <span class="s0">* Returns a string consisting of the server name, followed by a colon,</span>
 <span class="s0">* followed by the port number.  If the port number is not explicitly given in</span>
 <span class="s0">* the URL, this string will include the implicit port number.</span>
 <span class="s0">* If the server is an IPv6 address, it will be enclosed in square brackets.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">59 0 0 6 78 806 0 0 181 /**</span>
 <span class="s0">* Returns true if the port number encoded in this URL is the default port</span>
 <span class="s0">* number for the scheme (or if there is no port number), or false if it is a</span>
 <span class="s0">* nonstandard port.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">60 0 0 6 79 846 0 0 106 /**</span>
 <span class="s0">* Returns the default port number for the indicated scheme, or 0 if there is</span>
 <span class="s0">* no known default.</span>
 <span class="s0">*/ 1 6 scheme 1 868  </span>
<span class="s0">61 0 0 6 80 868 0 0 81 /**</span>
 <span class="s0">* Returns the path specified by the URL, or &quot;/&quot; if no path is specified.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">62 0 0 6 81 868 0 0 95 /**</span>
 <span class="s0">* Returns the query specified by the URL, or empty string if no query is</span>
 <span class="s0">* specified.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">63 0 0 6 82 868 0 0 106 /**</span>
 <span class="s0">* Returns the path (or &quot;/&quot; if no path is specified), followed by the query if</span>
 <span class="s0">* it is specified.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">64 0 0 6 83 806 0 0 115 /**</span>
 <span class="s0">* Returns true if the URL's scheme specifies an SSL-secured protocol such as</span>
 <span class="s0">* https, or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">65 0 0 6 84 868 0 0 50 /**</span>
 <span class="s0">* Returns the complete URL specification.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">66 0 0 4 85 845 0 0 61 /**</span>
 <span class="s0">* Replaces the scheme part of the URL specification.</span>
 <span class="s0">*/ 2 4 this 3 863  6 scheme 1 868  </span>
<span class="s0">67 0 0 4 86 845 0 0 114 /**</span>
 <span class="s0">* Replaces the authority part of the URL specification.  This includes the</span>
 <span class="s0">* username, server, and port.</span>
 <span class="s0">*/ 2 4 this 3 863  9 authority 1 868  </span>
<span class="s0">68 0 0 4 87 845 0 0 63 /**</span>
 <span class="s0">* Replaces the username part of the URL specification.</span>
 <span class="s0">*/ 2 4 this 3 863  8 username 1 868  </span>
<span class="s0">69 0 0 4 88 845 0 0 174 /**</span>
 <span class="s0">* Replaces the server part of the URL specification.</span>
 <span class="s0">* Unlike set_server_and_port, this method does not require IPv6 addresses to</span>
 <span class="s0">* be enclosed in square brackets.</span>
 <span class="s0">*/ 2 4 this 3 863  6 server 1 868  </span>
<span class="s0">70 0 0 4 89 845 0 0 59 /**</span>
 <span class="s0">* Replaces the port part of the URL specification.</span>
 <span class="s0">*/ 2 4 this 3 863  4 port 1 868  </span>
<span class="s0">71 0 0 4 89 845 0 0 91 /**</span>
 <span class="s0">* Replaces the port part of the URL specification, given a numeric port</span>
 <span class="s0">* number.</span>
 <span class="s0">*/ 2 4 this 3 863  4 port 1 804  </span>
<span class="s0">72 0 0 4 90 845 0 0 254 /**</span>
 <span class="s0">* Replaces the server and port parts of the URL specification simultaneously.</span>
 <span class="s0">* The input string should be of the form &quot;server:port&quot;, or just &quot;server&quot; to</span>
 <span class="s0">* make the port number implicit.</span>
 <span class="s0">* Any IPv6 address must be enclosed in square brackets.</span>
 <span class="s0">*/ 2 4 this 3 863  15 server_and_port 1 868  </span>
<span class="s0">73 0 0 4 91 845 0 0 59 /**</span>
 <span class="s0">* Replaces the path part of the URL specification.</span>
 <span class="s0">*/ 2 4 this 3 863  4 path 1 868  </span>
<span class="s0">74 0 0 4 92 845 0 0 60 /**</span>
 <span class="s0">* Replaces the query part of the URL specification.</span>
 <span class="s0">*/ 2 4 this 3 863  5 query 1 868  </span>
<span class="s0">75 0 0 4 93 845 0 0 191 /**</span>
 <span class="s0">* Completely replaces the URL with the indicated string.  If</span>
 <span class="s0">* server_name_expected is true, it is a hint that an undecorated URL is</span>
 <span class="s0">* probably a server name, not a local filename.</span>
 <span class="s0">*/ 3 4 this 3 863  3 url 1 868  20 server_name_expected 5 806  </span>
<span class="s0">76 0 0 6 95 868 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">77 0 0 6 96 806 0 0 98 /**</span>
 <span class="s0">* Returns false if the URLSpec is valid (not empty), or true if it is an</span>
 <span class="s0">* empty string.</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">78 0 0 6 98 869 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">79 0 0 6 99 869 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 864  </span>
<span class="s0">80 0 0 6 100 871 0 0 0 2 4 this 3 864  1 n 1 869  </span>
<span class="s0">81 0 0 6 101 806 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 863  2 in 1 856  </span>
<span class="s0">82 0 0 4 102 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 864  3 out 1 858  </span>
<span class="s0">83 0 0 6 103 868 0 0 313 /**</span>
 <span class="s0">* Returns the source string with all &quot;unsafe&quot; characters quoted, making a</span>
 <span class="s0">* string suitable for placing in a URL.  Letters, digits, and the underscore,</span>
 <span class="s0">* comma, period, and hyphen characters, as well as any included in the safe</span>
 <span class="s0">* string, are left alone; all others are converted to hex representation.</span>
 <span class="s0">*/ 2 6 source 1 868  4 safe 5 868  </span>
<span class="s0">84 0 0 6 104 868 0 0 100 /**</span>
 <span class="s0">* Behaves like quote() with the additional behavior of replacing spaces with</span>
 <span class="s0">* plus signs.</span>
 <span class="s0">*/ 2 6 source 1 868  4 safe 5 868  </span>
<span class="s0">85 0 0 6 105 868 0 0 121 /**</span>
 <span class="s0">* Reverses the operation of quote(): converts escaped characters of the form</span>
 <span class="s0">* &quot;%xx&quot; to their ascii equivalent.</span>
 <span class="s0">*/ 1 6 source 1 868  </span>
<span class="s0">86 0 0 6 106 868 0 0 169 /**</span>
 <span class="s0">* Reverses the operation of quote_plus(): converts escaped characters of the</span>
 <span class="s0">* form &quot;%xx&quot; to their ascii equivalent, and also converts plus signs to</span>
 <span class="s0">* spaces.</span>
 <span class="s0">*/ 1 6 source 1 868  </span>
<span class="s0">87 0 0 6 94 868 0 0 0 1 4 this 3 864  </span>
<span class="s0">88 0 0 6 97 806 0 0 0 1 4 this 3 864  </span>
<span class="s0">89 0 0 7 125 872 497 0 0 0 </span>
<span class="s0">90 0 0 15 125 872 497 0 0 1 6 param0 0 873  </span>
<span class="s0">91 0 0 7 128 875 515 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">92 0 0 15 128 875 515 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 876  </span>
<span class="s0">93 0 0 23 128 875 515 0 122 /**</span>
 <span class="s0">* Decodes the string into a sensible date.  Returns 0 (!is_valid()) if the</span>
 <span class="s0">* string cannot be correctly decoded.</span>
 <span class="s0">*/ 1 6 format 1 868  </span>
<span class="s0">94 0 0 23 128 875 515 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 time 1 877  </span>
<span class="s0">95 0 0 6 129 875 0 0 0 2 4 this 3 875  4 copy 1 876  </span>
<span class="s0">96 0 0 7 130 875 515 0 73 /**</span>
 <span class="s0">* Returns an HTTPDate that represents the current time and date.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">97 0 0 6 131 806 0 0 141 /**</span>
 <span class="s0">* Returns true if the date is meaningful, or false if it is -1 (which</span>
 <span class="s0">* generally indicates the source string could not be parsed.)</span>
 <span class="s0">*/ 1 4 this 3 876  </span>
<span class="s0">98 0 0 6 132 868 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 876  </span>
<span class="s0">99 0 0 6 133 877 0 0 48 /**</span>
 <span class="s0">* Returns the date as a C time_t value.</span>
 <span class="s0">*/ 1 4 this 3 876  </span>
<span class="s0">100 0 0 6 134 806 0 0 0 2 4 this 3 876  5 other 1 876  </span>
<span class="s0">101 0 0 6 135 806 0 0 0 2 4 this 3 876  5 other 1 876  </span>
<span class="s0">102 0 0 6 136 806 0 0 0 2 4 this 3 876  5 other 1 876  </span>
<span class="s0">103 0 0 6 137 806 0 0 0 2 4 this 3 876  5 other 1 876  </span>
<span class="s0">104 0 0 6 138 846 0 0 159 /**</span>
 <span class="s0">* Returns a number less than zero if this HTTPDate sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*/ 2 4 this 3 876  5 other 1 876  </span>
<span class="s0">105 0 0 6 139 875 0 0 0 2 4 this 3 875  7 seconds 1 846  </span>
<span class="s0">106 0 0 6 140 875 0 0 0 2 4 this 3 875  7 seconds 1 846  </span>
<span class="s0">107 0 0 7 141 875 515 0 0 2 4 this 3 876  7 seconds 1 846  </span>
<span class="s0">108 0 0 6 142 846 0 0 0 2 4 this 3 876  5 other 1 876  </span>
<span class="s0">109 0 0 7 142 875 515 0 0 2 4 this 3 876  7 seconds 1 846  </span>
<span class="s0">110 0 0 6 143 806 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 875  2 in 1 856  </span>
<span class="s0">111 0 0 4 144 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 876  3 out 1 858  </span>
<span class="s0">112 0 0 7 147 879 517 0 38 /**</span>
 <span class="s0">* Constructs an empty cookie.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">113 0 0 15 147 879 517 0 0 1 6 param0 0 880  </span>
<span class="s0">114 0 0 7 147 879 517 0 197 /**</span>
 <span class="s0">* Constructs a cookie according to the indicated string, presumably the tag</span>
 <span class="s0">* of a Set-Cookie header.  There is no way to detect a formatting error in</span>
 <span class="s0">* the string with this constructor.</span>
 <span class="s0">*/ 2 6 format 1 868  3 url 1 864  </span>
<span class="s0">115 0 0 7 147 879 517 0 179 /**</span>
 <span class="s0">* Constructs a cookie with the indicated name, path, and domain values, but</span>
 <span class="s0">* no other data.  This is most useful for looking up an existing cookie in</span>
 <span class="s0">* the HTTPClient.</span>
 <span class="s0">*/ 3 4 name 1 868  4 path 1 868  6 domain 1 868  </span>
<span class="s0">116 0 0 4 149 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 879  4 name 1 868  </span>
<span class="s0">117 0 0 6 150 868 0 0 93 /**</span>
 <span class="s0">* Returns the name of the cookie.  This is the key value specified by the</span>
 <span class="s0">* server.</span>
 <span class="s0">*/ 1 4 this 3 880  </span>
<span class="s0">118 0 0 4 151 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 879  5 value 1 868  </span>
<span class="s0">119 0 0 6 152 868 0 0 139 /**</span>
 <span class="s0">* Returns the value of the cookie.  This is the arbitrary string associated</span>
 <span class="s0">* with the cookie's name, as specified by the server.</span>
 <span class="s0">*/ 1 4 this 3 880  </span>
<span class="s0">120 0 0 4 153 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 879  6 domain 1 868  </span>
<span class="s0">121 0 0 6 154 868 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 880  </span>
<span class="s0">122 0 0 4 155 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 879  4 path 1 868  </span>
<span class="s0">123 0 0 6 156 868 0 0 99 /**</span>
 <span class="s0">* Returns the prefix of the URL paths on the server for which this cookie</span>
 <span class="s0">* will be sent.</span>
 <span class="s0">*/ 1 4 this 3 880  </span>
<span class="s0">124 0 0 4 157 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 879  7 expires 1 876  </span>
<span class="s0">125 0 0 4 158 845 0 0 53 /**</span>
 <span class="s0">* Removes the expiration date on the cookie.</span>
 <span class="s0">*/ 1 4 this 3 879  </span>
<span class="s0">126 0 0 6 159 806 0 0 78 /**</span>
 <span class="s0">* Returns true if the cookie has an expiration date, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 880  </span>
<span class="s0">127 0 0 7 160 875 515 0 102 /**</span>
 <span class="s0">* Returns the expiration date of the cookie if it is set, or an invalid date</span>
 <span class="s0">* if it is not.</span>
 <span class="s0">*/ 1 4 this 3 880  </span>
<span class="s0">128 0 0 4 161 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 879  4 flag 1 806  </span>
<span class="s0">129 0 0 6 162 806 0 0 129 /**</span>
 <span class="s0">* Returns true if the server has indicated this is a &quot;secure&quot; cookie which</span>
 <span class="s0">* should only be sent over an HTTPS channel.</span>
 <span class="s0">*/ 1 4 this 3 880  </span>
<span class="s0">130 0 0 6 163 806 0 0 0 2 4 this 3 880  5 other 1 880  </span>
<span class="s0">131 0 0 4 164 845 0 0 358 /**</span>
 <span class="s0">* Assuming the operator &lt; method, above, has already evaluated these two</span>
 <span class="s0">* cookies as equal, then assign the remaining values (value, expiration date,</span>
 <span class="s0">* secure flag) from the indicated cookie.  This is guaranteed not to change</span>
 <span class="s0">* the ordering of the cookie in a set, and so can be used to update an</span>
 <span class="s0">* existing cookie within a set with new values.</span>
 <span class="s0">*/ 2 4 this 3 879  5 other 1 880  </span>
<span class="s0">132 0 0 6 165 806 0 0 218 /**</span>
 <span class="s0">* Separates out the parameter/value pairs of the Set-Cookie header and</span>
 <span class="s0">* assigns the values of the cookie appropriate.  Returns true if the header</span>
 <span class="s0">* is parsed correctly, false if something is not understood.</span>
 <span class="s0">*/ 3 4 this 3 879  6 format 1 868  3 url 1 864  </span>
<span class="s0">133 0 0 6 166 806 0 0 105 /**</span>
 <span class="s0">* Returns true if the cookie's expiration date is before the indicated date,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 880  3 now 5 876  </span>
<span class="s0">134 0 0 6 167 806 0 0 112 /**</span>
 <span class="s0">* Returns true if the cookie is appropriate to send with the indicated URL</span>
 <span class="s0">* request, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 880  3 url 1 864  </span>
<span class="s0">135 0 0 4 168 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 880  3 out 1 858  </span>
<span class="s0">136 0 0 7 178 882 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">137 0 0 15 178 882 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 883  </span>
<span class="s0">138 0 0 7 179 882 0 0 0 2 4 this 3 882  4 copy 1 883  </span>
<span class="s0">139 0 0 4 180 845 0 0 561 /**</span>
 <span class="s0">* This may be called once, presumably at the beginning of an application, to</span>
 <span class="s0">* initialize OpenSSL's random seed.  On Windows, it is particularly important</span>
 <span class="s0">* to call this at startup if you are going to be performing any https</span>
 <span class="s0">* operations or otherwise use encryption, since the Windows algorithm for</span>
 <span class="s0">* getting a random seed takes 2-3 seconds at startup, but can take 30 seconds</span>
 <span class="s0">* or more after you have opened a 3-D graphics window and started rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* There is no harm in calling this method multiple times, or in not calling</span>
 <span class="s0">* it at all.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">140 0 0 4 181 845 0 0 511 /**</span>
 <span class="s0">* Specifies the complete set of proxies to use for all schemes.  This is</span>
 <span class="s0">* either a semicolon-delimited set of hostname:ports, or a semicolon-</span>
 <span class="s0">* delimited set of pairs of the form &quot;scheme=hostname:port&quot;, or a</span>
 <span class="s0">* combination.  Use the keyword DIRECT, or an empty string, to represent a</span>
 <span class="s0">* direct connection.  A particular scheme and/or proxy host may be listed</span>
 <span class="s0">* more than once.  This is a convenience function that can be used in place</span>
 <span class="s0">* of explicit calls to add_proxy() for each scheme/proxy pair.</span>
 <span class="s0">*/ 2 4 this 3 882  10 proxy_spec 1 868  </span>
<span class="s0">141 0 0 6 182 868 0 0 371 /**</span>
 <span class="s0">* Returns the complete set of proxies to use for all schemes.  This is a</span>
 <span class="s0">* string of the form specified by set_proxy_spec(), above.  Note that the</span>
 <span class="s0">* string returned by this function may not be exactly the same as the string</span>
 <span class="s0">* passed into set_proxy_spec(), since the string is regenerated from the</span>
 <span class="s0">* internal storage structures and may therefore be reordered.</span>
 <span class="s0">*/ 1 4 this 3 883  </span>
<span class="s0">142 0 0 4 183 845 0 0 197 /**</span>
 <span class="s0">* Specifies the set of hosts that should be connected to directly, without</span>
 <span class="s0">* using a proxy.  This is a semicolon-separated list of hostnames that may</span>
 <span class="s0">* contain wildcard characters (&quot;*&quot;).</span>
 <span class="s0">*/ 2 4 this 3 882  16 direct_host_spec 1 868  </span>
<span class="s0">143 0 0 6 184 868 0 0 189 /**</span>
 <span class="s0">* Returns the set of hosts that should be connected to directly, without</span>
 <span class="s0">* using a proxy, as a semicolon-separated list of hostnames that may contain</span>
 <span class="s0">* wildcard characters (&quot;*&quot;).</span>
 <span class="s0">*/ 1 4 this 3 883  </span>
<span class="s0">144 0 0 4 185 845 0 0 306 /**</span>
 <span class="s0">* If this is set true, then after a connection attempt through a proxy fails,</span>
 <span class="s0">* we always try a direct connection, regardless of whether the host is listed</span>
 <span class="s0">* on the direct_host_spec list.  If this is false, a direct attempt is not</span>
 <span class="s0">* made when we have a proxy in effect, even if the proxy fails.</span>
 <span class="s0">*/ 2 4 this 3 882  14 try_all_direct 1 806  </span>
<span class="s0">145 0 0 6 186 806 0 0 134 /**</span>
 <span class="s0">* Returns whether a failed connection through a proxy will be followed up by</span>
 <span class="s0">* a direct connection attempt, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 883  </span>
<span class="s0">146 0 0 4 187 845 0 0 128 /**</span>
 <span class="s0">* Resets the proxy spec to empty.  Subsequent calls to add_proxy() may be</span>
 <span class="s0">* made to build up the set of proxy servers.</span>
 <span class="s0">*/ 1 4 this 3 882  </span>
<span class="s0">147 0 0 4 188 845 0 0 271 /**</span>
 <span class="s0">* Adds the indicated proxy host as a proxy for communications on the given</span>
 <span class="s0">* scheme.  Usually the scheme is &quot;http&quot; or &quot;https&quot;.  It may be the empty</span>
 <span class="s0">* string to indicate a general proxy.  The proxy string may be the empty URL</span>
 <span class="s0">* to indicate a direct connection.</span>
 <span class="s0">*/ 3 4 this 3 882  6 scheme 1 868  5 proxy 1 864  </span>
<span class="s0">148 0 0 4 189 845 0 0 178 /**</span>
 <span class="s0">* Resets the set of direct hosts to empty.  Subsequent calls to</span>
 <span class="s0">* add_direct_host() may be made to build up the list of hosts that do not</span>
 <span class="s0">* require a proxy connection.</span>
 <span class="s0">*/ 1 4 this 3 882  </span>
<span class="s0">149 0 0 4 190 845 0 0 223 /**</span>
 <span class="s0">* Adds the indicated name to the set of hostnames that are connected to</span>
 <span class="s0">* directly, without using a proxy.  This name may be either a DNS name or an</span>
 <span class="s0">* IP address, and it may include the * as a wildcard character.</span>
 <span class="s0">*/ 2 4 this 3 882  8 hostname 1 868  </span>
<span class="s0">150 0 0 6 191 868 0 0 218 /**</span>
 <span class="s0">* Returns a semicolon-delimited list of proxies, in the order in which they</span>
 <span class="s0">* should be tried, that are appropriate for the indicated URL.  The keyword</span>
 <span class="s0">* DIRECT indicates a direct connection should be tried.</span>
 <span class="s0">*/ 2 4 this 3 883  3 url 1 864  </span>
<span class="s0">151 0 0 4 192 845 0 0 433 /**</span>
 <span class="s0">* Specifies the username:password string corresponding to a particular server</span>
 <span class="s0">* and/or realm, when demanded by the server.  Either or both of the server or</span>
 <span class="s0">* realm may be empty; if so, they match anything.  Also, the server may be</span>
 <span class="s0">* set to the special string `&quot;*proxy&quot;`, which will match any proxy server.</span>
 <span class="s0">*</span>
 <span class="s0">* If the username is set to the empty string, this clears the password for</span>
 <span class="s0">* the particular server/realm pair.</span>
 <span class="s0">*/ 4 4 this 3 882  6 server 1 868  5 realm 1 868  8 username 1 868  </span>
<span class="s0">152 0 0 6 193 868 0 0 144 /**</span>
 <span class="s0">* Returns the username:password string set for this server/realm pair, or</span>
 <span class="s0">* empty string if nothing has been set.  See set_username().</span>
 <span class="s0">*/ 3 4 this 3 883  6 server 1 868  5 realm 1 868  </span>
<span class="s0">153 0 0 4 194 845 0 0 116 /**</span>
 <span class="s0">* Stores the indicated cookie in the client's list of cookies, as if it had</span>
 <span class="s0">* been received from a server.</span>
 <span class="s0">*/ 2 4 this 3 882  6 cookie 1 880  </span>
<span class="s0">154 0 0 6 195 806 0 0 175 /**</span>
 <span class="s0">* Removes the cookie with the matching domain/path/name from the client's</span>
 <span class="s0">* list of cookies.  Returns true if it was removed, false if the cookie was</span>
 <span class="s0">* not matched.</span>
 <span class="s0">*/ 2 4 this 3 882  6 cookie 1 880  </span>
<span class="s0">155 0 0 4 196 845 0 0 58 /**</span>
 <span class="s0">* Removes the all stored cookies from the client.</span>
 <span class="s0">*/ 1 4 this 3 882  </span>
<span class="s0">156 0 0 6 197 806 0 0 124 /**</span>
 <span class="s0">* Returns true if there is a cookie in the client matching the given cookie's</span>
 <span class="s0">* domain/path/name, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 883  6 cookie 1 880  </span>
<span class="s0">157 0 0 7 198 879 517 0 163 /**</span>
 <span class="s0">* Looks up and returns the cookie in the client matching the given cookie's</span>
 <span class="s0">* domain/path/name.  If there is no matching cookie, returns an empty cookie.</span>
 <span class="s0">*/ 2 4 this 3 883  6 cookie 1 880  </span>
<span class="s0">158 0 0 4 199 845 0 0 179 /**</span>
 <span class="s0">* Copies all the cookies from the indicated HTTPClient into this one.</span>
 <span class="s0">* Existing cookies in this client are not affected, unless they are shadowed</span>
 <span class="s0">* by the new cookies.</span>
 <span class="s0">*/ 2 4 this 3 882  5 other 1 883  </span>
<span class="s0">159 0 0 4 200 845 0 0 172 /**</span>
 <span class="s0">* Outputs the complete list of cookies stored on the client, for all domains,</span>
 <span class="s0">* including the expired cookies (which will normally not be sent back to a</span>
 <span class="s0">* host).</span>
 <span class="s0">*/ 2 4 this 3 883  3 out 1 858  </span>
<span class="s0">160 0 0 4 201 845 0 0 192 /**</span>
 <span class="s0">* Writes to the indicated ostream a &quot;Cookie&quot; header line for sending the</span>
 <span class="s0">* cookies appropriate to the indicated URL along with an HTTP request.  This</span>
 <span class="s0">* also removes expired cookies.</span>
 <span class="s0">*/ 3 4 this 3 882  3 out 1 858  3 url 1 864  </span>
<span class="s0">161 0 0 4 202 845 0 0 250 /**</span>
 <span class="s0">* Sets the filename of the pem-formatted file that will be read for the</span>
 <span class="s0">* client public and private keys if an SSL server requests a certificate.</span>
 <span class="s0">* Either this or set_client_certificate_pem() may be used to specify a client</span>
 <span class="s0">* certificate.</span>
 <span class="s0">*/ 2 4 this 3 882  8 filename 1 865  </span>
<span class="s0">162 0 0 4 203 845 0 0 264 /**</span>
 <span class="s0">* Sets the pem-formatted contents of the certificate that will be parsed for</span>
 <span class="s0">* the client public and private keys if an SSL server requests a certificate.</span>
 <span class="s0">* Either this or set_client_certificate_filename() may be used to specify a</span>
 <span class="s0">* client certificate.</span>
 <span class="s0">*/ 2 4 this 3 882  3 pem 1 868  </span>
<span class="s0">163 0 0 4 204 845 0 0 160 /**</span>
 <span class="s0">* Sets the passphrase used to decrypt the private key in the certificate</span>
 <span class="s0">* named by set_client_certificate_filename() or set_client_certificate_pem().</span>
 <span class="s0">*/ 2 4 this 3 882  10 passphrase 1 868  </span>
<span class="s0">164 0 0 6 205 806 0 0 376 /**</span>
 <span class="s0">* Attempts to load the certificate named by set_client_certificate_filename()</span>
 <span class="s0">* immediately, and returns true if successful, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally this need not be explicitly called, since it will be called</span>
 <span class="s0">* automatically if the server requests a certificate, but it may be useful to</span>
 <span class="s0">* determine ahead of time if the certificate can be loaded correctly.</span>
 <span class="s0">*/ 1 4 this 3 882  </span>
<span class="s0">165 0 0 6 206 806 0 0 547 /**</span>
 <span class="s0">* Adds the certificate defined in the indicated PEM filename as a &quot;pre-</span>
 <span class="s0">* approved&quot; certificate for the indicated server, defined by the hostname and</span>
 <span class="s0">* port (only) from the given URL.</span>
 <span class="s0">*</span>
 <span class="s0">* If the server offers this particular certificate on a secure connection, it</span>
 <span class="s0">* will be accepted without question.  This is particularly useful for</span>
 <span class="s0">* communicating with a server using a known self-signed certificate.</span>
 <span class="s0">*</span>
 <span class="s0">* See also the similar add_preapproved_server_certificate_pem(), and the</span>
 <span class="s0">* weaker add_preapproved_server_certificate_name().</span>
 <span class="s0">*/ 3 4 this 3 882  3 url 1 864  8 filename 1 865  </span>
<span class="s0">166 0 0 6 207 806 0 0 577 /**</span>
 <span class="s0">* Adds the certificate defined in the indicated data string, formatted as a</span>
 <span class="s0">* PEM block, as a &quot;pre-approved&quot; certificate for the indicated server,</span>
 <span class="s0">* defined by the hostname and port (only) from the given URL.</span>
 <span class="s0">*</span>
 <span class="s0">* If the server offers this particular certificate on a secure connection, it</span>
 <span class="s0">* will be accepted without question.  This is particularly useful for</span>
 <span class="s0">* communicating with a server using a known self-signed certificate.</span>
 <span class="s0">*</span>
 <span class="s0">* See also the similar add_preapproved_server_certificate_filename(), and the</span>
 <span class="s0">* weaker add_preapproved_server_certificate_name().</span>
 <span class="s0">*/ 3 4 this 3 882  3 url 1 864  3 pem 1 868  </span>
<span class="s0">167 0 0 6 208 806 0 0 888 /**</span>
 <span class="s0">* Adds the certificate *name* only, as a &quot;pre-approved&quot; certificate name for</span>
 <span class="s0">* the indicated server, defined by the hostname and port (only) from the</span>
 <span class="s0">* given URL.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a weaker function than</span>
 <span class="s0">* add_preapproved_server_certificate_filename().  This checks only the</span>
 <span class="s0">* subject name of the certificate, without checking for a particular</span>
 <span class="s0">* certificate by key.  This means that a variety of server certificates may</span>
 <span class="s0">* match the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* Because this is a weaker verification, it only applies to server</span>
 <span class="s0">* certificates that are signed by a recognized certificate authority.  Thus,</span>
 <span class="s0">* it cannot be used to pre-approve self-signed certificates, but it can be</span>
 <span class="s0">* used to accept a server certificate offered by a different hostname than</span>
 <span class="s0">* the one in the cert itself.</span>
 <span class="s0">*</span>
 <span class="s0">* The certificate name should be formatted in the form</span>
 <span class="s0">* type0=value0/type1=value1/type2=...</span>
 <span class="s0">*/ 3 4 this 3 882  3 url 1 864  4 name 1 868  </span>
<span class="s0">168 0 0 4 209 845 0 0 92 /**</span>
 <span class="s0">* Removes all preapproved server certificates for the indicated server and</span>
 <span class="s0">* port.</span>
 <span class="s0">*/ 2 4 this 3 882  3 url 1 864  </span>
<span class="s0">169 0 0 4 210 845 0 0 71 /**</span>
 <span class="s0">* Removes all preapproved server certificates for all servers.</span>
 <span class="s0">*/ 1 4 this 3 882  </span>
<span class="s0">170 0 0 4 211 845 0 0 221 /**</span>
 <span class="s0">* Specifies the version of HTTP that the client uses to identify itself to</span>
 <span class="s0">* the server.  The default is HV_11, or HTTP 1.0; you can set this to HV_10</span>
 <span class="s0">* (HTTP 1.0) to request the server use the older interface.</span>
 <span class="s0">*/ 2 4 this 3 882  7 version 1 808  </span>
<span class="s0">171 0 0 6 212 808 0 0 93 /**</span>
 <span class="s0">* Returns the client's current setting for HTTP version.  See</span>
 <span class="s0">* set_http_version().</span>
 <span class="s0">*/ 1 4 this 3 883  </span>
<span class="s0">172 0 0 6 213 868 0 0 99 /**</span>
 <span class="s0">* Returns the current HTTP version setting as a string, e.g.  &quot;HTTP/1.0&quot; or</span>
 <span class="s0">* &quot;HTTP/1.1&quot;.</span>
 <span class="s0">*/ 1 4 this 3 883  </span>
<span class="s0">173 0 0 6 214 808 0 0 193 /**</span>
 <span class="s0">* Matches the string representing a particular HTTP version against any of</span>
 <span class="s0">* the known versions and returns the appropriate enumerated value, or</span>
 <span class="s0">* HV_other if the version is unknown.</span>
 <span class="s0">*/ 1 7 version 1 868  </span>
<span class="s0">174 0 0 6 215 806 0 0 263 /**</span>
 <span class="s0">* Reads the certificate(s) (delimited by -----BEGIN CERTIFICATE----- and</span>
 <span class="s0">* -----END CERTIFICATE-----) from the indicated file and makes them known as</span>
 <span class="s0">* trusted public keys for validating future connections.  Returns true on</span>
 <span class="s0">* success, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 882  8 filename 1 865  </span>
<span class="s0">175 0 0 4 217 845 0 0 263 /**</span>
 <span class="s0">* Specifies whether the client will insist on verifying the identity of the</span>
 <span class="s0">* servers it connects to via SSL (that is, https).</span>
 <span class="s0">*</span>
 <span class="s0">* The parameter value is an enumerated type which indicates the level of</span>
 <span class="s0">* security to which the client will insist upon.</span>
 <span class="s0">*/ 2 4 this 3 882  10 verify_ssl 1 815  </span>
<span class="s0">176 0 0 6 218 815 0 0 157 /**</span>
 <span class="s0">* Returns whether the client will insist on verifying the identity of the</span>
 <span class="s0">* servers it connects to via SSL (that is, https).  See set_verify_ssl().</span>
 <span class="s0">*/ 1 4 this 3 883  </span>
<span class="s0">177 0 0 4 219 845 0 0 404 /**</span>
 <span class="s0">* Specifies the set of ciphers that are to be made available for SSL</span>
 <span class="s0">* connections.  This is a string as described in the ciphers(1) man page of</span>
 <span class="s0">* the OpenSSL documentation (or see</span>
 <span class="s0">* https://www.openssl.org/docs/man1.1.1/man1/ciphers.html ).  If this isn't</span>
 <span class="s0">* specified, the default is provided by the Config file.  You may also specify</span>
 <span class="s0">* &quot;DEFAULT&quot; to use the built-in OpenSSL default value.</span>
 <span class="s0">*/ 2 4 this 3 882  11 cipher_list 1 868  </span>
<span class="s0">178 0 0 6 220 868 0 0 93 /**</span>
 <span class="s0">* Returns the set of ciphers as set by set_cipher_list().  See</span>
 <span class="s0">* set_cipher_list().</span>
 <span class="s0">*/ 1 4 this 3 883  </span>
<span class="s0">179 0 0 7 221 885 0 0 763 /**</span>
 <span class="s0">* Returns a new HTTPChannel object that may be used for reading multiple</span>
 <span class="s0">* documents using the same connection, for greater network efficiency than</span>
 <span class="s0">* calling HTTPClient::get_document() repeatedly (which would force a new</span>
 <span class="s0">* connection for each document).</span>
 <span class="s0">*</span>
 <span class="s0">* Also, HTTPChannel has some additional, less common interface methods than</span>
 <span class="s0">* the basic interface methods that exist on HTTPClient; if you wish to call</span>
 <span class="s0">* any of these methods you must first obtain an HTTPChannel.</span>
 <span class="s0">*</span>
 <span class="s0">* Pass true for persistent_connection to gain this network efficiency.  If,</span>
 <span class="s0">* on the other hand, your intention is to use the channel to retrieve only</span>
 <span class="s0">* one document, then pass false to inform the server that we will be dropping</span>
 <span class="s0">* the connection after the first document.</span>
 <span class="s0">*/ 2 4 this 3 882  21 persistent_connection 1 806  </span>
<span class="s0">180 0 0 7 222 885 0 0 262 /**</span>
 <span class="s0">* Posts form data to a particular URL and retrieves the response.  Returns a</span>
 <span class="s0">* new HTTPChannel object whether the document is successfully read or not;</span>
 <span class="s0">* you can test is_valid() and get_return_code() to determine whether the</span>
 <span class="s0">* document was retrieved.</span>
 <span class="s0">*/ 3 4 this 3 882  3 url 1 864  4 body 1 868  </span>
<span class="s0">181 0 0 7 223 885 0 0 233 /**</span>
 <span class="s0">* Opens the named document for reading.  Returns a new HTTPChannel object</span>
 <span class="s0">* whether the document is successfully read or not; you can test is_valid()</span>
 <span class="s0">* and get_return_code() to determine whether the document was retrieved.</span>
 <span class="s0">*/ 2 4 this 3 882  3 url 1 864  </span>
<span class="s0">182 0 0 7 224 885 0 0 252 /**</span>
 <span class="s0">* Like get_document(), except only the header associated with the document is</span>
 <span class="s0">* retrieved.  This may be used to test for existence of the document; it</span>
 <span class="s0">* might also return the size of the document (if the server gives us this</span>
 <span class="s0">* information).</span>
 <span class="s0">*/ 2 4 this 3 882  3 url 1 864  </span>
<span class="s0">183 0 0 6 225 868 0 0 222 /**</span>
 <span class="s0">* Implements HTTPAuthorization::base64_encode().  This is provided here just</span>
 <span class="s0">* as a convenient place to publish it for access by the scripting language;</span>
 <span class="s0">* C++ code should probably use HTTPAuthorization directly.</span>
 <span class="s0">*/ 1 1 s 1 868  </span>
<span class="s0">184 0 0 6 226 868 0 0 222 /**</span>
 <span class="s0">* Implements HTTPAuthorization::base64_decode().  This is provided here just</span>
 <span class="s0">* as a convenient place to publish it for access by the scripting language;</span>
 <span class="s0">* C++ code should probably use HTTPAuthorization directly.</span>
 <span class="s0">*/ 1 1 s 1 868  </span>
<span class="s0">185 0 0 7 227 882 0 0 49 /**</span>
 <span class="s0">* Returns the default global HTTPClient.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">186 0 0 7 229 886 599 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">187 0 0 15 229 886 599 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 887  </span>
<span class="s0">188 0 0 23 229 886 599 0 99 /**</span>
 <span class="s0">* This constructor accepts an explicit weak flag and a literal (not quoted)</span>
 <span class="s0">* tag string.</span>
 <span class="s0">*/ 2 4 weak 1 806  3 tag 1 868  </span>
<span class="s0">189 0 0 23 229 886 599 0 134 /**</span>
 <span class="s0">* This constructor accepts a string as formatted from an HTTP server (e.g.</span>
 <span class="s0">* the tag is quoted, with an optional W/ prefix.)</span>
 <span class="s0">*/ 1 4 text 1 868  </span>
<span class="s0">190 0 0 6 230 886 0 0 0 2 4 this 3 886  4 copy 1 887  </span>
<span class="s0">191 0 0 6 231 806 0 0 255 /**</span>
 <span class="s0">* Returns true if the entity tag is marked as &quot;weak&quot;. A consistent weak</span>
 <span class="s0">* entity tag does not guarantee that its resource has not changed in any way,</span>
 <span class="s0">* but it does promise that the resource has not changed in any semantically</span>
 <span class="s0">* meaningful way.</span>
 <span class="s0">*/ 1 4 this 3 887  </span>
<span class="s0">192 0 0 6 232 868 0 0 47 /**</span>
 <span class="s0">* Returns the tag as a literal string.</span>
 <span class="s0">*/ 1 4 this 3 887  </span>
<span class="s0">193 0 0 6 233 868 0 0 126 /**</span>
 <span class="s0">* Returns the entity tag formatted for sending to an HTTP server (the tag is</span>
 <span class="s0">* quoted, with a conditional W prefix).</span>
 <span class="s0">*/ 1 4 this 3 887  </span>
<span class="s0">194 0 0 6 234 806 0 0 115 /**</span>
 <span class="s0">* Returns true if the two tags have &quot;strong&quot; equivalence: they are the same</span>
 <span class="s0">* tag, and both are &quot;strong&quot;.</span>
 <span class="s0">*/ 2 4 this 3 887  5 other 1 887  </span>
<span class="s0">195 0 0 6 235 806 0 0 121 /**</span>
 <span class="s0">* Returns true if the two tags have &quot;weak&quot; equivalence: they are the same</span>
 <span class="s0">* tag, and one or both may be &quot;weak&quot;.</span>
 <span class="s0">*/ 2 4 this 3 887  5 other 1 887  </span>
<span class="s0">196 0 0 6 236 806 0 0 0 2 4 this 3 887  5 other 1 887  </span>
<span class="s0">197 0 0 6 237 806 0 0 0 2 4 this 3 887  5 other 1 887  </span>
<span class="s0">198 0 0 6 238 806 0 0 0 2 4 this 3 887  5 other 1 887  </span>
<span class="s0">199 0 0 6 239 846 0 0 167 /**</span>
 <span class="s0">* Returns a number less than zero if this HTTPEntityTag sorts before the</span>
 <span class="s0">* other one, greater than zero if it sorts after, or zero if they are</span>
 <span class="s0">* equivalent.</span>
 <span class="s0">*/ 2 4 this 3 887  5 other 1 887  </span>
<span class="s0">200 0 0 4 240 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 887  3 out 1 858  </span>
<span class="s0">201 0 0 7 243 888 623 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">202 0 0 15 243 888 623 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 889  </span>
<span class="s0">203 0 0 23 243 888 623 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 3 url 1 864  </span>
<span class="s0">204 0 0 23 243 888 623 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 3 url 1 868  </span>
<span class="s0">205 0 0 6 244 888 0 0 0 2 4 this 3 888  4 copy 1 889  </span>
<span class="s0">206 0 0 6 245 806 0 0 0 2 4 this 3 889  5 other 1 889  </span>
<span class="s0">207 0 0 6 246 806 0 0 0 2 4 this 3 889  5 other 1 889  </span>
<span class="s0">208 0 0 6 247 806 0 0 0 2 4 this 3 889  5 other 1 889  </span>
<span class="s0">209 0 0 6 248 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 889  5 other 1 889  </span>
<span class="s0">210 0 0 4 249 845 0 0 311 /**</span>
 <span class="s0">* Changes the URL of the DocumentSpec without modifying its other properties.</span>
 <span class="s0">* Normally this would be a strange thing to do, because the tag and date are</span>
 <span class="s0">* usually strongly associated with the URL.  To get a DocumentSpec pointing</span>
 <span class="s0">* to a new URL, you would normally create a new DocumentSpec object.</span>
 <span class="s0">*/ 2 4 this 3 888  3 url 1 864  </span>
<span class="s0">211 0 0 6 250 864 0 0 49 /**</span>
 <span class="s0">* Retrieves the URL of the DocumentSpec.</span>
 <span class="s0">*/ 1 4 this 3 889  </span>
<span class="s0">212 0 0 4 251 845 0 0 69 /**</span>
 <span class="s0">* Changes the identity tag associated with the DocumentSpec.</span>
 <span class="s0">*/ 2 4 this 3 888  3 tag 1 887  </span>
<span class="s0">213 0 0 6 252 806 0 0 79 /**</span>
 <span class="s0">* Returns true if an identity tag is associated with the DocumentSpec.</span>
 <span class="s0">*/ 1 4 this 3 889  </span>
<span class="s0">214 0 0 6 253 887 0 0 254 /**</span>
 <span class="s0">* Returns the identity tag associated with the DocumentSpec, if there is one.</span>
 <span class="s0">* It is an error to call this if has_tag() returns false.</span>
 <span class="s0">*</span>
 <span class="s0">* The identity tag is set by the HTTP server to uniquely refer to a</span>
 <span class="s0">* particular version of a document.</span>
 <span class="s0">*/ 1 4 this 3 889  </span>
<span class="s0">215 0 0 4 254 845 0 0 86 /**</span>
 <span class="s0">* Removes the identity tag associated with the DocumentSpec, if there is one.</span>
 <span class="s0">*/ 1 4 this 3 888  </span>
<span class="s0">216 0 0 4 255 845 0 0 75 /**</span>
 <span class="s0">* Changes the last-modified date associated with the DocumentSpec.</span>
 <span class="s0">*/ 2 4 this 3 888  4 date 1 876  </span>
<span class="s0">217 0 0 6 256 806 0 0 84 /**</span>
 <span class="s0">* Returns true if a last-modified date is associated with the DocumentSpec.</span>
 <span class="s0">*/ 1 4 this 3 889  </span>
<span class="s0">218 0 0 6 257 876 0 0 153 /**</span>
 <span class="s0">* Returns the last-modified date associated with the DocumentSpec, if there</span>
 <span class="s0">* is one.  It is an error to call this if has_date() returns false.</span>
 <span class="s0">*/ 1 4 this 3 889  </span>
<span class="s0">219 0 0 4 258 845 0 0 95 /**</span>
 <span class="s0">* Removes the last-modified date associated with the DocumentSpec, if there</span>
 <span class="s0">* is one.</span>
 <span class="s0">*/ 1 4 this 3 888  </span>
<span class="s0">220 0 0 4 260 845 0 0 1335 /**</span>
 <span class="s0">* Sets the request mode of this DocumentSpec.  This is only relevant when</span>
 <span class="s0">* using the DocumentSpec to generate a request (for instance, in</span>
 <span class="s0">* HTTPChannel).  This specifies whether the document request will ask the</span>
 <span class="s0">* server for a newer version than the indicated version, or the exact</span>
 <span class="s0">* version, neither, or either.</span>
 <span class="s0">*</span>
 <span class="s0">* The possible values are:</span>
 <span class="s0">*</span>
 <span class="s0">* RM_any: ignore date and tag (if specified), and retrieve any document that</span>
 <span class="s0">* matches the URL.  For a subrange request, if the document matches the</span>
 <span class="s0">* version indicated exactly, retrieve the subrange only; otherwise, retrieve</span>
 <span class="s0">* the entire document.</span>
 <span class="s0">*</span>
 <span class="s0">* RM_equal: request only the precise version of the document that matches the</span>
 <span class="s0">* particular date and/or tag exactly, if specified; fail if this version is</span>
 <span class="s0">* not available.</span>
 <span class="s0">*</span>
 <span class="s0">* RM_newer: request any document that is newer than the version indicated by</span>
 <span class="s0">* the particular date and/or tag; fail if only that version (or older</span>
 <span class="s0">* versions) are available.</span>
 <span class="s0">*</span>
 <span class="s0">* RM_newer_or_equal: request any document that matches the version indicated</span>
 <span class="s0">* by the particular date and/or tag, or is a newer version; fail if only</span>
 <span class="s0">* older versions are available.</span>
 <span class="s0">*</span>
 <span class="s0">* In any of the above, you may specify either or both of the last-modified</span>
 <span class="s0">* date and the identity tag, whichever is known to the client.</span>
 <span class="s0">*</span>
 <span class="s0">* The default mode is RM_any.</span>
 <span class="s0">*/ 2 4 this 3 888  12 request_mode 1 818  </span>
<span class="s0">221 0 0 6 261 818 0 0 82 /**</span>
 <span class="s0">* Returns the request mode of this DocumentSpec.  See set_request_mode().</span>
 <span class="s0">*/ 1 4 this 3 889  </span>
<span class="s0">222 0 0 4 263 845 0 0 642 /**</span>
 <span class="s0">* Specifies what kind of cached value is acceptable for this document.</span>
 <span class="s0">* Warning: some HTTP proxies may not respect this setting and may return a</span>
 <span class="s0">* cached result anyway.</span>
 <span class="s0">*</span>
 <span class="s0">* CC_allow_cache: the normal HTTP behavior; the server may return a cached</span>
 <span class="s0">* value if it believes it is valid.</span>
 <span class="s0">*</span>
 <span class="s0">* CC_revalidate: a proxy is forced to contact the origin server and verify</span>
 <span class="s0">* that is cached value is in fact still valid before it returns it.</span>
 <span class="s0">*</span>
 <span class="s0">* CC_no_cache: a proxy must not return its cached value at all, but is forced</span>
 <span class="s0">* to go all the way back to the origin server for the official document.</span>
 <span class="s0">*</span>
 <span class="s0">* The default mode is CC_allow_cache.</span>
 <span class="s0">*/ 2 4 this 3 888  13 cache_control 1 819  </span>
<span class="s0">223 0 0 6 264 819 0 0 83 /**</span>
 <span class="s0">* Returns the request mode of this DocumentSpec.  See set_cache_control().</span>
 <span class="s0">*/ 1 4 this 3 889  </span>
<span class="s0">224 0 0 6 265 806 0 0 152 /**</span>
 <span class="s0">* Can be used to read in the DocumentSpec from a stream generated either by</span>
 <span class="s0">* output() or write().  Returns true on success, false on failure.</span>
 <span class="s0">*/ 2 4 this 3 888  2 in 1 856  </span>
<span class="s0">225 0 0 4 266 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 889  3 out 1 858  </span>
<span class="s0">226 0 0 4 267 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 889  3 out 1 858  12 indent_level 5 846  </span>
<span class="s0">227 0 0 15 358 885 0 0 0 1 6 param0 0 891  </span>
<span class="s0">228 0 0 7 280 882 0 0 64 /**</span>
 <span class="s0">* Returns the HTTPClient object that owns this channel.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">229 0 0 6 281 806 0 0 126 /**</span>
 <span class="s0">* Returns true if the last-requested document was successfully retrieved and</span>
 <span class="s0">* is ready to be read, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">230 0 0 6 282 806 0 0 158 /**</span>
 <span class="s0">* Returns true if a connection has been established to the named server in a</span>
 <span class="s0">* previous call to connect_to() or begin_connect_to(), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">231 0 0 6 283 864 0 0 287 /**</span>
 <span class="s0">* Returns the URL that was used to retrieve the most recent document:</span>
 <span class="s0">* whatever URL was last passed to get_document() or get_header().  If a</span>
 <span class="s0">* redirect has transparently occurred, this will return the new, redirected</span>
 <span class="s0">* URL (the actual URL at which the document was located).</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">232 0 0 6 284 889 0 0 380 /**</span>
 <span class="s0">* Returns the DocumentSpec associated with the most recent document.  This</span>
 <span class="s0">* includes its actual URL (following redirects) along with the identity tag</span>
 <span class="s0">* and last-modified date, if supplied by the server.</span>
 <span class="s0">*</span>
 <span class="s0">* This structure may be saved and used to retrieve the same version of the</span>
 <span class="s0">* document later, or to conditionally retrieve a newer version if it is</span>
 <span class="s0">* available.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">233 0 0 6 285 808 0 0 137 /**</span>
 <span class="s0">* Returns the HTTP version number returned by the server, as one of the</span>
 <span class="s0">* HTTPClient enumerated types, e.g.  HTTPClient::HV_11.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">234 0 0 6 286 868 0 0 110 /**</span>
 <span class="s0">* Returns the HTTP version number returned by the server, formatted as a</span>
 <span class="s0">* string, e.g.  &quot;HTTP/1.1&quot;.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">235 0 0 6 287 846 0 0 501 /**</span>
 <span class="s0">* Returns the HTML return code from the document retrieval request.  This</span>
 <span class="s0">* will be in the 200 range if the document is successfully retrieved, or some</span>
 <span class="s0">* other value in the case of an error.</span>
 <span class="s0">*</span>
 <span class="s0">* Some proxy errors during an https-over-proxy request would return the same</span>
 <span class="s0">* status code as a different error that occurred on the host server.  To</span>
 <span class="s0">* differentiate these cases, status codes that are returned by the proxy</span>
 <span class="s0">* during the CONNECT phase (except code 407) are incremented by 1000.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">236 0 0 6 288 868 0 0 133 /**</span>
 <span class="s0">* Returns the string as returned by the server describing the status code for</span>
 <span class="s0">* humans.  This may or may not be meaningful.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">237 0 0 6 289 868 0 0 363 /**</span>
 <span class="s0">* If the document failed to connect because of a 401 (Authorization</span>
 <span class="s0">* required), this method will return the &quot;realm&quot; returned by the server in</span>
 <span class="s0">* which the requested document must be authenticated.  This string may be</span>
 <span class="s0">* presented to the user to request an associated username and password (which</span>
 <span class="s0">* then should be stored in HTTPClient::set_username()).</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">238 0 0 6 290 868 0 0 311 /**</span>
 <span class="s0">* If the document failed to connect because of a 407 (Proxy authorization</span>
 <span class="s0">* required), this method will return the &quot;realm&quot; returned by the proxy.  This</span>
 <span class="s0">* string may be presented to the user to request an associated username and</span>
 <span class="s0">* password (which then should be stored in HTTPClient::set_username()).</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">239 0 0 6 291 864 0 0 366 /**</span>
 <span class="s0">* If the document failed with a redirect code (300 series), this will</span>
 <span class="s0">* generally contain the new URL the server wants us to try.  In many cases,</span>
 <span class="s0">* the client will automatically follow redirects; if these are successful the</span>
 <span class="s0">* client will return a successful code and get_redirect() will return empty,</span>
 <span class="s0">* but get_url() will return the new, redirected URL.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">240 0 0 6 292 868 0 0 160 /**</span>
 <span class="s0">* Returns the HTML header value associated with the indicated key, or empty</span>
 <span class="s0">* string if the key was not defined in the message returned by the server.</span>
 <span class="s0">*/ 2 4 this 3 891  3 key 1 868  </span>
<span class="s0">241 0 0 6 293 846 0 0 212 /**</span>
 <span class="s0">* If the document automatically followed one or more redirects, this will</span>
 <span class="s0">* return the number of redirects that were automatically followed.  Use</span>
 <span class="s0">* get_redirect_step() to retrieve each URL in sequence.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">242 0 0 6 294 864 0 0 182 /**</span>
 <span class="s0">* Use in conjunction with get_num_redirect_steps() to extract the chain of</span>
 <span class="s0">* URL's that the channel was automatically redirected through to arrive at</span>
 <span class="s0">* the final document.</span>
 <span class="s0">*/ 2 4 this 3 891  1 n 1 846  </span>
<span class="s0">243 0 0 4 296 845 0 0 532 /**</span>
 <span class="s0">* Indicates whether the HTTPChannel should try to keep the connection to the</span>
 <span class="s0">* server open and reuse that connection for multiple documents, or whether it</span>
 <span class="s0">* should close the connection and open a new one for each request.  Set this</span>
 <span class="s0">* true to keep the connections around when possible, false to recycle them.</span>
 <span class="s0">*</span>
 <span class="s0">* It makes most sense to set this false when the HTTPChannel will be used</span>
 <span class="s0">* only once to retrieve a single document, true when you will be using the</span>
 <span class="s0">* same HTTPChannel object to retrieve multiple documents.</span>
 <span class="s0">*/ 2 4 this 3 885  21 persistent_connection 1 806  </span>
<span class="s0">244 0 0 6 297 806 0 0 267 /**</span>
 <span class="s0">* Returns whether the HTTPChannel should try to keep the connection to the</span>
 <span class="s0">* server open and reuse that connection for multiple documents, or whether it</span>
 <span class="s0">* should close the connection and open a new one for each request.  See</span>
 <span class="s0">* set_persistent_connection().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">245 0 0 6 298 806 0 0 217 /**</span>
 <span class="s0">* Returns true if the server has indicated it will close the connection after</span>
 <span class="s0">* this document has been read, or false if it will remain open (and future</span>
 <span class="s0">* documents may be requested on the same connection).</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">246 0 0 4 299 845 0 0 325 /**</span>
 <span class="s0">* If this is true (the normal case), the HTTPClient will be consulted for</span>
 <span class="s0">* information about the proxy to be used for each connection via this</span>
 <span class="s0">* HTTPChannel.  If this has been set to false by the user, then all</span>
 <span class="s0">* connections will be made directly, regardless of the proxy settings</span>
 <span class="s0">* indicated on the HTTPClient.</span>
 <span class="s0">*/ 2 4 this 3 885  11 allow_proxy 1 806  </span>
<span class="s0">247 0 0 6 300 806 0 0 325 /**</span>
 <span class="s0">* If this is true (the normal case), the HTTPClient will be consulted for</span>
 <span class="s0">* information about the proxy to be used for each connection via this</span>
 <span class="s0">* HTTPChannel.  If this has been set to false by the user, then all</span>
 <span class="s0">* connections will be made directly, regardless of the proxy settings</span>
 <span class="s0">* indicated on the HTTPClient.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">248 0 0 4 301 845 0 0 795 /**</span>
 <span class="s0">* Normally, a proxy is itself asked for ordinary URL's, and the proxy decides</span>
 <span class="s0">* whether to hand the client a cached version of the document or to contact</span>
 <span class="s0">* the server for a fresh version.  The proxy may also modify the headers and</span>
 <span class="s0">* transfer encoding on the way.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is set to true, then instead of asking for URL's from the proxy, we</span>
 <span class="s0">* will ask the proxy to open a connection to the server (for instance, on</span>
 <span class="s0">* port 80); if the proxy honors this request, then we contact the server</span>
 <span class="s0">* directly through this connection to retrieve the document.  If the proxy</span>
 <span class="s0">* does not honor the connect request, then the retrieve operation fails.</span>
 <span class="s0">*</span>
 <span class="s0">* SSL connections (e.g.  https), and connections through a Socks proxy, are</span>
 <span class="s0">* always tunneled, regardless of the setting of this flag.</span>
 <span class="s0">*/ 2 4 this 3 885  12 proxy_tunnel 1 806  </span>
<span class="s0">249 0 0 6 302 806 0 0 172 /**</span>
 <span class="s0">* Returns true if connections always tunnel through a proxy, or false (the</span>
 <span class="s0">* normal case) if we allow the proxy to serve up documents.  See</span>
 <span class="s0">* set_proxy_tunnel().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">250 0 0 4 303 845 0 0 322 /**</span>
 <span class="s0">* Sets the maximum length of time, in seconds, that the channel will wait</span>
 <span class="s0">* before giving up on establishing a TCP connection.</span>
 <span class="s0">*</span>
 <span class="s0">* At present, this is used only for the nonblocking interfaces (e.g.</span>
 <span class="s0">* begin_get_document(), begin_connect_to()), but it is used whether</span>
 <span class="s0">* set_blocking_connect() is true or false.</span>
 <span class="s0">*/ 2 4 this 3 885  15 timeout_seconds 1 854  </span>
<span class="s0">251 0 0 6 304 854 0 0 130 /**</span>
 <span class="s0">* Returns the length of time, in seconds, to wait for a new nonblocking</span>
 <span class="s0">* socket to connect.  See set_connect_timeout().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">252 0 0 4 305 845 0 0 641 /**</span>
 <span class="s0">* If this flag is true, a socket connect will block even for nonblocking I/O</span>
 <span class="s0">* calls like begin_get_document(), begin_connect_to(), etc.  If false, a</span>
 <span class="s0">* socket connect will not block for nonblocking I/O calls, but will block for</span>
 <span class="s0">* blocking I/O calls (get_document(), connect_to(), etc.).</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this true is useful when you want to use non-blocking I/O once you</span>
 <span class="s0">* have established the connection, but you don't want to bother with polling</span>
 <span class="s0">* for the initial connection.  It's also useful when you don't particularly</span>
 <span class="s0">* care about non-blocking I/O, but you need to respect timeouts like</span>
 <span class="s0">* connect_timeout and http_timeout.</span>
 <span class="s0">*/ 2 4 this 3 885  16 blocking_connect 1 806  </span>
<span class="s0">253 0 0 6 306 806 0 0 298 /**</span>
 <span class="s0">* If this flag is true, a socket connect will block even for nonblocking I/O</span>
 <span class="s0">* calls like begin_get_document(), begin_connect_to(), etc.  If false, a</span>
 <span class="s0">* socket connect will not block for nonblocking I/O calls, but will block for</span>
 <span class="s0">* blocking I/O calls (get_document(), connect_to(), etc.).</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">254 0 0 4 307 845 0 0 485 /**</span>
 <span class="s0">* Sets the maximum length of time, in seconds, that the channel will wait for</span>
 <span class="s0">* the HTTP server to finish sending its response to our request.</span>
 <span class="s0">*</span>
 <span class="s0">* The timer starts counting after the TCP connection has been established</span>
 <span class="s0">* (see set_connect_timeout(), above) and the request has been sent.</span>
 <span class="s0">*</span>
 <span class="s0">* At present, this is used only for the nonblocking interfaces (e.g.</span>
 <span class="s0">* begin_get_document(), begin_connect_to()), but it is used whether</span>
 <span class="s0">* set_blocking_connect() is true or false.</span>
 <span class="s0">*/ 2 4 this 3 885  15 timeout_seconds 1 854  </span>
<span class="s0">255 0 0 6 308 854 0 0 133 /**</span>
 <span class="s0">* Returns the length of time, in seconds, to wait for the HTTP server to</span>
 <span class="s0">* respond to our request.  See set_http_timeout().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">256 0 0 4 309 845 0 0 632 /**</span>
 <span class="s0">* Specifies the maximum number of bytes in a received (but unwanted) body</span>
 <span class="s0">* that will be skipped past, in order to reset to a new request.</span>
 <span class="s0">*</span>
 <span class="s0">* That is, if this HTTPChannel requests a file via get_document(), but does</span>
 <span class="s0">* not call download_to_ram(), download_to_file(), or open_read_body(), and</span>
 <span class="s0">* instead immediately requests a new file, then the HTTPChannel has a choice</span>
 <span class="s0">* whether to skip past the unwanted document, or to close the connection and</span>
 <span class="s0">* open a new one.  If the number of bytes to skip is more than this</span>
 <span class="s0">* threshold, the connection will be closed; otherwise, the data will simply</span>
 <span class="s0">* be read and discarded.</span>
 <span class="s0">*/ 2 4 this 3 885  14 skip_body_size 1 869  </span>
<span class="s0">257 0 0 6 310 869 0 0 176 /**</span>
 <span class="s0">* Returns the maximum number of bytes in a received (but unwanted) body that</span>
 <span class="s0">* will be skipped past, in order to reset to a new request.  See</span>
 <span class="s0">* set_skip_body_size().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">258 0 0 4 311 845 0 0 387 /**</span>
 <span class="s0">* Specifies the amount of time, in seconds, in which a previously-established</span>
 <span class="s0">* connection is allowed to remain open and unused.  If a previous connection</span>
 <span class="s0">* has remained unused for at least this number of seconds, it will be closed</span>
 <span class="s0">* and a new connection will be opened; otherwise, the same connection will be</span>
 <span class="s0">* reused for the next request (for this particular HTTPChannel).</span>
 <span class="s0">*/ 2 4 this 3 885  12 idle_timeout 1 854  </span>
<span class="s0">259 0 0 6 312 854 0 0 162 /**</span>
 <span class="s0">* Returns the amount of time, in seconds, in which an previously-established</span>
 <span class="s0">* connection is allowed to remain open and unused.  See set_idle_timeout().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">260 0 0 4 313 845 0 0 686 /**</span>
 <span class="s0">* Specifies whether nonblocking downloads (via download_to_file() or</span>
 <span class="s0">* download_to_ram()) will be limited so as not to use all available</span>
 <span class="s0">* bandwidth.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is true, when a download has been started on this channel it will</span>
 <span class="s0">* be invoked no more frequently than get_max_updates_per_second(), and the</span>
 <span class="s0">* total bandwidth used by the download will be no more than</span>
 <span class="s0">* get_max_bytes_per_second().  If this is false, downloads will proceed as</span>
 <span class="s0">* fast as the server can send the data.</span>
 <span class="s0">*</span>
 <span class="s0">* This only has effect on the nonblocking I/O methods like</span>
 <span class="s0">* begin_get_document(), etc.  The blocking methods like get_document() always</span>
 <span class="s0">* use as much CPU and bandwidth as they can get.</span>
 <span class="s0">*/ 2 4 this 3 885  17 download_throttle 1 806  </span>
<span class="s0">261 0 0 6 314 806 0 0 112 /**</span>
 <span class="s0">* Returns whether the nonblocking downloads will be bandwidth-limited.  See</span>
 <span class="s0">* set_download_throttle().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">262 0 0 4 315 845 0 0 178 /**</span>
 <span class="s0">* When bandwidth throttling is in effect (see set_download_throttle()), this</span>
 <span class="s0">* specifies the maximum number of bytes per second that may be consumed by</span>
 <span class="s0">* this channel.</span>
 <span class="s0">*/ 2 4 this 3 885  20 max_bytes_per_second 1 854  </span>
<span class="s0">263 0 0 6 316 854 0 0 135 /**</span>
 <span class="s0">* Returns the maximum number of bytes per second that may be consumed by this</span>
 <span class="s0">* channel when get_download_throttle() is true.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">264 0 0 4 317 845 0 0 194 /**</span>
 <span class="s0">* When bandwidth throttling is in effect (see set_download_throttle()), this</span>
 <span class="s0">* specifies the maximum number of times per second that run() will attempt to</span>
 <span class="s0">* do any downloading at all.</span>
 <span class="s0">*/ 2 4 this 3 885  22 max_updates_per_second 1 854  </span>
<span class="s0">265 0 0 6 318 854 0 0 134 /**</span>
 <span class="s0">* Returns the maximum number of times per second that run() will do anything</span>
 <span class="s0">* at all, when get_download_throttle() is true.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">266 0 0 4 319 845 0 0 127 /**</span>
 <span class="s0">* Specifies the Content-Type header, useful for applications that require</span>
 <span class="s0">* different types of content, such as JSON.</span>
 <span class="s0">*/ 2 4 this 3 885  12 content_type 1 868  </span>
<span class="s0">267 0 0 6 320 868 0 0 56 /**</span>
 <span class="s0">* Returns the value of the Content-Type header.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">268 0 0 4 321 845 0 0 320 /**</span>
 <span class="s0">* This may be called immediately after a call to get_document() or some</span>
 <span class="s0">* related function to specify the expected size of the document we are</span>
 <span class="s0">* retrieving, if we happen to know.  This is used as the return value to</span>
 <span class="s0">* get_file_size() only in the case that the server does not tell us the</span>
 <span class="s0">* actual file size.</span>
 <span class="s0">*/ 2 4 this 3 885  9 file_size 1 869  </span>
<span class="s0">269 0 0 6 322 893 0 0 506 /**</span>
 <span class="s0">* Returns the size of the file, if it is known.  Returns the value set by</span>
 <span class="s0">* set_expected_file_size() if the file size is not known, or 0 if this value</span>
 <span class="s0">* was not set.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is dynamically generated, the size may not be available until a</span>
 <span class="s0">* read has started (e.g.  open_read_body() has been called); and even then it</span>
 <span class="s0">* may increase as more of the file is read due to the nature of HTTP/1.1</span>
 <span class="s0">* requests which can change their minds midstream about how much data they're</span>
 <span class="s0">* sending you.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">270 0 0 6 323 806 0 0 327 /**</span>
 <span class="s0">* Returns true if the size of the file we are currently retrieving was told</span>
 <span class="s0">* us by the server and thus is reliably known, or false if the size reported</span>
 <span class="s0">* by get_file_size() represents an educated guess (possibly as set by</span>
 <span class="s0">* set_expected_file_size(), or as inferred from a chunked transfer encoding</span>
 <span class="s0">* in progress).</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">271 0 0 6 324 869 0 0 289 /**</span>
 <span class="s0">* Returns the first byte of the file requested by the request.  This will</span>
 <span class="s0">* normally be 0 to indicate that the file is being requested from the</span>
 <span class="s0">* beginning, but if the file was requested via a get_subdocument() call, this</span>
 <span class="s0">* will contain the first_byte parameter from that call.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">272 0 0 6 325 869 0 0 285 /**</span>
 <span class="s0">* Returns the last byte of the file requested by the request.  This will</span>
 <span class="s0">* normally be 0 to indicate that the file is being requested to its last</span>
 <span class="s0">* byte, but if the file was requested via a get_subdocument() call, this will</span>
 <span class="s0">* contain the last_byte parameter from that call.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">273 0 0 6 326 869 0 0 367 /**</span>
 <span class="s0">* Returns the first byte of the file (that will be) delivered by the server</span>
 <span class="s0">* in response to the current request.  Normally, this is the same as</span>
 <span class="s0">* get_first_byte_requested(), but some servers will ignore a subdocument</span>
 <span class="s0">* request and always return the whole file, in which case this value will be</span>
 <span class="s0">* 0, regardless of what was requested to get_subdocument().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">274 0 0 6 327 869 0 0 365 /**</span>
 <span class="s0">* Returns the last byte of the file (that will be) delivered by the server in</span>
 <span class="s0">* response to the current request.  Normally, this is the same as</span>
 <span class="s0">* get_last_byte_requested(), but some servers will ignore a subdocument</span>
 <span class="s0">* request and always return the whole file, in which case this value will be</span>
 <span class="s0">* 0, regardless of what was requested to get_subdocument().</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">275 0 0 4 328 845 0 0 97 /**</span>
 <span class="s0">* Outputs a list of all headers defined by the server to the indicated output</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/ 2 4 this 3 891  3 out 1 858  </span>
<span class="s0">276 0 0 4 329 845 0 0 538 /**</span>
 <span class="s0">* Stops whatever file transaction is currently in progress, closes the</span>
 <span class="s0">* connection, and resets to begin anew.  You shouldn't ever need to call</span>
 <span class="s0">* this, since the channel should be able to reset itself cleanly between</span>
 <span class="s0">* requests, but it is provided in case you are an especially nervous type.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this after every request unless you set</span>
 <span class="s0">* set_persistent_connection() to false, since calling reset() rudely closes</span>
 <span class="s0">* the connection regardless of whether we have told the server we intend to</span>
 <span class="s0">* keep it open or not.</span>
 <span class="s0">*/ 1 4 this 3 885  </span>
<span class="s0">277 0 0 4 330 845 0 0 487 /**</span>
 <span class="s0">* Preserves the previous status code (presumably a failure) from the previous</span>
 <span class="s0">* connection attempt.  If the subsequent connection attempt also fails, the</span>
 <span class="s0">* returned status code will be the better of the previous code and the</span>
 <span class="s0">* current code.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be called to daisy-chain subsequent attempts to download the same</span>
 <span class="s0">* document from different servers.  After all servers have been attempted,</span>
 <span class="s0">* the final status code will reflect the attempt that most nearly succeeded.</span>
 <span class="s0">*/ 1 4 this 3 885  </span>
<span class="s0">278 0 0 4 331 845 0 0 99 /**</span>
 <span class="s0">* Resets the extra headers that were previously added via calls to</span>
 <span class="s0">* send_extra_header().</span>
 <span class="s0">*/ 1 4 this 3 885  </span>
<span class="s0">279 0 0 4 332 845 0 0 352 /**</span>
 <span class="s0">* Specifies an additional key: value pair that is added into the header sent</span>
 <span class="s0">* to the server with the next request.  This is passed along with no</span>
 <span class="s0">* interpretation by the HTTPChannel code.  You may call this repeatedly to</span>
 <span class="s0">* append multiple headers.</span>
 <span class="s0">*</span>
 <span class="s0">* This is persistent for one request only; it must be set again for each new</span>
 <span class="s0">* request.</span>
 <span class="s0">*/ 3 4 this 3 885  3 key 1 868  5 value 1 868  </span>
<span class="s0">280 0 0 6 333 806 0 0 111 /**</span>
 <span class="s0">* Opens the named document for reading, if available.  Returns true if</span>
 <span class="s0">* successful, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">281 0 0 6 334 806 0 0 313 /**</span>
 <span class="s0">* Retrieves only the specified byte range of the indicated document.  If</span>
 <span class="s0">* last_byte is 0, it stands for the last byte of the document.  When a</span>
 <span class="s0">* subdocument is requested, get_file_size() and get_bytes_downloaded() will</span>
 <span class="s0">* report the number of bytes of the subdocument, not of the complete</span>
 <span class="s0">* document.</span>
 <span class="s0">*/ 4 4 this 3 885  3 url 1 889  10 first_byte 1 869  9 last_byte 1 869  </span>
<span class="s0">282 0 0 6 335 806 0 0 252 /**</span>
 <span class="s0">* Like get_document(), except only the header associated with the document is</span>
 <span class="s0">* retrieved.  This may be used to test for existence of the document; it</span>
 <span class="s0">* might also return the size of the document (if the server gives us this</span>
 <span class="s0">* information).</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">283 0 0 6 336 806 0 0 74 /**</span>
 <span class="s0">* Posts form data to a particular URL and retrieves the response.</span>
 <span class="s0">*/ 3 4 this 3 885  3 url 1 889  4 body 1 868  </span>
<span class="s0">284 0 0 6 337 806 0 0 111 /**</span>
 <span class="s0">* Uploads the indicated body to the server to replace the indicated URL, if</span>
 <span class="s0">* the server allows this.</span>
 <span class="s0">*/ 3 4 this 3 885  3 url 1 889  4 body 1 868  </span>
<span class="s0">285 0 0 6 338 806 0 0 59 /**</span>
 <span class="s0">* Requests the server to remove the indicated URL.</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">286 0 0 6 339 806 0 0 159 /**</span>
 <span class="s0">* Sends a TRACE message to the server, which should return back the same</span>
 <span class="s0">* message as the server received it, allowing inspection of proxy hops, etc.</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">287 0 0 6 340 806 0 0 319 /**</span>
 <span class="s0">* Establish a direct connection to the server and port indicated by the URL,</span>
 <span class="s0">* but do not issue any HTTP requests.  If successful, the connection may then</span>
 <span class="s0">* be taken to use for whatever purposes you like by calling get_connection().</span>
 <span class="s0">*</span>
 <span class="s0">* This establishes a blocking I/O socket.  Also see begin_connect_to().</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">288 0 0 6 341 806 0 0 136 /**</span>
 <span class="s0">* Sends an OPTIONS message to the server, which should query the available</span>
 <span class="s0">* options, possibly in relation to a specified URL.</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">289 0 0 4 342 845 0 0 445 /**</span>
 <span class="s0">* Begins a non-blocking request to retrieve a given document.  This method</span>
 <span class="s0">* will return immediately, even before a connection to the server has</span>
 <span class="s0">* necessarily been established; you must then call run() from time to time</span>
 <span class="s0">* until the return value of run() is false.  Then you may check is_valid()</span>
 <span class="s0">* and get_status_code() to determine the status of your request.</span>
 <span class="s0">*</span>
 <span class="s0">* If a previous request had been pending, that request is discarded.</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">290 0 0 4 343 845 0 0 345 /**</span>
 <span class="s0">* Begins a non-blocking request to retrieve only the specified byte range of</span>
 <span class="s0">* the indicated document.  If last_byte is 0, it stands for the last byte of</span>
 <span class="s0">* the document.  When a subdocument is requested, get_file_size() and</span>
 <span class="s0">* get_bytes_downloaded() will report the number of bytes of the subdocument,</span>
 <span class="s0">* not of the complete document.</span>
 <span class="s0">*/ 4 4 this 3 885  3 url 1 889  10 first_byte 1 869  9 last_byte 1 869  </span>
<span class="s0">291 0 0 4 344 845 0 0 115 /**</span>
 <span class="s0">* Begins a non-blocking request to retrieve a given header.  See</span>
 <span class="s0">* begin_get_document() and get_header().</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">292 0 0 4 345 845 0 0 431 /**</span>
 <span class="s0">* Posts form data to a particular URL and retrieves the response, all using</span>
 <span class="s0">* non-blocking I/O.  See begin_get_document() and post_form().</span>
 <span class="s0">*</span>
 <span class="s0">* It is important to note that you *must* call run() repeatedly after calling</span>
 <span class="s0">* this method until run() returns false, and you may not call any other</span>
 <span class="s0">* document posting or retrieving methods using the HTTPChannel object in the</span>
 <span class="s0">* interim, or your form data may not get posted.</span>
 <span class="s0">*/ 3 4 this 3 885  3 url 1 889  4 body 1 868  </span>
<span class="s0">293 0 0 6 346 806 0 0 425 /**</span>
 <span class="s0">* This must be called from time to time when non-blocking I/O is in use.  It</span>
 <span class="s0">* checks for data coming in on the socket and writes data out to the socket</span>
 <span class="s0">* when possible, and does whatever processing is required towards completing</span>
 <span class="s0">* the current task.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the task is still pending (and run() will need</span>
 <span class="s0">* to be called again in the future), or false if the current task is</span>
 <span class="s0">* complete.</span>
 <span class="s0">*/ 1 4 this 3 885  </span>
<span class="s0">294 0 0 4 347 845 0 0 536 /**</span>
 <span class="s0">* Begins a non-blocking request to establish a direct connection to the</span>
 <span class="s0">* server and port indicated by the URL.  No HTTP requests will be issued</span>
 <span class="s0">* beyond what is necessary to establish the connection.  When run() has</span>
 <span class="s0">* finished, you may call is_connection_ready() to determine if the connection</span>
 <span class="s0">* was successfully established.</span>
 <span class="s0">*</span>
 <span class="s0">* If successful, the connection may then be taken to use for whatever</span>
 <span class="s0">* purposes you like by calling get_connection().</span>
 <span class="s0">*</span>
 <span class="s0">* This establishes a nonblocking I/O socket.  Also see connect_to().</span>
 <span class="s0">*/ 2 4 this 3 885  3 url 1 889  </span>
<span class="s0">295 0 0 6 348 855 0 0 569 /**</span>
 <span class="s0">* Returns a newly-allocated istream suitable for reading the body of the</span>
 <span class="s0">* document.  This may only be called immediately after a call to</span>
 <span class="s0">* get_document() or post_form(), or after a call to run() has returned false.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that, in nonblocking mode, the returned stream may report an early</span>
 <span class="s0">* EOF, even before the actual end of file.  When this happens, you should</span>
 <span class="s0">* call stream-&gt;is_closed() to determine whether you should attempt to read</span>
 <span class="s0">* some more later.</span>
 <span class="s0">*</span>
 <span class="s0">* The user is responsible for passing the returned istream to</span>
 <span class="s0">* close_read_body() later.</span>
 <span class="s0">*/ 1 4 this 3 885  </span>
<span class="s0">296 0 0 4 349 845 0 0 243 /**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_body().  This really</span>
 <span class="s0">* just deletes the istream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/ 2 4 this 3 891  6 stream 1 856  </span>
<span class="s0">297 0 0 6 350 806 0 0 1345 /**</span>
 <span class="s0">* Specifies the name of a file to download the resulting document to.  This</span>
 <span class="s0">* should be called immediately after get_document() or begin_get_document()</span>
 <span class="s0">* or related functions.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of the blocking I/O methods like get_document(), this function</span>
 <span class="s0">* will download the entire document to the file and return true if it was</span>
 <span class="s0">* successfully downloaded, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of non-blocking I/O methods like begin_get_document(), this</span>
 <span class="s0">* function simply indicates an intention to download to the indicated file.</span>
 <span class="s0">* It returns true if the file can be opened for writing, false otherwise, but</span>
 <span class="s0">* the contents will not be completely downloaded until run() has returned</span>
 <span class="s0">* false.  At this time, it is possible that a communications error will have</span>
 <span class="s0">* left a partial file, so is_download_complete() may be called to test this.</span>
 <span class="s0">*</span>
 <span class="s0">* If subdocument_resumes is true and the document in question was previously</span>
 <span class="s0">* requested as a subdocument (i.e.  get_subdocument() with a first_byte value</span>
 <span class="s0">* greater than zero), this will automatically seek to the appropriate byte</span>
 <span class="s0">* within the file for writing the output.  In this case, the file must</span>
 <span class="s0">* already exist and must have at least first_byte bytes in it.  If</span>
 <span class="s0">* subdocument_resumes is false, a subdocument will always be downloaded</span>
 <span class="s0">* beginning at the first byte of the file.</span>
 <span class="s0">*/ 3 4 this 3 885  8 filename 1 865  19 subdocument_resumes 5 806  </span>
<span class="s0">298 0 0 6 351 806 0 0 1223 /**</span>
 <span class="s0">* Specifies a Ramfile object to download the resulting document to.  This</span>
 <span class="s0">* should be called immediately after get_document() or begin_get_document()</span>
 <span class="s0">* or related functions.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of the blocking I/O methods like get_document(), this function</span>
 <span class="s0">* will download the entire document to the Ramfile and return true if it was</span>
 <span class="s0">* successfully downloaded, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of non-blocking I/O methods like begin_get_document(), this</span>
 <span class="s0">* function simply indicates an intention to download to the indicated</span>
 <span class="s0">* Ramfile.  It returns true if the file can be opened for writing, false</span>
 <span class="s0">* otherwise, but the contents will not be completely downloaded until run()</span>
 <span class="s0">* has returned false.  At this time, it is possible that a communications</span>
 <span class="s0">* error will have left a partial file, so is_download_complete() may be</span>
 <span class="s0">* called to test this.</span>
 <span class="s0">*</span>
 <span class="s0">* If subdocument_resumes is true and the document in question was previously</span>
 <span class="s0">* requested as a subdocument (i.e.  get_subdocument() with a first_byte value</span>
 <span class="s0">* greater than zero), this will automatically seek to the appropriate byte</span>
 <span class="s0">* within the Ramfile for writing the output.  In this case, the Ramfile must</span>
 <span class="s0">* already have at least first_byte bytes in it.</span>
 <span class="s0">*/ 3 4 this 3 885  7 ramfile 1 895  19 subdocument_resumes 5 806  </span>
<span class="s0">299 0 0 6 352 806 0 0 1348 /**</span>
 <span class="s0">* Specifies the name of an ostream to download the resulting document to.</span>
 <span class="s0">* This should be called immediately after get_document() or</span>
 <span class="s0">* begin_get_document() or related functions.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of the blocking I/O methods like get_document(), this function</span>
 <span class="s0">* will download the entire document to the file and return true if it was</span>
 <span class="s0">* successfully downloaded, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of non-blocking I/O methods like begin_get_document(), this</span>
 <span class="s0">* function simply indicates an intention to download to the indicated file.</span>
 <span class="s0">* It returns true if the file can be opened for writing, false otherwise, but</span>
 <span class="s0">* the contents will not be completely downloaded until run() has returned</span>
 <span class="s0">* false.  At this time, it is possible that a communications error will have</span>
 <span class="s0">* left a partial file, so is_download_complete() may be called to test this.</span>
 <span class="s0">*</span>
 <span class="s0">* If subdocument_resumes is true and the document in question was previously</span>
 <span class="s0">* requested as a subdocument (i.e.  get_subdocument() with a first_byte value</span>
 <span class="s0">* greater than zero), this will automatically seek to the appropriate byte</span>
 <span class="s0">* within the file for writing the output.  In this case, the file must</span>
 <span class="s0">* already exist and must have at least first_byte bytes in it.  If</span>
 <span class="s0">* subdocument_resumes is false, a subdocument will always be downloaded</span>
 <span class="s0">* beginning at the first byte of the file.</span>
 <span class="s0">*/ 3 4 this 3 885  4 strm 1 858  19 subdocument_resumes 5 806  </span>
<span class="s0">300 0 0 6 353 859 0 0 351 /**</span>
 <span class="s0">* Returns the connection that was established via a previous call to</span>
 <span class="s0">* connect_to() or begin_connect_to(), or NULL if the connection attempt</span>
 <span class="s0">* failed or if those methods have not recently been called.</span>
 <span class="s0">*</span>
 <span class="s0">* This stream has been allocated from the free store.  It is the user's</span>
 <span class="s0">* responsibility to delete this pointer when finished with it.</span>
 <span class="s0">*/ 1 4 this 3 885  </span>
<span class="s0">301 0 0 6 354 869 0 0 331 /**</span>
 <span class="s0">* Returns the number of bytes downloaded during the last (or current)</span>
 <span class="s0">* download_to_file() or download_to_ram operation().  This can be used in</span>
 <span class="s0">* conjunction with get_file_size() to report the percent complete (but be</span>
 <span class="s0">* careful, since get_file_size() may return 0 if the server has not told us</span>
 <span class="s0">* the size of the file).</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">302 0 0 6 355 869 0 0 658 /**</span>
 <span class="s0">* When download throttling is in effect (set_download_throttle() has been set</span>
 <span class="s0">* to true) and non-blocking I/O methods (like begin_get_document()) are used,</span>
 <span class="s0">* this returns the number of bytes &quot;requested&quot; from the server so far: that</span>
 <span class="s0">* is, the theoretical maximum value for get_bytes_downloaded(), if the server</span>
 <span class="s0">* has been keeping up with our demand.</span>
 <span class="s0">*</span>
 <span class="s0">* If this number is less than get_bytes_downloaded(), then the server has not</span>
 <span class="s0">* been supplying bytes fast enough to meet our own download throttle rate.</span>
 <span class="s0">*</span>
 <span class="s0">* When download throttling is not in effect, or when the blocking I/O methods</span>
 <span class="s0">* (like get_document(), etc.) are used, this returns 0.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">303 0 0 6 356 806 0 0 600 /**</span>
 <span class="s0">* Returns true when a download_to() or download_to_ram() has executed and the</span>
 <span class="s0">* file has been fully downloaded.  If this still returns false after</span>
 <span class="s0">* processing has completed, there was an error in transmission.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simply testing is_download_complete() does not prove that the</span>
 <span class="s0">* requested document was successfully retrieved--you might have just</span>
 <span class="s0">* downloaded the &quot;404 not found&quot; stub (for instance) that a server would</span>
 <span class="s0">* provide in response to some error condition.  You should also check</span>
 <span class="s0">* is_valid() to prove that the file you expected has been successfully</span>
 <span class="s0">* retrieved.</span>
 <span class="s0">*/ 1 4 this 3 891  </span>
<span class="s0">304 0 0 7 357 898 0 0 0 0 </span>
<span class="s0">305 0 0 7 360 899 703 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">306 0 0 15 360 899 703 0 0 1 6 param0 0 900  </span>
<span class="s0">307 0 0 6 362 846 0 0 201 /**</span>
 <span class="s0">* Begins a background decompression of the named file (whose filename must</span>
 <span class="s0">* end in &quot;.pz&quot;) to a new file without the .pz extension.  The source file is</span>
 <span class="s0">* removed after successful completion.</span>
 <span class="s0">*/ 2 4 this 3 899  11 source_file 1 865  </span>
<span class="s0">308 0 0 6 362 846 0 0 162 /**</span>
 <span class="s0">* Begins a background decompression from the named source file to the named</span>
 <span class="s0">* destination file.  The source file is removed after successful completion.</span>
 <span class="s0">*/ 3 4 this 3 899  11 source_file 1 865  9 dest_file 1 865  </span>
<span class="s0">309 0 0 6 363 846 0 0 227 /**</span>
 <span class="s0">* Called each frame to do the next bit of work in the background task.</span>
 <span class="s0">* Returns EU_ok if a chunk is completed but there is more to go, or</span>
 <span class="s0">* EU_success when we're all done.  Any other return value indicates an error.</span>
 <span class="s0">*/ 1 4 this 3 899  </span>
<span class="s0">310 0 0 6 364 806 0 0 121 /**</span>
 <span class="s0">* Performs a foreground decompression of the named file; does not return</span>
 <span class="s0">* until the decompression is complete.</span>
 <span class="s0">*/ 2 4 this 3 899  11 source_file 1 865  </span>
<span class="s0">311 0 0 6 364 806 0 0 152 /**</span>
 <span class="s0">* Does an in-memory decompression of the indicated Ramfile.  The decompressed</span>
 <span class="s0">* contents are written back into the same Ramfile on completion.</span>
 <span class="s0">*/ 2 4 this 3 899  20 source_and_dest_file 1 895  </span>
<span class="s0">312 0 0 6 365 827 0 0 78 /**</span>
 <span class="s0">* Returns the ratio through the decompression step in the background.</span>
 <span class="s0">*/ 1 4 this 3 900  </span>
<span class="s0">313 0 0 7 371 902 709 0 38 /**</span>
 <span class="s0">* Primarily used for testing.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">314 0 0 15 371 902 709 0 0 1 6 param0 0 903  </span>
<span class="s0">315 0 0 7 371 902 709 0 64 /**</span>
 <span class="s0">* Create a download db with these client and server dbs</span>
 <span class="s0">*/ 2 11 server_file 1 905  11 client_file 1 905  </span>
<span class="s0">316 0 0 7 371 902 709 0 64 /**</span>
 <span class="s0">* Create a download db with these client and server dbs</span>
 <span class="s0">*/ 2 11 server_file 1 895  11 client_file 1 905  </span>
<span class="s0">317 0 0 4 373 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  3 out 1 858  </span>
<span class="s0">318 0 0 4 374 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  3 out 1 858  </span>
<span class="s0">319 0 0 4 375 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  3 out 1 858  </span>
<span class="s0">320 0 0 6 376 806 0 0 24 // Write a database file 2 4 this 3 902  4 file 1 905  </span>
<span class="s0">321 0 0 6 377 806 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 902  4 file 1 905  </span>
<span class="s0">322 0 0 6 378 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 903  </span>
<span class="s0">323 0 0 6 379 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 903  </span>
<span class="s0">324 0 0 6 380 868 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  5 index 1 846  </span>
<span class="s0">325 0 0 6 381 868 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  5 index 1 846  </span>
<span class="s0">326 0 0 6 382 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">327 0 0 4 383 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 902  6 mfname 1 868  4 size 1 846  </span>
<span class="s0">328 0 0 6 384 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 902  6 mfname 1 868  4 size 1 846  </span>
<span class="s0">329 0 0 6 385 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">330 0 0 4 386 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 902  6 mfname 1 868  4 size 1 846  </span>
<span class="s0">331 0 0 6 387 906 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">332 0 0 6 388 906 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">333 0 0 4 389 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 902  6 mfname 1 868  </span>
<span class="s0">334 0 0 4 390 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 902  6 mfname 1 868  </span>
<span class="s0">335 0 0 4 391 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 902  6 mfname 1 868  </span>
<span class="s0">336 0 0 4 392 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 902  6 mfname 1 868  </span>
<span class="s0">337 0 0 6 393 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">338 0 0 6 394 868 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 903  6 mfname 1 868  5 index 1 846  </span>
<span class="s0">339 0 0 6 395 806 0 0 28 // Queries from the Launcher 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">340 0 0 6 396 806 0 0 147 /**</span>
 <span class="s0">* A multifile is complete when it is completely downloaded.  Note: it may</span>
 <span class="s0">* already be decompressed or extracted and it is still complete</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">341 0 0 6 397 806 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">342 0 0 6 398 806 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">343 0 0 7 399 908 0 0 62 /**</span>
 <span class="s0">* Return the hash value of the file we are working on</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">344 0 0 4 400 845 0 0 55 /**</span>
 <span class="s0">* Set the hash value of file we are working on</span>
 <span class="s0">*/ 3 4 this 3 902  6 mfname 1 868  3 val 1 908  </span>
<span class="s0">345 0 0 7 401 908 0 0 51 /**</span>
 <span class="s0">* Return the hash value of the server file</span>
 <span class="s0">*/ 2 4 this 3 903  6 mfname 1 868  </span>
<span class="s0">346 0 0 4 402 845 0 0 55 /**</span>
 <span class="s0">* Set the hash value of file we are working on</span>
 <span class="s0">*/ 3 4 this 3 902  6 mfname 1 868  3 val 1 908  </span>
<span class="s0">347 0 0 4 403 845 0 0 27 // Operations on multifiles 2 4 this 3 902  6 mfname 1 868  </span>
<span class="s0">348 0 0 4 404 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 902  13 server_mfname 1 868  </span>
<span class="s0">349 0 0 4 405 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 902  6 mfname 1 868  </span>
<span class="s0">350 0 0 4 406 845 0 0 76 /**</span>
 <span class="s0">* Used on the server side makefiles to create a new clean server db</span>
 <span class="s0">*/ 1 4 this 3 902  </span>
<span class="s0">351 0 0 4 407 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 902  6 mfname 1 868  5 phase 1 906  4 size 1 846  6 status 1 846  </span>
<span class="s0">352 0 0 4 408 845 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 902  6 mfname 1 868  5 fname 1 868  </span>
<span class="s0">353 0 0 7 409 910 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 902  4 file 1 905  16 want_server_info 1 806  </span>
<span class="s0">354 0 0 7 409 910 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 902  4 file 1 895  16 want_server_info 1 806  </span>
<span class="s0">355 0 0 6 410 806 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 902  4 file 1 905  2 db 1 910  16 want_server_info 1 806  </span>
<span class="s0">356 0 0 4 411 845 0 0 176 /**</span>
 <span class="s0">* Appends a new version of the file onto the end of the list, or changes the</span>
 <span class="s0">* hash associated with a version previously added.</span>
 <span class="s0">*</span>
 <span class="s0">* Note: version numbers start at 1</span>
 <span class="s0">*/ 4 4 this 3 902  4 name 1 865  4 hash 1 911  7 version 1 846  </span>
<span class="s0">357 0 0 4 412 845 0 0 97 /**</span>
 <span class="s0">* Inserts a new version 1 copy of the file, sliding all the other versions up</span>
 <span class="s0">* by one.</span>
 <span class="s0">*/ 3 4 this 3 902  4 name 1 865  4 hash 1 911  </span>
<span class="s0">358 0 0 6 413 806 0 0 164 /**</span>
 <span class="s0">* Returns true if the indicated file has version information, false</span>
 <span class="s0">* otherwise.  Some files recorded in the database may not bother to track</span>
 <span class="s0">* versions.</span>
 <span class="s0">*/ 2 4 this 3 903  4 name 1 865  </span>
<span class="s0">359 0 0 6 414 846 0 0 72 /**</span>
 <span class="s0">* Returns the number of versions stored for the indicated file.</span>
 <span class="s0">*/ 2 4 this 3 903  4 name 1 865  </span>
<span class="s0">360 0 0 4 415 845 0 0 146 /**</span>
 <span class="s0">* Reduces the number of versions of a particular file stored in the ddb by</span>
 <span class="s0">* throwing away all versions higher than the indicated index.</span>
 <span class="s0">*/ 3 4 this 3 902  4 name 1 865  12 num_versions 1 846  </span>
<span class="s0">361 0 0 6 416 846 0 0 183 /**</span>
 <span class="s0">* Returns the version number of this particular file, determined by looking</span>
 <span class="s0">* up the hash generated from the file.  Returns -1 if the version number</span>
 <span class="s0">* cannot be determined.</span>
 <span class="s0">*/ 3 4 this 3 903  4 name 1 865  4 hash 1 911  </span>
<span class="s0">362 0 0 6 417 911 0 0 95 /**</span>
 <span class="s0">* Returns the MD5 hash associated with the indicated version of the indicated</span>
 <span class="s0">* file.</span>
 <span class="s0">*/ 3 4 this 3 903  4 name 1 865  7 version 1 846  </span>
<span class="s0">363 0 0 7 421 913 758 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">364 0 0 6 423 806 0 0 147 /**</span>
 <span class="s0">* Specifies the filename of the Multifile that the Extractor will read.</span>
 <span class="s0">* Returns true on success, false if the mulifile name is invalid.</span>
 <span class="s0">*/ 2 4 this 3 913  14 multifile_name 1 865  </span>
<span class="s0">365 0 0 4 424 845 0 0 192 /**</span>
 <span class="s0">* Specifies the directory into which all extracted subfiles will be written.</span>
 <span class="s0">* Relative paths of subfiles within the Multifile will be written as relative</span>
 <span class="s0">* paths to this directory.</span>
 <span class="s0">*/ 2 4 this 3 913  11 extract_dir 1 865  </span>
<span class="s0">366 0 0 4 425 845 0 0 132 /**</span>
 <span class="s0">* Interrupts the Extractor in the middle of its business and makes it ready</span>
 <span class="s0">* to accept a new list of subfiles to extract.</span>
 <span class="s0">*/ 1 4 this 3 913  </span>
<span class="s0">367 0 0 6 426 806 0 0 145 /**</span>
 <span class="s0">* Requests a particular subfile to be extracted when step() or run() is</span>
 <span class="s0">* called.  Returns true if the subfile exists, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 913  12 subfile_name 1 865  </span>
<span class="s0">368 0 0 6 427 846 0 0 100 /**</span>
 <span class="s0">* Requests all subfiles in the Multifile to be extracted.  Returns the number</span>
 <span class="s0">* requested.</span>
 <span class="s0">*/ 1 4 this 3 913  </span>
<span class="s0">369 0 0 6 428 846 0 0 390 /**</span>
 <span class="s0">* After all of the requests have been made via request_file() or</span>
 <span class="s0">* request_all_subfiles(), call step() repeatedly until it stops returning</span>
 <span class="s0">* EU_ok.</span>
 <span class="s0">*</span>
 <span class="s0">* step() extracts the next small unit of data from the Multifile.  Returns</span>
 <span class="s0">* EU_ok if progress is continuing, EU_error_abort if there is a problem, or</span>
 <span class="s0">* EU_success when the last piece has been extracted.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see run().</span>
 <span class="s0">*/ 1 4 this 3 913  </span>
<span class="s0">370 0 0 6 429 827 0 0 66 /**</span>
 <span class="s0">* Returns the fraction of the Multifile extracted so far.</span>
 <span class="s0">*/ 1 4 this 3 914  </span>
<span class="s0">371 0 0 6 430 806 0 0 367 /**</span>
 <span class="s0">* A convenience function to extract the Multifile all at once, when you don't</span>
 <span class="s0">* care about doing it in the background.</span>
 <span class="s0">*</span>
 <span class="s0">* First, call request_file() or request_all_files() to specify the files you</span>
 <span class="s0">* would like to extract, then call run() to do the extraction.  Also see</span>
 <span class="s0">* step() for when you would like the extraction to happen as a background</span>
 <span class="s0">* task.</span>
 <span class="s0">*/ 1 4 this 3 913  </span>
<span class="s0">372 0 0 7 433 916 774 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">373 0 0 4 434 845 0 0 134 /**</span>
 <span class="s0">* Adds the indicated generic ostream to the multiplex output.  The ostream</span>
 <span class="s0">* will receive whatever data is sent to the pipe.</span>
 <span class="s0">*/ 3 4 this 3 916  3 out 1 858  12 delete_later 5 806  </span>
<span class="s0">374 0 0 6 435 806 0 0 104 /**</span>
 <span class="s0">* Adds the given file, previously opened using the C stdio library, to the</span>
 <span class="s0">* multiplex output.</span>
 <span class="s0">*/ 3 4 this 3 916  4 file 1 917  15 close_when_done 1 806  </span>
<span class="s0">375 0 0 4 436 845 0 0 44 /**</span>
 <span class="s0">* Adds the standard output channel.</span>
 <span class="s0">*/ 1 4 this 3 916  </span>
<span class="s0">376 0 0 6 437 806 0 0 159 /**</span>
 <span class="s0">* Adds the given file to the multiplex output.  The file is opened in append</span>
 <span class="s0">* mode with line buffering.  Returns false if the file cannot be opened.</span>
 <span class="s0">*/ 2 4 this 3 916  4 file 1 905  </span>
<span class="s0">377 0 0 4 438 845 0 0 247 /**</span>
 <span class="s0">* Adds the system debug output the the multiplex output.  This may map to a</span>
 <span class="s0">* syslog or some such os-specific output system.  It may do nothing on a</span>
 <span class="s0">* particular system.</span>
 <span class="s0">*</span>
 <span class="s0">* Presently, this maps only to OutputDebugString() on Windows.</span>
 <span class="s0">*/ 1 4 this 3 916  </span>
<span class="s0">378 0 0 4 439 845 0 0 62 /**</span>
 <span class="s0">* Forces out all output that hasn't yet been written.</span>
 <span class="s0">*/ 1 4 this 3 916  </span>
<span class="s0">379 0 0 7 443 898 0 0 0 0 </span>
<span class="s0">380 0 0 7 446 919 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 root 1 864  4 http 5 882  </span>
<span class="s0">381 0 0 7 447 882 0 0 72 /**</span>
 <span class="s0">* Returns the HTTPClient object that services this mount point.</span>
 <span class="s0">*/ 1 4 this 3 920  </span>
<span class="s0">382 0 0 6 448 864 0 0 72 /**</span>
 <span class="s0">* Returns the URL that represents the root of this mount point.</span>
 <span class="s0">*/ 1 4 this 3 920  </span>
<span class="s0">383 0 0 4 449 845 0 0 396 /**</span>
 <span class="s0">* Reads all of the vfs-mount-url lines in the Config.prc file and replaces</span>
 <span class="s0">* the mount settings to match them.</span>
 <span class="s0">*</span>
 <span class="s0">* This will mount any url's mentioned in the config file, and unmount and</span>
 <span class="s0">* unmount any url's no longer mentioned in the config file.  Normally, it is</span>
 <span class="s0">* called automatically at startup, and need not be called again, unless you</span>
 <span class="s0">* have fiddled with some config settings.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">384 0 0 7 450 898 0 0 0 0 </span>
<span class="s0">385 0 0 7 452 922 782 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">386 0 0 15 452 922 782 0 0 1 6 param0 0 923  </span>
<span class="s0">387 0 0 7 452 922 782 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 6 buffer 1 925  </span>
<span class="s0">388 0 0 6 454 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 922  5 patch 1 905  6 infile 1 905  </span>
<span class="s0">389 0 0 6 455 846 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 922  </span>
<span class="s0">390 0 0 6 456 827 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 923  </span>
<span class="s0">391 0 0 7 458 927 791 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">392 0 0 55 458 927 791 0 0 1 6 source 1 839  </span>
<span class="s0">393 0 0 4 459 845 0 0 30 /**</span>
 <span class="s0">* Empties the buffer.</span>
 <span class="s0">*/ 1 4 this 3 927  </span>
<span class="s0">394 0 0 6 460 869 0 0 86 /**</span>
 <span class="s0">* Returns the number of characters available to be read from the data stream.</span>
 <span class="s0">*/ 1 4 this 3 927  </span>
<span class="s0">395 0 0 38 461 839 0 0 63 /**</span>
 <span class="s0">* Returns the contents of the data stream as a string.</span>
 <span class="s0">*/ 1 4 this 3 927  </span>
<span class="s0">396 0 0 36 462 845 0 0 0 2 4 this 3 927  4 data 1 839  </span>
<span class="s0">397 0 0 6 418 928 0 0 0 1 4 name 1 905  </span>
<span class="s0">398 0 0 6 419 928 0 0 0 1 4 name 1 905  </span>
<span class="s0">137</span>
<span class="s0">792 8 SSReader 0 26625 8 SSReader 8 SSReader 0 0 0 0 399 0 5 400 401 402 403 404 0 0 0 0 0 219</span>
<span class="s0">/**</span>
 <span class="s0">* An internal class for reading from a socket stream.  This serves as a base</span>
 <span class="s0">* class for both ISocketStream and SocketStream; its purpose is to minimize</span>
 <span class="s0">* redundant code between them.  Do not use it directly.</span>
 <span class="s0">*/</span>

<span class="s0">793 8 SSWriter 0 26625 8 SSWriter 8 SSWriter 0 0 0 0 405 0 11 406 407 408 409 410 411 412 413 414 415 416 0 0 0 0 0 217</span>
<span class="s0">/**</span>
 <span class="s0">* An internal class for writing to a socket stream.  This serves as a base</span>
 <span class="s0">* class for both OSocketStream and SocketStream; its purpose is to minimize</span>
 <span class="s0">* redundant code between them.  Do not use it directly.</span>
 <span class="s0">*/</span>

<span class="s0">794 13 ISocketStream 0 26625 13 ISocketStream 13 ISocketStream 0 0 0 0 421 0 3 422 423 424 0 0 2 3 795 417 418 3 792 419 420 0 1 796 278</span>
<span class="s0">/**</span>
 <span class="s0">* This is a base class for istreams implemented in Panda that read from a</span>
 <span class="s0">* (possibly non-blocking) socket.  It adds is_closed(), which can be called</span>
 <span class="s0">* after an eof condition to check whether the socket has been closed, or</span>
 <span class="s0">* whether more data may be available later.</span>
 <span class="s0">*/</span>

<span class="s0">795 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">796 9 ReadState 0 794624 24 ISocketStream::ReadState 24 ISocketStream::ReadState 794 0 0 0 0 0 0 0 0 0 4 10 RS_initial 25 ISocketStream::RS_initial 0</span>
<span class="s0">0 10 RS_reading 25 ISocketStream::RS_reading 0</span>
<span class="s0">1 11 RS_complete 26 ISocketStream::RS_complete 0</span>
<span class="s0">2 8 RS_error 23 ISocketStream::RS_error 0</span>
<span class="s0">3 0 0</span>

<span class="s0">797 13 OSocketStream 0 141313 13 OSocketStream 13 OSocketStream 0 0 0 0 432 0 3 429 430 431 0 0 2 3 798 425 426 3 793 427 428 0 0 251</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for ostreams that write to a (possibly non-blocking) socket.</span>
 <span class="s0">* It adds is_closed(), which can be called after any write operation fails to</span>
 <span class="s0">* check whether the socket has been closed, or whether more data may be sent</span>
 <span class="s0">* later.</span>
 <span class="s0">*/</span>

<span class="s0">798 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">799 12 SocketStream 0 141313 12 SocketStream 12 SocketStream 0 0 0 0 444 0 5 439 440 441 442 443 0 0 3 3 800 433 434 3 792 435 436 3 793 437 438 0 0 97</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for iostreams that read and write to a (possibly non-blocking)</span>
 <span class="s0">* socket.</span>
 <span class="s0">*/</span>

<span class="s0">800 8 iostream 0 2048 13 std::iostream 13 std::iostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">801 7 URLSpec 0 141313 7 URLSpec 7 URLSpec 0 0 0 1 445 495 9 929 930 931 932 933 934 935 936 937 47 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 483 484 486 487 488 489 490 491 492 493 494 0 2 482 485 0 0 0 224</span>
<span class="s0">/**</span>
 <span class="s0">* A container for a URL, e.g.  &quot;http://server:port/path&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* The URLSpec object is similar to a Filename in that it contains logic to</span>
 <span class="s0">* identify the various parts of a URL and return (or modify) them separately.</span>
 <span class="s0">*/</span>

<span class="s0">802 6 string 0 2105344 11 std::string 11 std::string 0 0 803 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">803 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">804 8 uint16_t 0 2105344 8 uint16_t 8 uint16_t 0 0 805 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">805 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">806 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">807 8 HTTPEnum 0 141313 8 HTTPEnum 8 HTTPEnum 0 0 0 1 496 497 0 0 0 0 0 0 2 808 809 147</span>
<span class="s0">/**</span>
 <span class="s0">* This class is just used as a namespace wrapper for some of the enumerated</span>
 <span class="s0">* types used by various classes within the HTTPClient family.</span>
 <span class="s0">*/</span>

<span class="s0">808 11 HTTPVersion 0 794624 21 HTTPEnum::HTTPVersion 21 HTTPEnum::HTTPVersion 807 0 0 0 0 0 0 0 0 0 4 5 HV_09 15 HTTPEnum::HV_09 20</span>
<span class="s0">// HTTP 0.9 or older</span>
<span class="s0">0 5 HV_10 15 HTTPEnum::HV_10 11</span>
<span class="s0">// HTTP 1.0</span>
<span class="s0">1 5 HV_11 15 HTTPEnum::HV_11 11</span>
<span class="s0">// HTTP 1.1</span>
<span class="s0">2 8 HV_other 18 HTTPEnum::HV_other 0</span>
<span class="s0">3 0 0</span>

<span class="s0">809 6 Method 0 794624 16 HTTPEnum::Method 16 HTTPEnum::Method 807 0 0 0 0 0 0 0 0 0 8 9 M_options 19 HTTPEnum::M_options 0</span>
<span class="s0">0 5 M_get 15 HTTPEnum::M_get 0</span>
<span class="s0">1 6 M_head 16 HTTPEnum::M_head 0</span>
<span class="s0">2 6 M_post 16 HTTPEnum::M_post 0</span>
<span class="s0">3 5 M_put 15 HTTPEnum::M_put 0</span>
<span class="s0">4 8 M_delete 18 HTTPEnum::M_delete 0</span>
<span class="s0">5 7 M_trace 17 HTTPEnum::M_trace 0</span>
<span class="s0">6 9 M_connect 19 HTTPEnum::M_connect 0</span>
<span class="s0">7 0 0</span>

<span class="s0">810 8 HTTPDate 0 141313 8 HTTPDate 8 HTTPDate 0 0 0 1 498 515 0 16 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 0 0 0 0 0 238</span>
<span class="s0">/**</span>
 <span class="s0">* A container for an HTTP-legal time/date indication.  This can accept a</span>
 <span class="s0">* string from an HTTP header and will decode it into a C time_t value;</span>
 <span class="s0">* conversely, it can accept a time_t value and encode it for output as a</span>
 <span class="s0">* string.</span>
 <span class="s0">*/</span>

<span class="s0">811 10 HTTPCookie 0 26625 10 HTTPCookie 10 HTTPCookie 0 0 0 1 516 517 6 938 939 940 941 942 943 20 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 0 0 0 0 0 124</span>
<span class="s0">/**</span>
 <span class="s0">* A cookie sent from an HTTP server to be stored on the client and returned</span>
 <span class="s0">* when the path and/or domain matches.</span>
 <span class="s0">*/</span>

<span class="s0">812 12 string const 0 8832 17 std::string const 17 std::string const 0 0 802 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">813 10 HTTPClient 0 75777 10 HTTPClient 10 HTTPClient 0 0 0 1 538 0 0 48 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 0 0 1 0 814 0 0 0 1 815 552</span>
<span class="s0">/**</span>
 <span class="s0">* Handles contacting an HTTP server and retrieving a document.  Each</span>
 <span class="s0">* HTTPClient object represents a separate context, and stores its own list of</span>
 <span class="s0">* cookies, passwords, and certificates; however, a given HTTPClient is</span>
 <span class="s0">* capable of making multiple simultaneous requests to the same or different</span>
 <span class="s0">* servers.</span>
 <span class="s0">*</span>
 <span class="s0">* It is up to the programmer whether one HTTPClient should be used to</span>
 <span class="s0">* retrieve all documents, or a separate one should be created each time.</span>
 <span class="s0">* There is a default, global HTTPClient available in</span>
 <span class="s0">* HTTPClient::get_global_ptr().</span>
 <span class="s0">*/</span>

<span class="s0">814 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">815 9 VerifySSL 0 794624 21 HTTPClient::VerifySSL 21 HTTPClient::VerifySSL 813 0 0 0 0 0 0 0 0 0 3 12 VS_no_verify 24 HTTPClient::VS_no_verify 28</span>
<span class="s0">// Don't care who we talk to</span>
<span class="s0">0 16 VS_no_date_check 28 HTTPClient::VS_no_date_check 53</span>
<span class="s0">// Must identify certs, but old, expired certs are OK</span>
<span class="s0">1 9 VS_normal 21 HTTPClient::VS_normal 50</span>
<span class="s0">// Identify certs and also check expiration dates.</span>
<span class="s0">2 0 0</span>

<span class="s0">816 13 HTTPEntityTag 0 141313 13 HTTPEntityTag 13 HTTPEntityTag 0 0 0 1 587 599 0 11 588 589 590 591 592 593 594 595 596 597 598 0 0 0 0 0 185</span>
<span class="s0">/**</span>
 <span class="s0">* A container for an &quot;entity tag&quot; from an HTTP server.  This is used to</span>
 <span class="s0">* identify a particular version of a document or resource, particularly</span>
 <span class="s0">* useful for verifying caches.</span>
 <span class="s0">*/</span>

<span class="s0">817 12 DocumentSpec 0 141313 12 DocumentSpec 12 DocumentSpec 0 0 0 1 600 623 5 944 945 946 947 948 22 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 0 0 0 0 2 818 819 315</span>
<span class="s0">/**</span>
 <span class="s0">* A descriptor that refers to a particular version of a document.  This</span>
 <span class="s0">* includes the URL of the document and its identity tag and last-modified</span>
 <span class="s0">* dates.</span>
 <span class="s0">*</span>
 <span class="s0">* The DocumentSpec may also be used to request a newer document than a</span>
 <span class="s0">* particular one if available, for instance to refresh a cached document.</span>
 <span class="s0">*/</span>

<span class="s0">818 11 RequestMode 0 794624 25 DocumentSpec::RequestMode 25 DocumentSpec::RequestMode 817 0 0 0 0 0 0 0 0 0 4 6 RM_any 20 DocumentSpec::RM_any 0</span>
<span class="s0">0 8 RM_equal 22 DocumentSpec::RM_equal 0</span>
<span class="s0">1 8 RM_newer 22 DocumentSpec::RM_newer 0</span>
<span class="s0">2 17 RM_equal_or_newer 31 DocumentSpec::RM_equal_or_newer 0</span>
<span class="s0">3 0 0</span>

<span class="s0">819 12 CacheControl 0 794624 26 DocumentSpec::CacheControl 26 DocumentSpec::CacheControl 817 0 0 0 0 0 0 0 0 0 3 14 CC_allow_cache 28 DocumentSpec::CC_allow_cache 0</span>
<span class="s0">0 13 CC_revalidate 27 DocumentSpec::CC_revalidate 0</span>
<span class="s0">1 11 CC_no_cache 25 DocumentSpec::CC_no_cache 0</span>
<span class="s0">2 0 0</span>

<span class="s0">820 13 URLSpec const 0 8832 13 URLSpec const 13 URLSpec const 0 0 801 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">821 19 HTTPEntityTag const 0 8832 19 HTTPEntityTag const 19 HTTPEntityTag const 0 0 816 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">822 14 HTTPDate const 0 8832 14 HTTPDate const 14 HTTPDate const 0 0 810 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">823 11 HTTPChannel 0 75777 11 HTTPChannel 11 HTTPChannel 0 0 0 1 701 0 0 77 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 1 952 0 1 0 824 0 0 0 1 825 554</span>
<span class="s0">/**</span>
 <span class="s0">* A single channel of communication from an HTTPClient.  This is similar to</span>
 <span class="s0">* the concept of a 'connection', except that HTTP is technically</span>
 <span class="s0">* connectionless; in fact, a channel may represent one unbroken connection or</span>
 <span class="s0">* it may transparently close and reopen a new connection with each request.</span>
 <span class="s0">*</span>
 <span class="s0">* A channel is conceptually a single thread of I/O. One document at a time</span>
 <span class="s0">* may be requested using a channel; a new document may (in general) not be</span>
 <span class="s0">* requested from the same HTTPChannel until the first document has been fully</span>
 <span class="s0">* retrieved.</span>
 <span class="s0">*/</span>

<span class="s0">824 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">825 10 StatusCode 0 794624 23 HTTPChannel::StatusCode 23 HTTPChannel::StatusCode 823 0 0 0 0 0 0 0 0 0 20 13 SC_incomplete 26 HTTPChannel::SC_incomplete 0</span>
<span class="s0">0 17 SC_internal_error 30 HTTPChannel::SC_internal_error 0</span>
<span class="s0">1 16 SC_no_connection 29 HTTPChannel::SC_no_connection 0</span>
<span class="s0">2 10 SC_timeout 23 HTTPChannel::SC_timeout 0</span>
<span class="s0">3 18 SC_lost_connection 31 HTTPChannel::SC_lost_connection 0</span>
<span class="s0">4 20 SC_non_http_response 33 HTTPChannel::SC_non_http_response 0</span>
<span class="s0">5 15 SC_invalid_http 28 HTTPChannel::SC_invalid_http 0</span>
<span class="s0">6 24 SC_socks_invalid_version 37 HTTPChannel::SC_socks_invalid_version 0</span>
<span class="s0">7 35 SC_socks_no_acceptable_login_method 48 HTTPChannel::SC_socks_no_acceptable_login_method 0</span>
<span class="s0">8 16 SC_socks_refused 29 HTTPChannel::SC_socks_refused 0</span>
<span class="s0">9 22 SC_socks_no_connection 35 HTTPChannel::SC_socks_no_connection 0</span>
<span class="s0">10 23 SC_ssl_internal_failure 36 HTTPChannel::SC_ssl_internal_failure 0</span>
<span class="s0">11 19 SC_ssl_no_handshake 32 HTTPChannel::SC_ssl_no_handshake 0</span>
<span class="s0">12 23 SC_http_error_watermark 36 HTTPChannel::SC_http_error_watermark 129</span>
<span class="s0">// No one returns this code, but StatusCode values higher than this are</span>
<span class="s0">// deemed more successful than any generic HTTP response.</span>
<span class="s0">13 33 SC_ssl_invalid_server_certificate 46 HTTPChannel::SC_ssl_invalid_server_certificate 0</span>
<span class="s0">14 37 SC_ssl_self_signed_server_certificate 50 HTTPChannel::SC_ssl_self_signed_server_certificate 0</span>
<span class="s0">15 24 SC_ssl_unexpected_server 37 HTTPChannel::SC_ssl_unexpected_server 0</span>
<span class="s0">16 22 SC_download_open_error 35 HTTPChannel::SC_download_open_error 79</span>
<span class="s0">// These errors are only generated after a download_to_*() call been</span>
<span class="s0">// issued.</span>
<span class="s0">17 23 SC_download_write_error 36 HTTPChannel::SC_download_write_error 0</span>
<span class="s0">18 25 SC_download_invalid_range 38 HTTPChannel::SC_download_invalid_range 0</span>
<span class="s0">19 0 195</span>
<span class="s0">// get_status_code() will either return an HTTP-style status code &gt;= 100</span>
<span class="s0">// (e.g.  404), or one of the following values.  In general, these are</span>
<span class="s0">// ordered from less-successful to more-successful.</span>

<span class="s0">826 12 Decompressor 0 26625 12 Decompressor 12 Decompressor 0 0 0 1 702 703 1 949 4 704 705 706 707 0 0 0 0 0 114</span>
<span class="s0">/**</span>
 <span class="s0">* This manages run-time decompression of a zlib-compressed stream, as a</span>
 <span class="s0">* background or foreground task.</span>
 <span class="s0">*/</span>

<span class="s0">827 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 828 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">828 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">829 10 DownloadDb 0 26625 10 DownloadDb 10 DownloadDb 0 0 0 1 708 709 0 45 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 0 0 0 0 1 830 332</span>
<span class="s0">/**</span>
 <span class="s0">* A listing of files within multifiles for management of client-side</span>
 <span class="s0">* synchronization with a server-provided set of files.</span>
 <span class="s0">*</span>
 <span class="s0">* This class manages one copy of the database for the client, representing</span>
 <span class="s0">* the files on the client system, and another copy for the server,</span>
 <span class="s0">* representing the files the server has available.</span>
 <span class="s0">*/</span>

<span class="s0">830 6 Status 0 794624 18 DownloadDb::Status 18 DownloadDb::Status 829 0 0 0 0 0 0 0 0 0 4 17 Status_incomplete 29 DownloadDb::Status_incomplete 0</span>
<span class="s0">0 15 Status_complete 27 DownloadDb::Status_complete 0</span>
<span class="s0">1 19 Status_decompressed 31 DownloadDb::Status_decompressed 0</span>
<span class="s0">2 16 Status_extracted 28 DownloadDb::Status_extracted 0</span>
<span class="s0">3 0 210</span>
<span class="s0">// Status of a multifile is stored in this enum Note these values are in</span>
<span class="s0">// increasing order of &quot;doneness&quot; So if you are decompressed, you are</span>
<span class="s0">// complete If you are extracted, you are decompressed and complete</span>

<span class="s0">831 9 Extractor 0 26625 9 Extractor 9 Extractor 0 0 0 1 757 758 1 950 8 759 760 761 762 763 764 765 766 0 0 0 0 0 543</span>
<span class="s0">/**</span>
 <span class="s0">* This class automatically extracts the contents of a Multifile to the</span>
 <span class="s0">* current directory (or to a specified directory) in the background.</span>
 <span class="s0">*</span>
 <span class="s0">* It is designed to limit its use of system resources and run unobtrusively</span>
 <span class="s0">* in the background.  After specifying the files you wish to extract via</span>
 <span class="s0">* repeated calls to request_subfile(), begin the process by calling run()</span>
 <span class="s0">* repeatedly.  Each call to run() extracts another small portion of the</span>
 <span class="s0">* Multifile.  Call run() whenever you have spare cycles until run() returns</span>
 <span class="s0">* EU_success.</span>
 <span class="s0">*/</span>

<span class="s0">832 15 MultiplexStream 0 141313 15 MultiplexStream 15 MultiplexStream 0 0 0 1 767 774 0 6 768 769 770 771 772 773 0 0 1 0 798 0 0 0 0 291</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special ostream that forwards the data that is written to it to</span>
 <span class="s0">* any number of other sources, for instance other ostreams, or explicitly to</span>
 <span class="s0">* a disk file or to system logging utilities.  It's a very handy thing to set</span>
 <span class="s0">* Notify to refer to when running in batch mode.</span>
 <span class="s0">*/</span>

<span class="s0">833 15 VirtualFileHTTP 0 75777 15 VirtualFileHTTP 15 VirtualFileHTTP 0 0 0 0 0 0 1 775 0 0 1 0 834 0 0 0 0 155</span>
<span class="s0">/**</span>
 <span class="s0">* This maps a document retrieved from an HTTPClient into the</span>
 <span class="s0">* VirtualFileSystem, allowing models etc.  to be loaded directly from a web</span>
 <span class="s0">* page.</span>
 <span class="s0">*/</span>

<span class="s0">834 11 VirtualFile 0 2048 11 VirtualFile 11 VirtualFile 0 0 0 0 0 0 0 0 0 0 0 0 91</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract base class for a file or directory within the</span>
 <span class="s0">* VirtualFileSystem.</span>
 <span class="s0">*/</span>

<span class="s0">835 20 VirtualFileMountHTTP 0 75777 20 VirtualFileMountHTTP 20 VirtualFileMountHTTP 0 0 0 1 776 0 0 4 777 778 779 780 0 0 1 0 836 0 0 0 0 65</span>
<span class="s0">/**</span>
 <span class="s0">* Maps a web page (URL root) into the VirtualFileSystem.</span>
 <span class="s0">*/</span>

<span class="s0">836 16 VirtualFileMount 0 2048 16 VirtualFileMount 16 VirtualFileMount 0 0 0 0 0 0 0 0 0 0 0 0 159</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract base class for a mount definition used within a</span>
 <span class="s0">* VirtualFileSystem.  Normally users don't need to monkey with this class</span>
 <span class="s0">* directly.</span>
 <span class="s0">*/</span>

<span class="s0">837 7 Patcher 0 26625 7 Patcher 7 Patcher 0 0 0 1 781 782 0 3 783 784 785 0 0 0 0 0 40</span>
<span class="s0">/**</span>
 <span class="s0">* Applies a patch synchronously</span>
 <span class="s0">*/</span>

<span class="s0">838 12 StringStream 0 141313 12 StringStream 12 StringStream 0 0 0 1 786 791 1 951 4 787 788 789 790 0 0 1 0 800 0 0 0 0 186</span>
<span class="s0">/**</span>
 <span class="s0">* A bi-directional stream object that reads and writes data to an internal</span>
 <span class="s0">* buffer, which can be retrieved and/or set as a string in Python 2 or a</span>
 <span class="s0">* bytes object in Python 3.</span>
 <span class="s0">*/</span>

<span class="s0">839 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 840 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">840 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 841 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">841 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">842 10 SSReader * 0 8576 10 SSReader * 10 SSReader * 0 0 792 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">843 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 844 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">844 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">845 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">846 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">847 16 SSReader const * 0 8576 16 SSReader const * 16 SSReader const * 0 0 848 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">848 14 SSReader const 0 8832 14 SSReader const 14 SSReader const 0 0 792 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">849 10 SSWriter * 0 8576 10 SSWriter * 10 SSWriter * 0 0 793 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">850 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 851 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">851 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 844 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">852 16 SSWriter const * 0 8576 16 SSWriter const * 16 SSWriter const * 0 0 853 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">853 14 SSWriter const 0 8832 14 SSWriter const 14 SSWriter const 0 0 793 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">854 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">855 15 ISocketStream * 0 8576 15 ISocketStream * 15 ISocketStream * 0 0 794 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">856 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 795 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">857 15 OSocketStream * 0 8576 15 OSocketStream * 15 OSocketStream * 0 0 797 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">858 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 798 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">859 14 SocketStream * 0 8576 14 SocketStream * 14 SocketStream * 0 0 799 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">860 20 SocketStream const * 0 8576 20 SocketStream const * 20 SocketStream const * 0 0 861 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">861 18 SocketStream const 0 8832 18 SocketStream const 18 SocketStream const 0 0 799 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">862 10 iostream * 0 8576 15 std::iostream * 15 std::iostream * 0 0 800 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">863 9 URLSpec * 0 8576 9 URLSpec * 9 URLSpec * 0 0 801 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">864 15 URLSpec const * 0 8576 15 URLSpec const * 15 URLSpec const * 0 0 820 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">865 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 866 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">866 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 867 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">867 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">868 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">869 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 870 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">870 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">871 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">872 10 HTTPEnum * 0 8576 10 HTTPEnum * 10 HTTPEnum * 0 0 807 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">873 16 HTTPEnum const * 0 8576 16 HTTPEnum const * 16 HTTPEnum const * 0 0 874 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">874 14 HTTPEnum const 0 8832 14 HTTPEnum const 14 HTTPEnum const 0 0 807 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">875 10 HTTPDate * 0 8576 10 HTTPDate * 10 HTTPDate * 0 0 810 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">876 16 HTTPDate const * 0 8576 16 HTTPDate const * 16 HTTPDate const * 0 0 822 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">877 6 time_t 0 2105344 6 time_t 6 time_t 0 0 878 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">878 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">879 12 HTTPCookie * 0 8576 12 HTTPCookie * 12 HTTPCookie * 0 0 811 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">880 18 HTTPCookie const * 0 8576 18 HTTPCookie const * 18 HTTPCookie const * 0 0 881 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">881 16 HTTPCookie const 0 8832 16 HTTPCookie const 16 HTTPCookie const 0 0 811 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">882 12 HTTPClient * 0 8576 12 HTTPClient * 12 HTTPClient * 0 0 813 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">883 18 HTTPClient const * 0 8576 18 HTTPClient const * 18 HTTPClient const * 0 0 884 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">884 16 HTTPClient const 0 8832 16 HTTPClient const 16 HTTPClient const 0 0 813 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">885 13 HTTPChannel * 0 8576 13 HTTPChannel * 13 HTTPChannel * 0 0 823 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">886 15 HTTPEntityTag * 0 8576 15 HTTPEntityTag * 15 HTTPEntityTag * 0 0 816 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">887 21 HTTPEntityTag const * 0 8576 21 HTTPEntityTag const * 21 HTTPEntityTag const * 0 0 821 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">888 14 DocumentSpec * 0 8576 14 DocumentSpec * 14 DocumentSpec * 0 0 817 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">889 20 DocumentSpec const * 0 8576 20 DocumentSpec const * 20 DocumentSpec const * 0 0 890 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">890 18 DocumentSpec const 0 8832 18 DocumentSpec const 18 DocumentSpec const 0 0 817 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">891 19 HTTPChannel const * 0 8576 19 HTTPChannel const * 19 HTTPChannel const * 0 0 892 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">892 17 HTTPChannel const 0 8832 17 HTTPChannel const 17 HTTPChannel const 0 0 823 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">893 10 streamsize 0 2105344 15 std::streamsize 15 std::streamsize 0 0 894 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">894 13 long long int 0 8226 13 long long int 13 long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">895 9 Ramfile * 0 8576 9 Ramfile * 9 Ramfile * 0 0 896 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">896 7 Ramfile 0 2048 7 Ramfile 7 Ramfile 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">897 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">898 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 897 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">899 14 Decompressor * 0 8576 14 Decompressor * 14 Decompressor * 0 0 826 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">900 20 Decompressor const * 0 8576 20 Decompressor const * 20 Decompressor const * 0 0 901 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">901 18 Decompressor const 0 8832 18 Decompressor const 18 Decompressor const 0 0 826 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">902 12 DownloadDb * 0 8576 12 DownloadDb * 12 DownloadDb * 0 0 829 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">903 18 DownloadDb const * 0 8576 18 DownloadDb const * 18 DownloadDb const * 0 0 904 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">904 16 DownloadDb const 0 8832 16 DownloadDb const 16 DownloadDb const 0 0 829 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">905 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 867 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">906 5 Phase 0 2105344 5 Phase 5 Phase 0 0 827 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">907 7 HashVal 0 2048 7 HashVal 7 HashVal 0 0 0 0 0 0 0 0 0 0 0 0 109</span>
<span class="s0">/**</span>
 <span class="s0">* Stores a 128-bit value that represents the hashed contents (typically MD5)</span>
 <span class="s0">* of a file or buffer.</span>
 <span class="s0">*/</span>

<span class="s0">908 9 HashVal * 0 8576 9 HashVal * 9 HashVal * 0 0 907 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">909 2 Db 0 1312768 14 DownloadDb::Db 14 DownloadDb::Db 829 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">910 4 Db * 0 8576 16 DownloadDb::Db * 16 DownloadDb::Db * 0 0 909 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">911 15 HashVal const * 0 8576 15 HashVal const * 15 HashVal const * 0 0 912 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">912 13 HashVal const 0 8832 13 HashVal const 13 HashVal const 0 0 907 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">913 11 Extractor * 0 8576 11 Extractor * 11 Extractor * 0 0 831 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">914 17 Extractor const * 0 8576 17 Extractor const * 17 Extractor const * 0 0 915 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">915 15 Extractor const 0 8832 15 Extractor const 15 Extractor const 0 0 831 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">916 17 MultiplexStream * 0 8576 17 MultiplexStream * 17 MultiplexStream * 0 0 832 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">917 6 FILE * 0 8576 6 FILE * 6 FILE * 0 0 918 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">918 4 FILE 0 1024 4 FILE 4 FILE 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">919 22 VirtualFileMountHTTP * 0 8576 22 VirtualFileMountHTTP * 22 VirtualFileMountHTTP * 0 0 835 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">920 28 VirtualFileMountHTTP const * 0 8576 28 VirtualFileMountHTTP const * 28 VirtualFileMountHTTP const * 0 0 921 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">921 26 VirtualFileMountHTTP const 0 8832 26 VirtualFileMountHTTP const 26 VirtualFileMountHTTP const 0 0 835 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">922 9 Patcher * 0 8576 9 Patcher * 9 Patcher * 0 0 837 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">923 15 Patcher const * 0 8576 15 Patcher const * 15 Patcher const * 0 0 924 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">924 13 Patcher const 0 8832 13 Patcher const 13 Patcher const 0 0 837 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">925 8 Buffer * 0 8576 8 Buffer * 8 Buffer * 0 0 926 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">926 6 Buffer 0 2048 6 Buffer 6 Buffer 0 0 0 0 0 0 0 0 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">927 14 StringStream * 0 8576 14 StringStream * 14 StringStream * 0 0 838 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">928 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">23</span>
<span class="s0">929 6 scheme 0 6 802 459 473 0 0 0 0 0 0 15 URLSpec::scheme 0</span>

<span class="s0">930 9 authority 0 6 802 460 474 0 0 0 0 0 0 18 URLSpec::authority 0</span>

<span class="s0">931 8 username 0 6 802 461 475 0 0 0 0 0 0 17 URLSpec::username 0</span>

<span class="s0">932 6 server 0 6 802 462 476 0 0 0 0 0 0 15 URLSpec::server 0</span>

<span class="s0">933 4 port 0 6 804 464 477 0 0 0 0 0 0 13 URLSpec::port 0</span>

<span class="s0">934 15 server_and_port 0 6 802 465 478 0 0 0 0 0 0 24 URLSpec::server_and_port 0</span>

<span class="s0">935 4 path 0 6 802 468 479 0 0 0 0 0 0 13 URLSpec::path 0</span>

<span class="s0">936 5 query 0 6 802 469 480 0 0 0 0 0 0 14 URLSpec::query 0</span>

<span class="s0">937 3 ssl 0 2 806 471 0 0 0 0 0 0 0 12 URLSpec::ssl 0</span>

<span class="s0">938 4 name 0 6 812 519 518 0 0 0 0 0 0 16 HTTPCookie::name 0</span>

<span class="s0">939 5 value 0 6 812 521 520 0 0 0 0 0 0 17 HTTPCookie::value 0</span>

<span class="s0">940 6 domain 0 6 812 523 522 0 0 0 0 0 0 18 HTTPCookie::domain 0</span>

<span class="s0">941 4 path 0 6 812 525 524 0 0 0 0 0 0 16 HTTPCookie::path 0</span>

<span class="s0">942 7 expires 0 30 810 529 526 528 527 0 0 0 0 19 HTTPCookie::expires 0</span>

<span class="s0">943 6 secure 0 6 806 531 530 0 0 0 0 0 0 18 HTTPCookie::secure 0</span>

<span class="s0">944 3 url 0 6 820 607 606 0 0 0 0 0 0 17 DocumentSpec::url 0</span>

<span class="s0">945 3 tag 0 30 821 610 608 609 611 0 0 0 0 17 DocumentSpec::tag 0</span>

<span class="s0">946 4 date 0 30 822 614 612 613 615 0 0 0 0 18 DocumentSpec::date 0</span>

<span class="s0">947 12 request_mode 0 6 818 617 616 0 0 0 0 0 0 26 DocumentSpec::request_mode 0</span>

<span class="s0">948 13 cache_control 0 6 819 619 618 0 0 0 0 0 0 27 DocumentSpec::cache_control 0</span>

<span class="s0">949 8 progress 0 2 827 707 0 0 0 0 0 0 0 22 Decompressor::progress 0</span>

<span class="s0">950 8 progress 0 2 827 765 0 0 0 0 0 0 0 19 Extractor::progress 0</span>

<span class="s0">951 4 data 0 6 839 789 790 0 0 0 0 0 0 18 StringStream::data 0</span>

<span class="s0">1</span>
<span class="s0">952 18 get_redirect_steps 0 637 638 31 HTTPChannel::get_redirect_steps 0</span>

</pre>
</body>
</html>