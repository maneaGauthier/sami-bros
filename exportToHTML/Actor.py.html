<html>
<head>
<title>Actor.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Actor.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Actor module: contains the Actor class. 
 
See the :ref:`loading-actors-and-animations` page in the Programming Guide 
to learn more about loading animated models. 
&quot;&quot;&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'Actor'</span><span class="s2">]</span>

<span class="s4">from </span><span class="s1">panda3d</span><span class="s2">.</span><span class="s1">core </span><span class="s4">import </span><span class="s2">*</span>
<span class="s4">from </span><span class="s1">panda3d</span><span class="s2">.</span><span class="s1">core </span><span class="s4">import </span><span class="s1">Loader </span><span class="s4">as </span><span class="s1">PandaLoader</span>
<span class="s4">from </span><span class="s1">direct</span><span class="s2">.</span><span class="s1">showbase</span><span class="s2">.</span><span class="s1">DirectObject </span><span class="s4">import </span><span class="s1">DirectObject</span>
<span class="s4">from </span><span class="s1">direct</span><span class="s2">.</span><span class="s1">showbase</span><span class="s2">.</span><span class="s1">Loader </span><span class="s4">import </span><span class="s1">Loader</span>
<span class="s4">from </span><span class="s1">direct</span><span class="s2">.</span><span class="s1">directnotify </span><span class="s4">import </span><span class="s1">DirectNotifyGlobal</span>


<span class="s4">class </span><span class="s1">Actor</span><span class="s2">(</span><span class="s1">DirectObject</span><span class="s2">, </span><span class="s1">NodePath</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Actor class: Contains methods for creating, manipulating 
    and playing animations on characters 
    &quot;&quot;&quot;</span>
    <span class="s1">notify </span><span class="s2">= </span><span class="s1">DirectNotifyGlobal</span><span class="s2">.</span><span class="s1">directNotify</span><span class="s2">.</span><span class="s1">newCategory</span><span class="s2">(</span><span class="s3">&quot;Actor&quot;</span><span class="s2">)</span>
    <span class="s1">partPrefix </span><span class="s2">= </span><span class="s3">&quot;__Actor_&quot;</span>

    <span class="s1">modelLoaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFSearch </span><span class="s2">|</span>
                                       <span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFReportErrors </span><span class="s2">|</span>
                                       <span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFConvertSkeleton</span><span class="s2">)</span>
    <span class="s1">animLoaderOptions </span><span class="s2">=  </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFSearch </span><span class="s2">|</span>
                                       <span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFReportErrors </span><span class="s2">|</span>
                                       <span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFConvertAnim</span><span class="s2">)</span>

    <span class="s1">validateSubparts </span><span class="s2">= </span><span class="s1">ConfigVariableBool</span><span class="s2">(</span><span class="s3">'validate-subparts'</span><span class="s2">, </span><span class="s4">True</span><span class="s2">)</span>
    <span class="s1">mergeLODBundles </span><span class="s2">= </span><span class="s1">ConfigVariableBool</span><span class="s2">(</span><span class="s3">'merge-lod-bundles'</span><span class="s2">, </span><span class="s4">True</span><span class="s2">)</span>
    <span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s1">ConfigVariableBool</span><span class="s2">(</span><span class="s3">'allow-async-bind'</span><span class="s2">, </span><span class="s4">True</span><span class="s2">)</span>

    <span class="s4">class </span><span class="s1">PartDef</span><span class="s2">:</span>

        <span class="s0">&quot;&quot;&quot;Instances of this class are stored within the 
        PartBundleDict to track all of the individual PartBundles 
        associated with the Actor.  In general, each separately loaded 
        model file is a different PartBundle.  This can include the 
        multiple different LOD's, as well as the multiple different 
        pieces of a multipart Actor. &quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partBundleNP</span><span class="s2">, </span><span class="s1">partBundleHandle</span><span class="s2">, </span><span class="s1">partModel</span><span class="s2">):</span>
            <span class="s5"># We also save the ModelRoot node along with the</span>
            <span class="s5"># PartBundle, so that the reference count in the ModelPool</span>
            <span class="s5"># will be accurate.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">partBundleNP </span><span class="s2">= </span><span class="s1">partBundleNP</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">partBundleHandle </span><span class="s2">= </span><span class="s1">partBundleHandle</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">partModel </span><span class="s2">= </span><span class="s1">partModel</span>

        <span class="s4">def </span><span class="s1">getBundle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">partBundleHandle</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">()</span>

        <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s3">'Actor.PartDef(%s, %s)' </span><span class="s2">% (</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">), </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">partModel</span><span class="s2">))</span>


        <span class="s5">#snake_case alias:</span>
        <span class="s1">get_bundle </span><span class="s2">= </span><span class="s1">getBundle</span>

    <span class="s4">class </span><span class="s1">AnimDef</span><span class="s2">:</span>

        <span class="s0">&quot;&quot;&quot;Instances of this class are stored within the 
        AnimControlDict to track all of the animations associated with 
        the Actor.  This includes animations that have already been 
        bound (these have a valid AnimControl) as well as those that 
        have not yet been bound (for these, self.animControl is None). 
 
        There is a different AnimDef for each different part or 
        sub-part, times each different animation in the AnimDict. &quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filename </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">animBundle </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">filename </span><span class="s2">= </span><span class="s1">filename</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">animBundle </span><span class="s2">= </span><span class="s1">animBundle</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">animControl </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">def </span><span class="s1">makeCopy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">AnimDef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">filename</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">animBundle</span><span class="s2">)</span>

        <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s3">'Actor.AnimDef(%s)' </span><span class="s2">% (</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">filename</span><span class="s2">))</span>


        <span class="s5">#snake_case alias:</span>
        <span class="s1">make_copy </span><span class="s2">= </span><span class="s1">makeCopy</span>

    <span class="s4">class </span><span class="s1">SubpartDef</span><span class="s2">:</span>

        <span class="s0">&quot;&quot;&quot;Instances of this class are stored within the SubpartDict 
        to track the existance of arbitrary sub-parts.  These are 
        designed to appear to the user to be identical to true &quot;part&quot; 
        of a multi-part Actor, but in fact each subpart represents a 
        subset of the joints of an existing part (which is accessible 
        via a different name). &quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">truePartName</span><span class="s2">, </span><span class="s1">subset </span><span class="s2">= </span><span class="s1">PartSubset</span><span class="s2">()):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">truePartName </span><span class="s2">= </span><span class="s1">truePartName</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">subset </span><span class="s2">= </span><span class="s1">subset</span>

        <span class="s4">def </span><span class="s1">makeCopy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">, </span><span class="s1">PartSubset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">subset</span><span class="s2">))</span>


        <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s3">'Actor.SubpartDef(%s, %s)' </span><span class="s2">% (</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">), </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">subset</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">models</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">anims</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">other</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">,</span>
                 <span class="s1">lodNode </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">flattenable </span><span class="s2">= </span><span class="s4">True</span><span class="s2">, </span><span class="s1">setFinal </span><span class="s2">= </span><span class="s4">False</span><span class="s2">,</span>
                 <span class="s1">mergeLODBundles </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">okMissing </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Actor constructor: can be used to create single or multipart 
        actors. If another Actor is supplied as an argument this 
        method acts like a copy constructor. Single part actors are 
        created by calling with a model and animation dictionary 
        ``(animName:animPath{})`` as follows:: 
 
           a = Actor(&quot;panda-3k.egg&quot;, {&quot;walk&quot;:&quot;panda-walk.egg&quot;, 
                                      &quot;run&quot;:&quot;panda-run.egg&quot;}) 
 
        This could be displayed and animated as such:: 
 
           a.reparentTo(render) 
           a.loop(&quot;walk&quot;) 
           a.stop() 
 
        Multipart actors expect a dictionary of parts and a dictionary 
        of animation dictionaries ``(partName:(animName:animPath{}){})`` 
        as below:: 
 
            a = Actor( 
 
                # part dictionary 
                {&quot;head&quot;: &quot;char/dogMM/dogMM_Shorts-head-mod&quot;, 
                 &quot;torso&quot;: &quot;char/dogMM/dogMM_Shorts-torso-mod&quot;, 
                 &quot;legs&quot;: &quot;char/dogMM/dogMM_Shorts-legs-mod&quot;}, 
 
                # dictionary of anim dictionaries 
                {&quot;head&quot;:{&quot;walk&quot;: &quot;char/dogMM/dogMM_Shorts-head-walk&quot;, 
                         &quot;run&quot;: &quot;char/dogMM/dogMM_Shorts-head-run&quot;}, 
                 &quot;torso&quot;:{&quot;walk&quot;: &quot;char/dogMM/dogMM_Shorts-torso-walk&quot;, 
                          &quot;run&quot;: &quot;char/dogMM/dogMM_Shorts-torso-run&quot;}, 
                 &quot;legs&quot;:{&quot;walk&quot;: &quot;char/dogMM/dogMM_Shorts-legs-walk&quot;, 
                         &quot;run&quot;: &quot;char/dogMM/dogMM_Shorts-legs-run&quot;} 
                 }) 
 
        In addition multipart actor parts need to be connected together 
        in a meaningful fashion:: 
 
            a.attach(&quot;head&quot;, &quot;torso&quot;, &quot;joint-head&quot;) 
            a.attach(&quot;torso&quot;, &quot;legs&quot;, &quot;joint-hips&quot;) 
 
        # 
        # ADD LOD COMMENT HERE! 
        # 
 
        Other useful Actor class functions:: 
 
            #fix actor eye rendering 
            a.drawInFront(&quot;joint-pupil?&quot;, &quot;eyes*&quot;) 
 
            #fix bounding volumes - this must be done after drawing 
            #the actor for a few frames, otherwise it has no effect 
            a.fixBounds() 
        &quot;&quot;&quot;</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">Actor_initialized</span>
            <span class="s4">return</span>
        <span class="s4">except</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">Actor_initialized </span><span class="s2">= </span><span class="s6">1</span>

        <span class="s5"># initialize our NodePath essence</span>
        <span class="s1">NodePath</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">loader </span><span class="s2">= </span><span class="s1">PandaLoader</span><span class="s2">.</span><span class="s1">getGlobalPtr</span><span class="s2">()</span>

        <span class="s5"># Set the mergeLODBundles flag.  If this is true, all</span>
        <span class="s5"># different LOD's will be merged into a single common bundle</span>
        <span class="s5"># (joint hierarchy).  All LOD's will thereafter share the same</span>
        <span class="s5"># skeleton, even though they may have been loaded from</span>
        <span class="s5"># different egg files.  If this is false, LOD's will be kept</span>
        <span class="s5"># completely isolated, and each LOD will have its own</span>
        <span class="s5"># skeleton.</span>

        <span class="s5"># When this flag is true, __animControlDict has only one key,</span>
        <span class="s5"># ['common']; when it is false, __animControlDict has one key</span>
        <span class="s5"># per each LOD name.</span>

        <span class="s4">if </span><span class="s1">mergeLODBundles </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s5"># If this isn't specified, it comes from the Config.prc</span>
            <span class="s5"># file.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles </span><span class="s2">= </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">.</span><span class="s1">getValue</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles </span><span class="s2">= </span><span class="s1">mergeLODBundles</span>

        <span class="s5"># Set the allowAsyncBind flag.  If this is true, it enables</span>
        <span class="s5"># asynchronous animation binding.  This requires that you have</span>
        <span class="s5"># run &quot;egg-optchar -preload&quot; on your animation and models to</span>
        <span class="s5"># generate the appropriate AnimPreloadTable.</span>
        <span class="s4">if </span><span class="s1">allowAsyncBind </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">allowAsyncBind</span><span class="s2">.</span><span class="s1">getValue</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s1">allowAsyncBind</span>

        <span class="s5"># create data structures</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__sortedLODNames </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict </span><span class="s2">= {}</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartsComplete </span><span class="s2">= </span><span class="s4">False</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODAnimation </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODCenter </span><span class="s2">= </span><span class="s1">Point3</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">switches </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s1">other </span><span class="s2">== </span><span class="s4">None</span><span class="s2">):</span>
            <span class="s5"># act like a normal constructor</span>

            <span class="s5"># create base hierarchy</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">gotName </span><span class="s2">= </span><span class="s6">0</span>

            <span class="s4">if </span><span class="s1">flattenable</span><span class="s2">:</span>
                <span class="s5"># If we want a flattenable Actor, don't create all</span>
                <span class="s5"># those ModelNodes, and the GeomNode is the same as</span>
                <span class="s5"># the root.</span>
                <span class="s1">root </span><span class="s2">= </span><span class="s1">PandaNode</span><span class="s2">(</span><span class="s3">'actor'</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assign</span><span class="s2">(</span><span class="s1">NodePath</span><span class="s2">(</span><span class="s1">root</span><span class="s2">))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">setGeomNode</span><span class="s2">(</span><span class="s1">NodePath</span><span class="s2">(</span><span class="s1">self</span><span class="s2">))</span>

            <span class="s4">else</span><span class="s2">:</span>
                <span class="s5"># A standard Actor has a ModelNode at the root, and</span>
                <span class="s5"># another ModelNode to protect the GeomNode.</span>
                <span class="s1">root </span><span class="s2">= </span><span class="s1">ModelNode</span><span class="s2">(</span><span class="s3">'actor'</span><span class="s2">)</span>
                <span class="s1">root</span><span class="s2">.</span><span class="s1">setPreserveTransform</span><span class="s2">(</span><span class="s6">1</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assign</span><span class="s2">(</span><span class="s1">NodePath</span><span class="s2">(</span><span class="s1">root</span><span class="s2">))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">setGeomNode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">attachNewNode</span><span class="s2">(</span><span class="s1">ModelNode</span><span class="s2">(</span><span class="s3">'actorGeom'</span><span class="s2">)))</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">__hasLOD </span><span class="s2">= </span><span class="s6">0</span>

            <span class="s5"># load models</span>
            <span class="s5">#</span>
            <span class="s5"># four cases:</span>
            <span class="s5">#</span>
            <span class="s5">#   models, anims{} = single part actor</span>
            <span class="s5">#   models{}, anims{} =  single part actor w/ LOD</span>
            <span class="s5">#   models{}, anims{}{} = multi-part actor</span>
            <span class="s5">#   models{}{}, anims{}{} = multi-part actor w/ LOD</span>
            <span class="s5">#</span>
            <span class="s5"># make sure we have models</span>
            <span class="s4">if </span><span class="s1">models</span><span class="s2">:</span>
                <span class="s5"># do we have a dictionary of models?</span>
                <span class="s4">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">models</span><span class="s2">) == </span><span class="s1">dict</span><span class="s2">:</span>
                    <span class="s5"># if this is a dictionary of dictionaries</span>
                    <span class="s4">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">models</span><span class="s2">[</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">models</span><span class="s2">))]) == </span><span class="s1">dict</span><span class="s2">:</span>
                        <span class="s5"># then it must be a multipart actor w/LOD</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">setLODNode</span><span class="s2">(</span><span class="s1">node </span><span class="s2">= </span><span class="s1">lodNode</span><span class="s2">)</span>
                        <span class="s5"># preserve numerical order for lod's</span>
                        <span class="s5"># this will make it easier to set ranges</span>
                        <span class="s1">sortedKeys </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">models</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
                        <span class="s1">sortedKeys</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
                        <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">sortedKeys</span><span class="s2">:</span>
                            <span class="s5"># make a node under the LOD switch</span>
                            <span class="s5"># for each lod (just because!)</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">addLOD</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">))</span>
                            <span class="s5"># iterate over both dicts</span>
                            <span class="s4">for </span><span class="s1">modelName </span><span class="s4">in </span><span class="s1">models</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">]:</span>
                                <span class="s1">self</span><span class="s2">.</span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">models</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">modelName</span><span class="s2">],</span>
                                               <span class="s1">modelName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">copy </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">,</span>
                                               <span class="s1">okMissing </span><span class="s2">= </span><span class="s1">okMissing</span><span class="s2">)</span>
                    <span class="s5"># then if there is a dictionary of dictionaries of anims</span>
                    <span class="s4">elif </span><span class="s1">type</span><span class="s2">(</span><span class="s1">anims</span><span class="s2">[</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">anims</span><span class="s2">))]) == </span><span class="s1">dict</span><span class="s2">:</span>
                        <span class="s5"># then this is a multipart actor w/o LOD</span>
                        <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">models</span><span class="s2">:</span>
                            <span class="s5"># pass in each part</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">models</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">], </span><span class="s1">partName</span><span class="s2">,</span>
                                           <span class="s1">copy </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s1">okMissing</span><span class="s2">)</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s5"># it is a single part actor w/LOD</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">setLODNode</span><span class="s2">(</span><span class="s1">node </span><span class="s2">= </span><span class="s1">lodNode</span><span class="s2">)</span>
                        <span class="s5"># preserve order of LOD's</span>
                        <span class="s1">sortedKeys </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">models</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
                        <span class="s1">sortedKeys</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
                        <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">sortedKeys</span><span class="s2">:</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">addLOD</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">))</span>
                            <span class="s5"># pass in dictionary of parts</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">models</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">], </span><span class="s1">lodName</span><span class="s2">=</span><span class="s1">lodName</span><span class="s2">,</span>
                                           <span class="s1">copy </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s1">okMissing</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s5"># else it is a single part actor</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">models</span><span class="s2">, </span><span class="s1">copy </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s1">okMissing</span><span class="s2">)</span>

            <span class="s5"># load anims</span>
            <span class="s5"># make sure the actor has animations</span>
            <span class="s4">if </span><span class="s1">anims</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">anims</span><span class="s2">) &gt;= </span><span class="s6">1</span><span class="s2">:</span>
                    <span class="s5"># if so, does it have a dictionary of dictionaries?</span>
                    <span class="s4">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">anims</span><span class="s2">[</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">anims</span><span class="s2">))]) == </span><span class="s1">dict</span><span class="s2">:</span>
                        <span class="s5"># are the models a dict of dicts too?</span>
                        <span class="s4">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">models</span><span class="s2">) == </span><span class="s1">dict</span><span class="s2">:</span>
                            <span class="s4">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">models</span><span class="s2">[</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">models</span><span class="s2">))]) == </span><span class="s1">dict</span><span class="s2">:</span>
                                <span class="s5"># then we have a multi-part w/ LOD</span>
                                <span class="s1">sortedKeys </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">models</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
                                <span class="s1">sortedKeys</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
                                <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">sortedKeys</span><span class="s2">:</span>
                                    <span class="s5"># iterate over both dicts</span>
                                    <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">anims</span><span class="s2">:</span>
                                        <span class="s1">self</span><span class="s2">.</span><span class="s1">loadAnims</span><span class="s2">(</span>
                                            <span class="s1">anims</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">], </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">)</span>
                            <span class="s4">else</span><span class="s2">:</span>
                                <span class="s5"># then it must be multi-part w/o LOD</span>
                                <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">anims</span><span class="s2">:</span>
                                    <span class="s1">self</span><span class="s2">.</span><span class="s1">loadAnims</span><span class="s2">(</span><span class="s1">anims</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">], </span><span class="s1">partName</span><span class="s2">)</span>
                    <span class="s4">elif </span><span class="s1">type</span><span class="s2">(</span><span class="s1">models</span><span class="s2">) == </span><span class="s1">dict</span><span class="s2">:</span>
                        <span class="s5"># then we have single-part w/ LOD</span>
                        <span class="s1">sortedKeys </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">models</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
                        <span class="s1">sortedKeys</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
                        <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">sortedKeys</span><span class="s2">:</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">loadAnims</span><span class="s2">(</span><span class="s1">anims</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s1">lodName</span><span class="s2">)</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s5"># else it is single-part w/o LOD</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">loadAnims</span><span class="s2">(</span><span class="s1">anims</span><span class="s2">)</span>

        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">copyActor</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s4">True</span><span class="s2">) </span><span class="s5"># overwrite everything</span>

        <span class="s4">if </span><span class="s1">setFinal</span><span class="s2">:</span>
            <span class="s5"># If setFinal is true, the Actor will set its top bounding</span>
            <span class="s5"># volume to be the &quot;final&quot; bounding volume: the bounding</span>
            <span class="s5"># volumes below the top volume will not be tested.  If a</span>
            <span class="s5"># cull test passes the top bounding volume, the whole</span>
            <span class="s5"># Actor is rendered.</span>

            <span class="s5"># We do this partly because an Actor is likely to be a</span>
            <span class="s5"># fairly small object relative to the scene, and is pretty</span>
            <span class="s5"># much going to be all onscreen or all offscreen anyway;</span>
            <span class="s5"># and partly because of the Character bug that doesn't</span>
            <span class="s5"># update the bounding volume for pieces that animate away</span>
            <span class="s5"># from their original position.  It's disturbing to see</span>
            <span class="s5"># someone's hands disappear; better to cull the whole</span>
            <span class="s5"># object or none of it.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">setFinal</span><span class="s2">(</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">delete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">Actor_deleted</span>
            <span class="s4">return</span>
        <span class="s4">except</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">Actor_deleted </span><span class="s2">= </span><span class="s6">1</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cleanup</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">copyActor</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
            <span class="s5"># act like a copy constructor</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">gotName </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">gotName</span>

            <span class="s5"># copy the scene graph elements of other</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">overwrite</span><span class="s2">):</span>
                <span class="s1">otherCopy </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">copyTo</span><span class="s2">(</span><span class="s1">NodePath</span><span class="s2">())</span>
                <span class="s1">otherCopy</span><span class="s2">.</span><span class="s1">detachNode</span><span class="s2">()</span>
                <span class="s5"># assign these elements to ourselve (overwrite)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">assign</span><span class="s2">(</span><span class="s1">otherCopy</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s5"># just copy these to ourselves</span>
                <span class="s1">otherCopy </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">copyTo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
            <span class="s5"># masad: check if otherCopy has a geomNode as its first child</span>
            <span class="s5"># if actor is initialized with flattenable, then otherCopy, not</span>
            <span class="s5"># its first child, is the geom node; check __init__, for reference</span>
            <span class="s4">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">getGeomNode</span><span class="s2">().</span><span class="s1">getName</span><span class="s2">() == </span><span class="s1">other</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">():</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">setGeomNode</span><span class="s2">(</span><span class="s1">otherCopy</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">setGeomNode</span><span class="s2">(</span><span class="s1">otherCopy</span><span class="s2">.</span><span class="s1">getChild</span><span class="s2">(</span><span class="s6">0</span><span class="s2">))</span>

            <span class="s5"># copy the switches for lods</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">switches </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">switches</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">'**/+LODNode'</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__hasLOD </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s4">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">()):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__hasLOD </span><span class="s2">= </span><span class="s6">1</span>


            <span class="s5"># copy the part dictionary from other</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__copyPartBundles</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__copySubpartDict</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartsComplete </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__subpartsComplete</span>

            <span class="s5"># copy the anim dictionary from other</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__copyAnimControls</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>


    <span class="s4">def </span><span class="s1">__cmp__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s5"># Actor inherits from NodePath, which inherits a definition of</span>
        <span class="s5"># __cmp__ from FFIExternalObject that uses the NodePath's</span>
        <span class="s5"># compareTo() method to compare different NodePaths.  But we</span>
        <span class="s5"># don't want this behavior for Actors; Actors should only be</span>
        <span class="s5"># compared pointerwise.  A NodePath that happens to reference</span>
        <span class="s5"># the same node is still different from the Actor.</span>
        <span class="s4">if </span><span class="s1">self </span><span class="s4">is </span><span class="s1">other</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s6">0</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s6">1</span>

    <span class="s4">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Actor print function 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s3">&quot;Actor %s, parts = %s, LODs = %s, anims = %s&quot; </span><span class="s2">% </span><span class="s1">\</span>
               <span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">(), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getPartNames</span><span class="s2">(), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getLODNames</span><span class="s2">(), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimNames</span><span class="s2">())</span>

    <span class="s4">def </span><span class="s1">listJoints</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s3">&quot;modelRoot&quot;</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Handy utility function to list the joint hierarchy of the 
        actor. &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
            <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">error</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>

        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>

        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">error</span><span class="s2">(</span><span class="s3">&quot;no part named: %s&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__doListJoints</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">(),</span>
                            <span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">subset</span><span class="s2">.</span><span class="s1">isIncludeEmpty</span><span class="s2">(), </span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">subset</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__doListJoints</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indentLevel</span><span class="s2">, </span><span class="s1">part</span><span class="s2">, </span><span class="s1">isIncluded</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">):</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s1">part</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">subset</span><span class="s2">.</span><span class="s1">matchesInclude</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
            <span class="s1">isIncluded </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s4">elif </span><span class="s1">subset</span><span class="s2">.</span><span class="s1">matchesExclude</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
            <span class="s1">isIncluded </span><span class="s2">= </span><span class="s4">False</span>

        <span class="s4">if </span><span class="s1">isIncluded</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s3">''</span>
            <span class="s4">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">part</span><span class="s2">, </span><span class="s3">'outputValue'</span><span class="s2">):</span>
                <span class="s1">lineStream </span><span class="s2">= </span><span class="s1">LineStream</span><span class="s2">()</span>
                <span class="s1">part</span><span class="s2">.</span><span class="s1">outputValue</span><span class="s2">(</span><span class="s1">lineStream</span><span class="s2">)</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">lineStream</span><span class="s2">.</span><span class="s1">getLine</span><span class="s2">()</span>

            <span class="s1">print</span><span class="s2">(</span><span class="s3">' '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">((</span><span class="s3">' ' </span><span class="s2">* </span><span class="s1">indentLevel</span><span class="s2">, </span><span class="s1">part</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">(), </span><span class="s1">value</span><span class="s2">)))</span>

        <span class="s4">for </span><span class="s1">child </span><span class="s4">in </span><span class="s1">part</span><span class="s2">.</span><span class="s1">getChildren</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__doListJoints</span><span class="s2">(</span><span class="s1">indentLevel </span><span class="s2">+ </span><span class="s6">2</span><span class="s2">, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">isIncluded</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">)</span>


    <span class="s4">def </span><span class="s1">getActorInfo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Utility function to create a list of information about an actor. 
        Useful for iterating over details of an actor. 
        &quot;&quot;&quot;</span>
        <span class="s1">lodInfo </span><span class="s2">= []</span>
        <span class="s4">for </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">partDict </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
                <span class="s1">lodName </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__sortedLODNames</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

            <span class="s1">partInfo </span><span class="s2">= []</span>
            <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">partDict</span><span class="s2">:</span>
                <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
                <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
                <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
                <span class="s1">partBundle </span><span class="s2">= </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">()</span>
                <span class="s1">animDict </span><span class="s2">= </span><span class="s1">partDict</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">]</span>
                <span class="s1">animInfo </span><span class="s2">= []</span>
                <span class="s4">for </span><span class="s1">animName </span><span class="s4">in </span><span class="s1">animDict</span><span class="s2">:</span>
                    <span class="s1">file </span><span class="s2">= </span><span class="s1">animDict</span><span class="s2">[</span><span class="s1">animName</span><span class="s2">].</span><span class="s1">filename</span>
                    <span class="s1">animControl </span><span class="s2">= </span><span class="s1">animDict</span><span class="s2">[</span><span class="s1">animName</span><span class="s2">].</span><span class="s1">animControl</span>
                    <span class="s1">animInfo</span><span class="s2">.</span><span class="s1">append</span><span class="s2">([</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">animControl</span><span class="s2">])</span>
                <span class="s1">partInfo</span><span class="s2">.</span><span class="s1">append</span><span class="s2">([</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">partBundle</span><span class="s2">, </span><span class="s1">animInfo</span><span class="s2">])</span>
            <span class="s1">lodInfo</span><span class="s2">.</span><span class="s1">append</span><span class="s2">([</span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">partInfo</span><span class="s2">])</span>
        <span class="s4">return </span><span class="s1">lodInfo</span>

    <span class="s4">def </span><span class="s1">getAnimNames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">animNames </span><span class="s2">= []</span>
        <span class="s4">for </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">lodInfo </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getActorInfo</span><span class="s2">():</span>
            <span class="s4">for </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">animInfo </span><span class="s4">in </span><span class="s1">lodInfo</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">animControl </span><span class="s4">in </span><span class="s1">animInfo</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">animName </span><span class="s4">not in </span><span class="s1">animNames</span><span class="s2">:</span>
                        <span class="s1">animNames</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">animNames</span>

    <span class="s4">def </span><span class="s1">pprint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Pretty print actor's details 
        &quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">lodInfo </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getActorInfo</span><span class="s2">():</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">'LOD: %s' </span><span class="s2">% </span><span class="s1">lodName</span><span class="s2">)</span>
            <span class="s4">for </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">animInfo </span><span class="s4">in </span><span class="s1">lodInfo</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">'  Part: %s' </span><span class="s2">% </span><span class="s1">partName</span><span class="s2">)</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">'  Bundle: %r' </span><span class="s2">% </span><span class="s1">bundle</span><span class="s2">)</span>
                <span class="s4">for </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">animControl </span><span class="s4">in </span><span class="s1">animInfo</span><span class="s2">:</span>
                    <span class="s1">print</span><span class="s2">(</span><span class="s3">'    Anim: %s' </span><span class="s2">% </span><span class="s1">animName</span><span class="s2">)</span>
                    <span class="s1">print</span><span class="s2">(</span><span class="s3">'      File: %s' </span><span class="s2">% </span><span class="s1">file</span><span class="s2">)</span>
                    <span class="s4">if </span><span class="s1">animControl </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                        <span class="s1">print</span><span class="s2">(</span><span class="s3">' (not loaded)'</span><span class="s2">)</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">print</span><span class="s2">(</span><span class="s3">'      NumFrames: %d PlayRate: %0.2f' </span><span class="s2">%</span>
                               <span class="s2">(</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">getNumFrames</span><span class="s2">(),</span>
                                <span class="s1">animControl</span><span class="s2">.</span><span class="s1">getPlayRate</span><span class="s2">()))</span>

    <span class="s4">def </span><span class="s1">cleanup</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        This method should be called when intending to destroy the Actor, and 
        cleans up any additional resources stored on the Actor class before 
        removing the underlying node using `removeNode()`. 
 
        Note that `removeNode()` itself is not sufficient to destroy actors, 
        which is why this method exists. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">stop</span><span class="s2">(</span><span class="s4">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">clearPythonData</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">flush</span><span class="s2">()</span>
        <span class="s4">if</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">.</span><span class="s1">removeNode</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">removeNode</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">removeNode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        You should call `cleanup()` for Actor objects instead, since 
        :meth:`~panda3d.core.NodePath.removeNode()` is not sufficient for 
        completely destroying Actor objects. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode </span><span class="s4">and </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">.</span><span class="s1">getNumChildren</span><span class="s2">() &gt; </span><span class="s6">0</span><span class="s2">):</span>
            <span class="s4">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;called actor.removeNode() on %s without calling cleanup()&quot; </span><span class="s2">% </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">())</span>
        <span class="s1">NodePath</span><span class="s2">.</span><span class="s1">removeNode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">clearPythonData</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__sortedLODNames </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict </span><span class="s2">= {}</span>

    <span class="s4">def </span><span class="s1">flush</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Actor flush function.  Used by `cleanup()`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">clearPythonData</span><span class="s2">()</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode </span><span class="s4">and </span><span class="s2">(</span><span class="s4">not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">()):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">removeNode</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s5"># remove all its children</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">.</span><span class="s1">getChildren</span><span class="s2">().</span><span class="s1">detach</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__hasLOD </span><span class="s2">= </span><span class="s6">0</span>

    <span class="s5"># accessing</span>

    <span class="s4">def </span><span class="s1">getAnimControlDict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span>

    <span class="s4">def </span><span class="s1">removeAnimControlDict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict </span><span class="s2">= {}</span>

    <span class="s4">def </span><span class="s1">getPartBundleDict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span>

    <span class="s4">def </span><span class="s1">getPartBundles</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Returns a list of PartBundle objects for the entire Actor, 
        or for the indicated part only. &quot;&quot;&quot;</span>

        <span class="s1">bundles </span><span class="s2">= []</span>

        <span class="s4">for </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">partBundleDict </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s4">if </span><span class="s1">partName </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s1">partDef </span><span class="s4">in </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                    <span class="s1">bundles</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">())</span>

            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
                <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">partDef </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
                    <span class="s1">bundles</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">())</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;Couldn't find part: %s&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>

        <span class="s4">return </span><span class="s1">bundles</span>

    <span class="s4">def </span><span class="s1">__updateSortedLODNames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5"># Cache the sorted LOD names so we don't have to grab them</span>
        <span class="s5"># and sort them every time somebody asks for the list</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__sortedLODNames </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s5"># Reverse sort the doing a string-&gt;int</span>
        <span class="s4">def </span><span class="s1">sortKey</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s4">if not </span><span class="s1">str</span><span class="s2">(</span><span class="s1">x</span><span class="s2">).</span><span class="s1">isdigit</span><span class="s2">():</span>
                <span class="s1">smap </span><span class="s2">= {</span><span class="s3">'h'</span><span class="s2">:</span><span class="s6">3</span><span class="s2">,</span>
                        <span class="s3">'m'</span><span class="s2">:</span><span class="s6">2</span><span class="s2">,</span>
                        <span class="s3">'l'</span><span class="s2">:</span><span class="s6">1</span><span class="s2">,</span>
                        <span class="s3">'f'</span><span class="s2">:</span><span class="s6">0</span><span class="s2">}</span>

                <span class="s3">&quot;&quot;&quot; 
                sx = smap.get(x[0], None) 
 
                if sx is None: 
                    self.notify.error('Invalid lodName: %s' % x) 
                &quot;&quot;&quot;</span>
                <span class="s4">return </span><span class="s1">smap</span><span class="s2">[</span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]]</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">int</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__sortedLODNames</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s1">sortKey</span><span class="s2">, </span><span class="s1">reverse</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">getLODNames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return list of Actor LOD names. If not an LOD actor, 
        returns 'lodRoot' 
        Caution - this returns a reference to the list - not your own copy 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__sortedLODNames</span>

    <span class="s4">def </span><span class="s1">getPartNames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return list of Actor part names. If not an multipart actor, 
        returns 'modelRoot' NOTE: returns parts of arbitrary LOD 
        &quot;&quot;&quot;</span>
        <span class="s1">partNames </span><span class="s2">= []</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">:</span>
            <span class="s1">partNames </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())).</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s4">return </span><span class="s1">partNames </span><span class="s2">+ </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>

    <span class="s4">def </span><span class="s1">getGeomNode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the node that contains all actor geometry 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span>

    <span class="s4">def </span><span class="s1">setGeomNode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the node that contains all actor geometry 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode </span><span class="s2">= </span><span class="s1">node</span>

    <span class="s4">def </span><span class="s1">getLODNode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the node that switches actor geometry in and out&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">setLODNode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the node that switches actor geometry in and out. 
        If one is not supplied as an argument, make one 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">node </span><span class="s2">== </span><span class="s4">None</span><span class="s2">):</span>
            <span class="s1">node </span><span class="s2">= </span><span class="s1">LODNode</span><span class="s2">.</span><span class="s1">makeDefaultLod</span><span class="s2">(</span><span class="s3">&quot;lod&quot;</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode </span><span class="s2">= </span><span class="s1">node</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">.</span><span class="s1">attachNewNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__hasLOD </span><span class="s2">= </span><span class="s6">1</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">switches </span><span class="s2">= {}</span>


    <span class="s4">def </span><span class="s1">useLOD</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Make the Actor ONLY display the given LOD 
        &quot;&quot;&quot;</span>
        <span class="s5"># make sure we don't call this twice in a row</span>
        <span class="s5"># and pollute the the switches dictionary</span>
        <span class="s1">child </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">))</span>
        <span class="s1">index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">findChild</span><span class="s2">(</span><span class="s1">child</span><span class="s2">.</span><span class="s1">node</span><span class="s2">())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">forceSwitch</span><span class="s2">(</span><span class="s1">index</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">printLOD</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">sortedKeys </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__sortedLODNames</span>
        <span class="s4">for </span><span class="s1">eachLod </span><span class="s4">in </span><span class="s1">sortedKeys</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;python switches for %s: in: %d, out %d&quot; </span><span class="s2">% (</span><span class="s1">eachLod</span><span class="s2">,</span>
                                              <span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">[</span><span class="s1">eachLod</span><span class="s2">][</span><span class="s6">0</span><span class="s2">],</span>
                                              <span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">[</span><span class="s1">eachLod</span><span class="s2">][</span><span class="s6">1</span><span class="s2">]))</span>

        <span class="s1">switchNum </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getNumSwitches</span><span class="s2">()</span>
        <span class="s4">for </span><span class="s1">eachSwitch </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">switchNum</span><span class="s2">):</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;c++ switches for %d: in: %d, out: %d&quot; </span><span class="s2">% (</span><span class="s1">eachSwitch</span><span class="s2">,</span>
                   <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getIn</span><span class="s2">(</span><span class="s1">eachSwitch</span><span class="s2">),</span>
                   <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getOut</span><span class="s2">(</span><span class="s1">eachSwitch</span><span class="s2">)))</span>


    <span class="s4">def </span><span class="s1">resetLOD</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restore all switch distance info (usually after a useLOD call)&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">clearForceSwitch</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">addLOD</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">inDist</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">outDist</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">center</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;addLOD(self, string) 
        Add a named node under the LODNode to parent all geometry 
        of a specific LOD under. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">attachNewNode</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">))</span>
        <span class="s5"># save the switch distance info</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">] = [</span><span class="s1">inDist</span><span class="s2">, </span><span class="s1">outDist</span><span class="s2">]</span>
        <span class="s5"># add the switch distance info</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">addSwitch</span><span class="s2">(</span><span class="s1">inDist</span><span class="s2">, </span><span class="s1">outDist</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">center </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">setCenter</span><span class="s2">(</span><span class="s1">center</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">setLOD</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">inDist</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">outDist</span><span class="s2">=</span><span class="s6">0</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;setLOD(self, string) 
        Set the switch distance for given LOD 
        &quot;&quot;&quot;</span>
        <span class="s5"># save the switch distance info</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">] = [</span><span class="s1">inDist</span><span class="s2">, </span><span class="s1">outDist</span><span class="s2">]</span>
        <span class="s5"># add the switch distance info</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">setSwitch</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">getLODIndex</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">), </span><span class="s1">inDist</span><span class="s2">, </span><span class="s1">outDist</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">getLODIndex</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;getLODIndex(self) 
        safe method (but expensive) for retrieving the child index 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">getChildren</span><span class="s2">()).</span><span class="s1">index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">getLOD</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">getLOD</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;getLOD(self, string) 
        Get the named node under the LOD to which we parent all LOD 
        specific geometry to. Returns 'None' if not found 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">:</span>
            <span class="s1">lod </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">if </span><span class="s1">lod</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">():</span>
                <span class="s4">return None</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">lod</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">hasLOD</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return 1 if the actor has LODs, 0 otherwise 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__hasLOD</span>

    <span class="s4">def </span><span class="s1">setCenter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">center</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">center </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">center </span><span class="s2">= </span><span class="s1">Point3</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODCenter </span><span class="s2">= </span><span class="s1">center</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">setCenter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODCenter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODAnimation</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">setLODAnimation</span><span class="s2">(*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODAnimation</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">setLODAnimation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">farDistance</span><span class="s2">, </span><span class="s1">nearDistance</span><span class="s2">, </span><span class="s1">delayFactor</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Activates a special mode in which the Actor animates less 
        frequently as it gets further from the camera.  This is 
        intended as a simple optimization to minimize the effort of 
        computing animation for lots of characters that may not 
        necessarily be very important to animate every frame. 
 
        If the character is closer to the camera than near_distance, 
        then it is animated its normal rate, every frame.  If the 
        character is exactly far_distance away, it is animated only 
        every delay_factor seconds (which should be a number greater 
        than 0).  If the character is between near_distance and 
        far_distance, its animation rate is linearly interpolated 
        according to its distance between the two.  The interpolation 
        function continues beyond far_distance, so that the character 
        is animated increasingly less frequently as it gets farther 
        away. &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODAnimation </span><span class="s2">= (</span><span class="s1">farDistance</span><span class="s2">, </span><span class="s1">nearDistance</span><span class="s2">, </span><span class="s1">delayFactor</span><span class="s2">)</span>

        <span class="s4">for </span><span class="s1">lodData </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s4">for </span><span class="s1">partData </span><span class="s4">in </span><span class="s1">lodData</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                <span class="s1">char </span><span class="s2">= </span><span class="s1">partData</span><span class="s2">.</span><span class="s1">partBundleNP</span>
                <span class="s1">char</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">setLodAnimation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODCenter</span><span class="s2">, </span><span class="s1">farDistance</span><span class="s2">, </span><span class="s1">nearDistance</span><span class="s2">, </span><span class="s1">delayFactor</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">clearLODAnimation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Description: Undoes the effect of a recent call to 
        set_lod_animation().  Henceforth, the character will animate 
        every frame, regardless of its distance from the camera. 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__LODAnimation </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">for </span><span class="s1">lodData </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s4">for </span><span class="s1">partData </span><span class="s4">in </span><span class="s1">lodData</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                <span class="s1">char </span><span class="s2">= </span><span class="s1">partData</span><span class="s2">.</span><span class="s1">partBundleNP</span>
                <span class="s1">char</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">clearLodAnimation</span><span class="s2">()</span>


    <span class="s4">def </span><span class="s1">update</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lod</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">force</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Updates all of the Actor's joints in the indicated LOD. 
        The LOD may be specified by name, or by number, where 0 is the 
        highest level of detail, 1 is the next highest, and so on. 
 
        If force is True, this will update every joint, even if we 
        don't believe it's necessary. 
 
        Returns True if any joint has changed as a result of this, 
        False otherwise. &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">lodName </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getLODNames</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= [</span><span class="s1">lodName</span><span class="s2">]</span>

        <span class="s1">anyChanged </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">if </span><span class="s1">lod </span><span class="s2">&lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">lodNames</span><span class="s2">):</span>
            <span class="s1">lodName </span><span class="s2">= </span><span class="s1">lodNames</span><span class="s2">[</span><span class="s1">lod</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">partName </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">]</span>
                <span class="s1">partNames </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">partNames </span><span class="s2">= [</span><span class="s1">partName</span><span class="s2">]</span>

            <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">partNames</span><span class="s2">:</span>
                <span class="s1">partBundle </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getPartBundle</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodNames</span><span class="s2">[</span><span class="s1">lod</span><span class="s2">])</span>
                <span class="s4">if </span><span class="s1">force</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">partBundle</span><span class="s2">.</span><span class="s1">forceUpdate</span><span class="s2">():</span>
                        <span class="s1">anyChanged </span><span class="s2">= </span><span class="s4">True</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">partBundle</span><span class="s2">.</span><span class="s1">update</span><span class="s2">():</span>
                        <span class="s1">anyChanged </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">'update() - no lod: %d' </span><span class="s2">% </span><span class="s1">lod</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">anyChanged</span>

    <span class="s4">def </span><span class="s1">getFrameRate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;getFrameRate(self, string, string=None) 
        Return actual frame rate of given anim name and given part. 
        If no anim specified, use the currently playing anim. 
        If no part specified, return anim durations of first part. 
        NOTE: returns info only for an arbitrary LOD 
        &quot;&quot;&quot;</span>
        <span class="s1">lodName </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">))</span>
        <span class="s1">controls </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">controls</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">controls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">getFrameRate</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">getBaseFrameRate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;getBaseFrameRate(self, string, string=None) 
        Return frame rate of given anim name and given part, unmodified 
        by any play rate in effect. 
        &quot;&quot;&quot;</span>
        <span class="s1">lodName </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">))</span>
        <span class="s1">controls </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">controls</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">controls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">getAnim</span><span class="s2">().</span><span class="s1">getBaseFrameRate</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">getPlayRate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the play rate of given anim for a given part. 
        If no part is given, assume first part in dictionary. 
        If no anim is given, find the current anim for the part. 
        NOTE: Returns info only for an arbitrary LOD 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">:</span>
            <span class="s5"># use the first lod</span>
            <span class="s1">lodName </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">))</span>
            <span class="s1">controls </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">controls</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">controls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">getPlayRate</span><span class="s2">()</span>
        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">setPlayRate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">rate</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;setPlayRate(self, float, string, string=None) 
        Set the play rate of given anim for a given part. 
        If no part is given, set for all parts in dictionary. 
 
        It used to be legal to let the animName default to the 
        currently-playing anim, but this was confusing and could lead 
        to the wrong anim's play rate getting set.  Better to insist 
        on this parameter. 
        NOTE: sets play rate on all LODs&quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">):</span>
            <span class="s1">control</span><span class="s2">.</span><span class="s1">setPlayRate</span><span class="s2">(</span><span class="s1">rate</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">getDuration</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                    <span class="s1">fromFrame</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">toFrame</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return duration of given anim name and given part. 
        If no anim specified, use the currently playing anim. 
        If no part specified, return anim duration of first part. 
        NOTE: returns info for arbitrary LOD 
        &quot;&quot;&quot;</span>
        <span class="s1">lodName </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">))</span>
        <span class="s1">controls </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">controls</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">return None</span>

        <span class="s1">animControl </span><span class="s2">= </span><span class="s1">controls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">fromFrame </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">fromFrame </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s4">if </span><span class="s1">toFrame </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">toFrame </span><span class="s2">= </span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">getNumFrames</span><span class="s2">()-</span><span class="s6">1</span>
        <span class="s4">return </span><span class="s2">((</span><span class="s1">toFrame</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)-</span><span class="s1">fromFrame</span><span class="s2">) / </span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">getFrameRate</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">getNumFrames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s5">#lodName = next(iter(self.__animControlDict))</span>
        <span class="s1">controls </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">controls</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">return None</span>
        <span class="s4">return </span><span class="s1">controls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">getNumFrames</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">getFrameTime</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">anim</span><span class="s2">, </span><span class="s1">frame</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s1">numFrames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getNumFrames</span><span class="s2">(</span><span class="s1">anim</span><span class="s2">,</span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s1">animTime </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getDuration</span><span class="s2">(</span><span class="s1">anim</span><span class="s2">,</span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s1">frameTime </span><span class="s2">= </span><span class="s1">animTime </span><span class="s2">* </span><span class="s1">float</span><span class="s2">(</span><span class="s1">frame</span><span class="s2">) / </span><span class="s1">numFrames</span>
        <span class="s4">return </span><span class="s1">frameTime</span>

    <span class="s4">def </span><span class="s1">getCurrentAnim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the anim currently playing on the actor. If part not 
        specified return current anim of an arbitrary part in dictionary. 
        NOTE: only returns info for an arbitrary LOD 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">return</span>

        <span class="s1">lodName</span><span class="s2">, </span><span class="s1">animControlDict </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()))</span>
        <span class="s4">if </span><span class="s1">partName </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">partName</span><span class="s2">, </span><span class="s1">animDict </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">animControlDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">animDict </span><span class="s2">= </span><span class="s1">animControlDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">animDict </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s5"># part was not present</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;couldn't find part: %s&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
                <span class="s4">return None</span>

        <span class="s5"># loop through all anims for named part and find if any are playing</span>
        <span class="s4">for </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">anim </span><span class="s4">in </span><span class="s1">animDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s4">if </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl </span><span class="s4">and </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">isPlaying</span><span class="s2">():</span>
                <span class="s4">return </span><span class="s1">animName</span>

        <span class="s5"># we must have found none, or gotten an error</span>
        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">getCurrentFrame</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the current frame number of the named anim, or if no 
        anim is specified, then the anim current playing on the 
        actor. If part not specified return current anim of first part 
        in dictionary.  NOTE: only returns info for an arbitrary LOD 
        &quot;&quot;&quot;</span>
        <span class="s1">lodName</span><span class="s2">, </span><span class="s1">animControlDict </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()))</span>
        <span class="s4">if </span><span class="s1">partName </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">partName</span><span class="s2">, </span><span class="s1">animDict </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">animControlDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">animDict </span><span class="s2">= </span><span class="s1">animControlDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">animDict </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s5"># part was not present</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;couldn't find part: %s&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
                <span class="s4">return None</span>

        <span class="s4">if </span><span class="s1">animName</span><span class="s2">:</span>
            <span class="s1">anim </span><span class="s2">= </span><span class="s1">animDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">)</span>
            <span class="s4">if not </span><span class="s1">anim</span><span class="s2">:</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;couldn't find anim: %s&quot; </span><span class="s2">% (</span><span class="s1">animName</span><span class="s2">))</span>
            <span class="s4">elif </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">getFrame</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># loop through all anims for named part and find if any are playing</span>
            <span class="s4">for </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">anim </span><span class="s4">in </span><span class="s1">animDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s4">if </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl </span><span class="s4">and </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">isPlaying</span><span class="s2">():</span>
                    <span class="s4">return </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">getFrame</span><span class="s2">()</span>

        <span class="s5"># we must have found none, or gotten an error</span>
        <span class="s4">return None</span>


    <span class="s5"># arranging</span>

    <span class="s4">def </span><span class="s1">getPart</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find the named part in the optional named lod and return it, or 
        return None if not present 
        &quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return None</span>
        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span>
        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">getPartBundle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find the named part in the optional named lod and return its 
        associated PartBundle, or return None if not present 
        &quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return None</span>
        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">()</span>
        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">removePart</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove the geometry and animations of the named part of the 
        optional named lod if present. 
        NOTE: this will remove child geometry also! 
        &quot;&quot;&quot;</span>
        <span class="s5"># find the corresponding part bundle dict</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return</span>

        <span class="s5"># remove the part</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">partName </span><span class="s4">in </span><span class="s1">partBundleDict</span><span class="s2">):</span>
            <span class="s1">partBundleDict</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">].</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">removeNode</span><span class="s2">()</span>
            <span class="s4">del</span><span class="s2">(</span><span class="s1">partBundleDict</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">])</span>

        <span class="s5"># find the corresponding anim control dict</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">lodName </span><span class="s2">= </span><span class="s3">'common'</span>
        <span class="s1">partDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return</span>

        <span class="s5"># remove the animations</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">partName </span><span class="s4">in </span><span class="s1">partDict</span><span class="s2">):</span>
            <span class="s4">del</span><span class="s2">(</span><span class="s1">partDict</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">])</span>

    <span class="s4">def </span><span class="s1">hidePart</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Make the given part of the optionally given lod not render, 
        even though still in the tree. 
        NOTE: this will affect child geometry 
        &quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return</span>
        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
            <span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">hide</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">showPart</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Make the given part render while in the tree. 
        NOTE: this will affect child geometry 
        &quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return</span>
        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
            <span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">show</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">showAllParts</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Make the given part and all its children render while in the tree. 
        NOTE: this will affect child geometry 
        &quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return</span>
        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
            <span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">show</span><span class="s2">()</span>
            <span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">getChildren</span><span class="s2">().</span><span class="s1">show</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">exposeJoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">,</span>
                    <span class="s1">localTransform </span><span class="s2">= </span><span class="s6">0</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;exposeJoint(self, NodePath, string, string, key=&quot;lodRoot&quot;) 
        Starts the joint animating the indicated node.  As the joint 
        animates, it will transform the node by the corresponding 
        amount.  This will replace whatever matrix is on the node each 
        frame.  The default is to expose the net transform from the root, 
        but if localTransform is true, only the node's local transform 
        from its parent is exposed.&quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return None</span>

        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>

        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
            <span class="s1">bundle </span><span class="s2">= </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
            <span class="s4">return None</span>

        <span class="s5"># Get a handle to the joint.</span>
        <span class="s1">joint </span><span class="s2">= </span><span class="s1">bundle</span><span class="s2">.</span><span class="s1">findChild</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">node </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">node </span><span class="s2">= </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">attachNewNode</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s1">joint</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">localTransform</span><span class="s2">:</span>
                <span class="s1">joint</span><span class="s2">.</span><span class="s1">addLocalTransform</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">node</span><span class="s2">())</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">joint</span><span class="s2">.</span><span class="s1">addNetTransform</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">node</span><span class="s2">())</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no joint named %s!&quot; </span><span class="s2">% (</span><span class="s1">jointName</span><span class="s2">))</span>

        <span class="s4">return </span><span class="s1">node</span>

    <span class="s4">def </span><span class="s1">stopJoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;stopJoint(self, string, string, key=&quot;lodRoot&quot;) 
        Stops the joint from animating external nodes.  If the joint 
        is animating a transform on a node, this will permanently stop 
        it.  However, this does not affect vertex animations.&quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return None</span>

        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>

        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
            <span class="s1">bundle </span><span class="s2">= </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
            <span class="s4">return None</span>

        <span class="s5"># Get a handle to the joint.</span>
        <span class="s1">joint </span><span class="s2">= </span><span class="s1">bundle</span><span class="s2">.</span><span class="s1">findChild</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s1">joint</span><span class="s2">):</span>
            <span class="s1">joint</span><span class="s2">.</span><span class="s1">clearNetTransforms</span><span class="s2">()</span>
            <span class="s1">joint</span><span class="s2">.</span><span class="s1">clearLocalTransforms</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no joint named %s!&quot; </span><span class="s2">% (</span><span class="s1">jointName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">getJoints</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">jointName </span><span class="s2">= </span><span class="s3">'*'</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Returns the list of all joints, from the named part or 
        from all parts, that match the indicated jointName.  The 
        jointName may include pattern characters like \\*. &quot;&quot;&quot;</span>

        <span class="s1">joints</span><span class="s2">=[]</span>
        <span class="s1">pattern </span><span class="s2">= </span><span class="s1">GlobPattern</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">lodName </span><span class="s2">== </span><span class="s4">None and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s5"># Get the common bundle.</span>
            <span class="s1">partBundleDicts </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles</span><span class="s2">]</span>

        <span class="s4">elif </span><span class="s1">lodName </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s5"># Get all LOD's.</span>
            <span class="s1">partBundleDicts </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Get one LOD.</span>
            <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
            <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;couldn't find lod: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
                <span class="s4">return </span><span class="s2">[]</span>
            <span class="s1">partBundleDicts </span><span class="s2">= [</span><span class="s1">partBundleDict</span><span class="s2">]</span>

        <span class="s4">for </span><span class="s1">partBundleDict </span><span class="s4">in </span><span class="s1">partBundleDicts</span><span class="s2">:</span>
            <span class="s1">parts </span><span class="s2">= []</span>
            <span class="s4">if </span><span class="s1">partName</span><span class="s2">:</span>
                <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
                <span class="s4">if not </span><span class="s1">subpartDef</span><span class="s2">:</span>
                    <span class="s5"># Whole part</span>
                    <span class="s1">subset </span><span class="s2">= </span><span class="s4">None</span>
                    <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s5"># Sub-part</span>
                    <span class="s1">subset </span><span class="s2">= </span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">subset</span>
                    <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
                <span class="s4">if not </span><span class="s1">partDef</span><span class="s2">:</span>
                    <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
                    <span class="s4">return </span><span class="s2">[]</span>
                <span class="s1">parts </span><span class="s2">= [</span><span class="s1">partDef</span><span class="s2">]</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">subset </span><span class="s2">= </span><span class="s4">None</span>
                <span class="s1">parts </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()</span>

            <span class="s4">for </span><span class="s1">partData </span><span class="s4">in </span><span class="s1">parts</span><span class="s2">:</span>
                <span class="s1">partBundle </span><span class="s2">= </span><span class="s1">partData</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">()</span>

                <span class="s4">if not </span><span class="s1">pattern</span><span class="s2">.</span><span class="s1">hasGlobCharacters</span><span class="s2">() </span><span class="s4">and not </span><span class="s1">subset</span><span class="s2">:</span>
                    <span class="s5"># The simple case.</span>
                    <span class="s1">joint </span><span class="s2">= </span><span class="s1">partBundle</span><span class="s2">.</span><span class="s1">findChild</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>
                    <span class="s4">if </span><span class="s1">joint</span><span class="s2">:</span>
                        <span class="s1">joints</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">joint</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s5"># The more complex case.</span>
                    <span class="s1">isIncluded </span><span class="s2">= </span><span class="s4">True</span>
                    <span class="s4">if </span><span class="s1">subset</span><span class="s2">:</span>
                        <span class="s1">isIncluded </span><span class="s2">= </span><span class="s1">subset</span><span class="s2">.</span><span class="s1">isIncludeEmpty</span><span class="s2">()</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">__getPartJoints</span><span class="s2">(</span><span class="s1">joints</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">partBundle</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">, </span><span class="s1">isIncluded</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">joints</span>

    <span class="s4">def </span><span class="s1">getOverlappingJoints</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partNameA</span><span class="s2">, </span><span class="s1">partNameB</span><span class="s2">, </span><span class="s1">jointName </span><span class="s2">= </span><span class="s3">'*'</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Returns the set of joints, matching jointName, that are 
        shared between partNameA and partNameB. &quot;&quot;&quot;</span>
        <span class="s1">jointsA </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">getJoints</span><span class="s2">(</span><span class="s1">partName </span><span class="s2">= </span><span class="s1">partNameA</span><span class="s2">, </span><span class="s1">jointName </span><span class="s2">= </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s1">lodName</span><span class="s2">))</span>
        <span class="s1">jointsB </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">getJoints</span><span class="s2">(</span><span class="s1">partName </span><span class="s2">= </span><span class="s1">partNameB</span><span class="s2">, </span><span class="s1">jointName </span><span class="s2">= </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s1">lodName</span><span class="s2">))</span>

        <span class="s4">return </span><span class="s1">jointsA </span><span class="s2">&amp; </span><span class="s1">jointsB</span>

    <span class="s4">def </span><span class="s1">__getPartJoints</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">joints</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">partNode</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">, </span><span class="s1">isIncluded</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Recursively walks the joint hierarchy to look for matching 
        joint names, implementing getJoints(). &quot;&quot;&quot;</span>

        <span class="s1">name </span><span class="s2">= </span><span class="s1">partNode</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">subset</span><span class="s2">:</span>
            <span class="s5"># Constrain the traversal just to the named subset.</span>
            <span class="s4">if </span><span class="s1">subset</span><span class="s2">.</span><span class="s1">matchesInclude</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
                <span class="s1">isIncluded </span><span class="s2">= </span><span class="s4">True</span>
            <span class="s4">elif </span><span class="s1">subset</span><span class="s2">.</span><span class="s1">matchesExclude</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
                <span class="s1">isIncluded </span><span class="s2">= </span><span class="s4">False</span>

        <span class="s4">if </span><span class="s1">isIncluded </span><span class="s4">and </span><span class="s1">pattern</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">name</span><span class="s2">) </span><span class="s4">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">partNode</span><span class="s2">, </span><span class="s1">MovingPartBase</span><span class="s2">):</span>
            <span class="s1">joints</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">partNode</span><span class="s2">)</span>

        <span class="s4">for </span><span class="s1">child </span><span class="s4">in </span><span class="s1">partNode</span><span class="s2">.</span><span class="s1">getChildren</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__getPartJoints</span><span class="s2">(</span><span class="s1">joints</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">, </span><span class="s1">isIncluded</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">getJointTransform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">'lodRoot'</span><span class="s2">):</span>
        <span class="s1">partBundleDict</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return None</span>

        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
            <span class="s1">bundle </span><span class="s2">= </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
            <span class="s4">return None</span>

        <span class="s1">joint </span><span class="s2">= </span><span class="s1">bundle</span><span class="s2">.</span><span class="s1">findChild</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">joint </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no joint named %s!&quot; </span><span class="s2">% (</span><span class="s1">jointName</span><span class="s2">))</span>
            <span class="s4">return None</span>
        <span class="s4">return </span><span class="s1">joint</span><span class="s2">.</span><span class="s1">getDefaultValue</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">getJointTransformState</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">'lodRoot'</span><span class="s2">):</span>
        <span class="s1">partBundleDict</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">return None</span>

        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
            <span class="s1">bundle </span><span class="s2">= </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
            <span class="s4">return None</span>

        <span class="s1">joint </span><span class="s2">= </span><span class="s1">bundle</span><span class="s2">.</span><span class="s1">findChild</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">joint </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no joint named %s!&quot; </span><span class="s2">% (</span><span class="s1">jointName</span><span class="s2">))</span>
            <span class="s4">return None</span>
        <span class="s4">return </span><span class="s1">joint</span><span class="s2">.</span><span class="s1">getTransformState</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">controlJoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;The converse of exposeJoint: this associates the joint with 
        the indicated node, so that the joint transform will be copied 
        from the node to the joint each frame.  This can be used for 
        programmer animation of a particular joint at runtime. 
 
        The parameter node should be the NodePath for the node whose 
        transform will animate the joint.  If node is None, a new node 
        will automatically be created and loaded with the joint's 
        initial transform.  In either case, the node used will be 
        returned. 
 
        It used to be necessary to call this before any animations 
        have been loaded and bound, but that is no longer so. 
        &quot;&quot;&quot;</span>
        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s1">trueName </span><span class="s2">= </span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span>
        <span class="s1">anyGood </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">for </span><span class="s1">bundleDict </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s1">bundle </span><span class="s2">= </span><span class="s1">bundleDict</span><span class="s2">[</span><span class="s1">trueName</span><span class="s2">].</span><span class="s1">getBundle</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">node </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s1">node </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">attachNewNode</span><span class="s2">(</span><span class="s1">ModelNode</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">))</span>
                <span class="s1">joint </span><span class="s2">= </span><span class="s1">bundle</span><span class="s2">.</span><span class="s1">findChild</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">joint </span><span class="s4">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">joint</span><span class="s2">, </span><span class="s1">MovingPartMatrix</span><span class="s2">):</span>
                    <span class="s1">node</span><span class="s2">.</span><span class="s1">setMat</span><span class="s2">(</span><span class="s1">joint</span><span class="s2">.</span><span class="s1">getDefaultValue</span><span class="s2">())</span>

            <span class="s4">if </span><span class="s1">bundle</span><span class="s2">.</span><span class="s1">controlJoint</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">node</span><span class="s2">.</span><span class="s1">node</span><span class="s2">()):</span>
                <span class="s1">anyGood </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s4">if not </span><span class="s1">anyGood</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;Cannot control joint %s&quot; </span><span class="s2">% (</span><span class="s1">jointName</span><span class="s2">))</span>

        <span class="s4">return </span><span class="s1">node</span>

    <span class="s4">def </span><span class="s1">freezeJoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">transform </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                    <span class="s1">pos</span><span class="s2">=</span><span class="s1">Vec3</span><span class="s2">(</span><span class="s6">0</span><span class="s2">,</span><span class="s6">0</span><span class="s2">,</span><span class="s6">0</span><span class="s2">), </span><span class="s1">hpr</span><span class="s2">=</span><span class="s1">Vec3</span><span class="s2">(</span><span class="s6">0</span><span class="s2">,</span><span class="s6">0</span><span class="s2">,</span><span class="s6">0</span><span class="s2">), </span><span class="s1">scale</span><span class="s2">=</span><span class="s1">Vec3</span><span class="s2">(</span><span class="s6">1</span><span class="s2">,</span><span class="s6">1</span><span class="s2">,</span><span class="s6">1</span><span class="s2">)):</span>
        <span class="s0">&quot;&quot;&quot;Similar to controlJoint, but the transform assigned is 
        static, and may not be animated at runtime (without another 
        subsequent call to freezeJoint).  This is slightly more 
        optimal than controlJoint() for cases in which the transform 
        is not intended to be animated during the lifetime of the 
        Actor. &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">transform </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">transform </span><span class="s2">= </span><span class="s1">TransformState</span><span class="s2">.</span><span class="s1">makePosHprScale</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">, </span><span class="s1">hpr</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">)</span>

        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s1">trueName </span><span class="s2">= </span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span>
        <span class="s1">anyGood </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">for </span><span class="s1">bundleDict </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s4">if </span><span class="s1">bundleDict</span><span class="s2">[</span><span class="s1">trueName</span><span class="s2">].</span><span class="s1">getBundle</span><span class="s2">().</span><span class="s1">freezeJoint</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">):</span>
                <span class="s1">anyGood </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s4">if not </span><span class="s1">anyGood</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;Cannot freeze joint %s&quot; </span><span class="s2">% (</span><span class="s1">jointName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">releaseJoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Undoes a previous call to controlJoint() or freezeJoint() 
        and restores the named joint to its normal animation. &quot;&quot;&quot;</span>

        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s1">trueName </span><span class="s2">= </span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span>
        <span class="s4">for </span><span class="s1">bundleDict </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s1">bundleDict</span><span class="s2">[</span><span class="s1">trueName</span><span class="s2">].</span><span class="s1">getBundle</span><span class="s2">().</span><span class="s1">releaseJoint</span><span class="s2">(</span><span class="s1">jointName</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">instance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;instance(self, NodePath, string, string, key=&quot;lodRoot&quot;) 
        Instance a nodePath to an actor part at a joint called jointName&quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
            <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
                <span class="s1">joint </span><span class="s2">= </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">&quot;**/&quot; </span><span class="s2">+ </span><span class="s1">jointName</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">joint</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">()):</span>
                    <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;%s not found!&quot; </span><span class="s2">% (</span><span class="s1">jointName</span><span class="s2">))</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s4">return </span><span class="s1">path</span><span class="s2">.</span><span class="s1">instanceTo</span><span class="s2">(</span><span class="s1">joint</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named %s!&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">attach</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">anotherPartName</span><span class="s2">, </span><span class="s1">jointName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;attach(self, string, string, string, key=&quot;lodRoot&quot;) 
        Attach one actor part to another at a joint called jointName&quot;&quot;&quot;</span>
        <span class="s1">partBundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">partBundleDict</span><span class="s2">:</span>
            <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
            <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">partDef</span><span class="s2">:</span>
                <span class="s1">anotherPartDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">anotherPartName</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">anotherPartDef</span><span class="s2">:</span>
                    <span class="s1">joint </span><span class="s2">= </span><span class="s1">anotherPartDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">&quot;**/&quot; </span><span class="s2">+ </span><span class="s1">jointName</span><span class="s2">)</span>
                    <span class="s4">if </span><span class="s2">(</span><span class="s1">joint</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">()):</span>
                        <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;%s not found!&quot; </span><span class="s2">% (</span><span class="s1">jointName</span><span class="s2">))</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">reparentTo</span><span class="s2">(</span><span class="s1">joint</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">anotherPartName</span><span class="s2">))</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named %s!&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>


    <span class="s4">def </span><span class="s1">drawInFront</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">frontPartName</span><span class="s2">, </span><span class="s1">backPartName</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">,</span>
                    <span class="s1">root</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;drawInFront(self, string, int, string=None, key=None) 
 
        Arrange geometry so the frontPart(s) are drawn in front of 
        backPart. 
 
        If mode == -1, the geometry is simply arranged to be drawn in 
        the correct order, assuming it is already under a 
        direct-render scene graph (like the DirectGui system).  That 
        is, frontPart is reparented to backPart, and backPart is 
        reordered to appear first among its siblings. 
 
        If mode == -2, the geometry is arranged to be drawn in the 
        correct order, and depth test/write is turned off for 
        frontPart. 
 
        If mode == -3, frontPart is drawn as a decal onto backPart. 
        This assumes that frontPart is mostly coplanar with and does 
        not extend beyond backPart, and that backPart is mostly flat 
        (not self-occluding). 
 
        If mode &gt; 0, the frontPart geometry is placed in the 'fixed' 
        bin, with the indicated drawing order.  This will cause it to 
        be drawn after almost all other geometry.  In this case, the 
        backPartName is actually unused. 
 
        Takes an optional argument root as the start of the search for the 
        given parts. Also takes optional lod name to refine search for the 
        named parts. If root and lod are defined, we search for the given 
        root under the given lod. 
        &quot;&quot;&quot;</span>
        <span class="s5"># check to see if we are working within an lod</span>
        <span class="s4">if </span><span class="s1">lodName </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s5"># find the named lod node</span>
            <span class="s1">lodRoot </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">if </span><span class="s1">root </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s5"># no need to look further</span>
                <span class="s1">root </span><span class="s2">= </span><span class="s1">lodRoot</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s5"># look for root under lod</span>
                <span class="s1">root </span><span class="s2">= </span><span class="s1">lodRoot</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">&quot;**/&quot; </span><span class="s2">+ </span><span class="s1">root</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># start search from self if no root and no lod given</span>
            <span class="s4">if </span><span class="s1">root </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s1">root </span><span class="s2">= </span><span class="s1">self</span>

        <span class="s1">frontParts </span><span class="s2">= </span><span class="s1">root</span><span class="s2">.</span><span class="s1">findAllMatches</span><span class="s2">(</span><span class="s3">&quot;**/&quot; </span><span class="s2">+ </span><span class="s1">frontPartName</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">mode </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s5"># Use the 'fixed' bin instead of reordering the scene</span>
            <span class="s5"># graph.</span>
            <span class="s4">for </span><span class="s1">part </span><span class="s4">in </span><span class="s1">frontParts</span><span class="s2">:</span>
                <span class="s1">part</span><span class="s2">.</span><span class="s1">setBin</span><span class="s2">(</span><span class="s3">'fixed'</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">)</span>
            <span class="s4">return</span>

        <span class="s4">if </span><span class="s1">mode </span><span class="s2">== -</span><span class="s6">2</span><span class="s2">:</span>
            <span class="s5"># Turn off depth test/write on the frontParts.</span>
            <span class="s4">for </span><span class="s1">part </span><span class="s4">in </span><span class="s1">frontParts</span><span class="s2">:</span>
                <span class="s1">part</span><span class="s2">.</span><span class="s1">setDepthWrite</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
                <span class="s1">part</span><span class="s2">.</span><span class="s1">setDepthTest</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>

        <span class="s5"># Find the back part.</span>
        <span class="s1">backPart </span><span class="s2">= </span><span class="s1">root</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">&quot;**/&quot; </span><span class="s2">+ </span><span class="s1">backPartName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">backPart</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">()):</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no part named %s!&quot; </span><span class="s2">% (</span><span class="s1">backPartName</span><span class="s2">))</span>
            <span class="s4">return</span>

        <span class="s4">if </span><span class="s1">mode </span><span class="s2">== -</span><span class="s6">3</span><span class="s2">:</span>
            <span class="s5"># Draw as a decal.</span>
            <span class="s1">backPart</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">setEffect</span><span class="s2">(</span><span class="s1">DecalEffect</span><span class="s2">.</span><span class="s1">make</span><span class="s2">())</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Reorder the backPart to be the first of its siblings.</span>
            <span class="s1">backPart</span><span class="s2">.</span><span class="s1">reparentTo</span><span class="s2">(</span><span class="s1">backPart</span><span class="s2">.</span><span class="s1">getParent</span><span class="s2">(), -</span><span class="s6">1</span><span class="s2">)</span>

        <span class="s5">#reparent all the front parts to the back part</span>
        <span class="s1">frontParts</span><span class="s2">.</span><span class="s1">reparentTo</span><span class="s2">(</span><span class="s1">backPart</span><span class="s2">)</span>


    <span class="s4">def </span><span class="s1">fixBounds</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s4">if</span><span class="s2">(</span><span class="s1">partName </span><span class="s2">== </span><span class="s4">None</span><span class="s2">):</span>
            <span class="s5">#iterate through everything</span>
            <span class="s4">for </span><span class="s1">lodData </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                <span class="s4">for </span><span class="s1">partData </span><span class="s4">in </span><span class="s1">lodData</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                    <span class="s1">char </span><span class="s2">= </span><span class="s1">partData</span><span class="s2">.</span><span class="s1">partBundleNP</span>
                    <span class="s1">char</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">update</span><span class="s2">()</span>
                    <span class="s1">geomNodes </span><span class="s2">= </span><span class="s1">char</span><span class="s2">.</span><span class="s1">findAllMatches</span><span class="s2">(</span><span class="s3">&quot;**/+GeomNode&quot;</span><span class="s2">)</span>
                    <span class="s4">for </span><span class="s1">thisGeomNode </span><span class="s4">in </span><span class="s1">geomNodes</span><span class="s2">:</span>
                        <span class="s4">for </span><span class="s1">thisGeom </span><span class="s4">in </span><span class="s1">thisGeomNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getGeoms</span><span class="s2">():</span>
                            <span class="s1">thisGeom</span><span class="s2">.</span><span class="s1">markBoundsStale</span><span class="s2">()</span>
                        <span class="s1">thisGeomNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">markInternalBoundsStale</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5">#iterate through for a specific part</span>
            <span class="s4">for </span><span class="s1">lodData </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                <span class="s1">partData </span><span class="s2">= </span><span class="s1">lodData</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
                <span class="s4">if</span><span class="s2">(</span><span class="s1">partData</span><span class="s2">):</span>
                    <span class="s1">char </span><span class="s2">= </span><span class="s1">partData</span><span class="s2">.</span><span class="s1">partBundleNP</span>
                    <span class="s1">char</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">update</span><span class="s2">()</span>
                    <span class="s1">geomNodes </span><span class="s2">= </span><span class="s1">char</span><span class="s2">.</span><span class="s1">findAllMatches</span><span class="s2">(</span><span class="s3">&quot;**/+GeomNode&quot;</span><span class="s2">)</span>
                    <span class="s4">for </span><span class="s1">thisGeomNode </span><span class="s4">in </span><span class="s1">geomNodes</span><span class="s2">:</span>
                        <span class="s4">for </span><span class="s1">thisGeom </span><span class="s4">in </span><span class="s1">thisGeomNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getGeoms</span><span class="s2">():</span>
                            <span class="s1">thisGeom</span><span class="s2">.</span><span class="s1">markBoundsStale</span><span class="s2">()</span>
                        <span class="s1">thisGeomNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">markInternalBoundsStale</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">fixBounds_old</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">part</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;fixBounds(self, nodePath=None) 
        Force recomputation of bounding spheres for all geoms 
        in a given part. If no part specified, fix all geoms 
        in this actor 
        &quot;&quot;&quot;</span>
        <span class="s5"># if no part name specified fix all parts</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">part</span><span class="s2">==</span><span class="s4">None</span><span class="s2">):</span>
            <span class="s1">part </span><span class="s2">= </span><span class="s1">self</span>

        <span class="s5"># update all characters first</span>
        <span class="s1">charNodes </span><span class="s2">= </span><span class="s1">part</span><span class="s2">.</span><span class="s1">findAllMatches</span><span class="s2">(</span><span class="s3">&quot;**/+Character&quot;</span><span class="s2">)</span>
        <span class="s4">for </span><span class="s1">charNode </span><span class="s4">in </span><span class="s1">charNodes</span><span class="s2">:</span>
            <span class="s1">charNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">update</span><span class="s2">()</span>

        <span class="s5"># for each geomNode, iterate through all geoms and force update</span>
        <span class="s5"># of bounding spheres by marking current bounds as stale</span>
        <span class="s1">geomNodes </span><span class="s2">= </span><span class="s1">part</span><span class="s2">.</span><span class="s1">findAllMatches</span><span class="s2">(</span><span class="s3">&quot;**/+GeomNode&quot;</span><span class="s2">)</span>
        <span class="s4">for </span><span class="s1">nodeNum</span><span class="s2">, </span><span class="s1">thisGeomNode </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">geomNodes</span><span class="s2">):</span>
            <span class="s4">for </span><span class="s1">geomNum</span><span class="s2">, </span><span class="s1">thisGeom </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">thisGeomNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getGeoms</span><span class="s2">()):</span>
                <span class="s1">thisGeom</span><span class="s2">.</span><span class="s1">markBoundsStale</span><span class="s2">()</span>
                <span class="s4">assert </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;fixing bounds for node %s, geom %s&quot; </span><span class="s2">% </span><span class="s1">\</span>
                                          <span class="s2">(</span><span class="s1">nodeNum</span><span class="s2">, </span><span class="s1">geomNum</span><span class="s2">))</span>
            <span class="s1">thisGeomNode</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">markInternalBoundsStale</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">showAllBounds</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Show the bounds of all actor geoms 
        &quot;&quot;&quot;</span>
        <span class="s1">geomNodes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">.</span><span class="s1">findAllMatches</span><span class="s2">(</span><span class="s3">&quot;**/+GeomNode&quot;</span><span class="s2">)</span>

        <span class="s4">for </span><span class="s1">node </span><span class="s4">in </span><span class="s1">geomNodes</span><span class="s2">:</span>
            <span class="s1">node</span><span class="s2">.</span><span class="s1">showBounds</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">hideAllBounds</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Hide the bounds of all actor geoms 
        &quot;&quot;&quot;</span>
        <span class="s1">geomNodes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">.</span><span class="s1">findAllMatches</span><span class="s2">(</span><span class="s3">&quot;**/+GeomNode&quot;</span><span class="s2">)</span>

        <span class="s4">for </span><span class="s1">node </span><span class="s4">in </span><span class="s1">geomNodes</span><span class="s2">:</span>
            <span class="s1">node</span><span class="s2">.</span><span class="s1">hideBounds</span><span class="s2">()</span>


    <span class="s5"># actions</span>
    <span class="s4">def </span><span class="s1">animPanel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5"># Don't use a regular import, to prevent ModuleFinder from picking</span>
        <span class="s5"># it up as a dependency when building a .p3d package.</span>
        <span class="s4">import </span><span class="s1">importlib</span>
        <span class="s1">AnimPanel </span><span class="s2">= </span><span class="s1">importlib</span><span class="s2">.</span><span class="s1">import_module</span><span class="s2">(</span><span class="s3">'direct.tkpanels.AnimPanel'</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">AnimPanel</span><span class="s2">.</span><span class="s1">AnimPanel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">stop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;stop(self, string=None, string=None) 
        Stop named animation on the given part of the actor. 
        If no name specified then stop all animations on the actor. 
        NOTE: stops all LODs&quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">):</span>
            <span class="s1">control</span><span class="s2">.</span><span class="s1">stop</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">play</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">fromFrame</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">toFrame</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;play(self, string, string=None) 
        Play the given animation on the given part of the actor. 
        If no part is specified, try to play on all parts. NOTE: 
        plays over ALL LODs&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">fromFrame </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">):</span>
                <span class="s1">control</span><span class="s2">.</span><span class="s1">play</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">toFrame </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                    <span class="s1">control</span><span class="s2">.</span><span class="s1">play</span><span class="s2">(</span><span class="s1">fromFrame</span><span class="s2">, </span><span class="s1">control</span><span class="s2">.</span><span class="s1">getNumFrames</span><span class="s2">() - </span><span class="s6">1</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">control</span><span class="s2">.</span><span class="s1">play</span><span class="s2">(</span><span class="s1">fromFrame</span><span class="s2">, </span><span class="s1">toFrame</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">loop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">restart</span><span class="s2">=</span><span class="s6">1</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
             <span class="s1">fromFrame</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">toFrame</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;loop(self, string, int=1, string=None) 
        Loop the given animation on the given part of the actor, 
        restarting at zero frame if requested. If no part name 
        is given then try to loop on all parts. NOTE: loops on 
        all LOD's 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">fromFrame </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">):</span>
                <span class="s1">control</span><span class="s2">.</span><span class="s1">loop</span><span class="s2">(</span><span class="s1">restart</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">toFrame </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                    <span class="s1">control</span><span class="s2">.</span><span class="s1">loop</span><span class="s2">(</span><span class="s1">restart</span><span class="s2">, </span><span class="s1">fromFrame</span><span class="s2">, </span><span class="s1">control</span><span class="s2">.</span><span class="s1">getNumFrames</span><span class="s2">() - </span><span class="s6">1</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">control</span><span class="s2">.</span><span class="s1">loop</span><span class="s2">(</span><span class="s1">restart</span><span class="s2">, </span><span class="s1">fromFrame</span><span class="s2">, </span><span class="s1">toFrame</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">pingpong</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">restart</span><span class="s2">=</span><span class="s6">1</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">fromFrame</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">toFrame</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;pingpong(self, string, int=1, string=None) 
        Loop the given animation on the given part of the actor, 
        restarting at zero frame if requested. If no part name 
        is given then try to loop on all parts. NOTE: loops on 
        all LOD's&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">fromFrame </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">fromFrame </span><span class="s2">= </span><span class="s6">0</span>

        <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">toFrame </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s1">control</span><span class="s2">.</span><span class="s1">pingpong</span><span class="s2">(</span><span class="s1">restart</span><span class="s2">, </span><span class="s1">fromFrame</span><span class="s2">, </span><span class="s1">control</span><span class="s2">.</span><span class="s1">getNumFrames</span><span class="s2">() - </span><span class="s6">1</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">control</span><span class="s2">.</span><span class="s1">pingpong</span><span class="s2">(</span><span class="s1">restart</span><span class="s2">, </span><span class="s1">fromFrame</span><span class="s2">, </span><span class="s1">toFrame</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">pose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">frame</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;pose(self, string, int, string=None) 
        Pose the actor in position found at given frame in the specified 
        animation for the specified part. If no part is specified attempt 
        to apply pose to all parts.&quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">):</span>
            <span class="s1">control</span><span class="s2">.</span><span class="s1">pose</span><span class="s2">(</span><span class="s1">frame</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">setBlend</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animBlend </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">frameBlend </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">blendType </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Changes the way the Actor handles blending of multiple 
        different animations, and/or interpolation between consecutive 
        frames. 
 
        The animBlend and frameBlend parameters are boolean flags. 
        You may set either or both to True or False.  If you do not 
        specify them, they do not change from the previous value. 
 
        When animBlend is True, multiple different animations may 
        simultaneously be playing on the Actor.  This means you may 
        call play(), loop(), or pose() on multiple animations and have 
        all of them contribute to the final pose each frame. 
 
        In this mode (that is, when animBlend is True), starting a 
        particular animation with play(), loop(), or pose() does not 
        implicitly make the animation visible; you must also call 
        setControlEffect() for each animation you wish to use to 
        indicate how much each animation contributes to the final 
        pose. 
 
        The frameBlend flag is unrelated to playing multiple 
        animations.  It controls whether the Actor smoothly 
        interpolates between consecutive frames of its animation (when 
        the flag is True) or holds each frame until the next one is 
        ready (when the flag is False).  The default value of 
        frameBlend is controlled by the interpolate-frames Config.prc 
        variable. 
 
        In either case, you may also specify blendType, which controls 
        the precise algorithm used to blend two or more different 
        matrix values into a final result.  Different skeleton 
        hierarchies may benefit from different algorithms.  The 
        default blendType is controlled by the anim-blend-type 
        Config.prc variable. 
        &quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">bundle </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getPartBundles</span><span class="s2">(</span><span class="s1">partName </span><span class="s2">= </span><span class="s1">partName</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">blendType </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s1">bundle</span><span class="s2">.</span><span class="s1">setBlendType</span><span class="s2">(</span><span class="s1">blendType</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">animBlend </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s1">bundle</span><span class="s2">.</span><span class="s1">setAnimBlendFlag</span><span class="s2">(</span><span class="s1">animBlend</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">frameBlend </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s1">bundle</span><span class="s2">.</span><span class="s1">setFrameBlendFlag</span><span class="s2">(</span><span class="s1">frameBlend</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">enableBlend</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">blendType </span><span class="s2">= </span><span class="s1">PartBundle</span><span class="s2">.</span><span class="s1">BTNormalizedLinear</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Enables blending of multiple animations simultaneously. 
        After this is called, you may call play(), loop(), or pose() 
        on multiple animations and have all of them contribute to the 
        final pose each frame. 
 
        With blending in effect, starting a particular animation with 
        play(), loop(), or pose() does not implicitly make the 
        animation visible; you must also call setControlEffect() for 
        each animation you wish to use to indicate how much each 
        animation contributes to the final pose. 
 
        This method is deprecated.  You should use setBlend() instead. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">setBlend</span><span class="s2">(</span><span class="s1">animBlend </span><span class="s2">= </span><span class="s4">True</span><span class="s2">, </span><span class="s1">blendType </span><span class="s2">= </span><span class="s1">blendType</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s1">partName</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">disableBlend</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restores normal one-animation-at-a-time operation after a 
        previous call to enableBlend(). 
 
        This method is deprecated.  You should use setBlend() instead. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">setBlend</span><span class="s2">(</span><span class="s1">animBlend </span><span class="s2">= </span><span class="s4">False</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s1">partName</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">setControlEffect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">effect</span><span class="s2">,</span>
                         <span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sets the amount by which the named animation contributes to 
        the overall pose.  This controls blending of multiple 
        animations; it only makes sense to call this after a previous 
        call to setBlend(animBlend = True). 
        &quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">):</span>
            <span class="s1">control</span><span class="s2">.</span><span class="s1">getPart</span><span class="s2">().</span><span class="s1">setControlEffect</span><span class="s2">(</span><span class="s1">control</span><span class="s2">, </span><span class="s1">effect</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">getAnimFilename</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s3">'modelRoot'</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        getAnimFilename(self, animName) 
        return the animFilename given the animName 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">lodName </span><span class="s2">= </span><span class="s3">'common'</span>
        <span class="s4">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">:</span>
            <span class="s1">lodName </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">)))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lodName </span><span class="s2">= </span><span class="s3">'lodRoot'</span>

        <span class="s4">try</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">][</span><span class="s1">animName</span><span class="s2">].</span><span class="s1">filename</span>
        <span class="s4">except</span><span class="s2">:</span>
            <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">getAnimControl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        getAnimControl(self, string, string, string=&quot;lodRoot&quot;) 
        Search the animControl dictionary indicated by lodName for 
        a given anim and part. If none specified, try the first part and lod. 
        Return the animControl if present, or None otherwise. 
        &quot;&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">partName</span><span class="s2">:</span>
            <span class="s1">partName </span><span class="s2">= </span><span class="s3">'modelRoot'</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">lodName </span><span class="s2">= </span><span class="s3">'common'</span>
        <span class="s4">elif not </span><span class="s1">lodName</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">:</span>
                <span class="s1">lodName </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">)))</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">lodName </span><span class="s2">= </span><span class="s3">'lodRoot'</span>

        <span class="s1">partDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
        <span class="s5"># if this assertion fails, named lod was not present</span>
        <span class="s4">assert </span><span class="s1">partDict </span><span class="s2">!= </span><span class="s4">None</span>

        <span class="s1">animDict </span><span class="s2">= </span><span class="s1">partDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">animDict </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s5"># part was not present</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;couldn't find part: %s&quot; </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">anim </span><span class="s2">= </span><span class="s1">animDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">anim </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s5"># anim was not present</span>
                <span class="s4">assert </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;couldn't find anim: %s&quot; </span><span class="s2">% (</span><span class="s1">animName</span><span class="s2">))</span>
                <span class="s4">pass</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s5"># bind the animation first if we need to</span>
                <span class="s4">if not </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">__bindAnimToPart</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">,</span>
                                          <span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s1">allowAsyncBind</span><span class="s2">)</span>
                <span class="s4">elif not </span><span class="s1">allowAsyncBind</span><span class="s2">:</span>
                    <span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">waitPending</span><span class="s2">()</span>
                <span class="s4">return </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span>

        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                        <span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;getAnimControls(self, string, string=None, string=None) 
 
        Returns a list of the AnimControls that represent the given 
        animation for the given part and the given lod. 
 
        If animName is None or omitted, the currently-playing 
        animation (or all currently-playing animations) is returned. 
        If animName is True, all animations are returned.  If animName 
        is a single string name, that particular animation is 
        returned.  If animName is a list of string names, all of the 
        names animations are returned. 
 
        If partName is None or omitted, all parts are returned (or 
        possibly the one overall Actor part, according to the 
        subpartsComplete flag). 
 
        If lodName is None or omitted, all LOD's are returned. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">partName </span><span class="s2">== </span><span class="s4">None and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartsComplete</span><span class="s2">:</span>
            <span class="s5"># If we have the __subpartsComplete flag, and no partName</span>
            <span class="s5"># is specified, it really means to play the animation on</span>
            <span class="s5"># all subparts, not on the overall Actor.</span>
            <span class="s1">partName </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>

        <span class="s1">controls </span><span class="s2">= []</span>
        <span class="s5"># build list of lodNames and corresponding animControlDicts</span>
        <span class="s5"># requested.</span>
        <span class="s4">if </span><span class="s1">lodName </span><span class="s2">== </span><span class="s4">None or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s5"># Get all LOD's</span>
            <span class="s1">animControlDictItems </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">partDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">partDict </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;couldn't find lod: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
                <span class="s1">animControlDictItems </span><span class="s2">= []</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">animControlDictItems </span><span class="s2">= [(</span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">partDict</span><span class="s2">)]</span>

        <span class="s4">for </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">partDict </span><span class="s4">in </span><span class="s1">animControlDictItems</span><span class="s2">:</span>
            <span class="s5"># Now, build the list of partNames and the corresponding</span>
            <span class="s5"># animDicts.</span>
            <span class="s4">if </span><span class="s1">partName </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                <span class="s5"># Get all main parts, but not sub-parts.</span>
                <span class="s1">animDictItems </span><span class="s2">= []</span>
                <span class="s4">for </span><span class="s1">thisPart</span><span class="s2">, </span><span class="s1">animDict </span><span class="s4">in </span><span class="s1">partDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                    <span class="s4">if </span><span class="s1">thisPart </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">:</span>
                        <span class="s1">animDictItems</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">thisPart</span><span class="s2">, </span><span class="s1">animDict</span><span class="s2">))</span>

            <span class="s4">else</span><span class="s2">:</span>
                <span class="s5"># Get exactly the named part or parts.</span>
                <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                    <span class="s1">partNameList </span><span class="s2">= [</span><span class="s1">partName</span><span class="s2">]</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">partNameList </span><span class="s2">= </span><span class="s1">partName</span>

                <span class="s1">animDictItems </span><span class="s2">= []</span>

                <span class="s4">for </span><span class="s1">pName </span><span class="s4">in </span><span class="s1">partNameList</span><span class="s2">:</span>
                    <span class="s1">animDict </span><span class="s2">= </span><span class="s1">partDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">pName</span><span class="s2">)</span>
                    <span class="s4">if </span><span class="s1">animDict </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                        <span class="s5"># Maybe it's a subpart that hasn't been bound yet.</span>
                        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">pName</span><span class="s2">)</span>
                        <span class="s4">if </span><span class="s1">subpartDef</span><span class="s2">:</span>
                            <span class="s1">animDict </span><span class="s2">= {}</span>
                            <span class="s1">partDict</span><span class="s2">[</span><span class="s1">pName</span><span class="s2">] = </span><span class="s1">animDict</span>

                    <span class="s4">if </span><span class="s1">animDict </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                        <span class="s5"># part was not present</span>
                        <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;couldn't find part: %s&quot; </span><span class="s2">% (</span><span class="s1">pName</span><span class="s2">))</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">animDictItems</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">pName</span><span class="s2">, </span><span class="s1">animDict</span><span class="s2">))</span>

            <span class="s4">if </span><span class="s1">animName </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s5"># get all playing animations</span>
                <span class="s4">for </span><span class="s1">thisPart</span><span class="s2">, </span><span class="s1">animDict </span><span class="s4">in </span><span class="s1">animDictItems</span><span class="s2">:</span>
                    <span class="s4">for </span><span class="s1">anim </span><span class="s4">in </span><span class="s1">animDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
                        <span class="s4">if </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl </span><span class="s4">and </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">isPlaying</span><span class="s2">():</span>
                            <span class="s1">controls</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s5"># get the named animation(s) only.</span>
                <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                    <span class="s5"># A single animName</span>
                    <span class="s1">animNameList </span><span class="s2">= [</span><span class="s1">animName</span><span class="s2">]</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s5"># A list of animNames, or True to indicate all anims.</span>
                    <span class="s1">animNameList </span><span class="s2">= </span><span class="s1">animName</span>
                <span class="s4">for </span><span class="s1">thisPart</span><span class="s2">, </span><span class="s1">animDict </span><span class="s4">in </span><span class="s1">animDictItems</span><span class="s2">:</span>
                    <span class="s1">names </span><span class="s2">= </span><span class="s1">animNameList</span>
                    <span class="s4">if </span><span class="s1">animNameList </span><span class="s4">is True</span><span class="s2">:</span>
                        <span class="s1">names </span><span class="s2">= </span><span class="s1">animDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
                    <span class="s4">for </span><span class="s1">animName </span><span class="s4">in </span><span class="s1">names</span><span class="s2">:</span>
                        <span class="s1">anim </span><span class="s2">= </span><span class="s1">animDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">)</span>
                        <span class="s4">if </span><span class="s1">anim </span><span class="s2">== </span><span class="s4">None and </span><span class="s1">partName </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
                            <span class="s4">for </span><span class="s1">pName </span><span class="s4">in </span><span class="s1">partNameList</span><span class="s2">:</span>
                                <span class="s5"># Maybe it's a subpart that hasn't been bound yet.</span>
                                <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">pName</span><span class="s2">)</span>
                                <span class="s4">if </span><span class="s1">subpartDef</span><span class="s2">:</span>
                                    <span class="s1">truePartName </span><span class="s2">= </span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span>
                                    <span class="s1">anim </span><span class="s2">= </span><span class="s1">partDict</span><span class="s2">[</span><span class="s1">truePartName</span><span class="s2">].</span><span class="s1">get</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">)</span>
                                    <span class="s4">if </span><span class="s1">anim</span><span class="s2">:</span>
                                        <span class="s1">anim </span><span class="s2">= </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">makeCopy</span><span class="s2">()</span>
                                        <span class="s1">animDict</span><span class="s2">[</span><span class="s1">animName</span><span class="s2">] = </span><span class="s1">anim</span>

                        <span class="s4">if </span><span class="s1">anim </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                            <span class="s5"># anim was not present</span>
                            <span class="s4">assert </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;couldn't find anim: %s&quot; </span><span class="s2">% (</span><span class="s1">animName</span><span class="s2">))</span>
                            <span class="s4">pass</span>
                        <span class="s4">else</span><span class="s2">:</span>
                            <span class="s5"># bind the animation first if we need to</span>
                            <span class="s1">animControl </span><span class="s2">= </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span>
                            <span class="s4">if </span><span class="s1">animControl </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
                                <span class="s1">animControl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__bindAnimToPart</span><span class="s2">(</span>
                                    <span class="s1">animName</span><span class="s2">, </span><span class="s1">thisPart</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">,</span>
                                    <span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s1">allowAsyncBind</span><span class="s2">)</span>
                            <span class="s4">elif not </span><span class="s1">allowAsyncBind</span><span class="s2">:</span>
                                <span class="s5"># Force the animation to load if it's</span>
                                <span class="s5"># not already loaded.</span>
                                <span class="s1">animControl</span><span class="s2">.</span><span class="s1">waitPending</span><span class="s2">()</span>

                            <span class="s4">if </span><span class="s1">animControl</span><span class="s2">:</span>
                                <span class="s1">controls</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">animControl</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">controls</span>

    <span class="s4">def </span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s3">&quot;modelRoot&quot;</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">,</span>
                  <span class="s1">copy </span><span class="s2">= </span><span class="s4">True</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">autoBindAnims </span><span class="s2">= </span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Actor model loader. Takes a model name (ie file path), a part 
        name(defaults to &quot;modelRoot&quot;) and an lod name(defaults to &quot;lodRoot&quot;). 
        &quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">partName </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span>

        <span class="s4">assert </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;in loadModel: %s, part: %s, lod: %s, copy: %s&quot; </span><span class="s2">% </span><span class="s1">\</span>
                                  <span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">))</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">NodePath</span><span class="s2">):</span>
            <span class="s5"># If we got a NodePath instead of a string, use *that* as</span>
            <span class="s5"># the model directly.</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">copy</span><span class="s2">):</span>
                <span class="s1">model </span><span class="s2">= </span><span class="s1">modelPath</span><span class="s2">.</span><span class="s1">copyTo</span><span class="s2">(</span><span class="s1">NodePath</span><span class="s2">())</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">model </span><span class="s2">= </span><span class="s1">modelPath</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># otherwise, we got the name of the model to load.</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">modelLoaderOptions</span>
            <span class="s4">if not </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s5"># If copy = 0, then we should always hit the disk.</span>
                <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">)</span>
                <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() &amp; ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFNoRamCache</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">okMissing </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">okMissing</span><span class="s2">:</span>
                    <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() &amp; ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFReportErrors</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() | </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFReportErrors</span><span class="s2">)</span>

            <span class="s5"># Ensure that custom Python loader hooks are initialized.</span>
            <span class="s1">Loader</span><span class="s2">.</span><span class="s1">_loadPythonFileTypes</span><span class="s2">()</span>

            <span class="s5"># Pass loaderOptions to specify that we want to</span>
            <span class="s5"># get the skeleton model.  This only matters to model</span>
            <span class="s5"># files (like .mb) for which we can choose to extract</span>
            <span class="s5"># either the skeleton or animation, or neither.</span>
            <span class="s1">model </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">loadSync</span><span class="s2">(</span><span class="s1">Filename</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">), </span><span class="s1">loaderOptions</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">model </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">model </span><span class="s2">= </span><span class="s1">NodePath</span><span class="s2">(</span><span class="s1">model</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s1">model </span><span class="s2">== </span><span class="s4">None</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">IOError</span><span class="s2">(</span><span class="s3">&quot;Could not load Actor model %s&quot; </span><span class="s2">% (</span><span class="s1">modelPath</span><span class="s2">))</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">isOfType</span><span class="s2">(</span><span class="s1">Character</span><span class="s2">.</span><span class="s1">getClassType</span><span class="s2">())):</span>
            <span class="s1">bundleNP </span><span class="s2">= </span><span class="s1">model</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">bundleNP </span><span class="s2">= </span><span class="s1">model</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">&quot;**/+Character&quot;</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s1">bundleNP</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">()):</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;%s is not a character!&quot; </span><span class="s2">% (</span><span class="s1">modelPath</span><span class="s2">))</span>
            <span class="s1">model</span><span class="s2">.</span><span class="s1">reparentTo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Maybe the model file also included some animations.  If</span>
            <span class="s5"># so, try to bind them immediately and put them into the</span>
            <span class="s5"># animControlDict.</span>
            <span class="s4">if </span><span class="s1">autoBindAnims</span><span class="s2">:</span>
                <span class="s1">acc </span><span class="s2">= </span><span class="s1">AnimControlCollection</span><span class="s2">()</span>
                <span class="s1">autoBind</span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(), </span><span class="s1">acc</span><span class="s2">, ~</span><span class="s6">0</span><span class="s2">)</span>
                <span class="s1">numAnims </span><span class="s2">= </span><span class="s1">acc</span><span class="s2">.</span><span class="s1">getNumAnims</span><span class="s2">()</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">numAnims </span><span class="s2">= </span><span class="s6">0</span>

            <span class="s5"># Now extract out the Character and integrate it with</span>
            <span class="s5"># the Actor.</span>

            <span class="s4">if </span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">!=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
                <span class="s5"># parent to appropriate node under LOD switch</span>
                <span class="s1">bundleNP</span><span class="s2">.</span><span class="s1">reparentTo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">)))</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">bundleNP</span><span class="s2">.</span><span class="s1">reparentTo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__geomNode</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__prepareBundle</span><span class="s2">(</span><span class="s1">bundleNP</span><span class="s2">, </span><span class="s1">model</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(), </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">)</span>

            <span class="s5"># we rename this node to make Actor copying easier</span>
            <span class="s1">bundleNP</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">setName</span><span class="s2">(</span><span class="s3">&quot;%s%s&quot;</span><span class="s2">%(</span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">partPrefix</span><span class="s2">,</span><span class="s1">partName</span><span class="s2">))</span>

            <span class="s4">if </span><span class="s1">numAnims </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s5"># If the model had some animations, store them in the</span>
                <span class="s5"># dict so they can be played.</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">info</span><span class="s2">(</span><span class="s3">&quot;model contains %s animations.&quot; </span><span class="s2">% (</span><span class="s1">numAnims</span><span class="s2">))</span>

                <span class="s5"># make sure this lod is in anim control dict</span>
                <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
                    <span class="s1">lodName </span><span class="s2">= </span><span class="s3">'common'</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">, {})</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">].</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, {})</span>

                <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">numAnims</span><span class="s2">):</span>
                    <span class="s1">animControl </span><span class="s2">= </span><span class="s1">acc</span><span class="s2">.</span><span class="s1">getAnim</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
                    <span class="s1">animName </span><span class="s2">= </span><span class="s1">acc</span><span class="s2">.</span><span class="s1">getAnimName</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>

                    <span class="s1">animDef </span><span class="s2">= </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">AnimDef</span><span class="s2">()</span>
                    <span class="s1">animDef</span><span class="s2">.</span><span class="s1">animBundle </span><span class="s2">= </span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">getAnim</span><span class="s2">()</span>
                    <span class="s1">animDef</span><span class="s2">.</span><span class="s1">animControl </span><span class="s2">= </span><span class="s1">animControl</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">][</span><span class="s1">animName</span><span class="s2">] = </span><span class="s1">animDef</span>

    <span class="s4">def </span><span class="s1">__prepareBundle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">bundleNP</span><span class="s2">, </span><span class="s1">partModel</span><span class="s2">,</span>
                        <span class="s1">partName</span><span class="s2">=</span><span class="s3">&quot;modelRoot&quot;</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s4">assert </span><span class="s1">partName </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span>

        <span class="s5"># Rename the node at the top of the hierarchy, if we</span>
        <span class="s5"># haven't already, to make it easier to identify this</span>
        <span class="s5"># actor in the scene graph.</span>
        <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gotName</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">setName</span><span class="s2">(</span><span class="s1">bundleNP</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getName</span><span class="s2">())</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">gotName </span><span class="s2">= </span><span class="s6">1</span>

        <span class="s1">bundleDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">bundleDict </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s5"># make a dictionary to store these parts in</span>
            <span class="s1">bundleDict </span><span class="s2">= {}</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">] = </span><span class="s1">bundleDict</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__updateSortedLODNames</span><span class="s2">()</span>

        <span class="s1">node </span><span class="s2">= </span><span class="s1">bundleNP</span><span class="s2">.</span><span class="s1">node</span><span class="s2">()</span>
        <span class="s5"># A model loaded from disk will always have just one bundle.</span>
        <span class="s4">assert</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">getNumBundles</span><span class="s2">() == </span><span class="s6">1</span><span class="s2">)</span>
        <span class="s1">bundleHandle </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">getBundleHandle</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">loadedBundleHandle </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">loadedBundleHandle</span><span class="s2">:</span>
                <span class="s5"># We've already got a bundle for this part; merge it.</span>
                <span class="s1">node</span><span class="s2">.</span><span class="s1">mergeBundles</span><span class="s2">(</span><span class="s1">bundleHandle</span><span class="s2">, </span><span class="s1">loadedBundleHandle</span><span class="s2">)</span>
                <span class="s1">bundleHandle </span><span class="s2">= </span><span class="s1">loadedBundleHandle</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s5"># We haven't already got a bundle for this part; store it.</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">] = </span><span class="s1">bundleHandle</span>

        <span class="s1">bundleDict</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">] = </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">PartDef</span><span class="s2">(</span><span class="s1">bundleNP</span><span class="s2">, </span><span class="s1">bundleHandle</span><span class="s2">, </span><span class="s1">partModel</span><span class="s2">)</span>


    <span class="s4">def </span><span class="s1">makeSubpart</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">includeJoints</span><span class="s2">, </span><span class="s1">excludeJoints </span><span class="s2">= [],</span>
                    <span class="s1">parent</span><span class="s2">=</span><span class="s3">&quot;modelRoot&quot;</span><span class="s2">, </span><span class="s1">overlapping </span><span class="s2">= </span><span class="s4">False</span><span class="s2">):</span>

        <span class="s0">&quot;&quot;&quot;Defines a new &quot;part&quot; of the Actor that corresponds to the 
        same geometry as the named parent part, but animates only a 
        certain subset of the joints.  This can be used for 
        partial-body animations, for instance to animate a hand waving 
        while the rest of the body continues to play its walking 
        animation. 
 
        includeJoints is a list of joint names that are to be animated 
        by the subpart.  Each name can include globbing characters 
        like '?' or '*', which will match one or any number of 
        characters, respectively.  Including a joint by naming it in 
        includeJoints implicitly includes all of the descendents of 
        that joint as well, except for excludeJoints, below. 
 
        excludeJoints is a list of joint names that are *not* to be 
        animated by the subpart.  As in includeJoints, each name can 
        include globbing characters.  If a joint is named by 
        excludeJoints, it will not be included (and neither will any 
        of its descendents), even if a parent joint was named by 
        includeJoints. 
 
        if overlapping is False, an error is raised (in the dev build) 
        if this subpart shares joints with any other subparts.  If 
        overlapping is True, no such error is raised. 
 
        parent is the actual partName that this subpart is based 
        on.&quot;&quot;&quot;</span>

        <span class="s4">assert </span><span class="s1">partName </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span>

        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s3">''</span><span class="s2">))</span>

        <span class="s1">subset </span><span class="s2">= </span><span class="s1">PartSubset</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">subset</span><span class="s2">)</span>
        <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">includeJoints</span><span class="s2">:</span>
            <span class="s1">subset</span><span class="s2">.</span><span class="s1">addIncludeJoint</span><span class="s2">(</span><span class="s1">GlobPattern</span><span class="s2">(</span><span class="s1">name</span><span class="s2">))</span>
        <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">excludeJoints</span><span class="s2">:</span>
            <span class="s1">subset</span><span class="s2">.</span><span class="s1">addExcludeJoint</span><span class="s2">(</span><span class="s1">GlobPattern</span><span class="s2">(</span><span class="s1">name</span><span class="s2">))</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">] = </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">__dev__ </span><span class="s4">and not </span><span class="s1">overlapping </span><span class="s4">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">validateSubparts</span><span class="s2">.</span><span class="s1">getValue</span><span class="s2">():</span>
            <span class="s5"># Without the overlapping flag True, we're not allowed to</span>
            <span class="s5"># define overlapping sub-parts.  Verify that we haven't.</span>
            <span class="s4">for </span><span class="s1">otherPartName</span><span class="s2">, </span><span class="s1">otherPartDef </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s4">if </span><span class="s1">otherPartName </span><span class="s2">!= </span><span class="s1">partName </span><span class="s4">and </span><span class="s1">otherPartDef</span><span class="s2">.</span><span class="s1">truePartName </span><span class="s2">== </span><span class="s1">parent</span><span class="s2">:</span>
                    <span class="s1">joints </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getOverlappingJoints</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">otherPartName</span><span class="s2">)</span>
                    <span class="s4">if </span><span class="s1">joints</span><span class="s2">:</span>
                        <span class="s4">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s3">'Overlapping joints: %s and %s' </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">otherPartName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">setSubpartsComplete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">):</span>

        <span class="s0">&quot;&quot;&quot;Sets the subpartsComplete flag.  This affects the behavior 
        of play(), loop(), stop(), etc., when no explicit parts are 
        specified. 
 
        When this flag is False (the default), play() with no parts 
        means to play the animation on the overall Actor, which is a 
        separate part that overlaps each of the subparts.  If you then 
        play a different animation on a subpart, it may stop the 
        overall animation (in non-blend mode) or blend with it (in 
        blend mode). 
 
        When this flag is True, play() with no parts means to play the 
        animation on each of the subparts--instead of on the overall 
        Actor.  In this case, you may then play a different animation 
        on a subpart, which replaces only that subpart's animation. 
 
        It makes sense to set this True when the union of all of your 
        subparts completely defines the entire Actor. 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartsComplete </span><span class="s2">= </span><span class="s1">flag</span>

        <span class="s4">if </span><span class="s1">__dev__ </span><span class="s4">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartsComplete </span><span class="s4">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">validateSubparts</span><span class="s2">.</span><span class="s1">getValue</span><span class="s2">():</span>
            <span class="s5"># If we've specified any parts at all so far, make sure we've</span>
            <span class="s5"># specified all of them.</span>
            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">verifySubpartsComplete</span><span class="s2">()</span>


    <span class="s4">def </span><span class="s1">getSubpartsComplete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;See setSubpartsComplete().&quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartsComplete</span>

    <span class="s4">def </span><span class="s1">verifySubpartsComplete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Ensures that each joint is defined by at least one 
        subPart.  Prints a warning if this is not the case. &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">partName</span><span class="s2">:</span>
            <span class="s4">assert </span><span class="s1">partName </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span>
            <span class="s1">partNames </span><span class="s2">= [</span><span class="s1">partName</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">lodName</span><span class="s2">:</span>
                <span class="s1">partNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">].</span><span class="s1">keys</span><span class="s2">()</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">partNames </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())).</span><span class="s1">keys</span><span class="s2">()</span>

        <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">partNames</span><span class="s2">:</span>
            <span class="s1">subJoints </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s4">for </span><span class="s1">subPartName</span><span class="s2">, </span><span class="s1">subPartDef </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s4">if </span><span class="s1">subPartName </span><span class="s2">!= </span><span class="s1">partName </span><span class="s4">and </span><span class="s1">subPartDef</span><span class="s2">.</span><span class="s1">truePartName </span><span class="s2">== </span><span class="s1">partName</span><span class="s2">:</span>
                    <span class="s1">subJoints </span><span class="s2">|= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">getJoints</span><span class="s2">(</span><span class="s1">partName </span><span class="s2">= </span><span class="s1">subPartName</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s1">lodName</span><span class="s2">))</span>

            <span class="s1">allJoints </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">getJoints</span><span class="s2">(</span><span class="s1">partName </span><span class="s2">= </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s1">diff </span><span class="s2">= </span><span class="s1">allJoints</span><span class="s2">.</span><span class="s1">difference</span><span class="s2">(</span><span class="s1">subJoints</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">diff</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">'Uncovered joints: %s' </span><span class="s2">% (</span><span class="s1">list</span><span class="s2">(</span><span class="s1">diff</span><span class="s2">)))</span>

    <span class="s4">def </span><span class="s1">loadAnims</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">anims</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s3">&quot;modelRoot&quot;</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s3">&quot;lodRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;loadAnims(self, string:string{}, string='modelRoot', 
        string='lodRoot') 
        Actor anim loader. Takes an optional partName (defaults to 
        'modelRoot' for non-multipart actors) and lodName (defaults 
        to 'lodRoot' for non-LOD actors) and dict of corresponding 
        anims in the form animName:animPath{} 
        &quot;&quot;&quot;</span>
        <span class="s1">reload </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= [</span><span class="s3">'common'</span><span class="s2">]</span>
        <span class="s4">elif </span><span class="s1">lodName </span><span class="s2">== </span><span class="s3">'all'</span><span class="s2">:</span>
            <span class="s1">reload </span><span class="s2">= </span><span class="s4">False</span>
            <span class="s1">lodNames </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">switches</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
            <span class="s1">lodNames</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
            <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">lodNames</span><span class="s2">)):</span>
                <span class="s1">lodNames</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodNames</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= [</span><span class="s1">lodName</span><span class="s2">]</span>

        <span class="s4">assert </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;in loadAnims: %s, part: %s, lod: %s&quot; </span><span class="s2">%</span>
                                  <span class="s2">(</span><span class="s1">anims</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodNames</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]))</span>

        <span class="s1">firstLoad </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s4">if not </span><span class="s1">reload</span><span class="s2">:</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodNames</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]][</span><span class="s1">partName</span><span class="s2">]</span>
                <span class="s1">firstLoad </span><span class="s2">= </span><span class="s4">False</span>
            <span class="s4">except</span><span class="s2">:</span>
                <span class="s4">pass</span>
        <span class="s4">for </span><span class="s1">lName </span><span class="s4">in </span><span class="s1">lodNames</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">firstLoad</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">lName</span><span class="s2">, {})</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lName</span><span class="s2">].</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, {})</span>

        <span class="s4">for </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">filename </span><span class="s4">in </span><span class="s1">anims</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s5"># make sure this lod is in anim control dict</span>
            <span class="s4">for </span><span class="s1">lName </span><span class="s4">in </span><span class="s1">lodNames</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">firstLoad</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">][</span><span class="s1">animName</span><span class="s2">] = </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">AnimDef</span><span class="s2">()</span>

                <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">filename</span><span class="s2">, </span><span class="s1">NodePath</span><span class="s2">):</span>
                    <span class="s5"># We were given a pre-load anim bundle, not a filename.</span>
                    <span class="s4">assert not </span><span class="s1">filename</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">()</span>
                    <span class="s4">if </span><span class="s1">filename</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">isOfType</span><span class="s2">(</span><span class="s1">AnimBundleNode</span><span class="s2">.</span><span class="s1">getClassType</span><span class="s2">()):</span>
                        <span class="s1">animBundleNP </span><span class="s2">= </span><span class="s1">filename</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">animBundleNP </span><span class="s2">= </span><span class="s1">filename</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">'**/+AnimBundleNode'</span><span class="s2">)</span>
                    <span class="s4">assert not </span><span class="s1">animBundleNP</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">()</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">][</span><span class="s1">animName</span><span class="s2">].</span><span class="s1">animBundle </span><span class="s2">= </span><span class="s1">animBundleNP</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getBundle</span><span class="s2">()</span>

                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s5"># We were given a filename that must be loaded.</span>
                    <span class="s5"># Store the filename only; we will load and bind</span>
                    <span class="s5"># it (and produce an AnimControl) when it is</span>
                    <span class="s5"># played.</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">][</span><span class="s1">animName</span><span class="s2">].</span><span class="s1">filename </span><span class="s2">= </span><span class="s1">filename</span>

    <span class="s4">def </span><span class="s1">initAnimsOnAllLODs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">,</span><span class="s1">partNames</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= [</span><span class="s3">'common'</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>

        <span class="s4">for </span><span class="s1">lod </span><span class="s4">in </span><span class="s1">lodNames</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">part </span><span class="s4">in </span><span class="s1">partNames</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">lod</span><span class="s2">,{})</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lod</span><span class="s2">].</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">part</span><span class="s2">, {})</span>

        <span class="s5">#for animName, filename in anims.items():</span>
        <span class="s5">#    # make sure this lod is in anim control dict</span>
        <span class="s5">#    for lod in self.__partBundleDict.keys():</span>
        <span class="s5">#        # store the file path only; we will bind it (and produce</span>
        <span class="s5">#        # an AnimControl) when it is played</span>
        <span class="s5">#</span>
        <span class="s5">#        self.__animControlDict[lod][partName][animName] = Actor.AnimDef(filename)</span>

    <span class="s4">def </span><span class="s1">loadAnimsOnAllLODs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">anims</span><span class="s2">,</span><span class="s1">partName</span><span class="s2">=</span><span class="s3">&quot;modelRoot&quot;</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;loadAnims(self, string:string{}, string='modelRoot', 
        string='lodRoot') 
        Actor anim loader. Takes an optional partName (defaults to 
        'modelRoot' for non-multipart actors) and lodName (defaults 
        to 'lodRoot' for non-LOD actors) and dict of corresponding 
        anims in the form animName:animPath{} 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= [</span><span class="s3">'common'</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>

        <span class="s4">for </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">filename </span><span class="s4">in </span><span class="s1">anims</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s5"># make sure this lod is in anim control dict</span>
            <span class="s4">for </span><span class="s1">lod </span><span class="s4">in </span><span class="s1">lodNames</span><span class="s2">:</span>
                <span class="s5"># store the file path only; we will bind it (and produce</span>
                <span class="s5"># an AnimControl) when it is played</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lod</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">][</span><span class="s1">animName</span><span class="s2">]= </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">AnimDef</span><span class="s2">(</span><span class="s1">filename</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">postFlatten</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Call this after performing an aggressive flatten operation, 
        such as flattenStrong(), that involves the Actor.  This is 
        especially necessary when mergeLODBundles is true, since this 
        kind of actor may be broken after a flatten operation; this 
        method should restore proper Actor functionality. &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s5"># Re-merge all bundles, and restore the common bundle map.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles </span><span class="s2">= {}</span>
            <span class="s4">for </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">bundleDict </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s4">for </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">partDef </span><span class="s4">in </span><span class="s1">bundleDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                    <span class="s1">loadedBundleHandle </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
                    <span class="s1">node </span><span class="s2">= </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">node</span><span class="s2">()</span>
                    <span class="s4">if </span><span class="s1">loadedBundleHandle</span><span class="s2">:</span>
                        <span class="s1">node</span><span class="s2">.</span><span class="s1">mergeBundles</span><span class="s2">(</span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleHandle</span><span class="s2">, </span><span class="s1">loadedBundleHandle</span><span class="s2">)</span>
                        <span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleHandle </span><span class="s2">= </span><span class="s1">loadedBundleHandle</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">] = </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleHandle</span>

        <span class="s5"># Since we may have merged together some bundles, all of</span>
        <span class="s5"># our anims are now suspect.  Force them to reload.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">unloadAnims</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">unloadAnims</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">anims</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;unloadAnims(self, string:string{}, string='modelRoot', 
        string='lodRoot') 
        Actor anim unloader. Takes an optional partName (defaults to 
        'modelRoot' for non-multipart actors) and lodName (defaults to 
        'lodRoot' for non-LOD actors) and list of animation 
        names. Deletes the anim control for the given animation and 
        parts/lods. 
 
        If any parameter is None or omitted, it means all of them. 
        &quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;in unloadAnims: %s, part: %s, lod: %s&quot; </span><span class="s2">%</span>
                                  <span class="s2">(</span><span class="s1">anims</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">))</span>

        <span class="s4">if </span><span class="s1">lodName </span><span class="s4">is None or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= [</span><span class="s1">lodName</span><span class="s2">]</span>

        <span class="s4">if </span><span class="s1">partName </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">lodNames</span><span class="s2">) &gt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">partNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">lodNames</span><span class="s2">))].</span><span class="s1">keys</span><span class="s2">()</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">partNames </span><span class="s2">= []</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">partNames </span><span class="s2">= [</span><span class="s1">partName</span><span class="s2">]</span>

        <span class="s4">if </span><span class="s1">anims </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">lodNames</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">partNames</span><span class="s2">:</span>
                    <span class="s4">for </span><span class="s1">animDef </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">].</span><span class="s1">values</span><span class="s2">():</span>
                        <span class="s4">if </span><span class="s1">animDef</span><span class="s2">.</span><span class="s1">animControl </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
                            <span class="s5"># Try to clear any control effects before we let</span>
                            <span class="s5"># our handle on them go. This is especially</span>
                            <span class="s5"># important if the anim control was blending</span>
                            <span class="s5"># animations.</span>
                            <span class="s1">animDef</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">getPart</span><span class="s2">().</span><span class="s1">clearControlEffects</span><span class="s2">()</span>
                            <span class="s1">animDef</span><span class="s2">.</span><span class="s1">animControl </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">lodNames</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">partNames</span><span class="s2">:</span>
                    <span class="s4">for </span><span class="s1">anim </span><span class="s4">in </span><span class="s1">anims</span><span class="s2">:</span>
                        <span class="s1">animDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">].</span><span class="s1">get</span><span class="s2">(</span><span class="s1">anim</span><span class="s2">)</span>
                        <span class="s4">if </span><span class="s1">animDef </span><span class="s4">and </span><span class="s1">animDef</span><span class="s2">.</span><span class="s1">animControl </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">:</span>
                            <span class="s5"># Try to clear any control effects before we let</span>
                            <span class="s5"># our handle on them go. This is especially</span>
                            <span class="s5"># important if the anim control was blending</span>
                            <span class="s5"># animations.</span>
                            <span class="s1">animDef</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">.</span><span class="s1">getPart</span><span class="s2">().</span><span class="s1">setControlEffect</span><span class="s2">(</span><span class="s1">animDef</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">, </span><span class="s6">0.0</span><span class="s2">)</span>
                            <span class="s1">animDef</span><span class="s2">.</span><span class="s1">animControl </span><span class="s2">= </span><span class="s4">None</span>


    <span class="s4">def </span><span class="s1">bindAnim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s4">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Binds the named animation to the named part and/or lod.  If 
        allowAsyncBind is False, this guarantees that the animation is 
        bound immediately--the animation is never bound in a 
        sub-thread; it will be loaded and bound in the main thread, so 
        it will be available by the time this method returns. 
 
        The parameters are the same as that for getAnimControls().  In 
        fact, this method is a thin wrapper around that other method. 
 
        Use this method if you need to ensure that an animation is 
        available before you start to play it, and you don't mind 
        holding up the render for a frame or two until the animation 
        is available. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName </span><span class="s2">= </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s1">partName</span><span class="s2">,</span>
                             <span class="s1">lodName </span><span class="s2">= </span><span class="s1">lodName</span><span class="s2">,</span>
                             <span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s1">allowAsyncBind</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">bindAllAnims</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s4">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Loads and binds all animations that have been defined for 
        the Actor. &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName </span><span class="s2">= </span><span class="s4">True</span><span class="s2">, </span><span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s1">allowAsyncBind</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">waitPending</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Blocks until all asynchronously pending animations (that 
        are currently playing) have been loaded and bound the the 
        Actor.  Call this after calling play() if you are using 
        asynchronous binds, but you need this particular animation 
        to be loaded immediately. &quot;&quot;&quot;</span>

        <span class="s4">for </span><span class="s1">bundle </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getPartBundles</span><span class="s2">(</span><span class="s1">partName </span><span class="s2">= </span><span class="s1">partName</span><span class="s2">):</span>
            <span class="s1">bundle</span><span class="s2">.</span><span class="s1">waitPending</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">__bindAnimToPart</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">,</span>
                         <span class="s1">allowAsyncBind </span><span class="s2">= </span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Binds the named animation to the named part/lod and returns 
        the associated animControl.  The animation is loaded and bound 
        in a sub-thread, if allowAsyncBind is True, 
        self.allowAsyncBind is True, threading is enabled, and the 
        animation has a preload table generated for it (e.g. via 
        &quot;egg-optchar -preload&quot;).  Even though the animation may or may 
        not be yet bound at the time this function returns, a usable 
        animControl is returned, or None if the animation could not be 
        bound. 
        &quot;&quot;&quot;</span>
        <span class="s5"># make sure this anim is in the dict</span>
        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>

        <span class="s1">partDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">]</span>
        <span class="s1">animDict </span><span class="s2">= </span><span class="s1">partDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">animDict </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s5"># It must be a subpart that hasn't been bound yet.</span>
            <span class="s1">animDict </span><span class="s2">= {}</span>
            <span class="s1">partDict</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">] = </span><span class="s1">animDict</span>

        <span class="s1">anim </span><span class="s2">= </span><span class="s1">animDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">anim </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s5"># It must be a subpart that hasn't been bound yet.</span>
            <span class="s1">anim </span><span class="s2">= </span><span class="s1">partDict</span><span class="s2">[</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">].</span><span class="s1">get</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">)</span>
            <span class="s1">anim </span><span class="s2">= </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">makeCopy</span><span class="s2">()</span>
            <span class="s1">animDict</span><span class="s2">[</span><span class="s1">animName</span><span class="s2">] = </span><span class="s1">anim</span>

        <span class="s4">if </span><span class="s1">anim </span><span class="s2">== </span><span class="s4">None</span><span class="s2">:</span>
            <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">error</span><span class="s2">(</span><span class="s3">&quot;actor has no animation %s&quot;</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">)</span>

        <span class="s5"># only bind if not already bound!</span>
        <span class="s4">if </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
            <span class="s1">bundle </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__commonBundleHandles</span><span class="s2">[</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">].</span><span class="s1">getBundle</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">bundle </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">].</span><span class="s1">getBundle</span><span class="s2">()</span>

        <span class="s4">if </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animBundle</span><span class="s2">:</span>
            <span class="s5"># We already have a bundle; just bind it.</span>
            <span class="s1">animControl </span><span class="s2">= </span><span class="s1">bundle</span><span class="s2">.</span><span class="s1">bindAnim</span><span class="s2">(</span><span class="s1">anim</span><span class="s2">.</span><span class="s1">animBundle</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">, </span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">subset</span><span class="s2">)</span>

        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Load and bind the anim.  This might be an asynchronous</span>
            <span class="s5"># operation that will complete in the background, but if so it</span>
            <span class="s5"># will still return a usable AnimControl.</span>
            <span class="s1">animControl </span><span class="s2">= </span><span class="s1">bundle</span><span class="s2">.</span><span class="s1">loadBindAnim</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">, </span><span class="s1">Filename</span><span class="s2">(</span><span class="s1">anim</span><span class="s2">.</span><span class="s1">filename</span><span class="s2">), -</span><span class="s6">1</span><span class="s2">,</span>
                <span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">subset</span><span class="s2">, </span><span class="s1">allowAsyncBind </span><span class="s4">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">allowAsyncBind</span><span class="s2">)</span>

        <span class="s4">if not </span><span class="s1">animControl</span><span class="s2">:</span>
            <span class="s5"># Couldn't bind.  (This implies the binding operation was</span>
            <span class="s5"># not attempted asynchronously.)</span>
            <span class="s4">return None</span>

        <span class="s5"># store the animControl</span>
        <span class="s1">anim</span><span class="s2">.</span><span class="s1">animControl </span><span class="s2">= </span><span class="s1">animControl</span>
        <span class="s4">assert </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;binding anim: %s to part: %s, lod: %s&quot; </span><span class="s2">%</span>
                                  <span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">))</span>
        <span class="s4">return </span><span class="s1">animControl</span>

    <span class="s4">def </span><span class="s1">__copyPartBundles</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;__copyPartBundles(self, Actor) 
        Copy the part bundle dictionary from another actor as this 
        instance's own. NOTE: this method does not actually copy geometry 
        &quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">:</span>
            <span class="s5"># find the lod Asad</span>
            <span class="s4">if </span><span class="s1">lodName </span><span class="s2">== </span><span class="s3">'lodRoot'</span><span class="s2">:</span>
                <span class="s1">partLod </span><span class="s2">= </span><span class="s1">self</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">partLod </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__LODNode</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">if </span><span class="s1">partLod</span><span class="s2">.</span><span class="s1">isEmpty</span><span class="s2">():</span>
                <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;no lod named: %s&quot; </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
                <span class="s4">return None</span>
            <span class="s4">for </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">partDef </span><span class="s4">in </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">].</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s5"># We can really only copy from a non-flattened avatar.</span>
                <span class="s4">assert </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">partBundleNP</span><span class="s2">.</span><span class="s1">node</span><span class="s2">().</span><span class="s1">getNumBundles</span><span class="s2">() == </span><span class="s6">1</span>

                <span class="s5"># find the part in our tree</span>
                <span class="s1">bundleNP </span><span class="s2">= </span><span class="s1">partLod</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s3">&quot;**/%s%s&quot;</span><span class="s2">%(</span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">partPrefix</span><span class="s2">,</span><span class="s1">partName</span><span class="s2">))</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">bundleNP </span><span class="s2">!= </span><span class="s4">None</span><span class="s2">):</span>
                    <span class="s5"># store the part bundle</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">__prepareBundle</span><span class="s2">(</span><span class="s1">bundleNP</span><span class="s2">, </span><span class="s1">partDef</span><span class="s2">.</span><span class="s1">partModel</span><span class="s2">,</span>
                                         <span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">Actor</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">error</span><span class="s2">(</span><span class="s3">&quot;lod: %s has no matching part: %s&quot; </span><span class="s2">%</span>
                                       <span class="s2">(</span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__copySubpartDict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Copies the subpartDict from another as this instance's own. 
        This makes a deep copy of the map and all of the names and 
        PartSubset objects within it.  We can't use copy.deepcopy() 
        because of the included C++ PartSubset objects.&quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict </span><span class="s2">= {}</span>
        <span class="s4">for </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">subpartDef </span><span class="s4">in </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">subpartDefCopy </span><span class="s2">= </span><span class="s1">subpartDef</span>
            <span class="s4">if </span><span class="s1">subpartDef</span><span class="s2">:</span>
                <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">makeCopy</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">[</span><span class="s1">partName</span><span class="s2">] = </span><span class="s1">subpartDef</span>

    <span class="s4">def </span><span class="s1">__copyAnimControls</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;__copyAnimControls(self, Actor) 
        Get the anims from the anim control's in the anim control 
        dictionary of another actor. Bind these anim's to the part 
        bundles in our part bundle dict that have matching names, and 
        store the resulting anim controls in our own part bundle dict&quot;&quot;&quot;</span>

        <span class="s4">assert</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">mergeLODBundles </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">)</span>

        <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">] = {}</span>
            <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">]:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">] = {}</span>
                <span class="s4">for </span><span class="s1">animName </span><span class="s4">in </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">]:</span>
                    <span class="s1">anim </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">][</span><span class="s1">animName</span><span class="s2">]</span>
                    <span class="s1">anim </span><span class="s2">= </span><span class="s1">anim</span><span class="s2">.</span><span class="s1">makeCopy</span><span class="s2">()</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">__animControlDict</span><span class="s2">[</span><span class="s1">lodName</span><span class="s2">][</span><span class="s1">partName</span><span class="s2">][</span><span class="s1">animName</span><span class="s2">] = </span><span class="s1">anim</span>


    <span class="s4">def </span><span class="s1">actorInterval</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s4">from </span><span class="s1">direct</span><span class="s2">.</span><span class="s1">interval </span><span class="s4">import </span><span class="s1">ActorInterval</span>
        <span class="s4">return </span><span class="s1">ActorInterval</span><span class="s2">.</span><span class="s1">ActorInterval</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">getAnimBlends</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a list of the form:: 
 
           [ (lodName, [(animName, [(partName, effect), (partName, effect), ...]), 
                        (animName, [(partName, effect), (partName, effect), ...]), 
                        ...]), 
             (lodName, [(animName, [(partName, effect), (partName, effect), ...]), 
                        (animName, [(partName, effect), (partName, effect), ...]), 
                        ...]), 
              ... ] 
 
        This list reports the non-zero control effects for each 
        partName within a particular animation and LOD. &quot;&quot;&quot;</span>

        <span class="s1">result </span><span class="s2">= []</span>

        <span class="s4">if </span><span class="s1">animName </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">animNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimNames</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">animNames </span><span class="s2">= [</span><span class="s1">animName</span><span class="s2">]</span>

        <span class="s4">if </span><span class="s1">lodName </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getLODNames</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">mergeLODBundles</span><span class="s2">:</span>
                <span class="s1">lodNames </span><span class="s2">= </span><span class="s1">lodNames</span><span class="s2">[:</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lodNames </span><span class="s2">= [</span><span class="s1">lodName</span><span class="s2">]</span>

        <span class="s4">if </span><span class="s1">partName </span><span class="s2">== </span><span class="s4">None and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartsComplete</span><span class="s2">:</span>
            <span class="s1">partNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">partNames </span><span class="s2">= [</span><span class="s1">partName</span><span class="s2">]</span>

        <span class="s4">for </span><span class="s1">lodName </span><span class="s4">in </span><span class="s1">lodNames</span><span class="s2">:</span>
            <span class="s1">animList </span><span class="s2">= []</span>
            <span class="s4">for </span><span class="s1">animName </span><span class="s4">in </span><span class="s1">animNames</span><span class="s2">:</span>
                <span class="s1">blendList </span><span class="s2">= []</span>
                <span class="s4">for </span><span class="s1">partName </span><span class="s4">in </span><span class="s1">partNames</span><span class="s2">:</span>
                    <span class="s1">control </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControl</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">)</span>
                    <span class="s4">if </span><span class="s1">control</span><span class="s2">:</span>
                        <span class="s1">part </span><span class="s2">= </span><span class="s1">control</span><span class="s2">.</span><span class="s1">getPart</span><span class="s2">()</span>
                        <span class="s1">effect </span><span class="s2">= </span><span class="s1">part</span><span class="s2">.</span><span class="s1">getControlEffect</span><span class="s2">(</span><span class="s1">control</span><span class="s2">)</span>
                        <span class="s4">if </span><span class="s1">effect </span><span class="s2">&gt; </span><span class="s6">0.</span><span class="s2">:</span>
                            <span class="s1">blendList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">effect</span><span class="s2">))</span>
                <span class="s4">if </span><span class="s1">blendList</span><span class="s2">:</span>
                    <span class="s1">animList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">blendList</span><span class="s2">))</span>
            <span class="s4">if </span><span class="s1">animList</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">animList</span><span class="s2">))</span>

        <span class="s4">return </span><span class="s1">result</span>

    <span class="s4">def </span><span class="s1">printAnimBlends</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s4">for </span><span class="s1">lodName</span><span class="s2">, </span><span class="s1">animList </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimBlends</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">):</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">'LOD %s:' </span><span class="s2">% (</span><span class="s1">lodName</span><span class="s2">))</span>
            <span class="s4">for </span><span class="s1">animName</span><span class="s2">, </span><span class="s1">blendList </span><span class="s4">in </span><span class="s1">animList</span><span class="s2">:</span>

                <span class="s1">list </span><span class="s2">= []</span>
                <span class="s4">for </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">effect </span><span class="s4">in </span><span class="s1">blendList</span><span class="s2">:</span>
                    <span class="s1">list</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">'%s:%.3f' </span><span class="s2">% (</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">effect</span><span class="s2">))</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">'  %s: %s' </span><span class="s2">% (</span><span class="s1">animName</span><span class="s2">, </span><span class="s3">', '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">list</span><span class="s2">)))</span>

    <span class="s4">def </span><span class="s1">osdAnimBlends</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">animName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s4">if not </span><span class="s1">onScreenDebug</span><span class="s2">.</span><span class="s1">enabled</span><span class="s2">:</span>
            <span class="s4">return</span>
        <span class="s5"># puts anim blending info into the on-screen debug panel</span>
        <span class="s4">if </span><span class="s1">animName </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">animNames </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimNames</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">animNames </span><span class="s2">= [</span><span class="s1">animName</span><span class="s2">]</span>
        <span class="s4">for </span><span class="s1">animName </span><span class="s4">in </span><span class="s1">animNames</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">animName </span><span class="s2">== </span><span class="s3">'nothing'</span><span class="s2">:</span>
                <span class="s4">continue</span>
            <span class="s1">thisAnim </span><span class="s2">= </span><span class="s3">''</span>
            <span class="s1">totalEffect </span><span class="s2">= </span><span class="s6">0.</span>
            <span class="s1">controls </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getAnimControls</span><span class="s2">(</span><span class="s1">animName</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">lodName</span><span class="s2">)</span>
            <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">controls</span><span class="s2">:</span>
                <span class="s1">part </span><span class="s2">= </span><span class="s1">control</span><span class="s2">.</span><span class="s1">getPart</span><span class="s2">()</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">part</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">()</span>
                <span class="s1">effect </span><span class="s2">= </span><span class="s1">part</span><span class="s2">.</span><span class="s1">getControlEffect</span><span class="s2">(</span><span class="s1">control</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">effect </span><span class="s2">&gt; </span><span class="s6">0.</span><span class="s2">:</span>
                    <span class="s1">totalEffect </span><span class="s2">+= </span><span class="s1">effect</span>
                    <span class="s1">thisAnim </span><span class="s2">+= (</span><span class="s3">'%s:%.3f, ' </span><span class="s2">% (</span><span class="s1">name</span><span class="s2">, </span><span class="s1">effect</span><span class="s2">))</span>
            <span class="s1">thisAnim </span><span class="s2">+= </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span>
            <span class="s4">for </span><span class="s1">control </span><span class="s4">in </span><span class="s1">controls</span><span class="s2">:</span>
                <span class="s1">part </span><span class="s2">= </span><span class="s1">control</span><span class="s2">.</span><span class="s1">getPart</span><span class="s2">()</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">part</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">()</span>
                <span class="s1">rate </span><span class="s2">= </span><span class="s1">control</span><span class="s2">.</span><span class="s1">getPlayRate</span><span class="s2">()</span>
                <span class="s1">thisAnim </span><span class="s2">+= (</span><span class="s3">'%s:%.1f, ' </span><span class="s2">% (</span><span class="s1">name</span><span class="s2">, </span><span class="s1">rate</span><span class="s2">))</span>
            <span class="s5"># don't display anything if this animation is not being played</span>
            <span class="s1">itemName </span><span class="s2">= </span><span class="s3">'anim %s' </span><span class="s2">% </span><span class="s1">animName</span>
            <span class="s4">if </span><span class="s1">totalEffect </span><span class="s2">&gt; </span><span class="s6">0.</span><span class="s2">:</span>
                <span class="s1">onScreenDebug</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">itemName</span><span class="s2">, </span><span class="s1">thisAnim</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">onScreenDebug</span><span class="s2">.</span><span class="s1">has</span><span class="s2">(</span><span class="s1">itemName</span><span class="s2">):</span>
                    <span class="s1">onScreenDebug</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">itemName</span><span class="s2">)</span>

    <span class="s5"># these functions compensate for actors that are modeled facing the viewer but need</span>
    <span class="s5"># to face away from the camera in the game</span>
    <span class="s4">def </span><span class="s1">faceAwayFromViewer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">getGeomNode</span><span class="s2">().</span><span class="s1">setH</span><span class="s2">(</span><span class="s6">180</span><span class="s2">)</span>
    <span class="s4">def </span><span class="s1">faceTowardsViewer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">getGeomNode</span><span class="s2">().</span><span class="s1">setH</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">renamePartBundles</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">partName</span><span class="s2">, </span><span class="s1">newBundleName</span><span class="s2">):</span>
        <span class="s1">subpartDef </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__subpartDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">, </span><span class="s1">Actor</span><span class="s2">.</span><span class="s1">SubpartDef</span><span class="s2">(</span><span class="s1">partName</span><span class="s2">))</span>
        <span class="s4">for </span><span class="s1">partBundleDict </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__partBundleDict</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s1">partDef </span><span class="s2">= </span><span class="s1">partBundleDict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">subpartDef</span><span class="s2">.</span><span class="s1">truePartName</span><span class="s2">)</span>
            <span class="s1">partDef</span><span class="s2">.</span><span class="s1">getBundle</span><span class="s2">().</span><span class="s1">setName</span><span class="s2">(</span><span class="s1">newBundleName</span><span class="s2">)</span>

    <span class="s5">#snake_case alias:</span>
    <span class="s1">control_joint </span><span class="s2">= </span><span class="s1">controlJoint</span>
    <span class="s1">set_lod_animation </span><span class="s2">= </span><span class="s1">setLODAnimation</span>
    <span class="s1">get_anim_control_dict </span><span class="s2">= </span><span class="s1">getAnimControlDict</span>
    <span class="s1">get_actor_info </span><span class="s2">= </span><span class="s1">getActorInfo</span>
    <span class="s1">clear_lod_animation </span><span class="s2">= </span><span class="s1">clearLODAnimation</span>
    <span class="s1">reset_lod </span><span class="s2">= </span><span class="s1">resetLOD</span>
    <span class="s1">fix_bounds </span><span class="s2">= </span><span class="s1">fixBounds</span>
    <span class="s1">get_anim_filename </span><span class="s2">= </span><span class="s1">getAnimFilename</span>
    <span class="s1">get_subparts_complete </span><span class="s2">= </span><span class="s1">getSubpartsComplete</span>
    <span class="s1">verify_subparts_complete </span><span class="s2">= </span><span class="s1">verifySubpartsComplete</span>
    <span class="s1">get_play_rate </span><span class="s2">= </span><span class="s1">getPlayRate</span>
    <span class="s1">clear_python_data </span><span class="s2">= </span><span class="s1">clearPythonData</span>
    <span class="s1">load_anims </span><span class="s2">= </span><span class="s1">loadAnims</span>
    <span class="s1">set_subparts_complete </span><span class="s2">= </span><span class="s1">setSubpartsComplete</span>
    <span class="s1">draw_in_front </span><span class="s2">= </span><span class="s1">drawInFront</span>
    <span class="s1">get_lod_node </span><span class="s2">= </span><span class="s1">getLODNode</span>
    <span class="s1">hide_part </span><span class="s2">= </span><span class="s1">hidePart</span>
    <span class="s1">get_joint_transform_state </span><span class="s2">= </span><span class="s1">getJointTransformState</span>
    <span class="s1">set_control_effect </span><span class="s2">= </span><span class="s1">setControlEffect</span>
    <span class="s1">get_anim_controls </span><span class="s2">= </span><span class="s1">getAnimControls</span>
    <span class="s1">release_joint </span><span class="s2">= </span><span class="s1">releaseJoint</span>
    <span class="s1">print_anim_blends </span><span class="s2">= </span><span class="s1">printAnimBlends</span>
    <span class="s1">get_lod </span><span class="s2">= </span><span class="s1">getLOD</span>
    <span class="s1">disable_blend </span><span class="s2">= </span><span class="s1">disableBlend</span>
    <span class="s1">show_part </span><span class="s2">= </span><span class="s1">showPart</span>
    <span class="s1">get_joint_transform </span><span class="s2">= </span><span class="s1">getJointTransform</span>
    <span class="s1">face_away_from_viewer </span><span class="s2">= </span><span class="s1">faceAwayFromViewer</span>
    <span class="s1">set_lod </span><span class="s2">= </span><span class="s1">setLOD</span>
    <span class="s1">osd_anim_blends </span><span class="s2">= </span><span class="s1">osdAnimBlends</span>
    <span class="s1">get_current_frame </span><span class="s2">= </span><span class="s1">getCurrentFrame</span>
    <span class="s1">set_play_rate </span><span class="s2">= </span><span class="s1">setPlayRate</span>
    <span class="s1">bind_all_anims </span><span class="s2">= </span><span class="s1">bindAllAnims</span>
    <span class="s1">unload_anims </span><span class="s2">= </span><span class="s1">unloadAnims</span>
    <span class="s1">remove_part </span><span class="s2">= </span><span class="s1">removePart</span>
    <span class="s1">use_lod </span><span class="s2">= </span><span class="s1">useLOD</span>
    <span class="s1">get_anim_blends </span><span class="s2">= </span><span class="s1">getAnimBlends</span>
    <span class="s1">get_lod_index </span><span class="s2">= </span><span class="s1">getLODIndex</span>
    <span class="s1">get_num_frames </span><span class="s2">= </span><span class="s1">getNumFrames</span>
    <span class="s1">post_flatten </span><span class="s2">= </span><span class="s1">postFlatten</span>
    <span class="s1">get_lod_names </span><span class="s2">= </span><span class="s1">getLODNames</span>
    <span class="s1">list_joints </span><span class="s2">= </span><span class="s1">listJoints</span>
    <span class="s1">make_subpart </span><span class="s2">= </span><span class="s1">makeSubpart</span>
    <span class="s1">get_anim_control </span><span class="s2">= </span><span class="s1">getAnimControl</span>
    <span class="s1">get_part_bundle </span><span class="s2">= </span><span class="s1">getPartBundle</span>
    <span class="s1">get_part_bundle_dict </span><span class="s2">= </span><span class="s1">getPartBundleDict</span>
    <span class="s1">get_duration </span><span class="s2">= </span><span class="s1">getDuration</span>
    <span class="s1">has_lod </span><span class="s2">= </span><span class="s1">hasLOD</span>
    <span class="s1">print_lod </span><span class="s2">= </span><span class="s1">printLOD</span>
    <span class="s1">fix_bounds_old </span><span class="s2">= </span><span class="s1">fixBounds_old</span>
    <span class="s1">get_anim_names </span><span class="s2">= </span><span class="s1">getAnimNames</span>
    <span class="s1">get_part_bundles </span><span class="s2">= </span><span class="s1">getPartBundles</span>
    <span class="s1">anim_panel </span><span class="s2">= </span><span class="s1">animPanel</span>
    <span class="s1">stop_joint </span><span class="s2">= </span><span class="s1">stopJoint</span>
    <span class="s1">actor_interval </span><span class="s2">= </span><span class="s1">actorInterval</span>
    <span class="s1">hide_all_bounds </span><span class="s2">= </span><span class="s1">hideAllBounds</span>
    <span class="s1">show_all_bounds </span><span class="s2">= </span><span class="s1">showAllBounds</span>
    <span class="s1">init_anims_on_all_lods </span><span class="s2">= </span><span class="s1">initAnimsOnAllLODs</span>
    <span class="s1">get_part </span><span class="s2">= </span><span class="s1">getPart</span>
    <span class="s1">add_lod </span><span class="s2">= </span><span class="s1">addLOD</span>
    <span class="s1">show_all_parts </span><span class="s2">= </span><span class="s1">showAllParts</span>
    <span class="s1">get_joints </span><span class="s2">= </span><span class="s1">getJoints</span>
    <span class="s1">get_overlapping_joints </span><span class="s2">= </span><span class="s1">getOverlappingJoints</span>
    <span class="s1">enable_blend </span><span class="s2">= </span><span class="s1">enableBlend</span>
    <span class="s1">face_towards_viewer </span><span class="s2">= </span><span class="s1">faceTowardsViewer</span>
    <span class="s1">bind_anim </span><span class="s2">= </span><span class="s1">bindAnim</span>
    <span class="s1">set_blend </span><span class="s2">= </span><span class="s1">setBlend</span>
    <span class="s1">get_frame_time </span><span class="s2">= </span><span class="s1">getFrameTime</span>
    <span class="s1">remove_node </span><span class="s2">= </span><span class="s1">removeNode</span>
    <span class="s1">wait_pending </span><span class="s2">= </span><span class="s1">waitPending</span>
    <span class="s1">expose_joint </span><span class="s2">= </span><span class="s1">exposeJoint</span>
    <span class="s1">set_lod_node </span><span class="s2">= </span><span class="s1">setLODNode</span>
    <span class="s1">get_frame_rate </span><span class="s2">= </span><span class="s1">getFrameRate</span>
    <span class="s1">get_current_anim </span><span class="s2">= </span><span class="s1">getCurrentAnim</span>
    <span class="s1">get_part_names </span><span class="s2">= </span><span class="s1">getPartNames</span>
    <span class="s1">freeze_joint </span><span class="s2">= </span><span class="s1">freezeJoint</span>
    <span class="s1">set_center </span><span class="s2">= </span><span class="s1">setCenter</span>
    <span class="s1">rename_part_bundles </span><span class="s2">= </span><span class="s1">renamePartBundles</span>
    <span class="s1">get_geom_node </span><span class="s2">= </span><span class="s1">getGeomNode</span>
    <span class="s1">set_geom_node </span><span class="s2">= </span><span class="s1">setGeomNode</span>
    <span class="s1">load_model </span><span class="s2">= </span><span class="s1">loadModel</span>
    <span class="s1">copy_actor </span><span class="s2">= </span><span class="s1">copyActor</span>
    <span class="s1">get_base_frame_rate </span><span class="s2">= </span><span class="s1">getBaseFrameRate</span>
    <span class="s1">remove_anim_control_dict </span><span class="s2">= </span><span class="s1">removeAnimControlDict</span>
    <span class="s1">load_anims_on_all_lods </span><span class="s2">= </span><span class="s1">loadAnimsOnAllLODs</span>
</pre>
</body>
</html>