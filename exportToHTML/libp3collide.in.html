<html>
<head>
<title>libp3collide.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3collide.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">12 libp3collide 4 dlaq 12 panda3d.core </span>
<span class="s0">280</span>
<span class="s0">290 20 get_collision_origin 0 6 570 36 CollisionSolid::get_collision_origin 0 1 1 0</span>
<span class="s0">69</span>
<span class="s0">virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0;</span>

<span class="s0">291 12 set_tangible 0 4 570 28 CollisionSolid::set_tangible 0 1 2 295</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the current state of the 'tangible' flag.  Set this true to make the</span>
 <span class="s0">* solid tangible, so that a CollisionHandlerPusher will not allow another</span>
 <span class="s0">* object to intersect it, or false to make it intangible, so that a</span>
 <span class="s0">* CollisionHandlerPusher will ignore it except to throw an event.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void CollisionSolid::set_tangible(bool tangible);</span>

<span class="s0">292 11 is_tangible 0 4 570 27 CollisionSolid::is_tangible 0 1 3 266</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether the solid is considered 'tangible' or not.  An intangible</span>
 <span class="s0">* solid has no effect in a CollisionHandlerPusher (except to throw an event);</span>
 <span class="s0">* it's useful for defining 'trigger' planes and spheres, that cause an effect</span>
 <span class="s0">* when passed through.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool CollisionSolid::is_tangible(void) const;</span>

<span class="s0">293 20 set_effective_normal 0 4 570 36 CollisionSolid::set_effective_normal 0 1 4 388</span>
<span class="s0">/**</span>
 <span class="s0">* Records a false normal for this CollisionSolid that will be reported by the</span>
 <span class="s0">* collision system with all collisions into it, instead of its actual normal.</span>
 <span class="s0">* This is useful as a workaround for the problem of an avatar wanting to</span>
 <span class="s0">* stand on a sloping ground; by storing a false normal, the ground appears to</span>
 <span class="s0">* be perfectly level, and the avatar does not tend to slide down it.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void CollisionSolid::set_effective_normal(LVector3 const &amp;effective_normal);</span>

<span class="s0">294 22 clear_effective_normal 0 4 570 38 CollisionSolid::clear_effective_normal 0 1 5 71</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the normal previously set by set_effective_normal().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void CollisionSolid::clear_effective_normal(void);</span>

<span class="s0">295 20 has_effective_normal 0 4 570 36 CollisionSolid::has_effective_normal 0 1 6 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a special normal was set by set_effective_normal(), false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool CollisionSolid::has_effective_normal(void) const;</span>

<span class="s0">296 20 get_effective_normal 0 4 570 36 CollisionSolid::get_effective_normal 0 1 7 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the normal that was set by set_effective_normal().  It is an error</span>
 <span class="s0">* to call this unless has_effective_normal() returns true.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline LVector3 const &amp;CollisionSolid::get_effective_normal(void) const;</span>

<span class="s0">297 28 set_respect_effective_normal 0 4 570 44 CollisionSolid::set_respect_effective_normal 0 1 8 296</span>
<span class="s0">/**</span>
 <span class="s0">* This is only meaningful for CollisionSolids that will be added to a</span>
 <span class="s0">* traverser as colliders.  It is normally true, but if set false, it means</span>
 <span class="s0">* that this particular solid does not care about the &quot;effective&quot; normal of</span>
 <span class="s0">* other solids it meets, but rather always uses the true normal.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal);</span>

<span class="s0">298 28 get_respect_effective_normal 0 4 570 44 CollisionSolid::get_respect_effective_normal 0 1 9 46</span>
<span class="s0">/**</span>
 <span class="s0">* See set_respect_effective_normal().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline bool CollisionSolid::get_respect_effective_normal(void) const;</span>

<span class="s0">299 10 get_bounds 0 4 570 26 CollisionSolid::get_bounds 0 1 10 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the solid's bounding volume.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">ConstPointerTo&lt; BoundingVolume &gt; CollisionSolid::get_bounds(void) const;</span>

<span class="s0">300 10 set_bounds 0 4 570 26 CollisionSolid::set_bounds 0 1 11 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the solid's bounding volume.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">void CollisionSolid::set_bounds(BoundingVolume const &amp;bounding_volume);</span>

<span class="s0">301 6 output 0 6 570 22 CollisionSolid::output 0 1 12 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual void CollisionSolid::output(std::ostream &amp;out) const;</span>

<span class="s0">302 5 write 0 6 570 21 CollisionSolid::write 0 1 13 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">virtual void CollisionSolid::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">303 14 get_class_type 0 4 570 30 CollisionSolid::get_class_type 0 1 14 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle CollisionSolid::get_class_type(void);</span>

<span class="s0">304 12 CollisionBox 0 260 576 26 CollisionBox::CollisionBox 0 2 15 16 256</span>
<span class="s0">/**</span>
 <span class="s0">* Create the Box by giving a Center and distances of each of the sides of</span>
 <span class="s0">* box from the Center.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Create the Box by Specifying the Diagonal Points</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an invalid Box.  Only used when reading from a bam file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">195</span>
<span class="s0">inline explicit CollisionBox::CollisionBox(LPoint3 const &amp;center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline explicit CollisionBox::CollisionBox(LPoint3 const &amp;min, LPoint3 const &amp;max);</span>

<span class="s0">305 14 get_num_points 0 4 576 28 CollisionBox::get_num_points 0 1 17 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 8: the number of vertices of a rectangular solid.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int CollisionBox::get_num_points(void) const;</span>

<span class="s0">306 14 get_point_aabb 0 4 576 28 CollisionBox::get_point_aabb 0 1 18 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth vertex of the Axis Aligned Bounding Box.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline LPoint3 CollisionBox::get_point_aabb(int n) const;</span>

<span class="s0">307 9 get_point 0 4 576 23 CollisionBox::get_point 0 1 19 45</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth vertex of the OBB.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LPoint3 CollisionBox::get_point(int n) const;</span>

<span class="s0">308 14 get_num_planes 0 4 576 28 CollisionBox::get_num_planes 0 1 20 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 6: the number of faces of a rectangular solid.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int CollisionBox::get_num_planes(void) const;</span>

<span class="s0">309 9 set_plane 0 4 576 23 CollisionBox::set_plane 0 1 21 57</span>
<span class="s0">/**</span>
 <span class="s0">* Creates the nth face of the rectangular solid.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LPlane CollisionBox::set_plane(int n) const;</span>

<span class="s0">310 9 get_plane 0 4 576 23 CollisionBox::get_plane 0 1 22 57</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth face of the rectangular solid.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LPlane CollisionBox::get_plane(int n) const;</span>

<span class="s0">311 10 set_center 0 4 576 24 CollisionBox::set_center 0 2 23 24 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void CollisionBox::set_center(LPoint3 const &amp;center);</span>
<span class="s0">inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">312 10 get_center 0 4 576 24 CollisionBox::get_center 0 1 25 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline LPoint3 const &amp;CollisionBox::get_center(void) const;</span>

<span class="s0">313 7 get_min 0 4 576 21 CollisionBox::get_min 0 1 26 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LPoint3 const &amp;CollisionBox::get_min(void) const;</span>

<span class="s0">314 7 get_max 0 4 576 21 CollisionBox::get_max 0 1 27 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LPoint3 const &amp;CollisionBox::get_max(void) const;</span>

<span class="s0">315 14 get_dimensions 0 4 576 28 CollisionBox::get_dimensions 0 1 28 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline LVector3 CollisionBox::get_dimensions(void) const;</span>

<span class="s0">316 14 get_class_type 0 4 576 28 CollisionBox::get_class_type 0 1 29 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle CollisionBox::get_class_type(void);</span>

<span class="s0">317 13 ~CollisionBox 0 516 576 27 CollisionBox::~CollisionBox 0 0 0</span>
<span class="s0">34</span>
<span class="s0">CollisionBox::~CollisionBox(void);</span>

<span class="s0">318 16 CollisionCapsule 0 260 580 34 CollisionCapsule::CollisionCapsule 0 2 30 31 115</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an invalid capsule.  Only used when reading from a bam file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">276</span>
<span class="s0">inline explicit CollisionCapsule::CollisionCapsule(LPoint3 const &amp;a, LPoint3 const &amp;db, PN_stdfloat radius);</span>
<span class="s0">inline explicit CollisionCapsule::CollisionCapsule(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius);</span>

<span class="s0">319 11 set_point_a 0 4 580 29 CollisionCapsule::set_point_a 0 2 32 33 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline void CollisionCapsule::set_point_a(LPoint3 const &amp;a);</span>
<span class="s0">inline void CollisionCapsule::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">320 11 get_point_a 0 4 580 29 CollisionCapsule::get_point_a 0 1 34 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint3 const &amp;CollisionCapsule::get_point_a(void) const;</span>

<span class="s0">321 11 set_point_b 0 4 580 29 CollisionCapsule::set_point_b 0 2 35 36 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline void CollisionCapsule::set_point_b(LPoint3 const &amp;b);</span>
<span class="s0">inline void CollisionCapsule::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">322 11 get_point_b 0 4 580 29 CollisionCapsule::get_point_b 0 1 37 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint3 const &amp;CollisionCapsule::get_point_b(void) const;</span>

<span class="s0">323 10 set_radius 0 4 580 28 CollisionCapsule::set_radius 0 1 38 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void CollisionCapsule::set_radius(PN_stdfloat radius);</span>

<span class="s0">324 10 get_radius 0 4 580 28 CollisionCapsule::get_radius 0 1 39 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PN_stdfloat CollisionCapsule::get_radius(void) const;</span>

<span class="s0">325 14 get_class_type 0 4 580 32 CollisionCapsule::get_class_type 0 1 40 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle CollisionCapsule::get_class_type(void);</span>

<span class="s0">326 17 ~CollisionCapsule 0 516 580 35 CollisionCapsule::~CollisionCapsule 0 0 0</span>
<span class="s0">42</span>
<span class="s0">CollisionCapsule::~CollisionCapsule(void);</span>

<span class="s0">327 14 get_class_type 0 4 583 32 CollisionHandler::get_class_type 0 1 42 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle CollisionHandler::get_class_type(void);</span>

<span class="s0">328 16 CollisionHandler 0 260 583 34 CollisionHandler::CollisionHandler 0 1 41 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline CollisionHandler::CollisionHandler(CollisionHandler const &amp;) = default;</span>

<span class="s0">329 17 ~CollisionHandler 0 516 583 35 CollisionHandler::~CollisionHandler 0 0 0</span>
<span class="s0">42</span>
<span class="s0">CollisionHandler::~CollisionHandler(void);</span>

<span class="s0">330 13 CollisionNode 0 260 585 28 CollisionNode::CollisionNode 0 1 43 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">explicit CollisionNode::CollisionNode(std::string const &amp;name);</span>

<span class="s0">331 16 set_collide_mask 0 4 585 31 CollisionNode::set_collide_mask 0 1 44 98</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously sets both the &quot;from&quot; and &quot;into&quot; CollideMask values to the</span>
 <span class="s0">* same thing.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void CollisionNode::set_collide_mask(CollideMask mask);</span>

<span class="s0">332 21 set_from_collide_mask 0 4 585 36 CollisionNode::set_from_collide_mask 0 1 45 222</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;from&quot; CollideMask.  In order for a collision to be detected from</span>
 <span class="s0">* this object into another object, the intersection of this object's &quot;from&quot;</span>
 <span class="s0">* mask and the other object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void CollisionNode::set_from_collide_mask(CollideMask mask);</span>

<span class="s0">333 21 set_into_collide_mask 0 4 585 36 CollisionNode::set_into_collide_mask 0 1 46 222</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;into&quot; CollideMask.  In order for a collision to be detected from</span>
 <span class="s0">* another object into this object, the intersection of the other object's</span>
 <span class="s0">* &quot;from&quot; mask and this object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void CollisionNode::set_into_collide_mask(CollideMask mask);</span>

<span class="s0">334 21 get_from_collide_mask 0 4 585 36 CollisionNode::get_from_collide_mask 0 1 47 233</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current &quot;from&quot; CollideMask.  In order for a collision to be</span>
 <span class="s0">* detected from this object into another object, the intersection of this</span>
 <span class="s0">* object's &quot;from&quot; mask and the other object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline CollideMask CollisionNode::get_from_collide_mask(void) const;</span>

<span class="s0">335 21 get_into_collide_mask 0 4 585 36 CollisionNode::get_into_collide_mask 0 1 48 233</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current &quot;into&quot; CollideMask.  In order for a collision to be</span>
 <span class="s0">* detected from another object into this object, the intersection of the</span>
 <span class="s0">* other object's &quot;from&quot; mask and this object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline CollideMask CollisionNode::get_into_collide_mask(void) const;</span>

<span class="s0">336 12 clear_solids 0 4 585 27 CollisionNode::clear_solids 0 1 49 44</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all solids from the node.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void CollisionNode::clear_solids(void);</span>

<span class="s0">337 14 get_num_solids 0 4 585 29 CollisionNode::get_num_solids 0 1 50 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::size_t CollisionNode::get_num_solids(void) const;</span>

<span class="s0">338 9 get_solid 0 4 585 24 CollisionNode::get_solid 0 1 51 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline ConstPointerTo&lt; CollisionSolid &gt; CollisionNode::get_solid(std::size_t n) const;</span>

<span class="s0">339 12 modify_solid 0 4 585 27 CollisionNode::modify_solid 0 1 52 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline PointerTo&lt; CollisionSolid &gt; CollisionNode::modify_solid(std::size_t n);</span>

<span class="s0">340 9 set_solid 0 4 585 24 CollisionNode::set_solid 0 1 53 55</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the solid with the indicated index.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void CollisionNode::set_solid(std::size_t n, CollisionSolid *solid);</span>

<span class="s0">341 12 insert_solid 0 4 585 27 CollisionNode::insert_solid 0 1 54 77</span>
<span class="s0">/**</span>
 <span class="s0">* Inserts the indicated solid to the node at the indicated position.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline void CollisionNode::insert_solid(std::size_t n, CollisionSolid const *solid);</span>

<span class="s0">342 12 remove_solid 0 4 585 27 CollisionNode::remove_solid 0 1 55 110</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the solid with the indicated index.  This will shift all subsequent</span>
 <span class="s0">* indices down by one.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void CollisionNode::remove_solid(std::size_t n);</span>

<span class="s0">343 9 add_solid 0 4 585 24 CollisionNode::add_solid 0 1 56 121</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated solid to the node.  Returns the index of the new solid</span>
 <span class="s0">* within the node's list of solids.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline std::size_t CollisionNode::add_solid(CollisionSolid const *solid);</span>

<span class="s0">344 17 get_collider_sort 0 4 585 32 CollisionNode::get_collider_sort 0 1 57 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the collider_sort value that has been set for this particular node.</span>
 <span class="s0">* See set_collider_sort().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int CollisionNode::get_collider_sort(void) const;</span>

<span class="s0">345 17 set_collider_sort 0 4 585 32 CollisionNode::set_collider_sort 0 1 58 594</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a particular collider_sort value on this node.  This controls the</span>
 <span class="s0">* order in which colliders (that is, &quot;from nodes&quot;) are grouped together for</span>
 <span class="s0">* the collision traversal.</span>
 <span class="s0">*</span>
 <span class="s0">* If there are 32 or fewer colliders added to any particular</span>
 <span class="s0">* CollisionTraverser, then this value has no meaning.  It is only useful if</span>
 <span class="s0">* there are many colliders, which may force the CollisionTraverser to make</span>
 <span class="s0">* multiple passes through the data; in that case, it may be a useful</span>
 <span class="s0">* optimization to group colliders that have similar bounding volumes together</span>
 <span class="s0">* (by giving them similar sort values).</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void CollisionNode::set_collider_sort(int sort);</span>

<span class="s0">346 24 get_default_collide_mask 0 4 585 39 CollisionNode::get_default_collide_mask 0 1 59 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default into_collide_mask assigned to new CollisionNodes.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline CollideMask CollisionNode::get_default_collide_mask(void);</span>

<span class="s0">347 14 get_class_type 0 4 585 29 CollisionNode::get_class_type 0 1 60 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle CollisionNode::get_class_type(void);</span>

<span class="s0">348 18 CollisionTraverser 0 260 592 38 CollisionTraverser::CollisionTraverser 0 2 61 62 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">168</span>
<span class="s0">explicit CollisionTraverser::CollisionTraverser(std::string const &amp;name = &quot;ctrav&quot;);</span>
<span class="s0">inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &amp;) = default;</span>

<span class="s0">349 19 ~CollisionTraverser 0 516 592 39 CollisionTraverser::~CollisionTraverser 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">CollisionTraverser::~CollisionTraverser(void);</span>

<span class="s0">350 26 set_respect_prev_transform 0 4 592 46 CollisionTraverser::set_respect_prev_transform 0 1 63 370</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates whether the prev_transform stored on a node</span>
 <span class="s0">* (as updated via set_fluid_pos(), etc.) is respected to calculate</span>
 <span class="s0">* collisions.  If this is true, certain types of collision tests will be</span>
 <span class="s0">* enhanced by the information about objects in motion.  If this is false,</span>
 <span class="s0">* objects are always considered to be static.  The default is false.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void CollisionTraverser::set_respect_prev_transform(bool flag);</span>

<span class="s0">351 26 get_respect_prev_transform 0 4 592 46 CollisionTraverser::get_respect_prev_transform 0 1 64 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that indicates whether the prev_transform stored on a node</span>
 <span class="s0">* is respected to calculate collisions.  See set_respect_prev_transform().</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline bool CollisionTraverser::get_respect_prev_transform(void) const;</span>

<span class="s0">352 12 add_collider 0 4 592 32 CollisionTraverser::add_collider 0 1 65 437</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new CollisionNode, representing an object that will be tested for</span>
 <span class="s0">* collisions into other objects, along with the handler that will serve each</span>
 <span class="s0">* detected collision.  Each CollisionNode may be served by only one handler</span>
 <span class="s0">* at a time, but a given handler may serve many CollisionNodes.</span>
 <span class="s0">*</span>
 <span class="s0">* The handler that serves a particular node may be changed from time to time</span>
 <span class="s0">* by calling add_collider() again on the same node.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">void CollisionTraverser::add_collider(NodePath const &amp;collider, CollisionHandler *handler);</span>

<span class="s0">353 15 remove_collider 0 4 592 35 CollisionTraverser::remove_collider 0 1 66 263</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the collider (and its associated handler) from the set of</span>
 <span class="s0">* CollisionNodes that will be tested each frame for collisions into other</span>
 <span class="s0">* objects.  Returns true if the definition was found and removed, false if it</span>
 <span class="s0">* wasn't present to begin with.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">bool CollisionTraverser::remove_collider(NodePath const &amp;collider);</span>

<span class="s0">354 12 has_collider 0 4 592 32 CollisionTraverser::has_collider 0 1 67 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated node is current in the set of nodes that will</span>
 <span class="s0">* be tested each frame for collisions into other objects.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">bool CollisionTraverser::has_collider(NodePath const &amp;collider) const;</span>

<span class="s0">355 17 get_num_colliders 0 4 592 37 CollisionTraverser::get_num_colliders 0 1 68 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of CollisionNodes that have been added to the traverser</span>
 <span class="s0">* via add_collider().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int CollisionTraverser::get_num_colliders(void) const;</span>

<span class="s0">356 12 get_collider 0 4 592 32 CollisionTraverser::get_collider 0 1 69 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth CollisionNode that has been added to the traverser via</span>
 <span class="s0">* add_collider().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">NodePath CollisionTraverser::get_collider(int n) const;</span>

<span class="s0">357 11 get_handler 0 4 592 31 CollisionTraverser::get_handler 0 1 70 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the handler that is currently assigned to serve the indicated</span>
 <span class="s0">* collision node, or NULL if the node is not on the traverser's set of active</span>
 <span class="s0">* nodes.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">CollisionHandler *CollisionTraverser::get_handler(NodePath const &amp;collider) const;</span>

<span class="s0">358 15 clear_colliders 0 4 592 35 CollisionTraverser::clear_colliders 0 1 71 90</span>
<span class="s0">/**</span>
 <span class="s0">* Completely empties the set of collision nodes and their associated</span>
 <span class="s0">* handlers.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void CollisionTraverser::clear_colliders(void);</span>

<span class="s0">359 8 traverse 0 4 592 28 CollisionTraverser::traverse 0 1 72 247</span>
<span class="s0">/**</span>
 <span class="s0">* Perform the traversal. Begins at the indicated root and detects all</span>
 <span class="s0">* collisions with any of its collider objects against nodes at or below the</span>
 <span class="s0">* indicated root, calling the appropriate CollisionHandler for each detected</span>
 <span class="s0">* collision.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void CollisionTraverser::traverse(NodePath const &amp;root);</span>

<span class="s0">360 12 set_recorder 0 4 592 32 CollisionTraverser::set_recorder 0 1 73 777</span>
<span class="s0">/**</span>
 <span class="s0">* Uses the indicated CollisionRecorder object to start recording the</span>
 <span class="s0">* intersection tests made by each subsequent call to traverse() on this</span>
 <span class="s0">* object.  A particular CollisionRecorder object can only record one</span>
 <span class="s0">* traverser at a time; if this object has already been assigned to another</span>
 <span class="s0">* traverser, that assignment is broken.</span>
 <span class="s0">*</span>
 <span class="s0">* This is intended to be used in a debugging mode to try to determine what</span>
 <span class="s0">* work is being performed by the collision traversal.  Usually, attaching a</span>
 <span class="s0">* recorder will impose significant runtime overhead.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not transfer ownership of the CollisionRecorder pointer;</span>
 <span class="s0">* maintenance of that remains the caller's responsibility.  If the</span>
 <span class="s0">* CollisionRecorder is destructed, it will cleanly remove itself from the</span>
 <span class="s0">* traverser.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void CollisionTraverser::set_recorder(CollisionRecorder *recorder);</span>

<span class="s0">361 12 has_recorder 0 4 592 32 CollisionTraverser::has_recorder 0 1 74 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the CollisionTraverser has a CollisionRecorder object</span>
 <span class="s0">* currently assigned, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool CollisionTraverser::has_recorder(void) const;</span>

<span class="s0">362 12 get_recorder 0 4 592 32 CollisionTraverser::get_recorder 0 1 75 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CollisionRecorder currently assigned, or NULL if no recorder is</span>
 <span class="s0">* assigned.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline CollisionRecorder *CollisionTraverser::get_recorder(void) const;</span>

<span class="s0">363 14 clear_recorder 0 4 592 34 CollisionTraverser::clear_recorder 0 1 76 107</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the CollisionRecorder from the traverser and restores normal low-</span>
 <span class="s0">* overhead operation.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void CollisionTraverser::clear_recorder(void);</span>

<span class="s0">364 6 output 0 4 596 25 CollisionRecorder::output 0 1 84 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void CollisionRecorder::output(std::ostream &amp;out) const;</span>

<span class="s0">365 14 get_class_type 0 4 596 33 CollisionRecorder::get_class_type 0 1 85 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle CollisionRecorder::get_class_type(void);</span>

<span class="s0">366 15 show_collisions 0 4 592 35 CollisionTraverser::show_collisions 0 1 77 300</span>
<span class="s0">/**</span>
 <span class="s0">* This is a high-level function to create a CollisionVisualizer object to</span>
 <span class="s0">* render the collision tests performed by this traverser.  The supplied root</span>
 <span class="s0">* should be any node in the scene graph; typically, the top node (e.g.</span>
 <span class="s0">* render).  The CollisionVisualizer will be attached to this node.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">CollisionVisualizer *CollisionTraverser::show_collisions(NodePath const &amp;root);</span>

<span class="s0">367 15 hide_collisions 0 4 592 35 CollisionTraverser::hide_collisions 0 1 78 69</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of a previous call to show_collisions().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void CollisionTraverser::hide_collisions(void);</span>

<span class="s0">368 6 output 0 4 592 26 CollisionTraverser::output 0 1 79 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void CollisionTraverser::output(std::ostream &amp;out) const;</span>

<span class="s0">369 5 write 0 4 592 25 CollisionTraverser::write 0 1 80 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void CollisionTraverser::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">370 12 __getstate__ 0 4 592 32 CollisionTraverser::__getstate__ 0 1 81 0</span>
<span class="s0">55</span>
<span class="s0">PyObject *CollisionTraverser::__getstate__(void) const;</span>

<span class="s0">371 12 __setstate__ 0 4 592 32 CollisionTraverser::__setstate__ 0 1 82 0</span>
<span class="s0">55</span>
<span class="s0">void CollisionTraverser::__setstate__(PyObject *state);</span>

<span class="s0">372 14 get_class_type 0 4 592 34 CollisionTraverser::get_class_type 0 1 83 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle CollisionTraverser::get_class_type(void);</span>

<span class="s0">373 8 get_from 0 4 598 24 CollisionEntry::get_from 0 1 86 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CollisionSolid pointer for the particular solid that triggered</span>
 <span class="s0">* this collision.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline CollisionSolid const *CollisionEntry::get_from(void) const;</span>

<span class="s0">374 8 has_into 0 4 598 24 CollisionEntry::has_into 0 1 87 288</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;into&quot; solid is, in fact, a CollisionSolid, and its</span>
 <span class="s0">* pointer is known (in which case get_into() may be called to retrieve it).</span>
 <span class="s0">* If this returns false, the collision was detected into a GeomNode, and</span>
 <span class="s0">* there is no CollisionSolid pointer to be retrieved.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool CollisionEntry::has_into(void) const;</span>

<span class="s0">375 8 get_into 0 4 598 24 CollisionEntry::get_into 0 1 88 243</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CollisionSolid pointer for the particular solid was collided</span>
 <span class="s0">* into.  This pointer might be NULL if the collision was into a piece of</span>
 <span class="s0">* visible geometry, instead of a normal CollisionSolid collision; see</span>
 <span class="s0">* has_into().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline CollisionSolid const *CollisionEntry::get_into(void) const;</span>

<span class="s0">376 13 get_from_node 0 4 598 29 CollisionEntry::get_from_node 0 1 89 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node that contains the CollisionSolid that triggered this</span>
 <span class="s0">* collision.  This will be a node that has been added to a CollisionTraverser</span>
 <span class="s0">* via add_collider().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline CollisionNode *CollisionEntry::get_from_node(void) const;</span>

<span class="s0">377 13 get_into_node 0 4 598 29 CollisionEntry::get_into_node 0 1 90 254</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node that contains the CollisionSolid that was collided into.</span>
 <span class="s0">* This returns a PandaNode pointer instead of something more specific,</span>
 <span class="s0">* because it might be either a CollisionNode or a GeomNode.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see get_into_node_path().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PandaNode *CollisionEntry::get_into_node(void) const;</span>

<span class="s0">378 18 get_from_node_path 0 4 598 34 CollisionEntry::get_from_node_path 0 1 91 224</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath that represents the CollisionNode that contains the</span>
 <span class="s0">* CollisionSolid that triggered this collision.  This will be a NodePath that</span>
 <span class="s0">* has been added to a CollisionTraverser via add_collider().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline NodePath CollisionEntry::get_from_node_path(void) const;</span>

<span class="s0">379 18 get_into_node_path 0 4 598 34 CollisionEntry::get_into_node_path 0 1 92 338</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath that represents the specific CollisionNode or GeomNode</span>
 <span class="s0">* instance that was collided into.  This is the same node returned by</span>
 <span class="s0">* get_into_node(), represented as a NodePath; however, it may be more useful</span>
 <span class="s0">* because the NodePath can resolve the particular instance of the node, if</span>
 <span class="s0">* there is more than one.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline NodePath CollisionEntry::get_into_node_path(void) const;</span>

<span class="s0">380 5 set_t 0 4 598 21 CollisionEntry::set_t 0 1 93 82</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a time value for this collision relative to other CollisionEntries</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void CollisionEntry::set_t(PN_stdfloat t);</span>

<span class="s0">381 5 get_t 0 4 598 21 CollisionEntry::get_t 0 1 94 83</span>
<span class="s0">/**</span>
 <span class="s0">* returns time value for this collision relative to other CollisionEntries</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat CollisionEntry::get_t(void) const;</span>

<span class="s0">382 8 collided 0 4 598 24 CollisionEntry::collided 0 1 95 188</span>
<span class="s0">/**</span>
 <span class="s0">* returns true if this represents an actual collision as opposed to a</span>
 <span class="s0">* potential collision, needed for iterative collision resolution where path</span>
 <span class="s0">* of collider changes mid-frame</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool CollisionEntry::collided(void) const;</span>

<span class="s0">383 14 reset_collided 0 4 598 30 CollisionEntry::reset_collided 0 1 96 45</span>
<span class="s0">/**</span>
 <span class="s0">* prepare for another collision test</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void CollisionEntry::reset_collided(void);</span>

<span class="s0">384 26 get_respect_prev_transform 0 4 598 42 CollisionEntry::get_respect_prev_transform 0 1 97 203</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the collision was detected by a CollisionTraverser whose</span>
 <span class="s0">* respect_prev_transform flag was set true, meaning we should consider motion</span>
 <span class="s0">* significant in evaluating collisions.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline bool CollisionEntry::get_respect_prev_transform(void) const;</span>

<span class="s0">385 17 set_surface_point 0 4 598 33 CollisionEntry::set_surface_point 0 1 98 178</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the point, on the surface of the &quot;into&quot; object, at which a collision</span>
 <span class="s0">* is detected.</span>
 <span class="s0">*</span>
 <span class="s0">* This point is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void CollisionEntry::set_surface_point(LPoint3 const &amp;point);</span>

<span class="s0">386 18 set_surface_normal 0 4 598 34 CollisionEntry::set_surface_normal 0 1 99 171</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the surface normal of the &quot;into&quot; object at the point of the</span>
 <span class="s0">* intersection.</span>
 <span class="s0">*</span>
 <span class="s0">* This normal is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void CollisionEntry::set_surface_normal(LVector3 const &amp;normal);</span>

<span class="s0">387 18 set_interior_point 0 4 598 34 CollisionEntry::set_interior_point 0 1 100 352</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the point, within the interior of the &quot;into&quot; object, which</span>
 <span class="s0">* represents the depth to which the &quot;from&quot; object has penetrated.  This can</span>
 <span class="s0">* also be described as the intersection point on the surface of the &quot;from&quot;</span>
 <span class="s0">* object (which is inside the &quot;into&quot; object).</span>
 <span class="s0">*</span>
 <span class="s0">* This point is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void CollisionEntry::set_interior_point(LPoint3 const &amp;point);</span>

<span class="s0">388 17 has_surface_point 0 4 598 33 CollisionEntry::has_surface_point 0 1 101 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the surface point has been specified, false otherwise.  See</span>
 <span class="s0">* get_surface_point().  Some types of collisions may not compute the surface</span>
 <span class="s0">* point.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool CollisionEntry::has_surface_point(void) const;</span>

<span class="s0">389 18 has_surface_normal 0 4 598 34 CollisionEntry::has_surface_normal 0 1 102 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the surface normal has been specified, false otherwise.</span>
 <span class="s0">* See get_surface_normal().  Some types of collisions may not compute the</span>
 <span class="s0">* surface normal.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool CollisionEntry::has_surface_normal(void) const;</span>

<span class="s0">390 18 has_interior_point 0 4 598 34 CollisionEntry::has_interior_point 0 1 103 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the interior point has been specified, false otherwise.</span>
 <span class="s0">* See get_interior_point().  Some types of collisions may not compute the</span>
 <span class="s0">* interior point.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool CollisionEntry::has_interior_point(void) const;</span>

<span class="s0">391 15 set_contact_pos 0 4 598 31 CollisionEntry::set_contact_pos 0 1 104 190</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the position of the &quot;from&quot; object at the instant at which the</span>
 <span class="s0">* collision is first detected.</span>
 <span class="s0">*</span>
 <span class="s0">* This position is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void CollisionEntry::set_contact_pos(LPoint3 const &amp;pos);</span>

<span class="s0">392 18 set_contact_normal 0 4 598 34 CollisionEntry::set_contact_normal 0 1 105 154</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the surface normal of the &quot;into&quot; object at the contact pos.</span>
 <span class="s0">*</span>
 <span class="s0">* This normal is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void CollisionEntry::set_contact_normal(LVector3 const &amp;normal);</span>

<span class="s0">393 15 has_contact_pos 0 4 598 31 CollisionEntry::has_contact_pos 0 1 106 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the contact position has been specified, false otherwise.</span>
 <span class="s0">* See get_contact_pos().  Some types of collisions may not compute the</span>
 <span class="s0">* contact pos.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool CollisionEntry::has_contact_pos(void) const;</span>

<span class="s0">394 18 has_contact_normal 0 4 598 34 CollisionEntry::has_contact_normal 0 1 107 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the contact normal has been specified, false otherwise.</span>
 <span class="s0">* See get_contact_normal().  Some types of collisions may not compute the</span>
 <span class="s0">* contact normal.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool CollisionEntry::has_contact_normal(void) const;</span>

<span class="s0">395 17 get_surface_point 0 4 598 33 CollisionEntry::get_surface_point 0 1 108 330</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point, on the surface of the &quot;into&quot; object, at which a</span>
 <span class="s0">* collision is detected.  This can be thought of as the first point of</span>
 <span class="s0">* intersection.  However the contact point is the actual first point of</span>
 <span class="s0">* intersection.</span>
 <span class="s0">*</span>
 <span class="s0">* The point will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">LPoint3 CollisionEntry::get_surface_point(NodePath const &amp;space) const;</span>

<span class="s0">396 18 get_surface_normal 0 4 598 34 CollisionEntry::get_surface_normal 0 1 109 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the surface normal of the &quot;into&quot; object at the point at which a</span>
 <span class="s0">* collision is detected.</span>
 <span class="s0">*</span>
 <span class="s0">* The normal will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">LVector3 CollisionEntry::get_surface_normal(NodePath const &amp;space) const;</span>

<span class="s0">397 18 get_interior_point 0 4 598 34 CollisionEntry::get_interior_point 0 1 110 431</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point, within the interior of the &quot;into&quot; object, which</span>
 <span class="s0">* represents the depth to which the &quot;from&quot; object has penetrated.  This can</span>
 <span class="s0">* also be described as the intersection point on the surface of the &quot;from&quot;</span>
 <span class="s0">* object (which is inside the &quot;into&quot; object).  It can be thought of as the</span>
 <span class="s0">* deepest point of intersection.</span>
 <span class="s0">*</span>
 <span class="s0">* The point will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">LPoint3 CollisionEntry::get_interior_point(NodePath const &amp;space) const;</span>

<span class="s0">398 7 get_all 0 4 598 23 CollisionEntry::get_all 0 1 111 244</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously transforms the surface point, surface normal, and interior</span>
 <span class="s0">* point of the collision into the indicated coordinate space.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if all three properties are available, or false if any one of</span>
 <span class="s0">* them is not.</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">bool CollisionEntry::get_all(NodePath const &amp;space, LPoint3 &amp;surface_point, LVector3 &amp;surface_normal, LPoint3 &amp;interior_point) const;</span>

<span class="s0">399 15 get_contact_pos 0 4 598 31 CollisionEntry::get_contact_pos 0 1 112 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the &quot;from&quot; object at the instant that a collision</span>
 <span class="s0">* is first detected.</span>
 <span class="s0">*</span>
 <span class="s0">* The position will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">LPoint3 CollisionEntry::get_contact_pos(NodePath const &amp;space) const;</span>

<span class="s0">400 18 get_contact_normal 0 4 598 34 CollisionEntry::get_contact_normal 0 1 113 175</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the surface normal of the &quot;into&quot; object at the contact position.</span>
 <span class="s0">*</span>
 <span class="s0">* The normal will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">LVector3 CollisionEntry::get_contact_normal(NodePath const &amp;space) const;</span>

<span class="s0">401 20 get_all_contact_info 0 4 598 36 CollisionEntry::get_all_contact_info 0 1 114 230</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously transforms the contact position and contact normal of the</span>
 <span class="s0">* collision into the indicated coordinate space.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if all three properties are available, or false if any one of</span>
 <span class="s0">* them is not.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">bool CollisionEntry::get_all_contact_info(NodePath const &amp;space, LPoint3 &amp;contact_pos, LVector3 &amp;contact_normal) const;</span>

<span class="s0">402 6 output 0 4 598 22 CollisionEntry::output 0 1 115 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void CollisionEntry::output(std::ostream &amp;out) const;</span>

<span class="s0">403 5 write 0 4 598 21 CollisionEntry::write 0 1 116 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void CollisionEntry::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">404 14 get_class_type 0 4 598 30 CollisionEntry::get_class_type 0 1 117 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle CollisionEntry::get_class_type(void);</span>

<span class="s0">405 15 ~CollisionEntry 0 516 598 31 CollisionEntry::~CollisionEntry 0 0 0</span>
<span class="s0">38</span>
<span class="s0">CollisionEntry::~CollisionEntry(void);</span>

<span class="s0">406 14 CollisionPlane 0 260 604 30 CollisionPlane::CollisionPlane 0 2 118 119 168</span>
<span class="s0">/**</span>
 <span class="s0">* This is only for the convenience of CollisionPolygon.  Normally, you should</span>
 <span class="s0">* not attempt to create an uninitialized CollisionPlane.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">inline CollisionPlane::CollisionPlane(LPlane const &amp;plane);</span>
<span class="s0">inline CollisionPlane::CollisionPlane(CollisionPlane const &amp;copy);</span>

<span class="s0">407 10 get_normal 0 4 604 26 CollisionPlane::get_normal 0 1 120 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LVector3 CollisionPlane::get_normal(void) const;</span>

<span class="s0">408 13 dist_to_plane 0 4 604 29 CollisionPlane::dist_to_plane 0 1 121 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &amp;point) const;</span>

<span class="s0">409 9 set_plane 0 4 604 25 CollisionPlane::set_plane 0 1 122 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void CollisionPlane::set_plane(LPlane const &amp;plane);</span>

<span class="s0">410 9 get_plane 0 4 604 25 CollisionPlane::get_plane 0 1 123 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline LPlane const &amp;CollisionPlane::get_plane(void) const;</span>

<span class="s0">411 4 flip 0 4 604 20 CollisionPlane::flip 0 1 124 57</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience method to flip the plane in-place.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline void CollisionPlane::flip(void);</span>

<span class="s0">412 14 get_class_type 0 4 604 30 CollisionPlane::get_class_type 0 1 125 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle CollisionPlane::get_class_type(void);</span>

<span class="s0">413 15 ~CollisionPlane 0 516 604 31 CollisionPlane::~CollisionPlane 0 0 0</span>
<span class="s0">38</span>
<span class="s0">CollisionPlane::~CollisionPlane(void);</span>

<span class="s0">414 18 CollisionFloorMesh 0 260 608 38 CollisionFloorMesh::CollisionFloorMesh 0 1 126 156</span>
<span class="s0">/**</span>
 <span class="s0">* This is only for the convenience of CollisionPolygon.  Normally, you should</span>
 <span class="s0">* not attempt to create an uninitialized CollisionPlane.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline CollisionFloorMesh::CollisionFloorMesh(void);</span>

<span class="s0">415 10 add_vertex 0 4 608 30 CollisionFloorMesh::add_vertex 0 1 127 47</span>
<span class="s0">/**</span>
 <span class="s0">* store away a vertex to index against</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void CollisionFloorMesh::add_vertex(LPoint3 const &amp;vert);</span>

<span class="s0">416 12 add_triangle 0 4 608 32 CollisionFloorMesh::add_triangle 0 1 128 42</span>
<span class="s0">/**</span>
 <span class="s0">* store a triangle for processing</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC);</span>

<span class="s0">417 16 get_num_vertices 0 4 608 36 CollisionFloorMesh::get_num_vertices 0 1 129 0</span>
<span class="s0">69</span>
<span class="s0">inline unsigned int CollisionFloorMesh::get_num_vertices(void) const;</span>

<span class="s0">418 10 get_vertex 0 4 608 30 CollisionFloorMesh::get_vertex 0 1 130 0</span>
<span class="s0">79</span>
<span class="s0">inline LPoint3 const &amp;CollisionFloorMesh::get_vertex(unsigned int index) const;</span>

<span class="s0">419 17 get_num_triangles 0 4 608 37 CollisionFloorMesh::get_num_triangles 0 1 131 0</span>
<span class="s0">70</span>
<span class="s0">inline unsigned int CollisionFloorMesh::get_num_triangles(void) const;</span>

<span class="s0">420 12 get_triangle 0 4 608 32 CollisionFloorMesh::get_triangle 0 1 132 0</span>
<span class="s0">75</span>
<span class="s0">inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const;</span>

<span class="s0">421 14 get_class_type 0 4 608 34 CollisionFloorMesh::get_class_type 0 1 133 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle CollisionFloorMesh::get_class_type(void);</span>

<span class="s0">422 19 ~CollisionFloorMesh 0 516 608 39 CollisionFloorMesh::~CollisionFloorMesh 0 0 0</span>
<span class="s0">46</span>
<span class="s0">CollisionFloorMesh::~CollisionFloorMesh(void);</span>

<span class="s0">423 16 CollisionPolygon 0 260 610 34 CollisionPolygon::CollisionPolygon 0 2 134 135 127</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an invalid polygon.  Only used when reading from a bam file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">225</span>
<span class="s0">inline CollisionPolygon::CollisionPolygon(LVecBase3 const &amp;a, LVecBase3 const &amp;b, LVecBase3 const &amp;c);</span>
<span class="s0">inline CollisionPolygon::CollisionPolygon(LVecBase3 const &amp;a, LVecBase3 const &amp;b, LVecBase3 const &amp;c, LVecBase3 const &amp;d);</span>

<span class="s0">424 14 get_num_points 0 4 610 32 CollisionPolygon::get_num_points 0 1 136 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertices of the CollisionPolygon.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t CollisionPolygon::get_num_points(void) const;</span>

<span class="s0">425 9 get_point 0 4 610 27 CollisionPolygon::get_point 0 1 137 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint3 CollisionPolygon::get_point(std::size_t n) const;</span>

<span class="s0">426 13 verify_points 0 4 610 31 CollisionPolygon::verify_points 0 2 138 139 676</span>
<span class="s0">/**</span>
 <span class="s0">* Verifies that the indicated set of points will define a valid</span>
 <span class="s0">* CollisionPolygon: that is, at least three non-collinear points, with no</span>
 <span class="s0">* points repeated.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Verifies that the indicated set of points will define a valid</span>
 <span class="s0">* CollisionPolygon: that is, at least three non-collinear points, with no</span>
 <span class="s0">* points repeated.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Verifies that the indicated set of points will define a valid</span>
 <span class="s0">* CollisionPolygon: that is, at least three non-collinear points, with no</span>
 <span class="s0">* points repeated.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not check that the polygon defined is convex; that check is made</span>
 <span class="s0">* later, once we have projected the points to 2-d space where the decision is</span>
 <span class="s0">* easier.</span>
 <span class="s0">*/</span>
<span class="s0">229</span>
<span class="s0">static inline bool CollisionPolygon::verify_points(LPoint3 const &amp;a, LPoint3 const &amp;b, LPoint3 const &amp;c);</span>
<span class="s0">static inline bool CollisionPolygon::verify_points(LPoint3 const &amp;a, LPoint3 const &amp;b, LPoint3 const &amp;c, LPoint3 const &amp;d);</span>

<span class="s0">427 8 is_valid 0 4 610 26 CollisionPolygon::is_valid 0 1 140 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the CollisionPolygon is valid (that is, it has at least</span>
 <span class="s0">* three vertices), or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">bool CollisionPolygon::is_valid(void) const;</span>

<span class="s0">428 10 is_concave 0 4 610 28 CollisionPolygon::is_concave 0 1 141 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the CollisionPolygon appears to be concave, or false if it</span>
 <span class="s0">* is safely convex.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">bool CollisionPolygon::is_concave(void) const;</span>

<span class="s0">429 14 get_class_type 0 4 610 32 CollisionPolygon::get_class_type 0 1 142 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle CollisionPolygon::get_class_type(void);</span>

<span class="s0">430 17 ~CollisionPolygon 0 516 610 35 CollisionPolygon::~CollisionPolygon 0 0 0</span>
<span class="s0">42</span>
<span class="s0">CollisionPolygon::~CollisionPolygon(void);</span>

<span class="s0">431 21 CollisionHandlerEvent 0 260 611 44 CollisionHandlerEvent::CollisionHandlerEvent 0 2 143 144 168</span>
<span class="s0">/**</span>
 <span class="s0">* The default CollisionHandlerEvent will throw no events.  Its pattern</span>
 <span class="s0">* strings must first be set via a call to add_in_pattern() and/or</span>
 <span class="s0">* add_out_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">CollisionHandlerEvent::CollisionHandlerEvent(void);</span>
<span class="s0">inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &amp;) = default;</span>

<span class="s0">432 17 clear_in_patterns 0 4 611 40 CollisionHandlerEvent::clear_in_patterns 0 1 145 80</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the previously-added in patterns.  See add_in_pattern.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void CollisionHandlerEvent::clear_in_patterns(void);</span>

<span class="s0">433 14 add_in_pattern 0 4 611 37 CollisionHandlerEvent::add_in_pattern 0 1 146 1586</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a pattern string to the list of events that will be generated in</span>
 <span class="s0">* response to a collision.  The pattern string describes how the event name</span>
 <span class="s0">* will be composed.  It is a string that may contain any of the following:</span>
 <span class="s0">*</span>
 <span class="s0">* %fn  - the name of the &quot;from&quot; object's node %in  - the name of the &quot;into&quot;</span>
 <span class="s0">* object's node %fs  - 't' if &quot;from&quot; is tangible, 'i' if intangible %is  -</span>
 <span class="s0">* 't' if &quot;into&quot; is tangible, 'i' if intangible %ig  - 'c' if the collision is</span>
 <span class="s0">* into a CollisionNode, 'g' if it is a geom.</span>
 <span class="s0">*</span>
 <span class="s0">* %(tag)fh - generate event only if &quot;from&quot; node has the indicated net tag.</span>
 <span class="s0">* %(tag)fx - generate event only if &quot;from&quot; node does not have the indicated</span>
 <span class="s0">* net tag.  %(tag)ih - generate event only if &quot;into&quot; node has the indicated</span>
 <span class="s0">* net tag.  %(tag)ix - generate event only if &quot;into&quot; node does not have the</span>
 <span class="s0">* indicated net tag.  %(tag)ft - the indicated net tag value of the &quot;from&quot;</span>
 <span class="s0">* node.  %(tag)it - the indicated net tag value of the &quot;into&quot; node.</span>
 <span class="s0">*</span>
 <span class="s0">* Parentheses in the above are literal and should be included in the actual</span>
 <span class="s0">* pattern.</span>
 <span class="s0">*</span>
 <span class="s0">* The event name will be based on the in_pattern string specified here, with</span>
 <span class="s0">* all occurrences of the above strings replaced with the corresponding</span>
 <span class="s0">* values.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, the in_pattern event is thrown on the first detection of a</span>
 <span class="s0">* collision between two particular nodes.  In subsequent passes, as long as a</span>
 <span class="s0">* collision between those two nodes continues to be detected each frame, the</span>
 <span class="s0">* again_pattern is thrown.  The first frame in which the collision is no</span>
 <span class="s0">* longer detected, the out_pattern event is thrown.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline void CollisionHandlerEvent::add_in_pattern(std::string const &amp;in_pattern);</span>

<span class="s0">434 14 set_in_pattern 0 4 611 37 CollisionHandlerEvent::set_in_pattern 0 1 147 189</span>
<span class="s0">/**</span>
 <span class="s0">* This method is deprecated; it completely replaces all the in patterns that</span>
 <span class="s0">* have previously been set with the indicated pattern.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_in_pattern() instead.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline void CollisionHandlerEvent::set_in_pattern(std::string const &amp;in_pattern);</span>

<span class="s0">435 19 get_num_in_patterns 0 4 611 42 CollisionHandlerEvent::get_num_in_patterns 0 1 148 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of in pattern strings that have been added.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline int CollisionHandlerEvent::get_num_in_patterns(void) const;</span>

<span class="s0">436 14 get_in_pattern 0 4 611 37 CollisionHandlerEvent::get_in_pattern 0 1 149 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth pattern string that indicates how the event names are</span>
 <span class="s0">* generated for each collision detected.  See add_in_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline std::string CollisionHandlerEvent::get_in_pattern(int n) const;</span>

<span class="s0">437 20 clear_again_patterns 0 4 611 43 CollisionHandlerEvent::clear_again_patterns 0 1 150 83</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the previously-added in patterns.  See add_again_pattern.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void CollisionHandlerEvent::clear_again_patterns(void);</span>

<span class="s0">438 17 add_again_pattern 0 4 611 40 CollisionHandlerEvent::add_again_pattern 0 1 151 649</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a collision between two particular nodes is *still* detected.  This</span>
 <span class="s0">* event is thrown each consecutive time a collision between two particular</span>
 <span class="s0">* nodes is detected, starting with the second time.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, the in_pattern event is thrown on the first detection of a</span>
 <span class="s0">* collision between two particular nodes.  In subsequent passes, as long as a</span>
 <span class="s0">* collision between those two nodes continues to be detected each frame, the</span>
 <span class="s0">* again_pattern is thrown.  The first frame in which the collision is no</span>
 <span class="s0">* longer detected, the out_pattern event is thrown.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void CollisionHandlerEvent::add_again_pattern(std::string const &amp;again_pattern);</span>

<span class="s0">439 17 set_again_pattern 0 4 611 40 CollisionHandlerEvent::set_again_pattern 0 1 152 192</span>
<span class="s0">/**</span>
 <span class="s0">* This method is deprecated; it completely replaces all the in patterns that</span>
 <span class="s0">* have previously been set with the indicated pattern.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_again_pattern() instead.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void CollisionHandlerEvent::set_again_pattern(std::string const &amp;again_pattern);</span>

<span class="s0">440 22 get_num_again_patterns 0 4 611 45 CollisionHandlerEvent::get_num_again_patterns 0 1 153 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of in pattern strings that have been added.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline int CollisionHandlerEvent::get_num_again_patterns(void) const;</span>

<span class="s0">441 17 get_again_pattern 0 4 611 40 CollisionHandlerEvent::get_again_pattern 0 1 154 148</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth pattern string that indicates how the event names are</span>
 <span class="s0">* generated for each collision detected.  See add_again_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline std::string CollisionHandlerEvent::get_again_pattern(int n) const;</span>

<span class="s0">442 18 clear_out_patterns 0 4 611 41 CollisionHandlerEvent::clear_out_patterns 0 1 155 81</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the previously-added in patterns.  See add_out_pattern.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void CollisionHandlerEvent::clear_out_patterns(void);</span>

<span class="s0">443 15 add_out_pattern 0 4 611 38 CollisionHandlerEvent::add_out_pattern 0 1 156 518</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a collision between two particular nodes is *no longer* detected.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, the in_pattern event is thrown on the first detection of a</span>
 <span class="s0">* collision between two particular nodes.  In subsequent passes, as long as a</span>
 <span class="s0">* collision between those two nodes continues to be detected each frame, the</span>
 <span class="s0">* again_pattern is thrown.  The first frame in which the collision is no</span>
 <span class="s0">* longer detected, the out_pattern event is thrown.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void CollisionHandlerEvent::add_out_pattern(std::string const &amp;out_pattern);</span>

<span class="s0">444 15 set_out_pattern 0 4 611 38 CollisionHandlerEvent::set_out_pattern 0 1 157 190</span>
<span class="s0">/**</span>
 <span class="s0">* This method is deprecated; it completely replaces all the in patterns that</span>
 <span class="s0">* have previously been set with the indicated pattern.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_out_pattern() instead.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void CollisionHandlerEvent::set_out_pattern(std::string const &amp;out_pattern);</span>

<span class="s0">445 20 get_num_out_patterns 0 4 611 43 CollisionHandlerEvent::get_num_out_patterns 0 1 158 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of in pattern strings that have been added.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline int CollisionHandlerEvent::get_num_out_patterns(void) const;</span>

<span class="s0">446 15 get_out_pattern 0 4 611 38 CollisionHandlerEvent::get_out_pattern 0 1 159 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth pattern string that indicates how the event names are</span>
 <span class="s0">* generated for each collision detected.  See add_out_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline std::string CollisionHandlerEvent::get_out_pattern(int n) const;</span>

<span class="s0">447 5 clear 0 4 611 28 CollisionHandlerEvent::clear 0 1 160 541</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the list of elements that all colliders are known to be colliding</span>
 <span class="s0">* with.  No &quot;out&quot; events will be thrown; if the same collision is detected</span>
 <span class="s0">* next frame, a new &quot;in&quot; event will be thrown for each collision.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be called each frame to defeat the persistent &quot;in&quot; event</span>
 <span class="s0">* mechanism, which prevents the same &quot;in&quot; event from being thrown repeatedly.</span>
 <span class="s0">* However, also see add_again_pattern(), which can be used to set the event</span>
 <span class="s0">* that is thrown when a collision is detected for two or more consecutive</span>
 <span class="s0">* frames.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void CollisionHandlerEvent::clear(void);</span>

<span class="s0">448 5 flush 0 4 611 28 CollisionHandlerEvent::flush 0 1 161 58</span>
<span class="s0">/**</span>
 <span class="s0">* Same as clear() except &quot;out&quot; events are thrown.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void CollisionHandlerEvent::flush(void);</span>

<span class="s0">449 10 __reduce__ 0 4 611 33 CollisionHandlerEvent::__reduce__ 0 1 162 46</span>
<span class="s0">// These help implement Python pickle support.</span>
<span class="s0">66</span>
<span class="s0">PyObject *CollisionHandlerEvent::__reduce__(PyObject *self) const;</span>

<span class="s0">450 12 __setstate__ 0 4 611 35 CollisionHandlerEvent::__setstate__ 0 1 163 0</span>
<span class="s0">76</span>
<span class="s0">void CollisionHandlerEvent::__setstate__(PyObject *self, vector_uchar data);</span>

<span class="s0">451 14 write_datagram 0 4 611 37 CollisionHandlerEvent::write_datagram 0 1 164 63</span>
<span class="s0">/**</span>
 <span class="s0">* Serializes this object, to implement pickle support.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void CollisionHandlerEvent::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">452 13 read_datagram 0 4 611 36 CollisionHandlerEvent::read_datagram 0 1 165 104</span>
<span class="s0">/**</span>
 <span class="s0">* Restores the object state from the given datagram, previously obtained using</span>
 <span class="s0">* __getstate__.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void CollisionHandlerEvent::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">453 14 get_class_type 0 4 611 37 CollisionHandlerEvent::get_class_type 0 1 166 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle CollisionHandlerEvent::get_class_type(void);</span>

<span class="s0">454 22 ~CollisionHandlerEvent 0 516 611 45 CollisionHandlerEvent::~CollisionHandlerEvent 0 0 0</span>
<span class="s0">52</span>
<span class="s0">CollisionHandlerEvent::~CollisionHandlerEvent(void);</span>

<span class="s0">455 12 add_collider 0 4 614 38 CollisionHandlerPhysical::add_collider 0 2 167 168 556</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new collider to the list with a NodePath that will be updated with</span>
 <span class="s0">* the collider's new position, or updates the existing collider with a new</span>
 <span class="s0">* NodePath object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new collider to the list with a NodePath that will be updated with</span>
 <span class="s0">* the collider's new position, or updates the existing collider with a new</span>
 <span class="s0">* NodePath object.</span>
 <span class="s0">*</span>
 <span class="s0">* The indicated DriveInterface will also be updated with the target's new</span>
 <span class="s0">* transform each frame.  This method should be used when the target is</span>
 <span class="s0">* directly controlled by a DriveInterface.</span>
 <span class="s0">*/</span>
<span class="s0">222</span>
<span class="s0">void CollisionHandlerPhysical::add_collider(NodePath const &amp;collider, NodePath const &amp;target);</span>
<span class="s0">void CollisionHandlerPhysical::add_collider(NodePath const &amp;collider, NodePath const &amp;target, DriveInterface *drive_interface);</span>

<span class="s0">456 15 remove_collider 0 4 614 41 CollisionHandlerPhysical::remove_collider 0 1 169 92</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the collider from the list of colliders that this handler knows</span>
 <span class="s0">* about.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">bool CollisionHandlerPhysical::remove_collider(NodePath const &amp;collider);</span>

<span class="s0">457 12 has_collider 0 4 614 38 CollisionHandlerPhysical::has_collider 0 1 170 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the handler knows about the indicated collider, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">bool CollisionHandlerPhysical::has_collider(NodePath const &amp;collider) const;</span>

<span class="s0">458 15 clear_colliders 0 4 614 41 CollisionHandlerPhysical::clear_colliders 0 1 171 77</span>
<span class="s0">/**</span>
 <span class="s0">* Completely empties the list of colliders this handler knows about.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void CollisionHandlerPhysical::clear_colliders(void);</span>

<span class="s0">459 10 set_center 0 4 614 36 CollisionHandlerPhysical::set_center 0 1 172 269</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies an arbitrary NodePath that the handler is always considered to be</span>
 <span class="s0">* facing.  It does not detect collisions with surfaces that appear to be</span>
 <span class="s0">* facing away from this NodePath.  This works best when the collision</span>
 <span class="s0">* surfaces in question are polygons.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void CollisionHandlerPhysical::set_center(NodePath const &amp;center);</span>

<span class="s0">460 12 clear_center 0 4 614 38 CollisionHandlerPhysical::clear_center 0 1 173 64</span>
<span class="s0">/**</span>
 <span class="s0">* Clears the center NodePath specified with set_center.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void CollisionHandlerPhysical::clear_center(void);</span>

<span class="s0">461 10 get_center 0 4 614 36 CollisionHandlerPhysical::get_center 0 1 174 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath specified with set_center, or the empty NodePath if</span>
 <span class="s0">* nothing has been specified.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline NodePath const &amp;CollisionHandlerPhysical::get_center(void) const;</span>

<span class="s0">462 10 has_center 0 4 614 36 CollisionHandlerPhysical::has_center 0 1 175 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a NodePath has been specified with set_center(), false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool CollisionHandlerPhysical::has_center(void) const;</span>

<span class="s0">463 11 has_contact 0 4 614 37 CollisionHandlerPhysical::has_contact 0 1 176 255</span>
<span class="s0">/**</span>
 <span class="s0">* Did the handler make any contacts with anything on the last collision pass?</span>
 <span class="s0">* Depending on how your world is setup, this can be used to tell if the</span>
 <span class="s0">* handler is out of the world (i.e.  out of bounds). That is the original use</span>
 <span class="s0">* of this call.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool CollisionHandlerPhysical::has_contact(void) const;</span>

<span class="s0">464 10 __reduce__ 0 4 614 36 CollisionHandlerPhysical::__reduce__ 0 1 177 0</span>
<span class="s0">69</span>
<span class="s0">PyObject *CollisionHandlerPhysical::__reduce__(PyObject *self) const;</span>

<span class="s0">465 12 __setstate__ 0 4 614 38 CollisionHandlerPhysical::__setstate__ 0 1 178 0</span>
<span class="s0">100</span>
<span class="s0">void CollisionHandlerPhysical::__setstate__(PyObject *self, vector_uchar data, PyObject *nodepaths);</span>

<span class="s0">466 14 get_class_type 0 4 614 40 CollisionHandlerPhysical::get_class_type 0 1 179 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle CollisionHandlerPhysical::get_class_type(void);</span>

<span class="s0">467 21 CollisionHandlerFloor 0 260 616 44 CollisionHandlerFloor::CollisionHandlerFloor 0 1 180 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">CollisionHandlerFloor::CollisionHandlerFloor(void);</span>

<span class="s0">468 10 set_offset 0 4 616 33 CollisionHandlerFloor::set_offset 0 1 181 166</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the linear offset to add to (or subtract from) the highest detected</span>
 <span class="s0">* collision point to determine the actual height at which to set the</span>
 <span class="s0">* collider.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset);</span>

<span class="s0">469 10 get_offset 0 4 616 33 CollisionHandlerFloor::get_offset 0 1 182 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the linear offset to add to (or subtract from) the highest detected</span>
 <span class="s0">* collision point to determine the actual height at which to set the</span>
 <span class="s0">* collider.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const;</span>

<span class="s0">470 9 set_reach 0 4 616 32 CollisionHandlerFloor::set_reach 0 1 183 82</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the reach to add to (or subtract from) the highest collision point</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach);</span>

<span class="s0">471 9 get_reach 0 4 616 32 CollisionHandlerFloor::get_reach 0 1 184 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the reach to add to (or subtract from) the highest collision point</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const;</span>

<span class="s0">472 16 set_max_velocity 0 4 616 39 CollisionHandlerFloor::set_max_velocity 0 1 185 199</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the maximum speed at which the object will be allowed to descend</span>
 <span class="s0">* towards a floor below it, in units per second.  Set this to zero to allow</span>
 <span class="s0">* it to instantly teleport any distance.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel);</span>

<span class="s0">473 16 get_max_velocity 0 4 616 39 CollisionHandlerFloor::get_max_velocity 0 1 186 160</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the maximum speed at which the object will be allowed to descend</span>
 <span class="s0">* towards a floor below it, in units per second.  See set_max_velocity().</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const;</span>

<span class="s0">474 14 write_datagram 0 4 616 37 CollisionHandlerFloor::write_datagram 0 1 187 63</span>
<span class="s0">/**</span>
 <span class="s0">* Serializes this object, to implement pickle support.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void CollisionHandlerFloor::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">475 13 read_datagram 0 4 616 36 CollisionHandlerFloor::read_datagram 0 1 188 104</span>
<span class="s0">/**</span>
 <span class="s0">* Restores the object state from the given datagram, previously obtained using</span>
 <span class="s0">* __getstate__.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void CollisionHandlerFloor::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">476 14 get_class_type 0 4 616 37 CollisionHandlerFloor::get_class_type 0 1 189 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle CollisionHandlerFloor::get_class_type(void);</span>

<span class="s0">477 22 CollisionHandlerPusher 0 260 617 46 CollisionHandlerPusher::CollisionHandlerPusher 0 1 190 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">CollisionHandlerPusher::CollisionHandlerPusher(void);</span>

<span class="s0">478 14 set_horizontal 0 4 617 38 CollisionHandlerPusher::set_horizontal 0 1 191 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void CollisionHandlerPusher::set_horizontal(bool flag);</span>

<span class="s0">479 14 get_horizontal 0 4 617 38 CollisionHandlerPusher::get_horizontal 0 1 192 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline bool CollisionHandlerPusher::get_horizontal(void) const;</span>

<span class="s0">480 14 write_datagram 0 4 617 38 CollisionHandlerPusher::write_datagram 0 1 193 63</span>
<span class="s0">/**</span>
 <span class="s0">* Serializes this object, to implement pickle support.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">void CollisionHandlerPusher::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">481 13 read_datagram 0 4 617 37 CollisionHandlerPusher::read_datagram 0 1 194 104</span>
<span class="s0">/**</span>
 <span class="s0">* Restores the object state from the given datagram, previously obtained using</span>
 <span class="s0">* __getstate__.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void CollisionHandlerPusher::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">482 14 get_class_type 0 4 617 38 CollisionHandlerPusher::get_class_type 0 1 195 0</span>
<span class="s0">63</span>
<span class="s0">static TypeHandle CollisionHandlerPusher::get_class_type(void);</span>

<span class="s0">483 27 CollisionHandlerFluidPusher 0 260 618 56 CollisionHandlerFluidPusher::CollisionHandlerFluidPusher 0 1 196 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void);</span>

<span class="s0">484 14 get_class_type 0 4 618 43 CollisionHandlerFluidPusher::get_class_type 0 1 197 0</span>
<span class="s0">68</span>
<span class="s0">static TypeHandle CollisionHandlerFluidPusher::get_class_type(void);</span>

<span class="s0">485 28 ~CollisionHandlerFluidPusher 0 516 618 57 CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher 0 0 0</span>
<span class="s0">64</span>
<span class="s0">CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher(void);</span>

<span class="s0">486 23 CollisionHandlerGravity 0 260 619 48 CollisionHandlerGravity::CollisionHandlerGravity 0 1 198 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">CollisionHandlerGravity::CollisionHandlerGravity(void);</span>

<span class="s0">487 10 set_offset 0 4 619 35 CollisionHandlerGravity::set_offset 0 1 199 166</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the linear offset to add to (or subtract from) the highest detected</span>
 <span class="s0">* collision point to determine the actual height at which to set the</span>
 <span class="s0">* collider.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset);</span>

<span class="s0">488 10 get_offset 0 4 619 35 CollisionHandlerGravity::get_offset 0 1 200 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the linear offset to add to (or subtract from) the highest detected</span>
 <span class="s0">* collision point to determine the actual height at which to set the</span>
 <span class="s0">* collider.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const;</span>

<span class="s0">489 9 set_reach 0 4 619 34 CollisionHandlerGravity::set_reach 0 1 201 82</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the reach to add to (or subtract from) the highest collision point</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach);</span>

<span class="s0">490 9 get_reach 0 4 619 34 CollisionHandlerGravity::get_reach 0 1 202 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the reach to add to (or subtract from) the highest collision point</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const;</span>

<span class="s0">491 19 get_airborne_height 0 4 619 44 CollisionHandlerGravity::get_airborne_height 0 1 203 202</span>
<span class="s0">/**</span>
 <span class="s0">* Return the height of the object from the ground.</span>
 <span class="s0">*</span>
 <span class="s0">* The object might not necessarily be at rest.  Use is_on_ground() if you</span>
 <span class="s0">* want to know whether the object is on the ground and at rest.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const;</span>

<span class="s0">492 12 is_on_ground 0 4 619 37 CollisionHandlerGravity::is_on_ground 0 1 204 33</span>
<span class="s0">/**</span>
 <span class="s0">* Is the object at rest?</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool CollisionHandlerGravity::is_on_ground(void) const;</span>

<span class="s0">493 19 get_impact_velocity 0 4 619 44 CollisionHandlerGravity::get_impact_velocity 0 1 205 283</span>
<span class="s0">/**</span>
 <span class="s0">* How hard did the object hit the ground.  This value is set on impact with</span>
 <span class="s0">* the ground.  You may want to watch (poll) on is_on_ground() and when that is</span>
 <span class="s0">* true, call get_impact_velocity(). Normally I avoid polling, but we are</span>
 <span class="s0">* calling is_on_ground() frequently anyway.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const;</span>

<span class="s0">494 18 get_contact_normal 0 4 619 43 CollisionHandlerGravity::get_contact_normal 0 1 206 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline LVector3 const &amp;CollisionHandlerGravity::get_contact_normal(void) const;</span>

<span class="s0">495 12 add_velocity 0 4 619 37 CollisionHandlerGravity::add_velocity 0 1 207 184</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the sepcified amount to the current velocity.  This is mostly here</span>
 <span class="s0">* allow this common operation to be faster for scripting, but it's also more</span>
 <span class="s0">* concise even in cpp.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity);</span>

<span class="s0">496 12 set_velocity 0 4 619 37 CollisionHandlerGravity::set_velocity 0 1 208 46</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the current vertical velocity.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity);</span>

<span class="s0">497 12 get_velocity 0 4 619 37 CollisionHandlerGravity::get_velocity 0 1 209 354</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the current vertical velocity.</span>
 <span class="s0">*</span>
 <span class="s0">* Generally, negative values mean the object is in free fall; while postive</span>
 <span class="s0">* values mean the object has vertical thrust.</span>
 <span class="s0">*</span>
 <span class="s0">* A zero value does not necessarily mean the object on the ground, it may</span>
 <span class="s0">* also be weightless and/or at the apex of its jump.</span>
 <span class="s0">*</span>
 <span class="s0">* See Also: is_on_ground() and get_gravity()</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const;</span>

<span class="s0">498 11 set_gravity 0 4 619 36 CollisionHandlerGravity::set_gravity 0 1 210 56</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the linear gravity force (always plumb).</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity);</span>

<span class="s0">499 11 get_gravity 0 4 619 36 CollisionHandlerGravity::get_gravity 0 1 211 56</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the linear gravity force (always plumb).</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const;</span>

<span class="s0">500 16 set_max_velocity 0 4 619 41 CollisionHandlerGravity::set_max_velocity 0 1 212 199</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the maximum speed at which the object will be allowed to descend</span>
 <span class="s0">* towards a floor below it, in units per second.  Set this to zero to allow</span>
 <span class="s0">* it to instantly teleport any distance.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel);</span>

<span class="s0">501 16 get_max_velocity 0 4 619 41 CollisionHandlerGravity::get_max_velocity 0 1 213 160</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the maximum speed at which the object will be allowed to descend</span>
 <span class="s0">* towards a floor below it, in units per second.  See set_max_velocity().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const;</span>

<span class="s0">502 15 set_legacy_mode 0 4 619 40 CollisionHandlerGravity::set_legacy_mode 0 1 214 229</span>
<span class="s0">/**</span>
 <span class="s0">* Enables old behavior required by Toontown (Sellbot Factory lava room is</span>
 <span class="s0">* good test case, lava and conveyor belt specifically). Behavior is to throw</span>
 <span class="s0">* enter/exit events only for floor that the toon is in contact with</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode);</span>

<span class="s0">503 15 get_legacy_mode 0 4 619 40 CollisionHandlerGravity::get_legacy_mode 0 1 215 49</span>
<span class="s0">/**</span>
 <span class="s0">* returns true if legacy mode is enabled</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool CollisionHandlerGravity::get_legacy_mode(void) const;</span>

<span class="s0">504 14 write_datagram 0 4 619 39 CollisionHandlerGravity::write_datagram 0 1 216 63</span>
<span class="s0">/**</span>
 <span class="s0">* Serializes this object, to implement pickle support.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void CollisionHandlerGravity::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">505 13 read_datagram 0 4 619 38 CollisionHandlerGravity::read_datagram 0 1 217 104</span>
<span class="s0">/**</span>
 <span class="s0">* Restores the object state from the given datagram, previously obtained using</span>
 <span class="s0">* __getstate__.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void CollisionHandlerGravity::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">506 14 get_class_type 0 4 619 39 CollisionHandlerGravity::get_class_type 0 1 218 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle CollisionHandlerGravity::get_class_type(void);</span>

<span class="s0">507 28 CollisionHandlerHighestEvent 0 260 621 58 CollisionHandlerHighestEvent::CollisionHandlerHighestEvent 0 2 219 220 168</span>
<span class="s0">/**</span>
 <span class="s0">* The default CollisionHandlerEvent will throw no events.  Its pattern</span>
 <span class="s0">* strings must first be set via a call to add_in_pattern() and/or</span>
 <span class="s0">* add_out_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">180</span>
<span class="s0">CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void);</span>
<span class="s0">inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &amp;) = default;</span>

<span class="s0">508 14 get_class_type 0 4 621 44 CollisionHandlerHighestEvent::get_class_type 0 1 221 0</span>
<span class="s0">69</span>
<span class="s0">static TypeHandle CollisionHandlerHighestEvent::get_class_type(void);</span>

<span class="s0">509 29 ~CollisionHandlerHighestEvent 0 516 621 59 CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent 0 0 0</span>
<span class="s0">66</span>
<span class="s0">CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent(void);</span>

<span class="s0">510 21 CollisionHandlerQueue 0 260 622 44 CollisionHandlerQueue::CollisionHandlerQueue 0 2 222 223 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">CollisionHandlerQueue::CollisionHandlerQueue(void);</span>
<span class="s0">inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &amp;) = default;</span>

<span class="s0">511 12 sort_entries 0 4 622 35 CollisionHandlerQueue::sort_entries 0 1 224 257</span>
<span class="s0">/**</span>
 <span class="s0">* Sorts all the detected collisions front-to-back by</span>
 <span class="s0">* from_intersection_point() so that those intersection points closest to the</span>
 <span class="s0">* collider's origin (e.g., the center of the CollisionSphere, or the point_a</span>
 <span class="s0">* of a CollisionSegment) appear first.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void CollisionHandlerQueue::sort_entries(void);</span>

<span class="s0">512 13 clear_entries 0 4 622 36 CollisionHandlerQueue::clear_entries 0 1 225 50</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the entries from the queue.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void CollisionHandlerQueue::clear_entries(void);</span>

<span class="s0">513 15 get_num_entries 0 4 622 38 CollisionHandlerQueue::get_num_entries 0 1 226 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of CollisionEntries detected last pass.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">int CollisionHandlerQueue::get_num_entries(void) const;</span>

<span class="s0">514 9 get_entry 0 4 622 32 CollisionHandlerQueue::get_entry 0 1 227 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth CollisionEntry detected last pass.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">CollisionEntry *CollisionHandlerQueue::get_entry(int n) const;</span>

<span class="s0">515 6 output 0 4 622 29 CollisionHandlerQueue::output 0 1 228 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void CollisionHandlerQueue::output(std::ostream &amp;out) const;</span>

<span class="s0">516 5 write 0 4 622 28 CollisionHandlerQueue::write 0 1 229 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">void CollisionHandlerQueue::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">517 10 __reduce__ 0 4 622 33 CollisionHandlerQueue::__reduce__ 0 1 230 0</span>
<span class="s0">66</span>
<span class="s0">PyObject *CollisionHandlerQueue::__reduce__(PyObject *self) const;</span>

<span class="s0">518 14 get_class_type 0 4 622 37 CollisionHandlerQueue::get_class_type 0 1 231 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle CollisionHandlerQueue::get_class_type(void);</span>

<span class="s0">519 22 ~CollisionHandlerQueue 0 516 622 45 CollisionHandlerQueue::~CollisionHandlerQueue 0 0 0</span>
<span class="s0">52</span>
<span class="s0">CollisionHandlerQueue::~CollisionHandlerQueue(void);</span>

<span class="s0">520 15 CollisionSphere 0 260 624 32 CollisionSphere::CollisionSphere 0 2 232 233 114</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an invalid sphere.  Only used when reading from a bam file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">210</span>
<span class="s0">inline explicit CollisionSphere::CollisionSphere(LPoint3 const &amp;center, PN_stdfloat radius);</span>
<span class="s0">inline explicit CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);</span>

<span class="s0">521 10 set_center 0 4 624 27 CollisionSphere::set_center 0 2 234 235 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">inline void CollisionSphere::set_center(LPoint3 const &amp;center);</span>
<span class="s0">inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">522 10 get_center 0 4 624 27 CollisionSphere::get_center 0 1 236 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LPoint3 const &amp;CollisionSphere::get_center(void) const;</span>

<span class="s0">523 10 set_radius 0 4 624 27 CollisionSphere::set_radius 0 1 237 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void CollisionSphere::set_radius(PN_stdfloat radius);</span>

<span class="s0">524 10 get_radius 0 4 624 27 CollisionSphere::get_radius 0 1 238 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PN_stdfloat CollisionSphere::get_radius(void) const;</span>

<span class="s0">525 14 get_class_type 0 4 624 31 CollisionSphere::get_class_type 0 1 239 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle CollisionSphere::get_class_type(void);</span>

<span class="s0">526 16 ~CollisionSphere 0 516 624 33 CollisionSphere::~CollisionSphere 0 0 0</span>
<span class="s0">40</span>
<span class="s0">CollisionSphere::~CollisionSphere(void);</span>

<span class="s0">527 18 CollisionInvSphere 0 260 625 38 CollisionInvSphere::CollisionInvSphere 0 2 240 241 114</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an invalid sphere.  Only used when reading from a bam file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">222</span>
<span class="s0">inline explicit CollisionInvSphere::CollisionInvSphere(LPoint3 const &amp;center, PN_stdfloat radius);</span>
<span class="s0">inline explicit CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);</span>

<span class="s0">528 14 get_class_type 0 4 625 34 CollisionInvSphere::get_class_type 0 1 242 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle CollisionInvSphere::get_class_type(void);</span>

<span class="s0">529 19 ~CollisionInvSphere 0 516 625 39 CollisionInvSphere::~CollisionInvSphere 0 0 0</span>
<span class="s0">46</span>
<span class="s0">CollisionInvSphere::~CollisionInvSphere(void);</span>

<span class="s0">530 12 CollisionRay 0 260 626 26 CollisionRay::CollisionRay 0 3 243 244 245 219</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an invalid ray.  This isn't terribly useful; it's expected that the</span>
 <span class="s0">* user will subsequently adjust the ray via set_origin()/set_direction() or</span>
 <span class="s0">* set_from_lens().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">274</span>
<span class="s0">inline CollisionRay::CollisionRay(void);</span>
<span class="s0">inline explicit CollisionRay::CollisionRay(LPoint3 const &amp;origin, LVector3 const &amp;direction);</span>
<span class="s0">inline explicit CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);</span>

<span class="s0">531 10 set_origin 0 4 626 24 CollisionRay::set_origin 0 2 246 247 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void CollisionRay::set_origin(LPoint3 const &amp;origin);</span>
<span class="s0">inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">532 10 get_origin 0 4 626 24 CollisionRay::get_origin 0 1 248 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline LPoint3 const &amp;CollisionRay::get_origin(void) const;</span>

<span class="s0">533 13 set_direction 0 4 626 27 CollisionRay::set_direction 0 2 249 250 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">inline void CollisionRay::set_direction(LVector3 const &amp;direction);</span>
<span class="s0">inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">534 13 get_direction 0 4 626 27 CollisionRay::get_direction 0 1 251 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LVector3 const &amp;CollisionRay::get_direction(void) const;</span>

<span class="s0">535 13 set_from_lens 0 4 626 27 CollisionRay::set_from_lens 0 2 252 253 591</span>
<span class="s0">/**</span>
 <span class="s0">* Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the</span>
 <span class="s0">* CollisionRay so that it begins at the LensNode's near plane and extends to</span>
 <span class="s0">* infinity, making it suitable for picking objects from the screen given a</span>
 <span class="s0">* camera and a mouse location.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the</span>
 <span class="s0">* CollisionRay so that it begins at the LensNode's near plane and extends to</span>
 <span class="s0">* infinity, making it suitable for picking objects from the screen given a</span>
 <span class="s0">* camera and a mouse location.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the point was acceptable, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">164</span>
<span class="s0">bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &amp;point);</span>
<span class="s0">inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);</span>

<span class="s0">536 14 get_class_type 0 4 626 28 CollisionRay::get_class_type 0 1 254 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle CollisionRay::get_class_type(void);</span>

<span class="s0">537 13 ~CollisionRay 0 516 626 27 CollisionRay::~CollisionRay 0 0 0</span>
<span class="s0">34</span>
<span class="s0">CollisionRay::~CollisionRay(void);</span>

<span class="s0">538 13 CollisionLine 0 260 627 28 CollisionLine::CollisionLine 0 3 255 256 257 221</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an invalid line.  This isn't terribly useful; it's expected that</span>
 <span class="s0">* the user will subsequently adjust the line via set_origin()/set_direction()</span>
 <span class="s0">* or set_from_lens().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">280</span>
<span class="s0">inline CollisionLine::CollisionLine(void);</span>
<span class="s0">inline explicit CollisionLine::CollisionLine(LPoint3 const &amp;origin, LVector3 const &amp;direction);</span>
<span class="s0">inline explicit CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);</span>

<span class="s0">539 14 get_class_type 0 4 627 29 CollisionLine::get_class_type 0 1 258 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle CollisionLine::get_class_type(void);</span>

<span class="s0">540 14 ~CollisionLine 0 516 627 29 CollisionLine::~CollisionLine 0 0 0</span>
<span class="s0">36</span>
<span class="s0">CollisionLine::~CollisionLine(void);</span>

<span class="s0">541 17 CollisionParabola 0 260 628 36 CollisionParabola::CollisionParabola 0 2 259 260 163</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an invalid parabola.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a parabola with the endpoints between t1 and t2 in the parametric</span>
 <span class="s0">* space of the parabola.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">163</span>
<span class="s0">inline CollisionParabola::CollisionParabola(void);</span>
<span class="s0">inline explicit CollisionParabola::CollisionParabola(LParabola const &amp;parabola, PN_stdfloat t1, PN_stdfloat t2);</span>

<span class="s0">542 12 set_parabola 0 4 628 31 CollisionParabola::set_parabola 0 1 261 57</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the parabola specified by this solid.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void CollisionParabola::set_parabola(LParabola const &amp;parabola);</span>

<span class="s0">543 12 get_parabola 0 4 628 31 CollisionParabola::get_parabola 0 1 262 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the parabola specified by this solid.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LParabola const &amp;CollisionParabola::get_parabola(void) const;</span>

<span class="s0">544 6 set_t1 0 4 628 25 CollisionParabola::set_t1 0 1 263 54</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the starting point on the parabola.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void CollisionParabola::set_t1(PN_stdfloat t1);</span>

<span class="s0">545 6 get_t1 0 4 628 25 CollisionParabola::get_t1 0 1 264 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the starting point on the parabola.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat CollisionParabola::get_t1(void) const;</span>

<span class="s0">546 6 set_t2 0 4 628 25 CollisionParabola::set_t2 0 1 265 52</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the ending point on the parabola.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void CollisionParabola::set_t2(PN_stdfloat t2);</span>

<span class="s0">547 6 get_t2 0 4 628 25 CollisionParabola::get_t2 0 1 266 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ending point on the parabola.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat CollisionParabola::get_t2(void) const;</span>

<span class="s0">548 14 get_class_type 0 4 628 33 CollisionParabola::get_class_type 0 1 267 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle CollisionParabola::get_class_type(void);</span>

<span class="s0">549 18 ~CollisionParabola 0 516 628 37 CollisionParabola::~CollisionParabola 0 0 0</span>
<span class="s0">44</span>
<span class="s0">CollisionParabola::~CollisionParabola(void);</span>

<span class="s0">550 16 CollisionSegment 0 260 632 34 CollisionSegment::CollisionSegment 0 3 268 269 270 227</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an invalid segment.  This isn't terribly useful; it's expected that</span>
 <span class="s0">* the user will subsequently adjust the segment via</span>
 <span class="s0">* set_origin()/set_direction() or set_from_lens().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">285</span>
<span class="s0">inline CollisionSegment::CollisionSegment(void);</span>
<span class="s0">inline explicit CollisionSegment::CollisionSegment(LPoint3 const &amp;a, LPoint3 const &amp;db);</span>
<span class="s0">inline explicit CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz);</span>

<span class="s0">551 11 set_point_a 0 4 632 29 CollisionSegment::set_point_a 0 2 271 272 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline void CollisionSegment::set_point_a(LPoint3 const &amp;a);</span>
<span class="s0">inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">552 11 get_point_a 0 4 632 29 CollisionSegment::get_point_a 0 1 273 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint3 const &amp;CollisionSegment::get_point_a(void) const;</span>

<span class="s0">553 11 set_point_b 0 4 632 29 CollisionSegment::set_point_b 0 2 274 275 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline void CollisionSegment::set_point_b(LPoint3 const &amp;b);</span>
<span class="s0">inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">554 11 get_point_b 0 4 632 29 CollisionSegment::get_point_b 0 1 276 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LPoint3 const &amp;CollisionSegment::get_point_b(void) const;</span>

<span class="s0">555 13 set_from_lens 0 4 632 31 CollisionSegment::set_from_lens 0 2 277 278 609</span>
<span class="s0">/**</span>
 <span class="s0">* Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the</span>
 <span class="s0">* CollisionSegment so that it begins at the LensNode's near plane and extends</span>
 <span class="s0">* to the far plane, making it suitable for picking objects from the screen</span>
 <span class="s0">* given a camera and a mouse location.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the</span>
 <span class="s0">* CollisionSegment so that it begins at the LensNode's near plane and extends</span>
 <span class="s0">* to the far plane, making it suitable for picking objects from the screen</span>
 <span class="s0">* given a camera and a mouse location.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the point was acceptable, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">172</span>
<span class="s0">bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &amp;point);</span>
<span class="s0">inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);</span>

<span class="s0">556 14 get_class_type 0 4 632 32 CollisionSegment::get_class_type 0 1 279 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle CollisionSegment::get_class_type(void);</span>

<span class="s0">557 17 ~CollisionSegment 0 516 632 35 CollisionSegment::~CollisionSegment 0 0 0</span>
<span class="s0">42</span>
<span class="s0">CollisionSegment::~CollisionSegment(void);</span>

<span class="s0">558 19 upcast_to_PandaNode 0 12 634 40 CollisionVisualizer::upcast_to_PandaNode 0 1 288 44</span>
<span class="s0">upcast from CollisionVisualizer to PandaNode</span>
<span class="s0">58</span>
<span class="s0">PandaNode *CollisionVisualizer::upcast_to_PandaNode(void);</span>

<span class="s0">559 31 downcast_to_CollisionVisualizer 0 12 586 42 PandaNode::downcast_to_CollisionVisualizer 0 0 46</span>
<span class="s0">downcast from PandaNode to CollisionVisualizer</span>
<span class="s0">70</span>
<span class="s0">CollisionVisualizer *PandaNode::downcast_to_CollisionVisualizer(void);</span>

<span class="s0">560 27 upcast_to_CollisionRecorder 0 12 634 48 CollisionVisualizer::upcast_to_CollisionRecorder 0 1 289 52</span>
<span class="s0">upcast from CollisionVisualizer to CollisionRecorder</span>
<span class="s0">74</span>
<span class="s0">CollisionRecorder *CollisionVisualizer::upcast_to_CollisionRecorder(void);</span>

<span class="s0">561 31 downcast_to_CollisionVisualizer 0 12 596 50 CollisionRecorder::downcast_to_CollisionVisualizer 0 0 54</span>
<span class="s0">downcast from CollisionRecorder to CollisionVisualizer</span>
<span class="s0">78</span>
<span class="s0">CollisionVisualizer *CollisionRecorder::downcast_to_CollisionVisualizer(void);</span>

<span class="s0">562 19 CollisionVisualizer 0 260 634 40 CollisionVisualizer::CollisionVisualizer 0 2 280 281 40</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Copy constructor.</span>
 <span class="s0">*/</span>
<span class="s0">150</span>
<span class="s0">explicit CollisionVisualizer::CollisionVisualizer(std::string const &amp;name);</span>
<span class="s0">CollisionVisualizer::CollisionVisualizer(CollisionVisualizer const &amp;copy);</span>

<span class="s0">563 20 ~CollisionVisualizer 0 518 634 41 CollisionVisualizer::~CollisionVisualizer 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual CollisionVisualizer::~CollisionVisualizer(void);</span>

<span class="s0">564 15 set_point_scale 0 4 634 36 CollisionVisualizer::set_point_scale 0 1 282 412</span>
<span class="s0">/**</span>
 <span class="s0">* Scales the points that are drawn to represent the surface and interior</span>
 <span class="s0">* intersection points of the collisions.  By default, these objects are drawn</span>
 <span class="s0">* at an arbitrary scale which is appropriate if the window units are the</span>
 <span class="s0">* default range -1 .. 1.  Change this scale accordinatly if the window units</span>
 <span class="s0">* are measured on some other scale or if you need to observe these objects in</span>
 <span class="s0">* a smaller window.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void CollisionVisualizer::set_point_scale(PN_stdfloat point_scale);</span>

<span class="s0">565 15 get_point_scale 0 4 634 36 CollisionVisualizer::get_point_scale 0 1 283 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value last set by set_point_scale().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline PN_stdfloat CollisionVisualizer::get_point_scale(void) const;</span>

<span class="s0">566 16 set_normal_scale 0 4 634 37 CollisionVisualizer::set_normal_scale 0 1 284 370</span>
<span class="s0">/**</span>
 <span class="s0">* Scales the line segments that are drawn to represent the normals of the</span>
 <span class="s0">* collisions.  By default, these objects are drawn at an arbitrary scale</span>
 <span class="s0">* which is appropriate if the scene units are measured in feet.  Change this</span>
 <span class="s0">* scale accordinatly if the scene units are measured on some other scale or</span>
 <span class="s0">* if you need to observe these normals from farther away.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void CollisionVisualizer::set_normal_scale(PN_stdfloat normal_scale);</span>

<span class="s0">567 16 get_normal_scale 0 4 634 37 CollisionVisualizer::get_normal_scale 0 1 285 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value last set by set_normal_scale().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline PN_stdfloat CollisionVisualizer::get_normal_scale(void) const;</span>

<span class="s0">568 5 clear 0 4 634 26 CollisionVisualizer::clear 0 1 286 110</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the visualization data from a previous traversal and resets the</span>
 <span class="s0">* visualizer to empty.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void CollisionVisualizer::clear(void);</span>

<span class="s0">569 14 get_class_type 0 4 634 35 CollisionVisualizer::get_class_type 0 1 287 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle CollisionVisualizer::get_class_type(void);</span>

<span class="s0">289</span>
<span class="s0">1 0 0 7 3 635 0 0 0 1 4 this 3 600  </span>
<span class="s0">2 0 0 4 7 637 0 0 295 /**</span>
 <span class="s0">* Sets the current state of the 'tangible' flag.  Set this true to make the</span>
 <span class="s0">* solid tangible, so that a CollisionHandlerPusher will not allow another</span>
 <span class="s0">* object to intersect it, or false to make it intangible, so that a</span>
 <span class="s0">* CollisionHandlerPusher will ignore it except to throw an event.</span>
 <span class="s0">*/ 2 4 this 3 636  8 tangible 1 574  </span>
<span class="s0">3 0 0 6 8 574 0 0 266 /**</span>
 <span class="s0">* Returns whether the solid is considered 'tangible' or not.  An intangible</span>
 <span class="s0">* solid has no effect in a CollisionHandlerPusher (except to throw an event);</span>
 <span class="s0">* it's useful for defining 'trigger' planes and spheres, that cause an effect</span>
 <span class="s0">* when passed through.</span>
 <span class="s0">*/ 1 4 this 3 600  </span>
<span class="s0">4 0 0 4 11 637 0 0 388 /**</span>
 <span class="s0">* Records a false normal for this CollisionSolid that will be reported by the</span>
 <span class="s0">* collision system with all collisions into it, instead of its actual normal.</span>
 <span class="s0">* This is useful as a workaround for the problem of an avatar wanting to</span>
 <span class="s0">* stand on a sloping ground; by storing a false normal, the ground appears to</span>
 <span class="s0">* be perfectly level, and the avatar does not tend to slide down it.</span>
 <span class="s0">*/ 2 4 this 3 636  16 effective_normal 1 638  </span>
<span class="s0">5 0 0 4 12 637 0 0 71 /**</span>
 <span class="s0">* Removes the normal previously set by set_effective_normal().</span>
 <span class="s0">*/ 1 4 this 3 636  </span>
<span class="s0">6 0 0 6 13 574 0 0 98 /**</span>
 <span class="s0">* Returns true if a special normal was set by set_effective_normal(), false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 600  </span>
<span class="s0">7 0 0 6 14 638 0 0 145 /**</span>
 <span class="s0">* Returns the normal that was set by set_effective_normal().  It is an error</span>
 <span class="s0">* to call this unless has_effective_normal() returns true.</span>
 <span class="s0">*/ 1 4 this 3 600  </span>
<span class="s0">8 0 0 4 15 637 0 0 296 /**</span>
 <span class="s0">* This is only meaningful for CollisionSolids that will be added to a</span>
 <span class="s0">* traverser as colliders.  It is normally true, but if set false, it means</span>
 <span class="s0">* that this particular solid does not care about the &quot;effective&quot; normal of</span>
 <span class="s0">* other solids it meets, but rather always uses the true normal.</span>
 <span class="s0">*/ 2 4 this 3 636  24 respect_effective_normal 1 574  </span>
<span class="s0">9 0 0 6 16 574 0 0 46 /**</span>
 <span class="s0">* See set_respect_effective_normal().</span>
 <span class="s0">*/ 1 4 this 3 600  </span>
<span class="s0">10 0 0 7 18 641 0 0 47 /**</span>
 <span class="s0">* Returns the solid's bounding volume.</span>
 <span class="s0">*/ 1 4 this 3 600  </span>
<span class="s0">11 0 0 4 19 637 0 0 47 /**</span>
 <span class="s0">* Returns the solid's bounding volume.</span>
 <span class="s0">*/ 2 4 this 3 636  15 bounding_volume 1 641  </span>
<span class="s0">12 0 0 4 22 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 600  3 out 1 642  </span>
<span class="s0">13 0 0 4 23 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 600  3 out 1 642  12 indent_level 5 591  </span>
<span class="s0">14 0 0 7 24 645 0 0 0 0 </span>
<span class="s0">15 0 0 7 26 647 317 0 59 /**</span>
 <span class="s0">* Create the Box by Specifying the Diagonal Points</span>
 <span class="s0">*/ 2 3 min 1 646  3 max 1 646  </span>
<span class="s0">16 0 0 7 26 647 317 0 106 /**</span>
 <span class="s0">* Create the Box by giving a Center and distances of each of the sides of</span>
 <span class="s0">* box from the Center.</span>
 <span class="s0">*/ 4 6 center 1 646  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">17 0 0 6 27 591 0 0 68 /**</span>
 <span class="s0">* Returns 8: the number of vertices of a rectangular solid.</span>
 <span class="s0">*/ 1 4 this 3 648  </span>
<span class="s0">18 0 0 7 28 635 0 0 67 /**</span>
 <span class="s0">* Returns the nth vertex of the Axis Aligned Bounding Box.</span>
 <span class="s0">*/ 2 4 this 3 648  1 n 1 591  </span>
<span class="s0">19 0 0 7 29 635 0 0 45 /**</span>
 <span class="s0">* Returns the nth vertex of the OBB.</span>
 <span class="s0">*/ 2 4 this 3 648  1 n 1 591  </span>
<span class="s0">20 0 0 6 30 591 0 0 65 /**</span>
 <span class="s0">* Returns 6: the number of faces of a rectangular solid.</span>
 <span class="s0">*/ 1 4 this 3 648  </span>
<span class="s0">21 0 0 7 31 650 0 0 57 /**</span>
 <span class="s0">* Creates the nth face of the rectangular solid.</span>
 <span class="s0">*/ 2 4 this 3 648  1 n 1 591  </span>
<span class="s0">22 0 0 7 32 650 0 0 57 /**</span>
 <span class="s0">* Returns the nth face of the rectangular solid.</span>
 <span class="s0">*/ 2 4 this 3 648  1 n 1 591  </span>
<span class="s0">23 0 0 4 33 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 647  6 center 1 646  </span>
<span class="s0">24 0 0 4 33 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 647  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">25 0 0 6 34 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 648  </span>
<span class="s0">26 0 0 6 35 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 648  </span>
<span class="s0">27 0 0 6 36 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 648  </span>
<span class="s0">28 0 0 7 37 651 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 648  </span>
<span class="s0">29 0 0 7 45 645 0 0 0 0 </span>
<span class="s0">30 0 0 7 48 652 326 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 a 1 646  2 db 1 646  6 radius 1 581  </span>
<span class="s0">31 0 0 7 48 652 326 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 7 2 ax 1 581  2 ay 1 581  2 az 1 581  2 bx 1 581  2 by 1 581  2 bz 1 581  6 radius 1 581  </span>
<span class="s0">32 0 0 4 49 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 652  1 a 1 646  </span>
<span class="s0">33 0 0 4 49 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 652  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">34 0 0 6 50 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 653  </span>
<span class="s0">35 0 0 4 51 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 652  1 b 1 646  </span>
<span class="s0">36 0 0 4 51 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 652  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">37 0 0 6 52 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 653  </span>
<span class="s0">38 0 0 4 53 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 652  6 radius 1 581  </span>
<span class="s0">39 0 0 6 54 581 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 653  </span>
<span class="s0">40 0 0 7 60 645 0 0 0 0 </span>
<span class="s0">41 0 0 15 65 657 329 0 0 1 6 param0 0 655  </span>
<span class="s0">42 0 0 7 64 645 0 0 0 0 </span>
<span class="s0">43 0 0 7 69 602 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 658  </span>
<span class="s0">44 0 0 4 70 637 0 0 98 /**</span>
 <span class="s0">* Simultaneously sets both the &quot;from&quot; and &quot;into&quot; CollideMask values to the</span>
 <span class="s0">* same thing.</span>
 <span class="s0">*/ 2 4 this 3 602  4 mask 1 659  </span>
<span class="s0">45 0 0 4 71 637 0 0 222 /**</span>
 <span class="s0">* Sets the &quot;from&quot; CollideMask.  In order for a collision to be detected from</span>
 <span class="s0">* this object into another object, the intersection of this object's &quot;from&quot;</span>
 <span class="s0">* mask and the other object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/ 2 4 this 3 602  4 mask 1 659  </span>
<span class="s0">46 0 0 4 72 637 0 0 222 /**</span>
 <span class="s0">* Sets the &quot;into&quot; CollideMask.  In order for a collision to be detected from</span>
 <span class="s0">* another object into this object, the intersection of the other object's</span>
 <span class="s0">* &quot;from&quot; mask and this object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/ 2 4 this 3 602  4 mask 1 659  </span>
<span class="s0">47 0 0 7 73 659 0 0 233 /**</span>
 <span class="s0">* Returns the current &quot;from&quot; CollideMask.  In order for a collision to be</span>
 <span class="s0">* detected from this object into another object, the intersection of this</span>
 <span class="s0">* object's &quot;from&quot; mask and the other object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/ 1 4 this 3 660  </span>
<span class="s0">48 0 0 7 74 659 0 0 233 /**</span>
 <span class="s0">* Returns the current &quot;into&quot; CollideMask.  In order for a collision to be</span>
 <span class="s0">* detected from another object into this object, the intersection of the</span>
 <span class="s0">* other object's &quot;from&quot; mask and this object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/ 1 4 this 3 660  </span>
<span class="s0">49 0 0 4 80 637 0 0 44 /**</span>
 <span class="s0">* Removes all solids from the node.</span>
 <span class="s0">*/ 1 4 this 3 602  </span>
<span class="s0">50 0 0 6 81 662 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 660  </span>
<span class="s0">51 0 0 7 82 600 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 660  1 n 1 662  </span>
<span class="s0">52 0 0 7 84 636 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 602  1 n 1 662  </span>
<span class="s0">53 0 0 4 85 637 0 0 55 /**</span>
 <span class="s0">* Replaces the solid with the indicated index.</span>
 <span class="s0">*/ 3 4 this 3 602  1 n 1 662  5 solid 1 636  </span>
<span class="s0">54 0 0 4 86 637 0 0 77 /**</span>
 <span class="s0">* Inserts the indicated solid to the node at the indicated position.</span>
 <span class="s0">*/ 3 4 this 3 602  1 n 1 662  5 solid 1 600  </span>
<span class="s0">55 0 0 4 87 637 0 0 110 /**</span>
 <span class="s0">* Removes the solid with the indicated index.  This will shift all subsequent</span>
 <span class="s0">* indices down by one.</span>
 <span class="s0">*/ 2 4 this 3 602  1 n 1 662  </span>
<span class="s0">56 0 0 6 88 662 0 0 121 /**</span>
 <span class="s0">* Adds the indicated solid to the node.  Returns the index of the new solid</span>
 <span class="s0">* within the node's list of solids.</span>
 <span class="s0">*/ 2 4 this 3 602  5 solid 1 600  </span>
<span class="s0">57 0 0 6 91 591 0 0 114 /**</span>
 <span class="s0">* Returns the collider_sort value that has been set for this particular node.</span>
 <span class="s0">* See set_collider_sort().</span>
 <span class="s0">*/ 1 4 this 3 660  </span>
<span class="s0">58 0 0 4 92 637 0 0 594 /**</span>
 <span class="s0">* Sets a particular collider_sort value on this node.  This controls the</span>
 <span class="s0">* order in which colliders (that is, &quot;from nodes&quot;) are grouped together for</span>
 <span class="s0">* the collision traversal.</span>
 <span class="s0">*</span>
 <span class="s0">* If there are 32 or fewer colliders added to any particular</span>
 <span class="s0">* CollisionTraverser, then this value has no meaning.  It is only useful if</span>
 <span class="s0">* there are many colliders, which may force the CollisionTraverser to make</span>
 <span class="s0">* multiple passes through the data; in that case, it may be a useful</span>
 <span class="s0">* optimization to group colliders that have similar bounding volumes together</span>
 <span class="s0">* (by giving them similar sort values).</span>
 <span class="s0">*/ 2 4 this 3 602  4 sort 1 591  </span>
<span class="s0">59 0 0 7 95 659 0 0 80 /**</span>
 <span class="s0">* Returns the default into_collide_mask assigned to new CollisionNodes.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">60 0 0 7 97 645 0 0 0 0 </span>
<span class="s0">61 0 0 15 100 666 349 0 0 1 6 param0 0 664  </span>
<span class="s0">62 0 0 7 100 666 349 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 5 658  </span>
<span class="s0">63 0 0 4 102 637 0 0 370 /**</span>
 <span class="s0">* Sets the flag that indicates whether the prev_transform stored on a node</span>
 <span class="s0">* (as updated via set_fluid_pos(), etc.) is respected to calculate</span>
 <span class="s0">* collisions.  If this is true, certain types of collision tests will be</span>
 <span class="s0">* enhanced by the information about objects in motion.  If this is false,</span>
 <span class="s0">* objects are always considered to be static.  The default is false.</span>
 <span class="s0">*/ 2 4 this 3 666  4 flag 1 574  </span>
<span class="s0">64 0 0 6 103 574 0 0 162 /**</span>
 <span class="s0">* Returns the flag that indicates whether the prev_transform stored on a node</span>
 <span class="s0">* is respected to calculate collisions.  See set_respect_prev_transform().</span>
 <span class="s0">*/ 1 4 this 3 664  </span>
<span class="s0">65 0 0 4 106 637 0 0 437 /**</span>
 <span class="s0">* Adds a new CollisionNode, representing an object that will be tested for</span>
 <span class="s0">* collisions into other objects, along with the handler that will serve each</span>
 <span class="s0">* detected collision.  Each CollisionNode may be served by only one handler</span>
 <span class="s0">* at a time, but a given handler may serve many CollisionNodes.</span>
 <span class="s0">*</span>
 <span class="s0">* The handler that serves a particular node may be changed from time to time</span>
 <span class="s0">* by calling add_collider() again on the same node.</span>
 <span class="s0">*/ 3 4 this 3 666  8 collider 1 667  7 handler 1 657  </span>
<span class="s0">66 0 0 6 107 574 0 0 263 /**</span>
 <span class="s0">* Removes the collider (and its associated handler) from the set of</span>
 <span class="s0">* CollisionNodes that will be tested each frame for collisions into other</span>
 <span class="s0">* objects.  Returns true if the definition was found and removed, false if it</span>
 <span class="s0">* wasn't present to begin with.</span>
 <span class="s0">*/ 2 4 this 3 666  8 collider 1 667  </span>
<span class="s0">67 0 0 6 108 574 0 0 145 /**</span>
 <span class="s0">* Returns true if the indicated node is current in the set of nodes that will</span>
 <span class="s0">* be tested each frame for collisions into other objects.</span>
 <span class="s0">*/ 2 4 this 3 664  8 collider 1 667  </span>
<span class="s0">68 0 0 6 109 591 0 0 108 /**</span>
 <span class="s0">* Returns the number of CollisionNodes that have been added to the traverser</span>
 <span class="s0">* via add_collider().</span>
 <span class="s0">*/ 1 4 this 3 664  </span>
<span class="s0">69 0 0 7 110 668 0 0 100 /**</span>
 <span class="s0">* Returns the nth CollisionNode that has been added to the traverser via</span>
 <span class="s0">* add_collider().</span>
 <span class="s0">*/ 2 4 this 3 664  1 n 1 591  </span>
<span class="s0">70 0 0 7 112 657 329 0 169 /**</span>
 <span class="s0">* Returns the handler that is currently assigned to serve the indicated</span>
 <span class="s0">* collision node, or NULL if the node is not on the traverser's set of active</span>
 <span class="s0">* nodes.</span>
 <span class="s0">*/ 2 4 this 3 664  8 collider 1 667  </span>
<span class="s0">71 0 0 4 113 637 0 0 90 /**</span>
 <span class="s0">* Completely empties the set of collision nodes and their associated</span>
 <span class="s0">* handlers.</span>
 <span class="s0">*/ 1 4 this 3 666  </span>
<span class="s0">72 0 0 4 116 637 0 0 247 /**</span>
 <span class="s0">* Perform the traversal. Begins at the indicated root and detects all</span>
 <span class="s0">* collisions with any of its collider objects against nodes at or below the</span>
 <span class="s0">* indicated root, calling the appropriate CollisionHandler for each detected</span>
 <span class="s0">* collision.</span>
 <span class="s0">*/ 2 4 this 3 666  4 root 1 667  </span>
<span class="s0">73 0 0 4 117 637 0 0 777 /**</span>
 <span class="s0">* Uses the indicated CollisionRecorder object to start recording the</span>
 <span class="s0">* intersection tests made by each subsequent call to traverse() on this</span>
 <span class="s0">* object.  A particular CollisionRecorder object can only record one</span>
 <span class="s0">* traverser at a time; if this object has already been assigned to another</span>
 <span class="s0">* traverser, that assignment is broken.</span>
 <span class="s0">*</span>
 <span class="s0">* This is intended to be used in a debugging mode to try to determine what</span>
 <span class="s0">* work is being performed by the collision traversal.  Usually, attaching a</span>
 <span class="s0">* recorder will impose significant runtime overhead.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not transfer ownership of the CollisionRecorder pointer;</span>
 <span class="s0">* maintenance of that remains the caller's responsibility.  If the</span>
 <span class="s0">* CollisionRecorder is destructed, it will cleanly remove itself from the</span>
 <span class="s0">* traverser.</span>
 <span class="s0">*/ 2 4 this 3 666  8 recorder 1 595  </span>
<span class="s0">74 0 0 6 118 574 0 0 120 /**</span>
 <span class="s0">* Returns true if the CollisionTraverser has a CollisionRecorder object</span>
 <span class="s0">* currently assigned, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 664  </span>
<span class="s0">75 0 0 6 119 595 0 0 99 /**</span>
 <span class="s0">* Returns the CollisionRecorder currently assigned, or NULL if no recorder is</span>
 <span class="s0">* assigned.</span>
 <span class="s0">*/ 1 4 this 3 664  </span>
<span class="s0">76 0 0 4 120 637 0 0 107 /**</span>
 <span class="s0">* Removes the CollisionRecorder from the traverser and restores normal low-</span>
 <span class="s0">* overhead operation.</span>
 <span class="s0">*/ 1 4 this 3 666  </span>
<span class="s0">77 0 0 7 127 669 563 0 300 /**</span>
 <span class="s0">* This is a high-level function to create a CollisionVisualizer object to</span>
 <span class="s0">* render the collision tests performed by this traverser.  The supplied root</span>
 <span class="s0">* should be any node in the scene graph; typically, the top node (e.g.</span>
 <span class="s0">* render).  The CollisionVisualizer will be attached to this node.</span>
 <span class="s0">*/ 2 4 this 3 666  4 root 1 667  </span>
<span class="s0">78 0 0 4 128 637 0 0 69 /**</span>
 <span class="s0">* Undoes the effect of a previous call to show_collisions().</span>
 <span class="s0">*/ 1 4 this 3 666  </span>
<span class="s0">79 0 0 4 129 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 664  3 out 1 642  </span>
<span class="s0">80 0 0 4 130 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 664  3 out 1 642  12 indent_level 1 591  </span>
<span class="s0">81 0 0 38 131 670 0 0 0 1 4 this 3 664  </span>
<span class="s0">82 0 0 36 132 637 0 0 0 2 4 this 3 666  5 state 1 670  </span>
<span class="s0">83 0 0 7 133 645 0 0 0 0 </span>
<span class="s0">84 0 0 4 125 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 673  3 out 1 642  </span>
<span class="s0">85 0 0 7 126 645 0 0 0 0 </span>
<span class="s0">86 0 0 7 136 600 0 0 104 /**</span>
 <span class="s0">* Returns the CollisionSolid pointer for the particular solid that triggered</span>
 <span class="s0">* this collision.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">87 0 0 6 137 574 0 0 288 /**</span>
 <span class="s0">* Returns true if the &quot;into&quot; solid is, in fact, a CollisionSolid, and its</span>
 <span class="s0">* pointer is known (in which case get_into() may be called to retrieve it).</span>
 <span class="s0">* If this returns false, the collision was detected into a GeomNode, and</span>
 <span class="s0">* there is no CollisionSolid pointer to be retrieved.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">88 0 0 7 138 600 0 0 243 /**</span>
 <span class="s0">* Returns the CollisionSolid pointer for the particular solid was collided</span>
 <span class="s0">* into.  This pointer might be NULL if the collision was into a piece of</span>
 <span class="s0">* visible geometry, instead of a normal CollisionSolid collision; see</span>
 <span class="s0">* has_into().</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">89 0 0 7 139 602 0 0 182 /**</span>
 <span class="s0">* Returns the node that contains the CollisionSolid that triggered this</span>
 <span class="s0">* collision.  This will be a node that has been added to a CollisionTraverser</span>
 <span class="s0">* via add_collider().</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">90 0 0 7 140 603 0 0 254 /**</span>
 <span class="s0">* Returns the node that contains the CollisionSolid that was collided into.</span>
 <span class="s0">* This returns a PandaNode pointer instead of something more specific,</span>
 <span class="s0">* because it might be either a CollisionNode or a GeomNode.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see get_into_node_path().</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">91 0 0 7 141 668 0 0 224 /**</span>
 <span class="s0">* Returns the NodePath that represents the CollisionNode that contains the</span>
 <span class="s0">* CollisionSolid that triggered this collision.  This will be a NodePath that</span>
 <span class="s0">* has been added to a CollisionTraverser via add_collider().</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">92 0 0 7 142 668 0 0 338 /**</span>
 <span class="s0">* Returns the NodePath that represents the specific CollisionNode or GeomNode</span>
 <span class="s0">* instance that was collided into.  This is the same node returned by</span>
 <span class="s0">* get_into_node(), represented as a NodePath; however, it may be more useful</span>
 <span class="s0">* because the NodePath can resolve the particular instance of the node, if</span>
 <span class="s0">* there is more than one.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">93 0 0 4 143 637 0 0 82 /**</span>
 <span class="s0">* Sets a time value for this collision relative to other CollisionEntries</span>
 <span class="s0">*/ 2 4 this 3 623  1 t 1 581  </span>
<span class="s0">94 0 0 6 144 581 0 0 83 /**</span>
 <span class="s0">* returns time value for this collision relative to other CollisionEntries</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">95 0 0 6 145 574 0 0 188 /**</span>
 <span class="s0">* returns true if this represents an actual collision as opposed to a</span>
 <span class="s0">* potential collision, needed for iterative collision resolution where path</span>
 <span class="s0">* of collider changes mid-frame</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">96 0 0 4 146 637 0 0 45 /**</span>
 <span class="s0">* prepare for another collision test</span>
 <span class="s0">*/ 1 4 this 3 623  </span>
<span class="s0">97 0 0 6 147 574 0 0 203 /**</span>
 <span class="s0">* Returns true if the collision was detected by a CollisionTraverser whose</span>
 <span class="s0">* respect_prev_transform flag was set true, meaning we should consider motion</span>
 <span class="s0">* significant in evaluating collisions.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">98 0 0 4 148 637 0 0 178 /**</span>
 <span class="s0">* Stores the point, on the surface of the &quot;into&quot; object, at which a collision</span>
 <span class="s0">* is detected.</span>
 <span class="s0">*</span>
 <span class="s0">* This point is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/ 2 4 this 3 623  5 point 1 646  </span>
<span class="s0">99 0 0 4 149 637 0 0 171 /**</span>
 <span class="s0">* Stores the surface normal of the &quot;into&quot; object at the point of the</span>
 <span class="s0">* intersection.</span>
 <span class="s0">*</span>
 <span class="s0">* This normal is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/ 2 4 this 3 623  6 normal 1 638  </span>
<span class="s0">100 0 0 4 150 637 0 0 352 /**</span>
 <span class="s0">* Stores the point, within the interior of the &quot;into&quot; object, which</span>
 <span class="s0">* represents the depth to which the &quot;from&quot; object has penetrated.  This can</span>
 <span class="s0">* also be described as the intersection point on the surface of the &quot;from&quot;</span>
 <span class="s0">* object (which is inside the &quot;into&quot; object).</span>
 <span class="s0">*</span>
 <span class="s0">* This point is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/ 2 4 this 3 623  5 point 1 646  </span>
<span class="s0">101 0 0 6 151 574 0 0 174 /**</span>
 <span class="s0">* Returns true if the surface point has been specified, false otherwise.  See</span>
 <span class="s0">* get_surface_point().  Some types of collisions may not compute the surface</span>
 <span class="s0">* point.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">102 0 0 6 152 574 0 0 176 /**</span>
 <span class="s0">* Returns true if the surface normal has been specified, false otherwise.</span>
 <span class="s0">* See get_surface_normal().  Some types of collisions may not compute the</span>
 <span class="s0">* surface normal.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">103 0 0 6 153 574 0 0 176 /**</span>
 <span class="s0">* Returns true if the interior point has been specified, false otherwise.</span>
 <span class="s0">* See get_interior_point().  Some types of collisions may not compute the</span>
 <span class="s0">* interior point.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">104 0 0 4 154 637 0 0 190 /**</span>
 <span class="s0">* Stores the position of the &quot;from&quot; object at the instant at which the</span>
 <span class="s0">* collision is first detected.</span>
 <span class="s0">*</span>
 <span class="s0">* This position is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/ 2 4 this 3 623  3 pos 1 646  </span>
<span class="s0">105 0 0 4 155 637 0 0 154 /**</span>
 <span class="s0">* Stores the surface normal of the &quot;into&quot; object at the contact pos.</span>
 <span class="s0">*</span>
 <span class="s0">* This normal is specified in the coordinate space of the &quot;into&quot; object.</span>
 <span class="s0">*/ 2 4 this 3 623  6 normal 1 638  </span>
<span class="s0">106 0 0 6 156 574 0 0 172 /**</span>
 <span class="s0">* Returns true if the contact position has been specified, false otherwise.</span>
 <span class="s0">* See get_contact_pos().  Some types of collisions may not compute the</span>
 <span class="s0">* contact pos.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">107 0 0 6 157 574 0 0 176 /**</span>
 <span class="s0">* Returns true if the contact normal has been specified, false otherwise.</span>
 <span class="s0">* See get_contact_normal().  Some types of collisions may not compute the</span>
 <span class="s0">* contact normal.</span>
 <span class="s0">*/ 1 4 this 3 675  </span>
<span class="s0">108 0 0 7 158 635 0 0 330 /**</span>
 <span class="s0">* Returns the point, on the surface of the &quot;into&quot; object, at which a</span>
 <span class="s0">* collision is detected.  This can be thought of as the first point of</span>
 <span class="s0">* intersection.  However the contact point is the actual first point of</span>
 <span class="s0">* intersection.</span>
 <span class="s0">*</span>
 <span class="s0">* The point will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/ 2 4 this 3 675  5 space 1 667  </span>
<span class="s0">109 0 0 7 159 651 0 0 200 /**</span>
 <span class="s0">* Returns the surface normal of the &quot;into&quot; object at the point at which a</span>
 <span class="s0">* collision is detected.</span>
 <span class="s0">*</span>
 <span class="s0">* The normal will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/ 2 4 this 3 675  5 space 1 667  </span>
<span class="s0">110 0 0 7 160 635 0 0 431 /**</span>
 <span class="s0">* Returns the point, within the interior of the &quot;into&quot; object, which</span>
 <span class="s0">* represents the depth to which the &quot;from&quot; object has penetrated.  This can</span>
 <span class="s0">* also be described as the intersection point on the surface of the &quot;from&quot;</span>
 <span class="s0">* object (which is inside the &quot;into&quot; object).  It can be thought of as the</span>
 <span class="s0">* deepest point of intersection.</span>
 <span class="s0">*</span>
 <span class="s0">* The point will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/ 2 4 this 3 675  5 space 1 667  </span>
<span class="s0">111 0 0 6 161 574 0 0 244 /**</span>
 <span class="s0">* Simultaneously transforms the surface point, surface normal, and interior</span>
 <span class="s0">* point of the collision into the indicated coordinate space.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if all three properties are available, or false if any one of</span>
 <span class="s0">* them is not.</span>
 <span class="s0">*/ 5 4 this 3 675  5 space 1 667  13 surface_point 1 635  14 surface_normal 1 651  14 interior_point 1 635  </span>
<span class="s0">112 0 0 7 162 635 0 0 200 /**</span>
 <span class="s0">* Returns the position of the &quot;from&quot; object at the instant that a collision</span>
 <span class="s0">* is first detected.</span>
 <span class="s0">*</span>
 <span class="s0">* The position will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/ 2 4 this 3 675  5 space 1 667  </span>
<span class="s0">113 0 0 7 163 651 0 0 175 /**</span>
 <span class="s0">* Returns the surface normal of the &quot;into&quot; object at the contact position.</span>
 <span class="s0">*</span>
 <span class="s0">* The normal will be converted into whichever coordinate space the caller</span>
 <span class="s0">* specifies.</span>
 <span class="s0">*/ 2 4 this 3 675  5 space 1 667  </span>
<span class="s0">114 0 0 6 164 574 0 0 230 /**</span>
 <span class="s0">* Simultaneously transforms the contact position and contact normal of the</span>
 <span class="s0">* collision into the indicated coordinate space.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if all three properties are available, or false if any one of</span>
 <span class="s0">* them is not.</span>
 <span class="s0">*/ 4 4 this 3 675  5 space 1 667  11 contact_pos 1 635  14 contact_normal 1 651  </span>
<span class="s0">115 0 0 4 165 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 675  3 out 1 642  </span>
<span class="s0">116 0 0 4 166 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 675  3 out 1 642  12 indent_level 5 591  </span>
<span class="s0">117 0 0 7 179 645 0 0 0 0 </span>
<span class="s0">118 0 0 15 182 679 413 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 677  </span>
<span class="s0">119 0 0 23 182 679 413 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 plane 1 680  </span>
<span class="s0">120 0 0 7 183 651 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 677  </span>
<span class="s0">121 0 0 6 184 581 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 677  5 point 1 646  </span>
<span class="s0">122 0 0 4 185 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 679  5 plane 1 680  </span>
<span class="s0">123 0 0 6 186 680 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 677  </span>
<span class="s0">124 0 0 4 187 637 0 0 57 /**</span>
 <span class="s0">* Convenience method to flip the plane in-place.</span>
 <span class="s0">*/ 1 4 this 3 679  </span>
<span class="s0">125 0 0 7 193 645 0 0 0 0 </span>
<span class="s0">126 0 0 7 196 681 422 0 144 /**</span>
 <span class="s0">* This is only for the convenience of CollisionPolygon.  Normally, you should</span>
 <span class="s0">* not attempt to create an uninitialized CollisionPlane.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">127 0 0 4 197 637 0 0 47 /**</span>
 <span class="s0">* store away a vertex to index against</span>
 <span class="s0">*/ 2 4 this 3 681  4 vert 1 646  </span>
<span class="s0">128 0 0 4 198 637 0 0 42 /**</span>
 <span class="s0">* store a triangle for processing</span>
 <span class="s0">*/ 4 4 this 3 681  6 pointA 1 682  6 pointB 1 682  6 pointC 1 682  </span>
<span class="s0">129 0 0 6 199 682 0 0 0 1 4 this 3 683  </span>
<span class="s0">130 0 0 6 200 646 0 0 0 2 4 this 3 683  5 index 1 682  </span>
<span class="s0">131 0 0 6 202 682 0 0 0 1 4 this 3 683  </span>
<span class="s0">132 0 0 7 203 685 0 0 0 2 4 this 3 683  5 index 1 682  </span>
<span class="s0">133 0 0 7 208 645 0 0 0 0 </span>
<span class="s0">134 0 0 23 211 690 430 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 1 a 1 686  1 b 1 686  1 c 1 686  </span>
<span class="s0">135 0 0 23 211 690 430 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 1 a 1 686  1 b 1 686  1 c 1 686  1 d 1 686  </span>
<span class="s0">136 0 0 6 212 662 0 0 66 /**</span>
 <span class="s0">* Returns the number of vertices of the CollisionPolygon.</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">137 0 0 7 213 635 0 0 82 /**</span>
 <span class="s0">* Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.</span>
 <span class="s0">*/ 2 4 this 3 691  1 n 1 662  </span>
<span class="s0">138 0 0 6 215 574 0 0 167 /**</span>
 <span class="s0">* Verifies that the indicated set of points will define a valid</span>
 <span class="s0">* CollisionPolygon: that is, at least three non-collinear points, with no</span>
 <span class="s0">* points repeated.</span>
 <span class="s0">*/ 3 1 a 1 646  1 b 1 646  1 c 1 646  </span>
<span class="s0">139 0 0 6 215 574 0 0 167 /**</span>
 <span class="s0">* Verifies that the indicated set of points will define a valid</span>
 <span class="s0">* CollisionPolygon: that is, at least three non-collinear points, with no</span>
 <span class="s0">* points repeated.</span>
 <span class="s0">*/ 4 1 a 1 646  1 b 1 646  1 c 1 646  1 d 1 646  </span>
<span class="s0">140 0 0 6 216 574 0 0 122 /**</span>
 <span class="s0">* Returns true if the CollisionPolygon is valid (that is, it has at least</span>
 <span class="s0">* three vertices), or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">141 0 0 6 217 574 0 0 106 /**</span>
 <span class="s0">* Returns true if the CollisionPolygon appears to be concave, or false if it</span>
 <span class="s0">* is safely convex.</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">142 0 0 7 221 645 0 0 0 0 </span>
<span class="s0">143 0 0 7 224 693 454 0 168 /**</span>
 <span class="s0">* The default CollisionHandlerEvent will throw no events.  Its pattern</span>
 <span class="s0">* strings must first be set via a call to add_in_pattern() and/or</span>
 <span class="s0">* add_out_pattern().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">144 0 0 15 224 693 454 0 0 1 6 param0 0 694  </span>
<span class="s0">145 0 0 4 225 637 0 0 80 /**</span>
 <span class="s0">* Removes all of the previously-added in patterns.  See add_in_pattern.</span>
 <span class="s0">*/ 1 4 this 3 693  </span>
<span class="s0">146 0 0 4 226 637 0 0 1586 /**</span>
 <span class="s0">* Adds a pattern string to the list of events that will be generated in</span>
 <span class="s0">* response to a collision.  The pattern string describes how the event name</span>
 <span class="s0">* will be composed.  It is a string that may contain any of the following:</span>
 <span class="s0">*</span>
 <span class="s0">* %fn  - the name of the &quot;from&quot; object's node %in  - the name of the &quot;into&quot;</span>
 <span class="s0">* object's node %fs  - 't' if &quot;from&quot; is tangible, 'i' if intangible %is  -</span>
 <span class="s0">* 't' if &quot;into&quot; is tangible, 'i' if intangible %ig  - 'c' if the collision is</span>
 <span class="s0">* into a CollisionNode, 'g' if it is a geom.</span>
 <span class="s0">*</span>
 <span class="s0">* %(tag)fh - generate event only if &quot;from&quot; node has the indicated net tag.</span>
 <span class="s0">* %(tag)fx - generate event only if &quot;from&quot; node does not have the indicated</span>
 <span class="s0">* net tag.  %(tag)ih - generate event only if &quot;into&quot; node has the indicated</span>
 <span class="s0">* net tag.  %(tag)ix - generate event only if &quot;into&quot; node does not have the</span>
 <span class="s0">* indicated net tag.  %(tag)ft - the indicated net tag value of the &quot;from&quot;</span>
 <span class="s0">* node.  %(tag)it - the indicated net tag value of the &quot;into&quot; node.</span>
 <span class="s0">*</span>
 <span class="s0">* Parentheses in the above are literal and should be included in the actual</span>
 <span class="s0">* pattern.</span>
 <span class="s0">*</span>
 <span class="s0">* The event name will be based on the in_pattern string specified here, with</span>
 <span class="s0">* all occurrences of the above strings replaced with the corresponding</span>
 <span class="s0">* values.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, the in_pattern event is thrown on the first detection of a</span>
 <span class="s0">* collision between two particular nodes.  In subsequent passes, as long as a</span>
 <span class="s0">* collision between those two nodes continues to be detected each frame, the</span>
 <span class="s0">* again_pattern is thrown.  The first frame in which the collision is no</span>
 <span class="s0">* longer detected, the out_pattern event is thrown.</span>
 <span class="s0">*/ 2 4 this 3 693  10 in_pattern 1 658  </span>
<span class="s0">147 0 0 4 227 637 0 0 189 /**</span>
 <span class="s0">* This method is deprecated; it completely replaces all the in patterns that</span>
 <span class="s0">* have previously been set with the indicated pattern.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_in_pattern() instead.</span>
 <span class="s0">*/ 2 4 this 3 693  10 in_pattern 1 658  </span>
<span class="s0">148 0 0 6 228 591 0 0 73 /**</span>
 <span class="s0">* Returns the number of in pattern strings that have been added.</span>
 <span class="s0">*/ 1 4 this 3 694  </span>
<span class="s0">149 0 0 6 229 658 0 0 145 /**</span>
 <span class="s0">* Returns the nth pattern string that indicates how the event names are</span>
 <span class="s0">* generated for each collision detected.  See add_in_pattern().</span>
 <span class="s0">*/ 2 4 this 3 694  1 n 1 591  </span>
<span class="s0">150 0 0 4 231 637 0 0 83 /**</span>
 <span class="s0">* Removes all of the previously-added in patterns.  See add_again_pattern.</span>
 <span class="s0">*/ 1 4 this 3 693  </span>
<span class="s0">151 0 0 4 232 637 0 0 649 /**</span>
 <span class="s0">* Adds the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a collision between two particular nodes is *still* detected.  This</span>
 <span class="s0">* event is thrown each consecutive time a collision between two particular</span>
 <span class="s0">* nodes is detected, starting with the second time.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, the in_pattern event is thrown on the first detection of a</span>
 <span class="s0">* collision between two particular nodes.  In subsequent passes, as long as a</span>
 <span class="s0">* collision between those two nodes continues to be detected each frame, the</span>
 <span class="s0">* again_pattern is thrown.  The first frame in which the collision is no</span>
 <span class="s0">* longer detected, the out_pattern event is thrown.</span>
 <span class="s0">*/ 2 4 this 3 693  13 again_pattern 1 658  </span>
<span class="s0">152 0 0 4 233 637 0 0 192 /**</span>
 <span class="s0">* This method is deprecated; it completely replaces all the in patterns that</span>
 <span class="s0">* have previously been set with the indicated pattern.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_again_pattern() instead.</span>
 <span class="s0">*/ 2 4 this 3 693  13 again_pattern 1 658  </span>
<span class="s0">153 0 0 6 234 591 0 0 73 /**</span>
 <span class="s0">* Returns the number of in pattern strings that have been added.</span>
 <span class="s0">*/ 1 4 this 3 694  </span>
<span class="s0">154 0 0 6 235 658 0 0 148 /**</span>
 <span class="s0">* Returns the nth pattern string that indicates how the event names are</span>
 <span class="s0">* generated for each collision detected.  See add_again_pattern().</span>
 <span class="s0">*/ 2 4 this 3 694  1 n 1 591  </span>
<span class="s0">155 0 0 4 237 637 0 0 81 /**</span>
 <span class="s0">* Removes all of the previously-added in patterns.  See add_out_pattern.</span>
 <span class="s0">*/ 1 4 this 3 693  </span>
<span class="s0">156 0 0 4 238 637 0 0 518 /**</span>
 <span class="s0">* Adds the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a collision between two particular nodes is *no longer* detected.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, the in_pattern event is thrown on the first detection of a</span>
 <span class="s0">* collision between two particular nodes.  In subsequent passes, as long as a</span>
 <span class="s0">* collision between those two nodes continues to be detected each frame, the</span>
 <span class="s0">* again_pattern is thrown.  The first frame in which the collision is no</span>
 <span class="s0">* longer detected, the out_pattern event is thrown.</span>
 <span class="s0">*/ 2 4 this 3 693  11 out_pattern 1 658  </span>
<span class="s0">157 0 0 4 239 637 0 0 190 /**</span>
 <span class="s0">* This method is deprecated; it completely replaces all the in patterns that</span>
 <span class="s0">* have previously been set with the indicated pattern.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_out_pattern() instead.</span>
 <span class="s0">*/ 2 4 this 3 693  11 out_pattern 1 658  </span>
<span class="s0">158 0 0 6 240 591 0 0 73 /**</span>
 <span class="s0">* Returns the number of in pattern strings that have been added.</span>
 <span class="s0">*/ 1 4 this 3 694  </span>
<span class="s0">159 0 0 6 241 658 0 0 146 /**</span>
 <span class="s0">* Returns the nth pattern string that indicates how the event names are</span>
 <span class="s0">* generated for each collision detected.  See add_out_pattern().</span>
 <span class="s0">*/ 2 4 this 3 694  1 n 1 591  </span>
<span class="s0">160 0 0 4 248 637 0 0 541 /**</span>
 <span class="s0">* Empties the list of elements that all colliders are known to be colliding</span>
 <span class="s0">* with.  No &quot;out&quot; events will be thrown; if the same collision is detected</span>
 <span class="s0">* next frame, a new &quot;in&quot; event will be thrown for each collision.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be called each frame to defeat the persistent &quot;in&quot; event</span>
 <span class="s0">* mechanism, which prevents the same &quot;in&quot; event from being thrown repeatedly.</span>
 <span class="s0">* However, also see add_again_pattern(), which can be used to set the event</span>
 <span class="s0">* that is thrown when a collision is detected for two or more consecutive</span>
 <span class="s0">* frames.</span>
 <span class="s0">*/ 1 4 this 3 693  </span>
<span class="s0">161 0 0 4 249 637 0 0 58 /**</span>
 <span class="s0">* Same as clear() except &quot;out&quot; events are thrown.</span>
 <span class="s0">*/ 1 4 this 3 693  </span>
<span class="s0">162 0 0 38 250 670 0 0 46 // These help implement Python pickle support. 1 4 this 3 694  </span>
<span class="s0">163 0 0 36 251 637 0 0 0 2 4 this 3 693  4 data 1 696  </span>
<span class="s0">164 0 0 4 252 637 0 0 63 /**</span>
 <span class="s0">* Serializes this object, to implement pickle support.</span>
 <span class="s0">*/ 2 4 this 3 694  11 destination 1 698  </span>
<span class="s0">165 0 0 4 253 637 0 0 104 /**</span>
 <span class="s0">* Restores the object state from the given datagram, previously obtained using</span>
 <span class="s0">* __getstate__.</span>
 <span class="s0">*/ 2 4 this 3 693  6 source 1 700  </span>
<span class="s0">166 0 0 7 254 645 0 0 0 0 </span>
<span class="s0">167 0 0 4 257 637 0 0 180 /**</span>
 <span class="s0">* Adds a new collider to the list with a NodePath that will be updated with</span>
 <span class="s0">* the collider's new position, or updates the existing collider with a new</span>
 <span class="s0">* NodePath object.</span>
 <span class="s0">*/ 3 4 this 3 702  8 collider 1 667  6 target 1 667  </span>
<span class="s0">168 0 0 4 257 637 0 0 374 /**</span>
 <span class="s0">* Adds a new collider to the list with a NodePath that will be updated with</span>
 <span class="s0">* the collider's new position, or updates the existing collider with a new</span>
 <span class="s0">* NodePath object.</span>
 <span class="s0">*</span>
 <span class="s0">* The indicated DriveInterface will also be updated with the target's new</span>
 <span class="s0">* transform each frame.  This method should be used when the target is</span>
 <span class="s0">* directly controlled by a DriveInterface.</span>
 <span class="s0">*/ 4 4 this 3 702  8 collider 1 667  6 target 1 667  15 drive_interface 1 703  </span>
<span class="s0">169 0 0 6 258 574 0 0 92 /**</span>
 <span class="s0">* Removes the collider from the list of colliders that this handler knows</span>
 <span class="s0">* about.</span>
 <span class="s0">*/ 2 4 this 3 702  8 collider 1 667  </span>
<span class="s0">170 0 0 6 259 574 0 0 94 /**</span>
 <span class="s0">* Returns true if the handler knows about the indicated collider, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 705  8 collider 1 667  </span>
<span class="s0">171 0 0 4 260 637 0 0 77 /**</span>
 <span class="s0">* Completely empties the list of colliders this handler knows about.</span>
 <span class="s0">*/ 1 4 this 3 702  </span>
<span class="s0">172 0 0 4 261 637 0 0 269 /**</span>
 <span class="s0">* Specifies an arbitrary NodePath that the handler is always considered to be</span>
 <span class="s0">* facing.  It does not detect collisions with surfaces that appear to be</span>
 <span class="s0">* facing away from this NodePath.  This works best when the collision</span>
 <span class="s0">* surfaces in question are polygons.</span>
 <span class="s0">*/ 2 4 this 3 702  6 center 1 667  </span>
<span class="s0">173 0 0 4 262 637 0 0 64 /**</span>
 <span class="s0">* Clears the center NodePath specified with set_center.</span>
 <span class="s0">*/ 1 4 this 3 702  </span>
<span class="s0">174 0 0 6 263 667 0 0 114 /**</span>
 <span class="s0">* Returns the NodePath specified with set_center, or the empty NodePath if</span>
 <span class="s0">* nothing has been specified.</span>
 <span class="s0">*/ 1 4 this 3 705  </span>
<span class="s0">175 0 0 6 264 574 0 0 95 /**</span>
 <span class="s0">* Returns true if a NodePath has been specified with set_center(), false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 705  </span>
<span class="s0">176 0 0 6 265 574 0 0 255 /**</span>
 <span class="s0">* Did the handler make any contacts with anything on the last collision pass?</span>
 <span class="s0">* Depending on how your world is setup, this can be used to tell if the</span>
 <span class="s0">* handler is out of the world (i.e.  out of bounds). That is the original use</span>
 <span class="s0">* of this call.</span>
 <span class="s0">*/ 1 4 this 3 705  </span>
<span class="s0">177 0 0 38 268 670 0 0 0 1 4 this 3 705  </span>
<span class="s0">178 0 0 36 269 637 0 0 0 3 4 this 3 702  4 data 1 696  9 nodepaths 1 670  </span>
<span class="s0">179 0 0 7 270 645 0 0 0 0 </span>
<span class="s0">180 0 0 7 272 707 454 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">181 0 0 4 273 637 0 0 166 /**</span>
 <span class="s0">* Sets the linear offset to add to (or subtract from) the highest detected</span>
 <span class="s0">* collision point to determine the actual height at which to set the</span>
 <span class="s0">* collider.</span>
 <span class="s0">*/ 2 4 this 3 707  6 offset 1 581  </span>
<span class="s0">182 0 0 6 274 581 0 0 169 /**</span>
 <span class="s0">* Returns the linear offset to add to (or subtract from) the highest detected</span>
 <span class="s0">* collision point to determine the actual height at which to set the</span>
 <span class="s0">* collider.</span>
 <span class="s0">*/ 1 4 this 3 708  </span>
<span class="s0">183 0 0 4 275 637 0 0 82 /**</span>
 <span class="s0">* Sets the reach to add to (or subtract from) the highest collision point</span>
 <span class="s0">*/ 2 4 this 3 707  5 reach 1 581  </span>
<span class="s0">184 0 0 6 276 581 0 0 85 /**</span>
 <span class="s0">* Returns the reach to add to (or subtract from) the highest collision point</span>
 <span class="s0">*/ 1 4 this 3 708  </span>
<span class="s0">185 0 0 4 277 637 0 0 199 /**</span>
 <span class="s0">* Sets the maximum speed at which the object will be allowed to descend</span>
 <span class="s0">* towards a floor below it, in units per second.  Set this to zero to allow</span>
 <span class="s0">* it to instantly teleport any distance.</span>
 <span class="s0">*/ 2 4 this 3 707  7 max_vel 1 581  </span>
<span class="s0">186 0 0 6 278 581 0 0 160 /**</span>
 <span class="s0">* Retrieves the maximum speed at which the object will be allowed to descend</span>
 <span class="s0">* towards a floor below it, in units per second.  See set_max_velocity().</span>
 <span class="s0">*/ 1 4 this 3 708  </span>
<span class="s0">187 0 0 4 282 637 0 0 63 /**</span>
 <span class="s0">* Serializes this object, to implement pickle support.</span>
 <span class="s0">*/ 2 4 this 3 708  11 destination 1 698  </span>
<span class="s0">188 0 0 4 283 637 0 0 104 /**</span>
 <span class="s0">* Restores the object state from the given datagram, previously obtained using</span>
 <span class="s0">* __getstate__.</span>
 <span class="s0">*/ 2 4 this 3 707  6 source 1 700  </span>
<span class="s0">189 0 0 7 284 645 0 0 0 0 </span>
<span class="s0">190 0 0 7 286 710 454 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">191 0 0 4 287 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 710  4 flag 1 574  </span>
<span class="s0">192 0 0 6 288 574 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 711  </span>
<span class="s0">193 0 0 4 290 637 0 0 63 /**</span>
 <span class="s0">* Serializes this object, to implement pickle support.</span>
 <span class="s0">*/ 2 4 this 3 711  11 destination 1 698  </span>
<span class="s0">194 0 0 4 291 637 0 0 104 /**</span>
 <span class="s0">* Restores the object state from the given datagram, previously obtained using</span>
 <span class="s0">* __getstate__.</span>
 <span class="s0">*/ 2 4 this 3 710  6 source 1 700  </span>
<span class="s0">195 0 0 7 292 645 0 0 0 0 </span>
<span class="s0">196 0 0 7 294 713 485 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">197 0 0 7 295 645 0 0 0 0 </span>
<span class="s0">198 0 0 7 298 714 454 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">199 0 0 4 299 637 0 0 166 /**</span>
 <span class="s0">* Sets the linear offset to add to (or subtract from) the highest detected</span>
 <span class="s0">* collision point to determine the actual height at which to set the</span>
 <span class="s0">* collider.</span>
 <span class="s0">*/ 2 4 this 3 714  6 offset 1 581  </span>
<span class="s0">200 0 0 6 300 581 0 0 169 /**</span>
 <span class="s0">* Returns the linear offset to add to (or subtract from) the highest detected</span>
 <span class="s0">* collision point to determine the actual height at which to set the</span>
 <span class="s0">* collider.</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">201 0 0 4 301 637 0 0 82 /**</span>
 <span class="s0">* Sets the reach to add to (or subtract from) the highest collision point</span>
 <span class="s0">*/ 2 4 this 3 714  5 reach 1 581  </span>
<span class="s0">202 0 0 6 302 581 0 0 85 /**</span>
 <span class="s0">* Returns the reach to add to (or subtract from) the highest collision point</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">203 0 0 6 303 581 0 0 202 /**</span>
 <span class="s0">* Return the height of the object from the ground.</span>
 <span class="s0">*</span>
 <span class="s0">* The object might not necessarily be at rest.  Use is_on_ground() if you</span>
 <span class="s0">* want to know whether the object is on the ground and at rest.</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">204 0 0 6 304 574 0 0 33 /**</span>
 <span class="s0">* Is the object at rest?</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">205 0 0 6 305 581 0 0 283 /**</span>
 <span class="s0">* How hard did the object hit the ground.  This value is set on impact with</span>
 <span class="s0">* the ground.  You may want to watch (poll) on is_on_ground() and when that is</span>
 <span class="s0">* true, call get_impact_velocity(). Normally I avoid polling, but we are</span>
 <span class="s0">* calling is_on_ground() frequently anyway.</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">206 0 0 6 306 638 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">207 0 0 4 307 637 0 0 184 /**</span>
 <span class="s0">* Adds the sepcified amount to the current velocity.  This is mostly here</span>
 <span class="s0">* allow this common operation to be faster for scripting, but it's also more</span>
 <span class="s0">* concise even in cpp.</span>
 <span class="s0">*/ 2 4 this 3 714  8 velocity 1 581  </span>
<span class="s0">208 0 0 4 308 637 0 0 46 /**</span>
 <span class="s0">* Sets the current vertical velocity.</span>
 <span class="s0">*/ 2 4 this 3 714  8 velocity 1 581  </span>
<span class="s0">209 0 0 6 309 581 0 0 354 /**</span>
 <span class="s0">* Gets the current vertical velocity.</span>
 <span class="s0">*</span>
 <span class="s0">* Generally, negative values mean the object is in free fall; while postive</span>
 <span class="s0">* values mean the object has vertical thrust.</span>
 <span class="s0">*</span>
 <span class="s0">* A zero value does not necessarily mean the object on the ground, it may</span>
 <span class="s0">* also be weightless and/or at the apex of its jump.</span>
 <span class="s0">*</span>
 <span class="s0">* See Also: is_on_ground() and get_gravity()</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">210 0 0 4 310 637 0 0 56 /**</span>
 <span class="s0">* Sets the linear gravity force (always plumb).</span>
 <span class="s0">*/ 2 4 this 3 714  7 gravity 1 581  </span>
<span class="s0">211 0 0 6 311 581 0 0 56 /**</span>
 <span class="s0">* Gets the linear gravity force (always plumb).</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">212 0 0 4 312 637 0 0 199 /**</span>
 <span class="s0">* Sets the maximum speed at which the object will be allowed to descend</span>
 <span class="s0">* towards a floor below it, in units per second.  Set this to zero to allow</span>
 <span class="s0">* it to instantly teleport any distance.</span>
 <span class="s0">*/ 2 4 this 3 714  7 max_vel 1 581  </span>
<span class="s0">213 0 0 6 313 581 0 0 160 /**</span>
 <span class="s0">* Retrieves the maximum speed at which the object will be allowed to descend</span>
 <span class="s0">* towards a floor below it, in units per second.  See set_max_velocity().</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">214 0 0 4 314 637 0 0 229 /**</span>
 <span class="s0">* Enables old behavior required by Toontown (Sellbot Factory lava room is</span>
 <span class="s0">* good test case, lava and conveyor belt specifically). Behavior is to throw</span>
 <span class="s0">* enter/exit events only for floor that the toon is in contact with</span>
 <span class="s0">*/ 2 4 this 3 714  11 legacy_mode 1 574  </span>
<span class="s0">215 0 0 6 315 574 0 0 49 /**</span>
 <span class="s0">* returns true if legacy mode is enabled</span>
 <span class="s0">*/ 1 4 this 3 715  </span>
<span class="s0">216 0 0 4 326 637 0 0 63 /**</span>
 <span class="s0">* Serializes this object, to implement pickle support.</span>
 <span class="s0">*/ 2 4 this 3 715  11 destination 1 698  </span>
<span class="s0">217 0 0 4 327 637 0 0 104 /**</span>
 <span class="s0">* Restores the object state from the given datagram, previously obtained using</span>
 <span class="s0">* __getstate__.</span>
 <span class="s0">*/ 2 4 this 3 714  6 source 1 700  </span>
<span class="s0">218 0 0 7 328 645 0 0 0 0 </span>
<span class="s0">219 0 0 7 330 717 509 0 168 /**</span>
 <span class="s0">* The default CollisionHandlerEvent will throw no events.  Its pattern</span>
 <span class="s0">* strings must first be set via a call to add_in_pattern() and/or</span>
 <span class="s0">* add_out_pattern().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">220 0 0 15 330 717 509 0 0 1 6 param0 0 718  </span>
<span class="s0">221 0 0 7 331 645 0 0 0 0 </span>
<span class="s0">222 0 0 7 334 720 519 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">223 0 0 15 334 720 519 0 0 1 6 param0 0 721  </span>
<span class="s0">224 0 0 4 335 637 0 0 257 /**</span>
 <span class="s0">* Sorts all the detected collisions front-to-back by</span>
 <span class="s0">* from_intersection_point() so that those intersection points closest to the</span>
 <span class="s0">* collider's origin (e.g., the center of the CollisionSphere, or the point_a</span>
 <span class="s0">* of a CollisionSegment) appear first.</span>
 <span class="s0">*/ 1 4 this 3 720  </span>
<span class="s0">225 0 0 4 336 637 0 0 50 /**</span>
 <span class="s0">* Removes all the entries from the queue.</span>
 <span class="s0">*/ 1 4 this 3 720  </span>
<span class="s0">226 0 0 6 337 591 0 0 69 /**</span>
 <span class="s0">* Returns the number of CollisionEntries detected last pass.</span>
 <span class="s0">*/ 1 4 this 3 721  </span>
<span class="s0">227 0 0 7 338 623 405 0 61 /**</span>
 <span class="s0">* Returns the nth CollisionEntry detected last pass.</span>
 <span class="s0">*/ 2 4 this 3 721  1 n 1 591  </span>
<span class="s0">228 0 0 4 342 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 721  3 out 1 642  </span>
<span class="s0">229 0 0 4 343 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 721  3 out 1 642  12 indent_level 5 591  </span>
<span class="s0">230 0 0 38 344 670 0 0 0 1 4 this 3 721  </span>
<span class="s0">231 0 0 7 345 645 0 0 0 0 </span>
<span class="s0">232 0 0 7 348 723 526 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 center 1 646  6 radius 1 581  </span>
<span class="s0">233 0 0 7 348 723 526 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 2 cx 1 581  2 cy 1 581  2 cz 1 581  6 radius 1 581  </span>
<span class="s0">234 0 0 4 349 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 723  6 center 1 646  </span>
<span class="s0">235 0 0 4 349 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 723  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">236 0 0 6 350 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 724  </span>
<span class="s0">237 0 0 4 351 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 723  6 radius 1 581  </span>
<span class="s0">238 0 0 6 352 581 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 724  </span>
<span class="s0">239 0 0 7 355 645 0 0 0 0 </span>
<span class="s0">240 0 0 7 358 726 529 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 center 1 646  6 radius 1 581  </span>
<span class="s0">241 0 0 7 358 726 529 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 2 cx 1 581  2 cy 1 581  2 cz 1 581  6 radius 1 581  </span>
<span class="s0">242 0 0 7 359 645 0 0 0 0 </span>
<span class="s0">243 0 0 7 362 727 537 0 183 /**</span>
 <span class="s0">* Creates an invalid ray.  This isn't terribly useful; it's expected that the</span>
 <span class="s0">* user will subsequently adjust the ray via set_origin()/set_direction() or</span>
 <span class="s0">* set_from_lens().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">244 0 0 7 362 727 537 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 origin 1 646  9 direction 1 638  </span>
<span class="s0">245 0 0 7 362 727 537 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 6 2 ox 1 581  2 oy 1 581  2 oz 1 581  2 dx 1 581  2 dy 1 581  2 dz 1 581  </span>
<span class="s0">246 0 0 4 363 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 727  6 origin 1 646  </span>
<span class="s0">247 0 0 4 363 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 727  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">248 0 0 6 364 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 728  </span>
<span class="s0">249 0 0 4 366 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 727  9 direction 1 638  </span>
<span class="s0">250 0 0 4 366 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 727  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">251 0 0 6 367 638 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 728  </span>
<span class="s0">252 0 0 6 369 574 0 0 327 /**</span>
 <span class="s0">* Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the</span>
 <span class="s0">* CollisionRay so that it begins at the LensNode's near plane and extends to</span>
 <span class="s0">* infinity, making it suitable for picking objects from the screen given a</span>
 <span class="s0">* camera and a mouse location.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the point was acceptable, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 727  6 camera 1 730  5 point 1 732  </span>
<span class="s0">253 0 0 6 369 574 0 0 262 /**</span>
 <span class="s0">* Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the</span>
 <span class="s0">* CollisionRay so that it begins at the LensNode's near plane and extends to</span>
 <span class="s0">* infinity, making it suitable for picking objects from the screen given a</span>
 <span class="s0">* camera and a mouse location.</span>
 <span class="s0">*/ 4 4 this 3 727  6 camera 1 730  2 px 1 581  2 py 1 581  </span>
<span class="s0">254 0 0 7 370 645 0 0 0 0 </span>
<span class="s0">255 0 0 7 373 736 540 0 185 /**</span>
 <span class="s0">* Creates an invalid line.  This isn't terribly useful; it's expected that</span>
 <span class="s0">* the user will subsequently adjust the line via set_origin()/set_direction()</span>
 <span class="s0">* or set_from_lens().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">256 0 0 7 373 736 540 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 origin 1 646  9 direction 1 638  </span>
<span class="s0">257 0 0 7 373 736 540 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 6 2 ox 1 581  2 oy 1 581  2 oz 1 581  2 dx 1 581  2 dy 1 581  2 dz 1 581  </span>
<span class="s0">258 0 0 7 374 645 0 0 0 0 </span>
<span class="s0">259 0 0 7 377 737 549 0 39 /**</span>
 <span class="s0">* Creates an invalid parabola.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">260 0 0 7 377 737 549 0 110 /**</span>
 <span class="s0">* Creates a parabola with the endpoints between t1 and t2 in the parametric</span>
 <span class="s0">* space of the parabola.</span>
 <span class="s0">*/ 3 8 parabola 1 738  2 t1 1 581  2 t2 1 581  </span>
<span class="s0">261 0 0 4 378 637 0 0 57 /**</span>
 <span class="s0">* Replaces the parabola specified by this solid.</span>
 <span class="s0">*/ 2 4 this 3 737  8 parabola 1 738  </span>
<span class="s0">262 0 0 6 379 738 0 0 56 /**</span>
 <span class="s0">* Returns the parabola specified by this solid.</span>
 <span class="s0">*/ 1 4 this 3 739  </span>
<span class="s0">263 0 0 4 380 637 0 0 54 /**</span>
 <span class="s0">* Changes the starting point on the parabola.</span>
 <span class="s0">*/ 2 4 this 3 737  2 t1 1 581  </span>
<span class="s0">264 0 0 6 381 581 0 0 54 /**</span>
 <span class="s0">* Returns the starting point on the parabola.</span>
 <span class="s0">*/ 1 4 this 3 739  </span>
<span class="s0">265 0 0 4 382 637 0 0 52 /**</span>
 <span class="s0">* Changes the ending point on the parabola.</span>
 <span class="s0">*/ 2 4 this 3 737  2 t2 1 581  </span>
<span class="s0">266 0 0 6 383 581 0 0 52 /**</span>
 <span class="s0">* Returns the ending point on the parabola.</span>
 <span class="s0">*/ 1 4 this 3 739  </span>
<span class="s0">267 0 0 7 390 645 0 0 0 0 </span>
<span class="s0">268 0 0 7 393 741 557 0 191 /**</span>
 <span class="s0">* Creates an invalid segment.  This isn't terribly useful; it's expected that</span>
 <span class="s0">* the user will subsequently adjust the segment via</span>
 <span class="s0">* set_origin()/set_direction() or set_from_lens().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">269 0 0 7 393 741 557 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 1 a 1 646  2 db 1 646  </span>
<span class="s0">270 0 0 7 393 741 557 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 6 2 ax 1 581  2 ay 1 581  2 az 1 581  2 bx 1 581  2 by 1 581  2 bz 1 581  </span>
<span class="s0">271 0 0 4 394 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 741  1 a 1 646  </span>
<span class="s0">272 0 0 4 394 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 741  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">273 0 0 6 395 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 742  </span>
<span class="s0">274 0 0 4 396 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 741  1 b 1 646  </span>
<span class="s0">275 0 0 4 396 637 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 741  1 x 1 581  1 y 1 581  1 z 1 581  </span>
<span class="s0">276 0 0 6 397 646 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 742  </span>
<span class="s0">277 0 0 6 398 574 0 0 336 /**</span>
 <span class="s0">* Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the</span>
 <span class="s0">* CollisionSegment so that it begins at the LensNode's near plane and extends</span>
 <span class="s0">* to the far plane, making it suitable for picking objects from the screen</span>
 <span class="s0">* given a camera and a mouse location.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the point was acceptable, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 741  6 camera 1 730  5 point 1 732  </span>
<span class="s0">278 0 0 6 398 574 0 0 271 /**</span>
 <span class="s0">* Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the</span>
 <span class="s0">* CollisionSegment so that it begins at the LensNode's near plane and extends</span>
 <span class="s0">* to the far plane, making it suitable for picking objects from the screen</span>
 <span class="s0">* given a camera and a mouse location.</span>
 <span class="s0">*/ 4 4 this 3 741  6 camera 1 730  2 px 1 581  2 py 1 581  </span>
<span class="s0">279 0 0 7 401 645 0 0 0 0 </span>
<span class="s0">280 0 0 15 409 669 563 0 28 /**</span>
 <span class="s0">* Copy constructor.</span>
 <span class="s0">*/ 1 4 copy 1 744  </span>
<span class="s0">281 0 0 7 409 669 563 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 658  </span>
<span class="s0">282 0 0 4 411 637 0 0 412 /**</span>
 <span class="s0">* Scales the points that are drawn to represent the surface and interior</span>
 <span class="s0">* intersection points of the collisions.  By default, these objects are drawn</span>
 <span class="s0">* at an arbitrary scale which is appropriate if the window units are the</span>
 <span class="s0">* default range -1 .. 1.  Change this scale accordinatly if the window units</span>
 <span class="s0">* are measured on some other scale or if you need to observe these objects in</span>
 <span class="s0">* a smaller window.</span>
 <span class="s0">*/ 2 4 this 3 669  11 point_scale 1 581  </span>
<span class="s0">283 0 0 6 412 581 0 0 59 /**</span>
 <span class="s0">* Returns the value last set by set_point_scale().</span>
 <span class="s0">*/ 1 4 this 3 744  </span>
<span class="s0">284 0 0 4 413 637 0 0 370 /**</span>
 <span class="s0">* Scales the line segments that are drawn to represent the normals of the</span>
 <span class="s0">* collisions.  By default, these objects are drawn at an arbitrary scale</span>
 <span class="s0">* which is appropriate if the scene units are measured in feet.  Change this</span>
 <span class="s0">* scale accordinatly if the scene units are measured on some other scale or</span>
 <span class="s0">* if you need to observe these normals from farther away.</span>
 <span class="s0">*/ 2 4 this 3 669  12 normal_scale 1 581  </span>
<span class="s0">285 0 0 6 414 581 0 0 60 /**</span>
 <span class="s0">* Returns the value last set by set_normal_scale().</span>
 <span class="s0">*/ 1 4 this 3 744  </span>
<span class="s0">286 0 0 4 415 637 0 0 110 /**</span>
 <span class="s0">* Removes all the visualization data from a previous traversal and resets the</span>
 <span class="s0">* visualizer to empty.</span>
 <span class="s0">*/ 1 4 this 3 669  </span>
<span class="s0">287 0 0 7 418 645 0 0 0 0 </span>
<span class="s0">288 0 0 7 405 603 0 0 0 1 4 this 3 669  </span>
<span class="s0">289 0 0 6 407 595 0 0 0 1 4 this 3 669  </span>
<span class="s0">176</span>
<span class="s0">570 14 CollisionSolid 0 75777 14 CollisionSolid 14 CollisionSolid 0 0 0 0 0 4 746 747 748 749 14 290 291 292 293 294 295 296 297 298 299 300 301 302 303 0 0 1 0 571 0 0 0 0 457</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract base class for all things that can collide with other things</span>
 <span class="s0">* in the world, and all the things they can collide with (except geometry).</span>
 <span class="s0">*</span>
 <span class="s0">* This class and its derivatives really work very similarly to the way</span>
 <span class="s0">* BoundingVolume and all of its derivatives work.  There's a different</span>
 <span class="s0">* subclass for each basic shape of solid, and double-dispatch function calls</span>
 <span class="s0">* handle the subset of the N*N intersection tests that we care about.</span>
 <span class="s0">*/</span>

<span class="s0">571 17 CopyOnWriteObject 0 2048 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169</span>
<span class="s0">/**</span>
 <span class="s0">* This base class provides basic reference counting, but also can be used</span>
 <span class="s0">* with a CopyOnWritePointer to provide get_read_pointer() and</span>
 <span class="s0">* get_write_pointer().</span>
 <span class="s0">*/</span>

<span class="s0">572 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 573 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">573 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">574 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">575 32 ConstPointerTo&lt; BoundingVolume &gt; 0 2048 32 ConstPointerTo&lt; BoundingVolume &gt; 32 ConstPointerTo&lt; BoundingVolume &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">576 12 CollisionBox 0 141313 12 CollisionBox 12 CollisionBox 0 0 0 1 304 317 4 750 751 752 753 12 305 306 307 308 309 310 311 312 313 314 315 316 0 0 1 0 570 0 0 0 0 47</span>
<span class="s0">/**</span>
 <span class="s0">* A cuboid collision volume or object.</span>
 <span class="s0">*/</span>

<span class="s0">577 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 572 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">578 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 579 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">579 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">580 16 CollisionCapsule 0 141313 16 CollisionCapsule 16 CollisionCapsule 0 0 0 1 318 326 3 754 755 756 7 319 320 321 322 323 324 325 0 0 1 0 570 0 0 0 0 201</span>
<span class="s0">/**</span>
 <span class="s0">* This implements a solid consisting of a cylinder with hemispherical endcaps,</span>
 <span class="s0">* also known as a capsule or a spherocylinder.</span>
 <span class="s0">*</span>
 <span class="s0">* This shape was previously erroneously called CollisionTube.</span>
 <span class="s0">*/</span>

<span class="s0">581 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 582 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">582 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">583 16 CollisionHandler 0 141313 16 CollisionHandler 16 CollisionHandler 0 0 0 1 328 329 0 1 327 0 0 1 0 584 0 0 0 0 262</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract interface to a number of classes that decide what to do when a</span>
 <span class="s0">* collision is detected.  One of these must be assigned to the</span>
 <span class="s0">* CollisionTraverser that is processing collisions in order to specify how to</span>
 <span class="s0">* dispatch detected collisions.</span>
 <span class="s0">*/</span>

<span class="s0">584 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">585 13 CollisionNode 0 75777 13 CollisionNode 13 CollisionNode 0 0 0 1 330 0 5 757 758 759 760 761 17 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 1 810 0 1 0 586 0 0 0 0 261</span>
<span class="s0">/**</span>
 <span class="s0">* A node in the scene graph that can hold any number of CollisionSolids.</span>
 <span class="s0">* This may either represent a bit of static geometry in the scene that things</span>
 <span class="s0">* will collide with, or an animated object twirling around in the world and</span>
 <span class="s0">* running into things.</span>
 <span class="s0">*/</span>

<span class="s0">586 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A basic node of the scene graph or data graph.  This is the base class of</span>
 <span class="s0">* all specialized nodes, and also serves as a generic node with no special</span>
 <span class="s0">* properties.</span>
 <span class="s0">*/</span>

<span class="s0">587 11 CollideMask 0 2105344 11 CollideMask 11 CollideMask 0 0 588 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">588 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 589 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">589 23 BitMask&lt; uint32_t, 32 &gt; 0 2048 23 BitMask&lt; uint32_t, 32 &gt; 23 BitMask&lt; uint32_t, 32 &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">590 32 ConstPointerTo&lt; CollisionSolid &gt; 0 2048 32 ConstPointerTo&lt; CollisionSolid &gt; 32 ConstPointerTo&lt; CollisionSolid &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">591 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">592 18 CollisionTraverser 0 26625 18 CollisionTraverser 18 CollisionTraverser 0 0 0 1 348 349 4 762 763 764 765 21 350 351 352 353 354 355 356 357 358 359 360 361 362 363 366 367 368 369 370 371 372 1 811 0 1 0 593 0 0 0 0 467</span>
<span class="s0">/**</span>
 <span class="s0">* This class manages the traversal through the scene graph to detect</span>
 <span class="s0">* collisions.  It holds ownership of a number of collider objects, each of</span>
 <span class="s0">* which is a CollisionNode and an associated CollisionHandler.</span>
 <span class="s0">*</span>
 <span class="s0">* When traverse() is called, it begins at the indicated root and detects all</span>
 <span class="s0">* collisions with any of its collider objects against nodes at or below the</span>
 <span class="s0">* indicated root, calling the appropriate CollisionHandler for each detected</span>
 <span class="s0">* collision.</span>
 <span class="s0">*/</span>

<span class="s0">593 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">594 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">595 19 CollisionRecorder * 0 8576 19 CollisionRecorder * 19 CollisionRecorder * 0 0 596 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">596 17 CollisionRecorder 0 75777 17 CollisionRecorder 17 CollisionRecorder 0 0 0 0 0 0 2 364 365 0 0 1 0 597 0 0 0 0 206</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used to help debug the work the collisions system is doing.</span>
 <span class="s0">* It is a virtual base class that just provides an interface for recording</span>
 <span class="s0">* collisions tested and detected each frame.</span>
 <span class="s0">*/</span>

<span class="s0">597 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">598 14 CollisionEntry 0 141313 14 CollisionEntry 14 CollisionEntry 0 0 0 0 405 8 766 767 768 769 770 771 772 773 32 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 0 0 1 0 599 0 0 0 0 437</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a single collision event.  One of these is created for each</span>
 <span class="s0">* collision detected by a CollisionTraverser, to be dealt with by the</span>
 <span class="s0">* CollisionHandler.</span>
 <span class="s0">*</span>
 <span class="s0">* A CollisionEntry provides slots for a number of data values (such as</span>
 <span class="s0">* intersection point and normal) that might or might not be known for each</span>
 <span class="s0">* collision.  It is up to the handler to determine what information is known</span>
 <span class="s0">* and to do the right thing with it.</span>
 <span class="s0">*/</span>

<span class="s0">599 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedWritable and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedWritables and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">600 22 CollisionSolid const * 0 8576 22 CollisionSolid const * 22 CollisionSolid const * 0 0 601 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">601 20 CollisionSolid const 0 8832 20 CollisionSolid const 20 CollisionSolid const 0 0 570 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">602 15 CollisionNode * 0 8576 15 CollisionNode * 15 CollisionNode * 0 0 585 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">603 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 586 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">604 14 CollisionPlane 0 141313 14 CollisionPlane 14 CollisionPlane 0 0 0 1 406 413 2 774 775 6 407 408 409 410 411 412 0 0 1 0 570 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">605 12 LPlane const 0 8832 12 LPlane const 12 LPlane const 0 0 606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">606 6 LPlane 0 2105344 6 LPlane 6 LPlane 0 0 607 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">607 7 LPlanef 0 2048 7 LPlanef 7 LPlanef 0 0 0 0 0 0 0 0 0 0 0 0 120</span>
<span class="s0">/**</span>
 <span class="s0">* An abstract mathematical description of a plane.  A plane is defined by the</span>
 <span class="s0">* equation Ax + By + Cz + D = 0.</span>
 <span class="s0">*/</span>

<span class="s0">608 18 CollisionFloorMesh 0 141313 18 CollisionFloorMesh 18 CollisionFloorMesh 0 0 0 1 414 422 2 776 777 7 415 416 417 418 419 420 421 2 812 813 0 1 0 570 0 0 0 0 124</span>
<span class="s0">/**</span>
 <span class="s0">* This object represents a solid made entirely of triangles, which will only</span>
 <span class="s0">* be tested again z axis aligned rays</span>
 <span class="s0">*/</span>

<span class="s0">609 8 LPoint3i 0 2048 8 LPoint3i 8 LPoint3i 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">610 16 CollisionPolygon 0 141313 16 CollisionPolygon 16 CollisionPolygon 0 0 0 1 423 430 3 778 779 780 6 424 425 426 427 428 429 1 814 0 1 0 604 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">611 21 CollisionHandlerEvent 0 141313 21 CollisionHandlerEvent 21 CollisionHandlerEvent 0 0 0 1 431 454 3 781 782 783 22 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 3 815 816 817 0 1 0 583 0 0 0 0 296</span>
<span class="s0">/**</span>
 <span class="s0">* A specialized kind of CollisionHandler that throws an event for each</span>
 <span class="s0">* collision detected.  The event thrown may be based on the name of the</span>
 <span class="s0">* moving object or the struck object, or both.  The first parameter of the</span>
 <span class="s0">* event will be a pointer to the CollisionEntry that triggered it.</span>
 <span class="s0">*/</span>

<span class="s0">612 6 string 0 2105344 11 std::string 11 std::string 0 0 613 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">613 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">614 24 CollisionHandlerPhysical 0 75777 24 CollisionHandlerPhysical 24 CollisionHandlerPhysical 0 0 0 0 454 1 784 12 455 456 457 458 459 460 461 462 463 464 465 466 0 0 1 0 611 0 0 0 0 209</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract base class for a number of CollisionHandlers that have some</span>
 <span class="s0">* physical effect on their moving bodies: they need to update the nodes'</span>
 <span class="s0">* positions based on the effects of the collision.</span>
 <span class="s0">*/</span>

<span class="s0">615 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 594 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">616 21 CollisionHandlerFloor 0 75777 21 CollisionHandlerFloor 21 CollisionHandlerFloor 0 0 0 1 467 454 3 785 786 787 9 468 469 470 471 472 473 474 475 476 0 0 1 0 614 0 0 0 0 294</span>
<span class="s0">/**</span>
 <span class="s0">* A specialized kind of CollisionHandler that sets the Z height of the</span>
 <span class="s0">* collider to a fixed linear offset from the highest detected collision point</span>
 <span class="s0">* each frame.  It's intended to implement walking around on a floor of</span>
 <span class="s0">* varying height by casting a ray down from the avatar's head.</span>
 <span class="s0">*/</span>

<span class="s0">617 22 CollisionHandlerPusher 0 75777 22 CollisionHandlerPusher 22 CollisionHandlerPusher 0 0 0 1 477 454 1 788 5 478 479 480 481 482 0 0 1 0 614 0 0 0 0 197</span>
<span class="s0">/**</span>
 <span class="s0">* A specialized kind of CollisionHandler that simply pushes back on things</span>
 <span class="s0">* that attempt to move into solid walls.  This is the simplest kind of &quot;real-</span>
 <span class="s0">* world&quot; collisions you can have.</span>
 <span class="s0">*/</span>

<span class="s0">618 27 CollisionHandlerFluidPusher 0 141313 27 CollisionHandlerFluidPusher 27 CollisionHandlerFluidPusher 0 0 0 1 483 485 0 1 484 0 0 1 0 617 0 0 0 0 139</span>
<span class="s0">/**</span>
 <span class="s0">* A CollisionHandlerPusher that makes use of timing and spatial information</span>
 <span class="s0">* from fluid collisions to improve collision response</span>
 <span class="s0">*/</span>

<span class="s0">619 23 CollisionHandlerGravity 0 75777 23 CollisionHandlerGravity 23 CollisionHandlerGravity 0 0 0 1 486 454 9 789 790 791 792 793 794 795 796 797 20 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 0 0 1 0 614 0 0 0 0 294</span>
<span class="s0">/**</span>
 <span class="s0">* A specialized kind of CollisionHandler that sets the Z height of the</span>
 <span class="s0">* collider to a fixed linear offset from the highest detected collision point</span>
 <span class="s0">* each frame.  It's intended to implement walking around on a floor of</span>
 <span class="s0">* varying height by casting a ray down from the avatar's head.</span>
 <span class="s0">*/</span>

<span class="s0">620 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 578 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">621 28 CollisionHandlerHighestEvent 0 141313 28 CollisionHandlerHighestEvent 28 CollisionHandlerHighestEvent 0 0 0 1 507 509 0 1 508 0 0 1 0 611 0 0 0 0 296</span>
<span class="s0">/**</span>
 <span class="s0">* A specialized kind of CollisionHandler that throws an event for each</span>
 <span class="s0">* collision detected.  The event thrown may be based on the name of the</span>
 <span class="s0">* moving object or the struck object, or both.  The first parameter of the</span>
 <span class="s0">* event will be a pointer to the CollisionEntry that triggered it.</span>
 <span class="s0">*/</span>

<span class="s0">622 21 CollisionHandlerQueue 0 141313 21 CollisionHandlerQueue 21 CollisionHandlerQueue 0 0 0 1 510 519 1 798 8 511 512 513 514 515 516 517 518 1 818 0 1 0 583 0 0 0 0 313</span>
<span class="s0">/**</span>
 <span class="s0">* A special kind of CollisionHandler that does nothing except remember the</span>
 <span class="s0">* CollisionEntries detected the last pass.  This set of CollisionEntries may</span>
 <span class="s0">* then be queried by the calling function.  It's primarily useful when a</span>
 <span class="s0">* simple intersection test is being made, e.g.  for picking from the window.</span>
 <span class="s0">*/</span>

<span class="s0">623 16 CollisionEntry * 0 8576 16 CollisionEntry * 16 CollisionEntry * 0 0 598 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">624 15 CollisionSphere 0 141313 15 CollisionSphere 15 CollisionSphere 0 0 0 1 520 526 2 799 800 5 521 522 523 524 525 0 0 1 0 570 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* A spherical collision volume or object.</span>
 <span class="s0">*/</span>

<span class="s0">625 18 CollisionInvSphere 0 141313 18 CollisionInvSphere 18 CollisionInvSphere 0 0 0 1 527 529 0 1 528 0 0 1 0 624 0 0 0 0 272</span>
<span class="s0">/**</span>
 <span class="s0">* An inverted sphere: this is a sphere whose collision surface is the inside</span>
 <span class="s0">* surface of the sphere.  Everything outside the sphere is solid matter;</span>
 <span class="s0">* everything inside is empty space.  Useful for constraining objects to</span>
 <span class="s0">* remain within a spherical perimeter.</span>
 <span class="s0">*/</span>

<span class="s0">626 12 CollisionRay 0 141313 12 CollisionRay 12 CollisionRay 0 0 0 1 530 537 2 801 802 6 531 532 533 534 535 536 0 0 1 0 570 0 0 0 0 220</span>
<span class="s0">/**</span>
 <span class="s0">* An infinite ray, with a specific origin and direction.  It begins at its</span>
 <span class="s0">* origin and continues in one direction to infinity, and it has no radius.</span>
 <span class="s0">* Useful for picking from a window, or for gravity effects.</span>
 <span class="s0">*/</span>

<span class="s0">627 13 CollisionLine 0 141313 13 CollisionLine 13 CollisionLine 0 0 0 1 538 540 0 1 539 0 0 1 0 626 0 0 0 0 131</span>
<span class="s0">/**</span>
 <span class="s0">* An infinite line, similar to a CollisionRay, except that it extends in both</span>
 <span class="s0">* directions.  It is, however, directional.</span>
 <span class="s0">*/</span>

<span class="s0">628 17 CollisionParabola 0 141313 17 CollisionParabola 17 CollisionParabola 0 0 0 1 541 549 3 803 804 805 7 542 543 544 545 546 547 548 0 0 1 0 570 0 0 0 0 308</span>
<span class="s0">/**</span>
 <span class="s0">* This defines a parabolic arc, or subset of an arc, similar to the path of a</span>
 <span class="s0">* projectile or falling object.  It is finite, having a specific beginning</span>
 <span class="s0">* and end, but it is infinitely thin.</span>
 <span class="s0">*</span>
 <span class="s0">* Think of it as a wire bending from point t1 to point t2 along the path of a</span>
 <span class="s0">* pre-defined parabola.</span>
 <span class="s0">*/</span>

<span class="s0">629 15 LParabola const 0 8832 15 LParabola const 15 LParabola const 0 0 630 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">630 9 LParabola 0 2105344 9 LParabola 9 LParabola 0 0 631 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">631 10 LParabolaf 0 2048 10 LParabolaf 10 LParabolaf 0 0 0 0 0 0 0 0 0 0 0 0 200</span>
<span class="s0">/**</span>
 <span class="s0">* An abstract mathematical description of a parabola, particularly useful for</span>
 <span class="s0">* describing arcs of projectiles.</span>
 <span class="s0">*</span>
 <span class="s0">* The parabolic equation, given parametrically here, is P = At^2 + Bt + C.</span>
 <span class="s0">*/</span>

<span class="s0">632 16 CollisionSegment 0 141313 16 CollisionSegment 16 CollisionSegment 0 0 0 1 550 557 2 806 807 6 551 552 553 554 555 556 0 0 1 0 570 0 0 0 0 371</span>
<span class="s0">/**</span>
 <span class="s0">* A finite line segment, with two specific endpoints but no thickness.  It's</span>
 <span class="s0">* similar to a CollisionRay, except it does not continue to infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* It does have an ordering, from point A to point B. If more than a single</span>
 <span class="s0">* point of the segment is intersecting a solid, the reported intersection</span>
 <span class="s0">* point is generally the closest on the segment to point A.</span>
 <span class="s0">*/</span>

<span class="s0">633 13 CollisionTube 0 2105345 13 CollisionTube 13 CollisionTube 0 0 580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">634 19 CollisionVisualizer 0 26625 19 CollisionVisualizer 19 CollisionVisualizer 0 0 0 1 562 563 2 808 809 6 564 565 566 567 568 569 0 0 2 3 586 558 559 3 596 560 561 0 0 304</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used to help debug the work the collisions system is doing.</span>
 <span class="s0">* It shows the polygons that are detected as collisions, as well as those</span>
 <span class="s0">* that are simply considered for collisions.</span>
 <span class="s0">*</span>
 <span class="s0">* It may be parented anywhere in the scene graph where it will be rendered to</span>
 <span class="s0">* achieve this.</span>
 <span class="s0">*/</span>

<span class="s0">635 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 572 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">636 16 CollisionSolid * 0 8576 16 CollisionSolid * 16 CollisionSolid * 0 0 570 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">637 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">638 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 620 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">639 20 BoundingVolume const 0 8832 20 BoundingVolume const 20 BoundingVolume const 0 0 640 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">640 14 BoundingVolume 0 2048 14 BoundingVolume 14 BoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 330</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class for any volume in any sense which can be said to</span>
 <span class="s0">* define the locality of reference of a node in a graph, along with all of</span>
 <span class="s0">* its descendants.  It is not necessarily a geometric volume (although see</span>
 <span class="s0">* GeometricBoundingVolume); this is simply an abstract interface for bounds</span>
 <span class="s0">* of any sort.</span>
 <span class="s0">*/</span>

<span class="s0">641 22 BoundingVolume const * 0 8576 22 BoundingVolume const * 22 BoundingVolume const * 0 0 639 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">642 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 643 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">643 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">644 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">645 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 644 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">646 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 577 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">647 14 CollisionBox * 0 8576 14 CollisionBox * 14 CollisionBox * 0 0 576 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">648 20 CollisionBox const * 0 8576 20 CollisionBox const * 20 CollisionBox const * 0 0 649 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">649 18 CollisionBox const 0 8832 18 CollisionBox const 18 CollisionBox const 0 0 576 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">650 8 LPlane * 0 8576 8 LPlane * 8 LPlane * 0 0 606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">651 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 578 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">652 18 CollisionCapsule * 0 8576 18 CollisionCapsule * 18 CollisionCapsule * 0 0 580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">653 24 CollisionCapsule const * 0 8576 24 CollisionCapsule const * 24 CollisionCapsule const * 0 0 654 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">654 22 CollisionCapsule const 0 8832 22 CollisionCapsule const 22 CollisionCapsule const 0 0 580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">655 24 CollisionHandler const * 0 8576 24 CollisionHandler const * 24 CollisionHandler const * 0 0 656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">656 22 CollisionHandler const 0 8832 22 CollisionHandler const 22 CollisionHandler const 0 0 583 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">657 18 CollisionHandler * 0 8576 18 CollisionHandler * 18 CollisionHandler * 0 0 583 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">658 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">659 13 CollideMask * 0 8576 13 CollideMask * 13 CollideMask * 0 0 587 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">660 21 CollisionNode const * 0 8576 21 CollisionNode const * 21 CollisionNode const * 0 0 661 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">661 19 CollisionNode const 0 8832 19 CollisionNode const 19 CollisionNode const 0 0 585 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">662 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 663 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">663 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">664 26 CollisionTraverser const * 0 8576 26 CollisionTraverser const * 26 CollisionTraverser const * 0 0 665 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">665 24 CollisionTraverser const 0 8832 24 CollisionTraverser const 24 CollisionTraverser const 0 0 592 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">666 20 CollisionTraverser * 0 8576 20 CollisionTraverser * 20 CollisionTraverser * 0 0 592 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">667 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">668 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 594 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">669 21 CollisionVisualizer * 0 8576 21 CollisionVisualizer * 21 CollisionVisualizer * 0 0 634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">670 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 671 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">671 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 672 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">672 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">673 25 CollisionRecorder const * 0 8576 25 CollisionRecorder const * 25 CollisionRecorder const * 0 0 674 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">674 23 CollisionRecorder const 0 8832 23 CollisionRecorder const 23 CollisionRecorder const 0 0 596 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">675 22 CollisionEntry const * 0 8576 22 CollisionEntry const * 22 CollisionEntry const * 0 0 676 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">676 20 CollisionEntry const 0 8832 20 CollisionEntry const 20 CollisionEntry const 0 0 598 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">677 22 CollisionPlane const * 0 8576 22 CollisionPlane const * 22 CollisionPlane const * 0 0 678 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">678 20 CollisionPlane const 0 8832 20 CollisionPlane const 20 CollisionPlane const 0 0 604 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">679 16 CollisionPlane * 0 8576 16 CollisionPlane * 16 CollisionPlane * 0 0 604 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">680 14 LPlane const * 0 8576 14 LPlane const * 14 LPlane const * 0 0 605 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">681 20 CollisionFloorMesh * 0 8576 20 CollisionFloorMesh * 20 CollisionFloorMesh * 0 0 608 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">682 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">683 26 CollisionFloorMesh const * 0 8576 26 CollisionFloorMesh const * 26 CollisionFloorMesh const * 0 0 684 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">684 24 CollisionFloorMesh const 0 8832 24 CollisionFloorMesh const 24 CollisionFloorMesh const 0 0 608 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">685 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 609 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">686 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 687 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">687 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 688 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">688 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 689 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">689 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">690 18 CollisionPolygon * 0 8576 18 CollisionPolygon * 18 CollisionPolygon * 0 0 610 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">691 24 CollisionPolygon const * 0 8576 24 CollisionPolygon const * 24 CollisionPolygon const * 0 0 692 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">692 22 CollisionPolygon const 0 8832 22 CollisionPolygon const 22 CollisionPolygon const 0 0 610 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">693 23 CollisionHandlerEvent * 0 8576 23 CollisionHandlerEvent * 23 CollisionHandlerEvent * 0 0 611 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">694 29 CollisionHandlerEvent const * 0 8576 29 CollisionHandlerEvent const * 29 CollisionHandlerEvent const * 0 0 695 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">695 27 CollisionHandlerEvent const 0 8832 27 CollisionHandlerEvent const 27 CollisionHandlerEvent const 0 0 611 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">696 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 697 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">697 24 pvector&lt; unsigned char &gt; 0 2048 24 pvector&lt; unsigned char &gt; 24 pvector&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">698 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 699 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">699 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">700 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 701 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">701 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 365</span>
<span class="s0">/**</span>
 <span class="s0">* A class to retrieve the individual data elements previously stored in a</span>
 <span class="s0">* Datagram.  Elements may be retrieved one at a time; it is up to the caller</span>
 <span class="s0">* to know the correct type and order of each element.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that it is the responsibility of the caller to ensure that the datagram</span>
 <span class="s0">* object is not destructed while this DatagramIterator is in use.</span>
 <span class="s0">*/</span>

<span class="s0">702 26 CollisionHandlerPhysical * 0 8576 26 CollisionHandlerPhysical * 26 CollisionHandlerPhysical * 0 0 614 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">703 16 DriveInterface * 0 8576 16 DriveInterface * 16 DriveInterface * 0 0 704 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">704 14 DriveInterface 0 2048 14 DriveInterface 14 DriveInterface 0 0 0 0 0 0 0 0 0 0 0 0 191</span>
<span class="s0">/**</span>
 <span class="s0">* This is a TFormer, similar to Trackball, that moves around a transform</span>
 <span class="s0">* matrix in response to mouse input.  The basic motion is on a horizontal</span>
 <span class="s0">* plane, as if driving a vehicle.</span>
 <span class="s0">*/</span>

<span class="s0">705 32 CollisionHandlerPhysical const * 0 8576 32 CollisionHandlerPhysical const * 32 CollisionHandlerPhysical const * 0 0 706 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">706 30 CollisionHandlerPhysical const 0 8832 30 CollisionHandlerPhysical const 30 CollisionHandlerPhysical const 0 0 614 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">707 23 CollisionHandlerFloor * 0 8576 23 CollisionHandlerFloor * 23 CollisionHandlerFloor * 0 0 616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">708 29 CollisionHandlerFloor const * 0 8576 29 CollisionHandlerFloor const * 29 CollisionHandlerFloor const * 0 0 709 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">709 27 CollisionHandlerFloor const 0 8832 27 CollisionHandlerFloor const 27 CollisionHandlerFloor const 0 0 616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">710 24 CollisionHandlerPusher * 0 8576 24 CollisionHandlerPusher * 24 CollisionHandlerPusher * 0 0 617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">711 30 CollisionHandlerPusher const * 0 8576 30 CollisionHandlerPusher const * 30 CollisionHandlerPusher const * 0 0 712 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">712 28 CollisionHandlerPusher const 0 8832 28 CollisionHandlerPusher const 28 CollisionHandlerPusher const 0 0 617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">713 29 CollisionHandlerFluidPusher * 0 8576 29 CollisionHandlerFluidPusher * 29 CollisionHandlerFluidPusher * 0 0 618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">714 25 CollisionHandlerGravity * 0 8576 25 CollisionHandlerGravity * 25 CollisionHandlerGravity * 0 0 619 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">715 31 CollisionHandlerGravity const * 0 8576 31 CollisionHandlerGravity const * 31 CollisionHandlerGravity const * 0 0 716 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">716 29 CollisionHandlerGravity const 0 8832 29 CollisionHandlerGravity const 29 CollisionHandlerGravity const 0 0 619 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">717 30 CollisionHandlerHighestEvent * 0 8576 30 CollisionHandlerHighestEvent * 30 CollisionHandlerHighestEvent * 0 0 621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">718 36 CollisionHandlerHighestEvent const * 0 8576 36 CollisionHandlerHighestEvent const * 36 CollisionHandlerHighestEvent const * 0 0 719 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">719 34 CollisionHandlerHighestEvent const 0 8832 34 CollisionHandlerHighestEvent const 34 CollisionHandlerHighestEvent const 0 0 621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">720 23 CollisionHandlerQueue * 0 8576 23 CollisionHandlerQueue * 23 CollisionHandlerQueue * 0 0 622 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">721 29 CollisionHandlerQueue const * 0 8576 29 CollisionHandlerQueue const * 29 CollisionHandlerQueue const * 0 0 722 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">722 27 CollisionHandlerQueue const 0 8832 27 CollisionHandlerQueue const 27 CollisionHandlerQueue const 0 0 622 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">723 17 CollisionSphere * 0 8576 17 CollisionSphere * 17 CollisionSphere * 0 0 624 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">724 23 CollisionSphere const * 0 8576 23 CollisionSphere const * 23 CollisionSphere const * 0 0 725 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">725 21 CollisionSphere const 0 8832 21 CollisionSphere const 21 CollisionSphere const 0 0 624 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">726 20 CollisionInvSphere * 0 8576 20 CollisionInvSphere * 20 CollisionInvSphere * 0 0 625 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">727 14 CollisionRay * 0 8576 14 CollisionRay * 14 CollisionRay * 0 0 626 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">728 20 CollisionRay const * 0 8576 20 CollisionRay const * 20 CollisionRay const * 0 0 729 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">729 18 CollisionRay const 0 8832 18 CollisionRay const 18 CollisionRay const 0 0 626 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">730 10 LensNode * 0 8576 10 LensNode * 10 LensNode * 0 0 731 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">731 8 LensNode 0 2048 8 LensNode 8 LensNode 0 0 0 0 0 0 0 0 0 0 0 0 181</span>
<span class="s0">/**</span>
 <span class="s0">* A node that contains a Lens.  The most important example of this kind of</span>
 <span class="s0">* node is a Camera, but other kinds of nodes also contain a lens (for</span>
 <span class="s0">* instance, a Spotlight).</span>
 <span class="s0">*/</span>

<span class="s0">732 15 LPoint2 const * 0 8576 15 LPoint2 const * 15 LPoint2 const * 0 0 733 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">733 13 LPoint2 const 0 8832 13 LPoint2 const 13 LPoint2 const 0 0 734 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">734 7 LPoint2 0 2105344 7 LPoint2 7 LPoint2 0 0 735 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">735 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">736 15 CollisionLine * 0 8576 15 CollisionLine * 15 CollisionLine * 0 0 627 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">737 19 CollisionParabola * 0 8576 19 CollisionParabola * 19 CollisionParabola * 0 0 628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">738 17 LParabola const * 0 8576 17 LParabola const * 17 LParabola const * 0 0 629 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">739 25 CollisionParabola const * 0 8576 25 CollisionParabola const * 25 CollisionParabola const * 0 0 740 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">740 23 CollisionParabola const 0 8832 23 CollisionParabola const 23 CollisionParabola const 0 0 628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">741 18 CollisionSegment * 0 8576 18 CollisionSegment * 18 CollisionSegment * 0 0 632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">742 24 CollisionSegment const * 0 8576 24 CollisionSegment const * 24 CollisionSegment const * 0 0 743 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">743 22 CollisionSegment const 0 8832 22 CollisionSegment const 22 CollisionSegment const 0 0 632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">744 27 CollisionVisualizer const * 0 8576 27 CollisionVisualizer const * 27 CollisionVisualizer const * 0 0 745 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">745 25 CollisionVisualizer const 0 8832 25 CollisionVisualizer const 25 CollisionVisualizer const 0 0 634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">64</span>
<span class="s0">746 16 collision_origin 0 2 572 290 0 0 0 0 0 0 0 32 CollisionSolid::collision_origin 0</span>

<span class="s0">747 8 tangible 0 6 574 292 291 0 0 0 0 0 0 24 CollisionSolid::tangible 0</span>

<span class="s0">748 24 respect_effective_normal 0 6 574 298 297 0 0 0 0 0 0 40 CollisionSolid::respect_effective_normal 0</span>

<span class="s0">749 6 bounds 0 6 575 299 300 0 0 0 0 0 0 22 CollisionSolid::bounds 0</span>

<span class="s0">750 6 center 0 2 577 312 0 0 0 0 0 0 0 20 CollisionBox::center 0</span>

<span class="s0">751 3 min 0 2 577 313 0 0 0 0 0 0 0 17 CollisionBox::min 0</span>

<span class="s0">752 3 max 0 2 577 314 0 0 0 0 0 0 0 17 CollisionBox::max 0</span>

<span class="s0">753 10 dimensions 0 2 578 315 0 0 0 0 0 0 0 24 CollisionBox::dimensions 0</span>

<span class="s0">754 7 point_a 0 6 577 320 319 0 0 0 0 0 0 25 CollisionCapsule::point_a 0</span>

<span class="s0">755 7 point_b 0 6 577 322 321 0 0 0 0 0 0 25 CollisionCapsule::point_b 0</span>

<span class="s0">756 6 radius 0 6 581 324 323 0 0 0 0 0 0 24 CollisionCapsule::radius 0</span>

<span class="s0">757 17 from_collide_mask 0 6 587 334 332 0 0 0 0 0 0 32 CollisionNode::from_collide_mask 0</span>

<span class="s0">758 17 into_collide_mask 0 6 587 335 333 0 0 0 0 0 0 32 CollisionNode::into_collide_mask 0</span>

<span class="s0">759 6 solids 0 358 590 338 340 0 0 342 337 341 0 21 CollisionNode::solids 0</span>

<span class="s0">760 13 collider_sort 0 6 591 344 345 0 0 0 0 0 0 28 CollisionNode::collider_sort 0</span>

<span class="s0">761 20 default_collide_mask 0 2 587 346 0 0 0 0 0 0 0 35 CollisionNode::default_collide_mask 0</span>

<span class="s0">762 22 respect_preV_transform 0 6 574 351 350 0 0 0 0 0 0 42 CollisionTraverser::respect_preV_transform 0</span>

<span class="s0">763 22 respect_prev_transform 0 6 574 351 350 0 0 0 0 0 0 42 CollisionTraverser::respect_prev_transform 0</span>

<span class="s0">764 9 colliders 0 66 594 356 0 0 0 0 355 0 0 29 CollisionTraverser::colliders 0</span>

<span class="s0">765 8 recorder 0 30 595 362 360 361 363 0 0 0 0 28 CollisionTraverser::recorder 0</span>

<span class="s0">766 10 from_solid 0 2 600 373 0 0 0 0 0 0 0 26 CollisionEntry::from_solid 0</span>

<span class="s0">767 10 into_solid 0 2 600 375 0 0 0 0 0 0 0 26 CollisionEntry::into_solid 0</span>

<span class="s0">768 9 from_node 0 2 602 376 0 0 0 0 0 0 0 25 CollisionEntry::from_node 0</span>

<span class="s0">769 9 into_node 0 2 603 377 0 0 0 0 0 0 0 25 CollisionEntry::into_node 0</span>

<span class="s0">770 14 from_node_path 0 2 594 378 0 0 0 0 0 0 0 30 CollisionEntry::from_node_path 0</span>

<span class="s0">771 14 into_node_path 0 2 594 379 0 0 0 0 0 0 0 30 CollisionEntry::into_node_path 0</span>

<span class="s0">772 1 t 0 6 581 381 380 0 0 0 0 0 0 17 CollisionEntry::t 0</span>

<span class="s0">773 22 respect_prev_transform 0 2 574 384 0 0 0 0 0 0 0 38 CollisionEntry::respect_prev_transform 0</span>

<span class="s0">774 6 normal 0 2 578 407 0 0 0 0 0 0 0 22 CollisionPlane::normal 0</span>

<span class="s0">775 5 plane 0 6 605 410 409 0 0 0 0 0 0 21 CollisionPlane::plane 0</span>

<span class="s0">776 8 vertices 0 66 577 418 0 0 0 0 417 0 0 28 CollisionFloorMesh::vertices 0</span>

<span class="s0">777 9 triangles 0 66 609 420 0 0 0 0 419 0 0 29 CollisionFloorMesh::triangles 0</span>

<span class="s0">778 6 points 0 66 572 425 0 0 0 0 424 0 0 24 CollisionPolygon::points 0</span>

<span class="s0">779 5 valid 0 2 574 427 0 0 0 0 0 0 0 23 CollisionPolygon::valid 0</span>

<span class="s0">780 7 concave 0 2 574 428 0 0 0 0 0 0 0 25 CollisionPolygon::concave 0</span>

<span class="s0">781 11 in_patterns 0 66 612 436 0 0 0 0 435 0 0 34 CollisionHandlerEvent::in_patterns 0</span>

<span class="s0">782 14 again_patterns 0 66 612 441 0 0 0 0 440 0 0 37 CollisionHandlerEvent::again_patterns 0</span>

<span class="s0">783 12 out_patterns 0 66 612 446 0 0 0 0 445 0 0 35 CollisionHandlerEvent::out_patterns 0</span>

<span class="s0">784 6 center 0 30 615 461 459 462 460 0 0 0 0 32 CollisionHandlerPhysical::center 0</span>

<span class="s0">785 6 offset 0 6 581 469 468 0 0 0 0 0 0 29 CollisionHandlerFloor::offset 0</span>

<span class="s0">786 5 reach 0 6 581 471 470 0 0 0 0 0 0 28 CollisionHandlerFloor::reach 0</span>

<span class="s0">787 12 max_velocity 0 6 581 473 472 0 0 0 0 0 0 35 CollisionHandlerFloor::max_velocity 0</span>

<span class="s0">788 10 horizontal 0 6 574 479 478 0 0 0 0 0 0 34 CollisionHandlerPusher::horizontal 0</span>

<span class="s0">789 6 offset 0 6 581 488 487 0 0 0 0 0 0 31 CollisionHandlerGravity::offset 0</span>

<span class="s0">790 5 reach 0 6 581 490 489 0 0 0 0 0 0 30 CollisionHandlerGravity::reach 0</span>

<span class="s0">791 15 airborne_height 0 2 581 491 0 0 0 0 0 0 0 40 CollisionHandlerGravity::airborne_height 0</span>

<span class="s0">792 9 on_ground 0 2 574 492 0 0 0 0 0 0 0 34 CollisionHandlerGravity::on_ground 0</span>

<span class="s0">793 15 impact_velocity 0 2 581 493 0 0 0 0 0 0 0 40 CollisionHandlerGravity::impact_velocity 0</span>

<span class="s0">794 14 contact_normal 0 2 620 494 0 0 0 0 0 0 0 39 CollisionHandlerGravity::contact_normal 0</span>

<span class="s0">795 8 velocity 0 6 581 497 496 0 0 0 0 0 0 33 CollisionHandlerGravity::velocity 0</span>

<span class="s0">796 7 gravity 0 6 581 499 498 0 0 0 0 0 0 32 CollisionHandlerGravity::gravity 0</span>

<span class="s0">797 12 max_velocity 0 6 581 501 500 0 0 0 0 0 0 37 CollisionHandlerGravity::max_velocity 0</span>

<span class="s0">798 7 entries 0 66 623 514 0 0 0 0 513 0 0 30 CollisionHandlerQueue::entries 0</span>

<span class="s0">799 6 center 0 6 577 522 521 0 0 0 0 0 0 23 CollisionSphere::center 0</span>

<span class="s0">800 6 radius 0 6 581 524 523 0 0 0 0 0 0 23 CollisionSphere::radius 0</span>

<span class="s0">801 6 origin 0 6 577 532 531 0 0 0 0 0 0 20 CollisionRay::origin 0</span>

<span class="s0">802 9 direction 0 6 620 534 533 0 0 0 0 0 0 23 CollisionRay::direction 0</span>

<span class="s0">803 8 parabola 0 6 629 543 542 0 0 0 0 0 0 27 CollisionParabola::parabola 0</span>

<span class="s0">804 2 t1 0 6 581 545 544 0 0 0 0 0 0 21 CollisionParabola::t1 0</span>

<span class="s0">805 2 t2 0 6 581 547 546 0 0 0 0 0 0 21 CollisionParabola::t2 0</span>

<span class="s0">806 7 point_a 0 6 577 552 551 0 0 0 0 0 0 25 CollisionSegment::point_a 0</span>

<span class="s0">807 7 point_b 0 6 577 554 553 0 0 0 0 0 0 25 CollisionSegment::point_b 0</span>

<span class="s0">808 11 point_scale 0 6 581 565 564 0 0 0 0 0 0 32 CollisionVisualizer::point_scale 0</span>

<span class="s0">809 12 normal_scale 0 6 581 567 566 0 0 0 0 0 0 33 CollisionVisualizer::normal_scale 0</span>

<span class="s0">9</span>
<span class="s0">810 10 get_solids 0 337 338 25 CollisionNode::get_solids 0</span>

<span class="s0">811 13 get_colliders 0 355 356 33 CollisionTraverser::get_colliders 0</span>

<span class="s0">812 12 get_vertices 0 417 418 32 CollisionFloorMesh::get_vertices 0</span>

<span class="s0">813 13 get_triangles 0 419 420 33 CollisionFloorMesh::get_triangles 0</span>

<span class="s0">814 10 get_points 0 424 425 28 CollisionPolygon::get_points 0</span>

<span class="s0">815 15 get_in_patterns 0 435 436 38 CollisionHandlerEvent::get_in_patterns 0</span>

<span class="s0">816 18 get_again_patterns 0 440 441 41 CollisionHandlerEvent::get_again_patterns 0</span>

<span class="s0">817 16 get_out_patterns 0 445 446 39 CollisionHandlerEvent::get_out_patterns 0</span>

<span class="s0">818 11 get_entries 0 513 514 34 CollisionHandlerQueue::get_entries 0</span>

</pre>
</body>
</html>