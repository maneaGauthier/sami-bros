<html>
<head>
<title>libp3device.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3device.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">11 libp3device 4 k0F5 12 panda3d.core </span>
<span class="s0">135</span>
<span class="s0">102 8 get_time 0 4 237 21 TrackerData::get_time 0 0 180</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time at which the position information (pos and orient) are</span>
 <span class="s0">* effective.  It is an error to call this if has_time() does not return true.</span>
 <span class="s0">* See set_time().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline double TrackerData::get_time(void) const;</span>

<span class="s0">103 8 set_time 0 4 237 21 TrackerData::set_time 0 0 251</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the time at which the position information (pos and orient) are</span>
 <span class="s0">* effective.  This is a time elapsed in seconds since some undefined epoch;</span>
 <span class="s0">* it may or may not correspond to the clock time indicated in the global</span>
 <span class="s0">* ClockObject.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void TrackerData::set_time(double time);</span>

<span class="s0">104 7 get_pos 0 4 237 20 TrackerData::get_pos 0 0 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current position of the tracker.  It is legal to call this if</span>
 <span class="s0">* has_pos() returns false; in this case, the position will always be (0, 0,</span>
 <span class="s0">* 0).</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LPoint3 const &amp;TrackerData::get_pos(void) const;</span>

<span class="s0">105 7 set_pos 0 4 237 20 TrackerData::set_pos 0 0 143</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the current position of the tracker sensor in space.  The</span>
 <span class="s0">* coordinate system of this position is defined by the tracker.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void TrackerData::set_pos(LPoint3 const &amp;pos);</span>

<span class="s0">106 10 get_orient 0 4 237 23 TrackerData::get_orient 0 0 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current orientation of the tracker.  It is legal to call this</span>
 <span class="s0">* if has_orient() returns false; in this case, the result is always the</span>
 <span class="s0">* identity orientation.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LOrientation const &amp;TrackerData::get_orient(void) const;</span>

<span class="s0">107 10 set_orient 0 4 237 23 TrackerData::set_orient 0 0 225</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the current orientation of the tracker sensor in space.  The</span>
 <span class="s0">* coordinate system of this orientation is defined by the tracker, but should</span>
 <span class="s0">* be the same coordinate system as that reflected by set_pos().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void TrackerData::set_orient(LOrientation const &amp;orient);</span>

<span class="s0">108 6 get_dt 0 4 237 19 TrackerData::get_dt 0 0 188</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of elapsed time over which the information (pos and</span>
 <span class="s0">* orient) were computed.  It is an error to call this if has_dt() does not</span>
 <span class="s0">* return true.  See set_dt().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline double TrackerData::get_dt(void) const;</span>

<span class="s0">109 6 set_dt 0 4 237 19 TrackerData::set_dt 0 0 259</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the amount of elapsed time over which which the information (pos</span>
 <span class="s0">* and orient) were computed.  This only makes sense if the information</span>
 <span class="s0">* represents velocity or acceleration, rather than position.  This is an</span>
 <span class="s0">* elapsed time in seconds.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void TrackerData::set_dt(double dt);</span>

<span class="s0">110 12 ~TrackerData 0 516 237 25 TrackerData::~TrackerData 0 0 0</span>
<span class="s0">32</span>
<span class="s0">TrackerData::~TrackerData(void);</span>

<span class="s0">111 22 operator typecast bool 0 132 251 48 InputDevice::ButtonState::operator typecast bool 0 1 21 0</span>
<span class="s0">21</span>
<span class="s0">operator bool (void);</span>

<span class="s0">112 8 is_known 0 4 251 34 InputDevice::ButtonState::is_known 0 0 55</span>
<span class="s0">/**</span>
 <span class="s0">* True if the button state is currently known.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool InputDevice::ButtonState::is_known(void) const;</span>

<span class="s0">113 10 is_pressed 0 4 251 36 InputDevice::ButtonState::is_pressed 0 0 63</span>
<span class="s0">/**</span>
 <span class="s0">* True if the button is currently known to be pressed.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool InputDevice::ButtonState::is_pressed(void) const;</span>

<span class="s0">114 10 get_handle 0 20 251 36 InputDevice::ButtonState::get_handle 0 0 57</span>
<span class="s0">getter for ButtonHandle InputDevice::ButtonState::handle;</span>
<span class="s0">62</span>
<span class="s0">ButtonHandle InputDevice::ButtonState::get_handle(void) const;</span>

<span class="s0">115 11 ButtonState 0 260 251 37 InputDevice::ButtonState::ButtonState 0 1 20 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline InputDevice::ButtonState::ButtonState(InputDevice::ButtonState const &amp;) = default;</span>

<span class="s0">116 12 ~ButtonState 0 516 251 38 InputDevice::ButtonState::~ButtonState 0 0 0</span>
<span class="s0">45</span>
<span class="s0">InputDevice::ButtonState::~ButtonState(void);</span>

<span class="s0">117 22 operator typecast bool 0 132 254 46 InputDevice::AxisState::operator typecast bool 0 1 23 0</span>
<span class="s0">21</span>
<span class="s0">operator bool (void);</span>

<span class="s0">118 8 get_axis 0 20 254 32 InputDevice::AxisState::get_axis 0 0 58</span>
<span class="s0">getter for InputDevice::Axis InputDevice::AxisState::axis;</span>
<span class="s0">63</span>
<span class="s0">InputDevice::Axis InputDevice::AxisState::get_axis(void) const;</span>

<span class="s0">119 8 set_axis 0 36 254 32 InputDevice::AxisState::set_axis 0 0 58</span>
<span class="s0">setter for InputDevice::Axis InputDevice::AxisState::axis;</span>
<span class="s0">63</span>
<span class="s0">void InputDevice::AxisState::set_axis(InputDevice::Axis value);</span>

<span class="s0">120 9 get_value 0 20 254 33 InputDevice::AxisState::get_value 0 0 48</span>
<span class="s0">getter for double InputDevice::AxisState::value;</span>
<span class="s0">53</span>
<span class="s0">double InputDevice::AxisState::get_value(void) const;</span>

<span class="s0">121 9 set_value 0 36 254 33 InputDevice::AxisState::set_value 0 0 48</span>
<span class="s0">setter for double InputDevice::AxisState::value;</span>
<span class="s0">53</span>
<span class="s0">void InputDevice::AxisState::set_value(double value);</span>

<span class="s0">122 9 get_known 0 20 254 33 InputDevice::AxisState::get_known 0 0 46</span>
<span class="s0">getter for bool InputDevice::AxisState::known;</span>
<span class="s0">51</span>
<span class="s0">bool InputDevice::AxisState::get_known(void) const;</span>

<span class="s0">123 9 set_known 0 36 254 33 InputDevice::AxisState::set_known 0 0 46</span>
<span class="s0">setter for bool InputDevice::AxisState::known;</span>
<span class="s0">51</span>
<span class="s0">void InputDevice::AxisState::set_known(bool value);</span>

<span class="s0">124 9 AxisState 0 260 254 33 InputDevice::AxisState::AxisState 0 1 22 0</span>
<span class="s0">83</span>
<span class="s0">inline InputDevice::AxisState::AxisState(InputDevice::AxisState const &amp;) = default;</span>

<span class="s0">125 10 ~AxisState 0 516 254 34 InputDevice::AxisState::~AxisState 0 0 0</span>
<span class="s0">41</span>
<span class="s0">InputDevice::AxisState::~AxisState(void);</span>

<span class="s0">126 9 get_level 0 20 255 35 InputDevice::BatteryData::get_level 0 0 53</span>
<span class="s0">getter for short int InputDevice::BatteryData::level;</span>
<span class="s0">58</span>
<span class="s0">short int InputDevice::BatteryData::get_level(void) const;</span>

<span class="s0">127 9 set_level 0 36 255 35 InputDevice::BatteryData::set_level 0 0 53</span>
<span class="s0">setter for short int InputDevice::BatteryData::level;</span>
<span class="s0">58</span>
<span class="s0">void InputDevice::BatteryData::set_level(short int value);</span>

<span class="s0">128 13 get_max_level 0 20 255 39 InputDevice::BatteryData::get_max_level 0 0 57</span>
<span class="s0">getter for short int InputDevice::BatteryData::max_level;</span>
<span class="s0">62</span>
<span class="s0">short int InputDevice::BatteryData::get_max_level(void) const;</span>

<span class="s0">129 13 set_max_level 0 36 255 39 InputDevice::BatteryData::set_max_level 0 0 57</span>
<span class="s0">setter for short int InputDevice::BatteryData::max_level;</span>
<span class="s0">62</span>
<span class="s0">void InputDevice::BatteryData::set_max_level(short int value);</span>

<span class="s0">130 11 BatteryData 0 260 255 37 InputDevice::BatteryData::BatteryData 0 2 24 25 0</span>
<span class="s0">151</span>
<span class="s0">inline InputDevice::BatteryData::BatteryData(void) = default;</span>
<span class="s0">inline InputDevice::BatteryData::BatteryData(InputDevice::BatteryData const &amp;) = default;</span>

<span class="s0">131 12 ~BatteryData 0 516 255 38 InputDevice::BatteryData::~BatteryData 0 0 0</span>
<span class="s0">45</span>
<span class="s0">InputDevice::BatteryData::~BatteryData(void);</span>

<span class="s0">132 8 get_name 0 4 245 21 InputDevice::get_name 0 0 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a human-readable name for the device.  Not necessarily unique.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::string InputDevice::get_name(void) const;</span>

<span class="s0">133 16 get_manufacturer 0 4 245 29 InputDevice::get_manufacturer 0 0 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string containing the manufacturer of the device, if this</span>
 <span class="s0">* information is known.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::string InputDevice::get_manufacturer(void) const;</span>

<span class="s0">134 17 get_serial_number 0 4 245 30 InputDevice::get_serial_number 0 0 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string containing the serial number of the device, if this</span>
 <span class="s0">* information is known.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::string InputDevice::get_serial_number(void) const;</span>

<span class="s0">135 13 get_vendor_id 0 4 245 26 InputDevice::get_vendor_id 0 0 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string containing the USB vendor ID of the device, if this</span>
 <span class="s0">* information is known.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline unsigned short int InputDevice::get_vendor_id(void) const;</span>

<span class="s0">136 14 get_product_id 0 4 245 27 InputDevice::get_product_id 0 0 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string containing the USB product ID of the device, if this</span>
 <span class="s0">* information is known.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline unsigned short int InputDevice::get_product_id(void) const;</span>

<span class="s0">137 12 is_connected 0 4 245 25 InputDevice::is_connected 0 0 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the device is still connected and able to receive data,</span>
 <span class="s0">* false otherwise.  May return false positives.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool InputDevice::is_connected(void) const;</span>

<span class="s0">138 16 get_device_class 0 4 245 29 InputDevice::get_device_class 0 0 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an identification of the general type of device.  If this could not</span>
 <span class="s0">* be determined, returns DeviceClass.unknown.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline InputDevice::DeviceClass InputDevice::get_device_class(void) const;</span>

<span class="s0">139 11 has_feature 0 4 245 24 InputDevice::has_feature 0 1 1 102</span>
<span class="s0">// Determine supported features</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the device supports the indicated feature.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline bool InputDevice::has_feature(InputDevice::Feature feature) const;</span>

<span class="s0">140 11 get_tracker 0 4 245 24 InputDevice::get_tracker 0 0 140</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the TrackerData associated with the input device's tracker.  This</span>
 <span class="s0">* only makes sense if has_tracker() also returns true.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline TrackerData InputDevice::get_tracker(void) const;</span>

<span class="s0">141 11 has_tracker 0 4 245 24 InputDevice::has_tracker 0 1 16 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the device features a tracker that can track position and/or</span>
 <span class="s0">* orientation in 3D space.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool InputDevice::has_tracker(void) const;</span>

<span class="s0">142 11 get_battery 0 4 245 24 InputDevice::get_battery 0 0 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a rough indication of the battery level, ranging from 0 (completely</span>
 <span class="s0">* empty battery) to the indicated max_level value.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline InputDevice::BatteryData InputDevice::get_battery(void) const;</span>

<span class="s0">143 11 has_battery 0 4 245 24 InputDevice::has_battery 0 1 17 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the device may be able to provide information about its</span>
 <span class="s0">* battery life.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool InputDevice::has_battery(void) const;</span>

<span class="s0">144 15 get_num_buttons 0 4 245 28 InputDevice::get_num_buttons 0 1 18 279</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of buttons known to the device.  This includes those</span>
 <span class="s0">* buttons whose state has been seen, as well as buttons that have been</span>
 <span class="s0">* associated with a ButtonHandle even if their state is unknown.  This number</span>
 <span class="s0">* may change as more buttons are discovered.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline std::size_t InputDevice::get_num_buttons(void) const;</span>

<span class="s0">145 10 get_button 0 4 245 23 InputDevice::get_button 0 0 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonState that is set at the given index, or throw an assert</span>
 <span class="s0">* if the index was not found in the list.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline InputDevice::ButtonState InputDevice::get_button(std::size_t index) const;</span>

<span class="s0">146 12 get_num_axes 0 4 245 25 InputDevice::get_num_axes 0 1 19 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of analog axes known to the InputDevice.  This number</span>
 <span class="s0">* may change as more axes are discovered.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline std::size_t InputDevice::get_num_axes(void) const;</span>

<span class="s0">147 8 get_axis 0 4 245 21 InputDevice::get_axis 0 0 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the axis state that is set at the given index, or throw an assert</span>
 <span class="s0">* if the index was not found in the list.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline InputDevice::AxisState InputDevice::get_axis(std::size_t index) const;</span>

<span class="s0">148 10 map_button 0 4 245 23 InputDevice::map_button 0 1 2 540</span>
<span class="s0">// Associate buttons/axes with symbolic handles.</span>

<span class="s0">/**</span>
 <span class="s0">* Associates the indicated ButtonHandle with the button of the indicated index</span>
 <span class="s0">* number.  When the given button index changes state, a corresponding</span>
 <span class="s0">* ButtonEvent will be generated with the given ButtonHandle.  Pass</span>
 <span class="s0">* ButtonHandle::none() to turn off any association.</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call this if you simply want to query the state of</span>
 <span class="s0">* the various buttons by index number; this is only necessary in order to</span>
 <span class="s0">* generate ButtonEvents when the buttons change state.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void InputDevice::map_button(std::size_t index, ButtonHandle handle);</span>

<span class="s0">149 8 map_axis 0 4 245 21 InputDevice::map_axis 0 1 3 251</span>
<span class="s0">/**</span>
 <span class="s0">* Associates the indicated Axis with the axis of the indicated index</span>
 <span class="s0">* number.  Pass Axis::none to turn off any association.</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call this if you simply want to query the state of</span>
 <span class="s0">* the various axes by index number.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void InputDevice::map_axis(std::size_t index, InputDevice::Axis axis);</span>

<span class="s0">150 11 find_button 0 4 245 24 InputDevice::find_button 0 1 4 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first ButtonState found with the given axis, or throw an assert</span>
 <span class="s0">* if the button handle was not found in the list.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline InputDevice::ButtonState InputDevice::find_button(ButtonHandle handle) const;</span>

<span class="s0">151 9 find_axis 0 4 245 22 InputDevice::find_axis 0 1 5 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first AnalogAxis found with the given axis, or throw an assert</span>
 <span class="s0">* if the axis was not found in the list.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline InputDevice::AxisState InputDevice::find_axis(InputDevice::Axis axis) const;</span>

<span class="s0">152 13 set_vibration 0 4 245 26 InputDevice::set_vibration 0 1 6 267</span>
<span class="s0">// Enable rumble force-feedback effects</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the strength of the vibration effect, if supported.  The values are</span>
 <span class="s0">* clamped to 0-1 range. The first value axes the low-frequency rumble</span>
 <span class="s0">* motor, whereas the second axes the high-frequency motor, if present.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void InputDevice::set_vibration(double strong, double weak);</span>

<span class="s0">153 21 enable_pointer_events 0 4 245 34 InputDevice::enable_pointer_events 0 1 7 59</span>
<span class="s0">/**</span>
 <span class="s0">* Enables the generation of mouse-movement events.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void InputDevice::enable_pointer_events(void);</span>

<span class="s0">154 22 disable_pointer_events 0 4 245 35 InputDevice::disable_pointer_events 0 1 8 60</span>
<span class="s0">/**</span>
 <span class="s0">* Disables the generation of mouse-movement events.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void InputDevice::disable_pointer_events(void);</span>

<span class="s0">155 4 poll 0 4 245 17 InputDevice::poll 0 1 9 233</span>
<span class="s0">/**</span>
 <span class="s0">* Polls the input device for new activity, to ensure it contains the latest</span>
 <span class="s0">* events.  This will only have any effect for some types of input devices;</span>
 <span class="s0">* others may be updated automatically, and this method will be a no-op.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">void InputDevice::poll(void);</span>

<span class="s0">156 16 has_button_event 0 4 245 29 InputDevice::has_button_event 0 1 10 218</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this device has a pending button event (a mouse button or</span>
 <span class="s0">* keyboard button down/up), false otherwise.  If this returns true, the</span>
 <span class="s0">* particular event may be extracted via get_button_event().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">bool InputDevice::has_button_event(void) const;</span>

<span class="s0">157 17 get_button_events 0 4 245 30 InputDevice::get_button_events 0 1 11 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the list of recently-generated ButtonEvents.</span>
 <span class="s0">* The list is also cleared.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">PointerTo&lt; ButtonEventList &gt; InputDevice::get_button_events(void);</span>

<span class="s0">158 17 has_pointer_event 0 4 245 30 InputDevice::has_pointer_event 0 1 12 198</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this device has a pending pointer event (a mouse movement),</span>
 <span class="s0">* or false otherwise.  If this returns true, the particular event may be</span>
 <span class="s0">* extracted via get_pointer_event().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool InputDevice::has_pointer_event(void) const;</span>

<span class="s0">159 18 get_pointer_events 0 4 245 31 InputDevice::get_pointer_events 0 1 13 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a PointerEventList containing all the recent pointer events.</span>
 <span class="s0">* Clears the list.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">PointerTo&lt; PointerEventList &gt; InputDevice::get_pointer_events(void);</span>

<span class="s0">160 6 output 0 6 245 19 InputDevice::output 0 1 14 58</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a one-line string describing the device.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual void InputDevice::output(std::ostream &amp;out) const;</span>

<span class="s0">161 11 get_buttons 0 20 245 24 InputDevice::get_buttons 0 0 54</span>
<span class="s0">getter for InputDevice::Buttons InputDevice::_buttons;</span>
<span class="s0">58</span>
<span class="s0">InputDevice::Buttons InputDevice::get_buttons(void) const;</span>

<span class="s0">162 8 get_axes 0 20 245 21 InputDevice::get_axes 0 0 48</span>
<span class="s0">getter for InputDevice::Axes InputDevice::_axes;</span>
<span class="s0">52</span>
<span class="s0">InputDevice::Axes InputDevice::get_axes(void) const;</span>

<span class="s0">163 16 get_pointer_data 0 20 245 29 InputDevice::get_pointer_data 0 0 50</span>
<span class="s0">getter for PointerData InputDevice::_pointer_data;</span>
<span class="s0">61</span>
<span class="s0">PointerData const &amp;InputDevice::get_pointer_data(void) const;</span>

<span class="s0">164 16 get_battery_data 0 20 245 29 InputDevice::get_battery_data 0 0 63</span>
<span class="s0">getter for InputDevice::BatteryData InputDevice::_battery_data;</span>
<span class="s0">67</span>
<span class="s0">InputDevice::BatteryData InputDevice::get_battery_data(void) const;</span>

<span class="s0">165 16 get_tracker_data 0 20 245 29 InputDevice::get_tracker_data 0 0 50</span>
<span class="s0">getter for TrackerData InputDevice::_tracker_data;</span>
<span class="s0">61</span>
<span class="s0">TrackerData const &amp;InputDevice::get_tracker_data(void) const;</span>

<span class="s0">166 14 get_class_type 0 4 245 27 InputDevice::get_class_type 0 1 15 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle InputDevice::get_class_type(void);</span>

<span class="s0">167 24 fork_asynchronous_thread 0 4 265 36 ClientBase::fork_asynchronous_thread 0 1 26 314</span>
<span class="s0">/**</span>
 <span class="s0">* Forks a separate thread to do all the polling of connected devices.  The</span>
 <span class="s0">* forked thread will poll after every poll_time seconds has elapsed.  Returns</span>
 <span class="s0">* true if the fork was successful, or false otherwise (for instance, because</span>
 <span class="s0">* we were already forked, or because asynchronous threads are disabled).</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool ClientBase::fork_asynchronous_thread(double poll_time);</span>

<span class="s0">168 9 is_forked 0 4 265 21 ClientBase::is_forked 0 1 27 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ClientBase has been forked (and, therefore, poll() does</span>
 <span class="s0">* not need to be called), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool ClientBase::is_forked(void) const;</span>

<span class="s0">169 4 poll 0 4 265 16 ClientBase::poll 0 1 28 183</span>
<span class="s0">/**</span>
 <span class="s0">* Initiates a poll of the client devices, if we are not forked and if we have</span>
 <span class="s0">* not already polled this frame.  Returns true if the poll occurred, or false</span>
 <span class="s0">* if it did not.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">inline bool ClientBase::poll(void);</span>

<span class="s0">170 18 get_last_poll_time 0 4 265 30 ClientBase::get_last_poll_time 0 1 29 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time (according to the global ClockObject's get_real_time()</span>
 <span class="s0">* method) of the last device poll.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline double ClientBase::get_last_poll_time(void) const;</span>

<span class="s0">171 21 set_coordinate_system 0 4 265 33 ClientBase::set_coordinate_system 0 1 30 138</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the coordinate system that all devices associated with this</span>
 <span class="s0">* client will operate in.  Normally, this is CS_default.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void ClientBase::set_coordinate_system(CoordinateSystem cs);</span>

<span class="s0">172 21 get_coordinate_system 0 4 265 33 ClientBase::get_coordinate_system 0 1 31 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the coordinate system that all devices associated with this client</span>
 <span class="s0">* will operate in.  Normally, this is CS_default.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline CoordinateSystem ClientBase::get_coordinate_system(void) const;</span>

<span class="s0">173 14 get_class_type 0 4 265 26 ClientBase::get_class_type 0 1 32 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle ClientBase::get_class_type(void);</span>

<span class="s0">174 10 AnalogNode 0 260 266 22 AnalogNode::AnalogNode 0 3 33 34 35 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">199</span>
<span class="s0">explicit AnalogNode::AnalogNode(ClientBase *client, std::string const &amp;device_name);</span>
<span class="s0">explicit AnalogNode::AnalogNode(InputDevice *device);</span>
<span class="s0">inline AnalogNode::AnalogNode(AnalogNode const &amp;) = default;</span>

<span class="s0">175 8 is_valid 0 4 266 20 AnalogNode::is_valid 0 1 36 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the AnalogNode is valid and connected to a server, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool AnalogNode::is_valid(void) const;</span>

<span class="s0">176 16 get_num_controls 0 4 266 28 AnalogNode::get_num_controls 0 1 37 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of analog controls known to the AnalogNode.  This number</span>
 <span class="s0">* may change as more controls are discovered.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int AnalogNode::get_num_controls(void) const;</span>

<span class="s0">177 17 get_control_state 0 4 266 29 AnalogNode::get_control_state 0 1 38 193</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current position of indicated analog control identified by its</span>
 <span class="s0">* index number, or 0.0 if the control is unknown.  The normal range of a</span>
 <span class="s0">* single control is -1.0 to 1.0.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline double AnalogNode::get_control_state(int index) const;</span>

<span class="s0">178 16 is_control_known 0 4 266 28 AnalogNode::is_control_known 0 1 39 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the state of the indicated analog control is known, or</span>
 <span class="s0">* false if we have never heard anything about this particular control.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool AnalogNode::is_control_known(int index) const;</span>

<span class="s0">179 10 set_output 0 4 266 22 AnalogNode::set_output 0 1 40 314</span>
<span class="s0">/**</span>
 <span class="s0">* Causes a particular analog control to be placed in the data graph for the</span>
 <span class="s0">* indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y</span>
 <span class="s0">* information, respectively; channels 0, 1, and 2 are available.  If flip is</span>
 <span class="s0">* true, the analog control value will be reversed before outputting it.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void AnalogNode::set_output(int channel, int index, bool flip);</span>

<span class="s0">180 12 clear_output 0 4 266 24 AnalogNode::clear_output 0 1 41 107</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the output to the data graph associated with the indicated channel.</span>
 <span class="s0">* See set_output().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void AnalogNode::clear_output(int channel);</span>

<span class="s0">181 10 get_output 0 4 266 22 AnalogNode::get_output 0 1 42 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the analog control index that is output to the data graph on the</span>
 <span class="s0">* indicated channel, or -1 if no control is output on that channel.  See</span>
 <span class="s0">* set_output().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int AnalogNode::get_output(int channel) const;</span>

<span class="s0">182 17 is_output_flipped 0 4 266 29 AnalogNode::is_output_flipped 0 1 43 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the analog control index that is output to the data graph</span>
 <span class="s0">* on the indicated channel is flipped.  See set_output().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool AnalogNode::is_output_flipped(int channel) const;</span>

<span class="s0">183 14 get_class_type 0 4 266 26 AnalogNode::get_class_type 0 1 44 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle AnalogNode::get_class_type(void);</span>

<span class="s0">184 10 ButtonNode 0 260 268 22 ButtonNode::ButtonNode 0 3 45 46 47 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">199</span>
<span class="s0">explicit ButtonNode::ButtonNode(ClientBase *client, std::string const &amp;device_name);</span>
<span class="s0">explicit ButtonNode::ButtonNode(InputDevice *device);</span>
<span class="s0">inline ButtonNode::ButtonNode(ButtonNode const &amp;) = default;</span>

<span class="s0">185 8 is_valid 0 4 268 20 ButtonNode::is_valid 0 1 48 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ButtonNode is valid and connected to a server, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool ButtonNode::is_valid(void) const;</span>

<span class="s0">186 15 get_num_buttons 0 4 268 27 ButtonNode::get_num_buttons 0 1 49 283</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of buttons known to the ButtonNode.  This includes those</span>
 <span class="s0">* buttons whose state has been seen, as well as buttons that have been</span>
 <span class="s0">* associated with a ButtonHandle even if their state is unknown.  This number</span>
 <span class="s0">* may change as more buttons are discovered.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int ButtonNode::get_num_buttons(void) const;</span>

<span class="s0">187 14 set_button_map 0 4 268 26 ButtonNode::set_button_map 0 1 50 490</span>
<span class="s0">/**</span>
 <span class="s0">* Associates the indicated ButtonHandle with the button of the indicated</span>
 <span class="s0">* index number.  When the given button index changes state, a corresponding</span>
 <span class="s0">* ButtonEvent will be generated with the given ButtonHandle.  Pass</span>
 <span class="s0">* ButtonHandle::none() to turn off any association.</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call this if you simply want to query the state of</span>
 <span class="s0">* the various buttons by index number; this is only necessary in order to</span>
 <span class="s0">* generate ButtonEvents when the buttons change state.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void ButtonNode::set_button_map(int index, ButtonHandle button);</span>

<span class="s0">188 14 get_button_map 0 4 268 26 ButtonNode::get_button_map 0 1 51 184</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle that was previously associated with the given</span>
 <span class="s0">* index number by a call to set_button_map(), or ButtonHandle::none() if no</span>
 <span class="s0">* button was associated.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline ButtonHandle ButtonNode::get_button_map(int index) const;</span>

<span class="s0">189 16 get_button_state 0 4 268 28 ButtonNode::get_button_state 0 1 52 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated button (identified by its index number) is</span>
 <span class="s0">* currently known to be down, or false if it is up or unknown.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool ButtonNode::get_button_state(int index) const;</span>

<span class="s0">190 15 is_button_known 0 4 268 27 ButtonNode::is_button_known 0 1 53 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the state of the indicated button is known, or false if we</span>
 <span class="s0">* have never heard anything about this particular button.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool ButtonNode::is_button_known(int index) const;</span>

<span class="s0">191 14 get_class_type 0 4 268 26 ButtonNode::get_class_type 0 1 54 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle ButtonNode::get_class_type(void);</span>

<span class="s0">192 8 DialNode 0 260 269 18 DialNode::DialNode 0 2 55 56 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">explicit DialNode::DialNode(ClientBase *client, std::string const &amp;device_name);</span>
<span class="s0">inline DialNode::DialNode(DialNode const &amp;) = default;</span>

<span class="s0">193 8 is_valid 0 4 269 18 DialNode::is_valid 0 1 57 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the DialNode is valid and connected to a server, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool DialNode::is_valid(void) const;</span>

<span class="s0">194 13 get_num_dials 0 4 269 23 DialNode::get_num_dials 0 1 58 123</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of dial dials known to the DialNode.  This number may</span>
 <span class="s0">* change as more dials are discovered.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int DialNode::get_num_dials(void) const;</span>

<span class="s0">195 9 read_dial 0 4 269 19 DialNode::read_dial 0 1 59 216</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of complete revolutions of the dial since the last time</span>
 <span class="s0">* read_dial() was called.  This is a destructive operation; it is not</span>
 <span class="s0">* possible to read the dial without resetting the counter.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline double DialNode::read_dial(int index);</span>

<span class="s0">196 13 is_dial_known 0 4 269 23 DialNode::is_dial_known 0 1 60 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the state of the indicated dial dial is known, or false if</span>
 <span class="s0">* we have never heard anything about this particular dial.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool DialNode::is_dial_known(int index) const;</span>

<span class="s0">197 14 get_class_type 0 4 269 24 DialNode::get_class_type 0 1 61 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle DialNode::get_class_type(void);</span>

<span class="s0">198 14 InputDeviceSet 0 260 270 30 InputDeviceSet::InputDeviceSet 0 2 62 63 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">InputDeviceSet::InputDeviceSet(void);</span>
<span class="s0">InputDeviceSet::InputDeviceSet(InputDeviceSet const &amp;copy);</span>

<span class="s0">199 10 operator = 0 4 270 26 InputDeviceSet::operator = 0 1 64 0</span>
<span class="s0">60</span>
<span class="s0">void InputDeviceSet::operator =(InputDeviceSet const &amp;copy);</span>

<span class="s0">200 15 ~InputDeviceSet 0 516 270 31 InputDeviceSet::~InputDeviceSet 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline InputDeviceSet::~InputDeviceSet(void);</span>

<span class="s0">201 5 clear 0 4 270 21 InputDeviceSet::clear 0 1 65 56</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all InputDevices from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void InputDeviceSet::clear(void);</span>

<span class="s0">202 7 reserve 0 4 270 23 InputDeviceSet::reserve 0 1 66 160</span>
<span class="s0">/**</span>
 <span class="s0">* This is a hint to Panda to allocate enough memory to hold the given number</span>
 <span class="s0">* of InputDevices, if you know ahead of time how many you will be adding.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void InputDeviceSet::reserve(std::size_t num);</span>

<span class="s0">203 11 operator [] 0 4 270 27 InputDeviceSet::operator [] 0 1 67 57</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth InputDevice in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline InputDevice *InputDeviceSet::operator [](std::size_t index) const;</span>

<span class="s0">204 4 size 0 4 270 20 InputDeviceSet::size 0 1 68 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of devices in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::size_t InputDeviceSet::size(void) const;</span>

<span class="s0">205 6 output 0 4 270 22 InputDeviceSet::output 0 1 69 103</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief one-line description of the InputDeviceSet to the indicated</span>
 <span class="s0">* output stream.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void InputDeviceSet::output(std::ostream &amp;out) const;</span>

<span class="s0">206 5 write 0 4 270 21 InputDeviceSet::write 0 1 70 108</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a complete multi-line description of the InputDeviceSet to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void InputDeviceSet::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">207 11 get_devices 0 4 271 31 InputDeviceManager::get_devices 0 2 71 72 156</span>
<span class="s0">/**</span>
 <span class="s0">* Description: Returns all currently connected devices.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Description: Returns all currently connected devices of the given device class.</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">InputDeviceSet InputDeviceManager::get_devices(void) const;</span>
<span class="s0">InputDeviceSet InputDeviceManager::get_devices(InputDevice::DeviceClass device_class) const;</span>

<span class="s0">208 10 add_device 0 4 271 30 InputDeviceManager::add_device 0 1 73 166</span>
<span class="s0">/**</span>
 <span class="s0">* Called when a new device has been discovered.  This may also be used to</span>
 <span class="s0">* register virtual devices.</span>
 <span class="s0">*</span>
 <span class="s0">* This causes a connect-device event to be thrown.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void InputDeviceManager::add_device(InputDevice *device);</span>

<span class="s0">209 13 remove_device 0 4 271 33 InputDeviceManager::remove_device 0 1 74 166</span>
<span class="s0">/**</span>
 <span class="s0">* Called when a device has been removed, or when a device should otherwise no</span>
 <span class="s0">* longer be tracked.</span>
 <span class="s0">*</span>
 <span class="s0">* This causes a disconnect-device event to be thrown.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void InputDeviceManager::remove_device(InputDevice *device);</span>

<span class="s0">210 6 update 0 6 271 26 InputDeviceManager::update 0 1 75 109</span>
<span class="s0">/**</span>
 <span class="s0">* Polls the system to see if there are any new devices.  In some</span>
 <span class="s0">* implementations this is a no-op.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">virtual void InputDeviceManager::update(void);</span>

<span class="s0">211 14 get_global_ptr 0 4 271 34 InputDeviceManager::get_global_ptr 0 1 76 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the singleton InputDeviceManager instance.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static inline InputDeviceManager *InputDeviceManager::get_global_ptr(void);</span>

<span class="s0">212 15 InputDeviceNode 0 260 272 32 InputDeviceNode::InputDeviceNode 0 2 77 78 0</span>
<span class="s0">155</span>
<span class="s0">InputDeviceNode::InputDeviceNode(InputDevice *device, std::string const &amp;name);</span>
<span class="s0">inline InputDeviceNode::InputDeviceNode(InputDeviceNode const &amp;) = default;</span>

<span class="s0">213 10 get_device 0 4 272 27 InputDeviceNode::get_device 0 0 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the associated device.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">PointerTo&lt; InputDevice &gt; InputDeviceNode::get_device(void) const;</span>

<span class="s0">214 10 set_device 0 4 272 27 InputDeviceNode::set_device 0 0 71</span>
<span class="s0">/**</span>
 <span class="s0">* Redirects the class to get the data from a different device.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void InputDeviceNode::set_device(InputDevice *device);</span>

<span class="s0">215 14 get_class_type 0 4 272 31 InputDeviceNode::get_class_type 0 1 79 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle InputDeviceNode::get_class_type(void);</span>

<span class="s0">216 16 ~InputDeviceNode 0 516 272 33 InputDeviceNode::~InputDeviceNode 0 0 0</span>
<span class="s0">40</span>
<span class="s0">InputDeviceNode::~InputDeviceNode(void);</span>

<span class="s0">217 11 TrackerNode 0 260 274 24 TrackerNode::TrackerNode 0 3 80 81 82 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">206</span>
<span class="s0">explicit TrackerNode::TrackerNode(ClientBase *client, std::string const &amp;device_name);</span>
<span class="s0">explicit TrackerNode::TrackerNode(InputDevice *device);</span>
<span class="s0">inline TrackerNode::TrackerNode(TrackerNode const &amp;) = default;</span>

<span class="s0">218 8 is_valid 0 4 274 21 TrackerNode::is_valid 0 1 83 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the TrackerNode is valid and connected to a server, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool TrackerNode::is_valid(void) const;</span>

<span class="s0">219 7 get_pos 0 4 274 20 TrackerNode::get_pos 0 1 84 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current position of the tracker, if it is available.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LPoint3 const &amp;TrackerNode::get_pos(void) const;</span>

<span class="s0">220 10 get_orient 0 4 274 23 TrackerNode::get_orient 0 1 85 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current orientation of the tracker, if it is available.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LOrientation const &amp;TrackerNode::get_orient(void) const;</span>

<span class="s0">221 13 get_transform 0 4 274 26 TrackerNode::get_transform 0 1 86 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current position and orientation of the tracker, as a combined</span>
 <span class="s0">* matrix.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LMatrix4 const &amp;TrackerNode::get_transform(void) const;</span>

<span class="s0">222 8 get_time 0 4 274 21 TrackerNode::get_time 0 1 87 57</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time of the tracker's last update.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline double TrackerNode::get_time(void) const;</span>

<span class="s0">223 8 has_time 0 4 274 21 TrackerNode::has_time 0 1 88 51</span>
<span class="s0">/**</span>
 <span class="s0">* True if this data comes with timestamps.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool TrackerNode::has_time(void) const;</span>

<span class="s0">224 29 set_tracker_coordinate_system 0 4 274 42 TrackerNode::set_tracker_coordinate_system 0 1 89 257</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the coordinate system that the tracker associated with this node</span>
 <span class="s0">* will operate in.  Normally, this is set from the ClientBase that's used to</span>
 <span class="s0">* create the TrackerNode, so it should not need to be set on an individual</span>
 <span class="s0">* tracker basis.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs);</span>

<span class="s0">225 29 get_tracker_coordinate_system 0 4 274 42 TrackerNode::get_tracker_coordinate_system 0 1 90 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the coordinate system that the tracker associated with this node</span>
 <span class="s0">* will operate in.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const;</span>

<span class="s0">226 27 set_graph_coordinate_system 0 4 274 40 TrackerNode::set_graph_coordinate_system 0 1 91 165</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the coordinate system that the TrackerNode will convert its</span>
 <span class="s0">* transform into for passing down the data graph.  Normally, this is</span>
 <span class="s0">* CS_default.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs);</span>

<span class="s0">227 27 get_graph_coordinate_system 0 4 274 40 TrackerNode::get_graph_coordinate_system 0 1 92 163</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the coordinate system that the TrackerNode will convert its</span>
 <span class="s0">* transform into for passing down the data graph.  Normally, this is</span>
 <span class="s0">* CS_default.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const;</span>

<span class="s0">228 14 get_class_type 0 4 274 27 TrackerNode::get_class_type 0 1 93 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle TrackerNode::get_class_type(void);</span>

<span class="s0">229 12 VirtualMouse 0 260 275 26 VirtualMouse::VirtualMouse 0 2 94 95 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">explicit VirtualMouse::VirtualMouse(std::string const &amp;name);</span>
<span class="s0">inline VirtualMouse::VirtualMouse(VirtualMouse const &amp;) = default;</span>

<span class="s0">230 13 set_mouse_pos 0 4 275 27 VirtualMouse::set_mouse_pos 0 1 96 155</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the current mouse pixel location, where (0,0) is the upper left, and</span>
 <span class="s0">* (width-1, height-1) is the lower right pixel of the virtual window.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void VirtualMouse::set_mouse_pos(int x, int y);</span>

<span class="s0">231 15 set_window_size 0 4 275 29 VirtualMouse::set_window_size 0 1 97 136</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the size of the &quot;window&quot; in which the mouse rolls.  This changes the</span>
 <span class="s0">* meaning of the values passed to set_mouse_pos().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void VirtualMouse::set_window_size(int width, int height);</span>

<span class="s0">232 12 set_mouse_on 0 4 275 26 VirtualMouse::set_mouse_on 0 1 98 217</span>
<span class="s0">/**</span>
 <span class="s0">* Sets whether the mouse should appear to be within the window or not.  If</span>
 <span class="s0">* this is true, the mouse is within the window; if false, the mouse is not</span>
 <span class="s0">* within the window (and set_mouse_pos() means nothing).</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void VirtualMouse::set_mouse_on(bool flag);</span>

<span class="s0">233 12 press_button 0 4 275 26 VirtualMouse::press_button 0 1 99 167</span>
<span class="s0">/**</span>
 <span class="s0">* Simulates a mouse or keyboard button being depressed.  This should be</span>
 <span class="s0">* followed up by a call to release_button() sometime later (possibly</span>
 <span class="s0">* immediately).</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void VirtualMouse::press_button(ButtonHandle button);</span>

<span class="s0">234 14 release_button 0 4 275 28 VirtualMouse::release_button 0 1 100 105</span>
<span class="s0">/**</span>
 <span class="s0">* Simulates the button being released.  This should follow a previous call to</span>
 <span class="s0">* press_button().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void VirtualMouse::release_button(ButtonHandle button);</span>

<span class="s0">235 14 get_class_type 0 4 275 28 VirtualMouse::get_class_type 0 1 101 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle VirtualMouse::get_class_type(void);</span>

<span class="s0">236 13 ~VirtualMouse 0 516 275 27 VirtualMouse::~VirtualMouse 0 0 0</span>
<span class="s0">34</span>
<span class="s0">VirtualMouse::~VirtualMouse(void);</span>

<span class="s0">101</span>
<span class="s0">1 0 0 6 80 252 0 0 69 /**</span>
 <span class="s0">* Returns true if the device supports the indicated feature.</span>
 <span class="s0">*/ 2 4 this 3 276  7 feature 1 248  </span>
<span class="s0">2 0 0 4 93 282 0 0 490 /**</span>
 <span class="s0">* Associates the indicated ButtonHandle with the button of the indicated index</span>
 <span class="s0">* number.  When the given button index changes state, a corresponding</span>
 <span class="s0">* ButtonEvent will be generated with the given ButtonHandle.  Pass</span>
 <span class="s0">* ButtonHandle::none() to turn off any association.</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call this if you simply want to query the state of</span>
 <span class="s0">* the various buttons by index number; this is only necessary in order to</span>
 <span class="s0">* generate ButtonEvents when the buttons change state.</span>
 <span class="s0">*/ 3 4 this 3 278  5 index 1 279  6 handle 1 281  </span>
<span class="s0">3 0 0 4 94 282 0 0 251 /**</span>
 <span class="s0">* Associates the indicated Axis with the axis of the indicated index</span>
 <span class="s0">* number.  Pass Axis::none to turn off any association.</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call this if you simply want to query the state of</span>
 <span class="s0">* the various axes by index number.</span>
 <span class="s0">*/ 3 4 this 3 278  5 index 1 279  4 axis 1 249  </span>
<span class="s0">4 0 0 7 95 283 116 0 137 /**</span>
 <span class="s0">* Returns the first ButtonState found with the given axis, or throw an assert</span>
 <span class="s0">* if the button handle was not found in the list.</span>
 <span class="s0">*/ 2 4 this 3 276  6 handle 1 281  </span>
<span class="s0">5 0 0 7 96 284 125 0 127 /**</span>
 <span class="s0">* Returns the first AnalogAxis found with the given axis, or throw an assert</span>
 <span class="s0">* if the axis was not found in the list.</span>
 <span class="s0">*/ 2 4 this 3 276  4 axis 1 249  </span>
<span class="s0">6 0 0 4 97 282 0 0 226 /**</span>
 <span class="s0">* Sets the strength of the vibration effect, if supported.  The values are</span>
 <span class="s0">* clamped to 0-1 range. The first value axes the low-frequency rumble</span>
 <span class="s0">* motor, whereas the second axes the high-frequency motor, if present.</span>
 <span class="s0">*/ 3 4 this 3 278  6 strong 1 238  4 weak 1 238  </span>
<span class="s0">7 0 0 4 98 282 0 0 59 /**</span>
 <span class="s0">* Enables the generation of mouse-movement events.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">8 0 0 4 99 282 0 0 60 /**</span>
 <span class="s0">* Disables the generation of mouse-movement events.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">9 0 0 4 100 282 0 0 233 /**</span>
 <span class="s0">* Polls the input device for new activity, to ensure it contains the latest</span>
 <span class="s0">* events.  This will only have any effect for some types of input devices;</span>
 <span class="s0">* others may be updated automatically, and this method will be a no-op.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">10 0 0 6 101 252 0 0 218 /**</span>
 <span class="s0">* Returns true if this device has a pending button event (a mouse button or</span>
 <span class="s0">* keyboard button down/up), false otherwise.  If this returns true, the</span>
 <span class="s0">* particular event may be extracted via get_button_event().</span>
 <span class="s0">*/ 1 4 this 3 276  </span>
<span class="s0">11 0 0 7 102 286 0 0 92 /**</span>
 <span class="s0">* Returns the list of recently-generated ButtonEvents.</span>
 <span class="s0">* The list is also cleared.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">12 0 0 6 103 252 0 0 198 /**</span>
 <span class="s0">* Returns true if this device has a pending pointer event (a mouse movement),</span>
 <span class="s0">* or false otherwise.  If this returns true, the particular event may be</span>
 <span class="s0">* extracted via get_pointer_event().</span>
 <span class="s0">*/ 1 4 this 3 276  </span>
<span class="s0">13 0 0 7 104 288 0 0 99 /**</span>
 <span class="s0">* Returns a PointerEventList containing all the recent pointer events.</span>
 <span class="s0">* Clears the list.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">14 0 0 4 105 282 0 0 58 /**</span>
 <span class="s0">* Writes a one-line string describing the device.</span>
 <span class="s0">*/ 2 4 this 3 276  3 out 1 289  </span>
<span class="s0">15 0 0 7 121 292 0 0 0 0 </span>
<span class="s0">16 0 0 6 83 252 0 0 115 /**</span>
 <span class="s0">* Returns true if the device features a tracker that can track position and/or</span>
 <span class="s0">* orientation in 3D space.</span>
 <span class="s0">*/ 1 4 this 3 276  </span>
<span class="s0">17 0 0 6 86 252 0 0 99 /**</span>
 <span class="s0">* Returns true if the device may be able to provide information about its</span>
 <span class="s0">* battery life.</span>
 <span class="s0">*/ 1 4 this 3 276  </span>
<span class="s0">18 0 0 6 87 279 0 0 279 /**</span>
 <span class="s0">* Returns the number of buttons known to the device.  This includes those</span>
 <span class="s0">* buttons whose state has been seen, as well as buttons that have been</span>
 <span class="s0">* associated with a ButtonHandle even if their state is unknown.  This number</span>
 <span class="s0">* may change as more buttons are discovered.</span>
 <span class="s0">*/ 1 4 this 3 276  </span>
<span class="s0">19 0 0 6 90 279 0 0 126 /**</span>
 <span class="s0">* Returns the number of analog axes known to the InputDevice.  This number</span>
 <span class="s0">* may change as more axes are discovered.</span>
 <span class="s0">*/ 1 4 this 3 276  </span>
<span class="s0">20 0 0 15 38 283 116 0 0 1 6 param0 0 293  </span>
<span class="s0">21 0 0 6 29 252 0 0 0 1 4 this 3 283  </span>
<span class="s0">22 0 0 15 51 284 125 0 0 1 6 param0 0 295  </span>
<span class="s0">23 0 0 6 41 252 0 0 0 1 4 this 3 284  </span>
<span class="s0">24 0 0 7 61 297 131 0 0 0 </span>
<span class="s0">25 0 0 15 61 297 131 0 0 1 6 param0 0 298  </span>
<span class="s0">26 0 0 6 123 252 0 0 314 /**</span>
 <span class="s0">* Forks a separate thread to do all the polling of connected devices.  The</span>
 <span class="s0">* forked thread will poll after every poll_time seconds has elapsed.  Returns</span>
 <span class="s0">* true if the fork was successful, or false otherwise (for instance, because</span>
 <span class="s0">* we were already forked, or because asynchronous threads are disabled).</span>
 <span class="s0">*/ 2 4 this 3 300  9 poll_time 1 238  </span>
<span class="s0">27 0 0 6 124 252 0 0 130 /**</span>
 <span class="s0">* Returns true if the ClientBase has been forked (and, therefore, poll() does</span>
 <span class="s0">* not need to be called), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 301  </span>
<span class="s0">28 0 0 6 125 252 0 0 183 /**</span>
 <span class="s0">* Initiates a poll of the client devices, if we are not forked and if we have</span>
 <span class="s0">* not already polled this frame.  Returns true if the poll occurred, or false</span>
 <span class="s0">* if it did not.</span>
 <span class="s0">*/ 1 4 this 3 300  </span>
<span class="s0">29 0 0 6 126 238 0 0 118 /**</span>
 <span class="s0">* Returns the time (according to the global ClockObject's get_real_time()</span>
 <span class="s0">* method) of the last device poll.</span>
 <span class="s0">*/ 1 4 this 3 301  </span>
<span class="s0">30 0 0 4 127 282 0 0 138 /**</span>
 <span class="s0">* Specifies the coordinate system that all devices associated with this</span>
 <span class="s0">* client will operate in.  Normally, this is CS_default.</span>
 <span class="s0">*/ 2 4 this 3 300  2 cs 1 303  </span>
<span class="s0">31 0 0 6 128 303 0 0 136 /**</span>
 <span class="s0">* Returns the coordinate system that all devices associated with this client</span>
 <span class="s0">* will operate in.  Normally, this is CS_default.</span>
 <span class="s0">*/ 1 4 this 3 301  </span>
<span class="s0">32 0 0 7 129 292 0 0 0 0 </span>
<span class="s0">33 0 0 15 132 306 0 0 0 1 6 param0 0 304  </span>
<span class="s0">34 0 0 7 132 306 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 client 1 300  11 device_name 1 307  </span>
<span class="s0">35 0 0 7 132 306 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 6 device 1 278  </span>
<span class="s0">36 0 0 6 133 252 0 0 97 /**</span>
 <span class="s0">* Returns true if the AnalogNode is valid and connected to a server, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 304  </span>
<span class="s0">37 0 0 6 134 308 0 0 133 /**</span>
 <span class="s0">* Returns the number of analog controls known to the AnalogNode.  This number</span>
 <span class="s0">* may change as more controls are discovered.</span>
 <span class="s0">*/ 1 4 this 3 304  </span>
<span class="s0">38 0 0 6 135 238 0 0 193 /**</span>
 <span class="s0">* Returns the current position of indicated analog control identified by its</span>
 <span class="s0">* index number, or 0.0 if the control is unknown.  The normal range of a</span>
 <span class="s0">* single control is -1.0 to 1.0.</span>
 <span class="s0">*/ 2 4 this 3 304  5 index 1 308  </span>
<span class="s0">39 0 0 6 136 252 0 0 153 /**</span>
 <span class="s0">* Returns true if the state of the indicated analog control is known, or</span>
 <span class="s0">* false if we have never heard anything about this particular control.</span>
 <span class="s0">*/ 2 4 this 3 304  5 index 1 308  </span>
<span class="s0">40 0 0 4 137 282 0 0 314 /**</span>
 <span class="s0">* Causes a particular analog control to be placed in the data graph for the</span>
 <span class="s0">* indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y</span>
 <span class="s0">* information, respectively; channels 0, 1, and 2 are available.  If flip is</span>
 <span class="s0">* true, the analog control value will be reversed before outputting it.</span>
 <span class="s0">*/ 4 4 this 3 306  7 channel 1 308  5 index 1 308  4 flip 1 252  </span>
<span class="s0">41 0 0 4 138 282 0 0 107 /**</span>
 <span class="s0">* Removes the output to the data graph associated with the indicated channel.</span>
 <span class="s0">* See set_output().</span>
 <span class="s0">*/ 2 4 this 3 306  7 channel 1 308  </span>
<span class="s0">42 0 0 6 139 308 0 0 174 /**</span>
 <span class="s0">* Returns the analog control index that is output to the data graph on the</span>
 <span class="s0">* indicated channel, or -1 if no control is output on that channel.  See</span>
 <span class="s0">* set_output().</span>
 <span class="s0">*/ 2 4 this 3 304  7 channel 1 308  </span>
<span class="s0">43 0 0 6 140 252 0 0 143 /**</span>
 <span class="s0">* Returns true if the analog control index that is output to the data graph</span>
 <span class="s0">* on the indicated channel is flipped.  See set_output().</span>
 <span class="s0">*/ 2 4 this 3 304  7 channel 1 308  </span>
<span class="s0">44 0 0 7 141 292 0 0 0 0 </span>
<span class="s0">45 0 0 15 143 311 0 0 0 1 6 param0 0 309  </span>
<span class="s0">46 0 0 7 143 311 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 client 1 300  11 device_name 1 307  </span>
<span class="s0">47 0 0 7 143 311 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 6 device 1 278  </span>
<span class="s0">48 0 0 6 144 252 0 0 97 /**</span>
 <span class="s0">* Returns true if the ButtonNode is valid and connected to a server, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 309  </span>
<span class="s0">49 0 0 6 145 308 0 0 283 /**</span>
 <span class="s0">* Returns the number of buttons known to the ButtonNode.  This includes those</span>
 <span class="s0">* buttons whose state has been seen, as well as buttons that have been</span>
 <span class="s0">* associated with a ButtonHandle even if their state is unknown.  This number</span>
 <span class="s0">* may change as more buttons are discovered.</span>
 <span class="s0">*/ 1 4 this 3 309  </span>
<span class="s0">50 0 0 4 146 282 0 0 490 /**</span>
 <span class="s0">* Associates the indicated ButtonHandle with the button of the indicated</span>
 <span class="s0">* index number.  When the given button index changes state, a corresponding</span>
 <span class="s0">* ButtonEvent will be generated with the given ButtonHandle.  Pass</span>
 <span class="s0">* ButtonHandle::none() to turn off any association.</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call this if you simply want to query the state of</span>
 <span class="s0">* the various buttons by index number; this is only necessary in order to</span>
 <span class="s0">* generate ButtonEvents when the buttons change state.</span>
 <span class="s0">*/ 3 4 this 3 311  5 index 1 308  6 button 1 281  </span>
<span class="s0">51 0 0 7 147 281 0 0 184 /**</span>
 <span class="s0">* Returns the ButtonHandle that was previously associated with the given</span>
 <span class="s0">* index number by a call to set_button_map(), or ButtonHandle::none() if no</span>
 <span class="s0">* button was associated.</span>
 <span class="s0">*/ 2 4 this 3 309  5 index 1 308  </span>
<span class="s0">52 0 0 6 148 252 0 0 147 /**</span>
 <span class="s0">* Returns true if the indicated button (identified by its index number) is</span>
 <span class="s0">* currently known to be down, or false if it is up or unknown.</span>
 <span class="s0">*/ 2 4 this 3 309  5 index 1 308  </span>
<span class="s0">53 0 0 6 149 252 0 0 144 /**</span>
 <span class="s0">* Returns true if the state of the indicated button is known, or false if we</span>
 <span class="s0">* have never heard anything about this particular button.</span>
 <span class="s0">*/ 2 4 this 3 309  5 index 1 308  </span>
<span class="s0">54 0 0 7 150 292 0 0 0 0 </span>
<span class="s0">55 0 0 7 152 312 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 client 1 300  11 device_name 1 307  </span>
<span class="s0">56 0 0 15 152 312 0 0 0 1 6 param0 0 313  </span>
<span class="s0">57 0 0 6 153 252 0 0 95 /**</span>
 <span class="s0">* Returns true if the DialNode is valid and connected to a server, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 313  </span>
<span class="s0">58 0 0 6 154 308 0 0 123 /**</span>
 <span class="s0">* Returns the number of dial dials known to the DialNode.  This number may</span>
 <span class="s0">* change as more dials are discovered.</span>
 <span class="s0">*/ 1 4 this 3 313  </span>
<span class="s0">59 0 0 6 155 238 0 0 216 /**</span>
 <span class="s0">* Returns the number of complete revolutions of the dial since the last time</span>
 <span class="s0">* read_dial() was called.  This is a destructive operation; it is not</span>
 <span class="s0">* possible to read the dial without resetting the counter.</span>
 <span class="s0">*/ 2 4 this 3 312  5 index 1 308  </span>
<span class="s0">60 0 0 6 156 252 0 0 145 /**</span>
 <span class="s0">* Returns true if the state of the indicated dial dial is known, or false if</span>
 <span class="s0">* we have never heard anything about this particular dial.</span>
 <span class="s0">*/ 2 4 this 3 313  5 index 1 308  </span>
<span class="s0">61 0 0 7 157 292 0 0 0 0 </span>
<span class="s0">62 0 0 7 159 315 200 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">63 0 0 15 159 315 200 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 316  </span>
<span class="s0">64 0 0 6 160 315 0 0 0 2 4 this 3 315  4 copy 1 316  </span>
<span class="s0">65 0 0 4 162 282 0 0 56 /**</span>
 <span class="s0">* Removes all InputDevices from the collection.</span>
 <span class="s0">*/ 1 4 this 3 315  </span>
<span class="s0">66 0 0 4 163 282 0 0 160 /**</span>
 <span class="s0">* This is a hint to Panda to allocate enough memory to hold the given number</span>
 <span class="s0">* of InputDevices, if you know ahead of time how many you will be adding.</span>
 <span class="s0">*/ 2 4 this 3 315  3 num 1 279  </span>
<span class="s0">67 0 0 7 164 278 0 0 57 /**</span>
 <span class="s0">* Returns the nth InputDevice in the collection.</span>
 <span class="s0">*/ 2 4 this 3 316  5 index 1 279  </span>
<span class="s0">68 0 0 6 165 279 0 0 59 /**</span>
 <span class="s0">* Returns the number of devices in the collection.</span>
 <span class="s0">*/ 1 4 this 3 316  </span>
<span class="s0">69 0 0 4 166 282 0 0 103 /**</span>
 <span class="s0">* Writes a brief one-line description of the InputDeviceSet to the indicated</span>
 <span class="s0">* output stream.</span>
 <span class="s0">*/ 2 4 this 3 316  3 out 1 289  </span>
<span class="s0">70 0 0 4 167 282 0 0 108 /**</span>
 <span class="s0">* Writes a complete multi-line description of the InputDeviceSet to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 3 4 this 3 316  3 out 1 289  12 indent_level 5 308  </span>
<span class="s0">71 0 0 7 169 315 200 0 64 /**</span>
 <span class="s0">* Description: Returns all currently connected devices.</span>
 <span class="s0">*/ 1 4 this 3 318  </span>
<span class="s0">72 0 0 7 169 315 200 0 90 /**</span>
 <span class="s0">* Description: Returns all currently connected devices of the given device class.</span>
 <span class="s0">*/ 2 4 this 3 318  12 device_class 1 247  </span>
<span class="s0">73 0 0 4 170 282 0 0 166 /**</span>
 <span class="s0">* Called when a new device has been discovered.  This may also be used to</span>
 <span class="s0">* register virtual devices.</span>
 <span class="s0">*</span>
 <span class="s0">* This causes a connect-device event to be thrown.</span>
 <span class="s0">*/ 2 4 this 3 320  6 device 1 278  </span>
<span class="s0">74 0 0 4 171 282 0 0 166 /**</span>
 <span class="s0">* Called when a device has been removed, or when a device should otherwise no</span>
 <span class="s0">* longer be tracked.</span>
 <span class="s0">*</span>
 <span class="s0">* This causes a disconnect-device event to be thrown.</span>
 <span class="s0">*/ 2 4 this 3 320  6 device 1 278  </span>
<span class="s0">75 0 0 4 172 282 0 0 109 /**</span>
 <span class="s0">* Polls the system to see if there are any new devices.  In some</span>
 <span class="s0">* implementations this is a no-op.</span>
 <span class="s0">*/ 1 4 this 3 320  </span>
<span class="s0">76 0 0 6 173 320 0 0 61 /**</span>
 <span class="s0">* Returns the singleton InputDeviceManager instance.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">77 0 0 23 175 321 216 0 0 2 6 device 1 278  4 name 1 307  </span>
<span class="s0">78 0 0 15 175 321 216 0 0 1 6 param0 0 322  </span>
<span class="s0">79 0 0 7 180 292 0 0 0 0 </span>
<span class="s0">80 0 0 7 183 324 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 client 1 300  11 device_name 1 307  </span>
<span class="s0">81 0 0 7 183 324 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 6 device 1 278  </span>
<span class="s0">82 0 0 15 183 324 0 0 0 1 6 param0 0 325  </span>
<span class="s0">83 0 0 6 184 252 0 0 98 /**</span>
 <span class="s0">* Returns true if the TrackerNode is valid and connected to a server, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 325  </span>
<span class="s0">84 0 0 6 185 327 0 0 75 /**</span>
 <span class="s0">* Returns the current position of the tracker, if it is available.</span>
 <span class="s0">*/ 1 4 this 3 325  </span>
<span class="s0">85 0 0 6 186 328 0 0 78 /**</span>
 <span class="s0">* Returns the current orientation of the tracker, if it is available.</span>
 <span class="s0">*/ 1 4 this 3 325  </span>
<span class="s0">86 0 0 6 187 329 0 0 96 /**</span>
 <span class="s0">* Returns the current position and orientation of the tracker, as a combined</span>
 <span class="s0">* matrix.</span>
 <span class="s0">*/ 1 4 this 3 325  </span>
<span class="s0">87 0 0 6 188 238 0 0 57 /**</span>
 <span class="s0">* Returns the time of the tracker's last update.</span>
 <span class="s0">*/ 1 4 this 3 325  </span>
<span class="s0">88 0 0 6 189 252 0 0 51 /**</span>
 <span class="s0">* True if this data comes with timestamps.</span>
 <span class="s0">*/ 1 4 this 3 325  </span>
<span class="s0">89 0 0 4 190 282 0 0 257 /**</span>
 <span class="s0">* Specifies the coordinate system that the tracker associated with this node</span>
 <span class="s0">* will operate in.  Normally, this is set from the ClientBase that's used to</span>
 <span class="s0">* create the TrackerNode, so it should not need to be set on an individual</span>
 <span class="s0">* tracker basis.</span>
 <span class="s0">*/ 2 4 this 3 324  2 cs 1 303  </span>
<span class="s0">90 0 0 6 191 303 0 0 103 /**</span>
 <span class="s0">* Returns the coordinate system that the tracker associated with this node</span>
 <span class="s0">* will operate in.</span>
 <span class="s0">*/ 1 4 this 3 325  </span>
<span class="s0">91 0 0 4 192 282 0 0 165 /**</span>
 <span class="s0">* Specifies the coordinate system that the TrackerNode will convert its</span>
 <span class="s0">* transform into for passing down the data graph.  Normally, this is</span>
 <span class="s0">* CS_default.</span>
 <span class="s0">*/ 2 4 this 3 324  2 cs 1 303  </span>
<span class="s0">92 0 0 6 193 303 0 0 163 /**</span>
 <span class="s0">* Returns the coordinate system that the TrackerNode will convert its</span>
 <span class="s0">* transform into for passing down the data graph.  Normally, this is</span>
 <span class="s0">* CS_default.</span>
 <span class="s0">*/ 1 4 this 3 325  </span>
<span class="s0">93 0 0 7 194 292 0 0 0 0 </span>
<span class="s0">94 0 0 15 196 335 236 0 0 1 6 param0 0 333  </span>
<span class="s0">95 0 0 7 196 335 236 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 307  </span>
<span class="s0">96 0 0 4 197 282 0 0 155 /**</span>
 <span class="s0">* Sets the current mouse pixel location, where (0,0) is the upper left, and</span>
 <span class="s0">* (width-1, height-1) is the lower right pixel of the virtual window.</span>
 <span class="s0">*/ 3 4 this 3 335  1 x 1 308  1 y 1 308  </span>
<span class="s0">97 0 0 4 198 282 0 0 136 /**</span>
 <span class="s0">* Sets the size of the &quot;window&quot; in which the mouse rolls.  This changes the</span>
 <span class="s0">* meaning of the values passed to set_mouse_pos().</span>
 <span class="s0">*/ 3 4 this 3 335  5 width 1 308  6 height 1 308  </span>
<span class="s0">98 0 0 4 199 282 0 0 217 /**</span>
 <span class="s0">* Sets whether the mouse should appear to be within the window or not.  If</span>
 <span class="s0">* this is true, the mouse is within the window; if false, the mouse is not</span>
 <span class="s0">* within the window (and set_mouse_pos() means nothing).</span>
 <span class="s0">*/ 2 4 this 3 335  4 flag 1 252  </span>
<span class="s0">99 0 0 4 200 282 0 0 167 /**</span>
 <span class="s0">* Simulates a mouse or keyboard button being depressed.  This should be</span>
 <span class="s0">* followed up by a call to release_button() sometime later (possibly</span>
 <span class="s0">* immediately).</span>
 <span class="s0">*/ 2 4 this 3 335  6 button 1 281  </span>
<span class="s0">100 0 0 4 201 282 0 0 105 /**</span>
 <span class="s0">* Simulates the button being released.  This should follow a previous call to</span>
 <span class="s0">* press_button().</span>
 <span class="s0">*/ 2 4 this 3 335  6 button 1 281  </span>
<span class="s0">101 0 0 7 202 292 0 0 0 0 </span>
<span class="s0">99</span>
<span class="s0">237 11 TrackerData 0 141313 11 TrackerData 11 TrackerData 0 0 0 0 110 4 336 337 338 339 0 0 0 0 0 0 64</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the kinds of data that a tracker might output.</span>
 <span class="s0">*/</span>

<span class="s0">238 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">239 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 240 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">240 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 241 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">241 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">242 18 LOrientation const 0 8832 18 LOrientation const 18 LOrientation const 0 0 243 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">243 12 LOrientation 0 2105344 12 LOrientation 12 LOrientation 0 0 244 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">244 13 LOrientationf 0 2048 13 LOrientationf 13 LOrientationf 0 0 0 0 0 0 0 0 0 0 0 0 65</span>
<span class="s0">/**</span>
 <span class="s0">* This is a unit quaternion representing an orientation.</span>
 <span class="s0">*/</span>

<span class="s0">245 11 InputDevice 0 75777 11 InputDevice 11 InputDevice 0 0 0 0 0 16 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 15 139 148 149 150 151 152 153 154 155 156 157 158 159 160 166 0 0 1 0 246 0 0 0 9 247 248 249 250 251 254 255 260 262 959</span>
<span class="s0">/**</span>
 <span class="s0">* This is a structure representing a single input device.  Input devices may</span>
 <span class="s0">* have zero or more buttons, pointers, or axes associated with them, and</span>
 <span class="s0">* optionally a motion tracker.</span>
 <span class="s0">*</span>
 <span class="s0">* These devices are brought under a common interface because there is such a</span>
 <span class="s0">* large range of devices out there that may support any number of these types</span>
 <span class="s0">* of axes, we couldn't even begin to cover them with type-specific</span>
 <span class="s0">* subclasses.</span>
 <span class="s0">*</span>
 <span class="s0">* Use the various has_() and get_num_() methods to determine information about</span>
 <span class="s0">* the device capabilities. For instance, has_keyboard() will give an</span>
 <span class="s0">* indication that you can receive keystroke events from this device, and</span>
 <span class="s0">* get_num_buttons() will tell you that the device may send button events.</span>
 <span class="s0">*</span>
 <span class="s0">* There is the DeviceType enumeration, however, which will (if known) contain</span>
 <span class="s0">* identification of the general category of devices this fits in, such as</span>
 <span class="s0">* keyboard, mouse, gamepad, or flight stick.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">246 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">247 11 DeviceClass 0 9183232 24 InputDevice::DeviceClass 24 InputDevice::DeviceClass 245 0 0 0 0 0 0 0 0 0 12 7 unknown 20 InputDevice::unknown 47</span>
<span class="s0">// It is not known what type of device this is.</span>
<span class="s0">0 14 virtual_device 27 InputDevice::virtual_device 121</span>
<span class="s0">// This means that the device doesn't correspond to a physical</span>
<span class="s0">// device, but rather to a dynamic source of input events.</span>
<span class="s0">1 8 keyboard 21 InputDevice::keyboard 37</span>
<span class="s0">// A physical, alphabetical keyboard.</span>
<span class="s0">2 5 mouse 18 InputDevice::mouse 0</span>
<span class="s0">3 5 touch 18 InputDevice::touch 0</span>
<span class="s0">4 7 gamepad 20 InputDevice::gamepad 59</span>
<span class="s0">// A gamepad with action buttons, a D-pad, and thumbsticks.</span>
<span class="s0">5 12 flight_stick 25 InputDevice::flight_stick 0</span>
<span class="s0">6 14 steering_wheel 27 InputDevice::steering_wheel 0</span>
<span class="s0">7 9 dance_pad 22 InputDevice::dance_pad 0</span>
<span class="s0">8 3 hmd 16 InputDevice::hmd 24</span>
<span class="s0">// Head-mounted display.</span>
<span class="s0">9 13 spatial_mouse 26 InputDevice::spatial_mouse 45</span>
<span class="s0">// 3D mouse, such as produced by 3Dconnexion.</span>
<span class="s0">10 9 digitizer 22 InputDevice::digitizer 37</span>
<span class="s0">// A graphics tablet with stylus/pen.</span>
<span class="s0">11 0 91</span>
<span class="s0">// This enum contains information that can be used to identify the</span>
<span class="s0">// type of input device.</span>

<span class="s0">248 7 Feature 0 9183232 20 InputDevice::Feature 20 InputDevice::Feature 245 0 0 0 0 0 0 0 0 0 5 7 pointer 20 InputDevice::pointer 51</span>
<span class="s0">// The device provides absolute screen coordinates.</span>
<span class="s0">0 8 keyboard 21 InputDevice::keyboard 56</span>
<span class="s0">// The device has an interface for providing text input.</span>
<span class="s0">1 7 tracker 20 InputDevice::tracker 51</span>
<span class="s0">// The device has a motion tracker, such as an HMD.</span>
<span class="s0">2 9 vibration 22 InputDevice::vibration 41</span>
<span class="s0">// The device can produce force feedback.</span>
<span class="s0">3 7 battery 20 InputDevice::battery 54</span>
<span class="s0">// The device provides information about battery life.</span>
<span class="s0">4 0 0</span>

<span class="s0">249 4 Axis 0 9183232 17 InputDevice::Axis 17 InputDevice::Axis 245 0 0 0 0 0 0 0 0 0 19 4 none 17 InputDevice::none 0</span>
<span class="s0">0 1 x 14 InputDevice::x 29</span>
<span class="s0">// Generic translational axes</span>
<span class="s0">1 1 y 14 InputDevice::y 0</span>
<span class="s0">2 1 z 14 InputDevice::z 0</span>
<span class="s0">3 3 yaw 16 InputDevice::yaw 57</span>
<span class="s0">// Generic rotational axes, used by joysticks and 3D mice</span>
<span class="s0">4 5 pitch 18 InputDevice::pitch 0</span>
<span class="s0">5 4 roll 17 InputDevice::roll 0</span>
<span class="s0">6 6 left_x 19 InputDevice::left_x 10</span>
<span class="s0">// Gamepad</span>
<span class="s0">7 6 left_y 19 InputDevice::left_y 0</span>
<span class="s0">8 12 left_trigger 25 InputDevice::left_trigger 0</span>
<span class="s0">9 7 right_x 20 InputDevice::right_x 0</span>
<span class="s0">10 7 right_y 20 InputDevice::right_y 0</span>
<span class="s0">11 13 right_trigger 26 InputDevice::right_trigger 0</span>
<span class="s0">12 8 throttle 21 InputDevice::throttle 24</span>
<span class="s0">// Flight stick specific</span>
<span class="s0">13 6 rudder 19 InputDevice::rudder 37</span>
<span class="s0">// When available separately from yaw</span>
<span class="s0">14 5 wheel 18 InputDevice::wheel 26</span>
<span class="s0">// Steering wheel / pedals</span>
<span class="s0">15 11 accelerator 24 InputDevice::accelerator 0</span>
<span class="s0">16 5 brake 18 InputDevice::brake 0</span>
<span class="s0">17 8 pressure 21 InputDevice::pressure 15</span>
<span class="s0">// Pen pressure</span>
<span class="s0">18 0 0</span>

<span class="s0">250 5 State 0 794624 18 InputDevice::State 18 InputDevice::State 245 0 0 0 0 0 0 0 0 0 3 9 S_unknown 22 InputDevice::S_unknown 0</span>
<span class="s0">0 4 S_up 17 InputDevice::S_up 0</span>
<span class="s0">1 6 S_down 19 InputDevice::S_down 0</span>
<span class="s0">2 0 0</span>

<span class="s0">251 11 ButtonState 0 403457 24 InputDevice::ButtonState 24 InputDevice::ButtonState 245 0 0 1 115 116 3 340 341 342 0 0 1 111 0 0 0 0</span>

<span class="s0">252 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">253 12 ButtonHandle 0 16779264 12 ButtonHandle 12 ButtonHandle 0 0 0 0 0 0 0 0 0 0 0 0 162</span>
<span class="s0">/**</span>
 <span class="s0">* A ButtonHandle represents a single button from any device, including</span>
 <span class="s0">* keyboard buttons and mouse buttons (but see KeyboardButton and</span>
 <span class="s0">* MouseButton).</span>
 <span class="s0">*/</span>

<span class="s0">254 9 AxisState 0 403457 22 InputDevice::AxisState 22 InputDevice::AxisState 245 0 0 1 124 125 3 343 344 345 0 0 1 117 0 0 0 0</span>

<span class="s0">255 11 BatteryData 0 403457 24 InputDevice::BatteryData 24 InputDevice::BatteryData 245 0 0 1 130 131 2 346 347 0 0 0 0 0 0 0</span>

<span class="s0">256 9 short int 0 8258 9 short int 9 short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">257 6 string 0 2105344 11 std::string 11 std::string 0 0 258 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">258 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">259 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">260 7 Buttons 0 2367488 20 InputDevice::Buttons 20 InputDevice::Buttons 245 0 261 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">261 22 pvector&lt; ButtonState &gt; 0 2048 35 pvector&lt; InputDevice::ButtonState &gt; 35 pvector&lt; InputDevice::ButtonState &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">262 4 Axes 0 2367488 17 InputDevice::Axes 17 InputDevice::Axes 245 0 263 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">263 20 pvector&lt; AxisState &gt; 0 2048 33 pvector&lt; InputDevice::AxisState &gt; 33 pvector&lt; InputDevice::AxisState &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">264 11 PointerData 0 2048 11 PointerData 11 PointerData 0 0 0 0 0 0 0 0 0 0 0 0 124</span>
<span class="s0">/**</span>
 <span class="s0">* Holds the data that might be generated by a 2-d pointer input device, such</span>
 <span class="s0">* as the mouse in the GraphicsWindow.</span>
 <span class="s0">*/</span>

<span class="s0">265 10 ClientBase 0 75777 10 ClientBase 10 ClientBase 0 0 0 0 0 0 7 167 168 169 170 171 172 173 0 0 1 0 246 0 0 0 0 307</span>
<span class="s0">/**</span>
 <span class="s0">* An abstract base class for a family of client device interfaces--including</span>
 <span class="s0">* trackers, buttons, dials, and other analog inputs.</span>
 <span class="s0">*</span>
 <span class="s0">* This provides a common interface to connect to such devices and extract</span>
 <span class="s0">* their data; it is used by TrackerNode etc.  to put these devices in the</span>
 <span class="s0">* data graph.</span>
 <span class="s0">*/</span>

<span class="s0">266 10 AnalogNode 0 75777 10 AnalogNode 10 AnalogNode 0 0 0 1 174 0 0 9 175 176 177 178 179 180 181 182 183 0 0 1 0 267 0 0 0 0 712</span>
<span class="s0">/**</span>
 <span class="s0">* This is the primary interface to analog controls like sliders and joysticks</span>
 <span class="s0">* associated with a ClientBase.  This creates a node that connects to the</span>
 <span class="s0">* named analog device, if it exists, and provides hooks to the user to read</span>
 <span class="s0">* the state of any of the sequentially numbered controls associated with that</span>
 <span class="s0">* device.</span>
 <span class="s0">*</span>
 <span class="s0">* Each control can return a value ranging from -1 to 1, reflecting the</span>
 <span class="s0">* current position of the control within its total range of motion.</span>
 <span class="s0">*</span>
 <span class="s0">* The user may choose up to two analog controls to place on the data graph as</span>
 <span class="s0">* the two channels of an xy datagram, similarly to the way a mouse places its</span>
 <span class="s0">* position data.  In this way, an AnalogNode may be used in place of a mouse.</span>
 <span class="s0">*/</span>

<span class="s0">267 8 DataNode 0 2048 8 DataNode 8 DataNode 0 0 0 0 0 0 0 0 0 0 0 0 422</span>
<span class="s0">/**</span>
 <span class="s0">* The fundamental type of node for the data graph.  The DataNode class is</span>
 <span class="s0">* itself primarily intended as an abstract class; it defines no inputs and no</span>
 <span class="s0">* outputs.  Most kinds of data nodes will derive from this to specify the</span>
 <span class="s0">* inputs and outputs in the constructor.</span>
 <span class="s0">*</span>
 <span class="s0">* DataNode does not attempt to cycle its data with a PipelineCycler.  The</span>
 <span class="s0">* data graph is intended to be used only within a single thread.</span>
 <span class="s0">*/</span>

<span class="s0">268 10 ButtonNode 0 75777 10 ButtonNode 10 ButtonNode 0 0 0 1 184 0 0 7 185 186 187 188 189 190 191 0 0 1 0 267 0 0 0 0 527</span>
<span class="s0">/**</span>
 <span class="s0">* This is the primary interface to on/off button devices associated with a</span>
 <span class="s0">* ClientBase.  This creates a node that connects to the named button device,</span>
 <span class="s0">* if it exists, and provides hooks to the user to read the state of any of</span>
 <span class="s0">* the sequentially numbered buttons associated with that device.</span>
 <span class="s0">*</span>
 <span class="s0">* It also can associate an arbitrary ButtonHandle with each button; when</span>
 <span class="s0">* buttons are associated with ButtonHandles, this node will put appropriate</span>
 <span class="s0">* up and down events on the data graph for each button state change.</span>
 <span class="s0">*/</span>

<span class="s0">269 8 DialNode 0 75777 8 DialNode 8 DialNode 0 0 0 1 192 0 0 5 193 194 195 196 197 0 0 1 0 267 0 0 0 0 511</span>
<span class="s0">/**</span>
 <span class="s0">* This is the primary interface to infinite dial type devices associated with</span>
 <span class="s0">* a ClientBase.  This creates a node that connects to the named dial device,</span>
 <span class="s0">* if it exists, and provides hooks to the user to read the state of any of</span>
 <span class="s0">* the sequentially numbered dial controls associated with that device.</span>
 <span class="s0">*</span>
 <span class="s0">* A dial is a rotating device that does not have stops--it can keep rotating</span>
 <span class="s0">* any number of times.  Therefore it does not have a specific position at any</span>
 <span class="s0">* given time, unlike an AnalogDevice.</span>
 <span class="s0">*/</span>

<span class="s0">270 14 InputDeviceSet 0 26625 14 InputDeviceSet 14 InputDeviceSet 0 0 0 1 198 200 0 7 199 201 202 203 204 205 206 0 0 0 0 0 192</span>
<span class="s0">/**</span>
 <span class="s0">* Manages a list of InputDevice objects, as returned by various</span>
 <span class="s0">* InputDeviceManager methods.  This is implemented like a set, meaning the</span>
 <span class="s0">* same device cannot occur more than once.</span>
 <span class="s0">*/</span>

<span class="s0">271 18 InputDeviceManager 0 43009 18 InputDeviceManager 18 InputDeviceManager 0 0 0 0 0 0 5 207 208 209 210 211 0 0 0 0 0 145</span>
<span class="s0">/**</span>
 <span class="s0">* This class keeps track of all the devices on a system, and sends out events</span>
 <span class="s0">* when a device has been hot-plugged.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">272 15 InputDeviceNode 0 141313 15 InputDeviceNode 15 InputDeviceNode 0 0 0 1 212 216 1 364 1 215 0 0 1 0 267 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the controller data sent from the InputDeviceManager, and transmits</span>
 <span class="s0">* it down the data graph.</span>
 <span class="s0">*</span>
 <span class="s0">* This is intended to only be accessed from the app thread.</span>
 <span class="s0">*/</span>

<span class="s0">273 24 PointerTo&lt; InputDevice &gt; 0 2048 24 PointerTo&lt; InputDevice &gt; 24 PointerTo&lt; InputDevice &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">274 11 TrackerNode 0 75777 11 TrackerNode 11 TrackerNode 0 0 0 1 217 0 0 11 218 219 220 221 222 223 224 225 226 227 228 0 0 1 0 267 0 0 0 0 244</span>
<span class="s0">/**</span>
 <span class="s0">* This class reads the position and orientation information from a tracker</span>
 <span class="s0">* device and makes it available as a transformation on the data graph.</span>
 <span class="s0">* It is also the primary interface to a Tracker object associated with a</span>
 <span class="s0">* ClientBase.</span>
 <span class="s0">*/</span>

<span class="s0">275 12 VirtualMouse 0 141313 12 VirtualMouse 12 VirtualMouse 0 0 0 1 229 236 0 6 230 231 232 233 234 235 0 0 1 0 267 0 0 0 0 291</span>
<span class="s0">/**</span>
 <span class="s0">* Poses as a MouseAndKeyboard object in the datagraph, but accepts input from</span>
 <span class="s0">* user calls, rather than reading the actual mouse and keyboard from an input</span>
 <span class="s0">* device.  The user can write high-level code to put the mouse wherever</span>
 <span class="s0">* he/she wants, and to insert keypresses on demand.</span>
 <span class="s0">*/</span>

<span class="s0">276 19 InputDevice const * 0 8576 19 InputDevice const * 19 InputDevice const * 0 0 277 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">277 17 InputDevice const 0 8832 17 InputDevice const 17 InputDevice const 0 0 245 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">278 13 InputDevice * 0 8576 13 InputDevice * 13 InputDevice * 0 0 245 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">279 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 280 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">280 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">281 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 253 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">282 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">283 13 ButtonState * 0 8576 26 InputDevice::ButtonState * 26 InputDevice::ButtonState * 0 0 251 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">284 11 AxisState * 0 8576 24 InputDevice::AxisState * 24 InputDevice::AxisState * 0 0 254 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">285 15 ButtonEventList 0 2048 15 ButtonEventList 15 ButtonEventList 0 0 0 0 0 0 0 0 0 0 0 0 225</span>
<span class="s0">/**</span>
 <span class="s0">* Records a set of button events that happened recently.  This class is</span>
 <span class="s0">* usually used only in the data graph, to transmit the recent button presses,</span>
 <span class="s0">* but it may be used anywhere a list of ButtonEvents is desired.</span>
 <span class="s0">*/</span>

<span class="s0">286 17 ButtonEventList * 0 8576 17 ButtonEventList * 17 ButtonEventList * 0 0 285 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">287 16 PointerEventList 0 2048 16 PointerEventList 16 PointerEventList 0 0 0 0 0 0 0 0 0 0 0 0 228</span>
<span class="s0">/**</span>
 <span class="s0">* Records a set of pointer events that happened recently.  This class is</span>
 <span class="s0">* usually used only in the data graph, to transmit the recent pointer</span>
 <span class="s0">* presses, but it may be used anywhere a list of PointerEvents is desired.</span>
 <span class="s0">*/</span>

<span class="s0">288 18 PointerEventList * 0 8576 18 PointerEventList * 18 PointerEventList * 0 0 287 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">289 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 290 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">290 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">291 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">292 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 291 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">293 19 ButtonState const * 0 8576 32 InputDevice::ButtonState const * 32 InputDevice::ButtonState const * 0 0 294 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">294 17 ButtonState const 0 8832 30 InputDevice::ButtonState const 30 InputDevice::ButtonState const 0 0 251 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">295 17 AxisState const * 0 8576 30 InputDevice::AxisState const * 30 InputDevice::AxisState const * 0 0 296 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">296 15 AxisState const 0 8832 28 InputDevice::AxisState const 28 InputDevice::AxisState const 0 0 254 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">297 13 BatteryData * 0 8576 26 InputDevice::BatteryData * 26 InputDevice::BatteryData * 0 0 255 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">298 19 BatteryData const * 0 8576 32 InputDevice::BatteryData const * 32 InputDevice::BatteryData const * 0 0 299 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">299 17 BatteryData const 0 8832 30 InputDevice::BatteryData const 30 InputDevice::BatteryData const 0 0 255 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">300 12 ClientBase * 0 8576 12 ClientBase * 12 ClientBase * 0 0 265 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">301 18 ClientBase const * 0 8576 18 ClientBase const * 18 ClientBase const * 0 0 302 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">302 16 ClientBase const 0 8832 16 ClientBase const 16 ClientBase const 0 0 265 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">303 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210</span>
<span class="s0">// The CS_default entry does not refer to a particular coordinate system,</span>
<span class="s0">// but rather to the value stored in default_coordinate_system, which in</span>
<span class="s0">// turn is loaded from the config variable &quot;coordinate-system&quot;.</span>
<span class="s0">0 12 CS_zup_right 12 CS_zup_right 21</span>
<span class="s0">// Z-Up, Right-handed</span>
<span class="s0">1 12 CS_yup_right 12 CS_yup_right 21</span>
<span class="s0">// Y-Up, Right-handed</span>
<span class="s0">2 11 CS_zup_left 11 CS_zup_left 20</span>
<span class="s0">// Z-Up, Left-handed</span>
<span class="s0">3 11 CS_yup_left 11 CS_yup_left 20</span>
<span class="s0">// Y-Up, Left-handed</span>
<span class="s0">4 10 CS_invalid 10 CS_invalid 156</span>
<span class="s0">// CS_invalid is not a coordinate system at all.  It can be used in user-</span>
<span class="s0">// input processing code to indicate a contradictory coordinate system</span>
<span class="s0">// request.</span>
<span class="s0">5 0 0</span>

<span class="s0">304 18 AnalogNode const * 0 8576 18 AnalogNode const * 18 AnalogNode const * 0 0 305 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">305 16 AnalogNode const 0 8832 16 AnalogNode const 16 AnalogNode const 0 0 266 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">306 12 AnalogNode * 0 8576 12 AnalogNode * 12 AnalogNode * 0 0 266 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">307 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">308 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">309 18 ButtonNode const * 0 8576 18 ButtonNode const * 18 ButtonNode const * 0 0 310 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">310 16 ButtonNode const 0 8832 16 ButtonNode const 16 ButtonNode const 0 0 268 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">311 12 ButtonNode * 0 8576 12 ButtonNode * 12 ButtonNode * 0 0 268 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">312 10 DialNode * 0 8576 10 DialNode * 10 DialNode * 0 0 269 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">313 16 DialNode const * 0 8576 16 DialNode const * 16 DialNode const * 0 0 314 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">314 14 DialNode const 0 8832 14 DialNode const 14 DialNode const 0 0 269 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">315 16 InputDeviceSet * 0 8576 16 InputDeviceSet * 16 InputDeviceSet * 0 0 270 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">316 22 InputDeviceSet const * 0 8576 22 InputDeviceSet const * 22 InputDeviceSet const * 0 0 317 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">317 20 InputDeviceSet const 0 8832 20 InputDeviceSet const 20 InputDeviceSet const 0 0 270 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">318 26 InputDeviceManager const * 0 8576 26 InputDeviceManager const * 26 InputDeviceManager const * 0 0 319 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">319 24 InputDeviceManager const 0 8832 24 InputDeviceManager const 24 InputDeviceManager const 0 0 271 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">320 20 InputDeviceManager * 0 8576 20 InputDeviceManager * 20 InputDeviceManager * 0 0 271 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">321 17 InputDeviceNode * 0 8576 17 InputDeviceNode * 17 InputDeviceNode * 0 0 272 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">322 23 InputDeviceNode const * 0 8576 23 InputDeviceNode const * 23 InputDeviceNode const * 0 0 323 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">323 21 InputDeviceNode const 0 8832 21 InputDeviceNode const 21 InputDeviceNode const 0 0 272 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">324 13 TrackerNode * 0 8576 13 TrackerNode * 13 TrackerNode * 0 0 274 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">325 19 TrackerNode const * 0 8576 19 TrackerNode const * 19 TrackerNode const * 0 0 326 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">326 17 TrackerNode const 0 8832 17 TrackerNode const 17 TrackerNode const 0 0 274 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">327 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 239 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">328 20 LOrientation const * 0 8576 20 LOrientation const * 20 LOrientation const * 0 0 242 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">329 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 330 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">330 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 331 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">331 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 332 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">332 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">333 20 VirtualMouse const * 0 8576 20 VirtualMouse const * 20 VirtualMouse const * 0 0 334 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">334 18 VirtualMouse const 0 8832 18 VirtualMouse const 18 VirtualMouse const 0 0 275 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">335 14 VirtualMouse * 0 8576 14 VirtualMouse * 14 VirtualMouse * 0 0 275 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">29</span>
<span class="s0">336 4 time 0 6 238 102 103 0 0 0 0 0 0 17 TrackerData::time 0</span>

<span class="s0">337 3 pos 0 6 239 104 105 0 0 0 0 0 0 16 TrackerData::pos 0</span>

<span class="s0">338 6 orient 0 6 242 106 107 0 0 0 0 0 0 19 TrackerData::orient 0</span>

<span class="s0">339 2 dt 0 6 238 108 109 0 0 0 0 0 0 15 TrackerData::dt 0</span>

<span class="s0">340 5 known 0 2 252 112 0 0 0 0 0 0 0 31 InputDevice::ButtonState::known 0</span>

<span class="s0">341 7 pressed 0 2 252 113 0 0 0 0 0 0 0 33 InputDevice::ButtonState::pressed 0</span>

<span class="s0">342 6 handle 0 2 253 114 0 0 0 0 0 0 0 32 InputDevice::ButtonState::handle 0</span>

<span class="s0">343 4 axis 0 6 249 118 119 0 0 0 0 0 0 28 InputDevice::AxisState::axis 0</span>

<span class="s0">344 5 value 0 6 238 120 121 0 0 0 0 0 0 29 InputDevice::AxisState::value 0</span>

<span class="s0">345 5 known 0 6 252 122 123 0 0 0 0 0 0 29 InputDevice::AxisState::known 0</span>

<span class="s0">346 5 level 0 6 256 126 127 0 0 0 0 0 0 31 InputDevice::BatteryData::level 35</span>
<span class="s0">// Ranges from 0 through max_level.</span>

<span class="s0">347 9 max_level 0 6 256 128 129 0 0 0 0 0 0 35 InputDevice::BatteryData::max_level 34</span>
<span class="s0">// Maximum value of 'level' field.</span>

<span class="s0">348 4 name 0 2 257 132 0 0 0 0 0 0 0 17 InputDevice::name 48</span>
<span class="s0">// The human-readable name of this input device.</span>

<span class="s0">349 12 manufacturer 0 2 257 133 0 0 0 0 0 0 0 25 InputDevice::manufacturer 63</span>
<span class="s0">// The device's manufacturer, or the empty string if not known.</span>

<span class="s0">350 13 serial_number 0 2 257 134 0 0 0 0 0 0 0 26 InputDevice::serial_number 64</span>
<span class="s0">// The device's serial number, or the empty string if not known.</span>

<span class="s0">351 9 vendor_id 0 2 259 135 0 0 0 0 0 0 0 22 InputDevice::vendor_id 50</span>
<span class="s0">// USB vendor ID of the device, or 0 if not known.</span>

<span class="s0">352 10 product_id 0 2 259 136 0 0 0 0 0 0 0 23 InputDevice::product_id 51</span>
<span class="s0">// USB product ID of the device, or 0 if not known.</span>

<span class="s0">353 9 connected 0 2 252 137 0 0 0 0 0 0 0 22 InputDevice::connected 139</span>
<span class="s0">// This is false if we know that the device is not currently connected.</span>
<span class="s0">// May report false positives if we can't know this with certainty.</span>

<span class="s0">354 12 device_class 0 2 247 138 0 0 0 0 0 0 0 25 InputDevice::device_class 127</span>
<span class="s0">// This contains an identification of the general type of device.  If</span>
<span class="s0">// this could not be determined, it is set to DC_unknown.</span>

<span class="s0">355 7 tracker 0 10 237 140 0 141 0 0 0 0 0 20 InputDevice::tracker 48</span>
<span class="s0">// Getters for the various types of device data.</span>

<span class="s0">356 7 battery 0 10 255 142 0 143 0 0 0 0 0 20 InputDevice::battery 0</span>

<span class="s0">357 7 buttons 0 66 251 145 0 0 0 0 144 0 0 20 InputDevice::buttons 40</span>
<span class="s0">// Make device buttons and axes iterable</span>

<span class="s0">358 4 axes 0 66 254 147 0 0 0 0 146 0 0 17 InputDevice::axes 0</span>

<span class="s0">359 8 _buttons 0 2 260 161 0 0 0 0 0 0 0 21 InputDevice::_buttons 0</span>

<span class="s0">360 5 _axes 0 2 262 162 0 0 0 0 0 0 0 18 InputDevice::_axes 0</span>

<span class="s0">361 13 _pointer_data 0 2 264 163 0 0 0 0 0 0 0 26 InputDevice::_pointer_data 0</span>

<span class="s0">362 13 _battery_data 0 2 255 164 0 0 0 0 0 0 0 26 InputDevice::_battery_data 0</span>

<span class="s0">363 13 _tracker_data 0 2 237 165 0 0 0 0 0 0 0 26 InputDevice::_tracker_data 0</span>

<span class="s0">364 6 device 0 6 273 213 214 0 0 0 0 0 0 23 InputDeviceNode::device 0</span>

<span class="s0">0</span>
</pre>
</body>
</html>