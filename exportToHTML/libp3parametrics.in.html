<html>
<head>
<title>libp3parametrics.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3parametrics.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">16 libp3parametrics 4 UKlv 12 panda3d.core </span>
<span class="s0">247</span>
<span class="s0">272 8 is_valid 0 6 519 25 ParametricCurve::is_valid 0 1 1 164</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the curve is defined.  This base class function always</span>
 <span class="s0">* returns true; derived classes might override this to sometimes return</span>
 <span class="s0">* false.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">virtual bool ParametricCurve::is_valid(void) const;</span>

<span class="s0">273 9 get_max_t 0 6 519 26 ParametricCurve::get_max_t 0 1 2 237</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the upper bound of t for the entire curve.  The curve is defined in</span>
 <span class="s0">* the range 0.0f &lt;= t &lt;= get_max_t().  This base class function always</span>
 <span class="s0">* returns 1.0f; derived classes might override this to return something else.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual PN_stdfloat ParametricCurve::get_max_t(void) const;</span>

<span class="s0">274 14 set_curve_type 0 4 519 31 ParametricCurve::set_curve_type 0 1 3 389</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating the use to which the curve is intended to be put.</span>
 <span class="s0">* This flag is optional and only serves to provide a hint to the egg reader</span>
 <span class="s0">* and writer code; it has no effect on the curve's behavior.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting the curve type also sets the num_dimensions to 3 or 1 according to</span>
 <span class="s0">* the type.</span>
 <span class="s0">*</span>
 <span class="s0">* THis flag may have one of the values PCT_XYZ, PCT_HPR, or PCT_T.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void ParametricCurve::set_curve_type(int type);</span>

<span class="s0">275 14 get_curve_type 0 4 519 31 ParametricCurve::get_curve_type 0 1 4 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag indicating the use to which the curve is intended to be</span>
 <span class="s0">* put.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int ParametricCurve::get_curve_type(void) const;</span>

<span class="s0">276 18 set_num_dimensions 0 4 519 35 ParametricCurve::set_num_dimensions 0 1 5 324</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of significant dimensions in the curve's vertices.</span>
 <span class="s0">* This should be one of 1, 2, or 3. Normally, XYZ and HPR curves have three</span>
 <span class="s0">* dimensions; time curves should always have one dimension.  This only serves</span>
 <span class="s0">* as a hint to the mopath editor, and also controls how the curve is written</span>
 <span class="s0">* out.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void ParametricCurve::set_num_dimensions(int num);</span>

<span class="s0">277 18 get_num_dimensions 0 4 519 35 ParametricCurve::get_num_dimensions 0 1 6 267</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of significant dimensions in the curve's vertices, as</span>
 <span class="s0">* set by a previous call to set_num_dimensions().  This is only a hint as to</span>
 <span class="s0">* how the curve is intended to be used; the actual number of dimensions of</span>
 <span class="s0">* any curve is always three.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">int ParametricCurve::get_num_dimensions(void) const;</span>

<span class="s0">278 11 calc_length 0 4 519 28 ParametricCurve::calc_length 0 2 7 8 188</span>
<span class="s0">/**</span>
 <span class="s0">* Approximates the length of the entire curve to within a few decimal places.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Approximates the length of the curve segment from parametric time 'from' to</span>
 <span class="s0">* time 'to'.</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">PN_stdfloat ParametricCurve::calc_length(void) const;</span>
<span class="s0">PN_stdfloat ParametricCurve::calc_length(PN_stdfloat from, PN_stdfloat to) const;</span>

<span class="s0">279 11 find_length 0 4 519 28 ParametricCurve::find_length 0 1 9 396</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the parametric value corresponding to the indicated distance along</span>
 <span class="s0">* the curve from the starting parametric value.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the inverse of calc_length(): rather than determining the length</span>
 <span class="s0">* along the curve between two parametric points, it determines the position</span>
 <span class="s0">* in parametric time of a point n units along the curve.</span>
 <span class="s0">*</span>
 <span class="s0">* The search distance must not be negative.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">PN_stdfloat ParametricCurve::find_length(PN_stdfloat start_t, PN_stdfloat length_offset) const;</span>

<span class="s0">280 9 get_point 0 6 519 26 ParametricCurve::get_point 0 1 10 0</span>
<span class="s0">83</span>
<span class="s0">virtual bool ParametricCurve::get_point(PN_stdfloat t, LVecBase3 &amp;point) const = 0;</span>

<span class="s0">281 11 get_tangent 0 6 519 28 ParametricCurve::get_tangent 0 1 11 0</span>
<span class="s0">87</span>
<span class="s0">virtual bool ParametricCurve::get_tangent(PN_stdfloat t, LVecBase3 &amp;tangent) const = 0;</span>

<span class="s0">282 6 get_pt 0 6 519 23 ParametricCurve::get_pt 0 1 12 0</span>
<span class="s0">100</span>
<span class="s0">virtual bool ParametricCurve::get_pt(PN_stdfloat t, LVecBase3 &amp;point, LVecBase3 &amp;tangent) const = 0;</span>

<span class="s0">283 14 get_2ndtangent 0 6 519 31 ParametricCurve::get_2ndtangent 0 1 13 0</span>
<span class="s0">91</span>
<span class="s0">virtual bool ParametricCurve::get_2ndtangent(PN_stdfloat t, LVecBase3 &amp;tangent2) const = 0;</span>

<span class="s0">284 12 adjust_point 0 6 519 29 ParametricCurve::adjust_point 0 1 14 144</span>
<span class="s0">/**</span>
 <span class="s0">* Recomputes the curve such that it passes through the point (px, py, pz) at</span>
 <span class="s0">* time t, but keeps the same tangent value at that point.</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">virtual bool ParametricCurve::adjust_point(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz);</span>

<span class="s0">285 14 adjust_tangent 0 6 519 31 ParametricCurve::adjust_tangent 0 1 15 129</span>
<span class="s0">/**</span>
 <span class="s0">* Recomputes the curve such that it has the tangent (tx, ty, tz) at time t,</span>
 <span class="s0">* but keeps the same position at the point.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">virtual bool ParametricCurve::adjust_tangent(PN_stdfloat t, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz);</span>

<span class="s0">286 9 adjust_pt 0 6 519 26 ParametricCurve::adjust_pt 0 1 16 116</span>
<span class="s0">/**</span>
 <span class="s0">* Recomputes the curve such that it passes through the point (px, py, pz)</span>
 <span class="s0">* with the tangent (tx, ty, tz).</span>
 <span class="s0">*/</span>
<span class="s0">151</span>
<span class="s0">virtual bool ParametricCurve::adjust_pt(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz);</span>

<span class="s0">287 9 recompute 0 6 519 26 ParametricCurve::recompute 0 1 17 115</span>
<span class="s0">/**</span>
 <span class="s0">* Recalculates the curve, if necessary.  Returns true if the resulting curve</span>
 <span class="s0">* is valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">virtual bool ParametricCurve::recompute(void);</span>

<span class="s0">288 6 stitch 0 6 519 23 ParametricCurve::stitch 0 1 18 259</span>
<span class="s0">/**</span>
 <span class="s0">* Regenerates this curve as one long curve: the first curve connected end-to-</span>
 <span class="s0">* end with the second one.  Either a or b may be the same as 'this'.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false on failure or if the curve type does not</span>
 <span class="s0">* support stitching.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">virtual bool ParametricCurve::stitch(ParametricCurve const *a, ParametricCurve const *b);</span>

<span class="s0">289 9 write_egg 0 4 519 26 ParametricCurve::write_egg 0 2 19 20 281</span>
<span class="s0">/**</span>
 <span class="s0">* Writes an egg description of the nurbs curve to the specified output file.</span>
 <span class="s0">* Returns true if the file is successfully written.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes an egg description of the nurbs curve to the specified output</span>
 <span class="s0">* stream.  Returns true if the file is successfully written.</span>
 <span class="s0">*/</span>
<span class="s0">186</span>
<span class="s0">bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">bool ParametricCurve::write_egg(std::ostream &amp;out, Filename const &amp;filename, CoordinateSystem cs);</span>

<span class="s0">290 14 get_class_type 0 4 519 31 ParametricCurve::get_class_type 0 1 21 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle ParametricCurve::get_class_type(void);</span>

<span class="s0">291 14 get_class_type 0 4 521 29 CubicCurveseg::get_class_type 0 1 22 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle CubicCurveseg::get_class_type(void);</span>

<span class="s0">292 25 ParametricCurveCollection 0 260 522 52 ParametricCurveCollection::ParametricCurveCollection 0 2 23 24 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">165</span>
<span class="s0">ParametricCurveCollection::ParametricCurveCollection(void);</span>
<span class="s0">inline ParametricCurveCollection::ParametricCurveCollection(ParametricCurveCollection const &amp;) = default;</span>

<span class="s0">293 9 add_curve 0 4 522 36 ParametricCurveCollection::add_curve 0 2 25 26 192</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new ParametricCurve to the collection at the indicated index.</span>
 <span class="s0">* @deprecated Use insert_curve(index, curve) instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new ParametricCurve to the collection.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">void ParametricCurveCollection::add_curve(ParametricCurve *curve);</span>
<span class="s0">void ParametricCurveCollection::add_curve(ParametricCurve *curve, int index);</span>

<span class="s0">294 12 insert_curve 0 4 522 39 ParametricCurveCollection::insert_curve 0 1 27 79</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new ParametricCurve to the collection at the indicated index.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">void ParametricCurveCollection::insert_curve(std::size_t index, ParametricCurve *curve);</span>

<span class="s0">295 10 add_curves 0 4 522 37 ParametricCurveCollection::add_curves 0 1 28 120</span>
<span class="s0">/**</span>
 <span class="s0">* Adds all the curves found in the scene graph rooted at the given node.</span>
 <span class="s0">* Returns the number of curves found.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">int ParametricCurveCollection::add_curves(PandaNode *node);</span>

<span class="s0">296 12 remove_curve 0 4 522 39 ParametricCurveCollection::remove_curve 0 2 29 30 255</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated ParametricCurve from the collection.  Returns true if</span>
 <span class="s0">* the curve was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the indicated ParametricCurve from the collection, by its index</span>
 <span class="s0">* number.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">bool ParametricCurveCollection::remove_curve(ParametricCurve *curve);</span>
<span class="s0">void ParametricCurveCollection::remove_curve(std::size_t index);</span>

<span class="s0">297 9 set_curve 0 4 522 36 ParametricCurveCollection::set_curve 0 1 31 94</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated ParametricCurve from the collection, by its index</span>
 <span class="s0">* number.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">void ParametricCurveCollection::set_curve(std::size_t index, ParametricCurve *curve);</span>

<span class="s0">298 9 has_curve 0 4 522 36 ParametricCurveCollection::has_curve 0 1 32 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated ParametricCurve appears in this collection,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">bool ParametricCurveCollection::has_curve(ParametricCurve *curve) const;</span>

<span class="s0">299 5 clear 0 4 522 32 ParametricCurveCollection::clear 0 1 33 60</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all ParametricCurves from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void ParametricCurveCollection::clear(void);</span>

<span class="s0">300 15 clear_timewarps 0 4 522 42 ParametricCurveCollection::clear_timewarps 0 1 34 63</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the timewarp curves from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void ParametricCurveCollection::clear_timewarps(void);</span>

<span class="s0">301 14 get_num_curves 0 4 522 41 ParametricCurveCollection::get_num_curves 0 1 35 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of ParametricCurves in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int ParametricCurveCollection::get_num_curves(void) const;</span>

<span class="s0">302 9 get_curve 0 4 522 36 ParametricCurveCollection::get_curve 0 1 36 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth ParametricCurve in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const;</span>

<span class="s0">303 13 get_xyz_curve 0 4 522 40 ParametricCurveCollection::get_xyz_curve 0 1 37 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first XYZ curve in the collection, if any, or NULL if there are</span>
 <span class="s0">* none.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const;</span>

<span class="s0">304 13 get_hpr_curve 0 4 522 40 ParametricCurveCollection::get_hpr_curve 0 1 38 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first HPR curve in the collection, if any, or NULL if there are</span>
 <span class="s0">* none.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const;</span>

<span class="s0">305 17 get_default_curve 0 4 522 44 ParametricCurveCollection::get_default_curve 0 1 39 180</span>
<span class="s0">/**</span>
 <span class="s0">* If there is an XYZ curve in the collection, returns it; otherwise, returns</span>
 <span class="s0">* the first curve whose type is unspecified.  Returns NULL if no curve meets</span>
 <span class="s0">* the criteria.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">ParametricCurve *ParametricCurveCollection::get_default_curve(void) const;</span>

<span class="s0">306 17 get_num_timewarps 0 4 522 44 ParametricCurveCollection::get_num_timewarps 0 1 40 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of timewarp curves in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">int ParametricCurveCollection::get_num_timewarps(void) const;</span>

<span class="s0">307 18 get_timewarp_curve 0 4 522 45 ParametricCurveCollection::get_timewarp_curve 0 1 41 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth timewarp curve in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const;</span>

<span class="s0">308 9 get_max_t 0 4 522 36 ParametricCurveCollection::get_max_t 0 1 42 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum T value associated with the *last* curve in the</span>
 <span class="s0">* collection.  Normally, this will be either the XYZ or HPR curve, or a</span>
 <span class="s0">* timewarp curve.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline PN_stdfloat ParametricCurveCollection::get_max_t(void) const;</span>

<span class="s0">309 9 make_even 0 4 522 36 ParametricCurveCollection::make_even 0 1 43 539</span>
<span class="s0">/**</span>
 <span class="s0">* Discards all existing timewarp curves and recomputes a new timewarp curve</span>
 <span class="s0">* that maps distance along the curve to parametric time, so that the distance</span>
 <span class="s0">* between any two points in parametric time is proportional to the</span>
 <span class="s0">* approximate distance of those same two points along the XYZ curve.</span>
 <span class="s0">*</span>
 <span class="s0">* segments_per_unit represents the number of segments to take per each unit</span>
 <span class="s0">* of parametric time of the original XYZ curve.</span>
 <span class="s0">*</span>
 <span class="s0">* The new timewarp curve (and thus, the apparent range of the collection)</span>
 <span class="s0">* will range from 0 to max_t.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">void ParametricCurveCollection::make_even(PN_stdfloat max_t, PN_stdfloat segments_per_unit);</span>

<span class="s0">310 12 face_forward 0 4 522 39 ParametricCurveCollection::face_forward 0 1 44 179</span>
<span class="s0">/**</span>
 <span class="s0">* Discards the existing HPR curve and generates a new one that looks in the</span>
 <span class="s0">* direction of travel along the XYZ curve, based on the XYZ curve's tangent</span>
 <span class="s0">* at each point.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void ParametricCurveCollection::face_forward(PN_stdfloat segments_per_unit);</span>

<span class="s0">311 11 reset_max_t 0 4 522 38 ParametricCurveCollection::reset_max_t 0 1 45 277</span>
<span class="s0">/**</span>
 <span class="s0">* Adjusts the apparent length of the curve by applying a new timewarp that</span>
 <span class="s0">* maps the range [0..max_t] to the range [0..get_max_t()].  After this call,</span>
 <span class="s0">* the curve collection will contain one more timewarp curve, and get_max_t()</span>
 <span class="s0">* will return the given max_t value.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void ParametricCurveCollection::reset_max_t(PN_stdfloat max_t);</span>

<span class="s0">312 8 evaluate 0 4 522 35 ParametricCurveCollection::evaluate 0 2 46 47 943</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the position and rotation represented by the first XYZ and HPR</span>
 <span class="s0">* curves in the collection at the given point t, after t has been modified by</span>
 <span class="s0">* all the timewarp curves in the collection applied in sequence, from back to</span>
 <span class="s0">* front.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the point is valid (i.e.  t is within the bounds indicated</span>
 <span class="s0">* by all the timewarp curves and within the bounds of the curves themselves),</span>
 <span class="s0">* or false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Computes the transform matrix representing translation to the position</span>
 <span class="s0">* indicated by the first XYZ curve in the collection and the rotation</span>
 <span class="s0">* indicated by the first HPR curve in the collection, after t has been</span>
 <span class="s0">* modified by all the timewarp curves in the collection applied in sequence,</span>
 <span class="s0">* from back to front.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the point is valid (i.e.  t is within the bounds indicated</span>
 <span class="s0">* by all the timewarp curves and within the bounds of the curves themselves),</span>
 <span class="s0">* or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">211</span>
<span class="s0">bool ParametricCurveCollection::evaluate(PN_stdfloat t, LVecBase3 &amp;xyz, LVecBase3 &amp;hpr) const;</span>
<span class="s0">bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &amp;result, CoordinateSystem cs = ::CS_default) const;</span>

<span class="s0">313 10 evaluate_t 0 4 522 37 ParametricCurveCollection::evaluate_t 0 1 48 219</span>
<span class="s0">/**</span>
 <span class="s0">* Determines the value of t that should be passed to the XYZ and HPR curves,</span>
 <span class="s0">* after applying the given value of t to all the timewarps.  Return -1.0f if</span>
 <span class="s0">* the value of t exceeds one of the timewarps' ranges.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">PN_stdfloat ParametricCurveCollection::evaluate_t(PN_stdfloat t) const;</span>

<span class="s0">314 12 evaluate_xyz 0 4 522 39 ParametricCurveCollection::evaluate_xyz 0 1 49 69</span>
<span class="s0">/**</span>
 <span class="s0">* Computes only the XYZ part of the curves.  See evaluate().</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline bool ParametricCurveCollection::evaluate_xyz(PN_stdfloat t, LVecBase3 &amp;xyz) const;</span>

<span class="s0">315 12 evaluate_hpr 0 4 522 39 ParametricCurveCollection::evaluate_hpr 0 1 50 69</span>
<span class="s0">/**</span>
 <span class="s0">* Computes only the HPR part of the curves.  See evaluate().</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline bool ParametricCurveCollection::evaluate_hpr(PN_stdfloat t, LVecBase3 &amp;hpr) const;</span>

<span class="s0">316 10 adjust_xyz 0 4 522 37 ParametricCurveCollection::adjust_xyz 0 2 51 52 418</span>
<span class="s0">/**</span>
 <span class="s0">* Adjust the XYZ curve at the indicated time to the new value.  The curve</span>
 <span class="s0">* shape will change correspondingly.  Returns true if successful, false if</span>
 <span class="s0">* unable to make the adjustment for some reason.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adjust the XYZ curve at the indicated time to the new value.  The curve</span>
 <span class="s0">* shape will change correspondingly.  Returns true if successful, false if</span>
 <span class="s0">* unable to make the adjustment for some reason.</span>
 <span class="s0">*/</span>
<span class="s0">191</span>
<span class="s0">inline bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, LVecBase3 const &amp;xyz);</span>

<span class="s0">317 10 adjust_hpr 0 4 522 37 ParametricCurveCollection::adjust_hpr 0 2 53 54 418</span>
<span class="s0">/**</span>
 <span class="s0">* Adjust the HPR curve at the indicated time to the new value.  The curve</span>
 <span class="s0">* shape will change correspondingly.  Returns true if successful, false if</span>
 <span class="s0">* unable to make the adjustment for some reason.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adjust the HPR curve at the indicated time to the new value.  The curve</span>
 <span class="s0">* shape will change correspondingly.  Returns true if successful, false if</span>
 <span class="s0">* unable to make the adjustment for some reason.</span>
 <span class="s0">*/</span>
<span class="s0">191</span>
<span class="s0">inline bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>
<span class="s0">bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, LVecBase3 const &amp;xyz);</span>

<span class="s0">318 9 recompute 0 4 522 36 ParametricCurveCollection::recompute 0 1 55 153</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures all the curves are freshly computed and up-to-date.  Returns true</span>
 <span class="s0">* if everything is valid, false if at least one curve is incorrect.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool ParametricCurveCollection::recompute(void);</span>

<span class="s0">319 6 stitch 0 4 522 33 ParametricCurveCollection::stitch 0 1 56 262</span>
<span class="s0">/**</span>
 <span class="s0">* Regenerates this curve as one long curve: the first curve connected end-to-</span>
 <span class="s0">* end with the second one.  Either a or b may be the same as 'this'.  This</span>
 <span class="s0">* will lose any timewarps on the input curves.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">bool ParametricCurveCollection::stitch(ParametricCurveCollection const *a, ParametricCurveCollection const *b);</span>

<span class="s0">320 6 output 0 4 522 33 ParametricCurveCollection::output 0 1 57 114</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief one-line description of the ParametricCurveCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void ParametricCurveCollection::output(std::ostream &amp;out) const;</span>

<span class="s0">321 5 write 0 4 522 32 ParametricCurveCollection::write 0 1 58 119</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a complete multi-line description of the ParametricCurveCollection</span>
 <span class="s0">* to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">void ParametricCurveCollection::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">322 9 write_egg 0 4 522 36 ParametricCurveCollection::write_egg 0 2 59 60 328</span>
<span class="s0">/**</span>
 <span class="s0">* Writes an egg description of all the nurbs curves in the collection to the</span>
 <span class="s0">* specified output file.  Returns true if the file is successfully written.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes an egg description of all the nurbs curves in the collection to the</span>
 <span class="s0">* specified output stream.  Returns true if the file is successfully written.</span>
 <span class="s0">*/</span>
<span class="s0">206</span>
<span class="s0">bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs = ::CS_default);</span>
<span class="s0">bool ParametricCurveCollection::write_egg(std::ostream &amp;out, Filename const &amp;filename, CoordinateSystem cs);</span>

<span class="s0">323 11 CurveFitter 0 260 527 24 CurveFitter::CurveFitter 0 2 61 62 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">CurveFitter::CurveFitter(void);</span>
<span class="s0">inline CurveFitter::CurveFitter(CurveFitter const &amp;) = default;</span>

<span class="s0">324 12 ~CurveFitter 0 516 527 25 CurveFitter::~CurveFitter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">CurveFitter::~CurveFitter(void);</span>

<span class="s0">325 5 reset 0 4 527 18 CurveFitter::reset 0 1 63 114</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the data points previously added to the CurveFitter, and</span>
 <span class="s0">* initializes it for a new curve.</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">void CurveFitter::reset(void);</span>

<span class="s0">326 7 add_xyz 0 4 527 20 CurveFitter::add_xyz 0 1 64 36</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a single sample xyz.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void CurveFitter::add_xyz(PN_stdfloat t, LVecBase3 const &amp;xyz);</span>

<span class="s0">327 7 add_hpr 0 4 527 20 CurveFitter::add_hpr 0 1 65 36</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a single sample hpr.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void CurveFitter::add_hpr(PN_stdfloat t, LVecBase3 const &amp;hpr);</span>

<span class="s0">328 11 add_xyz_hpr 0 4 527 24 CurveFitter::add_xyz_hpr 0 1 66 57</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a single sample xyz &amp; hpr simultaneously.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void CurveFitter::add_xyz_hpr(PN_stdfloat t, LVecBase3 const &amp;xyz, LVecBase3 const &amp;hpr);</span>

<span class="s0">329 15 get_num_samples 0 4 527 28 CurveFitter::get_num_samples 0 1 67 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of sample points that have been added.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int CurveFitter::get_num_samples(void) const;</span>

<span class="s0">330 12 get_sample_t 0 4 527 25 CurveFitter::get_sample_t 0 1 68 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the parametric value of the nth sample added.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">PN_stdfloat CurveFitter::get_sample_t(int n) const;</span>

<span class="s0">331 14 get_sample_xyz 0 4 527 27 CurveFitter::get_sample_xyz 0 1 69 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point in space of the nth sample added.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">LVecBase3 CurveFitter::get_sample_xyz(int n) const;</span>

<span class="s0">332 14 get_sample_hpr 0 4 527 27 CurveFitter::get_sample_hpr 0 1 70 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the orientation of the nth sample added.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">LVecBase3 CurveFitter::get_sample_hpr(int n) const;</span>

<span class="s0">333 18 get_sample_tangent 0 4 527 31 CurveFitter::get_sample_tangent 0 1 71 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the tangent associated with the nth sample added.  This is only</span>
 <span class="s0">* meaningful if compute_tangents() has already been called.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">LVecBase3 CurveFitter::get_sample_tangent(int n) const;</span>

<span class="s0">334 14 remove_samples 0 4 527 27 CurveFitter::remove_samples 0 1 72 108</span>
<span class="s0">/**</span>
 <span class="s0">* Eliminates all samples from index begin, up to but not including index end,</span>
 <span class="s0">* from the database.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void CurveFitter::remove_samples(int begin, int end);</span>

<span class="s0">335 6 sample 0 4 527 19 CurveFitter::sample 0 1 73 223</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a series of data points by sampling the given curve (or xyz/hpr</span>
 <span class="s0">* curves) the indicated number of times.  The sampling is made evenly in</span>
 <span class="s0">* parametric time, and then the timewarps, if any, are applied.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">void CurveFitter::sample(ParametricCurveCollection *curves, int count);</span>

<span class="s0">336 8 wrap_hpr 0 4 527 21 CurveFitter::wrap_hpr 0 1 74 165</span>
<span class="s0">/**</span>
 <span class="s0">* Resets each HPR data point so that the maximum delta between any two</span>
 <span class="s0">* consecutive points is 180 degrees, which should prevent incorrect HPR</span>
 <span class="s0">* wrapping.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void CurveFitter::wrap_hpr(void);</span>

<span class="s0">337 11 sort_points 0 4 527 24 CurveFitter::sort_points 0 1 75 115</span>
<span class="s0">/**</span>
 <span class="s0">* Sorts all the data points in order by parametric time, in case they were</span>
 <span class="s0">* added in an incorrect order.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void CurveFitter::sort_points(void);</span>

<span class="s0">338 8 desample 0 4 527 21 CurveFitter::desample 0 1 76 175</span>
<span class="s0">/**</span>
 <span class="s0">* Removes sample points in order to reduce the complexity of a sampled curve.</span>
 <span class="s0">* Keeps one out of every factor samples.  Also keeps the first and the last</span>
 <span class="s0">* samples.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void CurveFitter::desample(PN_stdfloat factor);</span>

<span class="s0">339 16 compute_tangents 0 4 527 29 CurveFitter::compute_tangents 0 1 77 231</span>
<span class="s0">/**</span>
 <span class="s0">* Once a set of points has been built, and prior to calling MakeHermite() or</span>
 <span class="s0">* MakeNurbs(), ComputeTangents() must be called to set up the tangents</span>
 <span class="s0">* correctly (unless the tangents were defined as the points were added).</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void CurveFitter::compute_tangents(PN_stdfloat scale);</span>

<span class="s0">340 12 make_hermite 0 4 527 25 CurveFitter::make_hermite 0 1 78 72</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the current set of data points into a Hermite curve.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">PointerTo&lt; ParametricCurveCollection &gt; CurveFitter::make_hermite(void) const;</span>

<span class="s0">341 10 make_nurbs 0 4 527 23 CurveFitter::make_nurbs 0 1 79 134</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the current set of data points into a NURBS curve.  This gives a</span>
 <span class="s0">* smoother curve than produced by MakeHermite().</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">PointerTo&lt; ParametricCurveCollection &gt; CurveFitter::make_nurbs(void) const;</span>

<span class="s0">342 6 output 0 4 527 19 CurveFitter::output 0 1 80 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void CurveFitter::output(std::ostream &amp;out) const;</span>

<span class="s0">343 5 write 0 4 527 18 CurveFitter::write 0 1 81 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void CurveFitter::write(std::ostream &amp;out) const;</span>

<span class="s0">344 14 get_class_type 0 4 527 27 CurveFitter::get_class_type 0 1 82 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle CurveFitter::get_class_type(void);</span>

<span class="s0">345 14 PiecewiseCurve 0 260 528 30 PiecewiseCurve::PiecewiseCurve 0 1 83 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">PiecewiseCurve::PiecewiseCurve(void);</span>

<span class="s0">346 14 get_class_type 0 4 528 30 PiecewiseCurve::get_class_type 0 1 84 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle PiecewiseCurve::get_class_type(void);</span>

<span class="s0">347 12 HermiteCurve 0 260 529 26 HermiteCurve::HermiteCurve 0 2 85 86 92</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a Hermite from the indicated (possibly non-hermite) curve.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">HermiteCurve::HermiteCurve(void);</span>
<span class="s0">HermiteCurve::HermiteCurve(ParametricCurve const &amp;pc);</span>

<span class="s0">348 11 get_num_cvs 0 4 529 25 HermiteCurve::get_num_cvs 0 1 87 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of CV's in the curve.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">int HermiteCurve::get_num_cvs(void) const;</span>

<span class="s0">349 9 insert_cv 0 4 529 23 HermiteCurve::insert_cv 0 1 88 547</span>
<span class="s0">/**</span>
 <span class="s0">* Inserts a new CV at the given parametric point along the curve.  If this</span>
 <span class="s0">* parametric point is already on the curve, the CV is assigned an index</span>
 <span class="s0">* between its two neighbors and the indices of all following CV's are</span>
 <span class="s0">* incremented by 1; its in and out tangents are chosen to keep the curve</span>
 <span class="s0">* consistent.  If the new parametric point is beyond the end of the existing</span>
 <span class="s0">* curve, the curve is extended to meet it and the new CV's position, in</span>
 <span class="s0">* tangent, and out tangent are set to zero.</span>
 <span class="s0">*</span>
 <span class="s0">* The index number of the new CV is returned.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">int HermiteCurve::insert_cv(PN_stdfloat t);</span>

<span class="s0">350 9 append_cv 0 4 529 23 HermiteCurve::append_cv 0 2 89 90 149</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new CV to the end of the curve.  The new CV is given initial in/out</span>
 <span class="s0">* tangents of 0.  The return value is the index of the new CV.</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">int HermiteCurve::append_cv(int type, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline int HermiteCurve::append_cv(int type, LVecBase3 const &amp;v);</span>

<span class="s0">351 9 remove_cv 0 4 529 23 HermiteCurve::remove_cv 0 1 91 100</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the given CV from the curve.  Returns true if the CV existed, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">bool HermiteCurve::remove_cv(int n);</span>

<span class="s0">352 14 remove_all_cvs 0 4 529 28 HermiteCurve::remove_all_cvs 0 1 92 43</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all CV's from the curve.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void HermiteCurve::remove_all_cvs(void);</span>

<span class="s0">353 11 set_cv_type 0 4 529 25 HermiteCurve::set_cv_type 0 1 93 544</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the given CV's continuity type.  Legal values are HC_CUT, HC_FREE,</span>
 <span class="s0">* HC_G1, or HC_SMOOTH.</span>
 <span class="s0">*</span>
 <span class="s0">* Other than HC_CUT, these have no effect on the actual curve; it remains up</span>
 <span class="s0">* to user software to impose the constraints these imply.</span>
 <span class="s0">*</span>
 <span class="s0">* HC_CUT implies a disconnection of the curve; HC_FREE imposes no constraints</span>
 <span class="s0">* on the tangents; HC_G1 forces the tangents to be collinear, and HC_SMOOTH</span>
 <span class="s0">* forces the tangents to be identical.  Setting type type to HC_G1 or</span>
 <span class="s0">* HC_SMOOTH may adjust the out tangent to match the in tangent.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool HermiteCurve::set_cv_type(int n, int type);</span>

<span class="s0">354 12 set_cv_point 0 4 529 26 HermiteCurve::set_cv_point 0 2 94 95 43</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the given CV's position.</span>
 <span class="s0">*/</span>
<span class="s0">151</span>
<span class="s0">bool HermiteCurve::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline bool HermiteCurve::set_cv_point(int n, LVecBase3 const &amp;v);</span>

<span class="s0">355 9 set_cv_in 0 4 529 23 HermiteCurve::set_cv_in 0 2 96 97 121</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the given CV's in tangent.  Depending on the continuity type, this</span>
 <span class="s0">* may also adjust the out tangent.</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">bool HermiteCurve::set_cv_in(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline bool HermiteCurve::set_cv_in(int n, LVecBase3 const &amp;v);</span>

<span class="s0">356 10 set_cv_out 0 4 529 24 HermiteCurve::set_cv_out 0 2 98 99 121</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the given CV's out tangent.  Depending on the continuity type, this</span>
 <span class="s0">* may also adjust the in tangent.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">bool HermiteCurve::set_cv_out(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline bool HermiteCurve::set_cv_out(int n, LVecBase3 const &amp;v);</span>

<span class="s0">357 13 set_cv_tstart 0 4 529 27 HermiteCurve::set_cv_tstart 0 1 100 103</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the given CV's parametric starting time.  This may affect the shape</span>
 <span class="s0">* of the curve.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool HermiteCurve::set_cv_tstart(int n, PN_stdfloat tstart);</span>

<span class="s0">358 11 set_cv_name 0 4 529 25 HermiteCurve::set_cv_name 0 1 101 60</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the name associated with a particular CV.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">bool HermiteCurve::set_cv_name(int n, char const *name);</span>

<span class="s0">359 11 get_cv_type 0 4 529 25 HermiteCurve::get_cv_type 0 1 102 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the given CV's continuity type, HC_CUT, HC_FREE, HC_G1, or</span>
 <span class="s0">* HC_SMOOTH, or 0 if there is no such CV.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">int HermiteCurve::get_cv_type(int n) const;</span>

<span class="s0">360 12 get_cv_point 0 4 529 26 HermiteCurve::get_cv_point 0 2 103 104 48</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the given CV.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">LVecBase3 const &amp;HermiteCurve::get_cv_point(int n) const;</span>
<span class="s0">void HermiteCurve::get_cv_point(int n, LVecBase3 &amp;v) const;</span>

<span class="s0">361 9 get_cv_in 0 4 529 23 HermiteCurve::get_cv_in 0 2 105 106 50</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the in tangent of the given CV.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">LVecBase3 const &amp;HermiteCurve::get_cv_in(int n) const;</span>
<span class="s0">void HermiteCurve::get_cv_in(int n, LVecBase3 &amp;v) const;</span>

<span class="s0">362 10 get_cv_out 0 4 529 24 HermiteCurve::get_cv_out 0 2 107 108 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the out tangent of the given CV.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">LVecBase3 const &amp;HermiteCurve::get_cv_out(int n) const;</span>
<span class="s0">void HermiteCurve::get_cv_out(int n, LVecBase3 &amp;v) const;</span>

<span class="s0">363 13 get_cv_tstart 0 4 529 27 HermiteCurve::get_cv_tstart 0 1 109 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the starting point in parametric space of the given CV.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">PN_stdfloat HermiteCurve::get_cv_tstart(int n) const;</span>

<span class="s0">364 11 get_cv_name 0 4 529 25 HermiteCurve::get_cv_name 0 1 110 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the given CV, or NULL.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">std::string HermiteCurve::get_cv_name(int n) const;</span>

<span class="s0">365 8 write_cv 0 4 529 22 HermiteCurve::write_cv 0 1 111 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void HermiteCurve::write_cv(std::ostream &amp;out, int n) const;</span>

<span class="s0">366 14 get_class_type 0 4 529 28 HermiteCurve::get_class_type 0 1 112 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle HermiteCurve::get_class_type(void);</span>

<span class="s0">367 20 ~NurbsCurveInterface 0 518 530 41 NurbsCurveInterface::~NurbsCurveInterface 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual NurbsCurveInterface::~NurbsCurveInterface(void);</span>

<span class="s0">368 9 set_order 0 6 530 30 NurbsCurveInterface::set_order 0 1 113 0</span>
<span class="s0">59</span>
<span class="s0">virtual void NurbsCurveInterface::set_order(int order) = 0;</span>

<span class="s0">369 9 get_order 0 6 530 30 NurbsCurveInterface::get_order 0 1 114 0</span>
<span class="s0">59</span>
<span class="s0">virtual int NurbsCurveInterface::get_order(void) const = 0;</span>

<span class="s0">370 11 get_num_cvs 0 6 530 32 NurbsCurveInterface::get_num_cvs 0 1 115 0</span>
<span class="s0">61</span>
<span class="s0">virtual int NurbsCurveInterface::get_num_cvs(void) const = 0;</span>

<span class="s0">371 13 get_num_knots 0 6 530 34 NurbsCurveInterface::get_num_knots 0 1 116 0</span>
<span class="s0">63</span>
<span class="s0">virtual int NurbsCurveInterface::get_num_knots(void) const = 0;</span>

<span class="s0">372 9 insert_cv 0 6 530 30 NurbsCurveInterface::insert_cv 0 1 117 0</span>
<span class="s0">63</span>
<span class="s0">virtual bool NurbsCurveInterface::insert_cv(PN_stdfloat t) = 0;</span>

<span class="s0">373 9 append_cv 0 4 530 30 NurbsCurveInterface::append_cv 0 3 118 119 120 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">213</span>
<span class="s0">inline int NurbsCurveInterface::append_cv(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline int NurbsCurveInterface::append_cv(LVecBase3 const &amp;v);</span>
<span class="s0">inline int NurbsCurveInterface::append_cv(LVecBase4 const &amp;v);</span>

<span class="s0">374 9 remove_cv 0 6 530 30 NurbsCurveInterface::remove_cv 0 1 121 0</span>
<span class="s0">55</span>
<span class="s0">virtual bool NurbsCurveInterface::remove_cv(int n) = 0;</span>

<span class="s0">375 14 remove_all_cvs 0 6 530 35 NurbsCurveInterface::remove_all_cvs 0 1 122 0</span>
<span class="s0">59</span>
<span class="s0">virtual void NurbsCurveInterface::remove_all_cvs(void) = 0;</span>

<span class="s0">376 12 set_cv_point 0 4 530 33 NurbsCurveInterface::set_cv_point 0 2 123 124 174</span>
<span class="s0">/**</span>
 <span class="s0">* Repositions the indicated CV.  Returns true if successful, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Repositions the indicated CV.  Returns true if successful, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">172</span>
<span class="s0">inline bool NurbsCurveInterface::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline bool NurbsCurveInterface::set_cv_point(int n, LVecBase3 const &amp;v);</span>

<span class="s0">377 12 get_cv_point 0 4 530 33 NurbsCurveInterface::get_cv_point 0 1 125 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the indicated CV.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LVecBase3 NurbsCurveInterface::get_cv_point(int n) const;</span>

<span class="s0">378 13 set_cv_weight 0 4 530 34 NurbsCurveInterface::set_cv_weight 0 1 126 94</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the weight of the indicated CV without affecting its position in 3-d</span>
 <span class="s0">* space.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool NurbsCurveInterface::set_cv_weight(int n, PN_stdfloat w);</span>

<span class="s0">379 13 get_cv_weight 0 4 530 34 NurbsCurveInterface::get_cv_weight 0 1 127 50</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the weight of the indicated CV.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline PN_stdfloat NurbsCurveInterface::get_cv_weight(int n) const;</span>

<span class="s0">380 6 set_cv 0 6 530 27 NurbsCurveInterface::set_cv 0 1 128 0</span>
<span class="s0">72</span>
<span class="s0">virtual bool NurbsCurveInterface::set_cv(int n, LVecBase4 const &amp;v) = 0;</span>

<span class="s0">381 6 get_cv 0 6 530 27 NurbsCurveInterface::get_cv 0 1 129 0</span>
<span class="s0">63</span>
<span class="s0">virtual LVecBase4 NurbsCurveInterface::get_cv(int n) const = 0;</span>

<span class="s0">382 8 set_knot 0 6 530 29 NurbsCurveInterface::set_knot 0 1 130 0</span>
<span class="s0">69</span>
<span class="s0">virtual bool NurbsCurveInterface::set_knot(int n, PN_stdfloat t) = 0;</span>

<span class="s0">383 8 get_knot 0 6 530 29 NurbsCurveInterface::get_knot 0 1 131 0</span>
<span class="s0">67</span>
<span class="s0">virtual PN_stdfloat NurbsCurveInterface::get_knot(int n) const = 0;</span>

<span class="s0">384 8 write_cv 0 4 530 29 NurbsCurveInterface::write_cv 0 1 132 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void NurbsCurveInterface::write_cv(std::ostream &amp;out, int n) const;</span>

<span class="s0">385 14 get_class_type 0 4 530 35 NurbsCurveInterface::get_class_type 0 1 133 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle NurbsCurveInterface::get_class_type(void);</span>

<span class="s0">386 24 upcast_to_PiecewiseCurve 0 12 531 36 NurbsCurve::upcast_to_PiecewiseCurve 0 1 137 40</span>
<span class="s0">upcast from NurbsCurve to PiecewiseCurve</span>
<span class="s0">59</span>
<span class="s0">PiecewiseCurve *NurbsCurve::upcast_to_PiecewiseCurve(void);</span>

<span class="s0">387 22 downcast_to_NurbsCurve 0 12 528 38 PiecewiseCurve::downcast_to_NurbsCurve 0 0 42</span>
<span class="s0">downcast from PiecewiseCurve to NurbsCurve</span>
<span class="s0">57</span>
<span class="s0">NurbsCurve *PiecewiseCurve::downcast_to_NurbsCurve(void);</span>

<span class="s0">388 29 upcast_to_NurbsCurveInterface 0 12 531 41 NurbsCurve::upcast_to_NurbsCurveInterface 0 1 138 45</span>
<span class="s0">upcast from NurbsCurve to NurbsCurveInterface</span>
<span class="s0">69</span>
<span class="s0">NurbsCurveInterface *NurbsCurve::upcast_to_NurbsCurveInterface(void);</span>

<span class="s0">389 22 downcast_to_NurbsCurve 0 12 530 43 NurbsCurveInterface::downcast_to_NurbsCurve 0 0 47</span>
<span class="s0">downcast from NurbsCurveInterface to NurbsCurve</span>
<span class="s0">62</span>
<span class="s0">NurbsCurve *NurbsCurveInterface::downcast_to_NurbsCurve(void);</span>

<span class="s0">390 10 NurbsCurve 0 260 531 22 NurbsCurve::NurbsCurve 0 2 134 135 188</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a NURBS curve equivalent to the indicated (possibly non-NURBS)</span>
 <span class="s0">* curve.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a NURBS curve according to the indicated NURBS parameters.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">NurbsCurve::NurbsCurve(void);</span>
<span class="s0">NurbsCurve::NurbsCurve(ParametricCurve const &amp;pc);</span>

<span class="s0">391 11 ~NurbsCurve 0 518 531 23 NurbsCurve::~NurbsCurve 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">virtual NurbsCurve::~NurbsCurve(void);</span>

<span class="s0">392 14 get_class_type 0 4 531 26 NurbsCurve::get_class_type 0 1 136 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle NurbsCurve::get_class_type(void);</span>

<span class="s0">393 11 get_start_t 0 4 532 29 NurbsCurveResult::get_start_t 0 1 140 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first legal value of t on the curve.  Usually this is 0.0.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline PN_stdfloat NurbsCurveResult::get_start_t(void) const;</span>

<span class="s0">394 9 get_end_t 0 4 532 27 NurbsCurveResult::get_end_t 0 1 141 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the last legal value of t on the curve.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PN_stdfloat NurbsCurveResult::get_end_t(void) const;</span>

<span class="s0">395 10 eval_point 0 4 532 28 NurbsCurveResult::eval_point 0 1 142 158</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the point on the curve corresponding to the indicated value in</span>
 <span class="s0">* parametric time.  Returns true if the t value is valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline bool NurbsCurveResult::eval_point(PN_stdfloat t, LVecBase3 &amp;point);</span>

<span class="s0">396 12 eval_tangent 0 4 532 30 NurbsCurveResult::eval_tangent 0 1 143 193</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the tangent to the curve at the indicated point in parametric</span>
 <span class="s0">* time.  This tangent vector will not necessarily be normalized, and could be</span>
 <span class="s0">* zero.  See also eval_point().</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline bool NurbsCurveResult::eval_tangent(PN_stdfloat t, LVecBase3 &amp;tangent);</span>

<span class="s0">397 19 eval_extended_point 0 4 532 37 NurbsCurveResult::eval_extended_point 0 1 144 145</span>
<span class="s0">/**</span>
 <span class="s0">* Evaluates the curve in n-dimensional space according to the extended</span>
 <span class="s0">* vertices associated with the curve in the indicated dimension.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline PN_stdfloat NurbsCurveResult::eval_extended_point(PN_stdfloat t, int d);</span>

<span class="s0">398 20 eval_extended_points 0 4 532 38 NurbsCurveResult::eval_extended_points 0 1 145 248</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously performs eval_extended_point on a contiguous sequence of</span>
 <span class="s0">* dimensions.  The dimensions evaluated are d through (d + num_values - 1);</span>
 <span class="s0">* the results are filled into the num_values elements in the indicated result</span>
 <span class="s0">* array.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">inline bool NurbsCurveResult::eval_extended_points(PN_stdfloat t, int d, PN_stdfloat result[], int num_values);</span>

<span class="s0">399 16 get_num_segments 0 4 532 34 NurbsCurveResult::get_num_segments 0 1 146 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of piecewise continuous segments within the curve.  This</span>
 <span class="s0">* number is usually not important unless you plan to call</span>
 <span class="s0">* eval_segment_point().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int NurbsCurveResult::get_num_segments(void) const;</span>

<span class="s0">400 18 eval_segment_point 0 4 532 36 NurbsCurveResult::eval_segment_point 0 1 147 637</span>
<span class="s0">/**</span>
 <span class="s0">* Evaluates the point on the curve corresponding to the indicated value in</span>
 <span class="s0">* parametric time within the indicated curve segment.  t should be in the</span>
 <span class="s0">* range [0, 1].</span>
 <span class="s0">*</span>
 <span class="s0">* The curve is internally represented as a number of connected (or possibly</span>
 <span class="s0">* unconnected) piecewise continuous segments.  The exact number of segments</span>
 <span class="s0">* for a particular curve depends on the knot vector, and is returned by</span>
 <span class="s0">* get_num_segments().  Normally, eval_point() is used to evaluate a point</span>
 <span class="s0">* along the continuous curve, but when you care more about local continuity,</span>
 <span class="s0">* you can use eval_segment_point() to evaluate the points along each segment.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">void NurbsCurveResult::eval_segment_point(int segment, PN_stdfloat t, LVecBase3 &amp;point) const;</span>

<span class="s0">401 20 eval_segment_tangent 0 4 532 38 NurbsCurveResult::eval_segment_tangent 0 1 148 207</span>
<span class="s0">/**</span>
 <span class="s0">* As eval_segment_point, but computes the tangent to the curve at the</span>
 <span class="s0">* indicated point.  The tangent vector will not necessarily be normalized,</span>
 <span class="s0">* and could be zero, particularly at the endpoints.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">void NurbsCurveResult::eval_segment_tangent(int segment, PN_stdfloat t, LVecBase3 &amp;tangent) const;</span>

<span class="s0">402 27 eval_segment_extended_point 0 4 532 45 NurbsCurveResult::eval_segment_extended_point 0 1 149 145</span>
<span class="s0">/**</span>
 <span class="s0">* Evaluates the curve in n-dimensional space according to the extended</span>
 <span class="s0">* vertices associated with the curve in the indicated dimension.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">PN_stdfloat NurbsCurveResult::eval_segment_extended_point(int segment, PN_stdfloat t, int d) const;</span>

<span class="s0">403 28 eval_segment_extended_points 0 4 532 46 NurbsCurveResult::eval_segment_extended_points 0 1 150 248</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously performs eval_extended_point on a contiguous sequence of</span>
 <span class="s0">* dimensions.  The dimensions evaluated are d through (d + num_values - 1);</span>
 <span class="s0">* the results are filled into the num_values elements in the indicated result</span>
 <span class="s0">* array.</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">void NurbsCurveResult::eval_segment_extended_points(int segment, PN_stdfloat t, int d, PN_stdfloat result[], int num_values) const;</span>

<span class="s0">404 13 get_segment_t 0 4 532 31 NurbsCurveResult::get_segment_t 0 1 151 217</span>
<span class="s0">/**</span>
 <span class="s0">* Accepts a t value in the range [0, 1], and assumed to be relative to the</span>
 <span class="s0">* indicated segment (as in eval_segment_point()), and returns the</span>
 <span class="s0">* corresponding t value in the entire curve (as in eval_point()).</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline PN_stdfloat NurbsCurveResult::get_segment_t(int segment, PN_stdfloat t) const;</span>

<span class="s0">405 15 adaptive_sample 0 4 532 33 NurbsCurveResult::adaptive_sample 0 1 152 330</span>
<span class="s0">/**</span>
 <span class="s0">* Determines the set of subdivisions necessary to approximate the curve with</span>
 <span class="s0">* a set of linear segments, no point of which is farther than tolerance units</span>
 <span class="s0">* from the actual curve.</span>
 <span class="s0">*</span>
 <span class="s0">* After this call, you may walk through the resulting set of samples with</span>
 <span class="s0">* get_num_samples(), get_sample_t(), and get_sample_point().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void NurbsCurveResult::adaptive_sample(PN_stdfloat tolerance);</span>

<span class="s0">406 15 get_num_samples 0 4 532 33 NurbsCurveResult::get_num_samples 0 1 153 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of sample points generated by the previous call to</span>
 <span class="s0">* adaptive_sample().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int NurbsCurveResult::get_num_samples(void) const;</span>

<span class="s0">407 12 get_sample_t 0 4 532 30 NurbsCurveResult::get_sample_t 0 1 154 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the t value of the nth sample point generated by the previous call</span>
 <span class="s0">* to adaptive_sample().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline PN_stdfloat NurbsCurveResult::get_sample_t(int n) const;</span>

<span class="s0">408 16 get_sample_point 0 4 532 34 NurbsCurveResult::get_sample_point 0 1 155 252</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point on the curve of the nth sample point generated by the</span>
 <span class="s0">* previous call to adaptive_sample().</span>
 <span class="s0">*</span>
 <span class="s0">* For tangents, or extended points, you should use get_sample_t() and pass it</span>
 <span class="s0">* into eval_tangent() or eval_extended_point().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline LPoint3 const &amp;NurbsCurveResult::get_sample_point(int n) const;</span>

<span class="s0">409 16 NurbsCurveResult 0 260 532 34 NurbsCurveResult::NurbsCurveResult 0 1 139 174</span>
<span class="s0">/**</span>
 <span class="s0">* The constructor automatically builds up the result as the product of the</span>
 <span class="s0">* indicated set of basis matrices and the indicated table of control vertex</span>
 <span class="s0">* positions.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline NurbsCurveResult::NurbsCurveResult(NurbsCurveResult const &amp;) = default;</span>

<span class="s0">410 19 NurbsCurveEvaluator 0 260 533 40 NurbsCurveEvaluator::NurbsCurveEvaluator 0 2 156 157 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">NurbsCurveEvaluator::NurbsCurveEvaluator(void);</span>
<span class="s0">inline NurbsCurveEvaluator::NurbsCurveEvaluator(NurbsCurveEvaluator const &amp;) = default;</span>

<span class="s0">411 9 set_order 0 4 533 30 NurbsCurveEvaluator::set_order 0 1 158 224</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the order of the curve.  This resets the knot vector to the default</span>
 <span class="s0">* knot vector for the number of vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* The order must be 1, 2, 3, or 4, and the value is one more than the degree</span>
 <span class="s0">* of the curve.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void NurbsCurveEvaluator::set_order(int order);</span>

<span class="s0">412 9 get_order 0 4 533 30 NurbsCurveEvaluator::get_order 0 1 159 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the order of the curve as set by a previous call to set_order().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int NurbsCurveEvaluator::get_order(void) const;</span>

<span class="s0">413 5 reset 0 4 533 26 NurbsCurveEvaluator::reset 0 1 160 231</span>
<span class="s0">/**</span>
 <span class="s0">* Resets all the vertices and knots to their default values, and sets the</span>
 <span class="s0">* curve up with the indicated number of vertices.  You must then call</span>
 <span class="s0">* set_vertex() repeatedly to fill in all of the vertex values appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void NurbsCurveEvaluator::reset(int num_vertices);</span>

<span class="s0">414 16 get_num_vertices 0 4 533 37 NurbsCurveEvaluator::get_num_vertices 0 1 161 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of control vertices in the curve.  This is the number</span>
 <span class="s0">* passed to the last call to reset().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int NurbsCurveEvaluator::get_num_vertices(void) const;</span>

<span class="s0">415 10 set_vertex 0 4 533 31 NurbsCurveEvaluator::set_vertex 0 2 162 163 441</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth control vertex of the curve, as a vertex in 4-d homogeneous</span>
 <span class="s0">* space.  In this form, the first three components of the vertex should</span>
 <span class="s0">* already have been scaled by the fourth component, which is the homogeneous</span>
 <span class="s0">* weight.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the nth control vertex of the curve.  This flavor sets the vertex as a</span>
 <span class="s0">* 3-d coordinate and a weight; the 3-d coordinate values are implicitly</span>
 <span class="s0">* scaled up by the weight factor.</span>
 <span class="s0">*/</span>
<span class="s0">179</span>
<span class="s0">inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4 const &amp;vertex);</span>
<span class="s0">inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3 const &amp;vertex, PN_stdfloat weight = 1.0);</span>

<span class="s0">416 10 get_vertex 0 4 533 31 NurbsCurveEvaluator::get_vertex 0 2 164 165 202</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth control vertex of the curve, relative to its indicated</span>
 <span class="s0">* coordinate space.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the nth control vertex of the curve, relative to the given</span>
 <span class="s0">* coordinate space.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">inline LVecBase4 const &amp;NurbsCurveEvaluator::get_vertex(int i) const;</span>
<span class="s0">inline LVecBase4 NurbsCurveEvaluator::get_vertex(int i, NodePath const &amp;rel_to) const;</span>

<span class="s0">417 16 set_vertex_space 0 4 533 37 NurbsCurveEvaluator::set_vertex_space 0 2 166 167 792</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the coordinate space of the nth control vertex.  If this is not</span>
 <span class="s0">* specified, or is set to an empty NodePath, the nth control vertex is deemed</span>
 <span class="s0">* to be in the coordinate space passed to evaluate().</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the space as a fixed NodePath, which is always the same</span>
 <span class="s0">* NodePath.  Also see setting the space as a path string, which can specify a</span>
 <span class="s0">* different NodePath for different instances of the curve.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the coordinate space of the nth control vertex.  If this is not</span>
 <span class="s0">* specified, or is set to an empty string, the nth control vertex is deemed</span>
 <span class="s0">* to be in the coordinate space passed to evaluate().</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the space as a string, which describes the path to find the</span>
 <span class="s0">* node relative to the rel_to NodePath when the curve is evaluated.</span>
 <span class="s0">*/</span>
<span class="s0">164</span>
<span class="s0">inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &amp;space);</span>
<span class="s0">inline void NurbsCurveEvaluator::set_vertex_space(int i, std::string const &amp;space);</span>

<span class="s0">418 16 get_vertex_space 0 4 533 37 NurbsCurveEvaluator::get_vertex_space 0 1 168 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the coordinate space of the nth control vertex of the curve,</span>
 <span class="s0">* expressed as a NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">NodePath NurbsCurveEvaluator::get_vertex_space(int i, NodePath const &amp;rel_to) const;</span>

<span class="s0">419 19 set_extended_vertex 0 4 533 40 NurbsCurveEvaluator::set_extended_vertex 0 1 169 768</span>
<span class="s0">/**</span>
 <span class="s0">* Sets an n-dimensional vertex value.  This allows definition of a NURBS</span>
 <span class="s0">* surface or curve in a sparse n-dimensional space, typically used for</span>
 <span class="s0">* associating additional properties (like color or joint membership) with</span>
 <span class="s0">* each vertex of a surface.</span>
 <span class="s0">*</span>
 <span class="s0">* The value d is an arbitrary integer value and specifies the dimension of</span>
 <span class="s0">* question for this particular vertex.  Any number of dimensions may be</span>
 <span class="s0">* specified, and they need not be consecutive.  If a value for a given</span>
 <span class="s0">* dimension is not specified, is it implicitly 0.0.</span>
 <span class="s0">*</span>
 <span class="s0">* The value is implicitly scaled by the homogenous weight value--that is, the</span>
 <span class="s0">* fourth component of the value passed to set_vertex().  This means the</span>
 <span class="s0">* ordinary vertex must be set first, before the extended vertices can be set.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void NurbsCurveEvaluator::set_extended_vertex(int i, int d, PN_stdfloat value);</span>

<span class="s0">420 19 get_extended_vertex 0 4 533 40 NurbsCurveEvaluator::get_extended_vertex 0 1 170 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an n-dimensional vertex value.  See set_extended_vertex().  This</span>
 <span class="s0">* returns the value set for the indicated dimension, or 0.0 if nothing has</span>
 <span class="s0">* been set.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline PN_stdfloat NurbsCurveEvaluator::get_extended_vertex(int i, int d) const;</span>

<span class="s0">421 21 set_extended_vertices 0 4 533 42 NurbsCurveEvaluator::set_extended_vertices 0 1 171 259</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously sets several extended values in the slots d through (d +</span>
 <span class="s0">* num_values - 1) from the num_values elements of the indicated array.  This</span>
 <span class="s0">* is equivalent to calling set_extended_vertex() num_values times.  See</span>
 <span class="s0">* set_extended_vertex().</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">void NurbsCurveEvaluator::set_extended_vertices(int i, int d, PN_stdfloat const values[], int num_values);</span>

<span class="s0">422 13 get_num_knots 0 4 533 34 NurbsCurveEvaluator::get_num_knots 0 1 172 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of knot values in the curve.  This is based on the</span>
 <span class="s0">* number of vertices and the order.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int NurbsCurveEvaluator::get_num_knots(void) const;</span>

<span class="s0">423 8 set_knot 0 4 533 29 NurbsCurveEvaluator::set_knot 0 1 173 184</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the value of the nth knot.  Each knot value should be greater than or</span>
 <span class="s0">* equal to the preceding value.  If no knot values are set, a default knot</span>
 <span class="s0">* vector is supplied.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void NurbsCurveEvaluator::set_knot(int i, PN_stdfloat knot);</span>

<span class="s0">424 8 get_knot 0 4 533 29 NurbsCurveEvaluator::get_knot 0 1 174 45</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value of the nth knot.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">PN_stdfloat NurbsCurveEvaluator::get_knot(int i) const;</span>

<span class="s0">425 15 normalize_knots 0 4 533 36 NurbsCurveEvaluator::normalize_knots 0 1 175 95</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the knot sequence so that the parametric range of the curve is 0</span>
 <span class="s0">* .. 1.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void NurbsCurveEvaluator::normalize_knots(void);</span>

<span class="s0">426 16 get_num_segments 0 4 533 37 NurbsCurveEvaluator::get_num_segments 0 1 176 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of piecewise continuous segments in the curve.  This is</span>
 <span class="s0">* based on the knot vector.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int NurbsCurveEvaluator::get_num_segments(void) const;</span>

<span class="s0">427 8 evaluate 0 4 533 29 NurbsCurveEvaluator::evaluate 0 2 177 178 447</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a NurbsCurveResult object that represents the result of applying</span>
 <span class="s0">* the knots to all of the current values of the vertices, transformed into</span>
 <span class="s0">* the indicated coordinate space.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a NurbsCurveResult object that represents the result of applying</span>
 <span class="s0">* the knots to all of the current values of the vertices, transformed into</span>
 <span class="s0">* the indicated coordinate space, and then further transformed by the</span>
 <span class="s0">* indicated matrix.</span>
 <span class="s0">*/</span>
<span class="s0">215</span>
<span class="s0">PointerTo&lt; NurbsCurveResult &gt; NurbsCurveEvaluator::evaluate(NodePath const &amp;rel_to = NodePath()) const;</span>
<span class="s0">PointerTo&lt; NurbsCurveResult &gt; NurbsCurveEvaluator::evaluate(NodePath const &amp;rel_to, LMatrix4 const &amp;mat) const;</span>

<span class="s0">428 6 output 0 4 533 27 NurbsCurveEvaluator::output 0 1 179 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void NurbsCurveEvaluator::output(std::ostream &amp;out) const;</span>

<span class="s0">429 11 get_start_u 0 4 534 31 NurbsSurfaceResult::get_start_u 0 1 181 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first legal value of u on the surface.  Usually this is 0.0.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline PN_stdfloat NurbsSurfaceResult::get_start_u(void) const;</span>

<span class="s0">430 9 get_end_u 0 4 534 29 NurbsSurfaceResult::get_end_u 0 1 182 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the last legal value of u on the surface.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline PN_stdfloat NurbsSurfaceResult::get_end_u(void) const;</span>

<span class="s0">431 11 get_start_v 0 4 534 31 NurbsSurfaceResult::get_start_v 0 1 183 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first legal value of v on the surface.  Usually this is 0.0.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline PN_stdfloat NurbsSurfaceResult::get_start_v(void) const;</span>

<span class="s0">432 9 get_end_v 0 4 534 29 NurbsSurfaceResult::get_end_v 0 1 184 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the last legal value of v on the surface.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline PN_stdfloat NurbsSurfaceResult::get_end_v(void) const;</span>

<span class="s0">433 10 eval_point 0 4 534 30 NurbsSurfaceResult::eval_point 0 1 185 168</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the point on the surface corresponding to the indicated value in</span>
 <span class="s0">* parametric time.  Returns true if the u, v values are valid, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline bool NurbsSurfaceResult::eval_point(PN_stdfloat u, PN_stdfloat v, LVecBase3 &amp;point);</span>

<span class="s0">434 11 eval_normal 0 4 534 31 NurbsSurfaceResult::eval_normal 0 1 186 193</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the normal to the surface at the indicated point in parametric</span>
 <span class="s0">* time.  This normal vector will not necessarily be normalized, and could be</span>
 <span class="s0">* zero.  See also eval_point().</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline bool NurbsSurfaceResult::eval_normal(PN_stdfloat u, PN_stdfloat v, LVecBase3 &amp;normal);</span>

<span class="s0">435 19 eval_extended_point 0 4 534 39 NurbsSurfaceResult::eval_extended_point 0 1 187 149</span>
<span class="s0">/**</span>
 <span class="s0">* Evaluates the surface in n-dimensional space according to the extended</span>
 <span class="s0">* vertices associated with the surface in the indicated dimension.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline PN_stdfloat NurbsSurfaceResult::eval_extended_point(PN_stdfloat u, PN_stdfloat v, int d);</span>

<span class="s0">436 20 eval_extended_points 0 4 534 40 NurbsSurfaceResult::eval_extended_points 0 1 188 248</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously performs eval_extended_point on a contiguous sequence of</span>
 <span class="s0">* dimensions.  The dimensions evaluated are d through (d + num_values - 1);</span>
 <span class="s0">* the results are filled into the num_values elements in the indicated result</span>
 <span class="s0">* array.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">inline bool NurbsSurfaceResult::eval_extended_points(PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values);</span>

<span class="s0">437 18 get_num_u_segments 0 4 534 38 NurbsSurfaceResult::get_num_u_segments 0 1 189 191</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of piecewise continuous segments within the surface in</span>
 <span class="s0">* the U direction.  This number is usually not important unless you plan to</span>
 <span class="s0">* call eval_segment_point().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int NurbsSurfaceResult::get_num_u_segments(void) const;</span>

<span class="s0">438 18 get_num_v_segments 0 4 534 38 NurbsSurfaceResult::get_num_v_segments 0 1 190 191</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of piecewise continuous segments within the surface in</span>
 <span class="s0">* the V direction.  This number is usually not important unless you plan to</span>
 <span class="s0">* call eval_segment_point().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int NurbsSurfaceResult::get_num_v_segments(void) const;</span>

<span class="s0">439 18 eval_segment_point 0 4 534 38 NurbsSurfaceResult::eval_segment_point 0 1 191 656</span>
<span class="s0">/**</span>
 <span class="s0">* Evaluates the point on the surface corresponding to the indicated value in</span>
 <span class="s0">* parametric time within the indicated surface segment.  u and v should be in</span>
 <span class="s0">* the range [0, 1].</span>
 <span class="s0">*</span>
 <span class="s0">* The surface is internally represented as a number of connected (or possibly</span>
 <span class="s0">* unconnected) piecewise continuous segments.  The exact number of segments</span>
 <span class="s0">* for a particular surface depends on the knot vector, and is returned by</span>
 <span class="s0">* get_num_segments().  Normally, eval_point() is used to evaluate a point</span>
 <span class="s0">* along the continuous surface, but when you care more about local</span>
 <span class="s0">* continuity, you can use eval_segment_point() to evaluate the points along</span>
 <span class="s0">* each segment.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">void NurbsSurfaceResult::eval_segment_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &amp;point) const;</span>

<span class="s0">440 19 eval_segment_normal 0 4 534 39 NurbsSurfaceResult::eval_segment_normal 0 1 192 176</span>
<span class="s0">/**</span>
 <span class="s0">* As eval_segment_point, but computes the normal to the surface at the</span>
 <span class="s0">* indicated point.  The normal vector will not necessarily be normalized, and</span>
 <span class="s0">* could be zero.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">void NurbsSurfaceResult::eval_segment_normal(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &amp;normal) const;</span>

<span class="s0">441 27 eval_segment_extended_point 0 4 534 47 NurbsSurfaceResult::eval_segment_extended_point 0 1 193 149</span>
<span class="s0">/**</span>
 <span class="s0">* Evaluates the surface in n-dimensional space according to the extended</span>
 <span class="s0">* vertices associated with the surface in the indicated dimension.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">PN_stdfloat NurbsSurfaceResult::eval_segment_extended_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d) const;</span>

<span class="s0">442 28 eval_segment_extended_points 0 4 534 48 NurbsSurfaceResult::eval_segment_extended_points 0 1 194 248</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously performs eval_extended_point on a contiguous sequence of</span>
 <span class="s0">* dimensions.  The dimensions evaluated are d through (d + num_values - 1);</span>
 <span class="s0">* the results are filled into the num_values elements in the indicated result</span>
 <span class="s0">* array.</span>
 <span class="s0">*/</span>
<span class="s0">151</span>
<span class="s0">void NurbsSurfaceResult::eval_segment_extended_points(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values) const;</span>

<span class="s0">443 13 get_segment_u 0 4 534 33 NurbsSurfaceResult::get_segment_u 0 1 195 219</span>
<span class="s0">/**</span>
 <span class="s0">* Accepts a u value in the range [0, 1], and assumed to be relative to the</span>
 <span class="s0">* indicated segment (as in eval_segment_point()), and returns the</span>
 <span class="s0">* corresponding u value in the entire surface (as in eval_point()).</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline PN_stdfloat NurbsSurfaceResult::get_segment_u(int ui, PN_stdfloat u) const;</span>

<span class="s0">444 13 get_segment_v 0 4 534 33 NurbsSurfaceResult::get_segment_v 0 1 196 219</span>
<span class="s0">/**</span>
 <span class="s0">* Accepts a v value in the range [0, 1], and assumed to be relative to the</span>
 <span class="s0">* indicated segment (as in eval_segment_point()), and returns the</span>
 <span class="s0">* corresponding v value in the entire surface (as in eval_point()).</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline PN_stdfloat NurbsSurfaceResult::get_segment_v(int vi, PN_stdfloat v) const;</span>

<span class="s0">445 18 NurbsSurfaceResult 0 260 534 38 NurbsSurfaceResult::NurbsSurfaceResult 0 1 180 174</span>
<span class="s0">/**</span>
 <span class="s0">* The constructor automatically builds up the result as the product of the</span>
 <span class="s0">* indicated set of basis matrices and the indicated table of control vertex</span>
 <span class="s0">* positions.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline NurbsSurfaceResult::NurbsSurfaceResult(NurbsSurfaceResult const &amp;) = default;</span>

<span class="s0">446 21 NurbsSurfaceEvaluator 0 260 535 44 NurbsSurfaceEvaluator::NurbsSurfaceEvaluator 0 2 197 198 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(void);</span>
<span class="s0">inline NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(NurbsSurfaceEvaluator const &amp;) = default;</span>

<span class="s0">447 11 set_u_order 0 4 535 34 NurbsSurfaceEvaluator::set_u_order 0 1 199 247</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the order of the surface in the U direction.  This resets the knot</span>
 <span class="s0">* vector to the default knot vector for the number of vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* The order must be 1, 2, 3, or 4, and the value is one more than the degree</span>
 <span class="s0">* of the surface.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void NurbsSurfaceEvaluator::set_u_order(int u_order);</span>

<span class="s0">448 11 get_u_order 0 4 535 34 NurbsSurfaceEvaluator::get_u_order 0 1 200 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the order of the surface in the U direction as set by a previous</span>
 <span class="s0">* call to set_u_order().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int NurbsSurfaceEvaluator::get_u_order(void) const;</span>

<span class="s0">449 11 set_v_order 0 4 535 34 NurbsSurfaceEvaluator::set_v_order 0 1 201 247</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the order of the surface in the V direction.  This resets the knot</span>
 <span class="s0">* vector to the default knot vector for the number of vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* The order must be 1, 2, 3, or 4, and the value is one more than the degree</span>
 <span class="s0">* of the surface.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void NurbsSurfaceEvaluator::set_v_order(int v_order);</span>

<span class="s0">450 11 get_v_order 0 4 535 34 NurbsSurfaceEvaluator::get_v_order 0 1 202 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the order of the surface in the V direction as set by a previous</span>
 <span class="s0">* call to set_v_order().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int NurbsSurfaceEvaluator::get_v_order(void) const;</span>

<span class="s0">451 5 reset 0 4 535 28 NurbsSurfaceEvaluator::reset 0 1 203 233</span>
<span class="s0">/**</span>
 <span class="s0">* Resets all the vertices and knots to their default values, and sets the</span>
 <span class="s0">* surface up with the indicated number of vertices.  You must then call</span>
 <span class="s0">* set_vertex() repeatedly to fill in all of the vertex values appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void NurbsSurfaceEvaluator::reset(int num_u_vertices, int num_v_vertices);</span>

<span class="s0">452 18 get_num_u_vertices 0 4 535 41 NurbsSurfaceEvaluator::get_num_u_vertices 0 1 204 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of control vertices in the U direction on the surface.</span>
 <span class="s0">* This is the number passed to the last call to reset().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int NurbsSurfaceEvaluator::get_num_u_vertices(void) const;</span>

<span class="s0">453 18 get_num_v_vertices 0 4 535 41 NurbsSurfaceEvaluator::get_num_v_vertices 0 1 205 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of control vertices in the V direction on the surface.</span>
 <span class="s0">* This is the number passed to the last call to reset().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int NurbsSurfaceEvaluator::get_num_v_vertices(void) const;</span>

<span class="s0">454 10 set_vertex 0 4 535 33 NurbsSurfaceEvaluator::set_vertex 0 2 206 207 445</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth control vertex of the surface, as a vertex in 4-d homogeneous</span>
 <span class="s0">* space.  In this form, the first three components of the vertex should</span>
 <span class="s0">* already have been scaled by the fourth component, which is the homogeneous</span>
 <span class="s0">* weight.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the nth control vertex of the surface.  This flavor sets the vertex as</span>
 <span class="s0">* a 3-d coordinate and a weight; the 3-d coordinate values are implicitly</span>
 <span class="s0">* scaled up by the weight factor.</span>
 <span class="s0">*/</span>
<span class="s0">201</span>
<span class="s0">inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4 const &amp;vertex);</span>
<span class="s0">inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3 const &amp;vertex, PN_stdfloat weight = 1.0);</span>

<span class="s0">455 10 get_vertex 0 4 535 33 NurbsSurfaceEvaluator::get_vertex 0 2 208 209 206</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth control vertex of the surface, relative to its indicated</span>
 <span class="s0">* coordinate space.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the nth control vertex of the surface, relative to the given</span>
 <span class="s0">* coordinate space.</span>
 <span class="s0">*/</span>
<span class="s0">178</span>
<span class="s0">inline LVecBase4 const &amp;NurbsSurfaceEvaluator::get_vertex(int ui, int vi) const;</span>
<span class="s0">inline LVecBase4 NurbsSurfaceEvaluator::get_vertex(int ui, int vi, NodePath const &amp;rel_to) const;</span>

<span class="s0">456 16 set_vertex_space 0 4 535 39 NurbsSurfaceEvaluator::set_vertex_space 0 2 210 211 796</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the coordinate space of the nth control vertex.  If this is not</span>
 <span class="s0">* specified, or is set to an empty NodePath, the nth control vertex is deemed</span>
 <span class="s0">* to be in the coordinate space passed to evaluate().</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the space as a fixed NodePath, which is always the same</span>
 <span class="s0">* NodePath.  Also see setting the space as a path string, which can specify a</span>
 <span class="s0">* different NodePath for different instances of the surface.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the coordinate space of the nth control vertex.  If this is not</span>
 <span class="s0">* specified, or is set to an empty string, the nth control vertex is deemed</span>
 <span class="s0">* to be in the coordinate space passed to evaluate().</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the space as a string, which describes the path to find the</span>
 <span class="s0">* node relative to the rel_to NodePath when the surface is evaluated.</span>
 <span class="s0">*/</span>
<span class="s0">186</span>
<span class="s0">inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &amp;space);</span>
<span class="s0">inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, std::string const &amp;space);</span>

<span class="s0">457 16 get_vertex_space 0 4 535 39 NurbsSurfaceEvaluator::get_vertex_space 0 1 212 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the coordinate space of the nth control vertex of the surface,</span>
 <span class="s0">* expressed as a NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">NodePath NurbsSurfaceEvaluator::get_vertex_space(int ui, int vi, NodePath const &amp;rel_to) const;</span>

<span class="s0">458 19 set_extended_vertex 0 4 535 42 NurbsSurfaceEvaluator::set_extended_vertex 0 1 213 770</span>
<span class="s0">/**</span>
 <span class="s0">* Sets an n-dimensional vertex value.  This allows definition of a NURBS</span>
 <span class="s0">* surface or surface in a sparse n-dimensional space, typically used for</span>
 <span class="s0">* associating additional properties (like color or joint membership) with</span>
 <span class="s0">* each vertex of a surface.</span>
 <span class="s0">*</span>
 <span class="s0">* The value d is an arbitrary integer value and specifies the dimension of</span>
 <span class="s0">* question for this particular vertex.  Any number of dimensions may be</span>
 <span class="s0">* specified, and they need not be consecutive.  If a value for a given</span>
 <span class="s0">* dimension is not specified, is it implicitly 0.0.</span>
 <span class="s0">*</span>
 <span class="s0">* The value is implicitly scaled by the homogenous weight value--that is, the</span>
 <span class="s0">* fourth component of the value passed to set_vertex().  This means the</span>
 <span class="s0">* ordinary vertex must be set first, before the extended vertices can be set.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">inline void NurbsSurfaceEvaluator::set_extended_vertex(int ui, int vi, int d, PN_stdfloat value);</span>

<span class="s0">459 19 get_extended_vertex 0 4 535 42 NurbsSurfaceEvaluator::get_extended_vertex 0 1 214 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an n-dimensional vertex value.  See set_extended_vertex().  This</span>
 <span class="s0">* returns the value set for the indicated dimension, or 0.0 if nothing has</span>
 <span class="s0">* been set.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline PN_stdfloat NurbsSurfaceEvaluator::get_extended_vertex(int ui, int vi, int d) const;</span>

<span class="s0">460 21 set_extended_vertices 0 4 535 44 NurbsSurfaceEvaluator::set_extended_vertices 0 1 215 259</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously sets several extended values in the slots d through (d +</span>
 <span class="s0">* num_values - 1) from the num_values elements of the indicated array.  This</span>
 <span class="s0">* is equivalent to calling set_extended_vertex() num_values times.  See</span>
 <span class="s0">* set_extended_vertex().</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">void NurbsSurfaceEvaluator::set_extended_vertices(int ui, int vi, int d, PN_stdfloat const values[], int num_values);</span>

<span class="s0">461 15 get_num_u_knots 0 4 535 38 NurbsSurfaceEvaluator::get_num_u_knots 0 1 216 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of knot values in the surface in the U direction.  This</span>
 <span class="s0">* is based on the number of vertices and the order.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int NurbsSurfaceEvaluator::get_num_u_knots(void) const;</span>

<span class="s0">462 10 set_u_knot 0 4 535 33 NurbsSurfaceEvaluator::set_u_knot 0 1 217 184</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the value of the nth knot.  Each knot value should be greater than or</span>
 <span class="s0">* equal to the preceding value.  If no knot values are set, a default knot</span>
 <span class="s0">* vector is supplied.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void NurbsSurfaceEvaluator::set_u_knot(int i, PN_stdfloat knot);</span>

<span class="s0">463 10 get_u_knot 0 4 535 33 NurbsSurfaceEvaluator::get_u_knot 0 1 218 45</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value of the nth knot.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">PN_stdfloat NurbsSurfaceEvaluator::get_u_knot(int i) const;</span>

<span class="s0">464 17 normalize_u_knots 0 4 535 40 NurbsSurfaceEvaluator::normalize_u_knots 0 1 219 116</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the knot sequence so that the parametric range of the surface in</span>
 <span class="s0">* the U direction is 0 .. 1.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void NurbsSurfaceEvaluator::normalize_u_knots(void);</span>

<span class="s0">465 15 get_num_v_knots 0 4 535 38 NurbsSurfaceEvaluator::get_num_v_knots 0 1 220 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of knot values in the surface in the V direction.  This</span>
 <span class="s0">* is based on the number of vertices and the order.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int NurbsSurfaceEvaluator::get_num_v_knots(void) const;</span>

<span class="s0">466 10 set_v_knot 0 4 535 33 NurbsSurfaceEvaluator::set_v_knot 0 1 221 184</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the value of the nth knot.  Each knot value should be greater than or</span>
 <span class="s0">* equal to the preceding value.  If no knot values are set, a default knot</span>
 <span class="s0">* vector is supplied.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void NurbsSurfaceEvaluator::set_v_knot(int i, PN_stdfloat knot);</span>

<span class="s0">467 10 get_v_knot 0 4 535 33 NurbsSurfaceEvaluator::get_v_knot 0 1 222 45</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value of the nth knot.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">PN_stdfloat NurbsSurfaceEvaluator::get_v_knot(int i) const;</span>

<span class="s0">468 17 normalize_v_knots 0 4 535 40 NurbsSurfaceEvaluator::normalize_v_knots 0 1 223 116</span>
<span class="s0">/**</span>
 <span class="s0">* Normalizes the knot sequence so that the parametric range of the surface in</span>
 <span class="s0">* the U direction is 0 .. 1.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void NurbsSurfaceEvaluator::normalize_v_knots(void);</span>

<span class="s0">469 18 get_num_u_segments 0 4 535 41 NurbsSurfaceEvaluator::get_num_u_segments 0 1 224 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of piecewise continuous segments in the surface in the U</span>
 <span class="s0">* direction.  This is based on the knot vector.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int NurbsSurfaceEvaluator::get_num_u_segments(void) const;</span>

<span class="s0">470 18 get_num_v_segments 0 4 535 41 NurbsSurfaceEvaluator::get_num_v_segments 0 1 225 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of piecewise continuous segments in the surface in the V</span>
 <span class="s0">* direction.  This is based on the knot vector.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int NurbsSurfaceEvaluator::get_num_v_segments(void) const;</span>

<span class="s0">471 8 evaluate 0 4 535 31 NurbsSurfaceEvaluator::evaluate 0 1 226 196</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a NurbsSurfaceResult object that represents the result of applying</span>
 <span class="s0">* the knots to all of the current values of the vertices, transformed into</span>
 <span class="s0">* the indicated coordinate space.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">PointerTo&lt; NurbsSurfaceResult &gt; NurbsSurfaceEvaluator::evaluate(NodePath const &amp;rel_to = NodePath()) const;</span>

<span class="s0">472 6 output 0 4 535 29 NurbsSurfaceEvaluator::output 0 1 227 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void NurbsSurfaceEvaluator::output(std::ostream &amp;out) const;</span>

<span class="s0">473 8 RopeNode 0 260 537 18 RopeNode::RopeNode 0 1 228 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">explicit RopeNode::RopeNode(std::string const &amp;name);</span>

<span class="s0">474 9 set_curve 0 4 537 19 RopeNode::set_curve 0 1 229 65</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the particular curve represented by the RopeNode.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void RopeNode::set_curve(NurbsCurveEvaluator *curve);</span>

<span class="s0">475 9 get_curve 0 4 537 19 RopeNode::get_curve 0 1 230 57</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the curve represented by the RopeNode.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline NurbsCurveEvaluator *RopeNode::get_curve(void) const;</span>

<span class="s0">476 15 set_render_mode 0 4 537 25 RopeNode::set_render_mode 0 1 231 130</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the method used to render the rope.  The simplest is RM_thread,</span>
 <span class="s0">* which just draws a one-pixel line segment.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode);</span>

<span class="s0">477 15 get_render_mode 0 4 537 25 RopeNode::get_render_mode 0 1 232 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the method used to render the rope.  See set_render_mode().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline RopeNode::RenderMode RopeNode::get_render_mode(void) const;</span>

<span class="s0">478 11 set_uv_mode 0 4 537 21 RopeNode::set_uv_mode 0 1 233 72</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the algorithm to use to generate UV's for the rope.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode);</span>

<span class="s0">479 11 get_uv_mode 0 4 537 21 RopeNode::get_uv_mode 0 1 234 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the algorithm to use to generate UV's for the rope.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline RopeNode::UVMode RopeNode::get_uv_mode(void) const;</span>

<span class="s0">480 16 set_uv_direction 0 4 537 26 RopeNode::set_uv_direction 0 1 235 115</span>
<span class="s0">/**</span>
 <span class="s0">* Specify true to vary the U coordinate down the length of the rope, or false</span>
 <span class="s0">* to vary the V coordinate.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void RopeNode::set_uv_direction(bool u_dominant);</span>

<span class="s0">481 16 get_uv_direction 0 4 537 26 RopeNode::get_uv_direction 0 1 236 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the rope runs down the U coordinate of the texture, or</span>
 <span class="s0">* false if it runs down the V coordinate.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool RopeNode::get_uv_direction(void) const;</span>

<span class="s0">482 12 set_uv_scale 0 4 537 22 RopeNode::set_uv_scale 0 1 237 206</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies an additional scaling factor to apply to generated UV's along the</span>
 <span class="s0">* rope.  This scale factor is applied in whichever direction is along the</span>
 <span class="s0">* rope, as specified by set_uv_direction().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void RopeNode::set_uv_scale(PN_stdfloat scale);</span>

<span class="s0">483 12 get_uv_scale 0 4 537 22 RopeNode::get_uv_scale 0 1 238 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scaling factor to apply to generated UV's for the rope.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PN_stdfloat RopeNode::get_uv_scale(void) const;</span>

<span class="s0">484 15 set_normal_mode 0 4 537 25 RopeNode::set_normal_mode 0 1 239 192</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the kind of normals to generate for the rope.  This is only</span>
 <span class="s0">* applicable when the RenderMode is set to RM_tube; in the other render</span>
 <span class="s0">* modes, normals are never generated.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode);</span>

<span class="s0">485 15 get_normal_mode 0 4 537 25 RopeNode::get_normal_mode 0 1 240 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the kind of normals to generate for the rope.  This is only</span>
 <span class="s0">* applicable when the RenderMode is set to RM_tube.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const;</span>

<span class="s0">486 11 set_tube_up 0 4 537 21 RopeNode::set_tube_up 0 1 241 419</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a normal vector, generally perpendicular to the main axis of the</span>
 <span class="s0">* starting point of the curve, that controls the &quot;top&quot; of the curve, when</span>
 <span class="s0">* RenderMode is RM_tube.  This is used to orient the vertices that make up</span>
 <span class="s0">* the tube.  If this vector is too nearly parallel with the starting</span>
 <span class="s0">* direction of the curve, there may be a tendency for the whole tube to</span>
 <span class="s0">* gimble-lock around its primary axis.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void RopeNode::set_tube_up(LVector3 const &amp;tube_up);</span>

<span class="s0">487 11 get_tube_up 0 4 537 21 RopeNode::get_tube_up 0 1 242 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the normal vector used to control the &quot;top&quot; of the curve, when</span>
 <span class="s0">* RenderMode is RM_tube.  See set_tube_up().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline LVector3 const &amp;RopeNode::get_tube_up(void) const;</span>

<span class="s0">488 20 set_use_vertex_color 0 4 537 30 RopeNode::set_use_vertex_color 0 1 243 351</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;use vertex color&quot; flag.  When this is true, the R, G, B, A vertex</span>
 <span class="s0">* color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,</span>
 <span class="s0">* respectively, of the extended vertex values, where n is the value returned</span>
 <span class="s0">* by get_vertex_color_dimension().  Use</span>
 <span class="s0">* NurbsCurveEvaluator::set_extended_vertex() to set these values.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void RopeNode::set_use_vertex_color(bool flag);</span>

<span class="s0">489 20 get_use_vertex_color 0 4 537 30 RopeNode::get_use_vertex_color 0 1 244 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;use vertex color&quot; flag.  See set_use_vertex_color().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool RopeNode::get_use_vertex_color(void) const;</span>

<span class="s0">490 26 get_vertex_color_dimension 0 4 537 36 RopeNode::get_vertex_color_dimension 0 1 245 221</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the numeric extended dimension in which the color components should</span>
 <span class="s0">* be found.  See NurbsCurveEvaluator::set_extended_vertex().</span>
 <span class="s0">*</span>
 <span class="s0">* The color components will be expected at (n, n + 1, n + 2, n + 3).</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">static inline int RopeNode::get_vertex_color_dimension(void);</span>

<span class="s0">491 14 set_num_subdiv 0 4 537 24 RopeNode::set_num_subdiv 0 1 246 154</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of subdivisions per cubic segment (that is, per unique</span>
 <span class="s0">* knot value) to draw in a fixed uniform tesselation of the curve.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void RopeNode::set_num_subdiv(int num_subdiv);</span>

<span class="s0">492 14 get_num_subdiv 0 4 537 24 RopeNode::get_num_subdiv 0 1 247 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of subdivisions per cubic segment to draw.  See</span>
 <span class="s0">* set_num_subdiv().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int RopeNode::get_num_subdiv(void) const;</span>

<span class="s0">493 14 set_num_slices 0 4 537 24 RopeNode::set_num_slices 0 1 248 404</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of radial subdivisions to make if RenderMode is</span>
 <span class="s0">* RM_tube.  It is ignored in the other render modes.</span>
 <span class="s0">*</span>
 <span class="s0">* Increasing this number increases the roundness of a cross-section of the</span>
 <span class="s0">* tube.  The minimum value for a dimensional tube is 3; setting it to 2 will</span>
 <span class="s0">* get you a thin piece of tape (which is similar to RM_billboard, except it</span>
 <span class="s0">* won't rotate to face the camera).</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void RopeNode::set_num_slices(int num_slices);</span>

<span class="s0">494 14 get_num_slices 0 4 537 24 RopeNode::get_num_slices 0 1 249 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of radial subdivisions to make if RenderMode is RM_tube.</span>
 <span class="s0">* It is ignored in the other render modes.  See set_num_slices().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int RopeNode::get_num_slices(void) const;</span>

<span class="s0">495 24 set_use_vertex_thickness 0 4 537 34 RopeNode::set_use_vertex_thickness 0 1 250 418</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;use vertex thickness&quot; flag.  When this is true, the vertex</span>
 <span class="s0">* thickness is assumed to be stored as the dimension</span>
 <span class="s0">* get_vertex_thickness_dimension(), of the extended vertex values.  Use</span>
 <span class="s0">* NurbsCurveEvaluator::set_extended_vertex() to set these values.</span>
 <span class="s0">*</span>
 <span class="s0">* In this mode, the overall thickness is also applied as a scale to the</span>
 <span class="s0">* vertex thickness.  Not all render modes support vertex thickness.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void RopeNode::set_use_vertex_thickness(bool flag);</span>

<span class="s0">496 24 get_use_vertex_thickness 0 4 537 34 RopeNode::get_use_vertex_thickness 0 1 251 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;use vertex thickness&quot; flag.  See set_use_vertex_thickness().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool RopeNode::get_use_vertex_thickness(void) const;</span>

<span class="s0">497 30 get_vertex_thickness_dimension 0 4 537 40 RopeNode::get_vertex_thickness_dimension 0 1 252 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the numeric extended dimension in which the thickness component</span>
 <span class="s0">* should be found.  See NurbsCurveEvaluator::set_extended_vertex().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">static inline int RopeNode::get_vertex_thickness_dimension(void);</span>

<span class="s0">498 13 set_thickness 0 4 537 23 RopeNode::set_thickness 0 1 253 236</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the thickness of the rope, in pixels or in spatial units,</span>
 <span class="s0">* depending on the render mode.  See set_render_mode().</span>
 <span class="s0">*</span>
 <span class="s0">* The thickness may also be specified on a per-vertex basis.  See</span>
 <span class="s0">* set_use_vertex_thickness().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void RopeNode::set_thickness(PN_stdfloat thickness);</span>

<span class="s0">499 13 get_thickness 0 4 537 23 RopeNode::get_thickness 0 1 254 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the thickness of the rope.  See set_thickness().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PN_stdfloat RopeNode::get_thickness(void) const;</span>

<span class="s0">500 10 set_matrix 0 4 537 20 RopeNode::set_matrix 0 1 255 207</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies an optional matrix which is used to transform each control vertex</span>
 <span class="s0">* after it has been transformed into the RopeNode's coordinate space, but</span>
 <span class="s0">* before the polygon vertices are generated.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void RopeNode::set_matrix(LMatrix4 const &amp;matrix);</span>

<span class="s0">501 12 clear_matrix 0 4 537 22 RopeNode::clear_matrix 0 1 256 67</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the node's matrix to identity.  See set_matrix().</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void RopeNode::clear_matrix(void);</span>

<span class="s0">502 10 has_matrix 0 4 537 20 RopeNode::has_matrix 0 1 257 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the node has a matrix set, false otherwise.  See</span>
 <span class="s0">* set_matrix().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool RopeNode::has_matrix(void) const;</span>

<span class="s0">503 10 get_matrix 0 4 537 20 RopeNode::get_matrix 0 1 258 206</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the optional matrix which is used to transform each control vertex</span>
 <span class="s0">* after it has been transformed into the RopeNode's coordinate space, but</span>
 <span class="s0">* before the polygon vertices are generated.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LMatrix4 const &amp;RopeNode::get_matrix(void) const;</span>

<span class="s0">504 11 reset_bound 0 4 537 21 RopeNode::reset_bound 0 1 259 206</span>
<span class="s0">/**</span>
 <span class="s0">* Recomputes the bounding volume.  This is normally called automatically, but</span>
 <span class="s0">* it must occasionally be called explicitly when the curve has changed</span>
 <span class="s0">* properties outside of this node's knowledge.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void RopeNode::reset_bound(NodePath const &amp;rel_to);</span>

<span class="s0">505 14 get_class_type 0 4 537 24 RopeNode::get_class_type 0 1 260 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle RopeNode::get_class_type(void);</span>

<span class="s0">506 9 ~RopeNode 0 516 537 19 RopeNode::~RopeNode 0 0 0</span>
<span class="s0">26</span>
<span class="s0">RopeNode::~RopeNode(void);</span>

<span class="s0">507 9 SheetNode 0 260 549 20 SheetNode::SheetNode 0 1 261 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">explicit SheetNode::SheetNode(std::string const &amp;name);</span>

<span class="s0">508 11 set_surface 0 4 549 22 SheetNode::set_surface 0 1 262 68</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the particular surface represented by the SheetNode.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void SheetNode::set_surface(NurbsSurfaceEvaluator *surface);</span>

<span class="s0">509 11 get_surface 0 4 549 22 SheetNode::get_surface 0 1 263 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the surface represented by the SheetNode.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline NurbsSurfaceEvaluator *SheetNode::get_surface(void) const;</span>

<span class="s0">510 20 set_use_vertex_color 0 4 549 31 SheetNode::set_use_vertex_color 0 1 264 269</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;use vertex color&quot; flag.  When this is true, the R, G, B, A vertex</span>
 <span class="s0">* color is assumed to be stored as the dimensions 0, 1, 2, 3, respectively,</span>
 <span class="s0">* of the extended vertex values.  Use</span>
 <span class="s0">* NurbsCurveEvaluator::set_extended_vertex() to set these values.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void SheetNode::set_use_vertex_color(bool flag);</span>

<span class="s0">511 20 get_use_vertex_color 0 4 549 31 SheetNode::get_use_vertex_color 0 1 265 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;use vertex color&quot; flag.  See set_use_vertex_color().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool SheetNode::get_use_vertex_color(void) const;</span>

<span class="s0">512 16 set_num_u_subdiv 0 4 549 27 SheetNode::set_num_u_subdiv 0 1 266 178</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of subdivisions per cubic segment (that is, per unique</span>
 <span class="s0">* knot value) to draw in a fixed uniform tesselation of the surface in the U</span>
 <span class="s0">* direction.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void SheetNode::set_num_u_subdiv(int num_u_subdiv);</span>

<span class="s0">513 16 get_num_u_subdiv 0 4 549 27 SheetNode::get_num_u_subdiv 0 1 267 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of subdivisions per cubic segment to draw in the U</span>
 <span class="s0">* direction.  See set_num_u_subdiv().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int SheetNode::get_num_u_subdiv(void) const;</span>

<span class="s0">514 16 set_num_v_subdiv 0 4 549 27 SheetNode::set_num_v_subdiv 0 1 268 178</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of subdivisions per cubic segment (that is, per unique</span>
 <span class="s0">* knot value) to draw in a fixed uniform tesselation of the surface in the V</span>
 <span class="s0">* direction.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void SheetNode::set_num_v_subdiv(int num_v_subdiv);</span>

<span class="s0">515 16 get_num_v_subdiv 0 4 549 27 SheetNode::get_num_v_subdiv 0 1 269 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of subdivisions per cubic segment to draw in the V</span>
 <span class="s0">* direction.  See set_num_v_subdiv().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int SheetNode::get_num_v_subdiv(void) const;</span>

<span class="s0">516 11 reset_bound 0 4 549 22 SheetNode::reset_bound 0 1 270 208</span>
<span class="s0">/**</span>
 <span class="s0">* Recomputes the bounding volume.  This is normally called automatically, but</span>
 <span class="s0">* it must occasionally be called explicitly when the surface has changed</span>
 <span class="s0">* properties outside of this node's knowledge.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void SheetNode::reset_bound(NodePath const &amp;rel_to);</span>

<span class="s0">517 14 get_class_type 0 4 549 25 SheetNode::get_class_type 0 1 271 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle SheetNode::get_class_type(void);</span>

<span class="s0">518 10 ~SheetNode 0 516 549 21 SheetNode::~SheetNode 0 0 0</span>
<span class="s0">28</span>
<span class="s0">SheetNode::~SheetNode(void);</span>

<span class="s0">271</span>
<span class="s0">1 0 0 6 3 542 0 0 164 /**</span>
 <span class="s0">* Returns true if the curve is defined.  This base class function always</span>
 <span class="s0">* returns true; derived classes might override this to sometimes return</span>
 <span class="s0">* false.</span>
 <span class="s0">*/ 1 4 this 3 550  </span>
<span class="s0">2 0 0 6 4 525 0 0 237 /**</span>
 <span class="s0">* Returns the upper bound of t for the entire curve.  The curve is defined in</span>
 <span class="s0">* the range 0.0f &lt;= t &lt;= get_max_t().  This base class function always</span>
 <span class="s0">* returns 1.0f; derived classes might override this to return something else.</span>
 <span class="s0">*/ 1 4 this 3 550  </span>
<span class="s0">3 0 0 4 5 552 0 0 389 /**</span>
 <span class="s0">* Sets the flag indicating the use to which the curve is intended to be put.</span>
 <span class="s0">* This flag is optional and only serves to provide a hint to the egg reader</span>
 <span class="s0">* and writer code; it has no effect on the curve's behavior.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting the curve type also sets the num_dimensions to 3 or 1 according to</span>
 <span class="s0">* the type.</span>
 <span class="s0">*</span>
 <span class="s0">* THis flag may have one of the values PCT_XYZ, PCT_HPR, or PCT_T.</span>
 <span class="s0">*/ 2 4 this 3 524  4 type 1 536  </span>
<span class="s0">4 0 0 6 6 536 0 0 91 /**</span>
 <span class="s0">* Returns the flag indicating the use to which the curve is intended to be</span>
 <span class="s0">* put.</span>
 <span class="s0">*/ 1 4 this 3 550  </span>
<span class="s0">5 0 0 4 7 552 0 0 324 /**</span>
 <span class="s0">* Specifies the number of significant dimensions in the curve's vertices.</span>
 <span class="s0">* This should be one of 1, 2, or 3. Normally, XYZ and HPR curves have three</span>
 <span class="s0">* dimensions; time curves should always have one dimension.  This only serves</span>
 <span class="s0">* as a hint to the mopath editor, and also controls how the curve is written</span>
 <span class="s0">* out.</span>
 <span class="s0">*/ 2 4 this 3 524  3 num 1 536  </span>
<span class="s0">6 0 0 6 8 536 0 0 267 /**</span>
 <span class="s0">* Returns the number of significant dimensions in the curve's vertices, as</span>
 <span class="s0">* set by a previous call to set_num_dimensions().  This is only a hint as to</span>
 <span class="s0">* how the curve is intended to be used; the actual number of dimensions of</span>
 <span class="s0">* any curve is always three.</span>
 <span class="s0">*/ 1 4 this 3 550  </span>
<span class="s0">7 0 0 6 9 525 0 0 86 /**</span>
 <span class="s0">* Approximates the length of the entire curve to within a few decimal places.</span>
 <span class="s0">*/ 1 4 this 3 550  </span>
<span class="s0">8 0 0 6 9 525 0 0 100 /**</span>
 <span class="s0">* Approximates the length of the curve segment from parametric time 'from' to</span>
 <span class="s0">* time 'to'.</span>
 <span class="s0">*/ 3 4 this 3 550  4 from 1 525  2 to 1 525  </span>
<span class="s0">9 0 0 6 10 525 0 0 396 /**</span>
 <span class="s0">* Returns the parametric value corresponding to the indicated distance along</span>
 <span class="s0">* the curve from the starting parametric value.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the inverse of calc_length(): rather than determining the length</span>
 <span class="s0">* along the curve between two parametric points, it determines the position</span>
 <span class="s0">* in parametric time of a point n units along the curve.</span>
 <span class="s0">*</span>
 <span class="s0">* The search distance must not be negative.</span>
 <span class="s0">*/ 3 4 this 3 550  7 start_t 1 525  13 length_offset 1 525  </span>
<span class="s0">10 0 0 6 11 542 0 0 0 3 4 this 3 550  1 t 1 525  5 point 1 553  </span>
<span class="s0">11 0 0 6 12 542 0 0 0 3 4 this 3 550  1 t 1 525  7 tangent 1 553  </span>
<span class="s0">12 0 0 6 13 542 0 0 0 4 4 this 3 550  1 t 1 525  5 point 1 553  7 tangent 1 553  </span>
<span class="s0">13 0 0 6 14 542 0 0 0 3 4 this 3 550  1 t 1 525  8 tangent2 1 553  </span>
<span class="s0">14 0 0 6 15 542 0 0 144 /**</span>
 <span class="s0">* Recomputes the curve such that it passes through the point (px, py, pz) at</span>
 <span class="s0">* time t, but keeps the same tangent value at that point.</span>
 <span class="s0">*/ 5 4 this 3 524  1 t 1 525  2 px 1 525  2 py 1 525  2 pz 1 525  </span>
<span class="s0">15 0 0 6 16 542 0 0 129 /**</span>
 <span class="s0">* Recomputes the curve such that it has the tangent (tx, ty, tz) at time t,</span>
 <span class="s0">* but keeps the same position at the point.</span>
 <span class="s0">*/ 5 4 this 3 524  1 t 1 525  2 tx 1 525  2 ty 1 525  2 tz 1 525  </span>
<span class="s0">16 0 0 6 17 542 0 0 116 /**</span>
 <span class="s0">* Recomputes the curve such that it passes through the point (px, py, pz)</span>
 <span class="s0">* with the tangent (tx, ty, tz).</span>
 <span class="s0">*/ 8 4 this 3 524  1 t 1 525  2 px 1 525  2 py 1 525  2 pz 1 525  2 tx 1 525  2 ty 1 525  2 tz 1 525  </span>
<span class="s0">17 0 0 6 18 542 0 0 115 /**</span>
 <span class="s0">* Recalculates the curve, if necessary.  Returns true if the resulting curve</span>
 <span class="s0">* is valid, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 524  </span>
<span class="s0">18 0 0 6 19 542 0 0 259 /**</span>
 <span class="s0">* Regenerates this curve as one long curve: the first curve connected end-to-</span>
 <span class="s0">* end with the second one.  Either a or b may be the same as 'this'.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false on failure or if the curve type does not</span>
 <span class="s0">* support stitching.</span>
 <span class="s0">*/ 3 4 this 3 524  1 a 1 550  1 b 1 550  </span>
<span class="s0">19 0 0 6 20 542 0 0 138 /**</span>
 <span class="s0">* Writes an egg description of the nurbs curve to the specified output file.</span>
 <span class="s0">* Returns true if the file is successfully written.</span>
 <span class="s0">*/ 3 4 this 3 524  8 filename 1 556  2 cs 5 558  </span>
<span class="s0">20 0 0 6 20 542 0 0 141 /**</span>
 <span class="s0">* Writes an egg description of the nurbs curve to the specified output</span>
 <span class="s0">* stream.  Returns true if the file is successfully written.</span>
 <span class="s0">*/ 4 4 this 3 524  3 out 1 559  8 filename 1 561  2 cs 1 558  </span>
<span class="s0">21 0 0 7 21 564 0 0 0 0 </span>
<span class="s0">22 0 0 7 23 564 0 0 0 0 </span>
<span class="s0">23 0 0 7 26 565 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">24 0 0 15 26 565 0 0 0 1 6 param0 0 566  </span>
<span class="s0">25 0 0 4 27 552 0 0 56 /**</span>
 <span class="s0">* Adds a new ParametricCurve to the collection.</span>
 <span class="s0">*/ 2 4 this 3 565  5 curve 1 524  </span>
<span class="s0">26 0 0 4 27 552 0 0 134 /**</span>
 <span class="s0">* Adds a new ParametricCurve to the collection at the indicated index.</span>
 <span class="s0">* @deprecated Use insert_curve(index, curve) instead.</span>
 <span class="s0">*/ 3 4 this 3 565  5 curve 1 524  5 index 1 536  </span>
<span class="s0">27 0 0 4 28 552 0 0 79 /**</span>
 <span class="s0">* Adds a new ParametricCurve to the collection at the indicated index.</span>
 <span class="s0">*/ 3 4 this 3 565  5 index 1 568  5 curve 1 524  </span>
<span class="s0">28 0 0 6 29 536 0 0 120 /**</span>
 <span class="s0">* Adds all the curves found in the scene graph rooted at the given node.</span>
 <span class="s0">* Returns the number of curves found.</span>
 <span class="s0">*/ 2 4 this 3 565  4 node 1 570  </span>
<span class="s0">29 0 0 6 30 542 0 0 160 /**</span>
 <span class="s0">* Removes the indicated ParametricCurve from the collection.  Returns true if</span>
 <span class="s0">* the curve was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/ 2 4 this 3 565  5 curve 1 524  </span>
<span class="s0">30 0 0 4 30 552 0 0 93 /**</span>
 <span class="s0">* Removes the indicated ParametricCurve from the collection, by its index</span>
 <span class="s0">* number.</span>
 <span class="s0">*/ 2 4 this 3 565  5 index 1 568  </span>
<span class="s0">31 0 0 4 31 552 0 0 94 /**</span>
 <span class="s0">* Replaces the indicated ParametricCurve from the collection, by its index</span>
 <span class="s0">* number.</span>
 <span class="s0">*/ 3 4 this 3 565  5 index 1 568  5 curve 1 524  </span>
<span class="s0">32 0 0 6 32 542 0 0 104 /**</span>
 <span class="s0">* Returns true if the indicated ParametricCurve appears in this collection,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 566  5 curve 1 524  </span>
<span class="s0">33 0 0 4 33 552 0 0 60 /**</span>
 <span class="s0">* Removes all ParametricCurves from the collection.</span>
 <span class="s0">*/ 1 4 this 3 565  </span>
<span class="s0">34 0 0 4 34 552 0 0 63 /**</span>
 <span class="s0">* Removes all the timewarp curves from the collection.</span>
 <span class="s0">*/ 1 4 this 3 565  </span>
<span class="s0">35 0 0 6 35 536 0 0 68 /**</span>
 <span class="s0">* Returns the number of ParametricCurves in the collection.</span>
 <span class="s0">*/ 1 4 this 3 566  </span>
<span class="s0">36 0 0 7 36 524 0 0 61 /**</span>
 <span class="s0">* Returns the nth ParametricCurve in the collection.</span>
 <span class="s0">*/ 2 4 this 3 566  5 index 1 536  </span>
<span class="s0">37 0 0 7 38 524 0 0 95 /**</span>
 <span class="s0">* Returns the first XYZ curve in the collection, if any, or NULL if there are</span>
 <span class="s0">* none.</span>
 <span class="s0">*/ 1 4 this 3 566  </span>
<span class="s0">38 0 0 7 39 524 0 0 95 /**</span>
 <span class="s0">* Returns the first HPR curve in the collection, if any, or NULL if there are</span>
 <span class="s0">* none.</span>
 <span class="s0">*/ 1 4 this 3 566  </span>
<span class="s0">39 0 0 7 40 524 0 0 180 /**</span>
 <span class="s0">* If there is an XYZ curve in the collection, returns it; otherwise, returns</span>
 <span class="s0">* the first curve whose type is unspecified.  Returns NULL if no curve meets</span>
 <span class="s0">* the criteria.</span>
 <span class="s0">*/ 1 4 this 3 566  </span>
<span class="s0">40 0 0 6 41 536 0 0 67 /**</span>
 <span class="s0">* Returns the number of timewarp curves in the collection.</span>
 <span class="s0">*/ 1 4 this 3 566  </span>
<span class="s0">41 0 0 7 42 524 0 0 60 /**</span>
 <span class="s0">* Returns the nth timewarp curve in the collection.</span>
 <span class="s0">*/ 2 4 this 3 566  1 n 1 536  </span>
<span class="s0">42 0 0 6 44 525 0 0 170 /**</span>
 <span class="s0">* Returns the maximum T value associated with the *last* curve in the</span>
 <span class="s0">* collection.  Normally, this will be either the XYZ or HPR curve, or a</span>
 <span class="s0">* timewarp curve.</span>
 <span class="s0">*/ 1 4 this 3 566  </span>
<span class="s0">43 0 0 4 54 552 0 0 539 /**</span>
 <span class="s0">* Discards all existing timewarp curves and recomputes a new timewarp curve</span>
 <span class="s0">* that maps distance along the curve to parametric time, so that the distance</span>
 <span class="s0">* between any two points in parametric time is proportional to the</span>
 <span class="s0">* approximate distance of those same two points along the XYZ curve.</span>
 <span class="s0">*</span>
 <span class="s0">* segments_per_unit represents the number of segments to take per each unit</span>
 <span class="s0">* of parametric time of the original XYZ curve.</span>
 <span class="s0">*</span>
 <span class="s0">* The new timewarp curve (and thus, the apparent range of the collection)</span>
 <span class="s0">* will range from 0 to max_t.</span>
 <span class="s0">*/ 3 4 this 3 565  5 max_t 1 525  17 segments_per_unit 1 525  </span>
<span class="s0">44 0 0 4 55 552 0 0 179 /**</span>
 <span class="s0">* Discards the existing HPR curve and generates a new one that looks in the</span>
 <span class="s0">* direction of travel along the XYZ curve, based on the XYZ curve's tangent</span>
 <span class="s0">* at each point.</span>
 <span class="s0">*/ 2 4 this 3 565  17 segments_per_unit 1 525  </span>
<span class="s0">45 0 0 4 56 552 0 0 277 /**</span>
 <span class="s0">* Adjusts the apparent length of the curve by applying a new timewarp that</span>
 <span class="s0">* maps the range [0..max_t] to the range [0..get_max_t()].  After this call,</span>
 <span class="s0">* the curve collection will contain one more timewarp curve, and get_max_t()</span>
 <span class="s0">* will return the given max_t value.</span>
 <span class="s0">*/ 2 4 this 3 565  5 max_t 1 525  </span>
<span class="s0">46 0 0 6 57 542 0 0 508 /**</span>
 <span class="s0">* Computes the transform matrix representing translation to the position</span>
 <span class="s0">* indicated by the first XYZ curve in the collection and the rotation</span>
 <span class="s0">* indicated by the first HPR curve in the collection, after t has been</span>
 <span class="s0">* modified by all the timewarp curves in the collection applied in sequence,</span>
 <span class="s0">* from back to front.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the point is valid (i.e.  t is within the bounds indicated</span>
 <span class="s0">* by all the timewarp curves and within the bounds of the curves themselves),</span>
 <span class="s0">* or false otherwise.</span>
 <span class="s0">*/ 4 4 this 3 566  1 t 1 525  6 result 1 571  2 cs 5 558  </span>
<span class="s0">47 0 0 6 57 542 0 0 433 /**</span>
 <span class="s0">* Computes the position and rotation represented by the first XYZ and HPR</span>
 <span class="s0">* curves in the collection at the given point t, after t has been modified by</span>
 <span class="s0">* all the timewarp curves in the collection applied in sequence, from back to</span>
 <span class="s0">* front.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the point is valid (i.e.  t is within the bounds indicated</span>
 <span class="s0">* by all the timewarp curves and within the bounds of the curves themselves),</span>
 <span class="s0">* or false otherwise.</span>
 <span class="s0">*/ 4 4 this 3 566  1 t 1 525  3 xyz 1 553  3 hpr 1 553  </span>
<span class="s0">48 0 0 6 58 525 0 0 219 /**</span>
 <span class="s0">* Determines the value of t that should be passed to the XYZ and HPR curves,</span>
 <span class="s0">* after applying the given value of t to all the timewarps.  Return -1.0f if</span>
 <span class="s0">* the value of t exceeds one of the timewarps' ranges.</span>
 <span class="s0">*/ 2 4 this 3 566  1 t 1 525  </span>
<span class="s0">49 0 0 6 59 542 0 0 69 /**</span>
 <span class="s0">* Computes only the XYZ part of the curves.  See evaluate().</span>
 <span class="s0">*/ 3 4 this 3 566  1 t 1 525  3 xyz 1 553  </span>
<span class="s0">50 0 0 6 60 542 0 0 69 /**</span>
 <span class="s0">* Computes only the HPR part of the curves.  See evaluate().</span>
 <span class="s0">*/ 3 4 this 3 566  1 t 1 525  3 hpr 1 553  </span>
<span class="s0">51 0 0 6 61 542 0 0 208 /**</span>
 <span class="s0">* Adjust the XYZ curve at the indicated time to the new value.  The curve</span>
 <span class="s0">* shape will change correspondingly.  Returns true if successful, false if</span>
 <span class="s0">* unable to make the adjustment for some reason.</span>
 <span class="s0">*/ 3 4 this 3 565  1 t 1 525  3 xyz 1 572  </span>
<span class="s0">52 0 0 6 61 542 0 0 208 /**</span>
 <span class="s0">* Adjust the XYZ curve at the indicated time to the new value.  The curve</span>
 <span class="s0">* shape will change correspondingly.  Returns true if successful, false if</span>
 <span class="s0">* unable to make the adjustment for some reason.</span>
 <span class="s0">*/ 5 4 this 3 565  1 t 1 525  1 x 1 525  1 y 1 525  1 z 1 525  </span>
<span class="s0">53 0 0 6 62 542 0 0 208 /**</span>
 <span class="s0">* Adjust the HPR curve at the indicated time to the new value.  The curve</span>
 <span class="s0">* shape will change correspondingly.  Returns true if successful, false if</span>
 <span class="s0">* unable to make the adjustment for some reason.</span>
 <span class="s0">*/ 3 4 this 3 565  1 t 1 525  3 xyz 1 572  </span>
<span class="s0">54 0 0 6 62 542 0 0 208 /**</span>
 <span class="s0">* Adjust the HPR curve at the indicated time to the new value.  The curve</span>
 <span class="s0">* shape will change correspondingly.  Returns true if successful, false if</span>
 <span class="s0">* unable to make the adjustment for some reason.</span>
 <span class="s0">*/ 5 4 this 3 565  1 t 1 525  1 h 1 525  1 p 1 525  1 r 1 525  </span>
<span class="s0">55 0 0 6 63 542 0 0 153 /**</span>
 <span class="s0">* Ensures all the curves are freshly computed and up-to-date.  Returns true</span>
 <span class="s0">* if everything is valid, false if at least one curve is incorrect.</span>
 <span class="s0">*/ 1 4 this 3 565  </span>
<span class="s0">56 0 0 6 64 542 0 0 262 /**</span>
 <span class="s0">* Regenerates this curve as one long curve: the first curve connected end-to-</span>
 <span class="s0">* end with the second one.  Either a or b may be the same as 'this'.  This</span>
 <span class="s0">* will lose any timewarps on the input curves.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false on failure.</span>
 <span class="s0">*/ 3 4 this 3 565  1 a 1 566  1 b 1 566  </span>
<span class="s0">57 0 0 4 65 552 0 0 114 /**</span>
 <span class="s0">* Writes a brief one-line description of the ParametricCurveCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 566  3 out 1 559  </span>
<span class="s0">58 0 0 4 66 552 0 0 119 /**</span>
 <span class="s0">* Writes a complete multi-line description of the ParametricCurveCollection</span>
 <span class="s0">* to the indicated output stream.</span>
 <span class="s0">*/ 3 4 this 3 566  3 out 1 559  12 indent_level 5 536  </span>
<span class="s0">59 0 0 6 67 542 0 0 162 /**</span>
 <span class="s0">* Writes an egg description of all the nurbs curves in the collection to the</span>
 <span class="s0">* specified output file.  Returns true if the file is successfully written.</span>
 <span class="s0">*/ 3 4 this 3 565  8 filename 1 556  2 cs 5 558  </span>
<span class="s0">60 0 0 6 67 542 0 0 164 /**</span>
 <span class="s0">* Writes an egg description of all the nurbs curves in the collection to the</span>
 <span class="s0">* specified output stream.  Returns true if the file is successfully written.</span>
 <span class="s0">*/ 4 4 this 3 565  3 out 1 559  8 filename 1 561  2 cs 1 558  </span>
<span class="s0">61 0 0 7 69 574 324 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">62 0 0 15 69 574 324 0 0 1 6 param0 0 575  </span>
<span class="s0">63 0 0 4 71 552 0 0 114 /**</span>
 <span class="s0">* Removes all the data points previously added to the CurveFitter, and</span>
 <span class="s0">* initializes it for a new curve.</span>
 <span class="s0">*/ 1 4 this 3 574  </span>
<span class="s0">64 0 0 4 72 552 0 0 36 /**</span>
 <span class="s0">* Adds a single sample xyz.</span>
 <span class="s0">*/ 3 4 this 3 574  1 t 1 525  3 xyz 1 572  </span>
<span class="s0">65 0 0 4 73 552 0 0 36 /**</span>
 <span class="s0">* Adds a single sample hpr.</span>
 <span class="s0">*/ 3 4 this 3 574  1 t 1 525  3 hpr 1 572  </span>
<span class="s0">66 0 0 4 74 552 0 0 57 /**</span>
 <span class="s0">* Adds a single sample xyz &amp; hpr simultaneously.</span>
 <span class="s0">*/ 4 4 this 3 574  1 t 1 525  3 xyz 1 572  3 hpr 1 572  </span>
<span class="s0">67 0 0 6 75 536 0 0 68 /**</span>
 <span class="s0">* Returns the number of sample points that have been added.</span>
 <span class="s0">*/ 1 4 this 3 575  </span>
<span class="s0">68 0 0 6 76 525 0 0 64 /**</span>
 <span class="s0">* Returns the parametric value of the nth sample added.</span>
 <span class="s0">*/ 2 4 this 3 575  1 n 1 536  </span>
<span class="s0">69 0 0 7 77 553 0 0 62 /**</span>
 <span class="s0">* Returns the point in space of the nth sample added.</span>
 <span class="s0">*/ 2 4 this 3 575  1 n 1 536  </span>
<span class="s0">70 0 0 7 78 553 0 0 59 /**</span>
 <span class="s0">* Returns the orientation of the nth sample added.</span>
 <span class="s0">*/ 2 4 this 3 575  1 n 1 536  </span>
<span class="s0">71 0 0 7 79 553 0 0 143 /**</span>
 <span class="s0">* Returns the tangent associated with the nth sample added.  This is only</span>
 <span class="s0">* meaningful if compute_tangents() has already been called.</span>
 <span class="s0">*/ 2 4 this 3 575  1 n 1 536  </span>
<span class="s0">72 0 0 4 80 552 0 0 108 /**</span>
 <span class="s0">* Eliminates all samples from index begin, up to but not including index end,</span>
 <span class="s0">* from the database.</span>
 <span class="s0">*/ 3 4 this 3 574  5 begin 1 536  3 end 1 536  </span>
<span class="s0">73 0 0 4 81 552 0 0 223 /**</span>
 <span class="s0">* Generates a series of data points by sampling the given curve (or xyz/hpr</span>
 <span class="s0">* curves) the indicated number of times.  The sampling is made evenly in</span>
 <span class="s0">* parametric time, and then the timewarps, if any, are applied.</span>
 <span class="s0">*/ 3 4 this 3 574  6 curves 1 565  5 count 1 536  </span>
<span class="s0">74 0 0 4 82 552 0 0 165 /**</span>
 <span class="s0">* Resets each HPR data point so that the maximum delta between any two</span>
 <span class="s0">* consecutive points is 180 degrees, which should prevent incorrect HPR</span>
 <span class="s0">* wrapping.</span>
 <span class="s0">*/ 1 4 this 3 574  </span>
<span class="s0">75 0 0 4 83 552 0 0 115 /**</span>
 <span class="s0">* Sorts all the data points in order by parametric time, in case they were</span>
 <span class="s0">* added in an incorrect order.</span>
 <span class="s0">*/ 1 4 this 3 574  </span>
<span class="s0">76 0 0 4 84 552 0 0 175 /**</span>
 <span class="s0">* Removes sample points in order to reduce the complexity of a sampled curve.</span>
 <span class="s0">* Keeps one out of every factor samples.  Also keeps the first and the last</span>
 <span class="s0">* samples.</span>
 <span class="s0">*/ 2 4 this 3 574  6 factor 1 525  </span>
<span class="s0">77 0 0 4 85 552 0 0 231 /**</span>
 <span class="s0">* Once a set of points has been built, and prior to calling MakeHermite() or</span>
 <span class="s0">* MakeNurbs(), ComputeTangents() must be called to set up the tangents</span>
 <span class="s0">* correctly (unless the tangents were defined as the points were added).</span>
 <span class="s0">*/ 2 4 this 3 574  5 scale 1 525  </span>
<span class="s0">78 0 0 7 86 565 0 0 72 /**</span>
 <span class="s0">* Converts the current set of data points into a Hermite curve.</span>
 <span class="s0">*/ 1 4 this 3 575  </span>
<span class="s0">79 0 0 7 87 565 0 0 134 /**</span>
 <span class="s0">* Converts the current set of data points into a NURBS curve.  This gives a</span>
 <span class="s0">* smoother curve than produced by MakeHermite().</span>
 <span class="s0">*/ 1 4 this 3 575  </span>
<span class="s0">80 0 0 4 88 552 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 575  3 out 1 559  </span>
<span class="s0">81 0 0 4 89 552 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 575  3 out 1 559  </span>
<span class="s0">82 0 0 7 90 564 0 0 0 0 </span>
<span class="s0">83 0 0 7 92 577 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">84 0 0 7 93 564 0 0 0 0 </span>
<span class="s0">85 0 0 7 95 578 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">86 0 0 23 95 578 0 0 80 /**</span>
 <span class="s0">* Constructs a Hermite from the indicated (possibly non-hermite) curve.</span>
 <span class="s0">*/ 1 2 pc 1 550  </span>
<span class="s0">87 0 0 6 96 536 0 0 51 /**</span>
 <span class="s0">* Returns the number of CV's in the curve.</span>
 <span class="s0">*/ 1 4 this 3 579  </span>
<span class="s0">88 0 0 6 97 536 0 0 547 /**</span>
 <span class="s0">* Inserts a new CV at the given parametric point along the curve.  If this</span>
 <span class="s0">* parametric point is already on the curve, the CV is assigned an index</span>
 <span class="s0">* between its two neighbors and the indices of all following CV's are</span>
 <span class="s0">* incremented by 1; its in and out tangents are chosen to keep the curve</span>
 <span class="s0">* consistent.  If the new parametric point is beyond the end of the existing</span>
 <span class="s0">* curve, the curve is extended to meet it and the new CV's position, in</span>
 <span class="s0">* tangent, and out tangent are set to zero.</span>
 <span class="s0">*</span>
 <span class="s0">* The index number of the new CV is returned.</span>
 <span class="s0">*/ 2 4 this 3 578  1 t 1 525  </span>
<span class="s0">89 0 0 6 98 536 0 0 0 3 4 this 3 578  4 type 1 536  1 v 1 572  </span>
<span class="s0">90 0 0 6 98 536 0 0 149 /**</span>
 <span class="s0">* Adds a new CV to the end of the curve.  The new CV is given initial in/out</span>
 <span class="s0">* tangents of 0.  The return value is the index of the new CV.</span>
 <span class="s0">*/ 5 4 this 3 578  4 type 1 536  1 x 1 525  1 y 1 525  1 z 1 525  </span>
<span class="s0">91 0 0 6 99 542 0 0 100 /**</span>
 <span class="s0">* Removes the given CV from the curve.  Returns true if the CV existed, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 578  1 n 1 536  </span>
<span class="s0">92 0 0 4 100 552 0 0 43 /**</span>
 <span class="s0">* Removes all CV's from the curve.</span>
 <span class="s0">*/ 1 4 this 3 578  </span>
<span class="s0">93 0 0 6 101 542 0 0 544 /**</span>
 <span class="s0">* Changes the given CV's continuity type.  Legal values are HC_CUT, HC_FREE,</span>
 <span class="s0">* HC_G1, or HC_SMOOTH.</span>
 <span class="s0">*</span>
 <span class="s0">* Other than HC_CUT, these have no effect on the actual curve; it remains up</span>
 <span class="s0">* to user software to impose the constraints these imply.</span>
 <span class="s0">*</span>
 <span class="s0">* HC_CUT implies a disconnection of the curve; HC_FREE imposes no constraints</span>
 <span class="s0">* on the tangents; HC_G1 forces the tangents to be collinear, and HC_SMOOTH</span>
 <span class="s0">* forces the tangents to be identical.  Setting type type to HC_G1 or</span>
 <span class="s0">* HC_SMOOTH may adjust the out tangent to match the in tangent.</span>
 <span class="s0">*/ 3 4 this 3 578  1 n 1 536  4 type 1 536  </span>
<span class="s0">94 0 0 6 102 542 0 0 0 3 4 this 3 578  1 n 1 536  1 v 1 572  </span>
<span class="s0">95 0 0 6 102 542 0 0 43 /**</span>
 <span class="s0">* Changes the given CV's position.</span>
 <span class="s0">*/ 5 4 this 3 578  1 n 1 536  1 x 1 525  1 y 1 525  1 z 1 525  </span>
<span class="s0">96 0 0 6 103 542 0 0 0 3 4 this 3 578  1 n 1 536  1 v 1 572  </span>
<span class="s0">97 0 0 6 103 542 0 0 121 /**</span>
 <span class="s0">* Changes the given CV's in tangent.  Depending on the continuity type, this</span>
 <span class="s0">* may also adjust the out tangent.</span>
 <span class="s0">*/ 5 4 this 3 578  1 n 1 536  1 x 1 525  1 y 1 525  1 z 1 525  </span>
<span class="s0">98 0 0 6 104 542 0 0 0 3 4 this 3 578  1 n 1 536  1 v 1 572  </span>
<span class="s0">99 0 0 6 104 542 0 0 121 /**</span>
 <span class="s0">* Changes the given CV's out tangent.  Depending on the continuity type, this</span>
 <span class="s0">* may also adjust the in tangent.</span>
 <span class="s0">*/ 5 4 this 3 578  1 n 1 536  1 x 1 525  1 y 1 525  1 z 1 525  </span>
<span class="s0">100 0 0 6 105 542 0 0 103 /**</span>
 <span class="s0">* Changes the given CV's parametric starting time.  This may affect the shape</span>
 <span class="s0">* of the curve.</span>
 <span class="s0">*/ 3 4 this 3 578  1 n 1 536  6 tstart 1 525  </span>
<span class="s0">101 0 0 6 106 542 0 0 60 /**</span>
 <span class="s0">* Changes the name associated with a particular CV.</span>
 <span class="s0">*/ 3 4 this 3 578  1 n 1 536  4 name 1 581  </span>
<span class="s0">102 0 0 6 107 536 0 0 120 /**</span>
 <span class="s0">* Returns the given CV's continuity type, HC_CUT, HC_FREE, HC_G1, or</span>
 <span class="s0">* HC_SMOOTH, or 0 if there is no such CV.</span>
 <span class="s0">*/ 2 4 this 3 579  1 n 1 536  </span>
<span class="s0">103 0 0 6 108 572 0 0 48 /**</span>
 <span class="s0">* Returns the position of the given CV.</span>
 <span class="s0">*/ 2 4 this 3 579  1 n 1 536  </span>
<span class="s0">104 0 0 4 108 552 0 0 0 3 4 this 3 579  1 n 1 536  1 v 1 553  </span>
<span class="s0">105 0 0 6 109 572 0 0 50 /**</span>
 <span class="s0">* Returns the in tangent of the given CV.</span>
 <span class="s0">*/ 2 4 this 3 579  1 n 1 536  </span>
<span class="s0">106 0 0 4 109 552 0 0 0 3 4 this 3 579  1 n 1 536  1 v 1 553  </span>
<span class="s0">107 0 0 6 110 572 0 0 51 /**</span>
 <span class="s0">* Returns the out tangent of the given CV.</span>
 <span class="s0">*/ 2 4 this 3 579  1 n 1 536  </span>
<span class="s0">108 0 0 4 110 552 0 0 0 3 4 this 3 579  1 n 1 536  1 v 1 553  </span>
<span class="s0">109 0 0 6 111 525 0 0 74 /**</span>
 <span class="s0">* Returns the starting point in parametric space of the given CV.</span>
 <span class="s0">*/ 2 4 this 3 579  1 n 1 536  </span>
<span class="s0">110 0 0 6 112 581 0 0 53 /**</span>
 <span class="s0">* Returns the name of the given CV, or NULL.</span>
 <span class="s0">*/ 2 4 this 3 579  1 n 1 536  </span>
<span class="s0">111 0 0 4 113 552 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 579  3 out 1 559  1 n 1 536  </span>
<span class="s0">112 0 0 7 114 564 0 0 0 0 </span>
<span class="s0">113 0 0 4 117 552 0 0 0 2 4 this 3 582  5 order 1 536  </span>
<span class="s0">114 0 0 6 118 536 0 0 0 1 4 this 3 583  </span>
<span class="s0">115 0 0 6 119 536 0 0 0 1 4 this 3 583  </span>
<span class="s0">116 0 0 6 120 536 0 0 0 1 4 this 3 583  </span>
<span class="s0">117 0 0 6 121 542 0 0 0 2 4 this 3 582  1 t 1 525  </span>
<span class="s0">118 0 0 6 122 536 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 582  1 v 1 572  </span>
<span class="s0">119 0 0 6 122 536 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 582  1 v 1 585  </span>
<span class="s0">120 0 0 6 122 536 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 582  1 x 1 525  1 y 1 525  1 z 1 525  </span>
<span class="s0">121 0 0 6 123 542 0 0 0 2 4 this 3 582  1 n 1 536  </span>
<span class="s0">122 0 0 4 124 552 0 0 0 1 4 this 3 582  </span>
<span class="s0">123 0 0 6 125 542 0 0 86 /**</span>
 <span class="s0">* Repositions the indicated CV.  Returns true if successful, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 582  1 n 1 536  1 v 1 572  </span>
<span class="s0">124 0 0 6 125 542 0 0 86 /**</span>
 <span class="s0">* Repositions the indicated CV.  Returns true if successful, false otherwise.</span>
 <span class="s0">*/ 5 4 this 3 582  1 n 1 536  1 x 1 525  1 y 1 525  1 z 1 525  </span>
<span class="s0">125 0 0 7 126 553 0 0 52 /**</span>
 <span class="s0">* Returns the position of the indicated CV.</span>
 <span class="s0">*/ 2 4 this 3 583  1 n 1 536  </span>
<span class="s0">126 0 0 6 127 542 0 0 94 /**</span>
 <span class="s0">* Sets the weight of the indicated CV without affecting its position in 3-d</span>
 <span class="s0">* space.</span>
 <span class="s0">*/ 3 4 this 3 582  1 n 1 536  1 w 1 525  </span>
<span class="s0">127 0 0 6 128 525 0 0 50 /**</span>
 <span class="s0">* Returns the weight of the indicated CV.</span>
 <span class="s0">*/ 2 4 this 3 583  1 n 1 536  </span>
<span class="s0">128 0 0 6 129 542 0 0 0 3 4 this 3 582  1 n 1 536  1 v 1 585  </span>
<span class="s0">129 0 0 7 130 589 0 0 0 2 4 this 3 583  1 n 1 536  </span>
<span class="s0">130 0 0 6 131 542 0 0 0 3 4 this 3 582  1 n 1 536  1 t 1 525  </span>
<span class="s0">131 0 0 6 132 525 0 0 0 2 4 this 3 583  1 n 1 536  </span>
<span class="s0">132 0 0 4 135 552 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 583  3 out 1 559  1 n 1 536  </span>
<span class="s0">133 0 0 7 136 564 0 0 0 0 </span>
<span class="s0">134 0 0 7 142 590 391 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">135 0 0 23 142 590 391 0 94 /**</span>
 <span class="s0">* Constructs a NURBS curve equivalent to the indicated (possibly non-NURBS)</span>
 <span class="s0">* curve.</span>
 <span class="s0">*/ 1 2 pc 1 550  </span>
<span class="s0">136 0 0 7 144 564 0 0 0 0 </span>
<span class="s0">137 0 0 7 138 577 0 0 0 1 4 this 3 590  </span>
<span class="s0">138 0 0 6 140 582 0 0 0 1 4 this 3 590  </span>
<span class="s0">139 0 0 15 164 593 0 0 0 1 6 param0 0 591  </span>
<span class="s0">140 0 0 6 146 525 0 0 81 /**</span>
 <span class="s0">* Returns the first legal value of t on the curve.  Usually this is 0.0.</span>
 <span class="s0">*/ 1 4 this 3 591  </span>
<span class="s0">141 0 0 6 147 525 0 0 58 /**</span>
 <span class="s0">* Returns the last legal value of t on the curve.</span>
 <span class="s0">*/ 1 4 this 3 591  </span>
<span class="s0">142 0 0 6 148 542 0 0 158 /**</span>
 <span class="s0">* Computes the point on the curve corresponding to the indicated value in</span>
 <span class="s0">* parametric time.  Returns true if the t value is valid, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 593  1 t 1 525  5 point 1 553  </span>
<span class="s0">143 0 0 6 149 542 0 0 193 /**</span>
 <span class="s0">* Computes the tangent to the curve at the indicated point in parametric</span>
 <span class="s0">* time.  This tangent vector will not necessarily be normalized, and could be</span>
 <span class="s0">* zero.  See also eval_point().</span>
 <span class="s0">*/ 3 4 this 3 593  1 t 1 525  7 tangent 1 553  </span>
<span class="s0">144 0 0 6 150 525 0 0 145 /**</span>
 <span class="s0">* Evaluates the curve in n-dimensional space according to the extended</span>
 <span class="s0">* vertices associated with the curve in the indicated dimension.</span>
 <span class="s0">*/ 3 4 this 3 593  1 t 1 525  1 d 1 536  </span>
<span class="s0">145 0 0 6 151 542 0 0 248 /**</span>
 <span class="s0">* Simultaneously performs eval_extended_point on a contiguous sequence of</span>
 <span class="s0">* dimensions.  The dimensions evaluated are d through (d + num_values - 1);</span>
 <span class="s0">* the results are filled into the num_values elements in the indicated result</span>
 <span class="s0">* array.</span>
 <span class="s0">*/ 5 4 this 3 593  1 t 1 525  1 d 1 536  6 result 1 594  10 num_values 1 536  </span>
<span class="s0">146 0 0 6 152 536 0 0 170 /**</span>
 <span class="s0">* Returns the number of piecewise continuous segments within the curve.  This</span>
 <span class="s0">* number is usually not important unless you plan to call</span>
 <span class="s0">* eval_segment_point().</span>
 <span class="s0">*/ 1 4 this 3 591  </span>
<span class="s0">147 0 0 4 153 552 0 0 637 /**</span>
 <span class="s0">* Evaluates the point on the curve corresponding to the indicated value in</span>
 <span class="s0">* parametric time within the indicated curve segment.  t should be in the</span>
 <span class="s0">* range [0, 1].</span>
 <span class="s0">*</span>
 <span class="s0">* The curve is internally represented as a number of connected (or possibly</span>
 <span class="s0">* unconnected) piecewise continuous segments.  The exact number of segments</span>
 <span class="s0">* for a particular curve depends on the knot vector, and is returned by</span>
 <span class="s0">* get_num_segments().  Normally, eval_point() is used to evaluate a point</span>
 <span class="s0">* along the continuous curve, but when you care more about local continuity,</span>
 <span class="s0">* you can use eval_segment_point() to evaluate the points along each segment.</span>
 <span class="s0">*/ 4 4 this 3 591  7 segment 1 536  1 t 1 525  5 point 1 553  </span>
<span class="s0">148 0 0 4 154 552 0 0 207 /**</span>
 <span class="s0">* As eval_segment_point, but computes the tangent to the curve at the</span>
 <span class="s0">* indicated point.  The tangent vector will not necessarily be normalized,</span>
 <span class="s0">* and could be zero, particularly at the endpoints.</span>
 <span class="s0">*/ 4 4 this 3 591  7 segment 1 536  1 t 1 525  7 tangent 1 553  </span>
<span class="s0">149 0 0 6 155 525 0 0 145 /**</span>
 <span class="s0">* Evaluates the curve in n-dimensional space according to the extended</span>
 <span class="s0">* vertices associated with the curve in the indicated dimension.</span>
 <span class="s0">*/ 4 4 this 3 591  7 segment 1 536  1 t 1 525  1 d 1 536  </span>
<span class="s0">150 0 0 4 156 552 0 0 248 /**</span>
 <span class="s0">* Simultaneously performs eval_extended_point on a contiguous sequence of</span>
 <span class="s0">* dimensions.  The dimensions evaluated are d through (d + num_values - 1);</span>
 <span class="s0">* the results are filled into the num_values elements in the indicated result</span>
 <span class="s0">* array.</span>
 <span class="s0">*/ 6 4 this 3 591  7 segment 1 536  1 t 1 525  1 d 1 536  6 result 1 594  10 num_values 1 536  </span>
<span class="s0">151 0 0 6 157 525 0 0 217 /**</span>
 <span class="s0">* Accepts a t value in the range [0, 1], and assumed to be relative to the</span>
 <span class="s0">* indicated segment (as in eval_segment_point()), and returns the</span>
 <span class="s0">* corresponding t value in the entire curve (as in eval_point()).</span>
 <span class="s0">*/ 3 4 this 3 591  7 segment 1 536  1 t 1 525  </span>
<span class="s0">152 0 0 4 158 552 0 0 330 /**</span>
 <span class="s0">* Determines the set of subdivisions necessary to approximate the curve with</span>
 <span class="s0">* a set of linear segments, no point of which is farther than tolerance units</span>
 <span class="s0">* from the actual curve.</span>
 <span class="s0">*</span>
 <span class="s0">* After this call, you may walk through the resulting set of samples with</span>
 <span class="s0">* get_num_samples(), get_sample_t(), and get_sample_point().</span>
 <span class="s0">*/ 2 4 this 3 593  9 tolerance 1 525  </span>
<span class="s0">153 0 0 6 159 536 0 0 102 /**</span>
 <span class="s0">* Returns the number of sample points generated by the previous call to</span>
 <span class="s0">* adaptive_sample().</span>
 <span class="s0">*/ 1 4 this 3 591  </span>
<span class="s0">154 0 0 6 160 525 0 0 110 /**</span>
 <span class="s0">* Returns the t value of the nth sample point generated by the previous call</span>
 <span class="s0">* to adaptive_sample().</span>
 <span class="s0">*/ 2 4 this 3 591  1 n 1 536  </span>
<span class="s0">155 0 0 6 161 595 0 0 252 /**</span>
 <span class="s0">* Returns the point on the curve of the nth sample point generated by the</span>
 <span class="s0">* previous call to adaptive_sample().</span>
 <span class="s0">*</span>
 <span class="s0">* For tangents, or extended points, you should use get_sample_t() and pass it</span>
 <span class="s0">* into eval_tangent() or eval_extended_point().</span>
 <span class="s0">*/ 2 4 this 3 591  1 n 1 536  </span>
<span class="s0">156 0 0 7 166 541 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">157 0 0 15 166 541 0 0 0 1 6 param0 0 599  </span>
<span class="s0">158 0 0 4 167 552 0 0 224 /**</span>
 <span class="s0">* Sets the order of the curve.  This resets the knot vector to the default</span>
 <span class="s0">* knot vector for the number of vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* The order must be 1, 2, 3, or 4, and the value is one more than the degree</span>
 <span class="s0">* of the curve.</span>
 <span class="s0">*/ 2 4 this 3 541  5 order 1 536  </span>
<span class="s0">159 0 0 6 168 536 0 0 83 /**</span>
 <span class="s0">* Returns the order of the curve as set by a previous call to set_order().</span>
 <span class="s0">*/ 1 4 this 3 599  </span>
<span class="s0">160 0 0 4 169 552 0 0 231 /**</span>
 <span class="s0">* Resets all the vertices and knots to their default values, and sets the</span>
 <span class="s0">* curve up with the indicated number of vertices.  You must then call</span>
 <span class="s0">* set_vertex() repeatedly to fill in all of the vertex values appropriately.</span>
 <span class="s0">*/ 2 4 this 3 541  12 num_vertices 1 536  </span>
<span class="s0">161 0 0 6 170 536 0 0 122 /**</span>
 <span class="s0">* Returns the number of control vertices in the curve.  This is the number</span>
 <span class="s0">* passed to the last call to reset().</span>
 <span class="s0">*/ 1 4 this 3 599  </span>
<span class="s0">162 0 0 4 171 552 0 0 194 /**</span>
 <span class="s0">* Sets the nth control vertex of the curve.  This flavor sets the vertex as a</span>
 <span class="s0">* 3-d coordinate and a weight; the 3-d coordinate values are implicitly</span>
 <span class="s0">* scaled up by the weight factor.</span>
 <span class="s0">*/ 4 4 this 3 541  1 i 1 536  6 vertex 1 572  6 weight 5 525  </span>
<span class="s0">163 0 0 4 171 552 0 0 245 /**</span>
 <span class="s0">* Sets the nth control vertex of the curve, as a vertex in 4-d homogeneous</span>
 <span class="s0">* space.  In this form, the first three components of the vertex should</span>
 <span class="s0">* already have been scaled by the fourth component, which is the homogeneous</span>
 <span class="s0">* weight.</span>
 <span class="s0">*/ 3 4 this 3 541  1 i 1 536  6 vertex 1 585  </span>
<span class="s0">164 0 0 6 172 585 0 0 102 /**</span>
 <span class="s0">* Returns the nth control vertex of the curve, relative to its indicated</span>
 <span class="s0">* coordinate space.</span>
 <span class="s0">*/ 2 4 this 3 599  1 i 1 536  </span>
<span class="s0">165 0 0 7 172 589 0 0 98 /**</span>
 <span class="s0">* Returns the nth control vertex of the curve, relative to the given</span>
 <span class="s0">* coordinate space.</span>
 <span class="s0">*/ 3 4 this 3 599  1 i 1 536  6 rel_to 1 601  </span>
<span class="s0">166 0 0 4 174 552 0 0 429 /**</span>
 <span class="s0">* Sets the coordinate space of the nth control vertex.  If this is not</span>
 <span class="s0">* specified, or is set to an empty NodePath, the nth control vertex is deemed</span>
 <span class="s0">* to be in the coordinate space passed to evaluate().</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the space as a fixed NodePath, which is always the same</span>
 <span class="s0">* NodePath.  Also see setting the space as a path string, which can specify a</span>
 <span class="s0">* different NodePath for different instances of the curve.</span>
 <span class="s0">*/ 3 4 this 3 541  1 i 1 536  5 space 1 601  </span>
<span class="s0">167 0 0 4 174 552 0 0 361 /**</span>
 <span class="s0">* Sets the coordinate space of the nth control vertex.  If this is not</span>
 <span class="s0">* specified, or is set to an empty string, the nth control vertex is deemed</span>
 <span class="s0">* to be in the coordinate space passed to evaluate().</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the space as a string, which describes the path to find the</span>
 <span class="s0">* node relative to the rel_to NodePath when the curve is evaluated.</span>
 <span class="s0">*/ 3 4 this 3 541  1 i 1 536  5 space 1 581  </span>
<span class="s0">168 0 0 7 175 604 0 0 107 /**</span>
 <span class="s0">* Returns the coordinate space of the nth control vertex of the curve,</span>
 <span class="s0">* expressed as a NodePath.</span>
 <span class="s0">*/ 3 4 this 3 599  1 i 1 536  6 rel_to 1 601  </span>
<span class="s0">169 0 0 4 176 552 0 0 768 /**</span>
 <span class="s0">* Sets an n-dimensional vertex value.  This allows definition of a NURBS</span>
 <span class="s0">* surface or curve in a sparse n-dimensional space, typically used for</span>
 <span class="s0">* associating additional properties (like color or joint membership) with</span>
 <span class="s0">* each vertex of a surface.</span>
 <span class="s0">*</span>
 <span class="s0">* The value d is an arbitrary integer value and specifies the dimension of</span>
 <span class="s0">* question for this particular vertex.  Any number of dimensions may be</span>
 <span class="s0">* specified, and they need not be consecutive.  If a value for a given</span>
 <span class="s0">* dimension is not specified, is it implicitly 0.0.</span>
 <span class="s0">*</span>
 <span class="s0">* The value is implicitly scaled by the homogenous weight value--that is, the</span>
 <span class="s0">* fourth component of the value passed to set_vertex().  This means the</span>
 <span class="s0">* ordinary vertex must be set first, before the extended vertices can be set.</span>
 <span class="s0">*/ 4 4 this 3 541  1 i 1 536  1 d 1 536  5 value 1 525  </span>
<span class="s0">170 0 0 6 177 525 0 0 172 /**</span>
 <span class="s0">* Returns an n-dimensional vertex value.  See set_extended_vertex().  This</span>
 <span class="s0">* returns the value set for the indicated dimension, or 0.0 if nothing has</span>
 <span class="s0">* been set.</span>
 <span class="s0">*/ 3 4 this 3 599  1 i 1 536  1 d 1 536  </span>
<span class="s0">171 0 0 4 178 552 0 0 259 /**</span>
 <span class="s0">* Simultaneously sets several extended values in the slots d through (d +</span>
 <span class="s0">* num_values - 1) from the num_values elements of the indicated array.  This</span>
 <span class="s0">* is equivalent to calling set_extended_vertex() num_values times.  See</span>
 <span class="s0">* set_extended_vertex().</span>
 <span class="s0">*/ 5 4 this 3 541  1 i 1 536  1 d 1 536  6 values 1 605  10 num_values 1 536  </span>
<span class="s0">172 0 0 6 179 536 0 0 117 /**</span>
 <span class="s0">* Returns the number of knot values in the curve.  This is based on the</span>
 <span class="s0">* number of vertices and the order.</span>
 <span class="s0">*/ 1 4 this 3 599  </span>
<span class="s0">173 0 0 4 180 552 0 0 184 /**</span>
 <span class="s0">* Sets the value of the nth knot.  Each knot value should be greater than or</span>
 <span class="s0">* equal to the preceding value.  If no knot values are set, a default knot</span>
 <span class="s0">* vector is supplied.</span>
 <span class="s0">*/ 3 4 this 3 541  1 i 1 536  4 knot 1 525  </span>
<span class="s0">174 0 0 6 181 525 0 0 45 /**</span>
 <span class="s0">* Returns the value of the nth knot.</span>
 <span class="s0">*/ 2 4 this 3 599  1 i 1 536  </span>
<span class="s0">175 0 0 4 183 552 0 0 95 /**</span>
 <span class="s0">* Normalizes the knot sequence so that the parametric range of the curve is 0</span>
 <span class="s0">* .. 1.</span>
 <span class="s0">*/ 1 4 this 3 541  </span>
<span class="s0">176 0 0 6 184 536 0 0 114 /**</span>
 <span class="s0">* Returns the number of piecewise continuous segments in the curve.  This is</span>
 <span class="s0">* based on the knot vector.</span>
 <span class="s0">*/ 1 4 this 3 599  </span>
<span class="s0">177 0 0 7 185 593 0 0 194 /**</span>
 <span class="s0">* Returns a NurbsCurveResult object that represents the result of applying</span>
 <span class="s0">* the knots to all of the current values of the vertices, transformed into</span>
 <span class="s0">* the indicated coordinate space.</span>
 <span class="s0">*/ 2 4 this 3 599  6 rel_to 5 601  </span>
<span class="s0">178 0 0 7 185 593 0 0 251 /**</span>
 <span class="s0">* Returns a NurbsCurveResult object that represents the result of applying</span>
 <span class="s0">* the knots to all of the current values of the vertices, transformed into</span>
 <span class="s0">* the indicated coordinate space, and then further transformed by the</span>
 <span class="s0">* indicated matrix.</span>
 <span class="s0">*/ 3 4 this 3 599  6 rel_to 1 601  3 mat 1 607  </span>
<span class="s0">179 0 0 4 186 552 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 599  3 out 1 559  </span>
<span class="s0">180 0 0 15 204 610 0 0 0 1 6 param0 0 608  </span>
<span class="s0">181 0 0 6 188 525 0 0 83 /**</span>
 <span class="s0">* Returns the first legal value of u on the surface.  Usually this is 0.0.</span>
 <span class="s0">*/ 1 4 this 3 608  </span>
<span class="s0">182 0 0 6 189 525 0 0 60 /**</span>
 <span class="s0">* Returns the last legal value of u on the surface.</span>
 <span class="s0">*/ 1 4 this 3 608  </span>
<span class="s0">183 0 0 6 190 525 0 0 83 /**</span>
 <span class="s0">* Returns the first legal value of v on the surface.  Usually this is 0.0.</span>
 <span class="s0">*/ 1 4 this 3 608  </span>
<span class="s0">184 0 0 6 191 525 0 0 60 /**</span>
 <span class="s0">* Returns the last legal value of v on the surface.</span>
 <span class="s0">*/ 1 4 this 3 608  </span>
<span class="s0">185 0 0 6 192 542 0 0 168 /**</span>
 <span class="s0">* Computes the point on the surface corresponding to the indicated value in</span>
 <span class="s0">* parametric time.  Returns true if the u, v values are valid, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 4 4 this 3 610  1 u 1 525  1 v 1 525  5 point 1 553  </span>
<span class="s0">186 0 0 6 193 542 0 0 193 /**</span>
 <span class="s0">* Computes the normal to the surface at the indicated point in parametric</span>
 <span class="s0">* time.  This normal vector will not necessarily be normalized, and could be</span>
 <span class="s0">* zero.  See also eval_point().</span>
 <span class="s0">*/ 4 4 this 3 610  1 u 1 525  1 v 1 525  6 normal 1 553  </span>
<span class="s0">187 0 0 6 194 525 0 0 149 /**</span>
 <span class="s0">* Evaluates the surface in n-dimensional space according to the extended</span>
 <span class="s0">* vertices associated with the surface in the indicated dimension.</span>
 <span class="s0">*/ 4 4 this 3 610  1 u 1 525  1 v 1 525  1 d 1 536  </span>
<span class="s0">188 0 0 6 195 542 0 0 248 /**</span>
 <span class="s0">* Simultaneously performs eval_extended_point on a contiguous sequence of</span>
 <span class="s0">* dimensions.  The dimensions evaluated are d through (d + num_values - 1);</span>
 <span class="s0">* the results are filled into the num_values elements in the indicated result</span>
 <span class="s0">* array.</span>
 <span class="s0">*/ 6 4 this 3 610  1 u 1 525  1 v 1 525  1 d 1 536  6 result 1 594  10 num_values 1 536  </span>
<span class="s0">189 0 0 6 196 536 0 0 191 /**</span>
 <span class="s0">* Returns the number of piecewise continuous segments within the surface in</span>
 <span class="s0">* the U direction.  This number is usually not important unless you plan to</span>
 <span class="s0">* call eval_segment_point().</span>
 <span class="s0">*/ 1 4 this 3 608  </span>
<span class="s0">190 0 0 6 197 536 0 0 191 /**</span>
 <span class="s0">* Returns the number of piecewise continuous segments within the surface in</span>
 <span class="s0">* the V direction.  This number is usually not important unless you plan to</span>
 <span class="s0">* call eval_segment_point().</span>
 <span class="s0">*/ 1 4 this 3 608  </span>
<span class="s0">191 0 0 4 198 552 0 0 656 /**</span>
 <span class="s0">* Evaluates the point on the surface corresponding to the indicated value in</span>
 <span class="s0">* parametric time within the indicated surface segment.  u and v should be in</span>
 <span class="s0">* the range [0, 1].</span>
 <span class="s0">*</span>
 <span class="s0">* The surface is internally represented as a number of connected (or possibly</span>
 <span class="s0">* unconnected) piecewise continuous segments.  The exact number of segments</span>
 <span class="s0">* for a particular surface depends on the knot vector, and is returned by</span>
 <span class="s0">* get_num_segments().  Normally, eval_point() is used to evaluate a point</span>
 <span class="s0">* along the continuous surface, but when you care more about local</span>
 <span class="s0">* continuity, you can use eval_segment_point() to evaluate the points along</span>
 <span class="s0">* each segment.</span>
 <span class="s0">*/ 6 4 this 3 608  2 ui 1 536  2 vi 1 536  1 u 1 525  1 v 1 525  5 point 1 553  </span>
<span class="s0">192 0 0 4 199 552 0 0 176 /**</span>
 <span class="s0">* As eval_segment_point, but computes the normal to the surface at the</span>
 <span class="s0">* indicated point.  The normal vector will not necessarily be normalized, and</span>
 <span class="s0">* could be zero.</span>
 <span class="s0">*/ 6 4 this 3 608  2 ui 1 536  2 vi 1 536  1 u 1 525  1 v 1 525  6 normal 1 553  </span>
<span class="s0">193 0 0 6 200 525 0 0 149 /**</span>
 <span class="s0">* Evaluates the surface in n-dimensional space according to the extended</span>
 <span class="s0">* vertices associated with the surface in the indicated dimension.</span>
 <span class="s0">*/ 6 4 this 3 608  2 ui 1 536  2 vi 1 536  1 u 1 525  1 v 1 525  1 d 1 536  </span>
<span class="s0">194 0 0 4 201 552 0 0 248 /**</span>
 <span class="s0">* Simultaneously performs eval_extended_point on a contiguous sequence of</span>
 <span class="s0">* dimensions.  The dimensions evaluated are d through (d + num_values - 1);</span>
 <span class="s0">* the results are filled into the num_values elements in the indicated result</span>
 <span class="s0">* array.</span>
 <span class="s0">*/ 8 4 this 3 608  2 ui 1 536  2 vi 1 536  1 u 1 525  1 v 1 525  1 d 1 536  6 result 1 594  10 num_values 1 536  </span>
<span class="s0">195 0 0 6 202 525 0 0 219 /**</span>
 <span class="s0">* Accepts a u value in the range [0, 1], and assumed to be relative to the</span>
 <span class="s0">* indicated segment (as in eval_segment_point()), and returns the</span>
 <span class="s0">* corresponding u value in the entire surface (as in eval_point()).</span>
 <span class="s0">*/ 3 4 this 3 608  2 ui 1 536  1 u 1 525  </span>
<span class="s0">196 0 0 6 203 525 0 0 219 /**</span>
 <span class="s0">* Accepts a v value in the range [0, 1], and assumed to be relative to the</span>
 <span class="s0">* indicated segment (as in eval_segment_point()), and returns the</span>
 <span class="s0">* corresponding v value in the entire surface (as in eval_point()).</span>
 <span class="s0">*/ 3 4 this 3 608  2 vi 1 536  1 v 1 525  </span>
<span class="s0">197 0 0 7 206 611 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">198 0 0 15 206 611 0 0 0 1 6 param0 0 612  </span>
<span class="s0">199 0 0 4 207 552 0 0 247 /**</span>
 <span class="s0">* Sets the order of the surface in the U direction.  This resets the knot</span>
 <span class="s0">* vector to the default knot vector for the number of vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* The order must be 1, 2, 3, or 4, and the value is one more than the degree</span>
 <span class="s0">* of the surface.</span>
 <span class="s0">*/ 2 4 this 3 611  7 u_order 1 536  </span>
<span class="s0">200 0 0 6 208 536 0 0 109 /**</span>
 <span class="s0">* Returns the order of the surface in the U direction as set by a previous</span>
 <span class="s0">* call to set_u_order().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">201 0 0 4 209 552 0 0 247 /**</span>
 <span class="s0">* Sets the order of the surface in the V direction.  This resets the knot</span>
 <span class="s0">* vector to the default knot vector for the number of vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* The order must be 1, 2, 3, or 4, and the value is one more than the degree</span>
 <span class="s0">* of the surface.</span>
 <span class="s0">*/ 2 4 this 3 611  7 v_order 1 536  </span>
<span class="s0">202 0 0 6 210 536 0 0 109 /**</span>
 <span class="s0">* Returns the order of the surface in the V direction as set by a previous</span>
 <span class="s0">* call to set_v_order().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">203 0 0 4 211 552 0 0 233 /**</span>
 <span class="s0">* Resets all the vertices and knots to their default values, and sets the</span>
 <span class="s0">* surface up with the indicated number of vertices.  You must then call</span>
 <span class="s0">* set_vertex() repeatedly to fill in all of the vertex values appropriately.</span>
 <span class="s0">*/ 3 4 this 3 611  14 num_u_vertices 1 536  14 num_v_vertices 1 536  </span>
<span class="s0">204 0 0 6 212 536 0 0 142 /**</span>
 <span class="s0">* Returns the number of control vertices in the U direction on the surface.</span>
 <span class="s0">* This is the number passed to the last call to reset().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">205 0 0 6 213 536 0 0 142 /**</span>
 <span class="s0">* Returns the number of control vertices in the V direction on the surface.</span>
 <span class="s0">* This is the number passed to the last call to reset().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">206 0 0 4 214 552 0 0 196 /**</span>
 <span class="s0">* Sets the nth control vertex of the surface.  This flavor sets the vertex as</span>
 <span class="s0">* a 3-d coordinate and a weight; the 3-d coordinate values are implicitly</span>
 <span class="s0">* scaled up by the weight factor.</span>
 <span class="s0">*/ 5 4 this 3 611  2 ui 1 536  2 vi 1 536  6 vertex 1 572  6 weight 5 525  </span>
<span class="s0">207 0 0 4 214 552 0 0 247 /**</span>
 <span class="s0">* Sets the nth control vertex of the surface, as a vertex in 4-d homogeneous</span>
 <span class="s0">* space.  In this form, the first three components of the vertex should</span>
 <span class="s0">* already have been scaled by the fourth component, which is the homogeneous</span>
 <span class="s0">* weight.</span>
 <span class="s0">*/ 4 4 this 3 611  2 ui 1 536  2 vi 1 536  6 vertex 1 585  </span>
<span class="s0">208 0 0 6 215 585 0 0 104 /**</span>
 <span class="s0">* Returns the nth control vertex of the surface, relative to its indicated</span>
 <span class="s0">* coordinate space.</span>
 <span class="s0">*/ 3 4 this 3 612  2 ui 1 536  2 vi 1 536  </span>
<span class="s0">209 0 0 7 215 589 0 0 100 /**</span>
 <span class="s0">* Returns the nth control vertex of the surface, relative to the given</span>
 <span class="s0">* coordinate space.</span>
 <span class="s0">*/ 4 4 this 3 612  2 ui 1 536  2 vi 1 536  6 rel_to 1 601  </span>
<span class="s0">210 0 0 4 216 552 0 0 431 /**</span>
 <span class="s0">* Sets the coordinate space of the nth control vertex.  If this is not</span>
 <span class="s0">* specified, or is set to an empty NodePath, the nth control vertex is deemed</span>
 <span class="s0">* to be in the coordinate space passed to evaluate().</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the space as a fixed NodePath, which is always the same</span>
 <span class="s0">* NodePath.  Also see setting the space as a path string, which can specify a</span>
 <span class="s0">* different NodePath for different instances of the surface.</span>
 <span class="s0">*/ 4 4 this 3 611  2 ui 1 536  2 vi 1 536  5 space 1 601  </span>
<span class="s0">211 0 0 4 216 552 0 0 363 /**</span>
 <span class="s0">* Sets the coordinate space of the nth control vertex.  If this is not</span>
 <span class="s0">* specified, or is set to an empty string, the nth control vertex is deemed</span>
 <span class="s0">* to be in the coordinate space passed to evaluate().</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the space as a string, which describes the path to find the</span>
 <span class="s0">* node relative to the rel_to NodePath when the surface is evaluated.</span>
 <span class="s0">*/ 4 4 this 3 611  2 ui 1 536  2 vi 1 536  5 space 1 581  </span>
<span class="s0">212 0 0 7 217 604 0 0 109 /**</span>
 <span class="s0">* Returns the coordinate space of the nth control vertex of the surface,</span>
 <span class="s0">* expressed as a NodePath.</span>
 <span class="s0">*/ 4 4 this 3 612  2 ui 1 536  2 vi 1 536  6 rel_to 1 601  </span>
<span class="s0">213 0 0 4 218 552 0 0 770 /**</span>
 <span class="s0">* Sets an n-dimensional vertex value.  This allows definition of a NURBS</span>
 <span class="s0">* surface or surface in a sparse n-dimensional space, typically used for</span>
 <span class="s0">* associating additional properties (like color or joint membership) with</span>
 <span class="s0">* each vertex of a surface.</span>
 <span class="s0">*</span>
 <span class="s0">* The value d is an arbitrary integer value and specifies the dimension of</span>
 <span class="s0">* question for this particular vertex.  Any number of dimensions may be</span>
 <span class="s0">* specified, and they need not be consecutive.  If a value for a given</span>
 <span class="s0">* dimension is not specified, is it implicitly 0.0.</span>
 <span class="s0">*</span>
 <span class="s0">* The value is implicitly scaled by the homogenous weight value--that is, the</span>
 <span class="s0">* fourth component of the value passed to set_vertex().  This means the</span>
 <span class="s0">* ordinary vertex must be set first, before the extended vertices can be set.</span>
 <span class="s0">*/ 5 4 this 3 611  2 ui 1 536  2 vi 1 536  1 d 1 536  5 value 1 525  </span>
<span class="s0">214 0 0 6 219 525 0 0 172 /**</span>
 <span class="s0">* Returns an n-dimensional vertex value.  See set_extended_vertex().  This</span>
 <span class="s0">* returns the value set for the indicated dimension, or 0.0 if nothing has</span>
 <span class="s0">* been set.</span>
 <span class="s0">*/ 4 4 this 3 612  2 ui 1 536  2 vi 1 536  1 d 1 536  </span>
<span class="s0">215 0 0 4 220 552 0 0 259 /**</span>
 <span class="s0">* Simultaneously sets several extended values in the slots d through (d +</span>
 <span class="s0">* num_values - 1) from the num_values elements of the indicated array.  This</span>
 <span class="s0">* is equivalent to calling set_extended_vertex() num_values times.  See</span>
 <span class="s0">* set_extended_vertex().</span>
 <span class="s0">*/ 6 4 this 3 611  2 ui 1 536  2 vi 1 536  1 d 1 536  6 values 1 605  10 num_values 1 536  </span>
<span class="s0">216 0 0 6 221 536 0 0 138 /**</span>
 <span class="s0">* Returns the number of knot values in the surface in the U direction.  This</span>
 <span class="s0">* is based on the number of vertices and the order.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">217 0 0 4 222 552 0 0 184 /**</span>
 <span class="s0">* Sets the value of the nth knot.  Each knot value should be greater than or</span>
 <span class="s0">* equal to the preceding value.  If no knot values are set, a default knot</span>
 <span class="s0">* vector is supplied.</span>
 <span class="s0">*/ 3 4 this 3 611  1 i 1 536  4 knot 1 525  </span>
<span class="s0">218 0 0 6 223 525 0 0 45 /**</span>
 <span class="s0">* Returns the value of the nth knot.</span>
 <span class="s0">*/ 2 4 this 3 612  1 i 1 536  </span>
<span class="s0">219 0 0 4 225 552 0 0 116 /**</span>
 <span class="s0">* Normalizes the knot sequence so that the parametric range of the surface in</span>
 <span class="s0">* the U direction is 0 .. 1.</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">220 0 0 6 226 536 0 0 138 /**</span>
 <span class="s0">* Returns the number of knot values in the surface in the V direction.  This</span>
 <span class="s0">* is based on the number of vertices and the order.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">221 0 0 4 227 552 0 0 184 /**</span>
 <span class="s0">* Sets the value of the nth knot.  Each knot value should be greater than or</span>
 <span class="s0">* equal to the preceding value.  If no knot values are set, a default knot</span>
 <span class="s0">* vector is supplied.</span>
 <span class="s0">*/ 3 4 this 3 611  1 i 1 536  4 knot 1 525  </span>
<span class="s0">222 0 0 6 228 525 0 0 45 /**</span>
 <span class="s0">* Returns the value of the nth knot.</span>
 <span class="s0">*/ 2 4 this 3 612  1 i 1 536  </span>
<span class="s0">223 0 0 4 230 552 0 0 116 /**</span>
 <span class="s0">* Normalizes the knot sequence so that the parametric range of the surface in</span>
 <span class="s0">* the U direction is 0 .. 1.</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">224 0 0 6 231 536 0 0 135 /**</span>
 <span class="s0">* Returns the number of piecewise continuous segments in the surface in the U</span>
 <span class="s0">* direction.  This is based on the knot vector.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">225 0 0 6 232 536 0 0 135 /**</span>
 <span class="s0">* Returns the number of piecewise continuous segments in the surface in the V</span>
 <span class="s0">* direction.  This is based on the knot vector.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">226 0 0 7 233 610 0 0 196 /**</span>
 <span class="s0">* Returns a NurbsSurfaceResult object that represents the result of applying</span>
 <span class="s0">* the knots to all of the current values of the vertices, transformed into</span>
 <span class="s0">* the indicated coordinate space.</span>
 <span class="s0">*/ 2 4 this 3 612  6 rel_to 5 601  </span>
<span class="s0">227 0 0 4 234 552 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 612  3 out 1 559  </span>
<span class="s0">228 0 0 7 241 614 506 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 581  </span>
<span class="s0">229 0 0 4 245 552 0 0 65 /**</span>
 <span class="s0">* Sets the particular curve represented by the RopeNode.</span>
 <span class="s0">*/ 2 4 this 3 614  5 curve 1 541  </span>
<span class="s0">230 0 0 7 246 541 0 0 57 /**</span>
 <span class="s0">* Returns the curve represented by the RopeNode.</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">231 0 0 4 247 552 0 0 130 /**</span>
 <span class="s0">* Specifies the method used to render the rope.  The simplest is RM_thread,</span>
 <span class="s0">* which just draws a one-pixel line segment.</span>
 <span class="s0">*/ 2 4 this 3 614  11 render_mode 1 538  </span>
<span class="s0">232 0 0 6 248 538 0 0 78 /**</span>
 <span class="s0">* Returns the method used to render the rope.  See set_render_mode().</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">233 0 0 4 249 552 0 0 72 /**</span>
 <span class="s0">* Specifies the algorithm to use to generate UV's for the rope.</span>
 <span class="s0">*/ 2 4 this 3 614  7 uv_mode 1 539  </span>
<span class="s0">234 0 0 6 250 539 0 0 70 /**</span>
 <span class="s0">* Returns the algorithm to use to generate UV's for the rope.</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">235 0 0 4 251 552 0 0 115 /**</span>
 <span class="s0">* Specify true to vary the U coordinate down the length of the rope, or false</span>
 <span class="s0">* to vary the V coordinate.</span>
 <span class="s0">*/ 2 4 this 3 614  10 u_dominant 1 542  </span>
<span class="s0">236 0 0 6 252 542 0 0 124 /**</span>
 <span class="s0">* Returns true if the rope runs down the U coordinate of the texture, or</span>
 <span class="s0">* false if it runs down the V coordinate.</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">237 0 0 4 253 552 0 0 206 /**</span>
 <span class="s0">* Specifies an additional scaling factor to apply to generated UV's along the</span>
 <span class="s0">* rope.  This scale factor is applied in whichever direction is along the</span>
 <span class="s0">* rope, as specified by set_uv_direction().</span>
 <span class="s0">*/ 2 4 this 3 614  5 scale 1 525  </span>
<span class="s0">238 0 0 6 254 525 0 0 78 /**</span>
 <span class="s0">* Returns the scaling factor to apply to generated UV's for the rope.</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">239 0 0 4 255 552 0 0 192 /**</span>
 <span class="s0">* Specifies the kind of normals to generate for the rope.  This is only</span>
 <span class="s0">* applicable when the RenderMode is set to RM_tube; in the other render</span>
 <span class="s0">* modes, normals are never generated.</span>
 <span class="s0">*/ 2 4 this 3 614  11 normal_mode 1 540  </span>
<span class="s0">240 0 0 6 256 540 0 0 131 /**</span>
 <span class="s0">* Returns the kind of normals to generate for the rope.  This is only</span>
 <span class="s0">* applicable when the RenderMode is set to RM_tube.</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">241 0 0 4 257 552 0 0 419 /**</span>
 <span class="s0">* Specifies a normal vector, generally perpendicular to the main axis of the</span>
 <span class="s0">* starting point of the curve, that controls the &quot;top&quot; of the curve, when</span>
 <span class="s0">* RenderMode is RM_tube.  This is used to orient the vertices that make up</span>
 <span class="s0">* the tube.  If this vector is too nearly parallel with the starting</span>
 <span class="s0">* direction of the curve, there may be a tendency for the whole tube to</span>
 <span class="s0">* gimble-lock around its primary axis.</span>
 <span class="s0">*/ 2 4 this 3 614  7 tube_up 1 617  </span>
<span class="s0">242 0 0 6 258 617 0 0 127 /**</span>
 <span class="s0">* Returns the normal vector used to control the &quot;top&quot; of the curve, when</span>
 <span class="s0">* RenderMode is RM_tube.  See set_tube_up().</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">243 0 0 4 259 552 0 0 351 /**</span>
 <span class="s0">* Sets the &quot;use vertex color&quot; flag.  When this is true, the R, G, B, A vertex</span>
 <span class="s0">* color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,</span>
 <span class="s0">* respectively, of the extended vertex values, where n is the value returned</span>
 <span class="s0">* by get_vertex_color_dimension().  Use</span>
 <span class="s0">* NurbsCurveEvaluator::set_extended_vertex() to set these values.</span>
 <span class="s0">*/ 2 4 this 3 614  4 flag 1 542  </span>
<span class="s0">244 0 0 6 260 542 0 0 76 /**</span>
 <span class="s0">* Returns the &quot;use vertex color&quot; flag.  See set_use_vertex_color().</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">245 0 0 6 261 536 0 0 221 /**</span>
 <span class="s0">* Returns the numeric extended dimension in which the color components should</span>
 <span class="s0">* be found.  See NurbsCurveEvaluator::set_extended_vertex().</span>
 <span class="s0">*</span>
 <span class="s0">* The color components will be expected at (n, n + 1, n + 2, n + 3).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">246 0 0 4 262 552 0 0 154 /**</span>
 <span class="s0">* Specifies the number of subdivisions per cubic segment (that is, per unique</span>
 <span class="s0">* knot value) to draw in a fixed uniform tesselation of the curve.</span>
 <span class="s0">*/ 2 4 this 3 614  10 num_subdiv 1 536  </span>
<span class="s0">247 0 0 6 263 536 0 0 98 /**</span>
 <span class="s0">* Returns the number of subdivisions per cubic segment to draw.  See</span>
 <span class="s0">* set_num_subdiv().</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">248 0 0 4 264 552 0 0 404 /**</span>
 <span class="s0">* Specifies the number of radial subdivisions to make if RenderMode is</span>
 <span class="s0">* RM_tube.  It is ignored in the other render modes.</span>
 <span class="s0">*</span>
 <span class="s0">* Increasing this number increases the roundness of a cross-section of the</span>
 <span class="s0">* tube.  The minimum value for a dimensional tube is 3; setting it to 2 will</span>
 <span class="s0">* get you a thin piece of tape (which is similar to RM_billboard, except it</span>
 <span class="s0">* won't rotate to face the camera).</span>
 <span class="s0">*/ 2 4 this 3 614  10 num_slices 1 536  </span>
<span class="s0">249 0 0 6 265 536 0 0 153 /**</span>
 <span class="s0">* Returns the number of radial subdivisions to make if RenderMode is RM_tube.</span>
 <span class="s0">* It is ignored in the other render modes.  See set_num_slices().</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">250 0 0 4 266 552 0 0 418 /**</span>
 <span class="s0">* Sets the &quot;use vertex thickness&quot; flag.  When this is true, the vertex</span>
 <span class="s0">* thickness is assumed to be stored as the dimension</span>
 <span class="s0">* get_vertex_thickness_dimension(), of the extended vertex values.  Use</span>
 <span class="s0">* NurbsCurveEvaluator::set_extended_vertex() to set these values.</span>
 <span class="s0">*</span>
 <span class="s0">* In this mode, the overall thickness is also applied as a scale to the</span>
 <span class="s0">* vertex thickness.  Not all render modes support vertex thickness.</span>
 <span class="s0">*/ 2 4 this 3 614  4 flag 1 542  </span>
<span class="s0">251 0 0 6 267 542 0 0 84 /**</span>
 <span class="s0">* Returns the &quot;use vertex thickness&quot; flag.  See set_use_vertex_thickness().</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">252 0 0 6 268 536 0 0 151 /**</span>
 <span class="s0">* Returns the numeric extended dimension in which the thickness component</span>
 <span class="s0">* should be found.  See NurbsCurveEvaluator::set_extended_vertex().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">253 0 0 4 269 552 0 0 236 /**</span>
 <span class="s0">* Specifies the thickness of the rope, in pixels or in spatial units,</span>
 <span class="s0">* depending on the render mode.  See set_render_mode().</span>
 <span class="s0">*</span>
 <span class="s0">* The thickness may also be specified on a per-vertex basis.  See</span>
 <span class="s0">* set_use_vertex_thickness().</span>
 <span class="s0">*/ 2 4 this 3 614  9 thickness 1 525  </span>
<span class="s0">254 0 0 6 270 525 0 0 67 /**</span>
 <span class="s0">* Returns the thickness of the rope.  See set_thickness().</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">255 0 0 4 271 552 0 0 207 /**</span>
 <span class="s0">* Specifies an optional matrix which is used to transform each control vertex</span>
 <span class="s0">* after it has been transformed into the RopeNode's coordinate space, but</span>
 <span class="s0">* before the polygon vertices are generated.</span>
 <span class="s0">*/ 2 4 this 3 614  6 matrix 1 607  </span>
<span class="s0">256 0 0 4 272 552 0 0 67 /**</span>
 <span class="s0">* Resets the node's matrix to identity.  See set_matrix().</span>
 <span class="s0">*/ 1 4 this 3 614  </span>
<span class="s0">257 0 0 6 273 542 0 0 92 /**</span>
 <span class="s0">* Returns true if the node has a matrix set, false otherwise.  See</span>
 <span class="s0">* set_matrix().</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">258 0 0 6 274 607 0 0 206 /**</span>
 <span class="s0">* Returns the optional matrix which is used to transform each control vertex</span>
 <span class="s0">* after it has been transformed into the RopeNode's coordinate space, but</span>
 <span class="s0">* before the polygon vertices are generated.</span>
 <span class="s0">*/ 1 4 this 3 615  </span>
<span class="s0">259 0 0 4 275 552 0 0 206 /**</span>
 <span class="s0">* Recomputes the bounding volume.  This is normally called automatically, but</span>
 <span class="s0">* it must occasionally be called explicitly when the curve has changed</span>
 <span class="s0">* properties outside of this node's knowledge.</span>
 <span class="s0">*/ 2 4 this 3 614  6 rel_to 1 601  </span>
<span class="s0">260 0 0 7 299 564 0 0 0 0 </span>
<span class="s0">261 0 0 7 302 618 518 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 581  </span>
<span class="s0">262 0 0 4 303 552 0 0 68 /**</span>
 <span class="s0">* Sets the particular surface represented by the SheetNode.</span>
 <span class="s0">*/ 2 4 this 3 618  7 surface 1 611  </span>
<span class="s0">263 0 0 7 304 611 0 0 60 /**</span>
 <span class="s0">* Returns the surface represented by the SheetNode.</span>
 <span class="s0">*/ 1 4 this 3 619  </span>
<span class="s0">264 0 0 4 305 552 0 0 269 /**</span>
 <span class="s0">* Sets the &quot;use vertex color&quot; flag.  When this is true, the R, G, B, A vertex</span>
 <span class="s0">* color is assumed to be stored as the dimensions 0, 1, 2, 3, respectively,</span>
 <span class="s0">* of the extended vertex values.  Use</span>
 <span class="s0">* NurbsCurveEvaluator::set_extended_vertex() to set these values.</span>
 <span class="s0">*/ 2 4 this 3 618  4 flag 1 542  </span>
<span class="s0">265 0 0 6 306 542 0 0 76 /**</span>
 <span class="s0">* Returns the &quot;use vertex color&quot; flag.  See set_use_vertex_color().</span>
 <span class="s0">*/ 1 4 this 3 619  </span>
<span class="s0">266 0 0 4 307 552 0 0 178 /**</span>
 <span class="s0">* Specifies the number of subdivisions per cubic segment (that is, per unique</span>
 <span class="s0">* knot value) to draw in a fixed uniform tesselation of the surface in the U</span>
 <span class="s0">* direction.</span>
 <span class="s0">*/ 2 4 this 3 618  12 num_u_subdiv 1 536  </span>
<span class="s0">267 0 0 6 308 536 0 0 119 /**</span>
 <span class="s0">* Returns the number of subdivisions per cubic segment to draw in the U</span>
 <span class="s0">* direction.  See set_num_u_subdiv().</span>
 <span class="s0">*/ 1 4 this 3 619  </span>
<span class="s0">268 0 0 4 309 552 0 0 178 /**</span>
 <span class="s0">* Specifies the number of subdivisions per cubic segment (that is, per unique</span>
 <span class="s0">* knot value) to draw in a fixed uniform tesselation of the surface in the V</span>
 <span class="s0">* direction.</span>
 <span class="s0">*/ 2 4 this 3 618  12 num_v_subdiv 1 536  </span>
<span class="s0">269 0 0 6 310 536 0 0 119 /**</span>
 <span class="s0">* Returns the number of subdivisions per cubic segment to draw in the V</span>
 <span class="s0">* direction.  See set_num_v_subdiv().</span>
 <span class="s0">*/ 1 4 this 3 619  </span>
<span class="s0">270 0 0 4 311 552 0 0 208 /**</span>
 <span class="s0">* Recomputes the bounding volume.  This is normally called automatically, but</span>
 <span class="s0">* it must occasionally be called explicitly when the surface has changed</span>
 <span class="s0">* properties outside of this node's knowledge.</span>
 <span class="s0">*/ 2 4 this 3 618  6 rel_to 1 601  </span>
<span class="s0">271 0 0 7 312 564 0 0 0 0 </span>
<span class="s0">102</span>
<span class="s0">519 15 ParametricCurve 0 75777 15 ParametricCurve 15 ParametricCurve 0 0 0 0 0 0 19 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 0 0 1 0 520 0 0 0 0 163</span>
<span class="s0">/**</span>
 <span class="s0">* A virtual base class for parametric curves.  This encapsulates all curves</span>
 <span class="s0">* in 3-d space defined for a single parameter t in the range [0,get_max_t()].</span>
 <span class="s0">*/</span>

<span class="s0">520 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A basic node of the scene graph or data graph.  This is the base class of</span>
 <span class="s0">* all specialized nodes, and also serves as a generic node with no special</span>
 <span class="s0">* properties.</span>
 <span class="s0">*/</span>

<span class="s0">521 13 CubicCurveseg 0 75777 13 CubicCurveseg 13 CubicCurveseg 0 0 0 0 0 0 1 291 0 0 1 0 519 0 0 0 0 940</span>
<span class="s0">/**</span>
 <span class="s0">* A CubicCurveseg is any curve that can be completely described by four</span>
 <span class="s0">* 4-valued basis vectors, one for each dimension in three-space, and one for</span>
 <span class="s0">* the homogeneous coordinate.  This includes Beziers, Hermites, and NURBS.</span>
 <span class="s0">*</span>
 <span class="s0">* This class encapsulates a single curve segment of the cubic curve.</span>
 <span class="s0">* Normally, when we think of Bezier and Hermite curves, we think of a</span>
 <span class="s0">* piecewise collection of such segments.</span>
 <span class="s0">*</span>
 <span class="s0">* Although this class includes methods such as hermite_basis() and</span>
 <span class="s0">* nurbs_basis(), to generate a Hermite and NURBS curve segment, respectively,</span>
 <span class="s0">* only the final basis vectors are stored: the product of the basis matrix of</span>
 <span class="s0">* the corresponding curve type, and its geometry vectors.  This is the</span>
 <span class="s0">* minimum information needed to evaluate the curve.  However, the individual</span>
 <span class="s0">* CV's that were used to compute these basis vectors are not retained; this</span>
 <span class="s0">* might be handled in a subclass (for instance, HermiteCurve).</span>
 <span class="s0">*/</span>

<span class="s0">522 25 ParametricCurveCollection 0 75777 25 ParametricCurveCollection 25 ParametricCurveCollection 0 0 0 1 292 0 6 629 630 631 632 633 634 30 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 2 654 655 0 1 0 523 0 0 0 0 343</span>
<span class="s0">/**</span>
 <span class="s0">* This is a set of zero or more ParametricCurves, which may or may not be</span>
 <span class="s0">* related.  If they are related, the set should contain no more than one XYZ</span>
 <span class="s0">* curve, no more than one HPR curve, and zero or more Timewarp curves, which</span>
 <span class="s0">* can then be evaluated as a unit to return a single transformation matrix</span>
 <span class="s0">* for a given unit of time.</span>
 <span class="s0">*/</span>

<span class="s0">523 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">524 17 ParametricCurve * 0 8576 17 ParametricCurve * 17 ParametricCurve * 0 0 519 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">525 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 526 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">526 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">527 11 CurveFitter 0 26625 11 CurveFitter 11 CurveFitter 0 0 0 1 323 324 0 20 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 0 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">528 14 PiecewiseCurve 0 75777 14 PiecewiseCurve 14 PiecewiseCurve 0 0 0 1 345 0 0 1 346 0 0 1 0 519 0 0 0 0 184</span>
<span class="s0">/**</span>
 <span class="s0">* A PiecewiseCurve is a curve made up of several curve segments, connected in</span>
 <span class="s0">* a head-to-tail fashion.  The length of each curve segment in parametric</span>
 <span class="s0">* space is definable.</span>
 <span class="s0">*/</span>

<span class="s0">529 12 HermiteCurve 0 75777 12 HermiteCurve 12 HermiteCurve 0 0 0 1 347 0 0 19 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 0 0 1 0 528 0 0 0 0 421</span>
<span class="s0">/**</span>
 <span class="s0">* A parametric curve defined by a sequence of control vertices, each with an</span>
 <span class="s0">* in and out tangent.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is actually implemented as a PiecewiseCurve made up of several</span>
 <span class="s0">* CubicCurvesegs, each of which is created using the hermite_basis() method.</span>
 <span class="s0">* The HermiteCurve class itself keeps its own list of the CV's that are used</span>
 <span class="s0">* to define the curve (since the CubicCurveseg class doesn't retain these).</span>
 <span class="s0">*/</span>

<span class="s0">530 19 NurbsCurveInterface 0 26625 19 NurbsCurveInterface 19 NurbsCurveInterface 0 0 0 0 367 0 18 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 2 656 657 0 0 0 0 211</span>
<span class="s0">/**</span>
 <span class="s0">* This abstract class defines the interface only for a Nurbs-style curve,</span>
 <span class="s0">* with knots and coordinates in homogeneous space.</span>
 <span class="s0">*</span>
 <span class="s0">* The NurbsCurve class inherits both from this and from ParametricCurve.</span>
 <span class="s0">*/</span>

<span class="s0">531 10 NurbsCurve 0 26625 10 NurbsCurve 10 NurbsCurve 0 0 0 1 390 391 0 1 392 0 0 2 3 528 386 387 3 530 388 389 0 0 830</span>
<span class="s0">/**</span>
 <span class="s0">* A Nonuniform Rational B-Spline.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is actually implemented as a PiecewiseCurve made up of several</span>
 <span class="s0">* CubicCurvesegs, each of which is created using the nurbs_basis() method.</span>
 <span class="s0">* The list of CV's and knots is kept here, within the NurbsCurve class.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is the original Panda-native implementation of a NURBS curve.</span>
 <span class="s0">* It is typedeffed as &quot;NurbsCurve&quot; and performs all NURBS curve functions if</span>
 <span class="s0">* we do not have the NURBS++ library available.</span>
 <span class="s0">*</span>
 <span class="s0">* However, if we *do* have the NURBS++ library, another class exists, the</span>
 <span class="s0">* NurbsPPCurve, which is a wrapper around that library and provides some</span>
 <span class="s0">* additional functionality.  In that case, the other class is typedeffed to</span>
 <span class="s0">* &quot;NurbsCurve&quot; instead of this one, and performs most of the NURBS curve</span>
 <span class="s0">* functions.  This class then becomes vestigial.</span>
 <span class="s0">*/</span>

<span class="s0">532 16 NurbsCurveResult 0 75777 16 NurbsCurveResult 16 NurbsCurveResult 0 0 0 1 409 0 0 16 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 2 658 659 0 1 0 523 0 0 0 0 453</span>
<span class="s0">/**</span>
 <span class="s0">* The result of a NurbsCurveEvaluator.  This object represents a curve in a</span>
 <span class="s0">* particular coordinate space.  It can return the point and/or tangent to the</span>
 <span class="s0">* curve at any point.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not related to NurbsCurve, CubicCurveseg or any of the</span>
 <span class="s0">* ParametricCurve-derived objects in this module.  It is a completely</span>
 <span class="s0">* parallel implementation of NURBS curves, and will probably eventually</span>
 <span class="s0">* replace the whole ParametricCurve class hierarchy.</span>
 <span class="s0">*/</span>

<span class="s0">533 19 NurbsCurveEvaluator 0 75777 19 NurbsCurveEvaluator 19 NurbsCurveEvaluator 0 0 0 1 410 0 0 18 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 2 660 661 0 1 0 523 0 0 0 0 492</span>
<span class="s0">/**</span>
 <span class="s0">* This class is an abstraction for evaluating NURBS curves.  It accepts an</span>
 <span class="s0">* array of vertices, each of which may be in a different coordinate space (as</span>
 <span class="s0">* defined by a NodePath), as well as an optional knot vector.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not related to NurbsCurve, CubicCurveseg or any of the</span>
 <span class="s0">* ParametricCurve-derived objects in this module.  It is a completely</span>
 <span class="s0">* parallel implementation of NURBS curves, and will probably eventually</span>
 <span class="s0">* replace the whole ParametricCurve class hierarchy.</span>
 <span class="s0">*/</span>

<span class="s0">534 18 NurbsSurfaceResult 0 75777 18 NurbsSurfaceResult 18 NurbsSurfaceResult 0 0 0 1 445 0 0 16 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 0 0 1 0 523 0 0 0 0 191</span>
<span class="s0">/**</span>
 <span class="s0">* The result of a NurbsSurfaceEvaluator.  This object represents a surface in</span>
 <span class="s0">* a particular coordinate space.  It can return the point and/or normal to</span>
 <span class="s0">* the surface at any point.</span>
 <span class="s0">*/</span>

<span class="s0">535 21 NurbsSurfaceEvaluator 0 75777 21 NurbsSurfaceEvaluator 21 NurbsSurfaceEvaluator 0 0 0 1 446 0 4 635 636 637 638 26 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 2 662 663 0 1 0 523 0 0 0 0 227</span>
<span class="s0">/**</span>
 <span class="s0">* This class is an abstraction for evaluating NURBS surfaces.  It accepts an</span>
 <span class="s0">* array of vertices, each of which may be in a different coordinate space (as</span>
 <span class="s0">* defined by a NodePath), as well as an optional knot vector.</span>
 <span class="s0">*/</span>

<span class="s0">536 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">537 8 RopeNode 0 141313 8 RopeNode 8 RopeNode 0 0 0 1 473 506 15 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 32 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 0 0 1 0 520 0 0 0 3 538 539 540 428</span>
<span class="s0">/**</span>
 <span class="s0">* This class draws a visible representation of the NURBS curve stored in its</span>
 <span class="s0">* NurbsCurveEvaluator.  It automatically recomputes the curve every frame.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not related to NurbsCurve, CubicCurveseg or any of the</span>
 <span class="s0">* ParametricCurve-derived objects in this module.  It is a completely</span>
 <span class="s0">* parallel implementation of NURBS curves, and will probably eventually</span>
 <span class="s0">* replace the whole ParametricCurve class hierarchy.</span>
 <span class="s0">*/</span>

<span class="s0">538 10 RenderMode 0 794624 20 RopeNode::RenderMode 20 RopeNode::RenderMode 537 0 0 0 0 0 0 0 0 0 4 9 RM_thread 19 RopeNode::RM_thread 59</span>
<span class="s0">// Render the rope as a one-pixel thread using a linestrip.</span>
<span class="s0">0 7 RM_tape 17 RopeNode::RM_tape 93</span>
<span class="s0">// Render the rope as a triangle strip oriented to be perpendicular to the</span>
<span class="s0">// tube_up vector.</span>
<span class="s0">1 12 RM_billboard 22 RopeNode::RM_billboard 90</span>
<span class="s0">// Render the rope as a triangle strip oriented to be perpendicular to the</span>
<span class="s0">// view vector.</span>
<span class="s0">2 7 RM_tube 17 RopeNode::RM_tube 62</span>
<span class="s0">// Render the rope as a hollow tube extruded along its length.</span>
<span class="s0">3 0 0</span>

<span class="s0">539 6 UVMode 0 794624 16 RopeNode::UVMode 16 RopeNode::UVMode 537 0 0 0 0 0 0 0 0 0 4 7 UV_none 17 RopeNode::UV_none 39</span>
<span class="s0">// Don't generate UV's along the curve.</span>
<span class="s0">0 13 UV_parametric 23 RopeNode::UV_parametric 69</span>
<span class="s0">// Generate UV's based on the parametric coordinates along the curve.</span>
<span class="s0">1 11 UV_distance 21 RopeNode::UV_distance 140</span>
<span class="s0">// Generate UV's in proportion to spatial distance along the curve, by</span>
<span class="s0">// using the distance function to compute the length of each segment.</span>
<span class="s0">2 12 UV_distance2 22 RopeNode::UV_distance2 310</span>
<span class="s0">// As above, but don't bother to take the square root of each segment.</span>
<span class="s0">// The distance is then in proportion to the sum-of-squares of the</span>
<span class="s0">// segments along the rope.  If the segments are similar in length, this</span>
<span class="s0">// approximates the proportion of UV_distance while avoiding hundreds of</span>
<span class="s0">// square root operations.</span>
<span class="s0">3 0 0</span>

<span class="s0">540 10 NormalMode 0 794624 20 RopeNode::NormalMode 20 RopeNode::NormalMode 537 0 0 0 0 0 0 0 0 0 2 7 NM_none 17 RopeNode::NM_none 26</span>
<span class="s0">// Don't generate normals.</span>
<span class="s0">0 9 NM_vertex 19 RopeNode::NM_vertex 43</span>
<span class="s0">// Generate vertex (smooth-shaded) normals.</span>
<span class="s0">1 0 0</span>

<span class="s0">541 21 NurbsCurveEvaluator * 0 8576 21 NurbsCurveEvaluator * 21 NurbsCurveEvaluator * 0 0 533 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">542 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">543 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 544 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">544 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 545 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">545 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">546 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 547 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">547 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 548 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">548 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">549 9 SheetNode 0 141313 9 SheetNode 9 SheetNode 0 0 0 1 507 518 0 10 508 509 510 511 512 513 514 515 516 517 0 0 1 0 520 0 0 0 0 447</span>
<span class="s0">/**</span>
 <span class="s0">* This class draws a visible representation of the NURBS surface stored in</span>
 <span class="s0">* its NurbsSurfaceEvaluator.  It automatically recomputes the surface every</span>
 <span class="s0">* frame.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not related to NurbsSurface, CubicSurfaceseg or any of the</span>
 <span class="s0">* ParametricSurface-derived objects in this module.  It is a completely</span>
 <span class="s0">* parallel implementation of NURBS surfaces, and will probably eventually</span>
 <span class="s0">* replace the whole ParametricSurface class hierarchy.</span>
 <span class="s0">*/</span>

<span class="s0">550 23 ParametricCurve const * 0 8576 23 ParametricCurve const * 23 ParametricCurve const * 0 0 551 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">551 21 ParametricCurve const 0 8832 21 ParametricCurve const 21 ParametricCurve const 0 0 519 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">552 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">553 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">554 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 555 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">555 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">556 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 557 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">557 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">558 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210</span>
<span class="s0">// The CS_default entry does not refer to a particular coordinate system,</span>
<span class="s0">// but rather to the value stored in default_coordinate_system, which in</span>
<span class="s0">// turn is loaded from the config variable &quot;coordinate-system&quot;.</span>
<span class="s0">0 12 CS_zup_right 12 CS_zup_right 21</span>
<span class="s0">// Z-Up, Right-handed</span>
<span class="s0">1 12 CS_yup_right 12 CS_yup_right 21</span>
<span class="s0">// Y-Up, Right-handed</span>
<span class="s0">2 11 CS_zup_left 11 CS_zup_left 20</span>
<span class="s0">// Z-Up, Left-handed</span>
<span class="s0">3 11 CS_yup_left 11 CS_yup_left 20</span>
<span class="s0">// Y-Up, Left-handed</span>
<span class="s0">4 10 CS_invalid 10 CS_invalid 156</span>
<span class="s0">// CS_invalid is not a coordinate system at all.  It can be used in user-</span>
<span class="s0">// input processing code to indicate a contradictory coordinate system</span>
<span class="s0">// request.</span>
<span class="s0">5 0 0</span>

<span class="s0">559 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 560 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">560 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">561 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 562 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">562 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 557 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">563 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">564 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 563 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">565 27 ParametricCurveCollection * 0 8576 27 ParametricCurveCollection * 27 ParametricCurveCollection * 0 0 522 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">566 33 ParametricCurveCollection const * 0 8576 33 ParametricCurveCollection const * 33 ParametricCurveCollection const * 0 0 567 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">567 31 ParametricCurveCollection const 0 8832 31 ParametricCurveCollection const 31 ParametricCurveCollection const 0 0 522 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">568 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 569 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">569 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">570 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 520 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">571 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 547 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">572 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 573 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">573 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">574 13 CurveFitter * 0 8576 13 CurveFitter * 13 CurveFitter * 0 0 527 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">575 19 CurveFitter const * 0 8576 19 CurveFitter const * 19 CurveFitter const * 0 0 576 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">576 17 CurveFitter const 0 8832 17 CurveFitter const 17 CurveFitter const 0 0 527 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">577 16 PiecewiseCurve * 0 8576 16 PiecewiseCurve * 16 PiecewiseCurve * 0 0 528 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">578 14 HermiteCurve * 0 8576 14 HermiteCurve * 14 HermiteCurve * 0 0 529 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">579 20 HermiteCurve const * 0 8576 20 HermiteCurve const * 20 HermiteCurve const * 0 0 580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">580 18 HermiteCurve const 0 8832 18 HermiteCurve const 18 HermiteCurve const 0 0 529 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">581 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">582 21 NurbsCurveInterface * 0 8576 21 NurbsCurveInterface * 21 NurbsCurveInterface * 0 0 530 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">583 27 NurbsCurveInterface const * 0 8576 27 NurbsCurveInterface const * 27 NurbsCurveInterface const * 0 0 584 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">584 25 NurbsCurveInterface const 0 8832 25 NurbsCurveInterface const 25 NurbsCurveInterface const 0 0 530 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">585 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 586 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">586 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 587 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">587 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 588 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">588 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">589 11 LVecBase4 * 0 8576 11 LVecBase4 * 11 LVecBase4 * 0 0 587 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">590 12 NurbsCurve * 0 8576 12 NurbsCurve * 12 NurbsCurve * 0 0 531 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">591 24 NurbsCurveResult const * 0 8576 24 NurbsCurveResult const * 24 NurbsCurveResult const * 0 0 592 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">592 22 NurbsCurveResult const 0 8832 22 NurbsCurveResult const 22 NurbsCurveResult const 0 0 532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">593 18 NurbsCurveResult * 0 8576 18 NurbsCurveResult * 18 NurbsCurveResult * 0 0 532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">594 14 PN_stdfloat [] 0 4202496 14 PN_stdfloat [] 14 PN_stdfloat [] 0 0 525 -1 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">595 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 596 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">596 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 597 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">597 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 598 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">598 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">599 27 NurbsCurveEvaluator const * 0 8576 27 NurbsCurveEvaluator const * 27 NurbsCurveEvaluator const * 0 0 600 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">600 25 NurbsCurveEvaluator const 0 8832 25 NurbsCurveEvaluator const 25 NurbsCurveEvaluator const 0 0 533 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">601 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 602 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">602 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 603 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">603 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">604 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 603 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">605 20 PN_stdfloat const [] 0 4202496 20 PN_stdfloat const [] 20 PN_stdfloat const [] 0 0 606 -1 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">606 17 PN_stdfloat const 0 8832 17 PN_stdfloat const 17 PN_stdfloat const 0 0 525 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">607 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 546 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">608 26 NurbsSurfaceResult const * 0 8576 26 NurbsSurfaceResult const * 26 NurbsSurfaceResult const * 0 0 609 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">609 24 NurbsSurfaceResult const 0 8832 24 NurbsSurfaceResult const 24 NurbsSurfaceResult const 0 0 534 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">610 20 NurbsSurfaceResult * 0 8576 20 NurbsSurfaceResult * 20 NurbsSurfaceResult * 0 0 534 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">611 23 NurbsSurfaceEvaluator * 0 8576 23 NurbsSurfaceEvaluator * 23 NurbsSurfaceEvaluator * 0 0 535 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">612 29 NurbsSurfaceEvaluator const * 0 8576 29 NurbsSurfaceEvaluator const * 29 NurbsSurfaceEvaluator const * 0 0 613 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">613 27 NurbsSurfaceEvaluator const 0 8832 27 NurbsSurfaceEvaluator const 27 NurbsSurfaceEvaluator const 0 0 535 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">614 10 RopeNode * 0 8576 10 RopeNode * 10 RopeNode * 0 0 537 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">615 16 RopeNode const * 0 8576 16 RopeNode const * 16 RopeNode const * 0 0 616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">616 14 RopeNode const 0 8832 14 RopeNode const 14 RopeNode const 0 0 537 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">617 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 543 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">618 11 SheetNode * 0 8576 11 SheetNode * 11 SheetNode * 0 0 549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">619 17 SheetNode const * 0 8576 17 SheetNode const * 17 SheetNode const * 0 0 620 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">620 15 SheetNode const 0 8832 15 SheetNode const 15 SheetNode const 0 0 549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">8</span>
<span class="s0">621 6 HC_CUT 0 5 1 536 0 1 1 </span>
<span class="s0">622 7 HC_FREE 0 5 2 536 0 1 2 </span>
<span class="s0">623 5 HC_G1 0 5 3 536 0 1 3 </span>
<span class="s0">624 9 HC_SMOOTH 0 5 4 536 0 1 4 </span>
<span class="s0">625 7 PCT_HPR 0 5 2 536 0 1 2 </span>
<span class="s0">626 8 PCT_NONE 0 5 0 536 0 1 0 </span>
<span class="s0">627 5 PCT_T 0 5 3 536 0 1 3 </span>
<span class="s0">628 7 PCT_XYZ 0 5 1 536 0 1 1 </span>
<span class="s0">25</span>
<span class="s0">629 6 curves 0 102 524 302 297 0 0 296 301 0 0 33 ParametricCurveCollection::curves 0</span>

<span class="s0">630 9 xyz_curve 0 2 524 303 0 0 0 0 0 0 0 36 ParametricCurveCollection::xyz_curve 0</span>

<span class="s0">631 9 hpr_curve 0 2 524 304 0 0 0 0 0 0 0 36 ParametricCurveCollection::hpr_curve 0</span>

<span class="s0">632 13 default_curve 0 2 524 305 0 0 0 0 0 0 0 40 ParametricCurveCollection::default_curve 0</span>

<span class="s0">633 15 timewarp_curves 0 66 524 307 0 0 0 0 306 0 0 42 ParametricCurveCollection::timewarp_curves 0</span>

<span class="s0">634 5 max_t 0 2 525 308 0 0 0 0 0 0 0 32 ParametricCurveCollection::max_t 0</span>

<span class="s0">635 7 u_order 0 6 536 448 447 0 0 0 0 0 0 30 NurbsSurfaceEvaluator::u_order 0</span>

<span class="s0">636 7 v_order 0 6 536 450 449 0 0 0 0 0 0 30 NurbsSurfaceEvaluator::v_order 0</span>

<span class="s0">637 7 u_knots 0 70 525 463 462 0 0 0 461 0 0 30 NurbsSurfaceEvaluator::u_knots 0</span>

<span class="s0">638 7 v_knots 0 70 525 467 466 0 0 0 465 0 0 30 NurbsSurfaceEvaluator::v_knots 0</span>

<span class="s0">639 5 curve 0 6 541 475 474 0 0 0 0 0 0 15 RopeNode::curve 0</span>

<span class="s0">640 11 render_mode 0 6 538 477 476 0 0 0 0 0 0 21 RopeNode::render_mode 0</span>

<span class="s0">641 7 uv_mode 0 6 539 479 478 0 0 0 0 0 0 17 RopeNode::uv_mode 0</span>

<span class="s0">642 12 uv_direction 0 6 542 481 480 0 0 0 0 0 0 22 RopeNode::uv_direction 0</span>

<span class="s0">643 8 uv_scale 0 6 525 483 482 0 0 0 0 0 0 18 RopeNode::uv_scale 0</span>

<span class="s0">644 11 normal_mode 0 6 540 485 484 0 0 0 0 0 0 21 RopeNode::normal_mode 0</span>

<span class="s0">645 7 tube_up 0 6 543 487 486 0 0 0 0 0 0 17 RopeNode::tube_up 0</span>

<span class="s0">646 16 use_vertex_color 0 6 542 489 488 0 0 0 0 0 0 26 RopeNode::use_vertex_color 0</span>

<span class="s0">647 22 vertex_color_dimension 0 2 536 490 0 0 0 0 0 0 0 32 RopeNode::vertex_color_dimension 0</span>

<span class="s0">648 10 num_subdiv 0 6 536 492 491 0 0 0 0 0 0 20 RopeNode::num_subdiv 0</span>

<span class="s0">649 10 num_slices 0 6 536 494 493 0 0 0 0 0 0 20 RopeNode::num_slices 0</span>

<span class="s0">650 20 use_vertex_thickness 0 6 542 496 495 0 0 0 0 0 0 30 RopeNode::use_vertex_thickness 0</span>

<span class="s0">651 26 vertex_thickness_dimension 0 2 536 497 0 0 0 0 0 0 0 36 RopeNode::vertex_thickness_dimension 0</span>

<span class="s0">652 9 thickness 0 6 525 499 498 0 0 0 0 0 0 19 RopeNode::thickness 0</span>

<span class="s0">653 6 matrix 0 30 546 503 500 502 501 0 0 0 0 16 RopeNode::matrix 0</span>

<span class="s0">10</span>
<span class="s0">654 10 get_curves 0 301 302 37 ParametricCurveCollection::get_curves 0</span>

<span class="s0">655 19 get_timewarp_curves 0 306 307 46 ParametricCurveCollection::get_timewarp_curves 0</span>

<span class="s0">656 7 get_cvs 0 370 381 28 NurbsCurveInterface::get_cvs 0</span>

<span class="s0">657 9 get_knots 0 371 383 30 NurbsCurveInterface::get_knots 0</span>

<span class="s0">658 13 get_sample_ts 0 406 407 31 NurbsCurveResult::get_sample_ts 0</span>

<span class="s0">659 17 get_sample_points 0 406 408 35 NurbsCurveResult::get_sample_points 0</span>

<span class="s0">660 12 get_vertices 0 414 416 33 NurbsCurveEvaluator::get_vertices 0</span>

<span class="s0">661 9 get_knots 0 422 424 30 NurbsCurveEvaluator::get_knots 0</span>

<span class="s0">662 11 get_u_knots 0 461 463 34 NurbsSurfaceEvaluator::get_u_knots 0</span>

<span class="s0">663 11 get_v_knots 0 465 467 34 NurbsSurfaceEvaluator::get_v_knots 0</span>

</pre>
</body>
</html>