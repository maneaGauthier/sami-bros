<html>
<head>
<title>libp3vision.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3vision.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">11 libp3vision 4 nRMq 14 panda3d.vision </span>
<span class="s0">15</span>
<span class="s0">15 4 make 0 4 30 15 ARToolKit::make 0 1 2 489</span>
<span class="s0">/**</span>
 <span class="s0">* Create a new ARToolKit instance.</span>
 <span class="s0">*</span>
 <span class="s0">* Camera must be the nodepath of a panda camera object.  The panda camera's</span>
 <span class="s0">* field of view is initialized to match the field of view of the physical</span>
 <span class="s0">* webcam.  Each time you call analyze, all marker nodepaths will be moved</span>
 <span class="s0">* into a position which is relative to this camera.  The marker_size</span>
 <span class="s0">* parameter indicates how large you printed the physical markers.  You should</span>
 <span class="s0">* use the same size units that you wish to use in the panda code.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">static ARToolKit *ARToolKit::make(NodePath camera, Filename const &amp;paramfile, double markersize);</span>

<span class="s0">16 10 ~ARToolKit 0 516 30 21 ARToolKit::~ARToolKit 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">ARToolKit::~ARToolKit(void);</span>

<span class="s0">17 13 set_threshold 0 4 30 24 ARToolKit::set_threshold 0 1 3 193</span>
<span class="s0">/**</span>
 <span class="s0">* As part of its analysis, the ARToolKit occasionally converts images to</span>
 <span class="s0">* black and white by thresholding them.  The threshold is set to 0.5 by</span>
 <span class="s0">* default, but you can tweak it here.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void ARToolKit::set_threshold(double n);</span>

<span class="s0">18 14 attach_pattern 0 4 30 25 ARToolKit::attach_pattern 0 1 4 213</span>
<span class="s0">/**</span>
 <span class="s0">* Associates the specified glyph with the specified NodePath.  Each time you</span>
 <span class="s0">* call analyze, ARToolKit will update the NodePath's transform.  If the node</span>
 <span class="s0">* is not visible, its scale will be set to zero.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">void ARToolKit::attach_pattern(Filename const &amp;pattern, NodePath path);</span>

<span class="s0">19 15 detach_patterns 0 4 30 26 ARToolKit::detach_patterns 0 1 5 55</span>
<span class="s0">/**</span>
 <span class="s0">* Dissociates all patterns from all NodePaths.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void ARToolKit::detach_patterns(void);</span>

<span class="s0">20 7 analyze 0 4 30 18 ARToolKit::analyze 0 1 6 334</span>
<span class="s0">/**</span>
 <span class="s0">* Analyzes the non-pad region of the specified texture.  This causes all</span>
 <span class="s0">* attached nodepaths to move.  The parameter do_flip_texture is true by</span>
 <span class="s0">* default, because Panda's representation of textures is upside down from</span>
 <span class="s0">* ARToolKit.  If you already have a texture that's upside-down, however, you</span>
 <span class="s0">* should set it to false.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void ARToolKit::analyze(Texture *tex, bool do_flip_texture = true);</span>

<span class="s0">21 9 ARToolKit 0 260 30 20 ARToolKit::ARToolKit 0 1 1 54</span>
<span class="s0">/**</span>
 <span class="s0">* Use ARToolKit::make to create an ARToolKit.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline ARToolKit::ARToolKit(ARToolKit const &amp;) = default;</span>

<span class="s0">22 15 get_num_options 0 4 31 28 WebcamVideo::get_num_options 0 1 7 198</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of webcam options.  An &quot;option&quot; consists of a device</span>
 <span class="s0">* plus a set of configuration parameters.  For example, &quot;Creative Webcam Live</span>
 <span class="s0">* at 640x480, 30 fps&quot; is an option.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">static int WebcamVideo::get_num_options(void);</span>

<span class="s0">23 10 get_option 0 4 31 23 WebcamVideo::get_option 0 1 8 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth webcam option.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static PointerTo&lt; WebcamVideo &gt; WebcamVideo::get_option(int n);</span>

<span class="s0">24 10 get_size_x 0 4 31 23 WebcamVideo::get_size_x 0 1 9 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the camera's size_x.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int WebcamVideo::get_size_x(void) const;</span>

<span class="s0">25 10 get_size_y 0 4 31 23 WebcamVideo::get_size_y 0 1 10 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the camera's size_y.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int WebcamVideo::get_size_y(void) const;</span>

<span class="s0">26 7 get_fps 0 4 31 20 WebcamVideo::get_fps 0 1 11 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the camera's framerate.  This is a maximum theoretical: the actual</span>
 <span class="s0">* performance will depend on the speed of the hardware.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline double WebcamVideo::get_fps(void) const;</span>

<span class="s0">27 16 get_pixel_format 0 4 31 29 WebcamVideo::get_pixel_format 0 1 12 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the camera's pixel format, as a FourCC code, if known.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline std::string const &amp;WebcamVideo::get_pixel_format(void) const;</span>

<span class="s0">28 6 output 0 4 31 19 WebcamVideo::output 0 1 13 112</span>
<span class="s0">/**</span>
 <span class="s0">* Outputs the WebcamVideo.  This function simply writes the name, size and</span>
 <span class="s0">* FPS to the output stream.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void WebcamVideo::output(std::ostream &amp;out) const;</span>

<span class="s0">29 14 get_class_type 0 4 31 27 WebcamVideo::get_class_type 0 1 14 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle WebcamVideo::get_class_type(void);</span>

<span class="s0">14</span>
<span class="s0">1 0 0 15 8 36 16 0 0 1 6 param0 0 34  </span>
<span class="s0">2 0 0 22 2 36 0 0 489 /**</span>
 <span class="s0">* Create a new ARToolKit instance.</span>
 <span class="s0">*</span>
 <span class="s0">* Camera must be the nodepath of a panda camera object.  The panda camera's</span>
 <span class="s0">* field of view is initialized to match the field of view of the physical</span>
 <span class="s0">* webcam.  Each time you call analyze, all marker nodepaths will be moved</span>
 <span class="s0">* into a position which is relative to this camera.  The marker_size</span>
 <span class="s0">* parameter indicates how large you printed the physical markers.  You should</span>
 <span class="s0">* use the same size units that you wish to use in the panda code.</span>
 <span class="s0">*/ 3 6 camera 1 37  9 paramfile 1 39  10 markersize 1 42  </span>
<span class="s0">3 0 0 4 4 43 0 0 193 /**</span>
 <span class="s0">* As part of its analysis, the ARToolKit occasionally converts images to</span>
 <span class="s0">* black and white by thresholding them.  The threshold is set to 0.5 by</span>
 <span class="s0">* default, but you can tweak it here.</span>
 <span class="s0">*/ 2 4 this 3 36  1 n 1 42  </span>
<span class="s0">4 0 0 4 5 43 0 0 213 /**</span>
 <span class="s0">* Associates the specified glyph with the specified NodePath.  Each time you</span>
 <span class="s0">* call analyze, ARToolKit will update the NodePath's transform.  If the node</span>
 <span class="s0">* is not visible, its scale will be set to zero.</span>
 <span class="s0">*/ 3 4 this 3 36  7 pattern 1 39  4 path 1 37  </span>
<span class="s0">5 0 0 4 6 43 0 0 55 /**</span>
 <span class="s0">* Dissociates all patterns from all NodePaths.</span>
 <span class="s0">*/ 1 4 this 3 36  </span>
<span class="s0">6 0 0 4 7 43 0 0 334 /**</span>
 <span class="s0">* Analyzes the non-pad region of the specified texture.  This causes all</span>
 <span class="s0">* attached nodepaths to move.  The parameter do_flip_texture is true by</span>
 <span class="s0">* default, because Panda's representation of textures is upside down from</span>
 <span class="s0">* ARToolKit.  If you already have a texture that's upside-down, however, you</span>
 <span class="s0">* should set it to false.</span>
 <span class="s0">*/ 3 4 this 3 36  3 tex 1 44  15 do_flip_texture 5 46  </span>
<span class="s0">7 0 0 6 11 47 0 0 198 /**</span>
 <span class="s0">* Returns the number of webcam options.  An &quot;option&quot; consists of a device</span>
 <span class="s0">* plus a set of configuration parameters.  For example, &quot;Creative Webcam Live</span>
 <span class="s0">* at 640x480, 30 fps&quot; is an option.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">8 0 0 7 12 48 0 0 41 /**</span>
 <span class="s0">* Returns the nth webcam option.</span>
 <span class="s0">*/ 1 1 n 1 47  </span>
<span class="s0">9 0 0 6 16 47 0 0 39 /**</span>
 <span class="s0">* Returns the camera's size_x.</span>
 <span class="s0">*/ 1 4 this 3 49  </span>
<span class="s0">10 0 0 6 17 47 0 0 39 /**</span>
 <span class="s0">* Returns the camera's size_y.</span>
 <span class="s0">*/ 1 4 this 3 49  </span>
<span class="s0">11 0 0 6 18 42 0 0 142 /**</span>
 <span class="s0">* Returns the camera's framerate.  This is a maximum theoretical: the actual</span>
 <span class="s0">* performance will depend on the speed of the hardware.</span>
 <span class="s0">*/ 1 4 this 3 49  </span>
<span class="s0">12 0 0 6 19 51 0 0 73 /**</span>
 <span class="s0">* Returns the camera's pixel format, as a FourCC code, if known.</span>
 <span class="s0">*/ 1 4 this 3 49  </span>
<span class="s0">13 0 0 4 20 43 0 0 112 /**</span>
 <span class="s0">* Outputs the WebcamVideo.  This function simply writes the name, size and</span>
 <span class="s0">* FPS to the output stream.</span>
 <span class="s0">*/ 2 4 this 3 49  3 out 1 52  </span>
<span class="s0">14 0 0 7 21 55 0 0 0 0 </span>
<span class="s0">26</span>
<span class="s0">30 9 ARToolKit 0 26625 9 ARToolKit 9 ARToolKit 0 0 0 1 21 16 0 5 15 17 18 19 20 0 0 0 0 0 636</span>
<span class="s0">/**</span>
 <span class="s0">* ARToolKit is a software library for building Augmented Reality (AR)</span>
 <span class="s0">* applications.  These are applications that involve the overlay of virtual</span>
 <span class="s0">* imagery on the real world.  It was developed by Dr.  Hirokazu Kato.  Its</span>
 <span class="s0">* ongoing development is being supported by the Human Interface Technology</span>
 <span class="s0">* Laboratory (HIT Lab) at the University of Washington, HIT Lab NZ at the</span>
 <span class="s0">* University of Canterbury, New Zealand, and ARToolworks, Inc, Seattle.  It</span>
 <span class="s0">* is available under a GPL license.  It is also possible to negotiate other</span>
 <span class="s0">* licenses with the copyright holders.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is a wrapper around the ARToolKit library.</span>
 <span class="s0">*/</span>

<span class="s0">31 11 WebcamVideo 0 75777 11 WebcamVideo 11 WebcamVideo 0 0 0 0 0 1 56 8 22 23 24 25 26 27 28 29 1 57 0 1 0 32 0 0 0 0 90</span>
<span class="s0">/**</span>
 <span class="s0">* Allows you to open a webcam or other video capture device as a video</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/</span>

<span class="s0">32 10 MovieVideo 0 2048 10 MovieVideo 10 MovieVideo 0 0 0 0 0 0 0 0 0 0 0 0 400</span>
<span class="s0">/**</span>
 <span class="s0">* A MovieVideo is actually any source that provides a sequence of video</span>
 <span class="s0">* frames.  That could include an AVI file, a digital camera, or an internet</span>
 <span class="s0">* TV station.</span>
 <span class="s0">*</span>
 <span class="s0">* The difference between a MovieVideo and a MovieVideoCursor is like the</span>
 <span class="s0">* difference between a filename and a file handle.  The MovieVideo just</span>
 <span class="s0">* indicates a particular movie.  The MovieVideoCursor is what allows access.</span>
 <span class="s0">*/</span>

<span class="s0">33 24 PointerTo&lt; WebcamVideo &gt; 0 2048 24 PointerTo&lt; WebcamVideo &gt; 24 PointerTo&lt; WebcamVideo &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">34 17 ARToolKit const * 0 8576 17 ARToolKit const * 17 ARToolKit const * 0 0 35 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">35 15 ARToolKit const 0 8832 15 ARToolKit const 15 ARToolKit const 0 0 30 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">36 11 ARToolKit * 0 8576 11 ARToolKit * 11 ARToolKit * 0 0 30 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">37 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 38 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">38 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">39 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 40 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">40 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 41 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">41 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">42 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">43 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">44 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 45 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">45 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a texture object, which is typically a single 2-d image but may</span>
 <span class="s0">* also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube</span>
 <span class="s0">* map texture.</span>
 <span class="s0">*</span>
 <span class="s0">* A texture's image data might be stored in system RAM (see get_ram_image())</span>
 <span class="s0">* or its image may be represented in texture memory on one or more</span>
 <span class="s0">* GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern</span>
 <span class="s0">* is that a texture is loaded from an image file on disk, which copies its</span>
 <span class="s0">* image data into system RAM; then the first time the texture is rendered its</span>
 <span class="s0">* image data is copied to texture memory (actually, to the graphics API), and</span>
 <span class="s0">* the system RAM image is automatically freed.</span>
 <span class="s0">*/</span>

<span class="s0">46 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">47 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">48 13 WebcamVideo * 0 8576 13 WebcamVideo * 13 WebcamVideo * 0 0 31 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">49 19 WebcamVideo const * 0 8576 19 WebcamVideo const * 19 WebcamVideo const * 0 0 50 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">50 17 WebcamVideo const 0 8832 17 WebcamVideo const 17 WebcamVideo const 0 0 31 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">51 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">52 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 53 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">53 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">54 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">55 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 54 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">1</span>
<span class="s0">56 7 options 0 66 33 23 0 0 0 0 22 0 0 20 WebcamVideo::options 0</span>

<span class="s0">1</span>
<span class="s0">57 11 get_options 0 22 23 24 WebcamVideo::get_options 0</span>

</pre>
</body>
</html>