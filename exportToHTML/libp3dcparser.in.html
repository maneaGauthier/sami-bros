<html>
<head>
<title>libp3dcparser.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3dcparser.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">13 libp3dcparser 4 zIbG 14 panda3d.direct </span>
<span class="s0">236</span>
<span class="s0">247 18 ~DCPackerInterface 0 518 485 37 DCPackerInterface::~DCPackerInterface 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">virtual DCPackerInterface::~DCPackerInterface(void);</span>

<span class="s0">248 8 get_name 0 4 485 27 DCPackerInterface::get_name 0 1 1 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this field, or empty string if the field is unnamed.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::string const &amp;DCPackerInterface::get_name(void) const;</span>

<span class="s0">249 15 find_seek_index 0 4 485 34 DCPackerInterface::find_seek_index 0 1 2 491</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number to be passed to a future call to DCPacker::seek()</span>
 <span class="s0">* to seek directly to the named field without having to look up the field</span>
 <span class="s0">* name in a table later, or -1 if the named field cannot be found.</span>
 <span class="s0">*</span>
 <span class="s0">* If the named field is nested within a switch or some similar dynamic</span>
 <span class="s0">* structure that reveals different fields based on the contents of the data,</span>
 <span class="s0">* this mechanism cannot be used to pre-fetch the field index number--you must</span>
 <span class="s0">* seek for the field by name.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">int DCPackerInterface::find_seek_index(std::string const &amp;name) const;</span>

<span class="s0">250 8 as_field 0 6 485 27 DCPackerInterface::as_field 0 2 3 4 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">virtual DCField *DCPackerInterface::as_field(void);</span>
<span class="s0">virtual DCField const *DCPackerInterface::as_field(void) const;</span>

<span class="s0">251 19 as_switch_parameter 0 6 485 38 DCPackerInterface::as_switch_parameter 0 2 5 6 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void);</span>
<span class="s0">virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const;</span>

<span class="s0">252 18 as_class_parameter 0 6 485 37 DCPackerInterface::as_class_parameter 0 2 7 8 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">virtual DCClassParameter *DCPackerInterface::as_class_parameter(void);</span>
<span class="s0">virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const;</span>

<span class="s0">253 11 check_match 0 4 485 30 DCPackerInterface::check_match 0 2 9 10 553</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the other interface is bitwise the same as this one--that</span>
 <span class="s0">* is, a uint32 only matches a uint32, etc.  Names of components, and range</span>
 <span class="s0">* limits, are not compared.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if this interface is bitwise the same as the interface</span>
 <span class="s0">* described with the indicated formatted string, e.g.  &quot;(uint8, uint8,</span>
 <span class="s0">* int16)&quot;, or false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* If DCFile is not NULL, it specifies the DCFile that was previously loaded,</span>
 <span class="s0">* from which some predefined structs and typedefs may be referenced in the</span>
 <span class="s0">* description string.</span>
 <span class="s0">*/</span>
<span class="s0">182</span>
<span class="s0">inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const;</span>
<span class="s0">bool DCPackerInterface::check_match(std::string const &amp;description, DCFile *dcfile = nullptr) const;</span>

<span class="s0">254 14 ~DCKeywordList 0 516 486 29 DCKeywordList::~DCKeywordList 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">DCKeywordList::~DCKeywordList(void);</span>

<span class="s0">255 11 has_keyword 0 4 486 26 DCKeywordList::has_keyword 0 2 11 12 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this list includes the indicated keyword, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if this list includes the indicated keyword, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">bool DCKeywordList::has_keyword(std::string const &amp;name) const;</span>
<span class="s0">bool DCKeywordList::has_keyword(DCKeyword const *keyword) const;</span>

<span class="s0">256 16 get_num_keywords 0 4 486 31 DCKeywordList::get_num_keywords 0 1 13 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of keywords in the list.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int DCKeywordList::get_num_keywords(void) const;</span>

<span class="s0">257 11 get_keyword 0 4 486 26 DCKeywordList::get_keyword 0 1 14 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth keyword in the list.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">DCKeyword const *DCKeywordList::get_keyword(int n) const;</span>

<span class="s0">258 19 get_keyword_by_name 0 4 486 34 DCKeywordList::get_keyword_by_name 0 1 15 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the keyword in the list with the indicated name, or NULL if there</span>
 <span class="s0">* is no keyword in the list with that name.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">DCKeyword const *DCKeywordList::get_keyword_by_name(std::string const &amp;name) const;</span>

<span class="s0">259 16 compare_keywords 0 4 486 31 DCKeywordList::compare_keywords 0 1 16 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this list has the same keywords as the other list, false if</span>
 <span class="s0">* some keywords differ.  Order is not considered important.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">bool DCKeywordList::compare_keywords(DCKeywordList const &amp;other) const;</span>

<span class="s0">260 27 upcast_to_DCPackerInterface 0 12 487 36 DCField::upcast_to_DCPackerInterface 0 1 50 40</span>
<span class="s0">upcast from DCField to DCPackerInterface</span>
<span class="s0">62</span>
<span class="s0">DCPackerInterface *DCField::upcast_to_DCPackerInterface(void);</span>

<span class="s0">261 19 downcast_to_DCField 0 12 485 38 DCPackerInterface::downcast_to_DCField 0 0 42</span>
<span class="s0">downcast from DCPackerInterface to DCField</span>
<span class="s0">54</span>
<span class="s0">DCField *DCPackerInterface::downcast_to_DCField(void);</span>

<span class="s0">262 23 upcast_to_DCKeywordList 0 12 487 32 DCField::upcast_to_DCKeywordList 0 1 51 36</span>
<span class="s0">upcast from DCField to DCKeywordList</span>
<span class="s0">54</span>
<span class="s0">DCKeywordList *DCField::upcast_to_DCKeywordList(void);</span>

<span class="s0">263 19 downcast_to_DCField 0 12 486 34 DCKeywordList::downcast_to_DCField 0 0 38</span>
<span class="s0">downcast from DCKeywordList to DCField</span>
<span class="s0">50</span>
<span class="s0">DCField *DCKeywordList::downcast_to_DCField(void);</span>

<span class="s0">264 8 ~DCField 0 518 487 17 DCField::~DCField 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">virtual DCField::~DCField(void);</span>

<span class="s0">265 10 get_number 0 4 487 19 DCField::get_number 0 1 17 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unique index number associated with this field.  This is defined</span>
 <span class="s0">* implicitly when the .dc file(s) are read.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int DCField::get_number(void) const;</span>

<span class="s0">266 9 get_class 0 4 487 18 DCField::get_class 0 1 18 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DCClass pointer for the class that contains this field.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline DCClass *DCField::get_class(void) const;</span>

<span class="s0">267 8 as_field 0 6 487 17 DCField::as_field 0 2 19 20 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">virtual DCField *DCField::as_field(void);</span>
<span class="s0">virtual DCField const *DCField::as_field(void) const;</span>

<span class="s0">268 15 as_atomic_field 0 6 487 24 DCField::as_atomic_field 0 2 21 22 288</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the same field pointer converted to an atomic field pointer, if</span>
 <span class="s0">* this is in fact an atomic field; otherwise, returns NULL.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the same field pointer converted to an atomic field pointer, if</span>
 <span class="s0">* this is in fact an atomic field; otherwise, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">virtual DCAtomicField *DCField::as_atomic_field(void);</span>
<span class="s0">virtual DCAtomicField const *DCField::as_atomic_field(void) const;</span>

<span class="s0">269 18 as_molecular_field 0 6 487 27 DCField::as_molecular_field 0 2 23 24 296</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the same field pointer converted to a molecular field pointer, if</span>
 <span class="s0">* this is in fact a molecular field; otherwise, returns NULL.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the same field pointer converted to a molecular field pointer, if</span>
 <span class="s0">* this is in fact a molecular field; otherwise, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">virtual DCMolecularField *DCField::as_molecular_field(void);</span>
<span class="s0">virtual DCMolecularField const *DCField::as_molecular_field(void) const;</span>

<span class="s0">270 12 as_parameter 0 6 487 21 DCField::as_parameter 0 2 25 26 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">virtual DCParameter *DCField::as_parameter(void);</span>
<span class="s0">virtual DCParameter const *DCField::as_parameter(void) const;</span>

<span class="s0">271 11 format_data 0 4 487 20 DCField::format_data 0 1 27 175</span>
<span class="s0">/**</span>
 <span class="s0">* Given a blob that represents the packed data for this field, returns a</span>
 <span class="s0">* string formatting it for human consumption.  Returns empty string if there</span>
 <span class="s0">* is an error.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">std::string DCField::format_data(vector_uchar const &amp;packed_data, bool show_field_names = true);</span>

<span class="s0">272 12 parse_string 0 4 487 21 DCField::parse_string 0 1 28 243</span>
<span class="s0">/**</span>
 <span class="s0">* Given a human-formatted string (for instance, as returned by format_data(),</span>
 <span class="s0">* above) that represents the value of this field, parse the string and return</span>
 <span class="s0">* the corresponding packed data.  Returns empty string if there is an error.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">vector_uchar DCField::parse_string(std::string const &amp;formatted_string);</span>

<span class="s0">273 15 validate_ranges 0 4 487 24 DCField::validate_ranges 0 1 29 221</span>
<span class="s0">/**</span>
 <span class="s0">* Verifies that all of the packed values in the field data are within the</span>
 <span class="s0">* specified ranges and that there are no extra bytes on the end of the</span>
 <span class="s0">* record.  Returns true if all fields are valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool DCField::validate_ranges(vector_uchar const &amp;packed_data) const;</span>

<span class="s0">274 17 has_default_value 0 4 487 26 DCField::has_default_value 0 1 30 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a default value has been explicitly established for this</span>
 <span class="s0">* field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool DCField::has_default_value(void) const;</span>

<span class="s0">275 17 get_default_value 0 4 487 26 DCField::get_default_value 0 1 31 218</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default value for this field.  If a default value has been</span>
 <span class="s0">* explicitly set (e.g.  has_default_value() returns true), returns that</span>
 <span class="s0">* value; otherwise, returns an implicit default for the field.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline vector_uchar const &amp;DCField::get_default_value(void) const;</span>

<span class="s0">276 14 is_bogus_field 0 4 487 23 DCField::is_bogus_field 0 1 32 251</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the field has been flagged as a bogus field.  This is set</span>
 <span class="s0">* for fields that are generated by the parser as placeholder for missing</span>
 <span class="s0">* fields, as when reading a partial file; it should not occur in a normal</span>
 <span class="s0">* valid dc file.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool DCField::is_bogus_field(void) const;</span>

<span class="s0">277 11 is_required 0 4 487 20 DCField::is_required 0 1 33 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;required&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool DCField::is_required(void) const;</span>

<span class="s0">278 12 is_broadcast 0 4 487 21 DCField::is_broadcast 0 1 34 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;broadcast&quot; flag is set for this field, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool DCField::is_broadcast(void) const;</span>

<span class="s0">279 6 is_ram 0 4 487 15 DCField::is_ram 0 1 35 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;ram&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool DCField::is_ram(void) const;</span>

<span class="s0">280 5 is_db 0 4 487 14 DCField::is_db 0 1 36 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;db&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline bool DCField::is_db(void) const;</span>

<span class="s0">281 9 is_clsend 0 4 487 18 DCField::is_clsend 0 1 37 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;clsend&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool DCField::is_clsend(void) const;</span>

<span class="s0">282 9 is_clrecv 0 4 487 18 DCField::is_clrecv 0 1 38 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;clrecv&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool DCField::is_clrecv(void) const;</span>

<span class="s0">283 10 is_ownsend 0 4 487 19 DCField::is_ownsend 0 1 39 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;ownsend&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool DCField::is_ownsend(void) const;</span>

<span class="s0">284 10 is_ownrecv 0 4 487 19 DCField::is_ownrecv 0 1 40 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;ownrecv&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool DCField::is_ownrecv(void) const;</span>

<span class="s0">285 9 is_airecv 0 4 487 18 DCField::is_airecv 0 1 41 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;airecv&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool DCField::is_airecv(void) const;</span>

<span class="s0">286 6 output 0 4 487 15 DCField::output 0 1 42 67</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void DCField::output(std::ostream &amp;out) const;</span>

<span class="s0">287 5 write 0 4 487 14 DCField::write 0 1 43 67</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void DCField::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">288 9 pack_args 0 4 487 18 DCField::pack_args 0 1 44 200</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the Python arguments from the indicated tuple into the packer.</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* It is assumed that the packer is currently positioned on this field.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">bool DCField::pack_args(DCPacker &amp;packer, PyObject *sequence) const;</span>

<span class="s0">289 11 unpack_args 0 4 487 20 DCField::unpack_args 0 1 45 220</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the values from the packer, beginning at the current point in the</span>
 <span class="s0">* unpack_buffer, into a Python tuple and returns the tuple.</span>
 <span class="s0">*</span>
 <span class="s0">* It is assumed that the packer is currently positioned on this field.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">PyObject *DCField::unpack_args(DCPacker &amp;packer) const;</span>

<span class="s0">290 14 receive_update 0 4 487 23 DCField::receive_update 0 1 46 135</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts the update message out of the datagram and applies it to the</span>
 <span class="s0">* indicated object by calling the appropriate method.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void DCField::receive_update(DCPacker &amp;packer, PyObject *distobj) const;</span>

<span class="s0">291 20 client_format_update 0 4 487 29 DCField::client_format_update 0 1 47 139</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update for</span>
 <span class="s0">* the indicated distributed object from the client.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">Datagram DCField::client_format_update(DOID_TYPE do_id, PyObject *args) const;</span>

<span class="s0">292 16 ai_format_update 0 4 487 25 DCField::ai_format_update 0 1 48 135</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update for</span>
 <span class="s0">* the indicated distributed object from the AI.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">Datagram DCField::ai_format_update(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const;</span>

<span class="s0">293 25 ai_format_update_msg_type 0 4 487 34 DCField::ai_format_update_msg_type 0 1 49 155</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update,</span>
 <span class="s0">* with the msg type, for the indicated distributed object from the AI.</span>
 <span class="s0">*/</span>
<span class="s0">139</span>
<span class="s0">Datagram DCField::ai_format_update_msg_type(DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const;</span>

<span class="s0">294 10 DCPackData 0 260 488 22 DCPackData::DCPackData 0 2 52 53 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">inline DCPackData::DCPackData(void);</span>
<span class="s0">inline DCPackData::DCPackData(DCPackData const &amp;) = default;</span>

<span class="s0">295 11 ~DCPackData 0 516 488 23 DCPackData::~DCPackData 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline DCPackData::~DCPackData(void);</span>

<span class="s0">296 5 clear 0 4 488 17 DCPackData::clear 0 1 54 98</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the contents of the data (without necessarily freeing its allocated</span>
 <span class="s0">* memory).</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">inline void DCPackData::clear(void);</span>

<span class="s0">297 10 get_string 0 4 488 22 DCPackData::get_string 0 1 55 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data buffer as a string.  Also see get_data().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline std::string DCPackData::get_string(void) const;</span>

<span class="s0">298 10 get_length 0 4 488 22 DCPackData::get_length 0 1 56 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current length of the buffer.  This is the number of useful</span>
 <span class="s0">* bytes stored in the buffer, not the amount of memory it takes up.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline std::size_t DCPackData::get_length(void) const;</span>

<span class="s0">299 8 DCPacker 0 260 489 18 DCPacker::DCPacker 0 2 57 58 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">DCPacker::DCPacker(void);</span>
<span class="s0">inline DCPacker::DCPacker(DCPacker const &amp;) = default;</span>

<span class="s0">300 9 ~DCPacker 0 516 489 19 DCPacker::~DCPacker 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">26</span>
<span class="s0">DCPacker::~DCPacker(void);</span>

<span class="s0">301 10 clear_data 0 4 489 20 DCPacker::clear_data 0 1 59 190</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the data in the pack buffer and unpack buffer.  This should be</span>
 <span class="s0">* called between calls to begin_pack(), unless you want to concatenate all of</span>
 <span class="s0">* the pack results together.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline void DCPacker::clear_data(void);</span>

<span class="s0">302 10 begin_pack 0 4 489 20 DCPacker::begin_pack 0 1 60 390</span>
<span class="s0">/**</span>
 <span class="s0">* Begins a packing session.  The parameter is the DC object that describes</span>
 <span class="s0">* the packing format; it may be a DCParameter or DCField.</span>
 <span class="s0">*</span>
 <span class="s0">* Unless you call clear_data() between sessions, multiple packing sessions</span>
 <span class="s0">* will be concatenated together into the same buffer.  If you wish to add</span>
 <span class="s0">* bytes to the buffer between packing sessions, use append_data() or</span>
 <span class="s0">* get_write_pointer().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void DCPacker::begin_pack(DCPackerInterface const *root);</span>

<span class="s0">303 8 end_pack 0 4 489 18 DCPacker::end_pack 0 1 61 138</span>
<span class="s0">/**</span>
 <span class="s0">* Finishes a packing session.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true on success, or false if there has been some error</span>
 <span class="s0">* during packing.</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">bool DCPacker::end_pack(void);</span>

<span class="s0">304 15 set_unpack_data 0 4 489 25 DCPacker::set_unpack_data 0 1 62 284</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the unpack_data pointer.  You may call this before calling the</span>
 <span class="s0">* version of begin_unpack() that takes only one parameter.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up the unpack_data pointer.  You may call this before calling the</span>
 <span class="s0">* version of begin_unpack() that takes only one parameter.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void DCPacker::set_unpack_data(vector_uchar const &amp;data);</span>

<span class="s0">305 12 begin_unpack 0 4 489 22 DCPacker::begin_unpack 0 1 63 375</span>
<span class="s0">/**</span>
 <span class="s0">* Begins an unpacking session.  You must have previously called</span>
 <span class="s0">* set_unpack_data() to specify a buffer to unpack.</span>
 <span class="s0">*</span>
 <span class="s0">* If there was data left in the buffer after a previous begin_unpack() ..</span>
 <span class="s0">* end_unpack() session, the new session will resume from the current point.</span>
 <span class="s0">* This method may be used, therefore, to unpack a sequence of objects from</span>
 <span class="s0">* the same buffer.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void DCPacker::begin_unpack(DCPackerInterface const *root);</span>

<span class="s0">306 10 end_unpack 0 4 489 20 DCPacker::end_unpack 0 1 64 186</span>
<span class="s0">/**</span>
 <span class="s0">* Finishes the unpacking session.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true on success, or false if there has been some error</span>
 <span class="s0">* during unpacking (or if all fields have not been unpacked).</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">bool DCPacker::end_unpack(void);</span>

<span class="s0">307 12 begin_repack 0 4 489 22 DCPacker::begin_repack 0 1 65 562</span>
<span class="s0">/**</span>
 <span class="s0">* Begins a repacking session.  You must have previously called</span>
 <span class="s0">* set_unpack_data() to specify a buffer to unpack.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike begin_pack() or begin_unpack() you may not concatenate the results</span>
 <span class="s0">* of multiple begin_repack() sessions in one buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, unlike in packing or unpacking modes, you may not walk through the</span>
 <span class="s0">* fields from beginning to end, or even pack two consecutive fields at once.</span>
 <span class="s0">* Instead, you must call seek() for each field you wish to modify and pack</span>
 <span class="s0">* only that one field; then call seek() again to modify another field.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void DCPacker::begin_repack(DCPackerInterface const *root);</span>

<span class="s0">308 10 end_repack 0 4 489 20 DCPacker::end_repack 0 1 66 186</span>
<span class="s0">/**</span>
 <span class="s0">* Finishes the repacking session.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true on success, or false if there has been some error</span>
 <span class="s0">* during repacking (or if all fields have not been repacked).</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">bool DCPacker::end_repack(void);</span>

<span class="s0">309 4 seek 0 4 489 14 DCPacker::seek 0 2 67 68 709</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the current unpack (or repack) position to the named field.  In unpack</span>
 <span class="s0">* mode, the next call to unpack_*() or push() will begin to read the named</span>
 <span class="s0">* field.  In repack mode, the next call to pack_*() or push() will modify the</span>
 <span class="s0">* named field.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false if the field is not known (or if the</span>
 <span class="s0">* packer is in an invalid mode).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Seeks to the field indentified by seek_index, which was returned by an</span>
 <span class="s0">* earlier call to DCField::find_seek_index() to get the index of some nested</span>
 <span class="s0">* field.  Also see the version of seek() that accepts a field name.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false if the field is not known (or if the</span>
 <span class="s0">* packer is in an invalid mode).</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">bool DCPacker::seek(std::string const &amp;field_name);</span>
<span class="s0">bool DCPacker::seek(int seek_index);</span>

<span class="s0">310 17 has_nested_fields 0 4 489 27 DCPacker::has_nested_fields 0 1 69 254</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the current field has any nested fields (and thus expects a</span>
 <span class="s0">* push() .. pop() interface), or false otherwise.  If this returns true,</span>
 <span class="s0">* get_num_nested_fields() may be called to determine how many nested fields</span>
 <span class="s0">* are expected.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool DCPacker::has_nested_fields(void) const;</span>

<span class="s0">311 21 get_num_nested_fields 0 4 489 31 DCPacker::get_num_nested_fields 0 1 70 517</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of nested fields associated with the current field, if</span>
 <span class="s0">* has_nested_fields() returned true.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value may be -1 to indicate that a variable number of nested</span>
 <span class="s0">* fields are accepted by this field type (e.g.  a variable-length array).</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this method is unreliable to determine how many fields you must</span>
 <span class="s0">* traverse before you can call pop(), since particularly in the presence of a</span>
 <span class="s0">* DCSwitch, it may change during traversal.  Use more_nested_fields()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int DCPacker::get_num_nested_fields(void) const;</span>

<span class="s0">312 18 more_nested_fields 0 4 489 28 DCPacker::more_nested_fields 0 1 71 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there are more nested fields to pack or unpack in the</span>
 <span class="s0">* current push sequence, false if it is time to call pop().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool DCPacker::more_nested_fields(void) const;</span>

<span class="s0">313 18 get_current_parent 0 4 489 28 DCPacker::get_current_parent 0 1 72 175</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the field that we left in our last call to push(): the owner of the</span>
 <span class="s0">* current level of fields.  This may be NULL at the beginning of the pack</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline DCPackerInterface const *DCPacker::get_current_parent(void) const;</span>

<span class="s0">314 17 get_current_field 0 4 489 27 DCPacker::get_current_field 0 1 73 197</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the field that will be referenced by the next call to pack_*() or</span>
 <span class="s0">* unpack_*().  This will be NULL if we have unpacked (or packed) all fields,</span>
 <span class="s0">* or if it is time to call pop().</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline DCPackerInterface const *DCPacker::get_current_field(void) const;</span>

<span class="s0">315 15 get_last_switch 0 4 489 25 DCPacker::get_last_switch 0 1 74 428</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the last DCSwitch instance that we have passed by and</span>
 <span class="s0">* selected one case of during the pack/unpack process.  Each time we</span>
 <span class="s0">* encounter a new DCSwitch and select a case, this will change state.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used to detect when a DCSwitch has been selected.  At the</span>
 <span class="s0">* moment this changes state, get_current_parent() will contain the particular</span>
 <span class="s0">* SwitchCase that was selected by the switch.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline DCSwitchParameter const *DCPacker::get_last_switch(void) const;</span>

<span class="s0">316 13 get_pack_type 0 4 489 23 DCPacker::get_pack_type 0 1 75 438</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of value expected by the current field.  See the</span>
 <span class="s0">* enumerated type definition at the top of DCPackerInterface.h.  If this</span>
 <span class="s0">* returns one of PT_double, PT_int, PT_int64, or PT_string, then you should</span>
 <span class="s0">* call the corresponding pack_double(), pack_int() function (or</span>
 <span class="s0">* unpack_double(), unpack_int(), etc.) to transfer data.  Otherwise, you</span>
 <span class="s0">* should call push() and begin packing or unpacking the nested fields.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline DCPackType DCPacker::get_pack_type(void) const;</span>

<span class="s0">317 22 get_current_field_name 0 4 489 32 DCPacker::get_current_field_name 0 1 76 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the current field, if it has a name, or the empty</span>
 <span class="s0">* string if the field does not have a name or there is no current field.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::string DCPacker::get_current_field_name(void) const;</span>

<span class="s0">318 4 push 0 4 489 14 DCPacker::push 0 1 77 315</span>
<span class="s0">/**</span>
 <span class="s0">* Marks the beginning of a nested series of fields.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called before filling the elements of an array or the</span>
 <span class="s0">* individual fields in a structure field.  It must also be balanced by a</span>
 <span class="s0">* matching pop().</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to use push() / pop() only if has_nested_fields() returns</span>
 <span class="s0">* true.</span>
 <span class="s0">*/</span>
<span class="s0">26</span>
<span class="s0">void DCPacker::push(void);</span>

<span class="s0">319 3 pop 0 4 489 13 DCPacker::pop 0 1 78 234</span>
<span class="s0">/**</span>
 <span class="s0">* Marks the end of a nested series of fields.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called to match a previous push() only after all the expected</span>
 <span class="s0">* number of nested fields have been packed.  It is an error to call it too</span>
 <span class="s0">* early, or too late.</span>
 <span class="s0">*/</span>
<span class="s0">25</span>
<span class="s0">void DCPacker::pop(void);</span>

<span class="s0">320 11 pack_double 0 4 489 21 DCPacker::pack_double 0 1 79 71</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void DCPacker::pack_double(double value);</span>

<span class="s0">321 8 pack_int 0 4 489 18 DCPacker::pack_int 0 1 80 71</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void DCPacker::pack_int(int value);</span>

<span class="s0">322 9 pack_uint 0 4 489 19 DCPacker::pack_uint 0 1 81 71</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void DCPacker::pack_uint(unsigned int value);</span>

<span class="s0">323 10 pack_int64 0 4 489 20 DCPacker::pack_int64 0 1 82 71</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void DCPacker::pack_int64(int64_t value);</span>

<span class="s0">324 11 pack_uint64 0 4 489 21 DCPacker::pack_uint64 0 1 83 71</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void DCPacker::pack_uint64(uint64_t value);</span>

<span class="s0">325 11 pack_string 0 4 489 21 DCPacker::pack_string 0 1 84 71</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void DCPacker::pack_string(std::string const &amp;value);</span>

<span class="s0">326 9 pack_blob 0 4 489 19 DCPacker::pack_blob 0 1 85 71</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void DCPacker::pack_blob(vector_uchar const &amp;value);</span>

<span class="s0">327 18 pack_literal_value 0 4 489 28 DCPacker::pack_literal_value 0 1 86 155</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated string value into the stream, representing a single pre-</span>
 <span class="s0">* packed field element, or a whole group of field elements at once.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void DCPacker::pack_literal_value(vector_uchar const &amp;value);</span>

<span class="s0">328 18 pack_default_value 0 4 489 28 DCPacker::pack_default_value 0 1 87 158</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the default value for the current element into the stream.  If no</span>
 <span class="s0">* default has been set for the current element, creates a sensible default.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void DCPacker::pack_default_value(void);</span>

<span class="s0">329 13 unpack_double 0 4 489 23 DCPacker::unpack_double 0 1 88 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double DCPacker::unpack_double(void);</span>

<span class="s0">330 10 unpack_int 0 4 489 20 DCPacker::unpack_int 0 1 89 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline int DCPacker::unpack_int(void);</span>

<span class="s0">331 11 unpack_uint 0 4 489 21 DCPacker::unpack_uint 0 1 90 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline unsigned int DCPacker::unpack_uint(void);</span>

<span class="s0">332 12 unpack_int64 0 4 489 22 DCPacker::unpack_int64 0 1 91 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline int64_t DCPacker::unpack_int64(void);</span>

<span class="s0">333 13 unpack_uint64 0 4 489 23 DCPacker::unpack_uint64 0 1 92 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline uint64_t DCPacker::unpack_uint64(void);</span>

<span class="s0">334 13 unpack_string 0 4 489 23 DCPacker::unpack_string 0 1 93 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline std::string DCPacker::unpack_string(void);</span>

<span class="s0">335 11 unpack_blob 0 4 489 21 DCPacker::unpack_blob 0 1 94 138</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the current binary data value from the stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline vector_uchar DCPacker::unpack_blob(void);</span>

<span class="s0">336 20 unpack_literal_value 0 4 489 30 DCPacker::unpack_literal_value 0 1 95 256</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the literal string that represents the packed value of the current</span>
 <span class="s0">* field, and advances the field pointer.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the literal string that represents the packed value of the current</span>
 <span class="s0">* field, and advances the field pointer.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline vector_uchar DCPacker::unpack_literal_value(void);</span>

<span class="s0">337 15 unpack_validate 0 4 489 25 DCPacker::unpack_validate 0 1 96 219</span>
<span class="s0">/**</span>
 <span class="s0">* Internally unpacks the current numeric or string value and validates it</span>
 <span class="s0">* against the type range limits, but does not return the value.  If the</span>
 <span class="s0">* current field contains nested fields, validates all of them.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void DCPacker::unpack_validate(void);</span>

<span class="s0">338 11 unpack_skip 0 4 489 21 DCPacker::unpack_skip 0 1 97 155</span>
<span class="s0">/**</span>
 <span class="s0">* Skips the current field without unpacking it and advances to the next</span>
 <span class="s0">* field.  If the current field contains nested fields, skips all of them.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void DCPacker::unpack_skip(void);</span>

<span class="s0">339 11 pack_object 0 4 489 21 DCPacker::pack_object 0 1 98 259</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the Python object of whatever type into the packer.  Each numeric</span>
 <span class="s0">* object and string object maps to the corresponding pack_value() call; a</span>
 <span class="s0">* tuple or sequence maps to a push() followed by all of the tuple's contents</span>
 <span class="s0">* followed by a pop().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void DCPacker::pack_object(PyObject *object);</span>

<span class="s0">340 13 unpack_object 0 4 489 23 DCPacker::unpack_object 0 1 99 238</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks a Python object of the appropriate type from the stream for the</span>
 <span class="s0">* current field.  This may be an integer or a string for a simple field</span>
 <span class="s0">* object; if the current field represents a list of fields it will be a</span>
 <span class="s0">* tuple.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">PyObject *DCPacker::unpack_object(void);</span>

<span class="s0">341 14 parse_and_pack 0 4 489 24 DCPacker::parse_and_pack 0 2 100 101 344</span>
<span class="s0">/**</span>
 <span class="s0">* Parses an object's value according to the DC file syntax (e.g.  as a</span>
 <span class="s0">* default value string) and packs it.  Returns true on success, false on a</span>
 <span class="s0">* parse error.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Parses an object's value according to the DC file syntax (e.g.  as a</span>
 <span class="s0">* default value string) and packs it.  Returns true on success, false on a</span>
 <span class="s0">* parse error.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">bool DCPacker::parse_and_pack(std::string const &amp;formatted_object);</span>
<span class="s0">bool DCPacker::parse_and_pack(std::istream &amp;in);</span>

<span class="s0">342 17 unpack_and_format 0 4 489 27 DCPacker::unpack_and_format 0 2 102 103 328</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks an object and formats its value into a syntax suitable for parsing</span>
 <span class="s0">* in the dc file (e.g.  as a default value), or as an input to parse_object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks an object and formats its value into a syntax suitable for parsing</span>
 <span class="s0">* in the dc file (e.g.  as a default value), or as an input to parse_object.</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">std::string DCPacker::unpack_and_format(bool show_field_names = true);</span>
<span class="s0">void DCPacker::unpack_and_format(std::ostream &amp;out, bool show_field_names = true);</span>

<span class="s0">343 15 had_parse_error 0 4 489 25 DCPacker::had_parse_error 0 1 104 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there has been an parse error since the most recent call to</span>
 <span class="s0">* begin(); this can only happen if you call parse_and_pack().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool DCPacker::had_parse_error(void) const;</span>

<span class="s0">344 14 had_pack_error 0 4 489 24 DCPacker::had_pack_error 0 1 105 471</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there has been an packing error since the most recent call</span>
 <span class="s0">* to begin(); in particular, this may be called after end() has returned</span>
 <span class="s0">* false to determine the nature of the failure.</span>
 <span class="s0">*</span>
 <span class="s0">* A return value of true indicates there was a push/pop mismatch, or the</span>
 <span class="s0">* push/pop structure did not match the data structure, or there were the</span>
 <span class="s0">* wrong number of elements in a nested push/pop structure, or on unpack that</span>
 <span class="s0">* the data stream was truncated.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool DCPacker::had_pack_error(void) const;</span>

<span class="s0">345 15 had_range_error 0 4 489 25 DCPacker::had_range_error 0 1 106 400</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there has been an range validation error since the most</span>
 <span class="s0">* recent call to begin(); in particular, this may be called after end() has</span>
 <span class="s0">* returned false to determine the nature of the failure.</span>
 <span class="s0">*</span>
 <span class="s0">* A return value of true indicates a value that was packed or unpacked did</span>
 <span class="s0">* not fit within the specified legal range for a parameter, or within the</span>
 <span class="s0">* limits of the field size.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool DCPacker::had_range_error(void) const;</span>

<span class="s0">346 9 had_error 0 4 489 19 DCPacker::had_error 0 1 107 222</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there has been any error (either a pack error or a range</span>
 <span class="s0">* error) since the most recent call to begin().  If this returns true, then</span>
 <span class="s0">* the matching call to end() will indicate an error (false).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool DCPacker::had_error(void) const;</span>

<span class="s0">347 22 get_num_unpacked_bytes 0 4 489 32 DCPacker::get_num_unpacked_bytes 0 1 108 290</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes that have been unpacked so far, or after</span>
 <span class="s0">* unpack_end(), the total number of bytes that were unpacked at all.  This</span>
 <span class="s0">* can be used to validate that all of the bytes in the buffer were actually</span>
 <span class="s0">* unpacked (which is not otherwise considered an error).</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t DCPacker::get_num_unpacked_bytes(void) const;</span>

<span class="s0">348 10 get_length 0 4 489 20 DCPacker::get_length 0 1 109 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current length of the buffer.  This is the number of useful</span>
 <span class="s0">* bytes stored in the buffer, not the amount of memory it takes up.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::size_t DCPacker::get_length(void) const;</span>

<span class="s0">349 10 get_string 0 4 489 20 DCPacker::get_string 0 1 110 160</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the packed data buffer as a string.  Also see get_data().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Copies the packed data into the indicated string.  Also see get_data().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::string DCPacker::get_string(void) const;</span>

<span class="s0">350 9 get_bytes 0 4 489 19 DCPacker::get_bytes 0 1 111 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the packed data buffer as a bytes object.  Also see get_data().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline vector_uchar DCPacker::get_bytes(void) const;</span>

<span class="s0">351 17 get_unpack_length 0 4 489 27 DCPacker::get_unpack_length 0 1 112 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes in the unpack data buffer.  This is the</span>
 <span class="s0">* buffer used when unpacking; it is separate from the pack data returned by</span>
 <span class="s0">* get_length(), which is filled during packing.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::size_t DCPacker::get_unpack_length(void) const;</span>

<span class="s0">352 17 get_unpack_string 0 4 489 27 DCPacker::get_unpack_string 0 1 113 223</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the unpack data buffer, as a string.  This is the buffer used when</span>
 <span class="s0">* unpacking; it is separate from the pack data returned by get_string(),</span>
 <span class="s0">* which is filled during packing.  Also see get_unpack_data().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::string DCPacker::get_unpack_string(void) const;</span>

<span class="s0">353 37 get_num_stack_elements_ever_allocated 0 4 489 47 DCPacker::get_num_stack_elements_ever_allocated 0 1 114 221</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of DCPacker::StackElement pointers ever simultaneously</span>
 <span class="s0">* allocated; these are now either in active use or have been recycled into</span>
 <span class="s0">* the deleted DCPacker::StackElement pool to be used again.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline int DCPacker::get_num_stack_elements_ever_allocated(void);</span>

<span class="s0">354 13 raw_pack_int8 0 4 489 23 DCPacker::raw_pack_int8 0 1 115 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void DCPacker::raw_pack_int8(int value);</span>

<span class="s0">355 14 raw_pack_int16 0 4 489 24 DCPacker::raw_pack_int16 0 1 116 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void DCPacker::raw_pack_int16(int value);</span>

<span class="s0">356 14 raw_pack_int32 0 4 489 24 DCPacker::raw_pack_int32 0 1 117 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void DCPacker::raw_pack_int32(int value);</span>

<span class="s0">357 14 raw_pack_int64 0 4 489 24 DCPacker::raw_pack_int64 0 1 118 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void DCPacker::raw_pack_int64(int64_t value);</span>

<span class="s0">358 14 raw_pack_uint8 0 4 489 24 DCPacker::raw_pack_uint8 0 1 119 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void DCPacker::raw_pack_uint8(unsigned int value);</span>

<span class="s0">359 15 raw_pack_uint16 0 4 489 25 DCPacker::raw_pack_uint16 0 1 120 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void DCPacker::raw_pack_uint16(unsigned int value);</span>

<span class="s0">360 15 raw_pack_uint32 0 4 489 25 DCPacker::raw_pack_uint32 0 1 121 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void DCPacker::raw_pack_uint32(unsigned int value);</span>

<span class="s0">361 15 raw_pack_uint64 0 4 489 25 DCPacker::raw_pack_uint64 0 1 122 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void DCPacker::raw_pack_uint64(uint64_t value);</span>

<span class="s0">362 16 raw_pack_float64 0 4 489 26 DCPacker::raw_pack_float64 0 1 123 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void DCPacker::raw_pack_float64(double value);</span>

<span class="s0">363 15 raw_pack_string 0 4 489 25 DCPacker::raw_pack_string 0 1 124 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void DCPacker::raw_pack_string(std::string const &amp;value);</span>

<span class="s0">364 13 raw_pack_blob 0 4 489 23 DCPacker::raw_pack_blob 0 1 125 67</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void DCPacker::raw_pack_blob(vector_uchar const &amp;value);</span>

<span class="s0">365 15 raw_unpack_int8 0 4 489 25 DCPacker::raw_unpack_int8 0 1 126 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int DCPacker::raw_unpack_int8(void);</span>

<span class="s0">366 16 raw_unpack_int16 0 4 489 26 DCPacker::raw_unpack_int16 0 1 127 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline int DCPacker::raw_unpack_int16(void);</span>

<span class="s0">367 16 raw_unpack_int32 0 4 489 26 DCPacker::raw_unpack_int32 0 1 128 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline int DCPacker::raw_unpack_int32(void);</span>

<span class="s0">368 16 raw_unpack_int64 0 4 489 26 DCPacker::raw_unpack_int64 0 1 129 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int64_t DCPacker::raw_unpack_int64(void);</span>

<span class="s0">369 16 raw_unpack_uint8 0 4 489 26 DCPacker::raw_unpack_uint8 0 1 130 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline unsigned int DCPacker::raw_unpack_uint8(void);</span>

<span class="s0">370 17 raw_unpack_uint16 0 4 489 27 DCPacker::raw_unpack_uint16 0 1 131 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline unsigned int DCPacker::raw_unpack_uint16(void);</span>

<span class="s0">371 17 raw_unpack_uint32 0 4 489 27 DCPacker::raw_unpack_uint32 0 1 132 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline unsigned int DCPacker::raw_unpack_uint32(void);</span>

<span class="s0">372 17 raw_unpack_uint64 0 4 489 27 DCPacker::raw_unpack_uint64 0 1 133 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline uint64_t DCPacker::raw_unpack_uint64(void);</span>

<span class="s0">373 18 raw_unpack_float64 0 4 489 28 DCPacker::raw_unpack_float64 0 1 134 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline double DCPacker::raw_unpack_float64(void);</span>

<span class="s0">374 17 raw_unpack_string 0 4 489 27 DCPacker::raw_unpack_string 0 1 135 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::string DCPacker::raw_unpack_string(void);</span>

<span class="s0">375 15 raw_unpack_blob 0 4 489 25 DCPacker::raw_unpack_blob 0 1 136 144</span>
<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline vector_uchar DCPacker::raw_unpack_blob(void);</span>

<span class="s0">376 19 as_simple_parameter 0 6 490 32 DCParameter::as_simple_parameter 0 2 137 138 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">virtual DCSimpleParameter *DCParameter::as_simple_parameter(void);</span>
<span class="s0">virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const;</span>

<span class="s0">377 18 as_array_parameter 0 6 490 31 DCParameter::as_array_parameter 0 2 139 140 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">141</span>
<span class="s0">virtual DCArrayParameter *DCParameter::as_array_parameter(void);</span>
<span class="s0">virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const;</span>

<span class="s0">378 9 make_copy 0 6 490 22 DCParameter::make_copy 0 1 141 0</span>
<span class="s0">60</span>
<span class="s0">virtual DCParameter *DCParameter::make_copy(void) const = 0;</span>

<span class="s0">379 8 is_valid 0 6 490 21 DCParameter::is_valid 0 1 142 0</span>
<span class="s0">51</span>
<span class="s0">virtual bool DCParameter::is_valid(void) const = 0;</span>

<span class="s0">380 11 get_typedef 0 4 490 24 DCParameter::get_typedef 0 1 143 139</span>
<span class="s0">/**</span>
 <span class="s0">* If this type has been referenced from a typedef, returns the DCTypedef</span>
 <span class="s0">* instance, or NULL if the type was declared on-the-fly.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">DCTypedef const *DCParameter::get_typedef(void) const;</span>

<span class="s0">381 16 get_element_type 0 4 491 34 DCArrayParameter::get_element_type 0 1 144 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of the individual elements of this array.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">DCParameter *DCArrayParameter::get_element_type(void) const;</span>

<span class="s0">382 14 get_array_size 0 4 491 32 DCArrayParameter::get_array_size 0 1 145 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the fixed number of elements in this array, or -1 if the array may</span>
 <span class="s0">* contain a variable number of elements.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">int DCArrayParameter::get_array_size(void) const;</span>

<span class="s0">383 16 get_num_elements 0 4 492 31 DCAtomicField::get_num_elements 0 1 146 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of elements (parameters) of the atomic field.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int DCAtomicField::get_num_elements(void) const;</span>

<span class="s0">384 11 get_element 0 4 492 26 DCAtomicField::get_element 0 1 147 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the parameter object describing the nth element.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">DCParameter *DCAtomicField::get_element(int n) const;</span>

<span class="s0">385 19 get_element_default 0 4 492 34 DCAtomicField::get_element_default 0 1 148 505</span>
<span class="s0">// These five methods are deprecated and will be removed soon.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the pre-formatted default value associated with the nth element of</span>
 <span class="s0">* the field.  This is only valid if has_element_default() returns true, in</span>
 <span class="s0">* which case this string represents the bytes that should be assigned to the</span>
 <span class="s0">* field as a default value.</span>
 <span class="s0">*</span>
 <span class="s0">* If the element is an array-type element, the returned value will include</span>
 <span class="s0">* the two-byte length preceding the array data.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated use get_element() instead.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">vector_uchar DCAtomicField::get_element_default(int n) const;</span>

<span class="s0">386 19 has_element_default 0 4 492 34 DCAtomicField::has_element_default 0 1 149 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the nth element of the field has a default value specified,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated use get_element() instead.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">bool DCAtomicField::has_element_default(int n) const;</span>

<span class="s0">387 16 get_element_name 0 4 492 31 DCAtomicField::get_element_name 0 1 150 272</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the nth element of the field.  This name is strictly</span>
 <span class="s0">* for documentary purposes; it does not generally affect operation.  If a</span>
 <span class="s0">* name is not specified, this will be the empty string.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated use get_element()-&gt;get_name() instead.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">std::string DCAtomicField::get_element_name(int n) const;</span>

<span class="s0">388 16 get_element_type 0 4 492 31 DCAtomicField::get_element_type 0 1 151 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the numeric type of the nth element of the field.  This method is</span>
 <span class="s0">* deprecated; use get_element() instead.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">DCSubatomicType DCAtomicField::get_element_type(int n) const;</span>

<span class="s0">389 19 get_element_divisor 0 4 492 34 DCAtomicField::get_element_divisor 0 1 152 340</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the divisor associated with the nth element of the field.  This</span>
 <span class="s0">* implements an implicit fixed-point system; floating-point values are to be</span>
 <span class="s0">* multiplied by this value before encoding into a packet, and divided by this</span>
 <span class="s0">* number after decoding.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is deprecated; use get_element()-&gt;get_divisor() instead.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">int DCAtomicField::get_element_divisor(int n) const;</span>

<span class="s0">390 14 ~DCDeclaration 0 518 493 29 DCDeclaration::~DCDeclaration 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual DCDeclaration::~DCDeclaration(void);</span>

<span class="s0">391 8 as_class 0 6 493 23 DCDeclaration::as_class 0 2 153 154 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">virtual DCClass *DCDeclaration::as_class(void);</span>
<span class="s0">virtual DCClass const *DCDeclaration::as_class(void) const;</span>

<span class="s0">392 9 as_switch 0 6 493 24 DCDeclaration::as_switch 0 2 155 156 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">virtual DCSwitch *DCDeclaration::as_switch(void);</span>
<span class="s0">virtual DCSwitch const *DCDeclaration::as_switch(void) const;</span>

<span class="s0">393 6 output 0 6 493 21 DCDeclaration::output 0 1 157 67</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual void DCDeclaration::output(std::ostream &amp;out) const;</span>

<span class="s0">394 5 write 0 4 493 20 DCDeclaration::write 0 1 158 67</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void DCDeclaration::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">395 11 get_dc_file 0 4 494 20 DCClass::get_dc_file 0 1 159 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DCFile object that contains the class.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline DCFile *DCClass::get_dc_file(void) const;</span>

<span class="s0">396 8 get_name 0 4 494 17 DCClass::get_name 0 1 160 42</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this class.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline std::string const &amp;DCClass::get_name(void) const;</span>

<span class="s0">397 10 get_number 0 4 494 19 DCClass::get_number 0 1 161 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unique index number associated with this class.  This is defined</span>
 <span class="s0">* implicitly when the .dc file(s) are read.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int DCClass::get_number(void) const;</span>

<span class="s0">398 15 get_num_parents 0 4 494 24 DCClass::get_num_parents 0 1 162 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of base classes this class inherits from.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">int DCClass::get_num_parents(void) const;</span>

<span class="s0">399 10 get_parent 0 4 494 19 DCClass::get_parent 0 1 163 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth parent class this class inherits from.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">DCClass *DCClass::get_parent(int n) const;</span>

<span class="s0">400 15 has_constructor 0 4 494 24 DCClass::has_constructor 0 1 164 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this class has a constructor method, false if it just uses</span>
 <span class="s0">* the default constructor.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">bool DCClass::has_constructor(void) const;</span>

<span class="s0">401 15 get_constructor 0 4 494 24 DCClass::get_constructor 0 1 165 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the constructor method for this class if it is defined, or NULL if</span>
 <span class="s0">* the class uses the default constructor.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">DCField *DCClass::get_constructor(void) const;</span>

<span class="s0">402 14 get_num_fields 0 4 494 23 DCClass::get_num_fields 0 1 166 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of fields defined directly in this class, ignoring</span>
 <span class="s0">* inheritance.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">int DCClass::get_num_fields(void) const;</span>

<span class="s0">403 9 get_field 0 4 494 18 DCClass::get_field 0 1 167 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth field in the class.  This is not necessarily the field with</span>
 <span class="s0">* index n; this is the nth field defined in the class directly, ignoring</span>
 <span class="s0">* inheritance.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">DCField *DCClass::get_field(int n) const;</span>

<span class="s0">404 17 get_field_by_name 0 4 494 26 DCClass::get_field_by_name 0 1 168 294</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the DCField that shares the indicated name.  If the</span>
 <span class="s0">* named field is not found in the current class, the parent classes will be</span>
 <span class="s0">* searched, so the value returned may not actually be a field within this</span>
 <span class="s0">* class.  Returns NULL if there is no such field defined.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">DCField *DCClass::get_field_by_name(std::string const &amp;name) const;</span>

<span class="s0">405 18 get_field_by_index 0 4 494 27 DCClass::get_field_by_index 0 1 169 302</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the DCField that has the indicated index number.  If</span>
 <span class="s0">* the numbered field is not found in the current class, the parent classes</span>
 <span class="s0">* will be searched, so the value returned may not actually be a field within</span>
 <span class="s0">* this class.  Returns NULL if there is no such field defined.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">DCField *DCClass::get_field_by_index(int index_number) const;</span>

<span class="s0">406 24 get_num_inherited_fields 0 4 494 33 DCClass::get_num_inherited_fields 0 1 170 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of field fields defined in this class and all</span>
 <span class="s0">* ancestor classes.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int DCClass::get_num_inherited_fields(void) const;</span>

<span class="s0">407 19 get_inherited_field 0 4 494 28 DCClass::get_inherited_field 0 1 171 315</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth field field in the class and all of its ancestors.</span>
 <span class="s0">*</span>
 <span class="s0">* This *used* to be the same thing as get_field_by_index(), back when the</span>
 <span class="s0">* fields were numbered sequentially within a class's inheritance hierarchy.</span>
 <span class="s0">* Now that fields have a globally unique index number, this is no longer</span>
 <span class="s0">* true.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">DCField *DCClass::get_inherited_field(int n) const;</span>

<span class="s0">408 9 is_struct 0 4 494 18 DCClass::is_struct 0 1 172 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the class has been identified with the &quot;struct&quot; keyword in</span>
 <span class="s0">* the dc file, false if it was declared with &quot;dclass&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool DCClass::is_struct(void) const;</span>

<span class="s0">409 14 is_bogus_class 0 4 494 23 DCClass::is_bogus_class 0 1 173 253</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the class has been flagged as a bogus class.  This is set</span>
 <span class="s0">* for classes that are generated by the parser as placeholder for missing</span>
 <span class="s0">* classes, as when reading a partial file; it should not occur in a normal</span>
 <span class="s0">* valid dc file.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool DCClass::is_bogus_class(void) const;</span>

<span class="s0">410 25 inherits_from_bogus_class 0 4 494 34 DCClass::inherits_from_bogus_class 0 1 174 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this class, or any class in the inheritance heirarchy for</span>
 <span class="s0">* this class, is a &quot;bogus&quot; class--a forward reference to an as-yet-undefined</span>
 <span class="s0">* class.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">bool DCClass::inherits_from_bogus_class(void) const;</span>

<span class="s0">411 14 start_generate 0 4 494 23 DCClass::start_generate 0 1 175 255</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the PStats timer going on the &quot;generate&quot; task, that is, marks the</span>
 <span class="s0">* beginning of the process of generating a new object, for the purposes of</span>
 <span class="s0">* timing this process.</span>
 <span class="s0">*</span>
 <span class="s0">* This should balance with a corresponding call to stop_generate().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void DCClass::start_generate(void);</span>

<span class="s0">412 13 stop_generate 0 4 494 22 DCClass::stop_generate 0 1 176 124</span>
<span class="s0">/**</span>
 <span class="s0">* Stops the PStats timer on the &quot;generate&quot; task.  This should balance with a</span>
 <span class="s0">* preceding call to start_generate().</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void DCClass::stop_generate(void);</span>

<span class="s0">413 6 output 0 6 494 15 DCClass::output 0 1 177 136</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">virtual void DCClass::output(std::ostream &amp;out) const;</span>

<span class="s0">414 13 has_class_def 0 4 494 22 DCClass::has_class_def 0 1 178 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the DCClass object has an associated Python class</span>
 <span class="s0">* definition, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">bool DCClass::has_class_def(void) const;</span>

<span class="s0">415 13 set_class_def 0 4 494 22 DCClass::set_class_def 0 1 179 141</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the class object associated with this DistributedClass.  This object</span>
 <span class="s0">* will be used to construct new instances of the class.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void DCClass::set_class_def(PyObject *class_def);</span>

<span class="s0">416 13 get_class_def 0 4 494 22 DCClass::get_class_def 0 1 180 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the class object that was previously associated with this</span>
 <span class="s0">* DistributedClass.  This will return a new reference to the object.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">PyObject *DCClass::get_class_def(void) const;</span>

<span class="s0">417 19 has_owner_class_def 0 4 494 28 DCClass::has_owner_class_def 0 1 181 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the DCClass object has an associated Python owner class</span>
 <span class="s0">* definition, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">bool DCClass::has_owner_class_def(void) const;</span>

<span class="s0">418 19 set_owner_class_def 0 4 494 28 DCClass::set_owner_class_def 0 1 182 153</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the owner class object associated with this DistributedClass.  This</span>
 <span class="s0">* object will be used to construct new owner instances of the class.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void DCClass::set_owner_class_def(PyObject *owner_class_def);</span>

<span class="s0">419 19 get_owner_class_def 0 4 494 28 DCClass::get_owner_class_def 0 1 183 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the owner class object that was previously associated with this</span>
 <span class="s0">* DistributedClass.  This will return a new reference to the object.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">PyObject *DCClass::get_owner_class_def(void) const;</span>

<span class="s0">420 14 receive_update 0 4 494 23 DCClass::receive_update 0 1 184 133</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts the update message out of the packer and applies it to the</span>
 <span class="s0">* indicated object by calling the appropriate method.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void DCClass::receive_update(PyObject *distobj, DatagramIterator &amp;di) const;</span>

<span class="s0">421 33 receive_update_broadcast_required 0 4 494 42 DCClass::receive_update_broadcast_required 0 1 185 224</span>
<span class="s0">/**</span>
 <span class="s0">* Processes a big datagram that includes all of the &quot;required&quot; fields that</span>
 <span class="s0">* are sent along with a normal &quot;generate with required&quot; message.  This is all</span>
 <span class="s0">* of the atomic fields that are marked &quot;broadcast required&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">void DCClass::receive_update_broadcast_required(PyObject *distobj, DatagramIterator &amp;di) const;</span>

<span class="s0">422 39 receive_update_broadcast_required_owner 0 4 494 48 DCClass::receive_update_broadcast_required_owner 0 1 186 267</span>
<span class="s0">/**</span>
 <span class="s0">* Processes a big datagram that includes all of the &quot;required&quot; fields that</span>
 <span class="s0">* are sent along with a normal &quot;generate with required&quot; message.  This is all</span>
 <span class="s0">* of the atomic fields that are marked &quot;broadcast ownrecv&quot;. Should be used</span>
 <span class="s0">* for 'owner-view' objects.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">void DCClass::receive_update_broadcast_required_owner(PyObject *distobj, DatagramIterator &amp;di) const;</span>

<span class="s0">423 27 receive_update_all_required 0 4 494 36 DCClass::receive_update_all_required 0 1 187 222</span>
<span class="s0">/**</span>
 <span class="s0">* Processes a big datagram that includes all of the &quot;required&quot; fields that</span>
 <span class="s0">* are sent when an avatar is created.  This is all of the atomic fields that</span>
 <span class="s0">* are marked &quot;required&quot;, whether they are broadcast or not.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void DCClass::receive_update_all_required(PyObject *distobj, DatagramIterator &amp;di) const;</span>

<span class="s0">424 20 receive_update_other 0 4 494 29 DCClass::receive_update_other 0 1 188 101</span>
<span class="s0">/**</span>
 <span class="s0">* Processes a datagram that lists some additional fields that are broadcast</span>
 <span class="s0">* in one chunk.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void DCClass::receive_update_other(PyObject *distobj, DatagramIterator &amp;di) const;</span>

<span class="s0">425 13 direct_update 0 4 494 22 DCClass::direct_update 0 2 189 190 148</span>
<span class="s0">/**</span>
 <span class="s0">* Processes an update for a named field from a packed value blob.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Processes an update for a named field from a packed datagram.</span>
 <span class="s0">*/</span>
<span class="s0">215</span>
<span class="s0">void DCClass::direct_update(PyObject *distobj, std::string const &amp;field_name, vector_uchar const &amp;value_blob);</span>
<span class="s0">void DCClass::direct_update(PyObject *distobj, std::string const &amp;field_name, Datagram const &amp;datagram);</span>

<span class="s0">426 19 pack_required_field 0 4 494 28 DCClass::pack_required_field 0 2 191 192 716</span>
<span class="s0">/**</span>
 <span class="s0">* Looks up the current value of the indicated field by calling the</span>
 <span class="s0">* appropriate get*() function, then packs that value into the datagram.  This</span>
 <span class="s0">* field is presumably either a required field or a specified optional field,</span>
 <span class="s0">* and we are building up a datagram for the generate-with-required message.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Looks up the current value of the indicated field by calling the</span>
 <span class="s0">* appropriate get*() function, then packs that value into the packer.  This</span>
 <span class="s0">* field is presumably either a required field or a specified optional field,</span>
 <span class="s0">* and we are building up a datagram for the generate-with-required message.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">201</span>
<span class="s0">bool DCClass::pack_required_field(Datagram &amp;datagram, PyObject *distobj, DCField const *field) const;</span>
<span class="s0">bool DCClass::pack_required_field(DCPacker &amp;packer, PyObject *distobj, DCField const *field) const;</span>

<span class="s0">427 20 client_format_update 0 4 494 29 DCClass::client_format_update 0 1 193 139</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update for</span>
 <span class="s0">* the indicated distributed object from the client.</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">Datagram DCClass::client_format_update(std::string const &amp;field_name, DOID_TYPE do_id, PyObject *args) const;</span>

<span class="s0">428 16 ai_format_update 0 4 494 25 DCClass::ai_format_update 0 1 194 135</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update for</span>
 <span class="s0">* the indicated distributed object from the AI.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">Datagram DCClass::ai_format_update(std::string const &amp;field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, PyObject *args) const;</span>

<span class="s0">429 25 ai_format_update_msg_type 0 4 494 34 DCClass::ai_format_update_msg_type 0 1 195 168</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update,</span>
 <span class="s0">* using the indicated msg type for the indicated distributed object from the</span>
 <span class="s0">* AI.</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">Datagram DCClass::ai_format_update_msg_type(std::string const &amp;field_name, DOID_TYPE do_id, CHANNEL_TYPE to_id, CHANNEL_TYPE from_id, int msg_type, PyObject *args) const;</span>

<span class="s0">430 18 ai_format_generate 0 4 494 27 DCClass::ai_format_generate 0 1 196 304</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a datagram containing the message necessary to generate a new</span>
 <span class="s0">* distributed object from the AI. This requires querying the object for the</span>
 <span class="s0">* initial value of its required fields.</span>
 <span class="s0">*</span>
 <span class="s0">* optional_fields is a list of fieldNames to generate in addition to the</span>
 <span class="s0">* normal required fields.</span>
 <span class="s0">*/</span>
<span class="s0">214</span>
<span class="s0">Datagram DCClass::ai_format_generate(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE parent_id, ZONEID_TYPE zone_id, CHANNEL_TYPE district_channel_id, CHANNEL_TYPE from_channel_id, PyObject *optional_fields) const;</span>

<span class="s0">431 26 client_format_generate_CMU 0 4 494 35 DCClass::client_format_generate_CMU 0 1 197 369</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a datagram containing the message necessary to generate a new</span>
 <span class="s0">* distributed object from the client.  This requires querying the object for</span>
 <span class="s0">* the initial value of its required fields.</span>
 <span class="s0">*</span>
 <span class="s0">* optional_fields is a list of fieldNames to generate in addition to the</span>
 <span class="s0">* normal required fields.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is only called by the CMU implementation.</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">Datagram DCClass::client_format_generate_CMU(PyObject *distobj, DOID_TYPE do_id, ZONEID_TYPE zone_id, PyObject *optional_fields) const;</span>

<span class="s0">432 9 get_class 0 4 495 27 DCClassParameter::get_class 0 1 198 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the class object this parameter represents.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">DCClass const *DCClassParameter::get_class(void) const;</span>

<span class="s0">433 17 ~DCClassParameter 0 516 495 35 DCClassParameter::~DCClassParameter 0 0 0</span>
<span class="s0">42</span>
<span class="s0">DCClassParameter::~DCClassParameter(void);</span>

<span class="s0">434 6 DCFile 0 260 496 14 DCFile::DCFile 0 2 199 200 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">DCFile::DCFile(void);</span>
<span class="s0">inline DCFile::DCFile(DCFile const &amp;) = default;</span>

<span class="s0">435 7 ~DCFile 0 516 496 15 DCFile::~DCFile 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">22</span>
<span class="s0">DCFile::~DCFile(void);</span>

<span class="s0">436 5 clear 0 4 496 13 DCFile::clear 0 1 201 106</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the classes defined within the DCFile and prepares it for</span>
 <span class="s0">* reading a new file.</span>
 <span class="s0">*/</span>
<span class="s0">25</span>
<span class="s0">void DCFile::clear(void);</span>

<span class="s0">437 8 read_all 0 4 496 16 DCFile::read_all 0 1 202 146</span>
<span class="s0">/**</span>
 <span class="s0">* This special method reads all of the .dc files named by the &quot;dc-file&quot;</span>
 <span class="s0">* config.prc variable, and loads them into the DCFile namespace.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">bool DCFile::read_all(void);</span>

<span class="s0">438 4 read 0 4 496 12 DCFile::read 0 2 203 204 763</span>
<span class="s0">/**</span>
 <span class="s0">* Opens and reads the indicated .dc file by name.  The distributed classes</span>
 <span class="s0">* defined in the file will be appended to the set of distributed classes</span>
 <span class="s0">* already recorded, if any.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the file is successfully read, false if there was an error</span>
 <span class="s0">* (in which case the file might have been partially read).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Parses the already-opened input stream for distributed class descriptions.</span>
 <span class="s0">* The filename parameter is optional and is only used when reporting errors.</span>
 <span class="s0">*</span>
 <span class="s0">* The distributed classes defined in the file will be appended to the set of</span>
 <span class="s0">* distributed classes already recorded, if any.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the file is successfully read, false if there was an error</span>
 <span class="s0">* (in which case the file might have been partially read).</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">bool DCFile::read(Filename filename);</span>
<span class="s0">bool DCFile::read(std::istream &amp;in, std::string const &amp;filename = string());</span>

<span class="s0">439 5 write 0 4 496 13 DCFile::write 0 2 205 206 396</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the indicated filename for output and writes a parseable description</span>
 <span class="s0">* of all the known distributed classes to the file.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the description is successfully written, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes a parseable description of all the known distributed classes to the</span>
 <span class="s0">* stream.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the description is successfully written, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">bool DCFile::write(Filename filename, bool brief) const;</span>
<span class="s0">bool DCFile::write(std::ostream &amp;out, bool brief) const;</span>

<span class="s0">440 15 get_num_classes 0 4 496 23 DCFile::get_num_classes 0 1 207 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of classes read from the .dc file(s).</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">int DCFile::get_num_classes(void) const;</span>

<span class="s0">441 9 get_class 0 4 496 17 DCFile::get_class 0 1 208 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth class read from the .dc file(s).</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">DCClass *DCFile::get_class(int n) const;</span>

<span class="s0">442 17 get_class_by_name 0 4 496 25 DCFile::get_class_by_name 0 1 209 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the class that has the indicated name, or NULL if there is no such</span>
 <span class="s0">* class.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">DCClass *DCFile::get_class_by_name(std::string const &amp;name) const;</span>

<span class="s0">443 18 get_switch_by_name 0 4 496 26 DCFile::get_switch_by_name 0 1 210 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the switch that has the indicated name, or NULL if there is no such</span>
 <span class="s0">* switch.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">DCSwitch *DCFile::get_switch_by_name(std::string const &amp;name) const;</span>

<span class="s0">444 18 get_field_by_index 0 4 496 26 DCFile::get_field_by_index 0 1 211 354</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the one DCField that has the indicated index number,</span>
 <span class="s0">* of all the DCFields across all classes in the file.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is only valid if dc-multiple-inheritance is set true in the</span>
 <span class="s0">* Config.prc file.  Without this setting, different DCFields may share the</span>
 <span class="s0">* same index number, so this global lookup is not possible.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">DCField *DCFile::get_field_by_index(int index_number) const;</span>

<span class="s0">445 17 all_objects_valid 0 4 496 25 DCFile::all_objects_valid 0 1 212 208</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all of the classes read from the DC file were defined and</span>
 <span class="s0">* valid, or false if any of them were undefined (&quot;bogus classes&quot;).  If this</span>
 <span class="s0">* is true, we might have read a partial file.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool DCFile::all_objects_valid(void) const;</span>

<span class="s0">446 22 get_num_import_modules 0 4 496 30 DCFile::get_num_import_modules 0 1 213 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of import lines read from the .dc file(s).</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">int DCFile::get_num_import_modules(void) const;</span>

<span class="s0">447 17 get_import_module 0 4 496 25 DCFile::get_import_module 0 1 214 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the module named by the nth import line read from the .dc file(s).</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">std::string DCFile::get_import_module(int n) const;</span>

<span class="s0">448 22 get_num_import_symbols 0 4 496 30 DCFile::get_num_import_symbols 0 1 215 217</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of symbols explicitly imported by the nth import line.</span>
 <span class="s0">* If this is 0, the line is &quot;import modulename&quot;; if it is more than 0, the</span>
 <span class="s0">* line is &quot;from modulename import symbol, symbol ... &quot;.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int DCFile::get_num_import_symbols(int n) const;</span>

<span class="s0">449 17 get_import_symbol 0 4 496 25 DCFile::get_import_symbol 0 1 216 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ith symbol named by the nth import line read from the .dc</span>
 <span class="s0">* file(s).</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">std::string DCFile::get_import_symbol(int n, int i) const;</span>

<span class="s0">450 16 get_num_typedefs 0 4 496 24 DCFile::get_num_typedefs 0 1 217 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of typedefs read from the .dc file(s).</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">int DCFile::get_num_typedefs(void) const;</span>

<span class="s0">451 11 get_typedef 0 4 496 19 DCFile::get_typedef 0 1 218 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth typedef read from the .dc file(s).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">DCTypedef *DCFile::get_typedef(int n) const;</span>

<span class="s0">452 19 get_typedef_by_name 0 4 496 27 DCFile::get_typedef_by_name 0 1 219 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the typedef that has the indicated name, or NULL if there is no</span>
 <span class="s0">* such typedef name.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">DCTypedef *DCFile::get_typedef_by_name(std::string const &amp;name) const;</span>

<span class="s0">453 16 get_num_keywords 0 4 496 24 DCFile::get_num_keywords 0 1 220 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of keywords read from the .dc file(s).</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">int DCFile::get_num_keywords(void) const;</span>

<span class="s0">454 11 get_keyword 0 4 496 19 DCFile::get_keyword 0 1 221 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth keyword read from the .dc file(s).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">DCKeyword const *DCFile::get_keyword(int n) const;</span>

<span class="s0">455 19 get_keyword_by_name 0 4 496 27 DCFile::get_keyword_by_name 0 1 222 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the keyword that has the indicated name, or NULL if there is no</span>
 <span class="s0">* such keyword name.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">DCKeyword const *DCFile::get_keyword_by_name(std::string const &amp;name) const;</span>

<span class="s0">456 8 get_hash 0 4 496 16 DCFile::get_hash 0 1 223 241</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a 32-bit hash index associated with this file.  This number is</span>
 <span class="s0">* guaranteed to be consistent if the contents of the file have not changed,</span>
 <span class="s0">* and it is very likely to be different if the contents of the file do</span>
 <span class="s0">* change.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">unsigned long int DCFile::get_hash(void) const;</span>

<span class="s0">457 8 get_name 0 4 497 19 DCKeyword::get_name 0 1 224 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this keyword.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">std::string const &amp;DCKeyword::get_name(void) const;</span>

<span class="s0">458 15 get_num_atomics 0 4 498 33 DCMolecularField::get_num_atomics 0 1 225 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of atomic fields that make up this molecular field.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int DCMolecularField::get_num_atomics(void) const;</span>

<span class="s0">459 10 get_atomic 0 4 498 28 DCMolecularField::get_atomic 0 1 226 178</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth atomic field that makes up this molecular field.  This may</span>
 <span class="s0">* or may not be a field of this particular class; it might be defined in a</span>
 <span class="s0">* parent class.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">DCAtomicField *DCMolecularField::get_atomic(int n) const;</span>

<span class="s0">460 17 ~DCMolecularField 0 516 498 35 DCMolecularField::~DCMolecularField 0 0 0</span>
<span class="s0">42</span>
<span class="s0">DCMolecularField::~DCMolecularField(void);</span>

<span class="s0">461 8 get_type 0 4 499 27 DCSimpleParameter::get_type 0 1 227 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the particular subatomic type represented by this instance.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">DCSubatomicType DCSimpleParameter::get_type(void) const;</span>

<span class="s0">462 11 has_modulus 0 4 499 30 DCSimpleParameter::has_modulus 0 1 228 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a modulus associated, false otherwise.,</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool DCSimpleParameter::has_modulus(void) const;</span>

<span class="s0">463 11 get_modulus 0 4 499 30 DCSimpleParameter::get_modulus 0 1 229 269</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the modulus associated with this type, if any.  It is an error to</span>
 <span class="s0">* call this if has_modulus() returned false.</span>
 <span class="s0">*</span>
 <span class="s0">* If present, this is the modulus that is used to constrain the numeric value</span>
 <span class="s0">* of the field before it is packed (and range-checked).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">double DCSimpleParameter::get_modulus(void) const;</span>

<span class="s0">464 11 get_divisor 0 4 499 30 DCSimpleParameter::get_divisor 0 1 230 292</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the divisor associated with this type.  This is 1 by default, but</span>
 <span class="s0">* if this is other than one it represents the scale to apply when packing and</span>
 <span class="s0">* unpacking numeric values (to store fixed-point values in an integer field).</span>
 <span class="s0">* It is only meaningful for numeric-type fields.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">int DCSimpleParameter::get_divisor(void) const;</span>

<span class="s0">465 18 ~DCSimpleParameter 0 516 499 37 DCSimpleParameter::~DCSimpleParameter 0 0 0</span>
<span class="s0">44</span>
<span class="s0">DCSimpleParameter::~DCSimpleParameter(void);</span>

<span class="s0">466 8 get_name 0 4 500 18 DCSwitch::get_name 0 1 231 43</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this switch.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">std::string const &amp;DCSwitch::get_name(void) const;</span>

<span class="s0">467 17 get_key_parameter 0 4 500 27 DCSwitch::get_key_parameter 0 1 232 189</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the key parameter on which the switch is based.  The value of this</span>
 <span class="s0">* parameter in the record determines which one of the several cases within</span>
 <span class="s0">* the switch will be used.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">DCField *DCSwitch::get_key_parameter(void) const;</span>

<span class="s0">468 13 get_num_cases 0 4 500 23 DCSwitch::get_num_cases 0 1 233 140</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of different cases within the switch.  The legal values</span>
 <span class="s0">* for case_index range from 0 to get_num_cases() - 1.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">int DCSwitch::get_num_cases(void) const;</span>

<span class="s0">469 17 get_case_by_value 0 4 500 27 DCSwitch::get_case_by_value 0 1 234 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number of the case with the indicated packed value, or -1</span>
 <span class="s0">* if no case has this value.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">int DCSwitch::get_case_by_value(vector_uchar const &amp;case_value) const;</span>

<span class="s0">470 8 get_case 0 4 500 18 DCSwitch::get_case 0 1 235 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DCPackerInterface that packs the nth case.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">DCPackerInterface *DCSwitch::get_case(int n) const;</span>

<span class="s0">471 16 get_default_case 0 4 500 26 DCSwitch::get_default_case 0 1 236 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DCPackerInterface that packs the default case, or NULL if there</span>
 <span class="s0">* is no default case.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">DCPackerInterface *DCSwitch::get_default_case(void) const;</span>

<span class="s0">472 9 get_value 0 4 500 19 DCSwitch::get_value 0 1 237 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the packed value associated with the indicated case.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">vector_uchar DCSwitch::get_value(int case_index) const;</span>

<span class="s0">473 14 get_num_fields 0 4 500 24 DCSwitch::get_num_fields 0 1 238 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of fields in the indicated case.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">int DCSwitch::get_num_fields(int case_index) const;</span>

<span class="s0">474 9 get_field 0 4 500 19 DCSwitch::get_field 0 1 239 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth field in the indicated case.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">DCField *DCSwitch::get_field(int case_index, int n) const;</span>

<span class="s0">475 17 get_field_by_name 0 4 500 27 DCSwitch::get_field_by_name 0 1 240 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the field with the given name from the indicated case, or NULL if</span>
 <span class="s0">* no field has this name.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">DCField *DCSwitch::get_field_by_name(int case_index, std::string const &amp;name) const;</span>

<span class="s0">476 10 get_switch 0 4 501 29 DCSwitchParameter::get_switch 0 1 241 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the switch object this parameter represents.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">DCSwitch const *DCSwitchParameter::get_switch(void) const;</span>

<span class="s0">477 18 ~DCSwitchParameter 0 516 501 37 DCSwitchParameter::~DCSwitchParameter 0 0 0</span>
<span class="s0">44</span>
<span class="s0">DCSwitchParameter::~DCSwitchParameter(void);</span>

<span class="s0">478 10 get_number 0 4 502 21 DCTypedef::get_number 0 1 242 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unique index number associated with this typedef definition.</span>
 <span class="s0">* This is defined implicitly when the .dc file(s) are read.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">int DCTypedef::get_number(void) const;</span>

<span class="s0">479 8 get_name 0 4 502 19 DCTypedef::get_name 0 1 243 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this typedef.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">std::string const &amp;DCTypedef::get_name(void) const;</span>

<span class="s0">480 15 get_description 0 4 502 26 DCTypedef::get_description 0 1 244 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a brief decription of the typedef, useful for human consumption.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">std::string DCTypedef::get_description(void) const;</span>

<span class="s0">481 16 is_bogus_typedef 0 4 502 27 DCTypedef::is_bogus_typedef 0 1 245 259</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the typedef has been flagged as a bogus typedef.  This is</span>
 <span class="s0">* set for typedefs that are generated by the parser as placeholder for</span>
 <span class="s0">* missing typedefs, as when reading a partial file; it should not occur in a</span>
 <span class="s0">* normal valid dc file.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">bool DCTypedef::is_bogus_typedef(void) const;</span>

<span class="s0">482 19 is_implicit_typedef 0 4 502 30 DCTypedef::is_implicit_typedef 0 1 246 157</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the typedef has been flagged as an implicit typedef,</span>
 <span class="s0">* meaning it was created for a DCClass that was referenced inline as a type.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool DCTypedef::is_implicit_typedef(void) const;</span>

<span class="s0">246</span>
<span class="s0">1 0 0 6 5 505 0 0 83 /**</span>
 <span class="s0">* Returns the name of this field, or empty string if the field is unnamed.</span>
 <span class="s0">*/ 1 4 this 3 503  </span>
<span class="s0">2 0 0 6 6 506 0 0 491 /**</span>
 <span class="s0">* Returns the index number to be passed to a future call to DCPacker::seek()</span>
 <span class="s0">* to seek directly to the named field without having to look up the field</span>
 <span class="s0">* name in a table later, or -1 if the named field cannot be found.</span>
 <span class="s0">*</span>
 <span class="s0">* If the named field is nested within a switch or some similar dynamic</span>
 <span class="s0">* structure that reveals different fields based on the contents of the data,</span>
 <span class="s0">* this mechanism cannot be used to pre-fetch the field index number--you must</span>
 <span class="s0">* seek for the field by name.</span>
 <span class="s0">*/ 2 4 this 3 503  4 name 1 505  </span>
<span class="s0">3 0 0 6 7 508 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 507  </span>
<span class="s0">4 0 0 6 7 509 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 503  </span>
<span class="s0">5 0 0 6 8 511 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 507  </span>
<span class="s0">6 0 0 6 8 512 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 503  </span>
<span class="s0">7 0 0 6 9 514 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 507  </span>
<span class="s0">8 0 0 6 9 515 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 503  </span>
<span class="s0">9 0 0 6 10 517 0 0 189 /**</span>
 <span class="s0">* Returns true if the other interface is bitwise the same as this one--that</span>
 <span class="s0">* is, a uint32 only matches a uint32, etc.  Names of components, and range</span>
 <span class="s0">* limits, are not compared.</span>
 <span class="s0">*/ 2 4 this 3 503  5 other 1 503  </span>
<span class="s0">10 0 0 6 10 517 0 0 362 /**</span>
 <span class="s0">* Returns true if this interface is bitwise the same as the interface</span>
 <span class="s0">* described with the indicated formatted string, e.g.  &quot;(uint8, uint8,</span>
 <span class="s0">* int16)&quot;, or false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* If DCFile is not NULL, it specifies the DCFile that was previously loaded,</span>
 <span class="s0">* from which some predefined structs and typedefs may be referenced in the</span>
 <span class="s0">* description string.</span>
 <span class="s0">*/ 3 4 this 3 503  11 description 1 505  6 dcfile 5 518  </span>
<span class="s0">11 0 0 6 13 517 0 0 85 /**</span>
 <span class="s0">* Returns true if this list includes the indicated keyword, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 519  7 keyword 1 521  </span>
<span class="s0">12 0 0 6 13 517 0 0 85 /**</span>
 <span class="s0">* Returns true if this list includes the indicated keyword, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 519  4 name 1 505  </span>
<span class="s0">13 0 0 6 14 506 0 0 54 /**</span>
 <span class="s0">* Returns the number of keywords in the list.</span>
 <span class="s0">*/ 1 4 this 3 519  </span>
<span class="s0">14 0 0 6 15 521 0 0 47 /**</span>
 <span class="s0">* Returns the nth keyword in the list.</span>
 <span class="s0">*/ 2 4 this 3 519  1 n 1 506  </span>
<span class="s0">15 0 0 6 16 521 0 0 129 /**</span>
 <span class="s0">* Returns the keyword in the list with the indicated name, or NULL if there</span>
 <span class="s0">* is no keyword in the list with that name.</span>
 <span class="s0">*/ 2 4 this 3 519  4 name 1 505  </span>
<span class="s0">16 0 0 6 17 517 0 0 147 /**</span>
 <span class="s0">* Returns true if this list has the same keywords as the other list, false if</span>
 <span class="s0">* some keywords differ.  Order is not considered important.</span>
 <span class="s0">*/ 2 4 this 3 519  5 other 1 519  </span>
<span class="s0">17 0 0 6 24 506 0 0 130 /**</span>
 <span class="s0">* Returns a unique index number associated with this field.  This is defined</span>
 <span class="s0">* implicitly when the .dc file(s) are read.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">18 0 0 6 25 523 0 0 78 /**</span>
 <span class="s0">* Returns the DCClass pointer for the class that contains this field.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">19 0 0 6 26 508 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 508  </span>
<span class="s0">20 0 0 6 26 509 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">21 0 0 6 27 524 0 0 143 /**</span>
 <span class="s0">* Returns the same field pointer converted to an atomic field pointer, if</span>
 <span class="s0">* this is in fact an atomic field; otherwise, returns NULL.</span>
 <span class="s0">*/ 1 4 this 3 508  </span>
<span class="s0">22 0 0 6 27 525 0 0 143 /**</span>
 <span class="s0">* Returns the same field pointer converted to an atomic field pointer, if</span>
 <span class="s0">* this is in fact an atomic field; otherwise, returns NULL.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">23 0 0 6 28 527 0 0 147 /**</span>
 <span class="s0">* Returns the same field pointer converted to a molecular field pointer, if</span>
 <span class="s0">* this is in fact a molecular field; otherwise, returns NULL.</span>
 <span class="s0">*/ 1 4 this 3 508  </span>
<span class="s0">24 0 0 6 28 528 0 0 147 /**</span>
 <span class="s0">* Returns the same field pointer converted to a molecular field pointer, if</span>
 <span class="s0">* this is in fact a molecular field; otherwise, returns NULL.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">25 0 0 6 29 530 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 508  </span>
<span class="s0">26 0 0 6 29 531 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">27 0 0 6 30 505 0 0 175 /**</span>
 <span class="s0">* Given a blob that represents the packed data for this field, returns a</span>
 <span class="s0">* string formatting it for human consumption.  Returns empty string if there</span>
 <span class="s0">* is an error.</span>
 <span class="s0">*/ 3 4 this 3 508  11 packed_data 1 533  16 show_field_names 5 517  </span>
<span class="s0">28 0 0 6 31 533 0 0 243 /**</span>
 <span class="s0">* Given a human-formatted string (for instance, as returned by format_data(),</span>
 <span class="s0">* above) that represents the value of this field, parse the string and return</span>
 <span class="s0">* the corresponding packed data.  Returns empty string if there is an error.</span>
 <span class="s0">*/ 2 4 this 3 508  16 formatted_string 1 505  </span>
<span class="s0">29 0 0 6 32 517 0 0 221 /**</span>
 <span class="s0">* Verifies that all of the packed values in the field data are within the</span>
 <span class="s0">* specified ranges and that there are no extra bytes on the end of the</span>
 <span class="s0">* record.  Returns true if all fields are valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 509  11 packed_data 1 533  </span>
<span class="s0">30 0 0 6 33 517 0 0 110 /**</span>
 <span class="s0">* Returns true if a default value has been explicitly established for this</span>
 <span class="s0">* field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">31 0 0 6 34 533 0 0 218 /**</span>
 <span class="s0">* Returns the default value for this field.  If a default value has been</span>
 <span class="s0">* explicitly set (e.g.  has_default_value() returns true), returns that</span>
 <span class="s0">* value; otherwise, returns an implicit default for the field.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">32 0 0 6 35 517 0 0 251 /**</span>
 <span class="s0">* Returns true if the field has been flagged as a bogus field.  This is set</span>
 <span class="s0">* for fields that are generated by the parser as placeholder for missing</span>
 <span class="s0">* fields, as when reading a partial file; it should not occur in a normal</span>
 <span class="s0">* valid dc file.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">33 0 0 6 36 517 0 0 86 /**</span>
 <span class="s0">* Returns true if the &quot;required&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">34 0 0 6 37 517 0 0 90 /**</span>
 <span class="s0">* Returns true if the &quot;broadcast&quot; flag is set for this field, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">35 0 0 6 38 517 0 0 81 /**</span>
 <span class="s0">* Returns true if the &quot;ram&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">36 0 0 6 39 517 0 0 80 /**</span>
 <span class="s0">* Returns true if the &quot;db&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">37 0 0 6 40 517 0 0 84 /**</span>
 <span class="s0">* Returns true if the &quot;clsend&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">38 0 0 6 41 517 0 0 84 /**</span>
 <span class="s0">* Returns true if the &quot;clrecv&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">39 0 0 6 42 517 0 0 85 /**</span>
 <span class="s0">* Returns true if the &quot;ownsend&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">40 0 0 6 43 517 0 0 85 /**</span>
 <span class="s0">* Returns true if the &quot;ownrecv&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">41 0 0 6 44 517 0 0 84 /**</span>
 <span class="s0">* Returns true if the &quot;airecv&quot; flag is set for this field, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 509  </span>
<span class="s0">42 0 0 4 45 537 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 2 4 this 3 509  3 out 1 535  </span>
<span class="s0">43 0 0 4 46 537 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 3 4 this 3 509  3 out 1 535  12 indent_level 1 506  </span>
<span class="s0">44 0 0 6 47 517 0 0 200 /**</span>
 <span class="s0">* Packs the Python arguments from the indicated tuple into the packer.</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* It is assumed that the packer is currently positioned on this field.</span>
 <span class="s0">*/ 3 4 this 3 509  6 packer 1 538  8 sequence 1 539  </span>
<span class="s0">45 0 0 6 48 539 0 0 220 /**</span>
 <span class="s0">* Unpacks the values from the packer, beginning at the current point in the</span>
 <span class="s0">* unpack_buffer, into a Python tuple and returns the tuple.</span>
 <span class="s0">*</span>
 <span class="s0">* It is assumed that the packer is currently positioned on this field.</span>
 <span class="s0">*/ 2 4 this 3 509  6 packer 1 538  </span>
<span class="s0">46 0 0 4 49 537 0 0 135 /**</span>
 <span class="s0">* Extracts the update message out of the datagram and applies it to the</span>
 <span class="s0">* indicated object by calling the appropriate method.</span>
 <span class="s0">*/ 3 4 this 3 509  6 packer 1 538  7 distobj 1 539  </span>
<span class="s0">47 0 0 7 50 546 0 0 139 /**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update for</span>
 <span class="s0">* the indicated distributed object from the client.</span>
 <span class="s0">*/ 3 4 this 3 509  5 do_id 1 543  4 args 1 539  </span>
<span class="s0">48 0 0 7 51 546 0 0 135 /**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update for</span>
 <span class="s0">* the indicated distributed object from the AI.</span>
 <span class="s0">*/ 5 4 this 3 509  5 do_id 1 543  5 to_id 1 547  7 from_id 1 547  4 args 1 539  </span>
<span class="s0">49 0 0 7 52 546 0 0 155 /**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update,</span>
 <span class="s0">* with the msg type, for the indicated distributed object from the AI.</span>
 <span class="s0">*/ 6 4 this 3 509  5 do_id 1 543  5 to_id 1 547  7 from_id 1 547  8 msg_type 1 506  4 args 1 539  </span>
<span class="s0">50 0 0 6 19 507 0 0 0 1 4 this 3 508  </span>
<span class="s0">51 0 0 6 21 550 0 0 0 1 4 this 3 508  </span>
<span class="s0">52 0 0 7 54 551 295 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">53 0 0 15 54 551 295 0 0 1 6 param0 0 552  </span>
<span class="s0">54 0 0 4 56 537 0 0 98 /**</span>
 <span class="s0">* Empties the contents of the data (without necessarily freeing its allocated</span>
 <span class="s0">* memory).</span>
 <span class="s0">*/ 1 4 this 3 551  </span>
<span class="s0">55 0 0 6 57 505 0 0 69 /**</span>
 <span class="s0">* Returns the data buffer as a string.  Also see get_data().</span>
 <span class="s0">*/ 1 4 this 3 552  </span>
<span class="s0">56 0 0 6 58 554 0 0 151 /**</span>
 <span class="s0">* Returns the current length of the buffer.  This is the number of useful</span>
 <span class="s0">* bytes stored in the buffer, not the amount of memory it takes up.</span>
 <span class="s0">*/ 1 4 this 3 552  </span>
<span class="s0">57 0 0 7 60 538 300 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">58 0 0 15 60 538 300 0 0 1 6 param0 0 555  </span>
<span class="s0">59 0 0 4 62 537 0 0 190 /**</span>
 <span class="s0">* Empties the data in the pack buffer and unpack buffer.  This should be</span>
 <span class="s0">* called between calls to begin_pack(), unless you want to concatenate all of</span>
 <span class="s0">* the pack results together.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">60 0 0 4 63 537 0 0 390 /**</span>
 <span class="s0">* Begins a packing session.  The parameter is the DC object that describes</span>
 <span class="s0">* the packing format; it may be a DCParameter or DCField.</span>
 <span class="s0">*</span>
 <span class="s0">* Unless you call clear_data() between sessions, multiple packing sessions</span>
 <span class="s0">* will be concatenated together into the same buffer.  If you wish to add</span>
 <span class="s0">* bytes to the buffer between packing sessions, use append_data() or</span>
 <span class="s0">* get_write_pointer().</span>
 <span class="s0">*/ 2 4 this 3 538  4 root 1 503  </span>
<span class="s0">61 0 0 6 64 517 0 0 138 /**</span>
 <span class="s0">* Finishes a packing session.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true on success, or false if there has been some error</span>
 <span class="s0">* during packing.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">62 0 0 4 65 537 0 0 141 /**</span>
 <span class="s0">* Sets up the unpack_data pointer.  You may call this before calling the</span>
 <span class="s0">* version of begin_unpack() that takes only one parameter.</span>
 <span class="s0">*/ 2 4 this 3 538  4 data 1 533  </span>
<span class="s0">63 0 0 4 66 537 0 0 375 /**</span>
 <span class="s0">* Begins an unpacking session.  You must have previously called</span>
 <span class="s0">* set_unpack_data() to specify a buffer to unpack.</span>
 <span class="s0">*</span>
 <span class="s0">* If there was data left in the buffer after a previous begin_unpack() ..</span>
 <span class="s0">* end_unpack() session, the new session will resume from the current point.</span>
 <span class="s0">* This method may be used, therefore, to unpack a sequence of objects from</span>
 <span class="s0">* the same buffer.</span>
 <span class="s0">*/ 2 4 this 3 538  4 root 1 503  </span>
<span class="s0">64 0 0 6 67 517 0 0 186 /**</span>
 <span class="s0">* Finishes the unpacking session.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true on success, or false if there has been some error</span>
 <span class="s0">* during unpacking (or if all fields have not been unpacked).</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">65 0 0 4 68 537 0 0 562 /**</span>
 <span class="s0">* Begins a repacking session.  You must have previously called</span>
 <span class="s0">* set_unpack_data() to specify a buffer to unpack.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike begin_pack() or begin_unpack() you may not concatenate the results</span>
 <span class="s0">* of multiple begin_repack() sessions in one buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, unlike in packing or unpacking modes, you may not walk through the</span>
 <span class="s0">* fields from beginning to end, or even pack two consecutive fields at once.</span>
 <span class="s0">* Instead, you must call seek() for each field you wish to modify and pack</span>
 <span class="s0">* only that one field; then call seek() again to modify another field.</span>
 <span class="s0">*/ 2 4 this 3 538  4 root 1 503  </span>
<span class="s0">66 0 0 6 69 517 0 0 186 /**</span>
 <span class="s0">* Finishes the repacking session.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true on success, or false if there has been some error</span>
 <span class="s0">* during repacking (or if all fields have not been repacked).</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">67 0 0 6 70 517 0 0 339 /**</span>
 <span class="s0">* Seeks to the field indentified by seek_index, which was returned by an</span>
 <span class="s0">* earlier call to DCField::find_seek_index() to get the index of some nested</span>
 <span class="s0">* field.  Also see the version of seek() that accepts a field name.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false if the field is not known (or if the</span>
 <span class="s0">* packer is in an invalid mode).</span>
 <span class="s0">*/ 2 4 this 3 538  10 seek_index 1 506  </span>
<span class="s0">68 0 0 6 70 517 0 0 368 /**</span>
 <span class="s0">* Sets the current unpack (or repack) position to the named field.  In unpack</span>
 <span class="s0">* mode, the next call to unpack_*() or push() will begin to read the named</span>
 <span class="s0">* field.  In repack mode, the next call to pack_*() or push() will modify the</span>
 <span class="s0">* named field.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false if the field is not known (or if the</span>
 <span class="s0">* packer is in an invalid mode).</span>
 <span class="s0">*/ 2 4 this 3 538  10 field_name 1 505  </span>
<span class="s0">69 0 0 6 71 517 0 0 254 /**</span>
 <span class="s0">* Returns true if the current field has any nested fields (and thus expects a</span>
 <span class="s0">* push() .. pop() interface), or false otherwise.  If this returns true,</span>
 <span class="s0">* get_num_nested_fields() may be called to determine how many nested fields</span>
 <span class="s0">* are expected.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">70 0 0 6 72 506 0 0 517 /**</span>
 <span class="s0">* Returns the number of nested fields associated with the current field, if</span>
 <span class="s0">* has_nested_fields() returned true.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value may be -1 to indicate that a variable number of nested</span>
 <span class="s0">* fields are accepted by this field type (e.g.  a variable-length array).</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this method is unreliable to determine how many fields you must</span>
 <span class="s0">* traverse before you can call pop(), since particularly in the presence of a</span>
 <span class="s0">* DCSwitch, it may change during traversal.  Use more_nested_fields()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">71 0 0 6 73 517 0 0 141 /**</span>
 <span class="s0">* Returns true if there are more nested fields to pack or unpack in the</span>
 <span class="s0">* current push sequence, false if it is time to call pop().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">72 0 0 6 74 503 0 0 175 /**</span>
 <span class="s0">* Returns the field that we left in our last call to push(): the owner of the</span>
 <span class="s0">* current level of fields.  This may be NULL at the beginning of the pack</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">73 0 0 6 75 503 0 0 197 /**</span>
 <span class="s0">* Returns the field that will be referenced by the next call to pack_*() or</span>
 <span class="s0">* unpack_*().  This will be NULL if we have unpacked (or packed) all fields,</span>
 <span class="s0">* or if it is time to call pop().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">74 0 0 6 76 512 0 0 428 /**</span>
 <span class="s0">* Returns a pointer to the last DCSwitch instance that we have passed by and</span>
 <span class="s0">* selected one case of during the pack/unpack process.  Each time we</span>
 <span class="s0">* encounter a new DCSwitch and select a case, this will change state.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used to detect when a DCSwitch has been selected.  At the</span>
 <span class="s0">* moment this changes state, get_current_parent() will contain the particular</span>
 <span class="s0">* SwitchCase that was selected by the switch.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">75 0 0 6 77 484 0 0 438 /**</span>
 <span class="s0">* Returns the type of value expected by the current field.  See the</span>
 <span class="s0">* enumerated type definition at the top of DCPackerInterface.h.  If this</span>
 <span class="s0">* returns one of PT_double, PT_int, PT_int64, or PT_string, then you should</span>
 <span class="s0">* call the corresponding pack_double(), pack_int() function (or</span>
 <span class="s0">* unpack_double(), unpack_int(), etc.) to transfer data.  Otherwise, you</span>
 <span class="s0">* should call push() and begin packing or unpacking the nested fields.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">76 0 0 6 78 505 0 0 154 /**</span>
 <span class="s0">* Returns the name of the current field, if it has a name, or the empty</span>
 <span class="s0">* string if the field does not have a name or there is no current field.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">77 0 0 4 79 537 0 0 315 /**</span>
 <span class="s0">* Marks the beginning of a nested series of fields.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called before filling the elements of an array or the</span>
 <span class="s0">* individual fields in a structure field.  It must also be balanced by a</span>
 <span class="s0">* matching pop().</span>
 <span class="s0">*</span>
 <span class="s0">* It is necessary to use push() / pop() only if has_nested_fields() returns</span>
 <span class="s0">* true.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">78 0 0 4 80 537 0 0 234 /**</span>
 <span class="s0">* Marks the end of a nested series of fields.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called to match a previous push() only after all the expected</span>
 <span class="s0">* number of nested fields have been packed.  It is an error to call it too</span>
 <span class="s0">* early, or too late.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">79 0 0 4 81 537 0 0 71 /**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 557  </span>
<span class="s0">80 0 0 4 82 537 0 0 71 /**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 506  </span>
<span class="s0">81 0 0 4 83 537 0 0 71 /**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 545  </span>
<span class="s0">82 0 0 4 84 537 0 0 71 /**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 558  </span>
<span class="s0">83 0 0 4 85 537 0 0 71 /**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 548  </span>
<span class="s0">84 0 0 4 86 537 0 0 71 /**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 505  </span>
<span class="s0">85 0 0 4 87 537 0 0 71 /**</span>
 <span class="s0">* Packs the indicated numeric or string value into the stream.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 533  </span>
<span class="s0">86 0 0 4 88 537 0 0 155 /**</span>
 <span class="s0">* Adds the indicated string value into the stream, representing a single pre-</span>
 <span class="s0">* packed field element, or a whole group of field elements at once.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 533  </span>
<span class="s0">87 0 0 4 89 537 0 0 158 /**</span>
 <span class="s0">* Adds the default value for the current element into the stream.  If no</span>
 <span class="s0">* default has been set for the current element, creates a sensible default.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">88 0 0 6 90 557 0 0 71 /**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">89 0 0 6 91 506 0 0 71 /**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">90 0 0 6 92 545 0 0 71 /**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">91 0 0 6 93 558 0 0 71 /**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">92 0 0 6 94 548 0 0 71 /**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">93 0 0 6 95 505 0 0 71 /**</span>
 <span class="s0">* Unpacks the current numeric or string value from the stream.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">94 0 0 6 96 533 0 0 65 /**</span>
 <span class="s0">* Unpacks the current binary data value from the stream.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">95 0 0 6 97 533 0 0 127 /**</span>
 <span class="s0">* Returns the literal string that represents the packed value of the current</span>
 <span class="s0">* field, and advances the field pointer.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">96 0 0 4 98 537 0 0 219 /**</span>
 <span class="s0">* Internally unpacks the current numeric or string value and validates it</span>
 <span class="s0">* against the type range limits, but does not return the value.  If the</span>
 <span class="s0">* current field contains nested fields, validates all of them.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">97 0 0 4 99 537 0 0 155 /**</span>
 <span class="s0">* Skips the current field without unpacking it and advances to the next</span>
 <span class="s0">* field.  If the current field contains nested fields, skips all of them.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">98 0 0 4 100 537 0 0 259 /**</span>
 <span class="s0">* Packs the Python object of whatever type into the packer.  Each numeric</span>
 <span class="s0">* object and string object maps to the corresponding pack_value() call; a</span>
 <span class="s0">* tuple or sequence maps to a push() followed by all of the tuple's contents</span>
 <span class="s0">* followed by a pop().</span>
 <span class="s0">*/ 2 4 this 3 538  6 object 1 539  </span>
<span class="s0">99 0 0 6 101 539 0 0 238 /**</span>
 <span class="s0">* Unpacks a Python object of the appropriate type from the stream for the</span>
 <span class="s0">* current field.  This may be an integer or a string for a simple field</span>
 <span class="s0">* object; if the current field represents a list of fields it will be a</span>
 <span class="s0">* tuple.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">100 0 0 6 102 517 0 0 171 /**</span>
 <span class="s0">* Parses an object's value according to the DC file syntax (e.g.  as a</span>
 <span class="s0">* default value string) and packs it.  Returns true on success, false on a</span>
 <span class="s0">* parse error.</span>
 <span class="s0">*/ 2 4 this 3 538  2 in 1 560  </span>
<span class="s0">101 0 0 6 102 517 0 0 171 /**</span>
 <span class="s0">* Parses an object's value according to the DC file syntax (e.g.  as a</span>
 <span class="s0">* default value string) and packs it.  Returns true on success, false on a</span>
 <span class="s0">* parse error.</span>
 <span class="s0">*/ 2 4 this 3 538  16 formatted_object 1 505  </span>
<span class="s0">102 0 0 6 103 505 0 0 163 /**</span>
 <span class="s0">* Unpacks an object and formats its value into a syntax suitable for parsing</span>
 <span class="s0">* in the dc file (e.g.  as a default value), or as an input to parse_object.</span>
 <span class="s0">*/ 2 4 this 3 538  16 show_field_names 5 517  </span>
<span class="s0">103 0 0 4 103 537 0 0 163 /**</span>
 <span class="s0">* Unpacks an object and formats its value into a syntax suitable for parsing</span>
 <span class="s0">* in the dc file (e.g.  as a default value), or as an input to parse_object.</span>
 <span class="s0">*/ 3 4 this 3 538  3 out 1 535  16 show_field_names 5 517  </span>
<span class="s0">104 0 0 6 104 517 0 0 149 /**</span>
 <span class="s0">* Returns true if there has been an parse error since the most recent call to</span>
 <span class="s0">* begin(); this can only happen if you call parse_and_pack().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">105 0 0 6 105 517 0 0 471 /**</span>
 <span class="s0">* Returns true if there has been an packing error since the most recent call</span>
 <span class="s0">* to begin(); in particular, this may be called after end() has returned</span>
 <span class="s0">* false to determine the nature of the failure.</span>
 <span class="s0">*</span>
 <span class="s0">* A return value of true indicates there was a push/pop mismatch, or the</span>
 <span class="s0">* push/pop structure did not match the data structure, or there were the</span>
 <span class="s0">* wrong number of elements in a nested push/pop structure, or on unpack that</span>
 <span class="s0">* the data stream was truncated.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">106 0 0 6 106 517 0 0 400 /**</span>
 <span class="s0">* Returns true if there has been an range validation error since the most</span>
 <span class="s0">* recent call to begin(); in particular, this may be called after end() has</span>
 <span class="s0">* returned false to determine the nature of the failure.</span>
 <span class="s0">*</span>
 <span class="s0">* A return value of true indicates a value that was packed or unpacked did</span>
 <span class="s0">* not fit within the specified legal range for a parameter, or within the</span>
 <span class="s0">* limits of the field size.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">107 0 0 6 107 517 0 0 222 /**</span>
 <span class="s0">* Returns true if there has been any error (either a pack error or a range</span>
 <span class="s0">* error) since the most recent call to begin().  If this returns true, then</span>
 <span class="s0">* the matching call to end() will indicate an error (false).</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">108 0 0 6 108 554 0 0 290 /**</span>
 <span class="s0">* Returns the number of bytes that have been unpacked so far, or after</span>
 <span class="s0">* unpack_end(), the total number of bytes that were unpacked at all.  This</span>
 <span class="s0">* can be used to validate that all of the bytes in the buffer were actually</span>
 <span class="s0">* unpacked (which is not otherwise considered an error).</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">109 0 0 6 109 554 0 0 151 /**</span>
 <span class="s0">* Returns the current length of the buffer.  This is the number of useful</span>
 <span class="s0">* bytes stored in the buffer, not the amount of memory it takes up.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">110 0 0 6 110 505 0 0 76 /**</span>
 <span class="s0">* Returns the packed data buffer as a string.  Also see get_data().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">111 0 0 6 111 533 0 0 82 /**</span>
 <span class="s0">* Returns the packed data buffer as a bytes object.  Also see get_data().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">112 0 0 6 112 554 0 0 210 /**</span>
 <span class="s0">* Returns the total number of bytes in the unpack data buffer.  This is the</span>
 <span class="s0">* buffer used when unpacking; it is separate from the pack data returned by</span>
 <span class="s0">* get_length(), which is filled during packing.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">113 0 0 6 113 505 0 0 223 /**</span>
 <span class="s0">* Returns the unpack data buffer, as a string.  This is the buffer used when</span>
 <span class="s0">* unpacking; it is separate from the pack data returned by get_string(),</span>
 <span class="s0">* which is filled during packing.  Also see get_unpack_data().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">114 0 0 6 114 506 0 0 221 /**</span>
 <span class="s0">* Returns the number of DCPacker::StackElement pointers ever simultaneously</span>
 <span class="s0">* allocated; these are now either in active use or have been recycled into</span>
 <span class="s0">* the deleted DCPacker::StackElement pool to be used again.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">115 0 0 4 115 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 506  </span>
<span class="s0">116 0 0 4 116 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 506  </span>
<span class="s0">117 0 0 4 117 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 506  </span>
<span class="s0">118 0 0 4 118 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 558  </span>
<span class="s0">119 0 0 4 119 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 545  </span>
<span class="s0">120 0 0 4 120 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 545  </span>
<span class="s0">121 0 0 4 121 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 545  </span>
<span class="s0">122 0 0 4 122 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 548  </span>
<span class="s0">123 0 0 4 123 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 557  </span>
<span class="s0">124 0 0 4 124 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 505  </span>
<span class="s0">125 0 0 4 125 537 0 0 67 /**</span>
 <span class="s0">* Packs the data into the buffer between packing sessions.</span>
 <span class="s0">*/ 2 4 this 3 538  5 value 1 533  </span>
<span class="s0">126 0 0 6 126 506 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">127 0 0 6 127 506 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">128 0 0 6 128 506 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">129 0 0 6 129 558 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">130 0 0 6 130 545 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">131 0 0 6 131 545 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">132 0 0 6 132 545 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">133 0 0 6 133 548 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">134 0 0 6 134 557 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">135 0 0 6 135 505 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">136 0 0 6 136 533 0 0 71 /**</span>
 <span class="s0">* Unpacks the data from the buffer between unpacking sessions.</span>
 <span class="s0">*/ 1 4 this 3 538  </span>
<span class="s0">137 0 0 6 138 562 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 530  </span>
<span class="s0">138 0 0 6 138 563 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 531  </span>
<span class="s0">139 0 0 6 139 565 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 530  </span>
<span class="s0">140 0 0 6 139 566 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 531  </span>
<span class="s0">141 0 0 6 140 530 0 0 0 1 4 this 3 531  </span>
<span class="s0">142 0 0 6 141 517 0 0 0 1 4 this 3 531  </span>
<span class="s0">143 0 0 6 142 568 0 0 139 /**</span>
 <span class="s0">* If this type has been referenced from a typedef, returns the DCTypedef</span>
 <span class="s0">* instance, or NULL if the type was declared on-the-fly.</span>
 <span class="s0">*/ 1 4 this 3 531  </span>
<span class="s0">144 0 0 6 144 530 0 0 69 /**</span>
 <span class="s0">* Returns the type of the individual elements of this array.</span>
 <span class="s0">*/ 1 4 this 3 566  </span>
<span class="s0">145 0 0 6 145 506 0 0 127 /**</span>
 <span class="s0">* Returns the fixed number of elements in this array, or -1 if the array may</span>
 <span class="s0">* contain a variable number of elements.</span>
 <span class="s0">*/ 1 4 this 3 566  </span>
<span class="s0">146 0 0 6 147 506 0 0 75 /**</span>
 <span class="s0">* Returns the number of elements (parameters) of the atomic field.</span>
 <span class="s0">*/ 1 4 this 3 525  </span>
<span class="s0">147 0 0 6 148 530 0 0 67 /**</span>
 <span class="s0">* Returns the parameter object describing the nth element.</span>
 <span class="s0">*/ 2 4 this 3 525  1 n 1 506  </span>
<span class="s0">148 0 0 6 149 533 0 0 441 /**</span>
 <span class="s0">* Returns the pre-formatted default value associated with the nth element of</span>
 <span class="s0">* the field.  This is only valid if has_element_default() returns true, in</span>
 <span class="s0">* which case this string represents the bytes that should be assigned to the</span>
 <span class="s0">* field as a default value.</span>
 <span class="s0">*</span>
 <span class="s0">* If the element is an array-type element, the returned value will include</span>
 <span class="s0">* the two-byte length preceding the array data.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated use get_element() instead.</span>
 <span class="s0">*/ 2 4 this 3 525  1 n 1 506  </span>
<span class="s0">149 0 0 6 150 517 0 0 151 /**</span>
 <span class="s0">* Returns true if the nth element of the field has a default value specified,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated use get_element() instead.</span>
 <span class="s0">*/ 2 4 this 3 525  1 n 1 506  </span>
<span class="s0">150 0 0 6 151 505 0 0 272 /**</span>
 <span class="s0">* Returns the name of the nth element of the field.  This name is strictly</span>
 <span class="s0">* for documentary purposes; it does not generally affect operation.  If a</span>
 <span class="s0">* name is not specified, this will be the empty string.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated use get_element()-&gt;get_name() instead.</span>
 <span class="s0">*/ 2 4 this 3 525  1 n 1 506  </span>
<span class="s0">151 0 0 6 152 483 0 0 126 /**</span>
 <span class="s0">* Returns the numeric type of the nth element of the field.  This method is</span>
 <span class="s0">* deprecated; use get_element() instead.</span>
 <span class="s0">*/ 2 4 this 3 525  1 n 1 506  </span>
<span class="s0">152 0 0 6 153 506 0 0 340 /**</span>
 <span class="s0">* Returns the divisor associated with the nth element of the field.  This</span>
 <span class="s0">* implements an implicit fixed-point system; floating-point values are to be</span>
 <span class="s0">* multiplied by this value before encoding into a packet, and divided by this</span>
 <span class="s0">* number after decoding.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is deprecated; use get_element()-&gt;get_divisor() instead.</span>
 <span class="s0">*/ 2 4 this 3 525  1 n 1 506  </span>
<span class="s0">153 0 0 6 156 523 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 570  </span>
<span class="s0">154 0 0 6 156 573 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 571  </span>
<span class="s0">155 0 0 6 157 575 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 570  </span>
<span class="s0">156 0 0 6 157 576 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 571  </span>
<span class="s0">157 0 0 4 158 537 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 2 4 this 3 571  3 out 1 535  </span>
<span class="s0">158 0 0 4 159 537 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 3 4 this 3 571  3 out 1 535  12 indent_level 1 506  </span>
<span class="s0">159 0 0 6 161 518 0 0 61 /**</span>
 <span class="s0">* Returns the DCFile object that contains the class.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">160 0 0 6 162 505 0 0 42 /**</span>
 <span class="s0">* Returns the name of this class.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">161 0 0 6 163 506 0 0 130 /**</span>
 <span class="s0">* Returns a unique index number associated with this class.  This is defined</span>
 <span class="s0">* implicitly when the .dc file(s) are read.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">162 0 0 6 164 506 0 0 71 /**</span>
 <span class="s0">* Returns the number of base classes this class inherits from.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">163 0 0 6 165 523 0 0 65 /**</span>
 <span class="s0">* Returns the nth parent class this class inherits from.</span>
 <span class="s0">*/ 2 4 this 3 573  1 n 1 506  </span>
<span class="s0">164 0 0 6 166 517 0 0 113 /**</span>
 <span class="s0">* Returns true if this class has a constructor method, false if it just uses</span>
 <span class="s0">* the default constructor.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">165 0 0 6 167 508 0 0 128 /**</span>
 <span class="s0">* Returns the constructor method for this class if it is defined, or NULL if</span>
 <span class="s0">* the class uses the default constructor.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">166 0 0 6 168 506 0 0 96 /**</span>
 <span class="s0">* Returns the number of fields defined directly in this class, ignoring</span>
 <span class="s0">* inheritance.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">167 0 0 6 169 508 0 0 176 /**</span>
 <span class="s0">* Returns the nth field in the class.  This is not necessarily the field with</span>
 <span class="s0">* index n; this is the nth field defined in the class directly, ignoring</span>
 <span class="s0">* inheritance.</span>
 <span class="s0">*/ 2 4 this 3 573  1 n 1 506  </span>
<span class="s0">168 0 0 6 170 508 0 0 294 /**</span>
 <span class="s0">* Returns a pointer to the DCField that shares the indicated name.  If the</span>
 <span class="s0">* named field is not found in the current class, the parent classes will be</span>
 <span class="s0">* searched, so the value returned may not actually be a field within this</span>
 <span class="s0">* class.  Returns NULL if there is no such field defined.</span>
 <span class="s0">*/ 2 4 this 3 573  4 name 1 505  </span>
<span class="s0">169 0 0 6 171 508 0 0 302 /**</span>
 <span class="s0">* Returns a pointer to the DCField that has the indicated index number.  If</span>
 <span class="s0">* the numbered field is not found in the current class, the parent classes</span>
 <span class="s0">* will be searched, so the value returned may not actually be a field within</span>
 <span class="s0">* this class.  Returns NULL if there is no such field defined.</span>
 <span class="s0">*/ 2 4 this 3 573  12 index_number 1 506  </span>
<span class="s0">170 0 0 6 172 506 0 0 102 /**</span>
 <span class="s0">* Returns the total number of field fields defined in this class and all</span>
 <span class="s0">* ancestor classes.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">171 0 0 6 173 508 0 0 315 /**</span>
 <span class="s0">* Returns the nth field field in the class and all of its ancestors.</span>
 <span class="s0">*</span>
 <span class="s0">* This *used* to be the same thing as get_field_by_index(), back when the</span>
 <span class="s0">* fields were numbered sequentially within a class's inheritance hierarchy.</span>
 <span class="s0">* Now that fields have a globally unique index number, this is no longer</span>
 <span class="s0">* true.</span>
 <span class="s0">*/ 2 4 this 3 573  1 n 1 506  </span>
<span class="s0">172 0 0 6 174 517 0 0 141 /**</span>
 <span class="s0">* Returns true if the class has been identified with the &quot;struct&quot; keyword in</span>
 <span class="s0">* the dc file, false if it was declared with &quot;dclass&quot;.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">173 0 0 6 175 517 0 0 253 /**</span>
 <span class="s0">* Returns true if the class has been flagged as a bogus class.  This is set</span>
 <span class="s0">* for classes that are generated by the parser as placeholder for missing</span>
 <span class="s0">* classes, as when reading a partial file; it should not occur in a normal</span>
 <span class="s0">* valid dc file.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">174 0 0 6 176 517 0 0 172 /**</span>
 <span class="s0">* Returns true if this class, or any class in the inheritance heirarchy for</span>
 <span class="s0">* this class, is a &quot;bogus&quot; class--a forward reference to an as-yet-undefined</span>
 <span class="s0">* class.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">175 0 0 4 177 537 0 0 255 /**</span>
 <span class="s0">* Starts the PStats timer going on the &quot;generate&quot; task, that is, marks the</span>
 <span class="s0">* beginning of the process of generating a new object, for the purposes of</span>
 <span class="s0">* timing this process.</span>
 <span class="s0">*</span>
 <span class="s0">* This should balance with a corresponding call to stop_generate().</span>
 <span class="s0">*/ 1 4 this 3 523  </span>
<span class="s0">176 0 0 4 178 537 0 0 124 /**</span>
 <span class="s0">* Stops the PStats timer on the &quot;generate&quot; task.  This should balance with a</span>
 <span class="s0">* preceding call to start_generate().</span>
 <span class="s0">*/ 1 4 this 3 523  </span>
<span class="s0">177 0 0 4 179 537 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 2 4 this 3 573  3 out 1 535  </span>
<span class="s0">178 0 0 6 180 517 0 0 108 /**</span>
 <span class="s0">* Returns true if the DCClass object has an associated Python class</span>
 <span class="s0">* definition, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">179 0 0 4 181 537 0 0 141 /**</span>
 <span class="s0">* Sets the class object associated with this DistributedClass.  This object</span>
 <span class="s0">* will be used to construct new instances of the class.</span>
 <span class="s0">*/ 2 4 this 3 523  9 class_def 1 539  </span>
<span class="s0">180 0 0 6 182 539 0 0 146 /**</span>
 <span class="s0">* Returns the class object that was previously associated with this</span>
 <span class="s0">* DistributedClass.  This will return a new reference to the object.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">181 0 0 6 183 517 0 0 114 /**</span>
 <span class="s0">* Returns true if the DCClass object has an associated Python owner class</span>
 <span class="s0">* definition, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">182 0 0 4 184 537 0 0 153 /**</span>
 <span class="s0">* Sets the owner class object associated with this DistributedClass.  This</span>
 <span class="s0">* object will be used to construct new owner instances of the class.</span>
 <span class="s0">*/ 2 4 this 3 523  15 owner_class_def 1 539  </span>
<span class="s0">183 0 0 6 185 539 0 0 152 /**</span>
 <span class="s0">* Returns the owner class object that was previously associated with this</span>
 <span class="s0">* DistributedClass.  This will return a new reference to the object.</span>
 <span class="s0">*/ 1 4 this 3 573  </span>
<span class="s0">184 0 0 4 186 537 0 0 133 /**</span>
 <span class="s0">* Extracts the update message out of the packer and applies it to the</span>
 <span class="s0">* indicated object by calling the appropriate method.</span>
 <span class="s0">*/ 3 4 this 3 573  7 distobj 1 539  2 di 1 578  </span>
<span class="s0">185 0 0 4 187 537 0 0 224 /**</span>
 <span class="s0">* Processes a big datagram that includes all of the &quot;required&quot; fields that</span>
 <span class="s0">* are sent along with a normal &quot;generate with required&quot; message.  This is all</span>
 <span class="s0">* of the atomic fields that are marked &quot;broadcast required&quot;.</span>
 <span class="s0">*/ 3 4 this 3 573  7 distobj 1 539  2 di 1 578  </span>
<span class="s0">186 0 0 4 188 537 0 0 267 /**</span>
 <span class="s0">* Processes a big datagram that includes all of the &quot;required&quot; fields that</span>
 <span class="s0">* are sent along with a normal &quot;generate with required&quot; message.  This is all</span>
 <span class="s0">* of the atomic fields that are marked &quot;broadcast ownrecv&quot;. Should be used</span>
 <span class="s0">* for 'owner-view' objects.</span>
 <span class="s0">*/ 3 4 this 3 573  7 distobj 1 539  2 di 1 578  </span>
<span class="s0">187 0 0 4 189 537 0 0 222 /**</span>
 <span class="s0">* Processes a big datagram that includes all of the &quot;required&quot; fields that</span>
 <span class="s0">* are sent when an avatar is created.  This is all of the atomic fields that</span>
 <span class="s0">* are marked &quot;required&quot;, whether they are broadcast or not.</span>
 <span class="s0">*/ 3 4 this 3 573  7 distobj 1 539  2 di 1 578  </span>
<span class="s0">188 0 0 4 190 537 0 0 101 /**</span>
 <span class="s0">* Processes a datagram that lists some additional fields that are broadcast</span>
 <span class="s0">* in one chunk.</span>
 <span class="s0">*/ 3 4 this 3 573  7 distobj 1 539  2 di 1 578  </span>
<span class="s0">189 0 0 4 191 537 0 0 72 /**</span>
 <span class="s0">* Processes an update for a named field from a packed datagram.</span>
 <span class="s0">*/ 4 4 this 3 523  7 distobj 1 539  10 field_name 1 505  8 datagram 1 580  </span>
<span class="s0">190 0 0 4 191 537 0 0 74 /**</span>
 <span class="s0">* Processes an update for a named field from a packed value blob.</span>
 <span class="s0">*/ 4 4 this 3 523  7 distobj 1 539  10 field_name 1 505  10 value_blob 1 533  </span>
<span class="s0">191 0 0 6 192 517 0 0 356 /**</span>
 <span class="s0">* Looks up the current value of the indicated field by calling the</span>
 <span class="s0">* appropriate get*() function, then packs that value into the packer.  This</span>
 <span class="s0">* field is presumably either a required field or a specified optional field,</span>
 <span class="s0">* and we are building up a datagram for the generate-with-required message.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/ 4 4 this 3 573  6 packer 1 538  7 distobj 1 539  5 field 1 509  </span>
<span class="s0">192 0 0 6 192 517 0 0 358 /**</span>
 <span class="s0">* Looks up the current value of the indicated field by calling the</span>
 <span class="s0">* appropriate get*() function, then packs that value into the datagram.  This</span>
 <span class="s0">* field is presumably either a required field or a specified optional field,</span>
 <span class="s0">* and we are building up a datagram for the generate-with-required message.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/ 4 4 this 3 573  8 datagram 1 546  7 distobj 1 539  5 field 1 509  </span>
<span class="s0">193 0 0 7 193 546 0 0 139 /**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update for</span>
 <span class="s0">* the indicated distributed object from the client.</span>
 <span class="s0">*/ 4 4 this 3 573  10 field_name 1 505  5 do_id 1 543  4 args 1 539  </span>
<span class="s0">194 0 0 7 194 546 0 0 135 /**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update for</span>
 <span class="s0">* the indicated distributed object from the AI.</span>
 <span class="s0">*/ 6 4 this 3 573  10 field_name 1 505  5 do_id 1 543  5 to_id 1 547  7 from_id 1 547  4 args 1 539  </span>
<span class="s0">195 0 0 7 195 546 0 0 168 /**</span>
 <span class="s0">* Generates a datagram containing the message necessary to send an update,</span>
 <span class="s0">* using the indicated msg type for the indicated distributed object from the</span>
 <span class="s0">* AI.</span>
 <span class="s0">*/ 7 4 this 3 573  10 field_name 1 505  5 do_id 1 543  5 to_id 1 547  7 from_id 1 547  8 msg_type 1 506  4 args 1 539  </span>
<span class="s0">196 0 0 7 196 546 0 0 0 8 4 this 3 573  7 distobj 1 539  5 do_id 1 543  9 parent_id 1 582  7 zone_id 1 582  19 district_channel_id 1 547  15 from_channel_id 1 547  15 optional_fields 1 539  </span>
<span class="s0">197 0 0 7 197 546 0 0 369 /**</span>
 <span class="s0">* Generates a datagram containing the message necessary to generate a new</span>
 <span class="s0">* distributed object from the client.  This requires querying the object for</span>
 <span class="s0">* the initial value of its required fields.</span>
 <span class="s0">*</span>
 <span class="s0">* optional_fields is a list of fieldNames to generate in addition to the</span>
 <span class="s0">* normal required fields.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is only called by the CMU implementation.</span>
 <span class="s0">*/ 5 4 this 3 573  7 distobj 1 539  5 do_id 1 543  7 zone_id 1 582  15 optional_fields 1 539  </span>
<span class="s0">198 0 0 6 199 573 0 0 62 /**</span>
 <span class="s0">* Returns the class object this parameter represents.</span>
 <span class="s0">*/ 1 4 this 3 515  </span>
<span class="s0">199 0 0 7 202 518 435 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">200 0 0 15 202 518 435 0 0 1 6 param0 0 583  </span>
<span class="s0">201 0 0 4 204 537 0 0 106 /**</span>
 <span class="s0">* Removes all of the classes defined within the DCFile and prepares it for</span>
 <span class="s0">* reading a new file.</span>
 <span class="s0">*/ 1 4 this 3 518  </span>
<span class="s0">202 0 0 6 205 517 0 0 146 /**</span>
 <span class="s0">* This special method reads all of the .dc files named by the &quot;dc-file&quot;</span>
 <span class="s0">* config.prc variable, and loads them into the DCFile namespace.</span>
 <span class="s0">*/ 1 4 this 3 518  </span>
<span class="s0">203 0 0 6 206 517 0 0 327 /**</span>
 <span class="s0">* Opens and reads the indicated .dc file by name.  The distributed classes</span>
 <span class="s0">* defined in the file will be appended to the set of distributed classes</span>
 <span class="s0">* already recorded, if any.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the file is successfully read, false if there was an error</span>
 <span class="s0">* (in which case the file might have been partially read).</span>
 <span class="s0">*/ 2 4 this 3 518  8 filename 1 585  </span>
<span class="s0">204 0 0 6 206 517 0 0 434 /**</span>
 <span class="s0">* Parses the already-opened input stream for distributed class descriptions.</span>
 <span class="s0">* The filename parameter is optional and is only used when reporting errors.</span>
 <span class="s0">*</span>
 <span class="s0">* The distributed classes defined in the file will be appended to the set of</span>
 <span class="s0">* distributed classes already recorded, if any.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the file is successfully read, false if there was an error</span>
 <span class="s0">* (in which case the file might have been partially read).</span>
 <span class="s0">*/ 3 4 this 3 518  2 in 1 560  8 filename 5 505  </span>
<span class="s0">205 0 0 6 207 517 0 0 218 /**</span>
 <span class="s0">* Opens the indicated filename for output and writes a parseable description</span>
 <span class="s0">* of all the known distributed classes to the file.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the description is successfully written, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 583  8 filename 1 585  5 brief 1 517  </span>
<span class="s0">206 0 0 6 207 517 0 0 176 /**</span>
 <span class="s0">* Writes a parseable description of all the known distributed classes to the</span>
 <span class="s0">* stream.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the description is successfully written, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 583  3 out 1 535  5 brief 1 517  </span>
<span class="s0">207 0 0 6 208 506 0 0 67 /**</span>
 <span class="s0">* Returns the number of classes read from the .dc file(s).</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">208 0 0 6 209 523 0 0 59 /**</span>
 <span class="s0">* Returns the nth class read from the .dc file(s).</span>
 <span class="s0">*/ 2 4 this 3 583  1 n 1 506  </span>
<span class="s0">209 0 0 6 210 523 0 0 95 /**</span>
 <span class="s0">* Returns the class that has the indicated name, or NULL if there is no such</span>
 <span class="s0">* class.</span>
 <span class="s0">*/ 2 4 this 3 583  4 name 1 505  </span>
<span class="s0">210 0 0 6 211 575 0 0 97 /**</span>
 <span class="s0">* Returns the switch that has the indicated name, or NULL if there is no such</span>
 <span class="s0">* switch.</span>
 <span class="s0">*/ 2 4 this 3 583  4 name 1 505  </span>
<span class="s0">211 0 0 6 212 508 0 0 354 /**</span>
 <span class="s0">* Returns a pointer to the one DCField that has the indicated index number,</span>
 <span class="s0">* of all the DCFields across all classes in the file.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is only valid if dc-multiple-inheritance is set true in the</span>
 <span class="s0">* Config.prc file.  Without this setting, different DCFields may share the</span>
 <span class="s0">* same index number, so this global lookup is not possible.</span>
 <span class="s0">*/ 2 4 this 3 583  12 index_number 1 506  </span>
<span class="s0">212 0 0 6 213 517 0 0 208 /**</span>
 <span class="s0">* Returns true if all of the classes read from the DC file were defined and</span>
 <span class="s0">* valid, or false if any of them were undefined (&quot;bogus classes&quot;).  If this</span>
 <span class="s0">* is true, we might have read a partial file.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">213 0 0 6 214 506 0 0 72 /**</span>
 <span class="s0">* Returns the number of import lines read from the .dc file(s).</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">214 0 0 6 215 505 0 0 85 /**</span>
 <span class="s0">* Returns the module named by the nth import line read from the .dc file(s).</span>
 <span class="s0">*/ 2 4 this 3 583  1 n 1 506  </span>
<span class="s0">215 0 0 6 216 506 0 0 217 /**</span>
 <span class="s0">* Returns the number of symbols explicitly imported by the nth import line.</span>
 <span class="s0">* If this is 0, the line is &quot;import modulename&quot;; if it is more than 0, the</span>
 <span class="s0">* line is &quot;from modulename import symbol, symbol ... &quot;.</span>
 <span class="s0">*/ 2 4 this 3 583  1 n 1 506  </span>
<span class="s0">216 0 0 6 217 505 0 0 92 /**</span>
 <span class="s0">* Returns the ith symbol named by the nth import line read from the .dc</span>
 <span class="s0">* file(s).</span>
 <span class="s0">*/ 3 4 this 3 583  1 n 1 506  1 i 1 506  </span>
<span class="s0">217 0 0 6 218 506 0 0 68 /**</span>
 <span class="s0">* Returns the number of typedefs read from the .dc file(s).</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">218 0 0 6 219 587 0 0 61 /**</span>
 <span class="s0">* Returns the nth typedef read from the .dc file(s).</span>
 <span class="s0">*/ 2 4 this 3 583  1 n 1 506  </span>
<span class="s0">219 0 0 6 220 587 0 0 104 /**</span>
 <span class="s0">* Returns the typedef that has the indicated name, or NULL if there is no</span>
 <span class="s0">* such typedef name.</span>
 <span class="s0">*/ 2 4 this 3 583  4 name 1 505  </span>
<span class="s0">220 0 0 6 221 506 0 0 68 /**</span>
 <span class="s0">* Returns the number of keywords read from the .dc file(s).</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">221 0 0 6 222 521 0 0 61 /**</span>
 <span class="s0">* Returns the nth keyword read from the .dc file(s).</span>
 <span class="s0">*/ 2 4 this 3 583  1 n 1 506  </span>
<span class="s0">222 0 0 6 223 521 0 0 104 /**</span>
 <span class="s0">* Returns the keyword that has the indicated name, or NULL if there is no</span>
 <span class="s0">* such keyword name.</span>
 <span class="s0">*/ 2 4 this 3 583  4 name 1 505  </span>
<span class="s0">223 0 0 6 224 588 0 0 241 /**</span>
 <span class="s0">* Returns a 32-bit hash index associated with this file.  This number is</span>
 <span class="s0">* guaranteed to be consistent if the contents of the file have not changed,</span>
 <span class="s0">* and it is very likely to be different if the contents of the file do</span>
 <span class="s0">* change.</span>
 <span class="s0">*/ 1 4 this 3 583  </span>
<span class="s0">224 0 0 6 226 505 0 0 44 /**</span>
 <span class="s0">* Returns the name of this keyword.</span>
 <span class="s0">*/ 1 4 this 3 521  </span>
<span class="s0">225 0 0 6 228 506 0 0 81 /**</span>
 <span class="s0">* Returns the number of atomic fields that make up this molecular field.</span>
 <span class="s0">*/ 1 4 this 3 528  </span>
<span class="s0">226 0 0 6 229 524 0 0 178 /**</span>
 <span class="s0">* Returns the nth atomic field that makes up this molecular field.  This may</span>
 <span class="s0">* or may not be a field of this particular class; it might be defined in a</span>
 <span class="s0">* parent class.</span>
 <span class="s0">*/ 2 4 this 3 528  1 n 1 506  </span>
<span class="s0">227 0 0 6 232 483 0 0 78 /**</span>
 <span class="s0">* Returns the particular subatomic type represented by this instance.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">228 0 0 6 233 517 0 0 75 /**</span>
 <span class="s0">* Returns true if there is a modulus associated, false otherwise.,</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">229 0 0 6 234 557 0 0 269 /**</span>
 <span class="s0">* Returns the modulus associated with this type, if any.  It is an error to</span>
 <span class="s0">* call this if has_modulus() returned false.</span>
 <span class="s0">*</span>
 <span class="s0">* If present, this is the modulus that is used to constrain the numeric value</span>
 <span class="s0">* of the field before it is packed (and range-checked).</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">230 0 0 6 235 506 0 0 292 /**</span>
 <span class="s0">* Returns the divisor associated with this type.  This is 1 by default, but</span>
 <span class="s0">* if this is other than one it represents the scale to apply when packing and</span>
 <span class="s0">* unpacking numeric values (to store fixed-point values in an integer field).</span>
 <span class="s0">* It is only meaningful for numeric-type fields.</span>
 <span class="s0">*/ 1 4 this 3 563  </span>
<span class="s0">231 0 0 6 238 505 0 0 43 /**</span>
 <span class="s0">* Returns the name of this switch.</span>
 <span class="s0">*/ 1 4 this 3 576  </span>
<span class="s0">232 0 0 6 239 508 0 0 189 /**</span>
 <span class="s0">* Returns the key parameter on which the switch is based.  The value of this</span>
 <span class="s0">* parameter in the record determines which one of the several cases within</span>
 <span class="s0">* the switch will be used.</span>
 <span class="s0">*/ 1 4 this 3 576  </span>
<span class="s0">233 0 0 6 240 506 0 0 140 /**</span>
 <span class="s0">* Returns the number of different cases within the switch.  The legal values</span>
 <span class="s0">* for case_index range from 0 to get_num_cases() - 1.</span>
 <span class="s0">*/ 1 4 this 3 576  </span>
<span class="s0">234 0 0 6 241 506 0 0 116 /**</span>
 <span class="s0">* Returns the index number of the case with the indicated packed value, or -1</span>
 <span class="s0">* if no case has this value.</span>
 <span class="s0">*/ 2 4 this 3 576  10 case_value 1 533  </span>
<span class="s0">235 0 0 6 242 507 0 0 65 /**</span>
 <span class="s0">* Returns the DCPackerInterface that packs the nth case.</span>
 <span class="s0">*/ 2 4 this 3 576  1 n 1 506  </span>
<span class="s0">236 0 0 6 243 507 0 0 109 /**</span>
 <span class="s0">* Returns the DCPackerInterface that packs the default case, or NULL if there</span>
 <span class="s0">* is no default case.</span>
 <span class="s0">*/ 1 4 this 3 576  </span>
<span class="s0">237 0 0 6 244 533 0 0 71 /**</span>
 <span class="s0">* Returns the packed value associated with the indicated case.</span>
 <span class="s0">*/ 2 4 this 3 576  10 case_index 1 506  </span>
<span class="s0">238 0 0 6 245 506 0 0 62 /**</span>
 <span class="s0">* Returns the number of fields in the indicated case.</span>
 <span class="s0">*/ 2 4 this 3 576  10 case_index 1 506  </span>
<span class="s0">239 0 0 6 246 508 0 0 55 /**</span>
 <span class="s0">* Returns the nth field in the indicated case.</span>
 <span class="s0">*/ 3 4 this 3 576  10 case_index 1 506  1 n 1 506  </span>
<span class="s0">240 0 0 6 247 508 0 0 111 /**</span>
 <span class="s0">* Returns the field with the given name from the indicated case, or NULL if</span>
 <span class="s0">* no field has this name.</span>
 <span class="s0">*/ 3 4 this 3 576  10 case_index 1 506  4 name 1 505  </span>
<span class="s0">241 0 0 6 249 576 0 0 63 /**</span>
 <span class="s0">* Returns the switch object this parameter represents.</span>
 <span class="s0">*/ 1 4 this 3 512  </span>
<span class="s0">242 0 0 6 252 506 0 0 142 /**</span>
 <span class="s0">* Returns a unique index number associated with this typedef definition.</span>
 <span class="s0">* This is defined implicitly when the .dc file(s) are read.</span>
 <span class="s0">*/ 1 4 this 3 568  </span>
<span class="s0">243 0 0 6 253 505 0 0 44 /**</span>
 <span class="s0">* Returns the name of this typedef.</span>
 <span class="s0">*/ 1 4 this 3 568  </span>
<span class="s0">244 0 0 6 254 505 0 0 83 /**</span>
 <span class="s0">* Returns a brief decription of the typedef, useful for human consumption.</span>
 <span class="s0">*/ 1 4 this 3 568  </span>
<span class="s0">245 0 0 6 255 517 0 0 259 /**</span>
 <span class="s0">* Returns true if the typedef has been flagged as a bogus typedef.  This is</span>
 <span class="s0">* set for typedefs that are generated by the parser as placeholder for</span>
 <span class="s0">* missing typedefs, as when reading a partial file; it should not occur in a</span>
 <span class="s0">* normal valid dc file.</span>
 <span class="s0">*/ 1 4 this 3 568  </span>
<span class="s0">246 0 0 6 256 517 0 0 157 /**</span>
 <span class="s0">* Returns true if the typedef has been flagged as an implicit typedef,</span>
 <span class="s0">* meaning it was created for a DCClass that was referenced inline as a type.</span>
 <span class="s0">*/ 1 4 this 3 568  </span>
<span class="s0">106</span>
<span class="s0">483 15 DCSubatomicType 0 532481 15 DCSubatomicType 15 DCSubatomicType 0 0 0 0 0 0 0 0 0 0 21 7 ST_int8 7 ST_int8 0</span>
<span class="s0">0 8 ST_int16 8 ST_int16 0</span>
<span class="s0">1 8 ST_int32 8 ST_int32 0</span>
<span class="s0">2 8 ST_int64 8 ST_int64 0</span>
<span class="s0">3 8 ST_uint8 8 ST_uint8 0</span>
<span class="s0">4 9 ST_uint16 9 ST_uint16 0</span>
<span class="s0">5 9 ST_uint32 9 ST_uint32 0</span>
<span class="s0">6 9 ST_uint64 9 ST_uint64 0</span>
<span class="s0">7 10 ST_float64 10 ST_float64 0</span>
<span class="s0">8 9 ST_string 9 ST_string 27</span>
<span class="s0">// a human-printable string</span>
<span class="s0">9 7 ST_blob 7 ST_blob 50</span>
<span class="s0">// any variable length message, stored as a string</span>
<span class="s0">10 9 ST_blob32 9 ST_blob32 49</span>
<span class="s0">// a blob with a 32-bit length, up to 4.2 GB long</span>
<span class="s0">11 13 ST_int16array 13 ST_int16array 0</span>
<span class="s0">12 13 ST_int32array 13 ST_int32array 0</span>
<span class="s0">13 14 ST_uint16array 14 ST_uint16array 0</span>
<span class="s0">14 14 ST_uint32array 14 ST_uint32array 0</span>
<span class="s0">15 12 ST_int8array 12 ST_int8array 0</span>
<span class="s0">16 13 ST_uint8array 13 ST_uint8array 0</span>
<span class="s0">17 19 ST_uint32uint8array 19 ST_uint32uint8array 121</span>
<span class="s0">// A special-purpose array: a list of alternating uint32 and uint8 values.</span>
<span class="s0">// In Python, this becomes a list of 2-tuples.</span>
<span class="s0">18 7 ST_char 7 ST_char 73</span>
<span class="s0">// Equivalent to uint8, except that it suggests a pack_type of PT_string.</span>
<span class="s0">19 10 ST_invalid 10 ST_invalid 0</span>
<span class="s0">20 0 188</span>
<span class="s0">/**</span>
 <span class="s0">* This defines the numeric type of each element of a DCAtomicField; that is,</span>
 <span class="s0">* the particular values that will get added to the message when the atomic</span>
 <span class="s0">* field method is called.</span>
 <span class="s0">*/</span>

<span class="s0">484 10 DCPackType 0 532481 10 DCPackType 10 DCPackType 0 0 0 0 0 0 0 0 0 0 12 10 PT_invalid 10 PT_invalid 59</span>
<span class="s0">// This one should never be returned in a normal situation.</span>
<span class="s0">0 9 PT_double 9 PT_double 259</span>
<span class="s0">// These PackTypes are all fundamental types, and should be packed (or</span>
<span class="s0">// unpacked) with the corresponding call to pack_double(), pack_int(), etc.</span>
<span class="s0">// PT_blob is similar to PT_string, except that it contains arbitrary binary</span>
<span class="s0">// data instead of just UTF-8 text.</span>
<span class="s0">1 6 PT_int 6 PT_int 0</span>
<span class="s0">2 7 PT_uint 7 PT_uint 0</span>
<span class="s0">3 8 PT_int64 8 PT_int64 0</span>
<span class="s0">4 9 PT_uint64 9 PT_uint64 0</span>
<span class="s0">5 9 PT_string 9 PT_string 0</span>
<span class="s0">6 7 PT_blob 7 PT_blob 0</span>
<span class="s0">7 8 PT_array 8 PT_array 192</span>
<span class="s0">// The remaining PackTypes imply a need to call push() and pop(). They are</span>
<span class="s0">// all variants on the same thing: a list of nested fields, but the PackType</span>
<span class="s0">// provides a bit of a semantic context.</span>
<span class="s0">8 8 PT_field 8 PT_field 0</span>
<span class="s0">9 8 PT_class 8 PT_class 0</span>
<span class="s0">10 9 PT_switch 9 PT_switch 0</span>
<span class="s0">11 0 137</span>
<span class="s0">// This enumerated type is returned by get_pack_type() and represents the best</span>
<span class="s0">// choice for a subsequent call to pack_*() or unpack_*().</span>

<span class="s0">485 17 DCPackerInterface 0 26625 17 DCPackerInterface 17 DCPackerInterface 0 0 0 0 247 0 6 248 249 250 251 252 253 0 0 0 0 0 257</span>
<span class="s0">/**</span>
 <span class="s0">* This defines the internal interface for packing values into a DCField.  The</span>
 <span class="s0">* various different DC objects inherit from this.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally these methods are called only by the DCPacker object; the user</span>
 <span class="s0">* wouldn't normally call these directly.</span>
 <span class="s0">*/</span>

<span class="s0">486 13 DCKeywordList 0 26625 13 DCKeywordList 13 DCKeywordList 0 0 0 0 254 0 5 255 256 257 258 259 0 0 0 0 0 95</span>
<span class="s0">/**</span>
 <span class="s0">* This is a list of keywords (see DCKeyword) that may be set on a particular</span>
 <span class="s0">* field.</span>
 <span class="s0">*/</span>

<span class="s0">487 7 DCField 0 26625 7 DCField 7 DCField 0 0 0 0 264 0 29 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 0 0 2 3 485 260 261 3 486 262 263 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* A single field of a Distributed Class, either atomic or molecular.</span>
 <span class="s0">*/</span>

<span class="s0">488 10 DCPackData 0 26625 10 DCPackData 10 DCPackData 0 0 0 1 294 295 0 3 296 297 298 0 0 0 0 0 73</span>
<span class="s0">/**</span>
 <span class="s0">* This is a block of data that receives the results of DCPacker.</span>
 <span class="s0">*/</span>

<span class="s0">489 8 DCPacker 0 26625 8 DCPacker 8 DCPacker 0 0 0 1 299 300 0 75 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 0 0 0 0 0 253</span>
<span class="s0">/**</span>
 <span class="s0">* This class can be used for packing a series of numeric and string data into</span>
 <span class="s0">* a binary stream, according to the DC specification.</span>
 <span class="s0">*</span>
 <span class="s0">* See also direct/src/doc/dcPacker.txt for a more complete description and</span>
 <span class="s0">* examples of using this class.</span>
 <span class="s0">*/</span>

<span class="s0">490 11 DCParameter 0 75777 11 DCParameter 11 DCParameter 0 0 0 0 264 0 5 376 377 378 379 380 0 0 1 0 487 0 0 0 0 314</span>
<span class="s0">/**</span>
 <span class="s0">* Represents the type specification for a single parameter within a field</span>
 <span class="s0">* specification.  This may be a simple type, or it may be a class or an array</span>
 <span class="s0">* reference.</span>
 <span class="s0">*</span>
 <span class="s0">* This may also be a typedef reference to another type, which has the same</span>
 <span class="s0">* properties as the referenced type, but a different name.</span>
 <span class="s0">*/</span>

<span class="s0">491 16 DCArrayParameter 0 75777 16 DCArrayParameter 16 DCArrayParameter 0 0 0 0 264 0 2 381 382 0 0 1 0 490 0 0 0 0 200</span>
<span class="s0">/**</span>
 <span class="s0">* This represents an array of some other kind of object, meaning this</span>
 <span class="s0">* parameter type accepts an arbitrary (or possibly fixed) number of nested</span>
 <span class="s0">* fields, all of which are of the same type.</span>
 <span class="s0">*/</span>

<span class="s0">492 13 DCAtomicField 0 75777 13 DCAtomicField 13 DCAtomicField 0 0 0 0 264 0 7 383 384 385 386 387 388 389 0 0 1 0 487 0 0 0 0 195</span>
<span class="s0">/**</span>
 <span class="s0">* A single atomic field of a Distributed Class, as read from a .dc file.</span>
 <span class="s0">* This defines an interface to the Distributed Class, and is always</span>
 <span class="s0">* implemented as a remote procedure method.</span>
 <span class="s0">*/</span>

<span class="s0">493 13 DCDeclaration 0 26625 13 DCDeclaration 13 DCDeclaration 0 0 0 0 390 0 4 391 392 393 394 0 0 0 0 0 369</span>
<span class="s0">/**</span>
 <span class="s0">* This is a common interface for a declaration in a DC file.  Currently, this</span>
 <span class="s0">* is either a class or a typedef declaration (import declarations are still</span>
 <span class="s0">* collected together at the top, and don't inherit from this object).  Its</span>
 <span class="s0">* only purpose is so that classes and typedefs can be stored in one list</span>
 <span class="s0">* together so they can be ordered correctly on output.</span>
 <span class="s0">*/</span>

<span class="s0">494 7 DCClass 0 75777 7 DCClass 7 DCClass 0 0 0 0 390 0 37 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 0 0 1 0 493 0 0 0 0 80</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a particular DistributedClass as read from an input .dc file.</span>
 <span class="s0">*/</span>

<span class="s0">495 16 DCClassParameter 0 141313 16 DCClassParameter 16 DCClassParameter 0 0 0 0 433 0 1 432 0 0 1 0 490 0 0 0 0 157</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a class (or struct) object used as a parameter itself.</span>
 <span class="s0">* This means that all the fields of the class get packed into the message.</span>
 <span class="s0">*/</span>

<span class="s0">496 6 DCFile 0 26625 6 DCFile 6 DCFile 0 0 0 1 434 435 0 21 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 0 0 0 0 0 101</span>
<span class="s0">/**</span>
 <span class="s0">* Represents the complete list of Distributed Class descriptions as read from</span>
 <span class="s0">* a .dc file.</span>
 <span class="s0">*/</span>

<span class="s0">497 9 DCKeyword 0 75777 9 DCKeyword 9 DCKeyword 0 0 0 0 390 0 1 457 0 0 1 0 493 0 0 0 0 187</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a single keyword declaration in the dc file.  It is used to</span>
 <span class="s0">* define a communication property associated with a field, for instance</span>
 <span class="s0">* &quot;broadcast&quot; or &quot;airecv&quot;.</span>
 <span class="s0">*/</span>

<span class="s0">498 16 DCMolecularField 0 141313 16 DCMolecularField 16 DCMolecularField 0 0 0 0 460 0 2 458 459 0 0 1 0 487 0 0 0 0 196</span>
<span class="s0">/**</span>
 <span class="s0">* A single molecular field of a Distributed Class, as read from a .dc file.</span>
 <span class="s0">* This represents a combination of two or more related atomic fields, that</span>
 <span class="s0">* will often be treated as a unit.</span>
 <span class="s0">*/</span>

<span class="s0">499 17 DCSimpleParameter 0 141313 17 DCSimpleParameter 17 DCSimpleParameter 0 0 0 0 465 0 4 461 462 463 464 0 0 1 0 490 0 0 0 0 282</span>
<span class="s0">/**</span>
 <span class="s0">* This is the most fundamental kind of parameter type: a single number or</span>
 <span class="s0">* string, one of the DCSubatomicType elements.  It may also optionally have a</span>
 <span class="s0">* divisor, which is meaningful only for the numeric type elements (and</span>
 <span class="s0">* represents a fixed-point numeric convention).</span>
 <span class="s0">*/</span>

<span class="s0">500 8 DCSwitch 0 75777 8 DCSwitch 8 DCSwitch 0 0 0 0 390 0 10 466 467 468 469 470 471 472 473 474 475 0 0 1 0 493 0 0 0 0 177</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a switch statement, which can appear inside a class body</span>
 <span class="s0">* and represents two or more alternative unpacking schemes based on the first</span>
 <span class="s0">* field read.</span>
 <span class="s0">*/</span>

<span class="s0">501 17 DCSwitchParameter 0 141313 17 DCSwitchParameter 17 DCSwitchParameter 0 0 0 0 477 0 1 476 0 0 1 0 490 0 0 0 0 140</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a switch object used as a parameter itself, which packs the</span>
 <span class="s0">* appropriate fields of the switch into the message.</span>
 <span class="s0">*/</span>

<span class="s0">502 9 DCTypedef 0 75777 9 DCTypedef 9 DCTypedef 0 0 0 0 390 0 5 478 479 480 481 482 0 0 1 0 493 0 0 0 0 142</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a single typedef declaration in the dc file.  It assigns a</span>
 <span class="s0">* particular type to a new name, just like a C typedef.</span>
 <span class="s0">*/</span>

<span class="s0">503 25 DCPackerInterface const * 0 8576 25 DCPackerInterface const * 25 DCPackerInterface const * 0 0 504 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">504 23 DCPackerInterface const 0 8832 23 DCPackerInterface const 23 DCPackerInterface const 0 0 485 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">505 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">506 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">507 19 DCPackerInterface * 0 8576 19 DCPackerInterface * 19 DCPackerInterface * 0 0 485 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">508 9 DCField * 0 8576 9 DCField * 9 DCField * 0 0 487 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">509 15 DCField const * 0 8576 15 DCField const * 15 DCField const * 0 0 510 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">510 13 DCField const 0 8832 13 DCField const 13 DCField const 0 0 487 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">511 19 DCSwitchParameter * 0 8576 19 DCSwitchParameter * 19 DCSwitchParameter * 0 0 501 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">512 25 DCSwitchParameter const * 0 8576 25 DCSwitchParameter const * 25 DCSwitchParameter const * 0 0 513 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">513 23 DCSwitchParameter const 0 8832 23 DCSwitchParameter const 23 DCSwitchParameter const 0 0 501 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">514 18 DCClassParameter * 0 8576 18 DCClassParameter * 18 DCClassParameter * 0 0 495 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">515 24 DCClassParameter const * 0 8576 24 DCClassParameter const * 24 DCClassParameter const * 0 0 516 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">516 22 DCClassParameter const 0 8832 22 DCClassParameter const 22 DCClassParameter const 0 0 495 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">517 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">518 8 DCFile * 0 8576 8 DCFile * 8 DCFile * 0 0 496 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">519 21 DCKeywordList const * 0 8576 21 DCKeywordList const * 21 DCKeywordList const * 0 0 520 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">520 19 DCKeywordList const 0 8832 19 DCKeywordList const 19 DCKeywordList const 0 0 486 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">521 17 DCKeyword const * 0 8576 17 DCKeyword const * 17 DCKeyword const * 0 0 522 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">522 15 DCKeyword const 0 8832 15 DCKeyword const 15 DCKeyword const 0 0 497 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">523 9 DCClass * 0 8576 9 DCClass * 9 DCClass * 0 0 494 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">524 15 DCAtomicField * 0 8576 15 DCAtomicField * 15 DCAtomicField * 0 0 492 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">525 21 DCAtomicField const * 0 8576 21 DCAtomicField const * 21 DCAtomicField const * 0 0 526 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">526 19 DCAtomicField const 0 8832 19 DCAtomicField const 19 DCAtomicField const 0 0 492 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">527 18 DCMolecularField * 0 8576 18 DCMolecularField * 18 DCMolecularField * 0 0 498 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">528 24 DCMolecularField const * 0 8576 24 DCMolecularField const * 24 DCMolecularField const * 0 0 529 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">529 22 DCMolecularField const 0 8832 22 DCMolecularField const 22 DCMolecularField const 0 0 498 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">530 13 DCParameter * 0 8576 13 DCParameter * 13 DCParameter * 0 0 490 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">531 19 DCParameter const * 0 8576 19 DCParameter const * 19 DCParameter const * 0 0 532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">532 17 DCParameter const 0 8832 17 DCParameter const 17 DCParameter const 0 0 490 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">533 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 534 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">534 24 pvector&lt; unsigned char &gt; 0 2048 24 pvector&lt; unsigned char &gt; 24 pvector&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">535 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">536 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">537 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">538 10 DCPacker * 0 8576 10 DCPacker * 10 DCPacker * 0 0 489 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">539 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 540 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">540 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 541 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">541 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">542 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">543 9 DOID_TYPE 0 2105344 9 DOID_TYPE 9 DOID_TYPE 0 0 544 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">544 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 545 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">545 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">546 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 542 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">547 12 CHANNEL_TYPE 0 2105344 12 CHANNEL_TYPE 12 CHANNEL_TYPE 0 0 548 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">548 8 uint64_t 0 2105344 8 uint64_t 8 uint64_t 0 0 549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">549 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">550 15 DCKeywordList * 0 8576 15 DCKeywordList * 15 DCKeywordList * 0 0 486 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">551 12 DCPackData * 0 8576 12 DCPackData * 12 DCPackData * 0 0 488 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">552 18 DCPackData const * 0 8576 18 DCPackData const * 18 DCPackData const * 0 0 553 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">553 16 DCPackData const 0 8832 16 DCPackData const 16 DCPackData const 0 0 488 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">554 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">555 16 DCPacker const * 0 8576 16 DCPacker const * 16 DCPacker const * 0 0 556 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">556 14 DCPacker const 0 8832 14 DCPacker const 14 DCPacker const 0 0 489 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">557 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">558 7 int64_t 0 2105344 7 int64_t 7 int64_t 0 0 559 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">559 13 long long int 0 8226 13 long long int 13 long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">560 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 561 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">561 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">562 19 DCSimpleParameter * 0 8576 19 DCSimpleParameter * 19 DCSimpleParameter * 0 0 499 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">563 25 DCSimpleParameter const * 0 8576 25 DCSimpleParameter const * 25 DCSimpleParameter const * 0 0 564 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">564 23 DCSimpleParameter const 0 8832 23 DCSimpleParameter const 23 DCSimpleParameter const 0 0 499 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">565 18 DCArrayParameter * 0 8576 18 DCArrayParameter * 18 DCArrayParameter * 0 0 491 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">566 24 DCArrayParameter const * 0 8576 24 DCArrayParameter const * 24 DCArrayParameter const * 0 0 567 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">567 22 DCArrayParameter const 0 8832 22 DCArrayParameter const 22 DCArrayParameter const 0 0 491 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">568 17 DCTypedef const * 0 8576 17 DCTypedef const * 17 DCTypedef const * 0 0 569 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">569 15 DCTypedef const 0 8832 15 DCTypedef const 15 DCTypedef const 0 0 502 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">570 15 DCDeclaration * 0 8576 15 DCDeclaration * 15 DCDeclaration * 0 0 493 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">571 21 DCDeclaration const * 0 8576 21 DCDeclaration const * 21 DCDeclaration const * 0 0 572 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">572 19 DCDeclaration const 0 8832 19 DCDeclaration const 19 DCDeclaration const 0 0 493 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">573 15 DCClass const * 0 8576 15 DCClass const * 15 DCClass const * 0 0 574 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">574 13 DCClass const 0 8832 13 DCClass const 13 DCClass const 0 0 494 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">575 10 DCSwitch * 0 8576 10 DCSwitch * 10 DCSwitch * 0 0 500 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">576 16 DCSwitch const * 0 8576 16 DCSwitch const * 16 DCSwitch const * 0 0 577 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">577 14 DCSwitch const 0 8832 14 DCSwitch const 14 DCSwitch const 0 0 500 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">578 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 579 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">579 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 365</span>
<span class="s0">/**</span>
 <span class="s0">* A class to retrieve the individual data elements previously stored in a</span>
 <span class="s0">* Datagram.  Elements may be retrieved one at a time; it is up to the caller</span>
 <span class="s0">* to know the correct type and order of each element.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that it is the responsibility of the caller to ensure that the datagram</span>
 <span class="s0">* object is not destructed while this DatagramIterator is in use.</span>
 <span class="s0">*/</span>

<span class="s0">580 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 581 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">581 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 542 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">582 11 ZONEID_TYPE 0 2105344 11 ZONEID_TYPE 11 ZONEID_TYPE 0 0 544 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">583 14 DCFile const * 0 8576 14 DCFile const * 14 DCFile const * 0 0 584 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">584 12 DCFile const 0 8832 12 DCFile const 12 DCFile const 0 0 496 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">585 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 586 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">586 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">587 11 DCTypedef * 0 8576 11 DCTypedef * 11 DCTypedef * 0 0 502 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">588 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">0</span>
<span class="s0">0</span>
</pre>
</body>
</html>