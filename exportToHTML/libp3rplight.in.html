<html>
<head>
<title>libp3rplight.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3rplight.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">12 libp3rplight 4 _K37 16 panda3d._rplight </span>
<span class="s0">106</span>
<span class="s0">112 10 GPUCommand 0 260 218 22 GPUCommand::GPUCommand 0 2 1 2 346</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new GPUCommand with the given command type.</span>
 <span class="s0">* @details This will construct a new GPUCommand of the given command type.</span>
 <span class="s0">*   The command type should be of GPUCommand::CommandType, and determines</span>
 <span class="s0">*   what data the GPUCommand contains, and how it will be handled.</span>
 <span class="s0">*</span>
 <span class="s0">* @param command_type The type of the GPUCommand</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">GPUCommand::GPUCommand(GPUCommand::CommandType command_type);</span>
<span class="s0">inline GPUCommand::GPUCommand(GPUCommand const &amp;) = default;</span>

<span class="s0">113 8 push_int 0 4 218 20 GPUCommand::push_int 0 1 3 308</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Appends an integer to the GPUCommand.</span>
 <span class="s0">* @details This adds an integer to the back of the GPUCommand. Depending on the</span>
 <span class="s0">*   setting in convert_int_to_float, this will either just convert the int to a</span>
 <span class="s0">*   float by casting it, or just do a bitwise copy.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v The integer to append.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline void GPUCommand::push_int(int v);</span>

<span class="s0">114 10 push_float 0 4 218 22 GPUCommand::push_float 0 1 4 415</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Appends a float to the GPUCommand.</span>
 <span class="s0">* @details This adds an integer to the back of the GPUCommand. Its used by all</span>
 <span class="s0">*   other push_xxx methods, and simply stores the value, then increments the write</span>
 <span class="s0">*   pointer. When the amount of floats exceeds the capacity of the GPUCommand,</span>
 <span class="s0">*   an error will be printed, and the method returns without doing anything else.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v The float to append.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void GPUCommand::push_float(float v);</span>

<span class="s0">115 9 push_vec3 0 4 218 21 GPUCommand::push_vec3 0 2 5 6 668</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Appends a 3-component floating point vector to the GPUCommand.</span>
 <span class="s0">* @details This appends a 3-component floating point vector to the command.</span>
 <span class="s0">*   It basically just calls push_float() for every component, in the order</span>
 <span class="s0">*   x, y, z, which causes the vector to occupy the space of 3 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Int-Vector to append.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* @brief Appends a 3-component integer vector to the GPUCommand.</span>
 <span class="s0">* @details This appends a 3-component integer vector to the command.</span>
 <span class="s0">*   It basically just calls push_int() for every component, in the order</span>
 <span class="s0">*   x, y, z, which causes the vector to occupy the space of 3 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Int-Vector to append.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">inline void GPUCommand::push_vec3(LVecBase3 const &amp;v);</span>
<span class="s0">inline void GPUCommand::push_vec3(LVecBase3i const &amp;v);</span>

<span class="s0">116 9 push_vec4 0 4 218 21 GPUCommand::push_vec4 0 2 7 8 671</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Appends a 4-component floating point vector to the GPUCommand.</span>
 <span class="s0">* @details This appends a 4-component floating point vector to the command.</span>
 <span class="s0">*   It basically just calls push_float() for every component, in the order</span>
 <span class="s0">*   x, y, z, which causes the vector to occupy the space of 3 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Int-Vector to append.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* @brief Appends a 4-component integer vector to the GPUCommand.</span>
 <span class="s0">* @details This appends a 4-component integer vector to the command.</span>
 <span class="s0">*   It basically just calls push_int() for every component, in the order</span>
 <span class="s0">*   x, y, z, w, which causes the vector to occupy the space of 4 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Int-Vector to append.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">inline void GPUCommand::push_vec4(LVecBase4 const &amp;v);</span>
<span class="s0">inline void GPUCommand::push_vec4(LVecBase4i const &amp;v);</span>

<span class="s0">117 9 push_mat3 0 4 218 21 GPUCommand::push_mat3 0 1 9 276</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Appends a floating point 3x3 matrix to the GPUCommand.</span>
 <span class="s0">* @details This appends a floating point 3x3 matrix to the GPUCommand, by</span>
 <span class="s0">*   pushing all components in row-order to the command. This occupies a space of</span>
 <span class="s0">*   9 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Matrix to append</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void GPUCommand::push_mat3(LMatrix3 const &amp;v);</span>

<span class="s0">118 9 push_mat4 0 4 218 21 GPUCommand::push_mat4 0 1 10 277</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Appends a floating point 4x4 matrix to the GPUCommand.</span>
 <span class="s0">* @details This appends a floating point 4x4 matrix to the GPUCommand, by</span>
 <span class="s0">*   pushing all components in row-order to the command. This occupies a space of</span>
 <span class="s0">*   16 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Matrix to append</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void GPUCommand::push_mat4(LMatrix4 const &amp;v);</span>

<span class="s0">119 24 get_uses_integer_packing 0 4 218 36 GPUCommand::get_uses_integer_packing 0 1 11 434</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns whether integers are packed as floats.</span>
 <span class="s0">* @details This returns how integer are packed into the data stream. If the</span>
 <span class="s0">*   returned value is true, then integers are packed using their binary</span>
 <span class="s0">*   representation converted to floating point format. If the returned value</span>
 <span class="s0">*   is false, then integers are packed by simply casting them to float,</span>
 <span class="s0">*   e.g. val = (float)i;</span>
 <span class="s0">* @return The integer representation flag</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline bool GPUCommand::get_uses_integer_packing(void);</span>

<span class="s0">120 8 write_to 0 4 218 20 GPUCommand::write_to 0 1 12 694</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Writes the GPU command to a given target.</span>
 <span class="s0">* @details This method writes all the data of the GPU command to a given target.</span>
 <span class="s0">*   The target should be a pointer to memory being big enough to hold the</span>
 <span class="s0">*   data. Presumably #dest will be a handle to texture memory.</span>
 <span class="s0">*   The command_index controls the offset where the data will be written</span>
 <span class="s0">*   to.</span>
 <span class="s0">*</span>
 <span class="s0">* @param dest Handle to the memory to write the command to</span>
 <span class="s0">* @param command_index Offset to write the command to. The command will write</span>
 <span class="s0">*   its data to command_index * GPU_COMMAND_ENTRIES. When writing</span>
 <span class="s0">*   the GPUCommand in a GPUCommandList, the command_index will</span>
 <span class="s0">*   most likely be the index of the command in the list.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void GPUCommand::write_to(PTA_uchar const &amp;dest, std::size_t command_index);</span>

<span class="s0">121 5 write 0 4 218 17 GPUCommand::write 0 1 13 373</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Prints out the GPUCommand to the console</span>
 <span class="s0">* @details This method prints the type, size, and data of the GPUCommand to the</span>
 <span class="s0">*   console. This helps for debugging the contents of the GPUCommand. Keep</span>
 <span class="s0">*   in mind that integers might be shown in their binary float representation,</span>
 <span class="s0">*   depending on the setting in the GPUCommand::convert_int_to_float method.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void GPUCommand::write(std::ostream &amp;out) const;</span>

<span class="s0">122 11 ~GPUCommand 0 516 218 23 GPUCommand::~GPUCommand 0 0 0</span>
<span class="s0">30</span>
<span class="s0">GPUCommand::~GPUCommand(void);</span>

<span class="s0">123 14 GPUCommandList 0 260 220 30 GPUCommandList::GPUCommandList 0 2 14 15 151</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new GPUCommandList</span>
 <span class="s0">* @details This constructs a new GPUCommandList. By default, there are no commands</span>
 <span class="s0">*   in the list.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">GPUCommandList::GPUCommandList(void);</span>
<span class="s0">inline GPUCommandList::GPUCommandList(GPUCommandList const &amp;) = default;</span>

<span class="s0">124 11 add_command 0 4 220 27 GPUCommandList::add_command 0 1 16 174</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Pushes a GPUCommand to the command list.</span>
 <span class="s0">* @details This adds a new GPUCommand to the list of commands to be processed.</span>
 <span class="s0">*</span>
 <span class="s0">* @param cmd The command to add</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void GPUCommandList::add_command(GPUCommand const &amp;cmd);</span>

<span class="s0">125 16 get_num_commands 0 4 220 32 GPUCommandList::get_num_commands 0 1 17 220</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the number of commands in this list.</span>
 <span class="s0">* @details This returns the amount of commands which are currently stored in this</span>
 <span class="s0">*   list, and are waiting to get processed.</span>
 <span class="s0">* @return Amount of commands</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">std::size_t GPUCommandList::get_num_commands(void);</span>

<span class="s0">126 17 write_commands_to 0 4 220 33 GPUCommandList::write_commands_to 0 1 18 586</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Writes the first n-commands to a destination.</span>
 <span class="s0">* @details This takes the first #limit commands, and writes them to the</span>
 <span class="s0">*   destination using GPUCommand::write_to. See GPUCommand::write_to for</span>
 <span class="s0">*   further information about #dest. The limit controls after how much</span>
 <span class="s0">*   commands the processing will be stopped. All commands which got processed</span>
 <span class="s0">*   will get removed from the list.</span>
 <span class="s0">*</span>
 <span class="s0">* @param dest Destination to write to, see GPUCommand::write_to</span>
 <span class="s0">* @param limit Maximum amount of commands to process</span>
 <span class="s0">*</span>
 <span class="s0">* @return Amount of commands processed, between 0 and #limit.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">std::size_t GPUCommandList::write_commands_to(PTA_uchar const &amp;dest, std::size_t limit = 32);</span>

<span class="s0">127 15 ~GPUCommandList 0 516 220 31 GPUCommandList::~GPUCommandList 0 0 0</span>
<span class="s0">38</span>
<span class="s0">GPUCommandList::~GPUCommandList(void);</span>

<span class="s0">128 10 IESDataset 0 260 223 22 IESDataset::IESDataset 0 2 19 20 112</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new empty dataset.</span>
 <span class="s0">* @details This constructs a new IESDataset with no data set.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">IESDataset::IESDataset(void);</span>
<span class="s0">inline IESDataset::IESDataset(IESDataset const &amp;) = default;</span>

<span class="s0">129 19 set_vertical_angles 0 4 223 31 IESDataset::set_vertical_angles 0 1 21 184</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the vertical angles of the dataset.</span>
 <span class="s0">* @details This sets the list of vertical angles of the dataset.</span>
 <span class="s0">*</span>
 <span class="s0">* @param vertical_angles Vector of all vertical angles.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">void IESDataset::set_vertical_angles(PTA_float const &amp;vertical_angles);</span>

<span class="s0">130 21 set_horizontal_angles 0 4 223 33 IESDataset::set_horizontal_angles 0 1 22 192</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the horizontal angles of the dataset.</span>
 <span class="s0">* @details This sets the list of horizontal angles of the dataset.</span>
 <span class="s0">*</span>
 <span class="s0">* @param horizontal_angles Vector of all horizontal angles.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void IESDataset::set_horizontal_angles(PTA_float const &amp;horizontal_angles);</span>

<span class="s0">131 18 set_candela_values 0 4 223 30 IESDataset::set_candela_values 0 1 23 336</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the candela values.</span>
 <span class="s0">* @details This sets the candela values of the dataset. They should be an</span>
 <span class="s0">*   interleaved 2D array with the dimensions vertical_angles x horizontal_angles.</span>
 <span class="s0">*   They also should be normalized by dividing by the maximum entry.</span>
 <span class="s0">* @param candela_values Interleaved 2D-vector of candela values.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void IESDataset::set_candela_values(PTA_float const &amp;candela_values);</span>

<span class="s0">132 29 generate_dataset_texture_into 0 4 223 41 IESDataset::generate_dataset_texture_into 0 1 24 362</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Generates the IES LUT</span>
 <span class="s0">* @details This generates the LUT into a given dataset texture. The x-axis</span>
 <span class="s0">*   referes to the vertical_angle, whereas the y-axis refers to the</span>
 <span class="s0">*   horizontal angle.</span>
 <span class="s0">*</span>
 <span class="s0">* @param dest_tex Texture to write the LUT into</span>
 <span class="s0">* @param z Layer to write the LUT into, in case the texture is a 3D Texture or</span>
 <span class="s0">*   2D Texture Array.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">void IESDataset::generate_dataset_texture_into(Texture *dest_tex, std::size_t z) const;</span>

<span class="s0">133 11 ~IESDataset 0 516 223 23 IESDataset::~IESDataset 0 0 0</span>
<span class="s0">30</span>
<span class="s0">IESDataset::~IESDataset(void);</span>

<span class="s0">134 18 invalidate_shadows 0 4 224 27 RPLight::invalidate_shadows 0 1 25 488</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Invalidates the shadows</span>
 <span class="s0">* @details This invalidates all shadows of the light, causing them to get</span>
 <span class="s0">*   regenerated. This might be the case  when the lights position or similar</span>
 <span class="s0">*   changed. This will cause all shadow sources to be updated, emitting a</span>
 <span class="s0">*   shadow update. Be careful when calling this method if you don't want all</span>
 <span class="s0">*   sources to get updated. If you only have to invalidate a single shadow source,</span>
 <span class="s0">*   use `get_shadow_source(n)-&gt;set_needs_update(true)`.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void RPLight::invalidate_shadows(void);</span>

<span class="s0">135 7 set_pos 0 4 224 16 RPLight::set_pos 0 2 26 27 467</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the position of the light</span>
 <span class="s0">* @details This sets the position of the light in world space. It will cause</span>
 <span class="s0">*   the light to get invalidated, and resubmitted to the GPU.</span>
 <span class="s0">*</span>
 <span class="s0">* @param pos Position in world space</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* @brief Sets the position of the light</span>
 <span class="s0">* @details @copydetails RPLight::set_pos(const LVecBase3 &amp;pos)</span>
 <span class="s0">*</span>
 <span class="s0">* @param x X-component of the position</span>
 <span class="s0">* @param y Y-component of the position</span>
 <span class="s0">* @param z Z-component of the position</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">inline void RPLight::set_pos(LVecBase3 const &amp;pos);</span>
<span class="s0">inline void RPLight::set_pos(float x, float y, float z);</span>

<span class="s0">136 7 get_pos 0 4 224 16 RPLight::get_pos 0 1 28 214</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the position of the light</span>
 <span class="s0">* @details This returns the position of the light previously set with</span>
 <span class="s0">*   RPLight::set_pos(). The returned position is in world space.</span>
 <span class="s0">* @return Light-position</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LVecBase3 const &amp;RPLight::get_pos(void) const;</span>

<span class="s0">137 9 set_color 0 4 224 18 RPLight::set_color 0 2 29 30 693</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the lights color</span>
 <span class="s0">* @details This sets the lights color. The color should not include the brightness</span>
 <span class="s0">*   of the light, you should control that with the energy. The color specifies</span>
 <span class="s0">*   the lights &quot;tint&quot; and will get multiplied with its specular and diffuse</span>
 <span class="s0">*   contribution.</span>
 <span class="s0">*</span>
 <span class="s0">*   The color will be normalized by dividing by the colors luminance. Setting</span>
 <span class="s0">*   higher values than 1.0 will have no effect.</span>
 <span class="s0">*</span>
 <span class="s0">* @param color Light color</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* @brief Sets the lights color</span>
 <span class="s0">* @details @copydetails RPLight::set_color(const LVecBase3 &amp;color)</span>
 <span class="s0">*</span>
 <span class="s0">* @param r Red-component of the color</span>
 <span class="s0">* @param g Green-component of the color</span>
 <span class="s0">* @param b Blue-component of the color</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline void RPLight::set_color(LVecBase3 const &amp;color);</span>
<span class="s0">inline void RPLight::set_color(float r, float g, float b);</span>

<span class="s0">138 9 get_color 0 4 224 18 RPLight::get_color 0 1 31 324</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the lights color</span>
 <span class="s0">* @details This returns the light color, previously set with RPLight::set_color.</span>
 <span class="s0">*   This does not include the energy of the light. It might differ from what</span>
 <span class="s0">*   was set with set_color, because the color is normalized by dividing it</span>
 <span class="s0">*   by its luminance.</span>
 <span class="s0">* @return Light-color</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LVecBase3 const &amp;RPLight::get_color(void) const;</span>

<span class="s0">139 26 set_color_from_temperature 0 4 224 35 RPLight::set_color_from_temperature 0 1 32 304</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the lights color from a given color temperature</span>
 <span class="s0">* @details This sets the lights color, given a temperature. This is more</span>
 <span class="s0">*   physically based than setting a user defined color. The color will be</span>
 <span class="s0">*   computed from the given temperature.</span>
 <span class="s0">*</span>
 <span class="s0">* @param temperature Light temperature</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void RPLight::set_color_from_temperature(float temperature);</span>

<span class="s0">140 10 set_energy 0 4 224 19 RPLight::set_energy 0 1 33 238</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the energy of the light</span>
 <span class="s0">* @details This sets the energy of the light, which can be seen as the brightness</span>
 <span class="s0">*   of the light. It will get multiplied with the normalized color.</span>
 <span class="s0">*</span>
 <span class="s0">* @param energy energy of the light</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void RPLight::set_energy(float energy);</span>

<span class="s0">141 10 get_energy 0 4 224 19 RPLight::get_energy 0 1 34 179</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the energy of the light</span>
 <span class="s0">* @details This returns the energy of the light, previously set with</span>
 <span class="s0">*   RPLight::set_energy.</span>
 <span class="s0">*</span>
 <span class="s0">* @return energy of the light</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline float RPLight::get_energy(void) const;</span>

<span class="s0">142 14 get_light_type 0 4 224 23 RPLight::get_light_type 0 1 35 243</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the type of the light</span>
 <span class="s0">* @details This returns the internal type of the light, which was specified</span>
 <span class="s0">*   in the lights constructor. This can be used to distinguish between light</span>
 <span class="s0">*   types.</span>
 <span class="s0">* @return Type of the light</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline RPLight::LightType RPLight::get_light_type(void) const;</span>

<span class="s0">143 17 set_casts_shadows 0 4 224 26 RPLight::set_casts_shadows 0 1 36 426</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Controls whether the light casts shadows</span>
 <span class="s0">* @details This sets whether the light casts shadows. You can not change this</span>
 <span class="s0">*   while the light is attached. When flag is set to true, the light will be</span>
 <span class="s0">*   setup to cast shadows, spawning shadow sources based on the lights type.</span>
 <span class="s0">*   If the flag is set to false, the light will be inddicated to cast no shadows.</span>
 <span class="s0">*</span>
 <span class="s0">* @param flag Whether the light casts shadows</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void RPLight::set_casts_shadows(bool flag = true);</span>

<span class="s0">144 17 get_casts_shadows 0 4 224 26 RPLight::get_casts_shadows 0 1 37 261</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns whether the light casts shadows</span>
 <span class="s0">* @details This returns whether the light casts shadows, the returned value</span>
 <span class="s0">*   is the one previously set with RPLight::set_casts_shadows.</span>
 <span class="s0">*</span>
 <span class="s0">* @return true if the light casts shadows, false otherwise</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool RPLight::get_casts_shadows(void) const;</span>

<span class="s0">145 25 set_shadow_map_resolution 0 4 224 34 RPLight::set_shadow_map_resolution 0 1 38 580</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the light's shadow map resolution</span>
 <span class="s0">* @details This sets the light's shadow map resolution. This has no effect</span>
 <span class="s0">*   when the light is not told to cast shadows (Use RPLight::set_casts_shadows).</span>
 <span class="s0">*</span>
 <span class="s0">*   When calling this on a light with multiple shadow sources (e.g.</span>
 <span class="s0">*   RPPointLight), this controls the resolution of each source. If the light</span>
 <span class="s0">*   has 6 shadow sources, and you use a resolution of 512x512, the light's</span>
 <span class="s0">*   shadow map will occupy a space of 6 * 512x512 maps in the shadow atlas.</span>
 <span class="s0">*</span>
 <span class="s0">* @param resolution Resolution of the shadow map in pixels</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void RPLight::set_shadow_map_resolution(std::size_t resolution);</span>

<span class="s0">146 25 get_shadow_map_resolution 0 4 224 34 RPLight::get_shadow_map_resolution 0 1 39 343</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the shadow map resolution</span>
 <span class="s0">* @details This returns the shadow map resolution of each source of the light.</span>
 <span class="s0">*   If the light is not setup to cast shadows, this value is meaningless.</span>
 <span class="s0">*   The returned value is the one previously set with RPLight::set_shadow_map_resolution.</span>
 <span class="s0">*</span>
 <span class="s0">* @return Shadow map resolution in pixels</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::size_t RPLight::get_shadow_map_resolution(void) const;</span>

<span class="s0">147 15 set_ies_profile 0 4 224 24 RPLight::set_ies_profile 0 1 40 500</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the IES profile</span>
 <span class="s0">* @details This sets the ies profile of the light. The parameter should be a</span>
 <span class="s0">*   handle previously returned by RenderPipeline.load_ies_profile. Using a</span>
 <span class="s0">*   value of -1 indicates no ies profile.</span>
 <span class="s0">*</span>
 <span class="s0">*   Notice that for IES profiles which cover a whole range, you should use an</span>
 <span class="s0">*   RPPointLight, whereas for ies profiles which only cover the lower</span>
 <span class="s0">*   hemisphere you should use an RPSpotLight for the best performance.</span>
 <span class="s0">*</span>
 <span class="s0">* @param profile IES Profile handle</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void RPLight::set_ies_profile(int profile);</span>

<span class="s0">148 15 get_ies_profile 0 4 224 24 RPLight::get_ies_profile 0 1 41 230</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the light's IES profile</span>
 <span class="s0">* @details This returns the IES profile of a light, previously set with</span>
 <span class="s0">*   RPLight::set_ies_profile. In case no ies profile was set, returns -1.</span>
 <span class="s0">*</span>
 <span class="s0">* @return IES Profile handle</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int RPLight::get_ies_profile(void) const;</span>

<span class="s0">149 15 has_ies_profile 0 4 224 24 RPLight::has_ies_profile 0 1 42 272</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns whether the light has an IES profile assigned</span>
 <span class="s0">* @details This returns whether the light has an IES profile assigned,</span>
 <span class="s0">*   previously done with RPLight::set_ies_profile.</span>
 <span class="s0">*</span>
 <span class="s0">* @return true if the light has an IES profile assigned, false otherwise</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool RPLight::has_ies_profile(void) const;</span>

<span class="s0">150 17 clear_ies_profile 0 4 224 26 RPLight::clear_ies_profile 0 1 43 184</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Clears the IES profile</span>
 <span class="s0">* @details This clears the IES profile of the light, telling it to no longer</span>
 <span class="s0">*   use an IES profile, and instead use the default attenuation.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void RPLight::clear_ies_profile(void);</span>

<span class="s0">151 14 set_near_plane 0 4 224 23 RPLight::set_near_plane 0 1 44 550</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the near plane of the light</span>
 <span class="s0">* @details This sets the near plane of all shadow sources of the light. It has</span>
 <span class="s0">*   no effects if the light does not cast shadows. This prevents artifacts from</span>
 <span class="s0">*   objects near to the light. It behaves like Lens::set_near().</span>
 <span class="s0">*</span>
 <span class="s0">*   It can also help increasing shadow map precision, low near planes will</span>
 <span class="s0">*   cause the precision to suffer. Try setting the near plane as big as possible.</span>
 <span class="s0">*</span>
 <span class="s0">*   If a negative or zero near plane is passed, an assertion is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* @param near_plane Near-plane</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void RPLight::set_near_plane(float near_plane);</span>

<span class="s0">152 14 get_near_plane 0 4 224 23 RPLight::get_near_plane 0 1 45 245</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the near plane of the light</span>
 <span class="s0">* @details This returns the light's near plane, previously set with</span>
 <span class="s0">*   RPLight::set_near_plane. If the light does not cast shadows, this value</span>
 <span class="s0">*   is meaningless.</span>
 <span class="s0">*</span>
 <span class="s0">* @return Near-plane</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline float RPLight::get_near_plane(void) const;</span>

<span class="s0">153 11 ShadowAtlas 0 260 233 24 ShadowAtlas::ShadowAtlas 0 2 46 47 880</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new shadow atlas.</span>
 <span class="s0">* @details This constructs a new shadow atlas with the given size and tile size.</span>
 <span class="s0">*</span>
 <span class="s0">*   The size determines the total size of the atlas in pixels. It should be a</span>
 <span class="s0">*   power-of-two to favour the GPU.</span>
 <span class="s0">*</span>
 <span class="s0">*   The tile_size determines the smallest unit of tiles the atlas can store.</span>
 <span class="s0">*   If, for example, a tile_size of 32 is used, then every entry stored must</span>
 <span class="s0">*   have a resolution of 32 or greater, and the resolution must be a multiple</span>
 <span class="s0">*   of 32. This is to optimize the search in the atlas, so the atlas does not</span>
 <span class="s0">*   have to check every pixel, and instead can just check whole tiles.</span>
 <span class="s0">*</span>
 <span class="s0">*   If you want to disable the use of tiles, set the tile_size to 1, which</span>
 <span class="s0">*   will make the shadow atlas use pixels instead of tiles.</span>
 <span class="s0">*</span>
 <span class="s0">* @param size Atlas-size in pixels</span>
 <span class="s0">* @param tile_size tile-size in pixels, or 1 to use no tiles.</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size = 32);</span>
<span class="s0">inline ShadowAtlas::ShadowAtlas(ShadowAtlas const &amp;) = default;</span>

<span class="s0">154 12 ~ShadowAtlas 0 516 233 25 ShadowAtlas::~ShadowAtlas 0 0 118</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Destructs the shadow atlas.</span>
 <span class="s0">* @details This destructs the shadow atlas, freeing all used resources.</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">ShadowAtlas::~ShadowAtlas(void);</span>

<span class="s0">155 18 get_num_used_tiles 0 4 233 31 ShadowAtlas::get_num_used_tiles 0 1 48 140</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the amount of used tiles</span>
 <span class="s0">* @details Returns the amount of used tiles in the atlas</span>
 <span class="s0">* @return Amount of used tiles</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int ShadowAtlas::get_num_used_tiles(void) const;</span>

<span class="s0">156 12 get_coverage 0 4 233 25 ShadowAtlas::get_coverage 0 1 49 315</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the amount of used tiles in percentage</span>
 <span class="s0">* @details This returns in percentage from 0 to 1 how much space of the atlas</span>
 <span class="s0">*   is used right now. A value of 1 means the atlas is completely full, whereas</span>
 <span class="s0">*   a value of 0 means the atlas is completely free.</span>
 <span class="s0">* @return Atlas usage in percentage</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline float ShadowAtlas::get_coverage(void) const;</span>

<span class="s0">157 15 TagStateManager 0 260 234 32 TagStateManager::TagStateManager 0 2 50 51 351</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new TagStateManager</span>
 <span class="s0">* @details This constructs a new TagStateManager. The #main_cam_node should</span>
 <span class="s0">*   refer to the main scene camera, and will most likely be base.cam.</span>
 <span class="s0">*   It is necessary to pass the camera because the C++ code does not have</span>
 <span class="s0">*   access to the showbase.</span>
 <span class="s0">*</span>
 <span class="s0">* @param main_cam_node The main scene camera</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">TagStateManager::TagStateManager(NodePath main_cam_node);</span>
<span class="s0">inline TagStateManager::TagStateManager(TagStateManager const &amp;) = default;</span>

<span class="s0">158 16 ~TagStateManager 0 516 234 33 TagStateManager::~TagStateManager 0 0 129</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Destructs the TagStateManager</span>
 <span class="s0">* @details This destructs the TagStateManager, and cleans up all resources used.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">TagStateManager::~TagStateManager(void);</span>

<span class="s0">159 11 apply_state 0 4 234 28 TagStateManager::apply_state 0 1 52 1011</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Applies a given state for a pass to a NodePath</span>
 <span class="s0">* @details This applies a shader to the given NodePath which is used when the</span>
 <span class="s0">*   NodePath is rendered by any registered camera for that pass.</span>
 <span class="s0">*   It also disables color write depending on the pass.</span>
 <span class="s0">*</span>
 <span class="s0">* @param np The nodepath to apply the shader to</span>
 <span class="s0">* @param shader A handle to the shader to apply</span>
 <span class="s0">* @param name Name of the state, should be a unique identifier</span>
 <span class="s0">* @param sort Determines the sort with which the shader will be applied.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* @brief Applies a given state to a NodePath</span>
 <span class="s0">* @details This applies a shader to the given NodePath which is used when the</span>
 <span class="s0">*   NodePath is rendered by any registered camera of the container.</span>
 <span class="s0">*</span>
 <span class="s0">* @param container The container which is used to store the state</span>
 <span class="s0">* @param np The nodepath to apply the shader to</span>
 <span class="s0">* @param shader A handle to the shader to apply</span>
 <span class="s0">* @param name Name of the state, should be a unique identifier</span>
 <span class="s0">* @param sort Changes the sort with which the shader will be applied.</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">inline void TagStateManager::apply_state(std::string const &amp;state, NodePath np, Shader *shader, std::string const &amp;name, int sort);</span>

<span class="s0">160 14 cleanup_states 0 4 234 31 TagStateManager::cleanup_states 0 1 53 232</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Cleans up all registered states.</span>
 <span class="s0">* @details This cleans up all states which were registered to the TagStateManager.</span>
 <span class="s0">*   It also calls Camera::clear_tag_states() on the main_cam_node and all attached</span>
 <span class="s0">*   cameras.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void TagStateManager::cleanup_states(void);</span>

<span class="s0">161 15 register_camera 0 4 234 32 TagStateManager::register_camera 0 1 54 769</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Registers a new camera which renders a certain pass</span>
 <span class="s0">* @details This registers a new camera which will be used to render the given</span>
 <span class="s0">*   pass. The TagStateManager will keep track of the camera and</span>
 <span class="s0">*   applies all registered states onto the camera with Camera::set_tag_state.</span>
 <span class="s0">*   It also applies the appropriate camera mask to the camera,</span>
 <span class="s0">*   and sets an initial state to disable color write depending on the pass.</span>
 <span class="s0">*</span>
 <span class="s0">* @param source Camera which will be used to render shadows</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* @brief Registers a new camera to a given container</span>
 <span class="s0">* @details This registers a new camera to a container, and sets its initial</span>
 <span class="s0">*   state as well as the camera mask.</span>
 <span class="s0">*</span>
 <span class="s0">* @param container The container to add the camera to</span>
 <span class="s0">* @param source The camera to add</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void TagStateManager::register_camera(std::string const &amp;state, Camera *source);</span>

<span class="s0">162 17 unregister_camera 0 4 234 34 TagStateManager::unregister_camera 0 1 55 527</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Unregisters a camera from the list of shadow cameras</span>
 <span class="s0">* @details This unregisters a camera from the list of shadows cameras. It also</span>
 <span class="s0">*   resets all tag states of the camera, and also its initial state.</span>
 <span class="s0">*</span>
 <span class="s0">* @param source Camera to unregister</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* @brief Unregisters a camera from a container</span>
 <span class="s0">* @details This unregisters a camera from the list of cameras of a given</span>
 <span class="s0">*   container. It also resets all tag states of the camera, and also its initial</span>
 <span class="s0">*   state.</span>
 <span class="s0">*</span>
 <span class="s0">* @param source Camera to unregister</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline void TagStateManager::unregister_camera(std::string const &amp;state, Camera *source);</span>

<span class="s0">163 8 get_mask 0 4 234 25 TagStateManager::get_mask 0 1 56 280</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the render mask for the given state</span>
 <span class="s0">* @details This returns the mask of a given render pass, which can be used</span>
 <span class="s0">*   to either show or hide objects from this pass.</span>
 <span class="s0">*</span>
 <span class="s0">* @param container_name Name of the render-pass</span>
 <span class="s0">* @return Bit mask of the render pass</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline BitMask32 TagStateManager::get_mask(std::string const &amp;container_name);</span>

<span class="s0">164 13 ShadowManager 0 260 235 28 ShadowManager::ShadowManager 0 2 57 58 348</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new shadow atlas</span>
 <span class="s0">* @details This constructs a new shadow atlas. There are a set of properties</span>
 <span class="s0">*   which should be set before calling ShadowManager::init, see the set-Methods.</span>
 <span class="s0">*   After all properties are set, ShadowManager::init should get called.</span>
 <span class="s0">*   ShadowManager::update should get called on a per frame basis.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">ShadowManager::ShadowManager(void);</span>
<span class="s0">inline ShadowManager::ShadowManager(ShadowManager const &amp;) = default;</span>

<span class="s0">165 15 set_max_updates 0 4 235 30 ShadowManager::set_max_updates 0 1 59 1064</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the maximum amount of updates per frame.</span>
 <span class="s0">* @details This controls the maximum amount of updated ShadowSources per frame.</span>
 <span class="s0">*   The ShadowManager will take the first &lt;max_updates&gt; ShadowSources, and</span>
 <span class="s0">*   generate shadow maps for them every frame. If there are more ShadowSources</span>
 <span class="s0">*   waiting to get updated than available updates, the sources are sorted by</span>
 <span class="s0">*   priority, and the update of the less important sources is delayed to the</span>
 <span class="s0">*   next frame.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the update count is set too low, and there are a lot of ShadowSources</span>
 <span class="s0">*   waiting to get updated, artifacts will occur, and there might be ShadowSources</span>
 <span class="s0">*   which never get updated, due to low priority.</span>
 <span class="s0">*</span>
 <span class="s0">*   If an update count of 0 is passed, no updates will happen. This also means</span>
 <span class="s0">*   that there are no shadows. This is not recommended.</span>
 <span class="s0">*</span>
 <span class="s0">*   If an update count &lt; 0 is passed, undefined behaviour occurs.</span>
 <span class="s0">*</span>
 <span class="s0">*   This method has to get called before ShadowManager::init, otherwise an</span>
 <span class="s0">*   assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param max_updates Maximum amoumt of updates</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void ShadowManager::set_max_updates(std::size_t max_updates);</span>

<span class="s0">166 9 set_scene 0 4 235 24 ShadowManager::set_scene 0 1 60 467</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the target scene</span>
 <span class="s0">* @details This sets the target scene for rendering shadows. All shadow cameras</span>
 <span class="s0">*   will be parented to this scene to render shadows.</span>
 <span class="s0">*</span>
 <span class="s0">*   Usually the scene will be ShowBase.render. If the scene is an empty or</span>
 <span class="s0">*   invalid NodePath, an assertion will be triggered.</span>
 <span class="s0">*</span>
 <span class="s0">*   This method has to get called before calling ShadowManager::init, or an</span>
 <span class="s0">*   assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param scene_parent The target scene</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void ShadowManager::set_scene(NodePath scene_parent);</span>

<span class="s0">167 21 set_tag_state_manager 0 4 235 36 ShadowManager::set_tag_state_manager 0 1 61 328</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the handle to the TagStageManager.</span>
 <span class="s0">* @details This sets the handle to the TagStateManager used by the pipeline.</span>
 <span class="s0">*   Usually this is RenderPipeline.get_tag_mgr().</span>
 <span class="s0">*</span>
 <span class="s0">*   This has to get called before ShadowManager::init, otherwise an assertion</span>
 <span class="s0">*   will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param tag_mgr [description]</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void ShadowManager::set_tag_state_manager(TagStateManager *tag_mgr);</span>

<span class="s0">168 25 set_atlas_graphics_output 0 4 235 40 ShadowManager::set_atlas_graphics_output 0 1 62 525</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the handle to the Shadow targets output</span>
 <span class="s0">* @details This sets the handle to the GraphicsOutput of the shadow atlas.</span>
 <span class="s0">*   Usually this is RenderTarget.get_internal_buffer(), whereas the RenderTarget</span>
 <span class="s0">*   is the target of the ShadowStage.</span>
 <span class="s0">*</span>
 <span class="s0">*   This is used for creating display regions and attaching cameras to them,</span>
 <span class="s0">*   for performing shadow updates.</span>
 <span class="s0">*</span>
 <span class="s0">*   This has to get called before ShadowManager::init, otherwise an assertion</span>
 <span class="s0">*   will be triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param graphics_output [description]</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void ShadowManager::set_atlas_graphics_output(GraphicsOutput *graphics_output);</span>

<span class="s0">169 14 set_atlas_size 0 4 235 29 ShadowManager::set_atlas_size 0 1 63 477</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the shadow atlas size</span>
 <span class="s0">* @details This sets the desired shadow atlas size. It should be big enough</span>
 <span class="s0">*   to store all important shadow sources, with some buffer, because the shadow</span>
 <span class="s0">*   maps usually won't be fitted perfectly, so gaps can occur.</span>
 <span class="s0">*</span>
 <span class="s0">*   This has to get called before calling ShadowManager::init. When calling this</span>
 <span class="s0">*   method after initialization, an assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param atlas_size Size of the shadow atlas in pixels</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void ShadowManager::set_atlas_size(std::size_t atlas_size);</span>

<span class="s0">170 14 get_atlas_size 0 4 235 29 ShadowManager::get_atlas_size 0 1 64 190</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the shadow atlas size.</span>
 <span class="s0">* @details This returns the shadow atlas size previously set with</span>
 <span class="s0">*   ShadowManager::set_atlas_size.</span>
 <span class="s0">* @return Shadow atlas size in pixels</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::size_t ShadowManager::get_atlas_size(void) const;</span>

<span class="s0">171 25 get_num_update_slots_left 0 4 235 40 ShadowManager::get_num_update_slots_left 0 1 65 274</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns how many update slots are left.</span>
 <span class="s0">* @details This returns how many update slots are left. You can assume the</span>
 <span class="s0">*   next n calls to add_update will succeed, whereas n is the value returned</span>
 <span class="s0">*   by this function.</span>
 <span class="s0">* @return Number of update slots left.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline std::size_t ShadowManager::get_num_update_slots_left(void) const;</span>

<span class="s0">172 9 get_atlas 0 4 235 24 ShadowManager::get_atlas 0 1 66 309</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns a handle to the shadow atlas.</span>
 <span class="s0">* @details This returns a handle to the internal shadow atlas instance. This</span>
 <span class="s0">*   is only valid after calling ShadowManager::init. Calling this earlier will</span>
 <span class="s0">*   trigger an assertion and undefined behaviour.</span>
 <span class="s0">* @return The internal ShadowAtlas instance</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline ShadowAtlas *ShadowManager::get_atlas(void) const;</span>

<span class="s0">173 4 init 0 4 235 19 ShadowManager::init 0 1 67 396</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Initializes the ShadowManager.</span>
 <span class="s0">* @details This initializes the ShadowManager. All properties should have</span>
 <span class="s0">*   been set before calling this, otherwise assertions will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">*   This setups everything required for rendering shadows, including the</span>
 <span class="s0">*   shadow atlas and the various shadow cameras. After calling this method,</span>
 <span class="s0">*   no properties can be changed anymore.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void ShadowManager::init(void);</span>

<span class="s0">174 6 update 0 4 235 21 ShadowManager::update 0 1 68 398</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Updates the ShadowManager</span>
 <span class="s0">* @details This updates the ShadowManager, processing all shadow sources which</span>
 <span class="s0">*   need to get updated.</span>
 <span class="s0">*</span>
 <span class="s0">*   This first collects all sources which require an update, sorts them by priority,</span>
 <span class="s0">*   and then processes the first &lt;max_updates&gt; ShadowSources.</span>
 <span class="s0">*</span>
 <span class="s0">*   This may not get called before ShadowManager::init, or an assertion will be</span>
 <span class="s0">*   thrown.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void ShadowManager::update(void);</span>

<span class="s0">175 20 InternalLightManager 0 260 237 42 InternalLightManager::InternalLightManager 0 2 69 70 242</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs the light manager</span>
 <span class="s0">* @details This constructs the light manager, initializing the light and shadow</span>
 <span class="s0">*   storage. You should set a command list and shadow manager before calling</span>
 <span class="s0">*   InternalLightManager::update. s</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">InternalLightManager::InternalLightManager(void);</span>
<span class="s0">inline InternalLightManager::InternalLightManager(InternalLightManager const &amp;) = default;</span>

<span class="s0">176 9 add_light 0 4 237 31 InternalLightManager::add_light 0 1 71 817</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Adds a new light.</span>
 <span class="s0">* @details This adds a new light to the list of lights. This will throw an</span>
 <span class="s0">*   error and return if the light is already attached. You may only call</span>
 <span class="s0">*   this after the ShadowManager was already set.</span>
 <span class="s0">*</span>
 <span class="s0">*   While the light is attached, the light manager keeps a reference to it, so</span>
 <span class="s0">*   the light does not get destructed.</span>
 <span class="s0">*</span>
 <span class="s0">*   This also setups the shadows on the light, in case shadows are enabled.</span>
 <span class="s0">*   While a light is attached, you can not change whether it casts shadows or not.</span>
 <span class="s0">*   To do so, detach the light, change the setting, and re-add the light.</span>
 <span class="s0">*</span>
 <span class="s0">*   In case no free light slot is available, an error will be printed and no</span>
 <span class="s0">*   action will be performed.</span>
 <span class="s0">*</span>
 <span class="s0">*   If no shadow manager was set, an assertion will be triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param light The light to add.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">void InternalLightManager::add_light(PointerTo&lt; RPLight &gt; light);</span>

<span class="s0">177 12 remove_light 0 4 237 34 InternalLightManager::remove_light 0 1 72 763</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Removes a light</span>
 <span class="s0">* @details This detaches a light. This prevents it from being rendered, and also</span>
 <span class="s0">*   cleans up all resources used by that light. If no reference is kept on the</span>
 <span class="s0">*   python side, the light will also get destructed.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the light was not previously attached with InternalLightManager::add_light,</span>
 <span class="s0">*   an error will be triggered and nothing happens.</span>
 <span class="s0">*</span>
 <span class="s0">*   In case the light was set to cast shadows, all shadow sources are cleaned</span>
 <span class="s0">*   up, and their regions in the shadow atlas are freed.</span>
 <span class="s0">*</span>
 <span class="s0">*   All resources used by the light in the light and shadow storage are also</span>
 <span class="s0">*   cleaned up, by emitting cleanup GPUCommands.</span>
 <span class="s0">*</span>
 <span class="s0">*   If no shadow manager was set, an assertion will be triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param light [description]</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void InternalLightManager::remove_light(PointerTo&lt; RPLight &gt; light);</span>

<span class="s0">178 6 update 0 4 237 28 InternalLightManager::update 0 1 73 336</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Main update method</span>
 <span class="s0">* @details This is the main update method of the InternalLightManager. It</span>
 <span class="s0">*   processes all lights and shadow sources, updates them, and notifies the</span>
 <span class="s0">*   GPU about it. This should be called on a per-frame basis.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the InternalLightManager was not initialized yet, an assertion is thrown.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void InternalLightManager::update(void);</span>

<span class="s0">179 14 set_camera_pos 0 4 237 36 InternalLightManager::set_camera_pos 0 1 74 200</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the camera position</span>
 <span class="s0">* @details This sets the camera position, which will be used to determine which</span>
 <span class="s0">*   shadow sources have to get updated</span>
 <span class="s0">*</span>
 <span class="s0">* @param mat View projection mat</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void InternalLightManager::set_camera_pos(LPoint3 const &amp;pos);</span>

<span class="s0">180 26 set_shadow_update_distance 0 4 237 48 InternalLightManager::set_shadow_update_distance 0 1 75 309</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the maximum shadow update distance</span>
 <span class="s0">* @details This controls the maximum distance until which shadows are updated.</span>
 <span class="s0">*   If a shadow source is past that distance, it is ignored and no longer recieves</span>
 <span class="s0">*   updates until it is in range again</span>
 <span class="s0">*</span>
 <span class="s0">* @param dist Distance in world space units</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline void InternalLightManager::set_shadow_update_distance(PN_stdfloat dist);</span>

<span class="s0">181 19 get_max_light_index 0 4 237 41 InternalLightManager::get_max_light_index 0 1 76 870</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the maximum light index</span>
 <span class="s0">* @details This returns the maximum light index (also called slot). Any lights</span>
 <span class="s0">*   after that slot are guaranteed to be zero-lights. This is useful when</span>
 <span class="s0">*   iterating over the list of lights, because iteration can be stopped when</span>
 <span class="s0">*   the maximum light index is reached.</span>
 <span class="s0">*</span>
 <span class="s0">*   The maximum light index points to the last slot which is used. If no lights</span>
 <span class="s0">*   are attached, -1 is returned. If one light is attached at slot 0, the index</span>
 <span class="s0">*   is 0, if two are attached at the slots 0 and 1, the index is 1, and so on.</span>
 <span class="s0">*</span>
 <span class="s0">*   If, for example, two lights are attached at the slots 2 and 5, then the</span>
 <span class="s0">*   index will be 5. Keep in mind that the max-index is not an indicator for</span>
 <span class="s0">*   how many lights are attached. Also, zero lights still may occur when iterating</span>
 <span class="s0">*   over the light lists</span>
 <span class="s0">*</span>
 <span class="s0">* @return Maximum light index</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int InternalLightManager::get_max_light_index(void) const;</span>

<span class="s0">182 14 get_num_lights 0 4 237 36 InternalLightManager::get_num_lights 0 1 77 325</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the amount of stored lights.</span>
 <span class="s0">* @details This returns the amount of stored lights. This behaves unlike</span>
 <span class="s0">*   InternalLightManager::get_max_light_index, and instead returns the true</span>
 <span class="s0">*   amount of lights, which is completely unrelated to the amount of used slots.</span>
 <span class="s0">*</span>
 <span class="s0">* @return Amount of stored lights</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline std::size_t InternalLightManager::get_num_lights(void) const;</span>

<span class="s0">183 22 get_num_shadow_sources 0 4 237 44 InternalLightManager::get_num_shadow_sources 0 1 78 293</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the amount of shadow sources.</span>
 <span class="s0">* @details This returns the total amount of stored shadow sources. This does</span>
 <span class="s0">*   not denote the amount of updated sources, but instead takes into account</span>
 <span class="s0">*   all sources, even those out of frustum.</span>
 <span class="s0">* @return Amount of shadow sources.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline std::size_t InternalLightManager::get_num_shadow_sources(void) const;</span>

<span class="s0">184 18 set_shadow_manager 0 4 237 40 InternalLightManager::set_shadow_manager 0 1 79 623</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the handle to the shadow manager</span>
 <span class="s0">* @details This sets the handle to the global shadow manager. It is usually</span>
 <span class="s0">*   constructed on the python side, so we need to get a handle to it.</span>
 <span class="s0">*</span>
 <span class="s0">*   The manager should be a handle to a ShadowManager instance, and will be</span>
 <span class="s0">*   stored somewhere on the python side most likely. The light manager does not</span>
 <span class="s0">*   keep a reference to it, so the python side should make sure to keep one.</span>
 <span class="s0">*</span>
 <span class="s0">*   Be sure to call this before the InternalLightManager::update() method is</span>
 <span class="s0">*   called, otherwise an assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param mgr The ShadowManager instance</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void InternalLightManager::set_shadow_manager(ShadowManager *mgr);</span>

<span class="s0">185 18 get_shadow_manager 0 4 237 40 InternalLightManager::get_shadow_manager 0 1 80 155</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the internal used ShadowManager</span>
 <span class="s0">* @details This returns a handle to the internally used shadow manager</span>
 <span class="s0">* @return Shadow manager</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline ShadowManager *InternalLightManager::get_shadow_manager(void) const;</span>

<span class="s0">186 16 set_command_list 0 4 237 38 InternalLightManager::set_command_list 0 1 81 671</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets a handle to the command list</span>
 <span class="s0">* @details This sets a handle to the global GPUCommandList. This is required to</span>
 <span class="s0">*   emit GPUCommands, which are used for attaching and detaching lights, as well</span>
 <span class="s0">*   as shadow source updates.</span>
 <span class="s0">*</span>
 <span class="s0">*   The cmd_list should be a handle to a GPUCommandList handle, and will be</span>
 <span class="s0">*   stored somewhere on the python side most likely. The light manager does not</span>
 <span class="s0">*   keep a reference to it, so the python side should make sure to keep one.</span>
 <span class="s0">*</span>
 <span class="s0">*   Be sure to call this before the InternalLightManager::update() method is</span>
 <span class="s0">*   called, otherwise an assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param cmd_list The GPUCommandList instance</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void InternalLightManager::set_command_list(GPUCommandList *cmd_list);</span>

<span class="s0">187 21 ~InternalLightManager 0 516 237 43 InternalLightManager::~InternalLightManager 0 0 0</span>
<span class="s0">50</span>
<span class="s0">InternalLightManager::~InternalLightManager(void);</span>

<span class="s0">188 12 RPPointLight 0 260 239 26 RPPointLight::RPPointLight 0 1 82 255</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new point light</span>
 <span class="s0">* @details This contructs a new point light with default settings. By default</span>
 <span class="s0">*   the light is set to be an infinitely small point light source. You can</span>
 <span class="s0">*   change this with RPPointLight::set_inner_radius.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">RPPointLight::RPPointLight(void);</span>

<span class="s0">189 10 set_radius 0 4 239 24 RPPointLight::set_radius 0 1 83 257</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the radius of the light</span>
 <span class="s0">* @details This sets the radius of the light. It controls the lights</span>
 <span class="s0">*   influence. After a distance greater than this radius, the light influence</span>
 <span class="s0">*   is zero.</span>
 <span class="s0">*</span>
 <span class="s0">* @param radius Light radius in world space</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void RPPointLight::set_radius(float radius);</span>

<span class="s0">190 10 get_radius 0 4 239 24 RPPointLight::get_radius 0 1 84 175</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the lights radius</span>
 <span class="s0">* @details This returns the lights radius previously set with</span>
 <span class="s0">*   RPPointLight::set_radius</span>
 <span class="s0">* @return Light radius in world space</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline float RPPointLight::get_radius(void) const;</span>

<span class="s0">191 16 set_inner_radius 0 4 239 30 RPPointLight::set_inner_radius 0 1 85 725</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the inner radius of the light</span>
 <span class="s0">* @details This sets the inner radius of the light. Anything greater than</span>
 <span class="s0">*   zero causes the light to get an area light. This has influence on the</span>
 <span class="s0">*   specular highlights of the light aswell as the shadows.</span>
 <span class="s0">*</span>
 <span class="s0">*   The inner radius controls the size of the lights sphere size in world</span>
 <span class="s0">*   space units. A radius of 0 means the light has no inner radius, and the</span>
 <span class="s0">*   light will be have like an infinite small point light source.</span>
 <span class="s0">*   A radius greater than zero will cause the light to behave like it would be</span>
 <span class="s0">*   an emissive sphere with the given inner radius emitting light. This is</span>
 <span class="s0">*   more physically correct.</span>
 <span class="s0">*</span>
 <span class="s0">* @param inner_radius Inner-radius in world space</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void RPPointLight::set_inner_radius(float inner_radius);</span>

<span class="s0">192 16 get_inner_radius 0 4 239 30 RPPointLight::get_inner_radius 0 1 86 193</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the inner radius of the light</span>
 <span class="s0">* @details This returns the inner radius of the light, previously set with</span>
 <span class="s0">*   RPPointLight::get_inner_radius.</span>
 <span class="s0">* @return [description]</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline float RPPointLight::get_inner_radius(void) const;</span>

<span class="s0">193 13 ~RPPointLight 0 516 239 27 RPPointLight::~RPPointLight 0 0 0</span>
<span class="s0">34</span>
<span class="s0">RPPointLight::~RPPointLight(void);</span>

<span class="s0">194 13 PSSMCameraRig 0 260 240 28 PSSMCameraRig::PSSMCameraRig 0 2 87 88 320</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new PSSM camera rig</span>
 <span class="s0">* @details This constructs a new camera rig, with a given amount of splits.</span>
 <span class="s0">*   The splits can not be changed later on. Splits are also called Cascades.</span>
 <span class="s0">*</span>
 <span class="s0">*   An assertion will be triggered if the splits are below zero.</span>
 <span class="s0">*</span>
 <span class="s0">* @param num_splits Amount of PSSM splits</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">PSSMCameraRig::PSSMCameraRig(std::size_t num_splits);</span>
<span class="s0">inline PSSMCameraRig::PSSMCameraRig(PSSMCameraRig const &amp;) = default;</span>

<span class="s0">195 14 ~PSSMCameraRig 0 516 240 29 PSSMCameraRig::~PSSMCameraRig 0 0 117</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Destructs the camera rig</span>
 <span class="s0">* @details This destructs the camera rig, cleaning up all used resources.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">PSSMCameraRig::~PSSMCameraRig(void);</span>

<span class="s0">196 17 set_pssm_distance 0 4 240 32 PSSMCameraRig::set_pssm_distance 0 1 89 316</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the maximum pssm distance.</span>
 <span class="s0">* @details This sets the maximum distance in world space until which shadows</span>
 <span class="s0">*   are rendered. After this distance, no shadows will be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the distance is below zero, an assertion is triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param distance Maximum distance in world space</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void PSSMCameraRig::set_pssm_distance(float distance);</span>

<span class="s0">197 16 set_sun_distance 0 4 240 31 PSSMCameraRig::set_sun_distance 0 1 90 664</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the suns distance</span>
 <span class="s0">* @details This sets the distance the cameras will have from the cameras frustum.</span>
 <span class="s0">*   This prevents far objects from having no shadows, which can occur when these</span>
 <span class="s0">*   objects are between the cameras frustum and the sun, but not inside of the</span>
 <span class="s0">*   cameras frustum. Setting the sun distance high enough will move the cameras</span>
 <span class="s0">*   away from the camera frustum, being able to cover those distant objects too.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the sun distance is set too high, artifacts will occur due to the reduced</span>
 <span class="s0">*   range of depth. If a value below zero is passed, an assertion will get</span>
 <span class="s0">*   triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param distance The sun distance</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PSSMCameraRig::set_sun_distance(float distance);</span>

<span class="s0">198 23 set_use_fixed_film_size 0 4 240 38 PSSMCameraRig::set_use_fixed_film_size 0 1 91 566</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets whether to use a fixed film size</span>
 <span class="s0">* @details This controls if a fixed film size should be used. This will cause</span>
 <span class="s0">*   the camera rig to cache the current film size, and only change it in case</span>
 <span class="s0">*   it gets too small. This provides less flickering when moving, because the</span>
 <span class="s0">*   film size will stay roughly constant. However, to prevent the cached film</span>
 <span class="s0">*   size getting too big, one should call PSSMCameraRig::reset_film_size</span>
 <span class="s0">*   once in a while, otherwise there might be a lot of wasted space.</span>
 <span class="s0">*</span>
 <span class="s0">* @param flag Whether to use a fixed film size</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void PSSMCameraRig::set_use_fixed_film_size(bool flag);</span>

<span class="s0">199 14 set_resolution 0 4 240 29 PSSMCameraRig::set_resolution 0 1 92 432</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the resolution of each split</span>
 <span class="s0">* @details This sets the resolution of each split. Currently it is equal for</span>
 <span class="s0">*   each split. This is required when using PSSMCameraRig::set_use_stable_csm,</span>
 <span class="s0">*   to compute how bix a texel is.</span>
 <span class="s0">*</span>
 <span class="s0">*   It has to match the y-resolution of the pssm shadow map. If an invalid</span>
 <span class="s0">*   resolution is triggered, an assertion is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* @param resolution The resolution of each split.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void PSSMCameraRig::set_resolution(std::size_t resolution);</span>

<span class="s0">200 18 set_use_stable_csm 0 4 240 33 PSSMCameraRig::set_use_stable_csm 0 1 93 403</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets whether to use stable CSM snapping.</span>
 <span class="s0">* @details This option controls if stable CSM snapping should be used. When the</span>
 <span class="s0">*   option is enabled, all splits will snap to their texels, so that when moving,</span>
 <span class="s0">*   no flickering will occur. However, this only works when the splits do not</span>
 <span class="s0">*   change their film size, rotation and angle.</span>
 <span class="s0">*</span>
 <span class="s0">* @param flag Whether to use stable CSM snapping</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void PSSMCameraRig::set_use_stable_csm(bool flag);</span>

<span class="s0">201 22 set_logarithmic_factor 0 4 240 37 PSSMCameraRig::set_logarithmic_factor 0 1 94 775</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the logarithmic factor</span>
 <span class="s0">* @details This sets the logarithmic factor, which is the core of the algorithm.</span>
 <span class="s0">*   PSSM splits the camera frustum based on a linear and a logarithmic factor.</span>
 <span class="s0">*   While a linear factor provides a good distribution, it often is not applicable</span>
 <span class="s0">*   for wider distances. A logarithmic distribution provides a better distribution</span>
 <span class="s0">*   at distance, but suffers from splitting in the near areas.</span>
 <span class="s0">*</span>
 <span class="s0">*   The logarithmic factor mixes the logarithmic and linear split distribution,</span>
 <span class="s0">*   to get the best of both. A greater factor will make the distribution more</span>
 <span class="s0">*   logarithmic, while a smaller factor will make it more linear.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the factor is below zero, an ssertion is triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param factor The logarithmic factor</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void PSSMCameraRig::set_logarithmic_factor(float factor);</span>

<span class="s0">202 15 set_border_bias 0 4 240 30 PSSMCameraRig::set_border_bias 0 1 95 482</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the border bias for each split</span>
 <span class="s0">* @details This sets the border bias for every split. This increases each</span>
 <span class="s0">*   splits frustum by multiplying it by (1 + bias), and helps reducing artifacts</span>
 <span class="s0">*   at the borders of the splits. Artifacts can occur when the bias is too low,</span>
 <span class="s0">*   because then the filtering will go over the bounds of the split, producing</span>
 <span class="s0">*   invalid results.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the bias is below zero, an assertion is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* @param bias Border bias</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void PSSMCameraRig::set_border_bias(float bias);</span>

<span class="s0">203 6 update 0 4 240 21 PSSMCameraRig::update 0 1 96 493</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Updates the PSSM camera rig</span>
 <span class="s0">* @details This updates the rig with an updated camera position, and a given</span>
 <span class="s0">*   light vector. This should be called on a per-frame basis. It will reposition</span>
 <span class="s0">*   all camera sources to fit the frustum based on the pssm distribution.</span>
 <span class="s0">*</span>
 <span class="s0">*   The light vector should be the vector from the light source, not the</span>
 <span class="s0">*   vector to the light source.</span>
 <span class="s0">*</span>
 <span class="s0">* @param cam_node Target camera node</span>
 <span class="s0">* @param light_vector The vector from the light to any point</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">void PSSMCameraRig::update(NodePath cam_node, LVecBase3 const &amp;light_vector);</span>

<span class="s0">204 21 reset_film_size_cache 0 4 240 36 PSSMCameraRig::reset_film_size_cache 0 1 97 719</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Resets the film size cache</span>
 <span class="s0">* @details In case PSSMCameraRig::set_use_fixed_film_size is used, this resets</span>
 <span class="s0">*   the film size cache. This might lead to a small &quot;jump&quot; in the shadows,</span>
 <span class="s0">*   because the film size changes, however it leads to a better shadow distribution.</span>
 <span class="s0">*</span>
 <span class="s0">*   This is the case because when using a fixed film size, the cache will get</span>
 <span class="s0">*   bigger and bigger, whenever the camera moves to a grazing angle. However,</span>
 <span class="s0">*   when moving back to a normal angle, the film size cache still stores this</span>
 <span class="s0">*   big angle, and thus the splits will have a much bigger film size than actualy</span>
 <span class="s0">*   required. To prevent this, call this method once in a while, so an optimal</span>
 <span class="s0">*   distribution is ensured.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void PSSMCameraRig::reset_film_size_cache(void);</span>

<span class="s0">205 10 get_camera 0 4 240 25 PSSMCameraRig::get_camera 0 1 98 593</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the n-th camera</span>
 <span class="s0">* @details This returns the n-th camera of the camera rig, which can be used</span>
 <span class="s0">*   for various stuff like showing its frustum, passing it as a shader input,</span>
 <span class="s0">*   and so on.</span>
 <span class="s0">*</span>
 <span class="s0">*   The first camera is the camera which is the camera of the first split,</span>
 <span class="s0">*   which is the split closest to the camera. All cameras follow in descending</span>
 <span class="s0">*   order until to the last camera, which is the split furthest away from the</span>
 <span class="s0">*   camera.</span>
 <span class="s0">*</span>
 <span class="s0">*   If an invalid index is passed, an assertion is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* @param index Index of the camera.</span>
 <span class="s0">* @return [description]</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline NodePath PSSMCameraRig::get_camera(std::size_t index);</span>

<span class="s0">206 11 reparent_to 0 4 240 26 PSSMCameraRig::reparent_to 0 1 99 342</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Reparents the camera rig</span>
 <span class="s0">* @details This reparents all cameras to the given parent. Usually the parent</span>
 <span class="s0">*   will be ShowBase.render. The parent should be the same node where the</span>
 <span class="s0">*   main camera is located in, too.</span>
 <span class="s0">*</span>
 <span class="s0">*   If an empty parrent is passed, an assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param parent Parent node path</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void PSSMCameraRig::reparent_to(NodePath parent);</span>

<span class="s0">207 13 get_mvp_array 0 4 240 28 PSSMCameraRig::get_mvp_array 0 1 100 315</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns a handle to the MVP array</span>
 <span class="s0">* @details This returns a handle to the array of view-projection matrices</span>
 <span class="s0">*   of the different splits. This can be used for computing shadows. The array</span>
 <span class="s0">*   is a PTALMatrix4 and thus can be directly bound to a shader.</span>
 <span class="s0">*</span>
 <span class="s0">* @return view-projection matrix array</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline PTA_LMatrix4 const &amp;PSSMCameraRig::get_mvp_array(void);</span>

<span class="s0">208 17 get_nearfar_array 0 4 240 32 PSSMCameraRig::get_nearfar_array 0 1 101 508</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns a handle to the near and far planes array</span>
 <span class="s0">* @details This returns a handle to the near and far plane array. Each split</span>
 <span class="s0">*   has an entry in the array, whereas the x component of the vecto denotes the</span>
 <span class="s0">*   near plane, and the y component denotes the far plane of the split.</span>
 <span class="s0">*</span>
 <span class="s0">*   This is required because the near and far planes of the splits change</span>
 <span class="s0">*   constantly. To access them in a shader, the shader needs access to the</span>
 <span class="s0">*   array.</span>
 <span class="s0">*</span>
 <span class="s0">* @return Array of near and far planes</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline PTA_LVecBase2 const &amp;PSSMCameraRig::get_nearfar_array(void);</span>

<span class="s0">209 11 RPSpotLight 0 260 241 24 RPSpotLight::RPSpotLight 0 1 102 206</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Creates a new spot light</span>
 <span class="s0">* @details This creates a new spot light with default properties set. You should</span>
 <span class="s0">*   set at least a direction, fov, radius and position to make the light useful.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">RPSpotLight::RPSpotLight(void);</span>

<span class="s0">210 10 set_radius 0 4 241 23 RPSpotLight::set_radius 0 1 103 0</span>
<span class="s0">50</span>
<span class="s0">inline void RPSpotLight::set_radius(float radius);</span>

<span class="s0">211 10 get_radius 0 4 241 23 RPSpotLight::get_radius 0 1 104 0</span>
<span class="s0">49</span>
<span class="s0">inline float RPSpotLight::get_radius(void) const;</span>

<span class="s0">212 7 set_fov 0 4 241 20 RPSpotLight::set_fov 0 1 105 0</span>
<span class="s0">44</span>
<span class="s0">inline void RPSpotLight::set_fov(float fov);</span>

<span class="s0">213 7 get_fov 0 4 241 20 RPSpotLight::get_fov 0 1 106 0</span>
<span class="s0">46</span>
<span class="s0">inline float RPSpotLight::get_fov(void) const;</span>

<span class="s0">214 13 set_direction 0 4 241 26 RPSpotLight::set_direction 0 2 107 108 0</span>
<span class="s0">130</span>
<span class="s0">inline void RPSpotLight::set_direction(LVecBase3 direction);</span>
<span class="s0">inline void RPSpotLight::set_direction(float dx, float dy, float dz);</span>

<span class="s0">215 13 get_direction 0 4 241 26 RPSpotLight::get_direction 0 1 109 0</span>
<span class="s0">63</span>
<span class="s0">inline LVecBase3 const &amp;RPSpotLight::get_direction(void) const;</span>

<span class="s0">216 7 look_at 0 4 241 20 RPSpotLight::look_at 0 2 110 111 0</span>
<span class="s0">111</span>
<span class="s0">inline void RPSpotLight::look_at(LVecBase3 point);</span>
<span class="s0">inline void RPSpotLight::look_at(float x, float y, float z);</span>

<span class="s0">217 12 ~RPSpotLight 0 516 241 25 RPSpotLight::~RPSpotLight 0 0 0</span>
<span class="s0">32</span>
<span class="s0">RPSpotLight::~RPSpotLight(void);</span>

<span class="s0">111</span>
<span class="s0">1 0 0 15 3 244 122 0 0 1 6 param0 0 242  </span>
<span class="s0">2 0 0 23 3 244 122 0 346 /**</span>
 <span class="s0">* @brief Constructs a new GPUCommand with the given command type.</span>
 <span class="s0">* @details This will construct a new GPUCommand of the given command type.</span>
 <span class="s0">*   The command type should be of GPUCommand::CommandType, and determines</span>
 <span class="s0">*   what data the GPUCommand contains, and how it will be handled.</span>
 <span class="s0">*</span>
 <span class="s0">* @param command_type The type of the GPUCommand</span>
 <span class="s0">*/ 1 12 command_type 1 219  </span>
<span class="s0">3 0 0 4 4 245 0 0 308 /**</span>
 <span class="s0">* @brief Appends an integer to the GPUCommand.</span>
 <span class="s0">* @details This adds an integer to the back of the GPUCommand. Depending on the</span>
 <span class="s0">*   setting in convert_int_to_float, this will either just convert the int to a</span>
 <span class="s0">*   float by casting it, or just do a bitwise copy.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v The integer to append.</span>
 <span class="s0">*/ 2 4 this 3 244  1 v 1 232  </span>
<span class="s0">4 0 0 4 5 245 0 0 415 /**</span>
 <span class="s0">* @brief Appends a float to the GPUCommand.</span>
 <span class="s0">* @details This adds an integer to the back of the GPUCommand. Its used by all</span>
 <span class="s0">*   other push_xxx methods, and simply stores the value, then increments the write</span>
 <span class="s0">*   pointer. When the amount of floats exceeds the capacity of the GPUCommand,</span>
 <span class="s0">*   an error will be printed, and the method returns without doing anything else.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v The float to append.</span>
 <span class="s0">*/ 2 4 this 3 244  1 v 1 230  </span>
<span class="s0">5 0 0 4 6 245 0 0 341 /**</span>
 <span class="s0">* @brief Appends a 3-component floating point vector to the GPUCommand.</span>
 <span class="s0">* @details This appends a 3-component floating point vector to the command.</span>
 <span class="s0">*   It basically just calls push_float() for every component, in the order</span>
 <span class="s0">*   x, y, z, which causes the vector to occupy the space of 3 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Int-Vector to append.</span>
 <span class="s0">*/ 2 4 this 3 244  1 v 1 246  </span>
<span class="s0">6 0 0 4 6 245 0 0 325 /**</span>
 <span class="s0">* @brief Appends a 3-component integer vector to the GPUCommand.</span>
 <span class="s0">* @details This appends a 3-component integer vector to the command.</span>
 <span class="s0">*   It basically just calls push_int() for every component, in the order</span>
 <span class="s0">*   x, y, z, which causes the vector to occupy the space of 3 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Int-Vector to append.</span>
 <span class="s0">*/ 2 4 this 3 244  1 v 1 247  </span>
<span class="s0">7 0 0 4 7 245 0 0 341 /**</span>
 <span class="s0">* @brief Appends a 4-component floating point vector to the GPUCommand.</span>
 <span class="s0">* @details This appends a 4-component floating point vector to the command.</span>
 <span class="s0">*   It basically just calls push_float() for every component, in the order</span>
 <span class="s0">*   x, y, z, which causes the vector to occupy the space of 3 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Int-Vector to append.</span>
 <span class="s0">*/ 2 4 this 3 244  1 v 1 250  </span>
<span class="s0">8 0 0 4 7 245 0 0 328 /**</span>
 <span class="s0">* @brief Appends a 4-component integer vector to the GPUCommand.</span>
 <span class="s0">* @details This appends a 4-component integer vector to the command.</span>
 <span class="s0">*   It basically just calls push_int() for every component, in the order</span>
 <span class="s0">*   x, y, z, w, which causes the vector to occupy the space of 4 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Int-Vector to append.</span>
 <span class="s0">*/ 2 4 this 3 244  1 v 1 254  </span>
<span class="s0">9 0 0 4 8 245 0 0 276 /**</span>
 <span class="s0">* @brief Appends a floating point 3x3 matrix to the GPUCommand.</span>
 <span class="s0">* @details This appends a floating point 3x3 matrix to the GPUCommand, by</span>
 <span class="s0">*   pushing all components in row-order to the command. This occupies a space of</span>
 <span class="s0">*   9 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Matrix to append</span>
 <span class="s0">*/ 2 4 this 3 244  1 v 1 257  </span>
<span class="s0">10 0 0 4 9 245 0 0 277 /**</span>
 <span class="s0">* @brief Appends a floating point 4x4 matrix to the GPUCommand.</span>
 <span class="s0">* @details This appends a floating point 4x4 matrix to the GPUCommand, by</span>
 <span class="s0">*   pushing all components in row-order to the command. This occupies a space of</span>
 <span class="s0">*   16 floats.</span>
 <span class="s0">*</span>
 <span class="s0">* @param v Matrix to append</span>
 <span class="s0">*/ 2 4 this 3 244  1 v 1 261  </span>
<span class="s0">11 0 0 6 10 231 0 0 434 /**</span>
 <span class="s0">* @brief Returns whether integers are packed as floats.</span>
 <span class="s0">* @details This returns how integer are packed into the data stream. If the</span>
 <span class="s0">*   returned value is true, then integers are packed using their binary</span>
 <span class="s0">*   representation converted to floating point format. If the returned value</span>
 <span class="s0">*   is false, then integers are packed by simply casting them to float,</span>
 <span class="s0">*   e.g. val = (float)i;</span>
 <span class="s0">* @return The integer representation flag</span>
 <span class="s0">*/ 0 </span>
<span class="s0">12 0 0 4 11 245 0 0 694 /**</span>
 <span class="s0">* @brief Writes the GPU command to a given target.</span>
 <span class="s0">* @details This method writes all the data of the GPU command to a given target.</span>
 <span class="s0">*   The target should be a pointer to memory being big enough to hold the</span>
 <span class="s0">*   data. Presumably #dest will be a handle to texture memory.</span>
 <span class="s0">*   The command_index controls the offset where the data will be written</span>
 <span class="s0">*   to.</span>
 <span class="s0">*</span>
 <span class="s0">* @param dest Handle to the memory to write the command to</span>
 <span class="s0">* @param command_index Offset to write the command to. The command will write</span>
 <span class="s0">*   its data to command_index * GPU_COMMAND_ENTRIES. When writing</span>
 <span class="s0">*   the GPUCommand in a GPUCommandList, the command_index will</span>
 <span class="s0">*   most likely be the index of the command in the list.</span>
 <span class="s0">*/ 3 4 this 3 244  4 dest 1 265  13 command_index 1 221  </span>
<span class="s0">13 0 0 4 12 245 0 0 373 /**</span>
 <span class="s0">* @brief Prints out the GPUCommand to the console</span>
 <span class="s0">* @details This method prints the type, size, and data of the GPUCommand to the</span>
 <span class="s0">*   console. This helps for debugging the contents of the GPUCommand. Keep</span>
 <span class="s0">*   in mind that integers might be shown in their binary float representation,</span>
 <span class="s0">*   depending on the setting in the GPUCommand::convert_int_to_float method.</span>
 <span class="s0">*/ 2 4 this 3 242  3 out 1 269  </span>
<span class="s0">14 0 0 7 15 271 127 0 151 /**</span>
 <span class="s0">* @brief Constructs a new GPUCommandList</span>
 <span class="s0">* @details This constructs a new GPUCommandList. By default, there are no commands</span>
 <span class="s0">*   in the list.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">15 0 0 15 15 271 127 0 0 1 6 param0 0 272  </span>
<span class="s0">16 0 0 4 16 245 0 0 174 /**</span>
 <span class="s0">* @brief Pushes a GPUCommand to the command list.</span>
 <span class="s0">* @details This adds a new GPUCommand to the list of commands to be processed.</span>
 <span class="s0">*</span>
 <span class="s0">* @param cmd The command to add</span>
 <span class="s0">*/ 2 4 this 3 271  3 cmd 1 242  </span>
<span class="s0">17 0 0 6 17 221 0 0 220 /**</span>
 <span class="s0">* @brief Returns the number of commands in this list.</span>
 <span class="s0">* @details This returns the amount of commands which are currently stored in this</span>
 <span class="s0">*   list, and are waiting to get processed.</span>
 <span class="s0">* @return Amount of commands</span>
 <span class="s0">*/ 1 4 this 3 271  </span>
<span class="s0">18 0 0 6 18 221 0 0 586 /**</span>
 <span class="s0">* @brief Writes the first n-commands to a destination.</span>
 <span class="s0">* @details This takes the first #limit commands, and writes them to the</span>
 <span class="s0">*   destination using GPUCommand::write_to. See GPUCommand::write_to for</span>
 <span class="s0">*   further information about #dest. The limit controls after how much</span>
 <span class="s0">*   commands the processing will be stopped. All commands which got processed</span>
 <span class="s0">*   will get removed from the list.</span>
 <span class="s0">*</span>
 <span class="s0">* @param dest Destination to write to, see GPUCommand::write_to</span>
 <span class="s0">* @param limit Maximum amount of commands to process</span>
 <span class="s0">*</span>
 <span class="s0">* @return Amount of commands processed, between 0 and #limit.</span>
 <span class="s0">*/ 3 4 this 3 271  4 dest 1 265  5 limit 5 221  </span>
<span class="s0">19 0 0 7 24 274 133 0 112 /**</span>
 <span class="s0">* @brief Constructs a new empty dataset.</span>
 <span class="s0">* @details This constructs a new IESDataset with no data set.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">20 0 0 15 24 274 133 0 0 1 6 param0 0 275  </span>
<span class="s0">21 0 0 4 25 245 0 0 184 /**</span>
 <span class="s0">* @brief Sets the vertical angles of the dataset.</span>
 <span class="s0">* @details This sets the list of vertical angles of the dataset.</span>
 <span class="s0">*</span>
 <span class="s0">* @param vertical_angles Vector of all vertical angles.</span>
 <span class="s0">*/ 2 4 this 3 274  15 vertical_angles 1 277  </span>
<span class="s0">22 0 0 4 26 245 0 0 192 /**</span>
 <span class="s0">* @brief Sets the horizontal angles of the dataset.</span>
 <span class="s0">* @details This sets the list of horizontal angles of the dataset.</span>
 <span class="s0">*</span>
 <span class="s0">* @param horizontal_angles Vector of all horizontal angles.</span>
 <span class="s0">*/ 2 4 this 3 274  17 horizontal_angles 1 277  </span>
<span class="s0">23 0 0 4 27 245 0 0 336 /**</span>
 <span class="s0">* @brief Sets the candela values.</span>
 <span class="s0">* @details This sets the candela values of the dataset. They should be an</span>
 <span class="s0">*   interleaved 2D array with the dimensions vertical_angles x horizontal_angles.</span>
 <span class="s0">*   They also should be normalized by dividing by the maximum entry.</span>
 <span class="s0">* @param candela_values Interleaved 2D-vector of candela values.</span>
 <span class="s0">*/ 2 4 this 3 274  14 candela_values 1 277  </span>
<span class="s0">24 0 0 4 28 245 0 0 362 /**</span>
 <span class="s0">* @brief Generates the IES LUT</span>
 <span class="s0">* @details This generates the LUT into a given dataset texture. The x-axis</span>
 <span class="s0">*   referes to the vertical_angle, whereas the y-axis refers to the</span>
 <span class="s0">*   horizontal angle.</span>
 <span class="s0">*</span>
 <span class="s0">* @param dest_tex Texture to write the LUT into</span>
 <span class="s0">* @param z Layer to write the LUT into, in case the texture is a 3D Texture or</span>
 <span class="s0">*   2D Texture Array.</span>
 <span class="s0">*/ 3 4 this 3 275  8 dest_tex 1 281  1 z 1 221  </span>
<span class="s0">25 0 0 4 33 245 0 0 488 /**</span>
 <span class="s0">* @brief Invalidates the shadows</span>
 <span class="s0">* @details This invalidates all shadows of the light, causing them to get</span>
 <span class="s0">*   regenerated. This might be the case  when the lights position or similar</span>
 <span class="s0">*   changed. This will cause all shadow sources to be updated, emitting a</span>
 <span class="s0">*   shadow update. Be careful when calling this method if you don't want all</span>
 <span class="s0">*   sources to get updated. If you only have to invalidate a single shadow source,</span>
 <span class="s0">*   use `get_shadow_source(n)-&gt;set_needs_update(true)`.</span>
 <span class="s0">*/ 1 4 this 3 283  </span>
<span class="s0">26 0 0 4 34 245 0 0 230 /**</span>
 <span class="s0">* @brief Sets the position of the light</span>
 <span class="s0">* @details This sets the position of the light in world space. It will cause</span>
 <span class="s0">*   the light to get invalidated, and resubmitted to the GPU.</span>
 <span class="s0">*</span>
 <span class="s0">* @param pos Position in world space</span>
 <span class="s0">*/ 2 4 this 3 283  3 pos 1 246  </span>
<span class="s0">27 0 0 4 34 245 0 0 235 /**</span>
 <span class="s0">* @brief Sets the position of the light</span>
 <span class="s0">* @details @copydetails RPLight::set_pos(const LVecBase3 &amp;pos)</span>
 <span class="s0">*</span>
 <span class="s0">* @param x X-component of the position</span>
 <span class="s0">* @param y Y-component of the position</span>
 <span class="s0">* @param z Z-component of the position</span>
 <span class="s0">*/ 4 4 this 3 283  1 x 1 230  1 y 1 230  1 z 1 230  </span>
<span class="s0">28 0 0 6 35 246 0 0 214 /**</span>
 <span class="s0">* @brief Returns the position of the light</span>
 <span class="s0">* @details This returns the position of the light previously set with</span>
 <span class="s0">*   RPLight::set_pos(). The returned position is in world space.</span>
 <span class="s0">* @return Light-position</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">29 0 0 4 40 245 0 0 461 /**</span>
 <span class="s0">* @brief Sets the lights color</span>
 <span class="s0">* @details This sets the lights color. The color should not include the brightness</span>
 <span class="s0">*   of the light, you should control that with the energy. The color specifies</span>
 <span class="s0">*   the lights &quot;tint&quot; and will get multiplied with its specular and diffuse</span>
 <span class="s0">*   contribution.</span>
 <span class="s0">*</span>
 <span class="s0">*   The color will be normalized by dividing by the colors luminance. Setting</span>
 <span class="s0">*   higher values than 1.0 will have no effect.</span>
 <span class="s0">*</span>
 <span class="s0">* @param color Light color</span>
 <span class="s0">*/ 2 4 this 3 283  5 color 1 246  </span>
<span class="s0">30 0 0 4 40 245 0 0 230 /**</span>
 <span class="s0">* @brief Sets the lights color</span>
 <span class="s0">* @details @copydetails RPLight::set_color(const LVecBase3 &amp;color)</span>
 <span class="s0">*</span>
 <span class="s0">* @param r Red-component of the color</span>
 <span class="s0">* @param g Green-component of the color</span>
 <span class="s0">* @param b Blue-component of the color</span>
 <span class="s0">*/ 4 4 this 3 283  1 r 1 230  1 g 1 230  1 b 1 230  </span>
<span class="s0">31 0 0 6 41 246 0 0 324 /**</span>
 <span class="s0">* @brief Returns the lights color</span>
 <span class="s0">* @details This returns the light color, previously set with RPLight::set_color.</span>
 <span class="s0">*   This does not include the energy of the light. It might differ from what</span>
 <span class="s0">*   was set with set_color, because the color is normalized by dividing it</span>
 <span class="s0">*   by its luminance.</span>
 <span class="s0">* @return Light-color</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">32 0 0 4 43 245 0 0 304 /**</span>
 <span class="s0">* @brief Sets the lights color from a given color temperature</span>
 <span class="s0">* @details This sets the lights color, given a temperature. This is more</span>
 <span class="s0">*   physically based than setting a user defined color. The color will be</span>
 <span class="s0">*   computed from the given temperature.</span>
 <span class="s0">*</span>
 <span class="s0">* @param temperature Light temperature</span>
 <span class="s0">*/ 2 4 this 3 283  11 temperature 1 230  </span>
<span class="s0">33 0 0 4 44 245 0 0 238 /**</span>
 <span class="s0">* @brief Sets the energy of the light</span>
 <span class="s0">* @details This sets the energy of the light, which can be seen as the brightness</span>
 <span class="s0">*   of the light. It will get multiplied with the normalized color.</span>
 <span class="s0">*</span>
 <span class="s0">* @param energy energy of the light</span>
 <span class="s0">*/ 2 4 this 3 283  6 energy 1 230  </span>
<span class="s0">34 0 0 6 45 230 0 0 179 /**</span>
 <span class="s0">* @brief Returns the energy of the light</span>
 <span class="s0">* @details This returns the energy of the light, previously set with</span>
 <span class="s0">*   RPLight::set_energy.</span>
 <span class="s0">*</span>
 <span class="s0">* @return energy of the light</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">35 0 0 6 48 226 0 0 243 /**</span>
 <span class="s0">* @brief Returns the type of the light</span>
 <span class="s0">* @details This returns the internal type of the light, which was specified</span>
 <span class="s0">*   in the lights constructor. This can be used to distinguish between light</span>
 <span class="s0">*   types.</span>
 <span class="s0">* @return Type of the light</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">36 0 0 4 50 245 0 0 426 /**</span>
 <span class="s0">* @brief Controls whether the light casts shadows</span>
 <span class="s0">* @details This sets whether the light casts shadows. You can not change this</span>
 <span class="s0">*   while the light is attached. When flag is set to true, the light will be</span>
 <span class="s0">*   setup to cast shadows, spawning shadow sources based on the lights type.</span>
 <span class="s0">*   If the flag is set to false, the light will be inddicated to cast no shadows.</span>
 <span class="s0">*</span>
 <span class="s0">* @param flag Whether the light casts shadows</span>
 <span class="s0">*/ 2 4 this 3 283  4 flag 5 231  </span>
<span class="s0">37 0 0 6 51 231 0 0 261 /**</span>
 <span class="s0">* @brief Returns whether the light casts shadows</span>
 <span class="s0">* @details This returns whether the light casts shadows, the returned value</span>
 <span class="s0">*   is the one previously set with RPLight::set_casts_shadows.</span>
 <span class="s0">*</span>
 <span class="s0">* @return true if the light casts shadows, false otherwise</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">38 0 0 4 54 245 0 0 580 /**</span>
 <span class="s0">* @brief Sets the light's shadow map resolution</span>
 <span class="s0">* @details This sets the light's shadow map resolution. This has no effect</span>
 <span class="s0">*   when the light is not told to cast shadows (Use RPLight::set_casts_shadows).</span>
 <span class="s0">*</span>
 <span class="s0">*   When calling this on a light with multiple shadow sources (e.g.</span>
 <span class="s0">*   RPPointLight), this controls the resolution of each source. If the light</span>
 <span class="s0">*   has 6 shadow sources, and you use a resolution of 512x512, the light's</span>
 <span class="s0">*   shadow map will occupy a space of 6 * 512x512 maps in the shadow atlas.</span>
 <span class="s0">*</span>
 <span class="s0">* @param resolution Resolution of the shadow map in pixels</span>
 <span class="s0">*/ 2 4 this 3 283  10 resolution 1 221  </span>
<span class="s0">39 0 0 6 55 221 0 0 343 /**</span>
 <span class="s0">* @brief Returns the shadow map resolution</span>
 <span class="s0">* @details This returns the shadow map resolution of each source of the light.</span>
 <span class="s0">*   If the light is not setup to cast shadows, this value is meaningless.</span>
 <span class="s0">*   The returned value is the one previously set with RPLight::set_shadow_map_resolution.</span>
 <span class="s0">*</span>
 <span class="s0">* @return Shadow map resolution in pixels</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">40 0 0 4 57 245 0 0 500 /**</span>
 <span class="s0">* @brief Sets the IES profile</span>
 <span class="s0">* @details This sets the ies profile of the light. The parameter should be a</span>
 <span class="s0">*   handle previously returned by RenderPipeline.load_ies_profile. Using a</span>
 <span class="s0">*   value of -1 indicates no ies profile.</span>
 <span class="s0">*</span>
 <span class="s0">*   Notice that for IES profiles which cover a whole range, you should use an</span>
 <span class="s0">*   RPPointLight, whereas for ies profiles which only cover the lower</span>
 <span class="s0">*   hemisphere you should use an RPSpotLight for the best performance.</span>
 <span class="s0">*</span>
 <span class="s0">* @param profile IES Profile handle</span>
 <span class="s0">*/ 2 4 this 3 283  7 profile 1 232  </span>
<span class="s0">41 0 0 6 58 232 0 0 230 /**</span>
 <span class="s0">* @brief Returns the light's IES profile</span>
 <span class="s0">* @details This returns the IES profile of a light, previously set with</span>
 <span class="s0">*   RPLight::set_ies_profile. In case no ies profile was set, returns -1.</span>
 <span class="s0">*</span>
 <span class="s0">* @return IES Profile handle</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">42 0 0 6 59 231 0 0 272 /**</span>
 <span class="s0">* @brief Returns whether the light has an IES profile assigned</span>
 <span class="s0">* @details This returns whether the light has an IES profile assigned,</span>
 <span class="s0">*   previously done with RPLight::set_ies_profile.</span>
 <span class="s0">*</span>
 <span class="s0">* @return true if the light has an IES profile assigned, false otherwise</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">43 0 0 4 60 245 0 0 184 /**</span>
 <span class="s0">* @brief Clears the IES profile</span>
 <span class="s0">* @details This clears the IES profile of the light, telling it to no longer</span>
 <span class="s0">*   use an IES profile, and instead use the default attenuation.</span>
 <span class="s0">*/ 1 4 this 3 283  </span>
<span class="s0">44 0 0 4 63 245 0 0 550 /**</span>
 <span class="s0">* @brief Sets the near plane of the light</span>
 <span class="s0">* @details This sets the near plane of all shadow sources of the light. It has</span>
 <span class="s0">*   no effects if the light does not cast shadows. This prevents artifacts from</span>
 <span class="s0">*   objects near to the light. It behaves like Lens::set_near().</span>
 <span class="s0">*</span>
 <span class="s0">*   It can also help increasing shadow map precision, low near planes will</span>
 <span class="s0">*   cause the precision to suffer. Try setting the near plane as big as possible.</span>
 <span class="s0">*</span>
 <span class="s0">*   If a negative or zero near plane is passed, an assertion is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* @param near_plane Near-plane</span>
 <span class="s0">*/ 2 4 this 3 283  10 near_plane 1 230  </span>
<span class="s0">45 0 0 6 64 230 0 0 245 /**</span>
 <span class="s0">* @brief Returns the near plane of the light</span>
 <span class="s0">* @details This returns the light's near plane, previously set with</span>
 <span class="s0">*   RPLight::set_near_plane. If the light does not cast shadows, this value</span>
 <span class="s0">*   is meaningless.</span>
 <span class="s0">*</span>
 <span class="s0">* @return Near-plane</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">46 0 0 15 67 236 154 0 0 1 6 param0 0 286  </span>
<span class="s0">47 0 0 23 67 236 154 0 880 /**</span>
 <span class="s0">* @brief Constructs a new shadow atlas.</span>
 <span class="s0">* @details This constructs a new shadow atlas with the given size and tile size.</span>
 <span class="s0">*</span>
 <span class="s0">*   The size determines the total size of the atlas in pixels. It should be a</span>
 <span class="s0">*   power-of-two to favour the GPU.</span>
 <span class="s0">*</span>
 <span class="s0">*   The tile_size determines the smallest unit of tiles the atlas can store.</span>
 <span class="s0">*   If, for example, a tile_size of 32 is used, then every entry stored must</span>
 <span class="s0">*   have a resolution of 32 or greater, and the resolution must be a multiple</span>
 <span class="s0">*   of 32. This is to optimize the search in the atlas, so the atlas does not</span>
 <span class="s0">*   have to check every pixel, and instead can just check whole tiles.</span>
 <span class="s0">*</span>
 <span class="s0">*   If you want to disable the use of tiles, set the tile_size to 1, which</span>
 <span class="s0">*   will make the shadow atlas use pixels instead of tiles.</span>
 <span class="s0">*</span>
 <span class="s0">* @param size Atlas-size in pixels</span>
 <span class="s0">* @param tile_size tile-size in pixels, or 1 to use no tiles.</span>
 <span class="s0">*/ 2 4 size 1 221  9 tile_size 5 221  </span>
<span class="s0">48 0 0 6 69 232 0 0 140 /**</span>
 <span class="s0">* @brief Returns the amount of used tiles</span>
 <span class="s0">* @details Returns the amount of used tiles in the atlas</span>
 <span class="s0">* @return Amount of used tiles</span>
 <span class="s0">*/ 1 4 this 3 286  </span>
<span class="s0">49 0 0 6 70 230 0 0 315 /**</span>
 <span class="s0">* @brief Returns the amount of used tiles in percentage</span>
 <span class="s0">* @details This returns in percentage from 0 to 1 how much space of the atlas</span>
 <span class="s0">*   is used right now. A value of 1 means the atlas is completely full, whereas</span>
 <span class="s0">*   a value of 0 means the atlas is completely free.</span>
 <span class="s0">* @return Atlas usage in percentage</span>
 <span class="s0">*/ 1 4 this 3 286  </span>
<span class="s0">50 0 0 23 74 290 158 0 351 /**</span>
 <span class="s0">* @brief Constructs a new TagStateManager</span>
 <span class="s0">* @details This constructs a new TagStateManager. The #main_cam_node should</span>
 <span class="s0">*   refer to the main scene camera, and will most likely be base.cam.</span>
 <span class="s0">*   It is necessary to pass the camera because the C++ code does not have</span>
 <span class="s0">*   access to the showbase.</span>
 <span class="s0">*</span>
 <span class="s0">* @param main_cam_node The main scene camera</span>
 <span class="s0">*/ 1 13 main_cam_node 1 288  </span>
<span class="s0">51 0 0 15 74 290 158 0 0 1 6 param0 0 291  </span>
<span class="s0">52 0 0 4 76 245 0 0 505 /**</span>
 <span class="s0">* @brief Applies a given state for a pass to a NodePath</span>
 <span class="s0">* @details This applies a shader to the given NodePath which is used when the</span>
 <span class="s0">*   NodePath is rendered by any registered camera for that pass.</span>
 <span class="s0">*   It also disables color write depending on the pass.</span>
 <span class="s0">*</span>
 <span class="s0">* @param np The nodepath to apply the shader to</span>
 <span class="s0">* @param shader A handle to the shader to apply</span>
 <span class="s0">* @param name Name of the state, should be a unique identifier</span>
 <span class="s0">* @param sort Determines the sort with which the shader will be applied.</span>
 <span class="s0">*/ 6 4 this 3 290  5 state 1 293  2 np 1 288  6 shader 1 294  4 name 1 293  4 sort 1 232  </span>
<span class="s0">53 0 0 4 77 245 0 0 232 /**</span>
 <span class="s0">* @brief Cleans up all registered states.</span>
 <span class="s0">* @details This cleans up all states which were registered to the TagStateManager.</span>
 <span class="s0">*   It also calls Camera::clear_tag_states() on the main_cam_node and all attached</span>
 <span class="s0">*   cameras.</span>
 <span class="s0">*/ 1 4 this 3 290  </span>
<span class="s0">54 0 0 4 78 245 0 0 497 /**</span>
 <span class="s0">* @brief Registers a new camera which renders a certain pass</span>
 <span class="s0">* @details This registers a new camera which will be used to render the given</span>
 <span class="s0">*   pass. The TagStateManager will keep track of the camera and</span>
 <span class="s0">*   applies all registered states onto the camera with Camera::set_tag_state.</span>
 <span class="s0">*   It also applies the appropriate camera mask to the camera,</span>
 <span class="s0">*   and sets an initial state to disable color write depending on the pass.</span>
 <span class="s0">*</span>
 <span class="s0">* @param source Camera which will be used to render shadows</span>
 <span class="s0">*/ 3 4 this 3 290  5 state 1 293  6 source 1 296  </span>
<span class="s0">55 0 0 4 79 245 0 0 261 /**</span>
 <span class="s0">* @brief Unregisters a camera from the list of shadow cameras</span>
 <span class="s0">* @details This unregisters a camera from the list of shadows cameras. It also</span>
 <span class="s0">*   resets all tag states of the camera, and also its initial state.</span>
 <span class="s0">*</span>
 <span class="s0">* @param source Camera to unregister</span>
 <span class="s0">*/ 3 4 this 3 290  5 state 1 293  6 source 1 296  </span>
<span class="s0">56 0 0 7 80 300 0 0 280 /**</span>
 <span class="s0">* @brief Returns the render mask for the given state</span>
 <span class="s0">* @details This returns the mask of a given render pass, which can be used</span>
 <span class="s0">*   to either show or hide objects from this pass.</span>
 <span class="s0">*</span>
 <span class="s0">* @param container_name Name of the render-pass</span>
 <span class="s0">* @return Bit mask of the render pass</span>
 <span class="s0">*/ 2 4 this 3 290  14 container_name 1 293  </span>
<span class="s0">57 0 0 7 82 238 0 0 348 /**</span>
 <span class="s0">* @brief Constructs a new shadow atlas</span>
 <span class="s0">* @details This constructs a new shadow atlas. There are a set of properties</span>
 <span class="s0">*   which should be set before calling ShadowManager::init, see the set-Methods.</span>
 <span class="s0">*   After all properties are set, ShadowManager::init should get called.</span>
 <span class="s0">*   ShadowManager::update should get called on a per frame basis.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">58 0 0 15 82 238 0 0 0 1 6 param0 0 301  </span>
<span class="s0">59 0 0 4 83 245 0 0 1064 /**</span>
 <span class="s0">* @brief Sets the maximum amount of updates per frame.</span>
 <span class="s0">* @details This controls the maximum amount of updated ShadowSources per frame.</span>
 <span class="s0">*   The ShadowManager will take the first &lt;max_updates&gt; ShadowSources, and</span>
 <span class="s0">*   generate shadow maps for them every frame. If there are more ShadowSources</span>
 <span class="s0">*   waiting to get updated than available updates, the sources are sorted by</span>
 <span class="s0">*   priority, and the update of the less important sources is delayed to the</span>
 <span class="s0">*   next frame.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the update count is set too low, and there are a lot of ShadowSources</span>
 <span class="s0">*   waiting to get updated, artifacts will occur, and there might be ShadowSources</span>
 <span class="s0">*   which never get updated, due to low priority.</span>
 <span class="s0">*</span>
 <span class="s0">*   If an update count of 0 is passed, no updates will happen. This also means</span>
 <span class="s0">*   that there are no shadows. This is not recommended.</span>
 <span class="s0">*</span>
 <span class="s0">*   If an update count &lt; 0 is passed, undefined behaviour occurs.</span>
 <span class="s0">*</span>
 <span class="s0">*   This method has to get called before ShadowManager::init, otherwise an</span>
 <span class="s0">*   assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param max_updates Maximum amoumt of updates</span>
 <span class="s0">*/ 2 4 this 3 238  11 max_updates 1 221  </span>
<span class="s0">60 0 0 4 84 245 0 0 467 /**</span>
 <span class="s0">* @brief Sets the target scene</span>
 <span class="s0">* @details This sets the target scene for rendering shadows. All shadow cameras</span>
 <span class="s0">*   will be parented to this scene to render shadows.</span>
 <span class="s0">*</span>
 <span class="s0">*   Usually the scene will be ShowBase.render. If the scene is an empty or</span>
 <span class="s0">*   invalid NodePath, an assertion will be triggered.</span>
 <span class="s0">*</span>
 <span class="s0">*   This method has to get called before calling ShadowManager::init, or an</span>
 <span class="s0">*   assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param scene_parent The target scene</span>
 <span class="s0">*/ 2 4 this 3 238  12 scene_parent 1 288  </span>
<span class="s0">61 0 0 4 85 245 0 0 328 /**</span>
 <span class="s0">* @brief Sets the handle to the TagStageManager.</span>
 <span class="s0">* @details This sets the handle to the TagStateManager used by the pipeline.</span>
 <span class="s0">*   Usually this is RenderPipeline.get_tag_mgr().</span>
 <span class="s0">*</span>
 <span class="s0">*   This has to get called before ShadowManager::init, otherwise an assertion</span>
 <span class="s0">*   will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param tag_mgr [description]</span>
 <span class="s0">*/ 2 4 this 3 238  7 tag_mgr 1 290  </span>
<span class="s0">62 0 0 4 86 245 0 0 525 /**</span>
 <span class="s0">* @brief Sets the handle to the Shadow targets output</span>
 <span class="s0">* @details This sets the handle to the GraphicsOutput of the shadow atlas.</span>
 <span class="s0">*   Usually this is RenderTarget.get_internal_buffer(), whereas the RenderTarget</span>
 <span class="s0">*   is the target of the ShadowStage.</span>
 <span class="s0">*</span>
 <span class="s0">*   This is used for creating display regions and attaching cameras to them,</span>
 <span class="s0">*   for performing shadow updates.</span>
 <span class="s0">*</span>
 <span class="s0">*   This has to get called before ShadowManager::init, otherwise an assertion</span>
 <span class="s0">*   will be triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param graphics_output [description]</span>
 <span class="s0">*/ 2 4 this 3 238  15 graphics_output 1 303  </span>
<span class="s0">63 0 0 4 87 245 0 0 477 /**</span>
 <span class="s0">* @brief Sets the shadow atlas size</span>
 <span class="s0">* @details This sets the desired shadow atlas size. It should be big enough</span>
 <span class="s0">*   to store all important shadow sources, with some buffer, because the shadow</span>
 <span class="s0">*   maps usually won't be fitted perfectly, so gaps can occur.</span>
 <span class="s0">*</span>
 <span class="s0">*   This has to get called before calling ShadowManager::init. When calling this</span>
 <span class="s0">*   method after initialization, an assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param atlas_size Size of the shadow atlas in pixels</span>
 <span class="s0">*/ 2 4 this 3 238  10 atlas_size 1 221  </span>
<span class="s0">64 0 0 6 88 221 0 0 190 /**</span>
 <span class="s0">* @brief Returns the shadow atlas size.</span>
 <span class="s0">* @details This returns the shadow atlas size previously set with</span>
 <span class="s0">*   ShadowManager::set_atlas_size.</span>
 <span class="s0">* @return Shadow atlas size in pixels</span>
 <span class="s0">*/ 1 4 this 3 301  </span>
<span class="s0">65 0 0 6 90 221 0 0 274 /**</span>
 <span class="s0">* @brief Returns how many update slots are left.</span>
 <span class="s0">* @details This returns how many update slots are left. You can assume the</span>
 <span class="s0">*   next n calls to add_update will succeed, whereas n is the value returned</span>
 <span class="s0">*   by this function.</span>
 <span class="s0">* @return Number of update slots left.</span>
 <span class="s0">*/ 1 4 this 3 301  </span>
<span class="s0">66 0 0 6 92 236 0 0 309 /**</span>
 <span class="s0">* @brief Returns a handle to the shadow atlas.</span>
 <span class="s0">* @details This returns a handle to the internal shadow atlas instance. This</span>
 <span class="s0">*   is only valid after calling ShadowManager::init. Calling this earlier will</span>
 <span class="s0">*   trigger an assertion and undefined behaviour.</span>
 <span class="s0">* @return The internal ShadowAtlas instance</span>
 <span class="s0">*/ 1 4 this 3 301  </span>
<span class="s0">67 0 0 4 95 245 0 0 396 /**</span>
 <span class="s0">* @brief Initializes the ShadowManager.</span>
 <span class="s0">* @details This initializes the ShadowManager. All properties should have</span>
 <span class="s0">*   been set before calling this, otherwise assertions will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">*   This setups everything required for rendering shadows, including the</span>
 <span class="s0">*   shadow atlas and the various shadow cameras. After calling this method,</span>
 <span class="s0">*   no properties can be changed anymore.</span>
 <span class="s0">*/ 1 4 this 3 238  </span>
<span class="s0">68 0 0 4 96 245 0 0 398 /**</span>
 <span class="s0">* @brief Updates the ShadowManager</span>
 <span class="s0">* @details This updates the ShadowManager, processing all shadow sources which</span>
 <span class="s0">*   need to get updated.</span>
 <span class="s0">*</span>
 <span class="s0">*   This first collects all sources which require an update, sorts them by priority,</span>
 <span class="s0">*   and then processes the first &lt;max_updates&gt; ShadowSources.</span>
 <span class="s0">*</span>
 <span class="s0">*   This may not get called before ShadowManager::init, or an assertion will be</span>
 <span class="s0">*   thrown.</span>
 <span class="s0">*/ 1 4 this 3 238  </span>
<span class="s0">69 0 0 7 98 305 187 0 242 /**</span>
 <span class="s0">* @brief Constructs the light manager</span>
 <span class="s0">* @details This constructs the light manager, initializing the light and shadow</span>
 <span class="s0">*   storage. You should set a command list and shadow manager before calling</span>
 <span class="s0">*   InternalLightManager::update. s</span>
 <span class="s0">*/ 0 </span>
<span class="s0">70 0 0 15 98 305 187 0 0 1 6 param0 0 306  </span>
<span class="s0">71 0 0 4 99 245 0 0 817 /**</span>
 <span class="s0">* @brief Adds a new light.</span>
 <span class="s0">* @details This adds a new light to the list of lights. This will throw an</span>
 <span class="s0">*   error and return if the light is already attached. You may only call</span>
 <span class="s0">*   this after the ShadowManager was already set.</span>
 <span class="s0">*</span>
 <span class="s0">*   While the light is attached, the light manager keeps a reference to it, so</span>
 <span class="s0">*   the light does not get destructed.</span>
 <span class="s0">*</span>
 <span class="s0">*   This also setups the shadows on the light, in case shadows are enabled.</span>
 <span class="s0">*   While a light is attached, you can not change whether it casts shadows or not.</span>
 <span class="s0">*   To do so, detach the light, change the setting, and re-add the light.</span>
 <span class="s0">*</span>
 <span class="s0">*   In case no free light slot is available, an error will be printed and no</span>
 <span class="s0">*   action will be performed.</span>
 <span class="s0">*</span>
 <span class="s0">*   If no shadow manager was set, an assertion will be triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param light The light to add.</span>
 <span class="s0">*/ 2 4 this 3 305  5 light 1 283  </span>
<span class="s0">72 0 0 4 100 245 0 0 763 /**</span>
 <span class="s0">* @brief Removes a light</span>
 <span class="s0">* @details This detaches a light. This prevents it from being rendered, and also</span>
 <span class="s0">*   cleans up all resources used by that light. If no reference is kept on the</span>
 <span class="s0">*   python side, the light will also get destructed.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the light was not previously attached with InternalLightManager::add_light,</span>
 <span class="s0">*   an error will be triggered and nothing happens.</span>
 <span class="s0">*</span>
 <span class="s0">*   In case the light was set to cast shadows, all shadow sources are cleaned</span>
 <span class="s0">*   up, and their regions in the shadow atlas are freed.</span>
 <span class="s0">*</span>
 <span class="s0">*   All resources used by the light in the light and shadow storage are also</span>
 <span class="s0">*   cleaned up, by emitting cleanup GPUCommands.</span>
 <span class="s0">*</span>
 <span class="s0">*   If no shadow manager was set, an assertion will be triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param light [description]</span>
 <span class="s0">*/ 2 4 this 3 305  5 light 1 283  </span>
<span class="s0">73 0 0 4 101 245 0 0 336 /**</span>
 <span class="s0">* @brief Main update method</span>
 <span class="s0">* @details This is the main update method of the InternalLightManager. It</span>
 <span class="s0">*   processes all lights and shadow sources, updates them, and notifies the</span>
 <span class="s0">*   GPU about it. This should be called on a per-frame basis.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the InternalLightManager was not initialized yet, an assertion is thrown.</span>
 <span class="s0">*/ 1 4 this 3 305  </span>
<span class="s0">74 0 0 4 102 245 0 0 200 /**</span>
 <span class="s0">* @brief Sets the camera position</span>
 <span class="s0">* @details This sets the camera position, which will be used to determine which</span>
 <span class="s0">*   shadow sources have to get updated</span>
 <span class="s0">*</span>
 <span class="s0">* @param mat View projection mat</span>
 <span class="s0">*/ 2 4 this 3 305  3 pos 1 308  </span>
<span class="s0">75 0 0 4 103 245 0 0 309 /**</span>
 <span class="s0">* @brief Sets the maximum shadow update distance</span>
 <span class="s0">* @details This controls the maximum distance until which shadows are updated.</span>
 <span class="s0">*   If a shadow source is past that distance, it is ignored and no longer recieves</span>
 <span class="s0">*   updates until it is in range again</span>
 <span class="s0">*</span>
 <span class="s0">* @param dist Distance in world space units</span>
 <span class="s0">*/ 2 4 this 3 305  4 dist 1 312  </span>
<span class="s0">76 0 0 6 104 232 0 0 870 /**</span>
 <span class="s0">* @brief Returns the maximum light index</span>
 <span class="s0">* @details This returns the maximum light index (also called slot). Any lights</span>
 <span class="s0">*   after that slot are guaranteed to be zero-lights. This is useful when</span>
 <span class="s0">*   iterating over the list of lights, because iteration can be stopped when</span>
 <span class="s0">*   the maximum light index is reached.</span>
 <span class="s0">*</span>
 <span class="s0">*   The maximum light index points to the last slot which is used. If no lights</span>
 <span class="s0">*   are attached, -1 is returned. If one light is attached at slot 0, the index</span>
 <span class="s0">*   is 0, if two are attached at the slots 0 and 1, the index is 1, and so on.</span>
 <span class="s0">*</span>
 <span class="s0">*   If, for example, two lights are attached at the slots 2 and 5, then the</span>
 <span class="s0">*   index will be 5. Keep in mind that the max-index is not an indicator for</span>
 <span class="s0">*   how many lights are attached. Also, zero lights still may occur when iterating</span>
 <span class="s0">*   over the light lists</span>
 <span class="s0">*</span>
 <span class="s0">* @return Maximum light index</span>
 <span class="s0">*/ 1 4 this 3 306  </span>
<span class="s0">77 0 0 6 106 221 0 0 325 /**</span>
 <span class="s0">* @brief Returns the amount of stored lights.</span>
 <span class="s0">* @details This returns the amount of stored lights. This behaves unlike</span>
 <span class="s0">*   InternalLightManager::get_max_light_index, and instead returns the true</span>
 <span class="s0">*   amount of lights, which is completely unrelated to the amount of used slots.</span>
 <span class="s0">*</span>
 <span class="s0">* @return Amount of stored lights</span>
 <span class="s0">*/ 1 4 this 3 306  </span>
<span class="s0">78 0 0 6 108 221 0 0 293 /**</span>
 <span class="s0">* @brief Returns the amount of shadow sources.</span>
 <span class="s0">* @details This returns the total amount of stored shadow sources. This does</span>
 <span class="s0">*   not denote the amount of updated sources, but instead takes into account</span>
 <span class="s0">*   all sources, even those out of frustum.</span>
 <span class="s0">* @return Amount of shadow sources.</span>
 <span class="s0">*/ 1 4 this 3 306  </span>
<span class="s0">79 0 0 4 110 245 0 0 623 /**</span>
 <span class="s0">* @brief Sets the handle to the shadow manager</span>
 <span class="s0">* @details This sets the handle to the global shadow manager. It is usually</span>
 <span class="s0">*   constructed on the python side, so we need to get a handle to it.</span>
 <span class="s0">*</span>
 <span class="s0">*   The manager should be a handle to a ShadowManager instance, and will be</span>
 <span class="s0">*   stored somewhere on the python side most likely. The light manager does not</span>
 <span class="s0">*   keep a reference to it, so the python side should make sure to keep one.</span>
 <span class="s0">*</span>
 <span class="s0">*   Be sure to call this before the InternalLightManager::update() method is</span>
 <span class="s0">*   called, otherwise an assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param mgr The ShadowManager instance</span>
 <span class="s0">*/ 2 4 this 3 305  3 mgr 1 238  </span>
<span class="s0">80 0 0 7 111 238 0 0 155 /**</span>
 <span class="s0">* @brief Returns the internal used ShadowManager</span>
 <span class="s0">* @details This returns a handle to the internally used shadow manager</span>
 <span class="s0">* @return Shadow manager</span>
 <span class="s0">*/ 1 4 this 3 306  </span>
<span class="s0">81 0 0 4 114 245 0 0 671 /**</span>
 <span class="s0">* @brief Sets a handle to the command list</span>
 <span class="s0">* @details This sets a handle to the global GPUCommandList. This is required to</span>
 <span class="s0">*   emit GPUCommands, which are used for attaching and detaching lights, as well</span>
 <span class="s0">*   as shadow source updates.</span>
 <span class="s0">*</span>
 <span class="s0">*   The cmd_list should be a handle to a GPUCommandList handle, and will be</span>
 <span class="s0">*   stored somewhere on the python side most likely. The light manager does not</span>
 <span class="s0">*   keep a reference to it, so the python side should make sure to keep one.</span>
 <span class="s0">*</span>
 <span class="s0">*   Be sure to call this before the InternalLightManager::update() method is</span>
 <span class="s0">*   called, otherwise an assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param cmd_list The GPUCommandList instance</span>
 <span class="s0">*/ 2 4 this 3 305  8 cmd_list 1 271  </span>
<span class="s0">82 0 0 7 117 313 193 0 255 /**</span>
 <span class="s0">* @brief Constructs a new point light</span>
 <span class="s0">* @details This contructs a new point light with default settings. By default</span>
 <span class="s0">*   the light is set to be an infinitely small point light source. You can</span>
 <span class="s0">*   change this with RPPointLight::set_inner_radius.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">83 0 0 4 118 245 0 0 257 /**</span>
 <span class="s0">* @brief Sets the radius of the light</span>
 <span class="s0">* @details This sets the radius of the light. It controls the lights</span>
 <span class="s0">*   influence. After a distance greater than this radius, the light influence</span>
 <span class="s0">*   is zero.</span>
 <span class="s0">*</span>
 <span class="s0">* @param radius Light radius in world space</span>
 <span class="s0">*/ 2 4 this 3 313  6 radius 1 230  </span>
<span class="s0">84 0 0 6 119 230 0 0 175 /**</span>
 <span class="s0">* @brief Returns the lights radius</span>
 <span class="s0">* @details This returns the lights radius previously set with</span>
 <span class="s0">*   RPPointLight::set_radius</span>
 <span class="s0">* @return Light radius in world space</span>
 <span class="s0">*/ 1 4 this 3 314  </span>
<span class="s0">85 0 0 4 121 245 0 0 725 /**</span>
 <span class="s0">* @brief Sets the inner radius of the light</span>
 <span class="s0">* @details This sets the inner radius of the light. Anything greater than</span>
 <span class="s0">*   zero causes the light to get an area light. This has influence on the</span>
 <span class="s0">*   specular highlights of the light aswell as the shadows.</span>
 <span class="s0">*</span>
 <span class="s0">*   The inner radius controls the size of the lights sphere size in world</span>
 <span class="s0">*   space units. A radius of 0 means the light has no inner radius, and the</span>
 <span class="s0">*   light will be have like an infinite small point light source.</span>
 <span class="s0">*   A radius greater than zero will cause the light to behave like it would be</span>
 <span class="s0">*   an emissive sphere with the given inner radius emitting light. This is</span>
 <span class="s0">*   more physically correct.</span>
 <span class="s0">*</span>
 <span class="s0">* @param inner_radius Inner-radius in world space</span>
 <span class="s0">*/ 2 4 this 3 313  12 inner_radius 1 230  </span>
<span class="s0">86 0 0 6 122 230 0 0 193 /**</span>
 <span class="s0">* @brief Returns the inner radius of the light</span>
 <span class="s0">* @details This returns the inner radius of the light, previously set with</span>
 <span class="s0">*   RPPointLight::get_inner_radius.</span>
 <span class="s0">* @return [description]</span>
 <span class="s0">*/ 1 4 this 3 314  </span>
<span class="s0">87 0 0 15 126 318 195 0 0 1 6 param0 0 316  </span>
<span class="s0">88 0 0 23 126 318 195 0 320 /**</span>
 <span class="s0">* @brief Constructs a new PSSM camera rig</span>
 <span class="s0">* @details This constructs a new camera rig, with a given amount of splits.</span>
 <span class="s0">*   The splits can not be changed later on. Splits are also called Cascades.</span>
 <span class="s0">*</span>
 <span class="s0">*   An assertion will be triggered if the splits are below zero.</span>
 <span class="s0">*</span>
 <span class="s0">* @param num_splits Amount of PSSM splits</span>
 <span class="s0">*/ 1 10 num_splits 1 221  </span>
<span class="s0">89 0 0 4 128 245 0 0 316 /**</span>
 <span class="s0">* @brief Sets the maximum pssm distance.</span>
 <span class="s0">* @details This sets the maximum distance in world space until which shadows</span>
 <span class="s0">*   are rendered. After this distance, no shadows will be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the distance is below zero, an assertion is triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param distance Maximum distance in world space</span>
 <span class="s0">*/ 2 4 this 3 318  8 distance 1 230  </span>
<span class="s0">90 0 0 4 129 245 0 0 664 /**</span>
 <span class="s0">* @brief Sets the suns distance</span>
 <span class="s0">* @details This sets the distance the cameras will have from the cameras frustum.</span>
 <span class="s0">*   This prevents far objects from having no shadows, which can occur when these</span>
 <span class="s0">*   objects are between the cameras frustum and the sun, but not inside of the</span>
 <span class="s0">*   cameras frustum. Setting the sun distance high enough will move the cameras</span>
 <span class="s0">*   away from the camera frustum, being able to cover those distant objects too.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the sun distance is set too high, artifacts will occur due to the reduced</span>
 <span class="s0">*   range of depth. If a value below zero is passed, an assertion will get</span>
 <span class="s0">*   triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param distance The sun distance</span>
 <span class="s0">*/ 2 4 this 3 318  8 distance 1 230  </span>
<span class="s0">91 0 0 4 130 245 0 0 566 /**</span>
 <span class="s0">* @brief Sets whether to use a fixed film size</span>
 <span class="s0">* @details This controls if a fixed film size should be used. This will cause</span>
 <span class="s0">*   the camera rig to cache the current film size, and only change it in case</span>
 <span class="s0">*   it gets too small. This provides less flickering when moving, because the</span>
 <span class="s0">*   film size will stay roughly constant. However, to prevent the cached film</span>
 <span class="s0">*   size getting too big, one should call PSSMCameraRig::reset_film_size</span>
 <span class="s0">*   once in a while, otherwise there might be a lot of wasted space.</span>
 <span class="s0">*</span>
 <span class="s0">* @param flag Whether to use a fixed film size</span>
 <span class="s0">*/ 2 4 this 3 318  4 flag 1 231  </span>
<span class="s0">92 0 0 4 131 245 0 0 432 /**</span>
 <span class="s0">* @brief Sets the resolution of each split</span>
 <span class="s0">* @details This sets the resolution of each split. Currently it is equal for</span>
 <span class="s0">*   each split. This is required when using PSSMCameraRig::set_use_stable_csm,</span>
 <span class="s0">*   to compute how bix a texel is.</span>
 <span class="s0">*</span>
 <span class="s0">*   It has to match the y-resolution of the pssm shadow map. If an invalid</span>
 <span class="s0">*   resolution is triggered, an assertion is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* @param resolution The resolution of each split.</span>
 <span class="s0">*/ 2 4 this 3 318  10 resolution 1 221  </span>
<span class="s0">93 0 0 4 132 245 0 0 403 /**</span>
 <span class="s0">* @brief Sets whether to use stable CSM snapping.</span>
 <span class="s0">* @details This option controls if stable CSM snapping should be used. When the</span>
 <span class="s0">*   option is enabled, all splits will snap to their texels, so that when moving,</span>
 <span class="s0">*   no flickering will occur. However, this only works when the splits do not</span>
 <span class="s0">*   change their film size, rotation and angle.</span>
 <span class="s0">*</span>
 <span class="s0">* @param flag Whether to use stable CSM snapping</span>
 <span class="s0">*/ 2 4 this 3 318  4 flag 1 231  </span>
<span class="s0">94 0 0 4 133 245 0 0 775 /**</span>
 <span class="s0">* @brief Sets the logarithmic factor</span>
 <span class="s0">* @details This sets the logarithmic factor, which is the core of the algorithm.</span>
 <span class="s0">*   PSSM splits the camera frustum based on a linear and a logarithmic factor.</span>
 <span class="s0">*   While a linear factor provides a good distribution, it often is not applicable</span>
 <span class="s0">*   for wider distances. A logarithmic distribution provides a better distribution</span>
 <span class="s0">*   at distance, but suffers from splitting in the near areas.</span>
 <span class="s0">*</span>
 <span class="s0">*   The logarithmic factor mixes the logarithmic and linear split distribution,</span>
 <span class="s0">*   to get the best of both. A greater factor will make the distribution more</span>
 <span class="s0">*   logarithmic, while a smaller factor will make it more linear.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the factor is below zero, an ssertion is triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param factor The logarithmic factor</span>
 <span class="s0">*/ 2 4 this 3 318  6 factor 1 230  </span>
<span class="s0">95 0 0 4 134 245 0 0 482 /**</span>
 <span class="s0">* @brief Sets the border bias for each split</span>
 <span class="s0">* @details This sets the border bias for every split. This increases each</span>
 <span class="s0">*   splits frustum by multiplying it by (1 + bias), and helps reducing artifacts</span>
 <span class="s0">*   at the borders of the splits. Artifacts can occur when the bias is too low,</span>
 <span class="s0">*   because then the filtering will go over the bounds of the split, producing</span>
 <span class="s0">*   invalid results.</span>
 <span class="s0">*</span>
 <span class="s0">*   If the bias is below zero, an assertion is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* @param bias Border bias</span>
 <span class="s0">*/ 2 4 this 3 318  4 bias 1 230  </span>
<span class="s0">96 0 0 4 135 245 0 0 493 /**</span>
 <span class="s0">* @brief Updates the PSSM camera rig</span>
 <span class="s0">* @details This updates the rig with an updated camera position, and a given</span>
 <span class="s0">*   light vector. This should be called on a per-frame basis. It will reposition</span>
 <span class="s0">*   all camera sources to fit the frustum based on the pssm distribution.</span>
 <span class="s0">*</span>
 <span class="s0">*   The light vector should be the vector from the light source, not the</span>
 <span class="s0">*   vector to the light source.</span>
 <span class="s0">*</span>
 <span class="s0">* @param cam_node Target camera node</span>
 <span class="s0">* @param light_vector The vector from the light to any point</span>
 <span class="s0">*/ 3 4 this 3 318  8 cam_node 1 288  12 light_vector 1 246  </span>
<span class="s0">97 0 0 4 136 245 0 0 719 /**</span>
 <span class="s0">* @brief Resets the film size cache</span>
 <span class="s0">* @details In case PSSMCameraRig::set_use_fixed_film_size is used, this resets</span>
 <span class="s0">*   the film size cache. This might lead to a small &quot;jump&quot; in the shadows,</span>
 <span class="s0">*   because the film size changes, however it leads to a better shadow distribution.</span>
 <span class="s0">*</span>
 <span class="s0">*   This is the case because when using a fixed film size, the cache will get</span>
 <span class="s0">*   bigger and bigger, whenever the camera moves to a grazing angle. However,</span>
 <span class="s0">*   when moving back to a normal angle, the film size cache still stores this</span>
 <span class="s0">*   big angle, and thus the splits will have a much bigger film size than actualy</span>
 <span class="s0">*   required. To prevent this, call this method once in a while, so an optimal</span>
 <span class="s0">*   distribution is ensured.</span>
 <span class="s0">*/ 1 4 this 3 318  </span>
<span class="s0">98 0 0 7 137 288 0 0 593 /**</span>
 <span class="s0">* @brief Returns the n-th camera</span>
 <span class="s0">* @details This returns the n-th camera of the camera rig, which can be used</span>
 <span class="s0">*   for various stuff like showing its frustum, passing it as a shader input,</span>
 <span class="s0">*   and so on.</span>
 <span class="s0">*</span>
 <span class="s0">*   The first camera is the camera which is the camera of the first split,</span>
 <span class="s0">*   which is the split closest to the camera. All cameras follow in descending</span>
 <span class="s0">*   order until to the last camera, which is the split furthest away from the</span>
 <span class="s0">*   camera.</span>
 <span class="s0">*</span>
 <span class="s0">*   If an invalid index is passed, an assertion is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* @param index Index of the camera.</span>
 <span class="s0">* @return [description]</span>
 <span class="s0">*/ 2 4 this 3 318  5 index 1 221  </span>
<span class="s0">99 0 0 4 138 245 0 0 342 /**</span>
 <span class="s0">* @brief Reparents the camera rig</span>
 <span class="s0">* @details This reparents all cameras to the given parent. Usually the parent</span>
 <span class="s0">*   will be ShowBase.render. The parent should be the same node where the</span>
 <span class="s0">*   main camera is located in, too.</span>
 <span class="s0">*</span>
 <span class="s0">*   If an empty parrent is passed, an assertion will get triggered.</span>
 <span class="s0">*</span>
 <span class="s0">* @param parent Parent node path</span>
 <span class="s0">*/ 2 4 this 3 318  6 parent 1 288  </span>
<span class="s0">100 0 0 6 139 319 0 0 315 /**</span>
 <span class="s0">* @brief Returns a handle to the MVP array</span>
 <span class="s0">* @details This returns a handle to the array of view-projection matrices</span>
 <span class="s0">*   of the different splits. This can be used for computing shadows. The array</span>
 <span class="s0">*   is a PTALMatrix4 and thus can be directly bound to a shader.</span>
 <span class="s0">*</span>
 <span class="s0">* @return view-projection matrix array</span>
 <span class="s0">*/ 1 4 this 3 318  </span>
<span class="s0">101 0 0 6 140 324 0 0 508 /**</span>
 <span class="s0">* @brief Returns a handle to the near and far planes array</span>
 <span class="s0">* @details This returns a handle to the near and far plane array. Each split</span>
 <span class="s0">*   has an entry in the array, whereas the x component of the vecto denotes the</span>
 <span class="s0">*   near plane, and the y component denotes the far plane of the split.</span>
 <span class="s0">*</span>
 <span class="s0">*   This is required because the near and far planes of the splits change</span>
 <span class="s0">*   constantly. To access them in a shader, the shader needs access to the</span>
 <span class="s0">*   array.</span>
 <span class="s0">*</span>
 <span class="s0">* @return Array of near and far planes</span>
 <span class="s0">*/ 1 4 this 3 318  </span>
<span class="s0">102 0 0 7 142 329 217 0 206 /**</span>
 <span class="s0">* @brief Creates a new spot light</span>
 <span class="s0">* @details This creates a new spot light with default properties set. You should</span>
 <span class="s0">*   set at least a direction, fov, radius and position to make the light useful.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">103 0 0 4 143 245 0 0 0 2 4 this 3 329  6 radius 1 230  </span>
<span class="s0">104 0 0 6 144 230 0 0 0 1 4 this 3 330  </span>
<span class="s0">105 0 0 4 146 245 0 0 0 2 4 this 3 329  3 fov 1 230  </span>
<span class="s0">106 0 0 6 147 230 0 0 0 1 4 this 3 330  </span>
<span class="s0">107 0 0 4 149 245 0 0 0 2 4 this 3 329  9 direction 1 332  </span>
<span class="s0">108 0 0 4 149 245 0 0 0 4 4 this 3 329  2 dx 1 230  2 dy 1 230  2 dz 1 230  </span>
<span class="s0">109 0 0 6 150 246 0 0 0 1 4 this 3 330  </span>
<span class="s0">110 0 0 4 151 245 0 0 0 2 4 this 3 329  5 point 1 332  </span>
<span class="s0">111 0 0 4 151 245 0 0 0 4 4 this 3 329  1 x 1 230  1 y 1 230  1 z 1 230  </span>
<span class="s0">115</span>
<span class="s0">218 10 GPUCommand 0 141313 10 GPUCommand 10 GPUCommand 0 0 0 1 112 122 0 9 113 114 115 116 117 118 119 120 121 0 0 0 0 1 219 303</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Class for storing data to be transferred to the GPU.</span>
 <span class="s0">* @details This class can be seen like a packet, to be transferred to the GPU.</span>
 <span class="s0">*   It has a command type, which tells the GPU what to do once it recieved this</span>
 <span class="s0">*   &quot;packet&quot;. It stores a limited amount of floating point components.</span>
 <span class="s0">*/</span>

<span class="s0">219 11 CommandType 0 794624 23 GPUCommand::CommandType 23 GPUCommand::CommandType 218 0 0 0 0 0 0 0 0 0 5 11 CMD_invalid 23 GPUCommand::CMD_invalid 0</span>
<span class="s0">0 15 CMD_store_light 27 GPUCommand::CMD_store_light 0</span>
<span class="s0">1 16 CMD_remove_light 28 GPUCommand::CMD_remove_light 0</span>
<span class="s0">2 16 CMD_store_source 28 GPUCommand::CMD_store_source 0</span>
<span class="s0">3 18 CMD_remove_sources 30 GPUCommand::CMD_remove_sources 0</span>
<span class="s0">4 0 197</span>
<span class="s0">/**</span>
   <span class="s0">* The different types of GPUCommands. Each type has a special case in</span>
   <span class="s0">* the command queue processor. When adding new types, those need to</span>
   <span class="s0">* be handled in the command target, too.</span>
   <span class="s0">*/</span>

<span class="s0">220 14 GPUCommandList 0 141313 14 GPUCommandList 14 GPUCommandList 0 0 0 1 123 127 1 333 3 124 125 126 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Class to store a list of commands.</span>
 <span class="s0">* @details This is a class to store a list of GPUCommands. It provides</span>
 <span class="s0">*   functionality to only provide the a given amount of commands at one time.</span>
 <span class="s0">*/</span>

<span class="s0">221 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 222 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">222 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">223 10 IESDataset 0 141313 10 IESDataset 10 IESDataset 0 0 0 1 128 133 0 4 129 130 131 132 0 0 0 0 0 347</span>
<span class="s0">/**</span>
 <span class="s0">* @brief This class generates a LUT from IES data.</span>
 <span class="s0">* @details This class is used by the IESLoader to generate a LUT texture which</span>
 <span class="s0">*   is used in the shaders to perform IES lighting. It takes a set of vertical</span>
 <span class="s0">*   and horizontal angles, as well as a set of candela values, which then are</span>
 <span class="s0">*   lineary interpolated onto a 2D LUT Texture.</span>
 <span class="s0">*/</span>

<span class="s0">224 7 RPLight 0 75777 7 RPLight 7 RPLight 0 0 0 0 0 8 334 335 336 337 338 339 340 341 19 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 0 0 1 0 225 0 0 0 1 226 267</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Base class for Lights</span>
 <span class="s0">* @details This is the base class for all lights in the render pipeline. It</span>
 <span class="s0">*   stores common properties, and provides methods to modify these.</span>
 <span class="s0">*   It also defines some interface functions which subclasses have to implement.</span>
 <span class="s0">*/</span>

<span class="s0">225 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">226 9 LightType 0 794624 18 RPLight::LightType 18 RPLight::LightType 224 0 0 0 0 0 0 0 0 0 3 8 LT_empty 17 RPLight::LT_empty 0</span>
<span class="s0">0 14 LT_point_light 23 RPLight::LT_point_light 0</span>
<span class="s0">1 13 LT_spot_light 22 RPLight::LT_spot_light 0</span>
<span class="s0">2 0 40</span>
<span class="s0">/**</span>
   <span class="s0">* Different types of light.</span>
   <span class="s0">*/</span>

<span class="s0">227 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 228 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">228 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 229 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">229 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">230 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">231 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">232 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">233 11 ShadowAtlas 0 26625 11 ShadowAtlas 11 ShadowAtlas 0 0 0 1 153 154 2 342 343 2 155 156 0 0 0 0 0 189</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Class which manages distributing shadow maps in an atlas.</span>
 <span class="s0">* @details This class manages the shadow atlas. It handles finding and reserving</span>
 <span class="s0">*   space for new shadow maps.</span>
 <span class="s0">*/</span>

<span class="s0">234 15 TagStateManager 0 26625 15 TagStateManager 15 TagStateManager 0 0 0 1 157 158 0 5 159 160 161 162 163 0 0 0 0 0 455</span>
<span class="s0">/**</span>
 <span class="s0">* @brief This class handles all different tag states</span>
 <span class="s0">* @details The TagStateManager stores a list of RenderStates assigned to different</span>
 <span class="s0">*   steps in the pipeline. For example, there are a list of shadow states, which</span>
 <span class="s0">*   are applied whenever objects are rendered from a shadow camera.</span>
 <span class="s0">*</span>
 <span class="s0">*   The Manager also stores a list of all cameras used in the different stages,</span>
 <span class="s0">*   to keep track of the states used and to be able to attach new states.</span>
 <span class="s0">*/</span>

<span class="s0">235 13 ShadowManager 0 75777 13 ShadowManager 13 ShadowManager 0 0 0 1 164 0 3 344 345 346 10 165 166 167 168 169 170 171 172 173 174 0 0 1 0 225 0 0 0 0 0</span>

<span class="s0">236 13 ShadowAtlas * 0 8576 13 ShadowAtlas * 13 ShadowAtlas * 0 0 233 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">237 20 InternalLightManager 0 141313 20 InternalLightManager 20 InternalLightManager 0 0 0 1 175 187 4 347 348 349 350 11 176 177 178 179 180 181 182 183 184 185 186 0 0 0 0 0 359</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Internal class used for handling lights and shadows.</span>
 <span class="s0">* @details This is the internal class used by the pipeline to handle all</span>
 <span class="s0">*   lights and shadows. It stores references to the lights, manages handling</span>
 <span class="s0">*   the light and shadow slots, and also communicates with the GPU with the</span>
 <span class="s0">*   GPUCommandQueue to store light and shadow source data.</span>
 <span class="s0">*/</span>

<span class="s0">238 15 ShadowManager * 0 8576 15 ShadowManager * 15 ShadowManager * 0 0 235 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">239 12 RPPointLight 0 141313 12 RPPointLight 12 RPPointLight 0 0 0 1 188 193 2 351 352 4 189 190 191 192 0 0 1 0 224 0 0 0 0 217</span>
<span class="s0">/**</span>
 <span class="s0">* @brief PointLight class</span>
 <span class="s0">* @details This represents a point light, a light which has a position and</span>
 <span class="s0">*   radius. Checkout the RenderPipeline documentation for more information</span>
 <span class="s0">*   about this type of light.</span>
 <span class="s0">*/</span>

<span class="s0">240 13 PSSMCameraRig 0 26625 13 PSSMCameraRig 13 PSSMCameraRig 0 0 0 1 194 195 0 13 196 197 198 199 200 201 202 203 204 205 206 207 208 0 0 0 0 0 1005</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Main class used for handling PSSM</span>
 <span class="s0">* @details This is the main class for supporting PSSM, it is used by the PSSM</span>
 <span class="s0">*   plugin to compute the position of the splits.</span>
 <span class="s0">*</span>
 <span class="s0">*   It supports handling a varying amount of cameras, and fitting those cameras</span>
 <span class="s0">*   into the main camera frustum, to render distant shadows. It also supports</span>
 <span class="s0">*   various optimizations for fitting the frustum, e.g. rotating the sources</span>
 <span class="s0">*   to get a better coverage.</span>
 <span class="s0">*</span>
 <span class="s0">*   It also provides methods to get arrays of data about the used cameras</span>
 <span class="s0">*   view-projection matrices and their near and far plane, which is required for</span>
 <span class="s0">*   processing the data in the shadow sampling shader.</span>
 <span class="s0">*</span>
 <span class="s0">*   In this class, there is often referred to &quot;Splits&quot; or also called &quot;Cascades&quot;.</span>
 <span class="s0">*   These denote the different cameras which are used to split the frustum,</span>
 <span class="s0">*   and are a common term related to the PSSM algorithm.</span>
 <span class="s0">*</span>
 <span class="s0">*   To understand the functionality of this class, a detailed knowledge of the</span>
 <span class="s0">*   PSSM algorithm is helpful.</span>
 <span class="s0">*/</span>

<span class="s0">241 11 RPSpotLight 0 141313 11 RPSpotLight 11 RPSpotLight 0 0 0 1 209 217 3 353 354 355 7 210 211 212 213 214 215 216 0 0 1 0 224 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* @brief SpotLight class</span>
 <span class="s0">* @details This represents a spot light, a light which has a position, radius,</span>
 <span class="s0">*   direction and FoV. Checkout the RenderPipeline documentation for more</span>
 <span class="s0">*   information about this type of light.</span>
 <span class="s0">*/</span>

<span class="s0">242 18 GPUCommand const * 0 8576 18 GPUCommand const * 18 GPUCommand const * 0 0 243 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">243 16 GPUCommand const 0 8832 16 GPUCommand const 16 GPUCommand const 0 0 218 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">244 12 GPUCommand * 0 8576 12 GPUCommand * 12 GPUCommand * 0 0 218 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">245 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">246 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 227 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">247 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 248 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">248 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 249 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">249 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">250 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 251 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">251 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 252 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">252 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 253 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">253 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">254 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 255 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">255 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 256 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">256 10 LVecBase4i 0 2048 10 LVecBase4i 10 LVecBase4i 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">257 16 LMatrix3 const * 0 8576 16 LMatrix3 const * 16 LMatrix3 const * 0 0 258 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">258 14 LMatrix3 const 0 8832 14 LMatrix3 const 14 LMatrix3 const 0 0 259 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">259 8 LMatrix3 0 2105344 8 LMatrix3 8 LMatrix3 0 0 260 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">260 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 3-by-3 transform matrix.  It typically will represent either a</span>
 <span class="s0">* rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix</span>
 <span class="s0">* (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.</span>
 <span class="s0">*/</span>

<span class="s0">261 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 262 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">262 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 263 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">263 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 264 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">264 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">265 17 PTA_uchar const * 0 8576 17 PTA_uchar const * 17 PTA_uchar const * 0 0 266 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">266 15 PTA_uchar const 0 8832 15 PTA_uchar const 15 PTA_uchar const 0 0 267 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">267 9 PTA_uchar 0 2105344 9 PTA_uchar 9 PTA_uchar 0 0 268 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">268 31 PointerToArray&lt; unsigned char &gt; 0 2048 31 PointerToArray&lt; unsigned char &gt; 31 PointerToArray&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">269 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 270 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">270 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">271 16 GPUCommandList * 0 8576 16 GPUCommandList * 16 GPUCommandList * 0 0 220 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">272 22 GPUCommandList const * 0 8576 22 GPUCommandList const * 22 GPUCommandList const * 0 0 273 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">273 20 GPUCommandList const 0 8832 20 GPUCommandList const 20 GPUCommandList const 0 0 220 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">274 12 IESDataset * 0 8576 12 IESDataset * 12 IESDataset * 0 0 223 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">275 18 IESDataset const * 0 8576 18 IESDataset const * 18 IESDataset const * 0 0 276 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">276 16 IESDataset const 0 8832 16 IESDataset const 16 IESDataset const 0 0 223 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">277 17 PTA_float const * 0 8576 17 PTA_float const * 17 PTA_float const * 0 0 278 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">278 15 PTA_float const 0 8832 15 PTA_float const 15 PTA_float const 0 0 279 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">279 9 PTA_float 0 2105344 9 PTA_float 9 PTA_float 0 0 280 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">280 23 PointerToArray&lt; float &gt; 0 2048 23 PointerToArray&lt; float &gt; 23 PointerToArray&lt; float &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">281 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 282 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">282 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a texture object, which is typically a single 2-d image but may</span>
 <span class="s0">* also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube</span>
 <span class="s0">* map texture.</span>
 <span class="s0">*</span>
 <span class="s0">* A texture's image data might be stored in system RAM (see get_ram_image())</span>
 <span class="s0">* or its image may be represented in texture memory on one or more</span>
 <span class="s0">* GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern</span>
 <span class="s0">* is that a texture is loaded from an image file on disk, which copies its</span>
 <span class="s0">* image data into system RAM; then the first time the texture is rendered its</span>
 <span class="s0">* image data is copied to texture memory (actually, to the graphics API), and</span>
 <span class="s0">* the system RAM image is automatically freed.</span>
 <span class="s0">*/</span>

<span class="s0">283 9 RPLight * 0 8576 9 RPLight * 9 RPLight * 0 0 224 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">284 15 RPLight const * 0 8576 15 RPLight const * 15 RPLight const * 0 0 285 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">285 13 RPLight const 0 8832 13 RPLight const 13 RPLight const 0 0 224 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">286 19 ShadowAtlas const * 0 8576 19 ShadowAtlas const * 19 ShadowAtlas const * 0 0 287 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">287 17 ShadowAtlas const 0 8832 17 ShadowAtlas const 17 ShadowAtlas const 0 0 233 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">288 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 289 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">289 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">290 17 TagStateManager * 0 8576 17 TagStateManager * 17 TagStateManager * 0 0 234 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">291 23 TagStateManager const * 0 8576 23 TagStateManager const * 23 TagStateManager const * 0 0 292 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">292 21 TagStateManager const 0 8832 21 TagStateManager const 21 TagStateManager const 0 0 234 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">293 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">294 8 Shader * 0 8576 8 Shader * 8 Shader * 0 0 295 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">295 6 Shader 0 2048 6 Shader 6 Shader 0 0 0 0 0 0 0 0 0 0 0 0 8</span>
<span class="s0">/**</span>

 <span class="s0">*/</span>

<span class="s0">296 8 Camera * 0 8576 8 Camera * 8 Camera * 0 0 297 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">297 6 Camera 0 2048 6 Camera 6 Camera 0 0 0 0 0 0 0 0 0 0 0 0 121</span>
<span class="s0">/**</span>
 <span class="s0">* A node that can be positioned around in the scene graph to represent a</span>
 <span class="s0">* point of view for rendering a scene.</span>
 <span class="s0">*/</span>

<span class="s0">298 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 299 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">299 23 BitMask&lt; uint32_t, 32 &gt; 0 2048 23 BitMask&lt; uint32_t, 32 &gt; 23 BitMask&lt; uint32_t, 32 &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">300 11 BitMask32 * 0 8576 11 BitMask32 * 11 BitMask32 * 0 0 298 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">301 21 ShadowManager const * 0 8576 21 ShadowManager const * 21 ShadowManager const * 0 0 302 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">302 19 ShadowManager const 0 8832 19 ShadowManager const 19 ShadowManager const 0 0 235 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">303 16 GraphicsOutput * 0 8576 16 GraphicsOutput * 16 GraphicsOutput * 0 0 304 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">304 14 GraphicsOutput 0 2048 14 GraphicsOutput 14 GraphicsOutput 0 0 0 0 0 0 0 0 0 0 0 0 727</span>
<span class="s0">/**</span>
 <span class="s0">* This is a base class for the various different classes that represent the</span>
 <span class="s0">* result of a frame of rendering.  The most common kind of GraphicsOutput is</span>
 <span class="s0">* a GraphicsWindow, which is a real-time window on the desktop, but another</span>
 <span class="s0">* example is GraphicsBuffer, which is an offscreen buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* The actual rendering, and anything associated with the graphics context</span>
 <span class="s0">* itself, is managed by the associated GraphicsStateGuardian (which might</span>
 <span class="s0">* output to multiple GraphicsOutput objects).</span>
 <span class="s0">*</span>
 <span class="s0">* GraphicsOutputs are not actually writable to bam files, of course, but they</span>
 <span class="s0">* may be passed as event parameters, so they inherit from</span>
 <span class="s0">* TypedWritableReferenceCount instead of TypedReferenceCount for that</span>
 <span class="s0">* convenience.</span>
 <span class="s0">*/</span>

<span class="s0">305 22 InternalLightManager * 0 8576 22 InternalLightManager * 22 InternalLightManager * 0 0 237 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">306 28 InternalLightManager const * 0 8576 28 InternalLightManager const * 28 InternalLightManager const * 0 0 307 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">307 26 InternalLightManager const 0 8832 26 InternalLightManager const 26 InternalLightManager const 0 0 237 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">308 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 309 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">309 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 310 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">310 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 311 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">311 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">312 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 230 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">313 14 RPPointLight * 0 8576 14 RPPointLight * 14 RPPointLight * 0 0 239 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">314 20 RPPointLight const * 0 8576 20 RPPointLight const * 20 RPPointLight const * 0 0 315 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">315 18 RPPointLight const 0 8832 18 RPPointLight const 18 RPPointLight const 0 0 239 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">316 21 PSSMCameraRig const * 0 8576 21 PSSMCameraRig const * 21 PSSMCameraRig const * 0 0 317 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">317 19 PSSMCameraRig const 0 8832 19 PSSMCameraRig const 19 PSSMCameraRig const 0 0 240 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">318 15 PSSMCameraRig * 0 8576 15 PSSMCameraRig * 15 PSSMCameraRig * 0 0 240 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">319 20 PTA_LMatrix4 const * 0 8576 20 PTA_LMatrix4 const * 20 PTA_LMatrix4 const * 0 0 320 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">320 18 PTA_LMatrix4 const 0 8832 18 PTA_LMatrix4 const 18 PTA_LMatrix4 const 0 0 321 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">321 12 PTA_LMatrix4 0 2105344 12 PTA_LMatrix4 12 PTA_LMatrix4 0 0 322 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">322 13 PTA_LMatrix4f 0 2105344 13 PTA_LMatrix4f 13 PTA_LMatrix4f 0 0 323 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">323 36 PointerToArray&lt; UnalignedLMatrix4f &gt; 0 2048 36 PointerToArray&lt; UnalignedLMatrix4f &gt; 36 PointerToArray&lt; UnalignedLMatrix4f &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">324 21 PTA_LVecBase2 const * 0 8576 21 PTA_LVecBase2 const * 21 PTA_LVecBase2 const * 0 0 325 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">325 19 PTA_LVecBase2 const 0 8832 19 PTA_LVecBase2 const 19 PTA_LVecBase2 const 0 0 326 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">326 13 PTA_LVecBase2 0 2105344 13 PTA_LVecBase2 13 PTA_LVecBase2 0 0 327 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">327 14 PTA_LVecBase2f 0 2105344 14 PTA_LVecBase2f 14 PTA_LVecBase2f 0 0 328 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">328 28 PointerToArray&lt; LVecBase2f &gt; 0 2048 28 PointerToArray&lt; LVecBase2f &gt; 28 PointerToArray&lt; LVecBase2f &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">329 13 RPSpotLight * 0 8576 13 RPSpotLight * 13 RPSpotLight * 0 0 241 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">330 19 RPSpotLight const * 0 8576 19 RPSpotLight const * 19 RPSpotLight const * 0 0 331 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">331 17 RPSpotLight const 0 8832 17 RPSpotLight const 17 RPSpotLight const 0 0 241 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">332 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 228 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">23</span>
<span class="s0">333 12 num_commands 0 2 221 125 0 0 0 0 0 0 0 28 GPUCommandList::num_commands 0</span>

<span class="s0">334 3 pos 0 6 227 136 135 0 0 0 0 0 0 12 RPLight::pos 0</span>

<span class="s0">335 5 color 0 6 227 138 137 0 0 0 0 0 0 14 RPLight::color 0</span>

<span class="s0">336 6 energy 0 6 230 141 140 0 0 0 0 0 0 15 RPLight::energy 0</span>

<span class="s0">337 10 light_type 0 2 226 142 0 0 0 0 0 0 0 19 RPLight::light_type 0</span>

<span class="s0">338 13 casts_shadows 0 6 231 144 143 0 0 0 0 0 0 22 RPLight::casts_shadows 0</span>

<span class="s0">339 21 shadow_map_resolution 0 6 221 146 145 0 0 0 0 0 0 30 RPLight::shadow_map_resolution 0</span>

<span class="s0">340 11 ies_profile 0 30 232 148 147 149 150 0 0 0 0 20 RPLight::ies_profile 0</span>

<span class="s0">341 10 near_plane 0 6 230 152 151 0 0 0 0 0 0 19 RPLight::near_plane 0</span>

<span class="s0">342 14 num_used_tiles 0 2 232 155 0 0 0 0 0 0 0 27 ShadowAtlas::num_used_tiles 0</span>

<span class="s0">343 8 coverage 0 2 230 156 0 0 0 0 0 0 0 21 ShadowAtlas::coverage 0</span>

<span class="s0">344 10 atlas_size 0 6 221 170 169 0 0 0 0 0 0 25 ShadowManager::atlas_size 0</span>

<span class="s0">345 21 num_update_slots_left 0 2 221 171 0 0 0 0 0 0 0 36 ShadowManager::num_update_slots_left 0</span>

<span class="s0">346 5 atlas 0 2 236 172 0 0 0 0 0 0 0 20 ShadowManager::atlas 0</span>

<span class="s0">347 15 max_light_index 0 2 232 181 0 0 0 0 0 0 0 37 InternalLightManager::max_light_index 0</span>

<span class="s0">348 10 num_lights 0 2 221 182 0 0 0 0 0 0 0 32 InternalLightManager::num_lights 0</span>

<span class="s0">349 18 num_shadow_sources 0 2 221 183 0 0 0 0 0 0 0 40 InternalLightManager::num_shadow_sources 0</span>

<span class="s0">350 14 shadow_manager 0 6 238 185 184 0 0 0 0 0 0 36 InternalLightManager::shadow_manager 0</span>

<span class="s0">351 6 radius 0 6 230 190 189 0 0 0 0 0 0 20 RPPointLight::radius 0</span>

<span class="s0">352 12 inner_radius 0 6 230 192 191 0 0 0 0 0 0 26 RPPointLight::inner_radius 0</span>

<span class="s0">353 6 radius 0 6 230 211 210 0 0 0 0 0 0 19 RPSpotLight::radius 0</span>

<span class="s0">354 3 fov 0 6 230 213 212 0 0 0 0 0 0 16 RPSpotLight::fov 0</span>

<span class="s0">355 9 direction 0 6 227 215 214 0 0 0 0 0 0 22 RPSpotLight::direction 0</span>

<span class="s0">0</span>
</pre>
</body>
</html>