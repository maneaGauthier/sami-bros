<html>
<head>
<title>libp3putil.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3putil.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">10 libp3putil 4 xqRv 12 panda3d.core </span>
<span class="s0">956</span>
<span class="s0">969 5 clear 0 4 1927 56 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt;::clear 0 1 18 0</span>
<span class="s0">75</span>
<span class="s0">inline void PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt;::clear(void);</span>

<span class="s0">970 6 output 0 4 1927 57 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt;::output 0 1 19 0</span>
<span class="s0">88</span>
<span class="s0">void PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">971 19 ~PointerToArrayBase 0 516 1926 49 PointerToArrayBase&lt; ushort &gt;::~PointerToArrayBase 0 0 0</span>
<span class="s0">63</span>
<span class="s0">inline PointerToArrayBase&lt; ushort &gt;::~PointerToArrayBase(void);</span>

<span class="s0">972 11 operator == 0 4 1926 41 PointerToArrayBase&lt; ushort &gt;::operator == 0 1 16 64</span>
<span class="s0">// These are implemented in PointerToVoid, but expose them here.</span>
<span class="s0">103</span>
<span class="s0">inline bool PointerToArrayBase&lt; ushort &gt;::operator ==(PointerToArrayBase&lt; ushort &gt; const &amp;other) const;</span>

<span class="s0">973 11 operator != 0 4 1926 41 PointerToArrayBase&lt; ushort &gt;::operator != 0 1 17 0</span>
<span class="s0">103</span>
<span class="s0">inline bool PointerToArrayBase&lt; ushort &gt;::operator !=(PointerToArrayBase&lt; ushort &gt; const &amp;other) const;</span>

<span class="s0">974 19 ConstPointerToArray 0 260 1925 50 ConstPointerToArray&lt; ushort &gt;::ConstPointerToArray 0 2 1 2 0</span>
<span class="s0">198</span>
<span class="s0">inline ConstPointerToArray&lt; ushort &gt;::ConstPointerToArray(PointerToArray&lt; ushort &gt; const &amp;copy);</span>
<span class="s0">inline ConstPointerToArray&lt; ushort &gt;::ConstPointerToArray(ConstPointerToArray&lt; ushort &gt; const &amp;copy);</span>

<span class="s0">975 5 clear 0 4 1925 36 ConstPointerToArray&lt; ushort &gt;::clear 0 1 3 0</span>
<span class="s0">55</span>
<span class="s0">inline void ConstPointerToArray&lt; ushort &gt;::clear(void);</span>

<span class="s0">976 4 size 0 4 1925 35 ConstPointerToArray&lt; ushort &gt;::size 0 1 4 0</span>
<span class="s0">78</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; ushort &gt;::size(void) const;</span>

<span class="s0">977 11 get_element 0 4 1925 42 ConstPointerToArray&lt; ushort &gt;::get_element 0 1 5 0</span>
<span class="s0">96</span>
<span class="s0">inline ushort const &amp;ConstPointerToArray&lt; ushort &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">978 11 __getitem__ 0 4 1925 42 ConstPointerToArray&lt; ushort &gt;::__getitem__ 0 1 6 0</span>
<span class="s0">89</span>
<span class="s0">ushort const &amp;ConstPointerToArray&lt; ushort &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">979 8 get_data 0 4 1925 39 ConstPointerToArray&lt; ushort &gt;::get_data 0 1 7 0</span>
<span class="s0">62</span>
<span class="s0">PyObject *ConstPointerToArray&lt; ushort &gt;::get_data(void) const;</span>

<span class="s0">980 11 get_subdata 0 4 1925 42 ConstPointerToArray&lt; ushort &gt;::get_subdata 0 1 8 0</span>
<span class="s0">115</span>
<span class="s0">PyObject *ConstPointerToArray&lt; ushort &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">981 13 get_ref_count 0 4 1925 44 ConstPointerToArray&lt; ushort &gt;::get_ref_count 0 1 9 0</span>
<span class="s0">68</span>
<span class="s0">inline int ConstPointerToArray&lt; ushort &gt;::get_ref_count(void) const;</span>

<span class="s0">982 18 get_node_ref_count 0 4 1925 49 ConstPointerToArray&lt; ushort &gt;::get_node_ref_count 0 1 10 0</span>
<span class="s0">73</span>
<span class="s0">inline int ConstPointerToArray&lt; ushort &gt;::get_node_ref_count(void) const;</span>

<span class="s0">983 5 count 0 4 1925 36 ConstPointerToArray&lt; ushort &gt;::count 0 1 11 0</span>
<span class="s0">89</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; ushort &gt;::count(ushort const &amp;) const;</span>

<span class="s0">984 10 __reduce__ 0 4 1925 41 ConstPointerToArray&lt; ushort &gt;::__reduce__ 0 1 12 0</span>
<span class="s0">74</span>
<span class="s0">PyObject *ConstPointerToArray&lt; ushort &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">985 13 __getbuffer__ 0 4 1925 44 ConstPointerToArray&lt; ushort &gt;::__getbuffer__ 0 1 13 0</span>
<span class="s0">99</span>
<span class="s0">int ConstPointerToArray&lt; ushort &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;</span>

<span class="s0">986 17 __releasebuffer__ 0 4 1925 48 ConstPointerToArray&lt; ushort &gt;::__releasebuffer__ 0 1 14 0</span>
<span class="s0">93</span>
<span class="s0">void ConstPointerToArray&lt; ushort &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">987 12 __deepcopy__ 0 4 1925 43 ConstPointerToArray&lt; ushort &gt;::__deepcopy__ 0 1 15 0</span>
<span class="s0">96</span>
<span class="s0">ConstPointerToArray&lt; ushort &gt; ConstPointerToArray&lt; ushort &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">988 20 ~ConstPointerToArray 0 516 1925 51 ConstPointerToArray&lt; ushort &gt;::~ConstPointerToArray 0 0 0</span>
<span class="s0">58</span>
<span class="s0">ConstPointerToArray&lt; ushort &gt;::~ConstPointerToArray(void);</span>

<span class="s0">989 14 PointerToArray 0 260 1929 40 PointerToArray&lt; ushort &gt;::PointerToArray 0 3 20 21 22 0</span>
<span class="s0">279</span>
<span class="s0">inline PointerToArray&lt; ushort &gt;::PointerToArray(TypeHandle type_handle = (::_get_type_handle((ushort const *)(0))));</span>
<span class="s0">inline PointerToArray&lt; ushort &gt;::PointerToArray(PointerToArray&lt; ushort &gt; const &amp;copy);</span>
<span class="s0">PointerToArray&lt; ushort &gt;::PointerToArray(PyObject *self, PyObject *source);</span>

<span class="s0">990 11 empty_array 0 4 1929 37 PointerToArray&lt; ushort &gt;::empty_array 0 1 23 0</span>
<span class="s0">171</span>
<span class="s0">static inline PointerToArray&lt; ushort &gt; PointerToArray&lt; ushort &gt;::empty_array(unsigned long long int n, TypeHandle type_handle = (::_get_type_handle((ushort const *)(0))));</span>

<span class="s0">991 5 clear 0 4 1929 31 PointerToArray&lt; ushort &gt;::clear 0 1 24 0</span>
<span class="s0">50</span>
<span class="s0">inline void PointerToArray&lt; ushort &gt;::clear(void);</span>

<span class="s0">992 4 size 0 4 1929 30 PointerToArray&lt; ushort &gt;::size 0 1 25 0</span>
<span class="s0">73</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; ushort &gt;::size(void) const;</span>

<span class="s0">993 9 push_back 0 4 1929 35 PointerToArray&lt; ushort &gt;::push_back 0 1 26 0</span>
<span class="s0">65</span>
<span class="s0">inline void PointerToArray&lt; ushort &gt;::push_back(ushort const &amp;x);</span>

<span class="s0">994 8 pop_back 0 4 1929 34 PointerToArray&lt; ushort &gt;::pop_back 0 1 27 0</span>
<span class="s0">53</span>
<span class="s0">inline void PointerToArray&lt; ushort &gt;::pop_back(void);</span>

<span class="s0">995 11 get_element 0 4 1929 37 PointerToArray&lt; ushort &gt;::get_element 0 1 28 0</span>
<span class="s0">91</span>
<span class="s0">inline ushort const &amp;PointerToArray&lt; ushort &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">996 11 set_element 0 4 1929 37 PointerToArray&lt; ushort &gt;::set_element 0 1 29 0</span>
<span class="s0">97</span>
<span class="s0">inline void PointerToArray&lt; ushort &gt;::set_element(unsigned long long int n, ushort const &amp;value);</span>

<span class="s0">997 11 __getitem__ 0 4 1929 37 PointerToArray&lt; ushort &gt;::__getitem__ 0 1 30 0</span>
<span class="s0">84</span>
<span class="s0">ushort const &amp;PointerToArray&lt; ushort &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">998 11 __setitem__ 0 4 1929 37 PointerToArray&lt; ushort &gt;::__setitem__ 0 1 31 0</span>
<span class="s0">90</span>
<span class="s0">void PointerToArray&lt; ushort &gt;::__setitem__(unsigned long long int n, ushort const &amp;value);</span>

<span class="s0">999 8 get_data 0 4 1929 34 PointerToArray&lt; ushort &gt;::get_data 0 1 32 0</span>
<span class="s0">57</span>
<span class="s0">PyObject *PointerToArray&lt; ushort &gt;::get_data(void) const;</span>

<span class="s0">1000 8 set_data 0 4 1929 34 PointerToArray&lt; ushort &gt;::set_data 0 1 33 0</span>
<span class="s0">56</span>
<span class="s0">void PointerToArray&lt; ushort &gt;::set_data(PyObject *data);</span>

<span class="s0">1001 11 get_subdata 0 4 1929 37 PointerToArray&lt; ushort &gt;::get_subdata 0 1 34 0</span>
<span class="s0">110</span>
<span class="s0">PyObject *PointerToArray&lt; ushort &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">1002 11 set_subdata 0 4 1929 37 PointerToArray&lt; ushort &gt;::set_subdata 0 1 35 0</span>
<span class="s0">145</span>
<span class="s0">inline void PointerToArray&lt; ushort &gt;::set_subdata(unsigned long long int n, unsigned long long int count, std::basic_string&lt; char &gt; const &amp;data);</span>

<span class="s0">1003 13 get_ref_count 0 4 1929 39 PointerToArray&lt; ushort &gt;::get_ref_count 0 1 36 0</span>
<span class="s0">63</span>
<span class="s0">inline int PointerToArray&lt; ushort &gt;::get_ref_count(void) const;</span>

<span class="s0">1004 18 get_node_ref_count 0 4 1929 44 PointerToArray&lt; ushort &gt;::get_node_ref_count 0 1 37 0</span>
<span class="s0">68</span>
<span class="s0">inline int PointerToArray&lt; ushort &gt;::get_node_ref_count(void) const;</span>

<span class="s0">1005 5 count 0 4 1929 31 PointerToArray&lt; ushort &gt;::count 0 1 38 0</span>
<span class="s0">84</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; ushort &gt;::count(ushort const &amp;) const;</span>

<span class="s0">1006 10 __reduce__ 0 4 1929 36 PointerToArray&lt; ushort &gt;::__reduce__ 0 1 39 0</span>
<span class="s0">69</span>
<span class="s0">PyObject *PointerToArray&lt; ushort &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">1007 13 __getbuffer__ 0 4 1929 39 PointerToArray&lt; ushort &gt;::__getbuffer__ 0 1 40 0</span>
<span class="s0">88</span>
<span class="s0">int PointerToArray&lt; ushort &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags);</span>

<span class="s0">1008 17 __releasebuffer__ 0 4 1929 43 PointerToArray&lt; ushort &gt;::__releasebuffer__ 0 1 41 0</span>
<span class="s0">88</span>
<span class="s0">void PointerToArray&lt; ushort &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">1009 12 __deepcopy__ 0 4 1929 38 PointerToArray&lt; ushort &gt;::__deepcopy__ 0 1 42 0</span>
<span class="s0">86</span>
<span class="s0">PointerToArray&lt; ushort &gt; PointerToArray&lt; ushort &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">1010 15 ~PointerToArray 0 516 1929 41 PointerToArray&lt; ushort &gt;::~PointerToArray 0 0 0</span>
<span class="s0">48</span>
<span class="s0">PointerToArray&lt; ushort &gt;::~PointerToArray(void);</span>

<span class="s0">1011 14 ~AnimInterface 0 518 1930 29 AnimInterface::~AnimInterface 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual AnimInterface::~AnimInterface(void);</span>

<span class="s0">1012 4 play 0 4 1930 19 AnimInterface::play 0 2 43 44 477</span>
<span class="s0">/**</span>
 <span class="s0">* Runs the entire animation from beginning to end and stops.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Runs the animation from the frame &quot;from&quot; to and including the frame &quot;to&quot;,</span>
 <span class="s0">* at which point the animation is stopped.  Both &quot;from&quot; and &quot;to&quot; frame</span>
 <span class="s0">* numbers may be outside the range (0, get_num_frames()) and the animation</span>
 <span class="s0">* will follow the range correctly, reporting numbers modulo get_num_frames().</span>
 <span class="s0">* For instance, play(0, get_num_frames() * 2) will play the animation twice</span>
 <span class="s0">* and then stop.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline void AnimInterface::play(void);</span>
<span class="s0">inline void AnimInterface::play(double from, double to);</span>

<span class="s0">1013 4 loop 0 4 1930 19 AnimInterface::loop 0 2 45 46 392</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the entire animation looping.  If restart is true, the animation is</span>
 <span class="s0">* restarted from the beginning; otherwise, it continues from the current</span>
 <span class="s0">* frame.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Loops the animation from the frame &quot;from&quot; to and including the frame &quot;to&quot;,</span>
 <span class="s0">* indefinitely.  If restart is true, the animation is restarted from the</span>
 <span class="s0">* beginning; otherwise, it continues from the current frame.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">inline void AnimInterface::loop(bool restart);</span>
<span class="s0">inline void AnimInterface::loop(bool restart, double from, double to);</span>

<span class="s0">1014 8 pingpong 0 4 1930 23 AnimInterface::pingpong 0 2 47 48 369</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the entire animation bouncing back and forth between its first frame</span>
 <span class="s0">* and last frame.  If restart is true, the animation is restarted from the</span>
 <span class="s0">* beginning; otherwise, it continues from the current frame.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Loops the animation from the frame &quot;from&quot; to and including the frame &quot;to&quot;,</span>
 <span class="s0">* and then back in the opposite direction, indefinitely.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">inline void AnimInterface::pingpong(bool restart);</span>
<span class="s0">inline void AnimInterface::pingpong(bool restart, double from, double to);</span>

<span class="s0">1015 4 stop 0 4 1930 19 AnimInterface::stop 0 1 49 130</span>
<span class="s0">/**</span>
 <span class="s0">* Stops a currently playing or looping animation right where it is.  The</span>
 <span class="s0">* animation remains posed at the current frame.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline void AnimInterface::stop(void);</span>

<span class="s0">1016 4 pose 0 4 1930 19 AnimInterface::pose 0 1 50 72</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the animation to the indicated frame and holds it there.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void AnimInterface::pose(double frame);</span>

<span class="s0">1017 13 set_play_rate 0 4 1930 28 AnimInterface::set_play_rate 0 1 51 243</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the rate at which the animation plays.  1.0 is the normal speed,</span>
 <span class="s0">* 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to</span>
 <span class="s0">* pause the animation, and a negative value will play the animation</span>
 <span class="s0">* backwards.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void AnimInterface::set_play_rate(double play_rate);</span>

<span class="s0">1018 13 get_play_rate 0 4 1930 28 AnimInterface::get_play_rate 0 1 52 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the rate at which the animation plays.  See set_play_rate().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline double AnimInterface::get_play_rate(void) const;</span>

<span class="s0">1019 14 get_frame_rate 0 4 1930 29 AnimInterface::get_frame_rate 0 1 53 234</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the native frame rate of the animation.  This is the number of</span>
 <span class="s0">* frames per second that will elapse when the play_rate is set to 1.0.  It is</span>
 <span class="s0">* a fixed property of the animation and may not be adjusted by the user.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline double AnimInterface::get_frame_rate(void) const;</span>

<span class="s0">1020 14 get_num_frames 0 6 1930 29 AnimInterface::get_num_frames 0 1 54 278</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of frames in the animation.  This is a property of the</span>
 <span class="s0">* animation and may not be directly adjusted by the user (although it may</span>
 <span class="s0">* change without warning with certain kinds of animations, since this is a</span>
 <span class="s0">* virtual method that may be overridden).</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">virtual int AnimInterface::get_num_frames(void) const;</span>

<span class="s0">1021 9 get_frame 0 4 1930 24 AnimInterface::get_frame 0 1 55 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current integer frame number.  This number will be in the range</span>
 <span class="s0">* 0 &lt;= f &lt; get_num_frames().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int AnimInterface::get_frame(void) const;</span>

<span class="s0">1022 14 get_next_frame 0 4 1930 29 AnimInterface::get_next_frame 0 1 56 330</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current integer frame number + 1, constrained to the range 0 &lt;=</span>
 <span class="s0">* f &lt; get_num_frames().</span>
 <span class="s0">*</span>
 <span class="s0">* If the play mode is PM_play, this will clamp to the same value as</span>
 <span class="s0">* get_frame() at the end of the animation.  If the play mode is any other</span>
 <span class="s0">* value, this will wrap around to frame 0 at the end of the animation.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int AnimInterface::get_next_frame(void) const;</span>

<span class="s0">1023 8 get_frac 0 4 1930 23 AnimInterface::get_frac 0 1 57 314</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the fractional part of the current frame.  Normally, this is in the</span>
 <span class="s0">* range 0.0 &lt;= f &lt; 1.0, but in the one special case of an animation playing</span>
 <span class="s0">* to its end frame and stopping, it might exactly equal 1.0.</span>
 <span class="s0">*</span>
 <span class="s0">* It will always be true that get_full_frame() + get_frac() ==</span>
 <span class="s0">* get_full_fframe().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline double AnimInterface::get_frac(void) const;</span>

<span class="s0">1024 14 get_full_frame 0 4 1930 29 AnimInterface::get_full_frame 0 1 58 372</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current integer frame number.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the value returned by get_frame(), this frame number may extend</span>
 <span class="s0">* beyond the range of get_num_frames() if the frame range passed to play(),</span>
 <span class="s0">* loop(), etc.  did.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the value returned by get_full_fframe(), this return value will</span>
 <span class="s0">* never exceed the value passed to to_frame in the play() method.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int AnimInterface::get_full_frame(void) const;</span>

<span class="s0">1025 15 get_full_fframe 0 4 1930 30 AnimInterface::get_full_fframe 0 1 59 490</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current floating-point frame number.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the value returned by get_frame(), this frame number may extend</span>
 <span class="s0">* beyond the range of get_num_frames() if the frame range passed to play(),</span>
 <span class="s0">* loop(), etc.  did.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the value returned by get_full_frame(), this return value may equal</span>
 <span class="s0">* (to_frame + 1.0), when the animation has played to its natural end.</span>
 <span class="s0">* However, in this case the return value of get_full_frame() will be</span>
 <span class="s0">* to_frame, not (to_frame + 1).</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline double AnimInterface::get_full_fframe(void) const;</span>

<span class="s0">1026 10 is_playing 0 4 1930 25 AnimInterface::is_playing 0 1 60 208</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the animation is currently playing, false if it is stopped</span>
 <span class="s0">* (e.g.  because stop() or pose() was called, or because it reached the end</span>
 <span class="s0">* of the animation after play() was called).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool AnimInterface::is_playing(void) const;</span>

<span class="s0">1027 6 output 0 6 1930 21 AnimInterface::output 0 1 61 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual void AnimInterface::output(std::ostream &amp;out) const;</span>

<span class="s0">1028 14 get_class_type 0 4 1930 29 AnimInterface::get_class_type 0 1 62 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle AnimInterface::get_class_type(void);</span>

<span class="s0">1029 9 UpdateSeq 0 260 1935 20 UpdateSeq::UpdateSeq 0 2 63 64 132</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an UpdateSeq in the given state.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates an UpdateSeq in the 'initial' state.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">constexpr UpdateSeq::UpdateSeq(void);</span>
<span class="s0">inline UpdateSeq::UpdateSeq(UpdateSeq const &amp;copy);</span>

<span class="s0">1030 7 initial 0 4 1935 18 UpdateSeq::initial 0 1 65 0</span>
<span class="s0">52</span>
<span class="s0">static constexpr UpdateSeq UpdateSeq::initial(void);</span>

<span class="s0">1031 3 old 0 4 1935 14 UpdateSeq::old 0 1 66 0</span>
<span class="s0">48</span>
<span class="s0">static constexpr UpdateSeq UpdateSeq::old(void);</span>

<span class="s0">1032 5 fresh 0 4 1935 16 UpdateSeq::fresh 0 1 67 0</span>
<span class="s0">50</span>
<span class="s0">static constexpr UpdateSeq UpdateSeq::fresh(void);</span>

<span class="s0">1033 10 operator = 0 4 1935 21 UpdateSeq::operator = 0 1 68 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void UpdateSeq::operator =(UpdateSeq const &amp;copy);</span>

<span class="s0">1034 5 clear 0 4 1935 16 UpdateSeq::clear 0 1 69 55</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the UpdateSeq to the 'initial' state.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">inline void UpdateSeq::clear(void);</span>

<span class="s0">1035 10 is_initial 0 4 1935 21 UpdateSeq::is_initial 0 1 70 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the UpdateSeq is in the 'initial' state.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool UpdateSeq::is_initial(void) const;</span>

<span class="s0">1036 6 is_old 0 4 1935 17 UpdateSeq::is_old 0 1 71 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the UpdateSeq is in the 'old' state.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool UpdateSeq::is_old(void) const;</span>

<span class="s0">1037 8 is_fresh 0 4 1935 19 UpdateSeq::is_fresh 0 1 72 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the UpdateSeq is in the 'fresh' state.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool UpdateSeq::is_fresh(void) const;</span>

<span class="s0">1038 10 is_special 0 4 1935 21 UpdateSeq::is_special 0 1 73 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the UpdateSeq is in any special states, i.e.  'initial',</span>
 <span class="s0">* 'old', or 'fresh'.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool UpdateSeq::is_special(void) const;</span>

<span class="s0">1039 11 operator == 0 4 1935 22 UpdateSeq::operator == 0 1 74 0</span>
<span class="s0">65</span>
<span class="s0">inline bool UpdateSeq::operator ==(UpdateSeq const &amp;other) const;</span>

<span class="s0">1040 11 operator != 0 4 1935 22 UpdateSeq::operator != 0 1 75 0</span>
<span class="s0">65</span>
<span class="s0">inline bool UpdateSeq::operator !=(UpdateSeq const &amp;other) const;</span>

<span class="s0">1041 10 operator &lt; 0 4 1935 21 UpdateSeq::operator &lt; 0 1 76 0</span>
<span class="s0">64</span>
<span class="s0">inline bool UpdateSeq::operator &lt;(UpdateSeq const &amp;other) const;</span>

<span class="s0">1042 11 operator &lt;= 0 4 1935 22 UpdateSeq::operator &lt;= 0 1 77 0</span>
<span class="s0">65</span>
<span class="s0">inline bool UpdateSeq::operator &lt;=(UpdateSeq const &amp;other) const;</span>

<span class="s0">1043 10 operator &gt; 0 4 1935 21 UpdateSeq::operator &gt; 0 1 78 0</span>
<span class="s0">64</span>
<span class="s0">inline bool UpdateSeq::operator &gt;(UpdateSeq const &amp;other) const;</span>

<span class="s0">1044 11 operator &gt;= 0 4 1935 22 UpdateSeq::operator &gt;= 0 1 79 0</span>
<span class="s0">65</span>
<span class="s0">inline bool UpdateSeq::operator &gt;=(UpdateSeq const &amp;other) const;</span>

<span class="s0">1045 11 operator ++ 0 68 1935 22 UpdateSeq::operator ++ 0 1 80 0</span>
<span class="s0">46</span>
<span class="s0">inline UpdateSeq UpdateSeq::operator ++(void);</span>

<span class="s0">1046 11 operator ++ 0 4 1935 22 UpdateSeq::operator ++ 0 1 81 0</span>
<span class="s0">46</span>
<span class="s0">inline UpdateSeq UpdateSeq::operator ++(int );</span>

<span class="s0">1047 7 get_seq 0 4 1935 18 UpdateSeq::get_seq 0 1 82 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the internal integer value associated with the UpdateSeq.  Useful</span>
 <span class="s0">* for debugging only.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const;</span>

<span class="s0">1048 6 output 0 4 1935 17 UpdateSeq::output 0 1 83 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void UpdateSeq::output(std::ostream &amp;out) const;</span>

<span class="s0">1049 10 ~UpdateSeq 0 516 1935 21 UpdateSeq::~UpdateSeq 0 0 0</span>
<span class="s0">28</span>
<span class="s0">UpdateSeq::~UpdateSeq(void);</span>

<span class="s0">1050 6 fillin 0 6 1939 21 TypedWritable::fillin 0 1 84 308</span>
<span class="s0">/**</span>
 <span class="s0">* This internal function is intended to be called by each class's</span>
 <span class="s0">* make_from_bam() method to read in all of the relevant data from the BamFile</span>
 <span class="s0">* for the new object.  It is also called directly by the BamReader to re-read</span>
 <span class="s0">* the data for an object that has been placed on the stream for an update.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">virtual void TypedWritable::fillin(DatagramIterator &amp;scan, BamReader *manager);</span>

<span class="s0">1051 17 mark_bam_modified 0 4 1939 32 TypedWritable::mark_bam_modified 0 1 85 345</span>
<span class="s0">/**</span>
 <span class="s0">* Increments the bam_modified counter, so that this object will be</span>
 <span class="s0">* invalidated and retransmitted on any open bam streams.  This should</span>
 <span class="s0">* normally not need to be called by user code; it should be called internally</span>
 <span class="s0">* when the object has been changed in a way that legitimately requires its</span>
 <span class="s0">* retransmission to any connected clients.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void TypedWritable::mark_bam_modified(void);</span>

<span class="s0">1052 16 get_bam_modified 0 4 1939 31 TypedWritable::get_bam_modified 0 1 86 140</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current bam_modified counter.  This counter is normally</span>
 <span class="s0">* incremented automatically whenever the object is modified.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline UpdateSeq TypedWritable::get_bam_modified(void) const;</span>

<span class="s0">1053 10 __reduce__ 0 4 1939 25 TypedWritable::__reduce__ 0 1 87 0</span>
<span class="s0">58</span>
<span class="s0">PyObject *TypedWritable::__reduce__(PyObject *self) const;</span>

<span class="s0">1054 18 __reduce_persist__ 0 4 1939 33 TypedWritable::__reduce_persist__ 0 1 88 0</span>
<span class="s0">85</span>
<span class="s0">PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const;</span>

<span class="s0">1055 20 encode_to_bam_stream 0 4 1939 35 TypedWritable::encode_to_bam_stream 0 2 89 90 854</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the TypedWritable object into a single stream of data using a</span>
 <span class="s0">* BamWriter, and returns that data as a bytes object.  Returns an empty bytes</span>
 <span class="s0">* object on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a convenience method particularly useful for cases when you are</span>
 <span class="s0">* only serializing a single object.  If you have many objects to process, it</span>
 <span class="s0">* is more efficient to use the same BamWriter to serialize all of them</span>
 <span class="s0">* together.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Converts the TypedWritable object into a single stream of data using a</span>
 <span class="s0">* BamWriter, and stores that data in the indicated string.  Returns true on</span>
 <span class="s0">* success, false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a convenience method particularly useful for cases when you are</span>
 <span class="s0">* only serializing a single object.  If you have many objects to process, it</span>
 <span class="s0">* is more efficient to use the same BamWriter to serialize all of them</span>
 <span class="s0">* together.</span>
 <span class="s0">*/</span>
<span class="s0">165</span>
<span class="s0">inline vector_uchar TypedWritable::encode_to_bam_stream(void) const;</span>
<span class="s0">bool TypedWritable::encode_to_bam_stream(vector_uchar &amp;data, BamWriter *writer = nullptr) const;</span>

<span class="s0">1056 26 decode_raw_from_bam_stream 0 4 1939 41 TypedWritable::decode_raw_from_bam_stream 0 0 953</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the bytes created by a previous call to encode_to_bam_stream(), and</span>
 <span class="s0">* extracts the single object on those bytes.  Returns true on success, false</span>
 <span class="s0">* on error.</span>
 <span class="s0">*</span>
 <span class="s0">* This variant sets the TypedWritable and ReferenceCount pointers separately;</span>
 <span class="s0">* both are pointers to the same object.  The reference count is not</span>
 <span class="s0">* incremented; it is the caller's responsibility to manage the reference</span>
 <span class="s0">* count.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this method cannot be used to retrieve objects that do not</span>
 <span class="s0">* inherit from ReferenceCount, because these objects cannot persist beyond</span>
 <span class="s0">* the lifetime of the BamReader that reads them.  To retrieve these objects</span>
 <span class="s0">* from a bam stream, you must construct a BamReader directly.</span>
 <span class="s0">*</span>
 <span class="s0">* If you happen to know that the particular object in question inherits from</span>
 <span class="s0">* TypedWritableReferenceCount or PandaNode, consider calling the variant of</span>
 <span class="s0">* decode_from_bam_stream() defined for those methods, which presents a</span>
 <span class="s0">* simpler interface.</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">static bool TypedWritable::decode_raw_from_bam_stream(TypedWritable *&amp;ptr, ReferenceCount *&amp;ref_ptr, vector_uchar data, BamReader *reader = nullptr);</span>

<span class="s0">1057 14 get_class_type 0 4 1939 29 TypedWritable::get_class_type 0 1 91 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle TypedWritable::get_class_type(void);</span>

<span class="s0">1058 23 upcast_to_TypedWritable 0 12 1941 52 TypedWritableReferenceCount::upcast_to_TypedWritable 0 1 94 56</span>
<span class="s0">upcast from TypedWritableReferenceCount to TypedWritable</span>
<span class="s0">74</span>
<span class="s0">TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void);</span>

<span class="s0">1059 39 downcast_to_TypedWritableReferenceCount 0 12 1939 54 TypedWritable::downcast_to_TypedWritableReferenceCount 0 0 58</span>
<span class="s0">downcast from TypedWritable to TypedWritableReferenceCount</span>
<span class="s0">90</span>
<span class="s0">TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">1060 24 upcast_to_ReferenceCount 0 12 1941 53 TypedWritableReferenceCount::upcast_to_ReferenceCount 0 1 95 57</span>
<span class="s0">upcast from TypedWritableReferenceCount to ReferenceCount</span>
<span class="s0">76</span>
<span class="s0">ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void);</span>

<span class="s0">1061 39 downcast_to_TypedWritableReferenceCount 0 12 1942 55 ReferenceCount::downcast_to_TypedWritableReferenceCount 0 0 59</span>
<span class="s0">downcast from ReferenceCount to TypedWritableReferenceCount</span>
<span class="s0">91</span>
<span class="s0">TypedWritableReferenceCount *ReferenceCount::downcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">1062 22 decode_from_bam_stream 0 4 1941 51 TypedWritableReferenceCount::decode_from_bam_stream 0 1 92 491</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the bytes created by a previous call to encode_to_bam_stream(), and</span>
 <span class="s0">* extracts and returns the single object on those bytes.  Returns NULL on</span>
 <span class="s0">* error.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended to replace decode_raw_from_bam_stream() when you</span>
 <span class="s0">* know the stream in question returns an object of type</span>
 <span class="s0">* TypedWritableReferenceCount, allowing for easier reference count</span>
 <span class="s0">* management.  Note that the caller is still responsible for maintaining the</span>
 <span class="s0">* reference count on the return value.</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">static PointerTo&lt; TypedWritableReferenceCount &gt; TypedWritableReferenceCount::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr);</span>

<span class="s0">1063 14 get_class_type 0 4 1941 43 TypedWritableReferenceCount::get_class_type 0 1 93 0</span>
<span class="s0">68</span>
<span class="s0">static TypeHandle TypedWritableReferenceCount::get_class_type(void);</span>

<span class="s0">1064 28 ~TypedWritableReferenceCount 0 516 1941 57 TypedWritableReferenceCount::~TypedWritableReferenceCount 0 0 0</span>
<span class="s0">64</span>
<span class="s0">TypedWritableReferenceCount::~TypedWritableReferenceCount(void);</span>

<span class="s0">1065 37 upcast_to_TypedWritableReferenceCount 0 12 1943 53 BamCacheRecord::upcast_to_TypedWritableReferenceCount 0 1 118 57</span>
<span class="s0">upcast from BamCacheRecord to TypedWritableReferenceCount</span>
<span class="s0">89</span>
<span class="s0">TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">1066 26 downcast_to_BamCacheRecord 0 12 1941 55 TypedWritableReferenceCount::downcast_to_BamCacheRecord 0 0 59</span>
<span class="s0">downcast from TypedWritableReferenceCount to BamCacheRecord</span>
<span class="s0">78</span>
<span class="s0">BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void);</span>

<span class="s0">1067 24 upcast_to_LinkedListNode 0 12 1943 40 BamCacheRecord::upcast_to_LinkedListNode 0 0 44</span>
<span class="s0">upcast from BamCacheRecord to LinkedListNode</span>
<span class="s0">63</span>
<span class="s0">LinkedListNode *BamCacheRecord::upcast_to_LinkedListNode(void);</span>

<span class="s0">1068 26 downcast_to_BamCacheRecord 0 12 1944 42 LinkedListNode::downcast_to_BamCacheRecord 0 0 46</span>
<span class="s0">downcast from LinkedListNode to BamCacheRecord</span>
<span class="s0">65</span>
<span class="s0">BamCacheRecord *LinkedListNode::downcast_to_BamCacheRecord(void);</span>

<span class="s0">1069 15 ~BamCacheRecord 0 518 1943 31 BamCacheRecord::~BamCacheRecord 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">virtual BamCacheRecord::~BamCacheRecord(void);</span>

<span class="s0">1070 9 make_copy 0 4 1943 25 BamCacheRecord::make_copy 0 1 96 179</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a duplicate of the BamCacheRecord.  The duplicate will not have a</span>
 <span class="s0">* data pointer set, even though one may have been assigned to the original</span>
 <span class="s0">* via set_data().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline PointerTo&lt; BamCacheRecord &gt; BamCacheRecord::make_copy(void) const;</span>

<span class="s0">1071 11 operator == 0 4 1943 27 BamCacheRecord::operator == 0 1 97 0</span>
<span class="s0">75</span>
<span class="s0">inline bool BamCacheRecord::operator ==(BamCacheRecord const &amp;other) const;</span>

<span class="s0">1072 19 get_source_pathname 0 4 1943 35 BamCacheRecord::get_source_pathname 0 1 98 237</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the full pathname to the source file that originally generated this</span>
 <span class="s0">* cache request.  In some cases, for instance in the case of a of a multipage</span>
 <span class="s0">* texture like &quot;cube_#.png&quot;, this may not not a true filename on disk.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline Filename const &amp;BamCacheRecord::get_source_pathname(void) const;</span>

<span class="s0">1073 18 get_cache_filename 0 4 1943 34 BamCacheRecord::get_cache_filename 0 1 99 230</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the cache file as hashed from the source_pathname.</span>
 <span class="s0">* This will be relative to the root of the cache directory, and it will not</span>
 <span class="s0">* include any suffixes that may be appended to resolve hash conflicts.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline Filename const &amp;BamCacheRecord::get_cache_filename(void) const;</span>

<span class="s0">1074 20 get_source_timestamp 0 4 1943 36 BamCacheRecord::get_source_timestamp 0 1 100 204</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the file timestamp of the original source file that generated this</span>
 <span class="s0">* cache record, if available.  In some cases the original file timestamp is</span>
 <span class="s0">* not available, and this will return 0.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline time_t BamCacheRecord::get_source_timestamp(void) const;</span>

<span class="s0">1075 17 get_recorded_time 0 4 1943 33 BamCacheRecord::get_recorded_time 0 1 101 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time at which this particular record was recorded or updated.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline time_t BamCacheRecord::get_recorded_time(void) const;</span>

<span class="s0">1076 23 get_num_dependent_files 0 4 1943 39 BamCacheRecord::get_num_dependent_files 0 1 102 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of source files that contribute to the cache.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int BamCacheRecord::get_num_dependent_files(void) const;</span>

<span class="s0">1077 22 get_dependent_pathname 0 4 1943 38 BamCacheRecord::get_dependent_pathname 0 1 103 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the full pathname of the nth source files that contributes to the</span>
 <span class="s0">* cache.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline Filename const &amp;BamCacheRecord::get_dependent_pathname(int n) const;</span>

<span class="s0">1078 20 dependents_unchanged 0 4 1943 36 BamCacheRecord::dependents_unchanged 0 1 104 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all of the dependent files are still the same as when the</span>
 <span class="s0">* cache was recorded, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">bool BamCacheRecord::dependents_unchanged(void) const;</span>

<span class="s0">1079 21 clear_dependent_files 0 4 1943 37 BamCacheRecord::clear_dependent_files 0 1 105 80</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the list of files that contribute to the data in this record.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void BamCacheRecord::clear_dependent_files(void);</span>

<span class="s0">1080 18 add_dependent_file 0 4 1943 34 BamCacheRecord::add_dependent_file 0 2 106 107 309</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated file to the list of files that will be loaded to</span>
 <span class="s0">* generate the data in this record.  This should be called once for the</span>
 <span class="s0">* primary source file, and again for each secondary source file, if any.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Variant of add_dependent_file that takes an already opened VirtualFile.</span>
 <span class="s0">*/</span>
<span class="s0">132</span>
<span class="s0">void BamCacheRecord::add_dependent_file(Filename const &amp;pathname);</span>
<span class="s0">void BamCacheRecord::add_dependent_file(VirtualFile const *file);</span>

<span class="s0">1081 8 has_data 0 4 1943 24 BamCacheRecord::has_data 0 1 108 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this cache record has an in-memory data object associated--</span>
 <span class="s0">* that is, the object stored in the cache.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool BamCacheRecord::has_data(void) const;</span>

<span class="s0">1082 10 clear_data 0 4 1943 26 BamCacheRecord::clear_data 0 1 109 147</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the in-memory data object associated with this record, if any.</span>
 <span class="s0">* This does not affect the on-disk representation of the record.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void BamCacheRecord::clear_data(void);</span>

<span class="s0">1083 8 get_data 0 4 1943 24 BamCacheRecord::get_data 0 1 110 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the data stored in the record, or NULL if there is no</span>
 <span class="s0">* data.  The pointer is not removed from the record.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline TypedWritable *BamCacheRecord::get_data(void) const;</span>

<span class="s0">1084 12 extract_data 0 4 1943 28 BamCacheRecord::extract_data 0 0 416</span>
<span class="s0">/**</span>
 <span class="s0">* Fills ptr and ref_ptr with the two different-typed pointers to the same</span>
 <span class="s0">* object, the data stored within this record.  This transfers ownership of</span>
 <span class="s0">* the data pointer; the caller will be responsible for managing the reference</span>
 <span class="s0">* counts on this object subsequently.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the record contained any data (and the pointers have been</span>
 <span class="s0">* filled), false if it didn't (and the pointers are NULL).</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">inline bool BamCacheRecord::extract_data(TypedWritable *&amp;ptr, ReferenceCount *&amp;ref_ptr);</span>

<span class="s0">1085 8 set_data 0 4 1943 24 BamCacheRecord::set_data 0 4 111 112 113 114 916</span>
<span class="s0">/**</span>
 <span class="s0">* Stores a new data object on the record.  You should pass the same pointer</span>
 <span class="s0">* twice, to both parameters; this allows the C++ typecasting to automatically</span>
 <span class="s0">* convert the pointer into both a TypedWritable and a ReferenceCount pointer,</span>
 <span class="s0">* so that the BamCacheRecord object can reliably manage the reference counts.</span>
 <span class="s0">*</span>
 <span class="s0">* You may pass 0 or NULL as the second parameter.  If you do this, the</span>
 <span class="s0">* BamCacheRecord will not manage the object's reference count; it will be up</span>
 <span class="s0">* to you to ensure the object is not deleted during the lifetime of the</span>
 <span class="s0">* BamCacheRecord object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This variant on set_data() is provided to easily pass objects deriving from</span>
 <span class="s0">* TypedWritable.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This variant on set_data() is provided to easily pass objects deriving from</span>
 <span class="s0">* TypedWritableReferenceCount.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This variant on set_data() is provided just to allow Python code to pass a</span>
 <span class="s0">* 0 as the second parameter.</span>
 <span class="s0">*/</span>
<span class="s0">281</span>
<span class="s0">inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr);</span>
<span class="s0">inline void BamCacheRecord::set_data(TypedWritable *ptr);</span>
<span class="s0">inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr);</span>
<span class="s0">inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy);</span>

<span class="s0">1086 6 output 0 4 1943 22 BamCacheRecord::output 0 1 115 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void BamCacheRecord::output(std::ostream &amp;out) const;</span>

<span class="s0">1087 5 write 0 4 1943 21 BamCacheRecord::write 0 1 116 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void BamCacheRecord::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1088 14 get_class_type 0 4 1943 30 BamCacheRecord::get_class_type 0 1 117 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle BamCacheRecord::get_class_type(void);</span>

<span class="s0">1089 8 BamCache 0 260 1949 18 BamCache::BamCache 0 1 119 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">25</span>
<span class="s0">BamCache::BamCache(void);</span>

<span class="s0">1090 9 ~BamCache 0 516 1949 19 BamCache::~BamCache 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">26</span>
<span class="s0">BamCache::~BamCache(void);</span>

<span class="s0">1091 10 set_active 0 4 1949 20 BamCache::set_active 0 1 120 347</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the state of the active flag.  &quot;active&quot; means that the cache should</span>
 <span class="s0">* be consulted automatically on loads, &quot;not active&quot; means that objects should</span>
 <span class="s0">* be loaded directly without consulting the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* This represents the global flag.  Also see the individual cache_models,</span>
 <span class="s0">* cache_textures, cache_compressed_textures flags.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void BamCache::set_active(bool flag);</span>

<span class="s0">1092 10 get_active 0 4 1949 20 BamCache::get_active 0 1 121 381</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the BamCache is currently active, false if it is not.</span>
 <span class="s0">* &quot;active&quot; means that the cache should be consulted automatically on loads,</span>
 <span class="s0">* &quot;not active&quot; means that objects should be loaded directly without</span>
 <span class="s0">* consulting the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* This represents the global flag.  Also see the individual cache_models,</span>
 <span class="s0">* cache_textures, cache_compressed_textures flags.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool BamCache::get_active(void) const;</span>

<span class="s0">1093 16 set_cache_models 0 4 1949 26 BamCache::set_cache_models 0 1 122 118</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates whether model files (e.g.  egg files and bam files) will be</span>
 <span class="s0">* stored in the cache, as bam files.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void BamCache::set_cache_models(bool flag);</span>

<span class="s0">1094 16 get_cache_models 0 4 1949 26 BamCache::get_cache_models 0 1 123 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether model files (e.g.  egg files and bam files) will be stored</span>
 <span class="s0">* in the cache, as bam files.</span>
 <span class="s0">*</span>
 <span class="s0">* This also returns false if get_active() is false.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool BamCache::get_cache_models(void) const;</span>

<span class="s0">1095 18 set_cache_textures 0 4 1949 28 BamCache::set_cache_textures 0 1 124 101</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates whether texture files will be stored in the cache, as</span>
 <span class="s0">* uncompressed txo files.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void BamCache::set_cache_textures(bool flag);</span>

<span class="s0">1096 18 get_cache_textures 0 4 1949 28 BamCache::get_cache_textures 0 1 125 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether texture files (e.g.  egg files and bam files) will be</span>
 <span class="s0">* stored in the cache, as txo files.</span>
 <span class="s0">*</span>
 <span class="s0">* This also returns false if get_active() is false.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool BamCache::get_cache_textures(void) const;</span>

<span class="s0">1097 29 set_cache_compressed_textures 0 4 1949 39 BamCache::set_cache_compressed_textures 0 1 126 722</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates whether compressed texture files will be stored in the cache, as</span>
 <span class="s0">* compressed txo files.  The compressed data may either be generated in-CPU,</span>
 <span class="s0">* via the squish library, or it may be extracted from the GSG after the</span>
 <span class="s0">* texture has been loaded.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be set in conjunction with set_cache_textures(), or independently</span>
 <span class="s0">* of it.  If set_cache_textures() is true and this is false, all textures</span>
 <span class="s0">* will be cached in their uncompressed form.  If set_cache_textures() is</span>
 <span class="s0">* false and this is true, only compressed textures will be cached, and they</span>
 <span class="s0">* will be cached in their compressed form.  If both are true, all textures</span>
 <span class="s0">* will be cached, in their uncompressed or compressed form appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void BamCache::set_cache_compressed_textures(bool flag);</span>

<span class="s0">1098 29 get_cache_compressed_textures 0 4 1949 39 BamCache::get_cache_compressed_textures 0 1 127 202</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether compressed texture files will be stored in the cache, as</span>
 <span class="s0">* compressed txo files.  See set_cache_compressed_textures().</span>
 <span class="s0">*</span>
 <span class="s0">* This also returns false if get_active() is false.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool BamCache::get_cache_compressed_textures(void) const;</span>

<span class="s0">1099 26 set_cache_compiled_shaders 0 4 1949 36 BamCache::set_cache_compiled_shaders 0 1 128 184</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates whether compiled shader programs will be stored in the cache, as</span>
 <span class="s0">* binary .sho files.  This may not be supported by all shader languages or</span>
 <span class="s0">* graphics renderers.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void BamCache::set_cache_compiled_shaders(bool flag);</span>

<span class="s0">1100 26 get_cache_compiled_shaders 0 4 1949 36 BamCache::get_cache_compiled_shaders 0 1 129 196</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether compiled shader programs will be stored in the cache, as</span>
 <span class="s0">* binary .txo files.  See set_cache_compiled_shaders().</span>
 <span class="s0">*</span>
 <span class="s0">* This also returns false if get_active() is false.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool BamCache::get_cache_compiled_shaders(void) const;</span>

<span class="s0">1101 8 set_root 0 4 1949 18 BamCache::set_root 0 1 130 372</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the current root pathname of the cache.  This specifies where the</span>
 <span class="s0">* cache files are stored on disk.  This should name a directory that is on a</span>
 <span class="s0">* disk local to the machine (not on a network-mounted disk), for instance,</span>
 <span class="s0">* /tmp/panda-cache or /c/panda-cache.</span>
 <span class="s0">*</span>
 <span class="s0">* If the directory does not already exist, it will be created as a result of</span>
 <span class="s0">* this call.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void BamCache::set_root(Filename const &amp;root);</span>

<span class="s0">1102 8 get_root 0 4 1949 18 BamCache::get_root 0 1 131 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current root pathname of the cache.  See set_root().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline Filename BamCache::get_root(void) const;</span>

<span class="s0">1103 14 set_flush_time 0 4 1949 24 BamCache::set_flush_time 0 1 132 86</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the time in seconds between automatic flushes of the cache index.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void BamCache::set_flush_time(int flush_time);</span>

<span class="s0">1104 14 get_flush_time 0 4 1949 24 BamCache::get_flush_time 0 1 133 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time in seconds between automatic flushes of the cache index.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int BamCache::get_flush_time(void) const;</span>

<span class="s0">1105 20 set_cache_max_kbytes 0 4 1949 30 BamCache::set_cache_max_kbytes 0 1 134 430</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the maximum size, in kilobytes, which the cache is allowed to</span>
 <span class="s0">* grow to.  If a newly cached file would exceed this size, an older file is</span>
 <span class="s0">* removed from the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that in the case of multiple different processes simultaneously</span>
 <span class="s0">* operating on the same cache directory, the actual cache size may slightly</span>
 <span class="s0">* exceed this value from time to time due to latency in checking between the</span>
 <span class="s0">* processes.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void BamCache::set_cache_max_kbytes(int max_kbytes);</span>

<span class="s0">1106 20 get_cache_max_kbytes 0 4 1949 30 BamCache::get_cache_max_kbytes 0 1 135 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum size, in kilobytes, which the cache is allowed to grow</span>
 <span class="s0">* to.  See set_cache_max_kbytes().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int BamCache::get_cache_max_kbytes(void) const;</span>

<span class="s0">1107 13 set_read_only 0 4 1949 23 BamCache::set_read_only 0 1 136 252</span>
<span class="s0">/**</span>
 <span class="s0">* Can be used to put the cache in read-only mode, or take it out of read-only</span>
 <span class="s0">* mode.  Note that if you put it into read-write mode, and it discovers that</span>
 <span class="s0">* it does not have write access, it will put itself right back into read-only</span>
 <span class="s0">* mode.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void BamCache::set_read_only(bool ro);</span>

<span class="s0">1108 13 get_read_only 0 4 1949 23 BamCache::get_read_only 0 1 137 230</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the cache is in read-only mode.  Normally, the cache starts</span>
 <span class="s0">* in read-write mode.  It can put itself into read-only mode automatically if</span>
 <span class="s0">* it discovers that it does not have write access to the cache.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool BamCache::get_read_only(void) const;</span>

<span class="s0">1109 6 lookup 0 4 1949 16 BamCache::lookup 0 1 138 782</span>
<span class="s0">/**</span>
 <span class="s0">* Looks up a file in the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is cacheable, then regardless of whether the file is found in</span>
 <span class="s0">* the cache or not, this returns a BamCacheRecord.  On the other hand, if the</span>
 <span class="s0">* file cannot be cached, returns NULL.</span>
 <span class="s0">*</span>
 <span class="s0">* If record-&gt;has_data() returns true, then the file was found in the cache,</span>
 <span class="s0">* and you may call record-&gt;extract_data() to get the object.  If</span>
 <span class="s0">* record-&gt;has_data() returns false, then the file was not found in the cache</span>
 <span class="s0">* or the cache was stale; and you should reload the source file (calling</span>
 <span class="s0">* record-&gt;add_dependent_file() for each file loaded, including the original</span>
 <span class="s0">* source file), and then call record-&gt;set_data() to record the resulting</span>
 <span class="s0">* loaded object; and finally, you should call store() to write the cached</span>
 <span class="s0">* record to disk.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">PointerTo&lt; BamCacheRecord &gt; BamCache::lookup(Filename const &amp;source_filename, std::string const &amp;cache_extension);</span>

<span class="s0">1110 5 store 0 4 1949 15 BamCache::store 0 1 139 212</span>
<span class="s0">/**</span>
 <span class="s0">* Flushes a cache entry to disk.  You must have retrieved the cache record</span>
 <span class="s0">* via a prior call to lookup(), and then stored the data via</span>
 <span class="s0">* record-&gt;set_data().  Returns true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">bool BamCache::store(BamCacheRecord *record);</span>

<span class="s0">1111 20 consider_flush_index 0 4 1949 30 BamCache::consider_flush_index 0 1 140 92</span>
<span class="s0">/**</span>
 <span class="s0">* Flushes the index if enough time has elapsed since the index was last</span>
 <span class="s0">* flushed.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void BamCache::consider_flush_index(void);</span>

<span class="s0">1112 11 flush_index 0 4 1949 21 BamCache::flush_index 0 1 141 48</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures the index is written to disk.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void BamCache::flush_index(void);</span>

<span class="s0">1113 10 list_index 0 4 1949 20 BamCache::list_index 0 1 142 63</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the contents of the index to standard output.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">void BamCache::list_index(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1114 14 get_global_ptr 0 4 1949 24 BamCache::get_global_ptr 0 1 143 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global BamCache object, which is used</span>
 <span class="s0">* automatically by the ModelPool and TexturePool.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline BamCache *BamCache::get_global_ptr(void);</span>

<span class="s0">1115 27 consider_flush_global_index 0 4 1949 37 BamCache::consider_flush_global_index 0 1 144 84</span>
<span class="s0">/**</span>
 <span class="s0">* If there is a global BamCache object, calls consider_flush_index() on it.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static inline void BamCache::consider_flush_global_index(void);</span>

<span class="s0">1116 18 flush_global_index 0 4 1949 28 BamCache::flush_global_index 0 1 145 75</span>
<span class="s0">/**</span>
 <span class="s0">* If there is a global BamCache object, calls flush_index() on it.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">static inline void BamCache::flush_global_index(void);</span>

<span class="s0">1117 8 BamEnums 0 260 1950 18 BamEnums::BamEnums 0 2 146 147 0</span>
<span class="s0">97</span>
<span class="s0">inline BamEnums::BamEnums(void) = default;</span>
<span class="s0">inline BamEnums::BamEnums(BamEnums const &amp;) = default;</span>

<span class="s0">1118 9 ~BamEnums 0 516 1950 19 BamEnums::~BamEnums 0 0 0</span>
<span class="s0">26</span>
<span class="s0">BamEnums::~BamEnums(void);</span>

<span class="s0">1119 13 LoaderOptions 0 260 1954 28 LoaderOptions::LoaderOptions 0 3 148 149 150 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">247</span>
<span class="s0">LoaderOptions::LoaderOptions(int flags = (::LoaderOptions::LF_search | ::LoaderOptions::LF_report_errors));</span>
<span class="s0">constexpr LoaderOptions::LoaderOptions(int flags, int texture_flags);</span>
<span class="s0">inline LoaderOptions::LoaderOptions(LoaderOptions const &amp;) = default;</span>

<span class="s0">1120 9 set_flags 0 4 1954 24 LoaderOptions::set_flags 0 1 151 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void LoaderOptions::set_flags(int flags);</span>

<span class="s0">1121 9 get_flags 0 4 1954 24 LoaderOptions::get_flags 0 1 152 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int LoaderOptions::get_flags(void) const;</span>

<span class="s0">1122 17 set_texture_flags 0 4 1954 32 LoaderOptions::set_texture_flags 0 1 153 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void LoaderOptions::set_texture_flags(int flags);</span>

<span class="s0">1123 17 get_texture_flags 0 4 1954 32 LoaderOptions::get_texture_flags 0 1 154 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int LoaderOptions::get_texture_flags(void) const;</span>

<span class="s0">1124 21 set_texture_num_views 0 4 1954 36 LoaderOptions::set_texture_num_views 0 1 155 459</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the expected number of views to load for the texture.  This is</span>
 <span class="s0">* ignored unless TF_multiview is included in texture_flags.  This must be</span>
 <span class="s0">* specified when loading a 3-d multiview texture or 2-d texture array, in</span>
 <span class="s0">* which case it is used to differentiate z levels from separate views; it</span>
 <span class="s0">* may be zero in the case of 2-d textures or cube maps, in which case the</span>
 <span class="s0">* number of views can be inferred from the number of images found on disk.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LoaderOptions::set_texture_num_views(int num_views);</span>

<span class="s0">1125 21 get_texture_num_views 0 4 1954 36 LoaderOptions::get_texture_num_views 0 1 156 39</span>
<span class="s0">/**</span>
 <span class="s0">* See set_texture_num_views().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int LoaderOptions::get_texture_num_views(void) const;</span>

<span class="s0">1126 22 set_auto_texture_scale 0 4 1954 37 LoaderOptions::set_auto_texture_scale 0 1 157 209</span>
<span class="s0">/**</span>
 <span class="s0">* Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a</span>
 <span class="s0">* texture is scaled from disk when it is subsequently loaded.  Set it to</span>
 <span class="s0">* ATS_unspecified to restore the default behavior.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale);</span>

<span class="s0">1127 22 get_auto_texture_scale 0 4 1954 37 LoaderOptions::get_auto_texture_scale 0 1 158 40</span>
<span class="s0">/**</span>
 <span class="s0">* See set_auto_texture_scale().</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const;</span>

<span class="s0">1128 6 output 0 4 1954 21 LoaderOptions::output 0 1 159 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void LoaderOptions::output(std::ostream &amp;out) const;</span>

<span class="s0">1129 14 ~LoaderOptions 0 516 1954 29 LoaderOptions::~LoaderOptions 0 0 0</span>
<span class="s0">36</span>
<span class="s0">LoaderOptions::~LoaderOptions(void);</span>

<span class="s0">1130 9 BamReader 0 260 1957 20 BamReader::BamReader 0 1 160 50</span>
<span class="s0">// The primary interface for a caller.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">explicit BamReader::BamReader(DatagramGenerator *source = nullptr);</span>

<span class="s0">1131 10 ~BamReader 0 516 1957 21 BamReader::~BamReader 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">BamReader::~BamReader(void);</span>

<span class="s0">1132 10 set_source 0 4 1957 21 BamReader::set_source 0 1 161 142</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the source of future datagrams for this BamReader.  This also</span>
 <span class="s0">* implicitly calls init() if it has not already been called.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void BamReader::set_source(DatagramGenerator *source);</span>

<span class="s0">1133 10 get_source 0 4 1957 21 BamReader::get_source 0 1 162 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current source of the BamReader as set by set_source() or the</span>
 <span class="s0">* constructor.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline DatagramGenerator *BamReader::get_source(void);</span>

<span class="s0">1134 4 init 0 4 1957 15 BamReader::init 0 1 163 210</span>
<span class="s0">/**</span>
 <span class="s0">* Initializes the BamReader prior to reading any objects from its source.</span>
 <span class="s0">* This includes reading the Bam header.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns true if the BamReader successfully initialized, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">27</span>
<span class="s0">bool BamReader::init(void);</span>

<span class="s0">1135 12 set_aux_data 0 4 1957 23 BamReader::set_aux_data 0 1 164 1007</span>
<span class="s0">/**</span>
 <span class="s0">* Associates an arbitrary block of data with the indicated object (or NULL),</span>
 <span class="s0">* and the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* This is intended to provide a place for temporary storage for objects</span>
 <span class="s0">* reading themselves from the bam file.  To use it, inherit from</span>
 <span class="s0">* BamReader::AuxData and store whatever data you like there.  Then associate</span>
 <span class="s0">* your AuxData with the object as it is being read with set_aux_data().  You</span>
 <span class="s0">* may later set the aux data to NULL to remove it; or it will automatically</span>
 <span class="s0">* be removed (and deleted) after finalize() is called for the object in</span>
 <span class="s0">* question.</span>
 <span class="s0">*</span>
 <span class="s0">* If the TypedWritable pointer is NULL, the the aux data is stored globally</span>
 <span class="s0">* for the BamReader in general.  This pointer is available to any bam</span>
 <span class="s0">* objects, and will not be automatically removed until the BamReader itself</span>
 <span class="s0">* destructs.</span>
 <span class="s0">*</span>
 <span class="s0">* In either case, the name is just an arbitrary user-defined key.  If there</span>
 <span class="s0">* is already a data pointer stored for the obj/name pair, that data pointer</span>
 <span class="s0">* will be replaced (and deleted).</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">void BamReader::set_aux_data(TypedWritable *obj, std::string const &amp;name, BamReader::AuxData *data);</span>

<span class="s0">1136 12 get_aux_data 0 4 1957 23 BamReader::get_aux_data 0 1 165 173</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer previously associated with the bam reader by a previous</span>
 <span class="s0">* call to set_aux_data(), or NULL if data with the indicated key has not been</span>
 <span class="s0">* set.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">BamReader::AuxData *BamReader::get_aux_data(TypedWritable *obj, std::string const &amp;name) const;</span>

<span class="s0">1137 12 get_filename 0 4 1957 23 BamReader::get_filename 0 1 166 199</span>
<span class="s0">/**</span>
 <span class="s0">* If a BAM is a file, then the BamReader should contain the name of the file.</span>
 <span class="s0">* This enables the reader to interpret pathnames in the BAM as relative to</span>
 <span class="s0">* the directory containing the BAM.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline Filename const &amp;BamReader::get_filename(void) const;</span>

<span class="s0">1138 18 get_loader_options 0 4 1957 29 BamReader::get_loader_options 0 1 167 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the LoaderOptions passed to the loader when the model was</span>
 <span class="s0">* requested, if any.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline LoaderOptions const &amp;BamReader::get_loader_options(void) const;</span>

<span class="s0">1139 18 set_loader_options 0 4 1957 29 BamReader::set_loader_options 0 1 168 58</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the LoaderOptions for this BamReader.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void BamReader::set_loader_options(LoaderOptions const &amp;options);</span>

<span class="s0">1140 11 read_object 0 4 1957 22 BamReader::read_object 0 1 169 1393</span>
<span class="s0">/**</span>
 <span class="s0">* Reads a single object from the Bam file.  If the object type is known, a</span>
 <span class="s0">* new object of the appropriate type is created and returned; otherwise, NULL</span>
 <span class="s0">* is returned.  NULL is also returned when the end of the file is reached.</span>
 <span class="s0">* is_eof() may be called to differentiate between these two cases.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be called repeatedly to extract out all the objects in the Bam</span>
 <span class="s0">* file, but typically (especially for scene graph files, indicated with the</span>
 <span class="s0">* .bam extension), only one object is retrieved directly from the Bam file:</span>
 <span class="s0">* the root of the scene graph.  The remaining objects will all be retrieved</span>
 <span class="s0">* recursively by the first object.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the object returned may not yet be complete.  In particular, some</span>
 <span class="s0">* of its pointers may not be filled in; you must call resolve() to fill in</span>
 <span class="s0">* all the available pointers before you can safely use any objects returned</span>
 <span class="s0">* by read_object().</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of read_object() requires the caller to know what type of</span>
 <span class="s0">* object it has received in order to properly manage the reference counts.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads a single object from the Bam file.</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of read_object() returns both a TypedWritable and a</span>
 <span class="s0">* ReferenceCount pointer to the same object, so the reference count may be</span>
 <span class="s0">* tracked reliably, without having to know precisely what type of object we</span>
 <span class="s0">* have.</span>
 <span class="s0">* @return true on success, or false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">TypedWritable *BamReader::read_object(void);</span>
<span class="s0">bool BamReader::read_object(TypedWritable *&amp;ptr, ReferenceCount *&amp;ref_ptr);</span>

<span class="s0">1141 6 is_eof 0 4 1957 17 BamReader::is_eof 0 1 170 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the reader has reached end-of-file, false otherwise.  This</span>
 <span class="s0">* call is only valid after a call to read_object().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool BamReader::is_eof(void) const;</span>

<span class="s0">1142 7 resolve 0 4 1957 18 BamReader::resolve 0 1 171 565</span>
<span class="s0">/**</span>
 <span class="s0">* This may be called at any time during processing of the Bam file to resolve</span>
 <span class="s0">* all the known pointers so far.  It is usually called at the end of the</span>
 <span class="s0">* processing, after all objects have been read, which is generally the best</span>
 <span class="s0">* time to call it.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called at least once after reading a particular object via</span>
 <span class="s0">* get_object() in order to validate that object.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if all objects have been resolved, or false if</span>
 <span class="s0">* some objects are still outstanding (in which case you will need to call</span>
 <span class="s0">* resolve() again later).</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">bool BamReader::resolve(void);</span>

<span class="s0">1143 14 change_pointer 0 4 1957 25 BamReader::change_pointer 0 1 172 406</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that an object recently read from the bam stream should be</span>
 <span class="s0">* replaced with a new object.  Any future occurrences of the original object</span>
 <span class="s0">* in the stream will henceforth return the new object instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the replacement was successfully made, or false</span>
 <span class="s0">* if the object was not read from the stream (or if change_pointer had</span>
 <span class="s0">* already been called on it).</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer);</span>

<span class="s0">1144 18 get_file_major_ver 0 4 1957 29 BamReader::get_file_major_ver 0 1 173 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the major version number of the Bam file currently being read.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int BamReader::get_file_major_ver(void) const;</span>

<span class="s0">1145 18 get_file_minor_ver 0 4 1957 29 BamReader::get_file_minor_ver 0 1 174 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minor version number of the Bam file currently being read.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int BamReader::get_file_minor_ver(void) const;</span>

<span class="s0">1146 15 get_file_endian 0 4 1957 26 BamReader::get_file_endian 0 1 175 254</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the endian preference indicated by the Bam file currently being</span>
 <span class="s0">* read.  This does not imply that every number is stored using the indicated</span>
 <span class="s0">* convention, but individual objects may choose to respect this flag when</span>
 <span class="s0">* recording data.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline BamEnums::BamEndian BamReader::get_file_endian(void) const;</span>

<span class="s0">1147 24 get_file_stdfloat_double 0 4 1957 35 BamReader::get_file_stdfloat_double 0 1 176 220</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the file stores all &quot;standard&quot; floats as 64-bit doubles, or</span>
 <span class="s0">* false if they are 32-bit floats.  This is determined by the compilation</span>
 <span class="s0">* flags of the version of Panda that generated this file.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool BamReader::get_file_stdfloat_double(void) const;</span>

<span class="s0">1148 21 get_current_major_ver 0 4 1957 32 BamReader::get_current_major_ver 0 1 177 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the major version number of Bam files supported by the current code</span>
 <span class="s0">* base.  This must match get_file_major_ver() in order to successfully read a</span>
 <span class="s0">* file.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int BamReader::get_current_major_ver(void) const;</span>

<span class="s0">1149 21 get_current_minor_ver 0 4 1957 32 BamReader::get_current_minor_ver 0 1 178 184</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minor version number of Bam files supported by the current code</span>
 <span class="s0">* base.  This must match or exceed get_file_minor_ver() in order to</span>
 <span class="s0">* successfully read a file.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int BamReader::get_current_minor_ver(void) const;</span>

<span class="s0">1150 16 get_file_version 0 4 1957 27 BamReader::get_file_version 0 1 179 0</span>
<span class="s0">50</span>
<span class="s0">PyObject *BamReader::get_file_version(void) const;</span>

<span class="s0">1151 16 register_factory 0 4 1957 27 BamReader::register_factory 0 1 180 208</span>
<span class="s0">/**</span>
 <span class="s0">* Registers a factory function that is called when an object of the given</span>
 <span class="s0">* type is encountered within the .bam stream.</span>
 <span class="s0">*</span>
 <span class="s0">* @param user_data an optional pointer to be passed along to the function.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static void BamReader::register_factory(TypeHandle handle, PyObject *func);</span>

<span class="s0">1152 9 BamWriter 0 260 1964 20 BamWriter::BamWriter 0 2 181 182 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">explicit BamWriter::BamWriter(DatagramSink *target = nullptr);</span>
<span class="s0">inline BamWriter::BamWriter(BamWriter const &amp;) = default;</span>

<span class="s0">1153 10 ~BamWriter 0 516 1964 21 BamWriter::~BamWriter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">BamWriter::~BamWriter(void);</span>

<span class="s0">1154 10 set_target 0 4 1964 21 BamWriter::set_target 0 1 183 153</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the destination of future datagrams written by the BamWriter.  This</span>
 <span class="s0">* also implicitly calls init() if it has not already been called.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void BamWriter::set_target(DatagramSink *target);</span>

<span class="s0">1155 10 get_target 0 4 1964 21 BamWriter::get_target 0 1 184 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current target of the BamWriter as set by set_target() or the</span>
 <span class="s0">* constructor.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline DatagramSink *BamWriter::get_target(void);</span>

<span class="s0">1156 4 init 0 4 1964 15 BamWriter::init 0 1 185 220</span>
<span class="s0">/**</span>
 <span class="s0">* Initializes the BamWriter prior to writing any objects to its output</span>
 <span class="s0">* stream.  This includes writing out the Bam header.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns true if the BamWriter successfully initialized, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">27</span>
<span class="s0">bool BamWriter::init(void);</span>

<span class="s0">1157 12 get_filename 0 4 1964 23 BamWriter::get_filename 0 1 186 197</span>
<span class="s0">/**</span>
 <span class="s0">* If a BAM is a file, then the BamWriter should contain the name of the file.</span>
 <span class="s0">* This enables the writer to convert pathnames in the BAM to relative to the</span>
 <span class="s0">* directory containing the BAM.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline Filename const &amp;BamWriter::get_filename(void) const;</span>

<span class="s0">1158 12 write_object 0 4 1964 23 BamWriter::write_object 0 1 187 736</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a single object to the Bam file, so that the</span>
 <span class="s0">* BamReader::read_object() can later correctly restore the object and all its</span>
 <span class="s0">* pointers.</span>
 <span class="s0">*</span>
 <span class="s0">* This implicitly also writes any additional objects this object references</span>
 <span class="s0">* (if they haven't already been written), so that pointers may be fully</span>
 <span class="s0">* resolved.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be called repeatedly to write a sequence of objects to the Bam</span>
 <span class="s0">* file, but typically (especially for scene graph files, indicated with the</span>
 <span class="s0">* .bam extension), only one object is written directly from the Bam file: the</span>
 <span class="s0">* root of the scene graph.  The remaining objects will all be written</span>
 <span class="s0">* recursively by the first object.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the object is successfully written, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool BamWriter::write_object(TypedWritable const *obj);</span>

<span class="s0">1159 10 has_object 0 4 1964 21 BamWriter::has_object 0 1 188 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the object has previously been written (or at least</span>
 <span class="s0">* requested to be written) to the bam file, or false if we've never heard of</span>
 <span class="s0">* it before.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">bool BamWriter::has_object(TypedWritable const *obj) const;</span>

<span class="s0">1160 5 flush 0 4 1964 16 BamWriter::flush 0 1 189 85</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that all data written thus far is manifested on the output stream.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">void BamWriter::flush(void);</span>

<span class="s0">1161 18 get_file_major_ver 0 4 1964 29 BamWriter::get_file_major_ver 0 1 190 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the major version number of the Bam file currently being written.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int BamWriter::get_file_major_ver(void) const;</span>

<span class="s0">1162 18 get_file_minor_ver 0 4 1964 29 BamWriter::get_file_minor_ver 0 1 191 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minor version number of the Bam file currently being written.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int BamWriter::get_file_minor_ver(void) const;</span>

<span class="s0">1163 18 set_file_minor_ver 0 4 1964 29 BamWriter::set_file_minor_ver 0 1 192 232</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the minor .bam version to write.  This should be called before</span>
 <span class="s0">* init().  Each Panda version has only a fairly narrow range of versions it</span>
 <span class="s0">* is able to write; consult the .bam documentation for more information.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void BamWriter::set_file_minor_ver(int minor_ver);</span>

<span class="s0">1164 15 get_file_endian 0 4 1964 26 BamWriter::get_file_endian 0 1 193 257</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the endian preference indicated by the Bam file currently being</span>
 <span class="s0">* written.  This does not imply that every number is stored using the</span>
 <span class="s0">* indicated convention, but individual objects may choose to respect this</span>
 <span class="s0">* flag when recording data.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline BamEnums::BamEndian BamWriter::get_file_endian(void) const;</span>

<span class="s0">1165 24 get_file_stdfloat_double 0 4 1964 35 BamWriter::get_file_stdfloat_double 0 1 194 248</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the file will store all &quot;standard&quot; floats as 64-bit</span>
 <span class="s0">* doubles, or false if they are 32-bit floats.  This isn't runtime settable;</span>
 <span class="s0">* it's based on the compilation flags of the version of Panda that generated</span>
 <span class="s0">* this file.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool BamWriter::get_file_stdfloat_double(void) const;</span>

<span class="s0">1166 21 get_file_texture_mode 0 4 1964 32 BamWriter::get_file_texture_mode 0 1 195 196</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the BamTextureMode preference indicated by the Bam file currently</span>
 <span class="s0">* being written.  Texture objects written to this Bam file will be encoded</span>
 <span class="s0">* according to the specified mode.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const;</span>

<span class="s0">1167 21 set_file_texture_mode 0 4 1964 32 BamWriter::set_file_texture_mode 0 1 196 187</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the BamTextureMode preference for the Bam file currently being</span>
 <span class="s0">* written.  Texture objects written to this Bam file will be encoded</span>
 <span class="s0">* according to the specified mode.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode);</span>

<span class="s0">1168 13 get_root_node 0 4 1964 24 BamWriter::get_root_node 0 1 197 165</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the root node of the part of the scene graph we are currently</span>
 <span class="s0">* writing out.  This is used for determining what to make NodePaths relative</span>
 <span class="s0">* to.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline TypedWritable *BamWriter::get_root_node(void) const;</span>

<span class="s0">1169 13 set_root_node 0 4 1964 24 BamWriter::set_root_node 0 1 198 160</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the root node of the part of the scene graph we are currently writing</span>
 <span class="s0">* out.  NodePaths written to this bam file will be relative to this node.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void BamWriter::set_root_node(TypedWritable *root_node);</span>

<span class="s0">1170 7 BitMask 0 260 1967 32 BitMask&lt; uint16_t, 16 &gt;::BitMask 0 3 199 200 201 0</span>
<span class="s0">215</span>
<span class="s0">constexpr BitMask&lt; uint16_t, 16 &gt;::BitMask(void) = default;</span>
<span class="s0">inline constexpr BitMask&lt; uint16_t, 16 &gt;::BitMask(uint16_t init_value);</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt;::BitMask(BitMask&lt; uint16_t, 16 &gt; const &amp;) = default;</span>

<span class="s0">1171 6 all_on 0 4 1967 31 BitMask&lt; uint16_t, 16 &gt;::all_on 0 1 202 0</span>
<span class="s0">76</span>
<span class="s0">static inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::all_on(void);</span>

<span class="s0">1172 7 all_off 0 4 1967 32 BitMask&lt; uint16_t, 16 &gt;::all_off 0 1 203 0</span>
<span class="s0">77</span>
<span class="s0">static inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::all_off(void);</span>

<span class="s0">1173 8 lower_on 0 4 1967 33 BitMask&lt; uint16_t, 16 &gt;::lower_on 0 1 204 0</span>
<span class="s0">85</span>
<span class="s0">static inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::lower_on(int on_bits);</span>

<span class="s0">1174 3 bit 0 4 1967 28 BitMask&lt; uint16_t, 16 &gt;::bit 0 1 205 0</span>
<span class="s0">78</span>
<span class="s0">static inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::bit(int index);</span>

<span class="s0">1175 5 range 0 4 1967 30 BitMask&lt; uint16_t, 16 &gt;::range 0 1 206 0</span>
<span class="s0">92</span>
<span class="s0">static inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::range(int low_bit, int size);</span>

<span class="s0">1176 16 has_max_num_bits 0 4 1967 41 BitMask&lt; uint16_t, 16 &gt;::has_max_num_bits 0 1 207 0</span>
<span class="s0">70</span>
<span class="s0">static constexpr bool BitMask&lt; uint16_t, 16 &gt;::has_max_num_bits(void);</span>

<span class="s0">1177 16 get_max_num_bits 0 4 1967 41 BitMask&lt; uint16_t, 16 &gt;::get_max_num_bits 0 1 208 0</span>
<span class="s0">69</span>
<span class="s0">static constexpr int BitMask&lt; uint16_t, 16 &gt;::get_max_num_bits(void);</span>

<span class="s0">1178 12 get_num_bits 0 4 1967 37 BitMask&lt; uint16_t, 16 &gt;::get_num_bits 0 1 209 0</span>
<span class="s0">64</span>
<span class="s0">constexpr int BitMask&lt; uint16_t, 16 &gt;::get_num_bits(void) const;</span>

<span class="s0">1179 7 get_bit 0 4 1967 32 BitMask&lt; uint16_t, 16 &gt;::get_bit 0 1 210 0</span>
<span class="s0">62</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::get_bit(int index) const;</span>

<span class="s0">1180 7 set_bit 0 4 1967 32 BitMask&lt; uint16_t, 16 &gt;::set_bit 0 1 211 0</span>
<span class="s0">56</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::set_bit(int index);</span>

<span class="s0">1181 9 clear_bit 0 4 1967 34 BitMask&lt; uint16_t, 16 &gt;::clear_bit 0 1 212 0</span>
<span class="s0">58</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::clear_bit(int index);</span>

<span class="s0">1182 10 set_bit_to 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::set_bit_to 0 1 213 0</span>
<span class="s0">71</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::set_bit_to(int index, bool value);</span>

<span class="s0">1183 7 is_zero 0 4 1967 32 BitMask&lt; uint16_t, 16 &gt;::is_zero 0 1 214 0</span>
<span class="s0">57</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::is_zero(void) const;</span>

<span class="s0">1184 9 is_all_on 0 4 1967 34 BitMask&lt; uint16_t, 16 &gt;::is_all_on 0 1 215 0</span>
<span class="s0">59</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::is_all_on(void) const;</span>

<span class="s0">1185 7 extract 0 4 1967 32 BitMask&lt; uint16_t, 16 &gt;::extract 0 1 216 0</span>
<span class="s0">78</span>
<span class="s0">inline uint16_t BitMask&lt; uint16_t, 16 &gt;::extract(int low_bit, int size) const;</span>

<span class="s0">1186 5 store 0 4 1967 30 BitMask&lt; uint16_t, 16 &gt;::store 0 1 217 0</span>
<span class="s0">82</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::store(uint16_t value, int low_bit, int size);</span>

<span class="s0">1187 10 has_any_of 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::has_any_of 0 1 218 0</span>
<span class="s0">77</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::has_any_of(int low_bit, int size) const;</span>

<span class="s0">1188 10 has_all_of 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::has_all_of 0 1 219 0</span>
<span class="s0">77</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::has_all_of(int low_bit, int size) const;</span>

<span class="s0">1189 9 set_range 0 4 1967 34 BitMask&lt; uint16_t, 16 &gt;::set_range 0 1 220 0</span>
<span class="s0">70</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::set_range(int low_bit, int size);</span>

<span class="s0">1190 11 clear_range 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::clear_range 0 1 221 0</span>
<span class="s0">72</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::clear_range(int low_bit, int size);</span>

<span class="s0">1191 12 set_range_to 0 4 1967 37 BitMask&lt; uint16_t, 16 &gt;::set_range_to 0 1 222 0</span>
<span class="s0">85</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::set_range_to(bool value, int low_bit, int size);</span>

<span class="s0">1192 8 get_word 0 4 1967 33 BitMask&lt; uint16_t, 16 &gt;::get_word 0 1 223 0</span>
<span class="s0">62</span>
<span class="s0">inline uint16_t BitMask&lt; uint16_t, 16 &gt;::get_word(void) const;</span>

<span class="s0">1193 8 set_word 0 4 1967 33 BitMask&lt; uint16_t, 16 &gt;::set_word 0 1 224 0</span>
<span class="s0">62</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::set_word(uint16_t value);</span>

<span class="s0">1194 15 get_num_on_bits 0 4 1967 40 BitMask&lt; uint16_t, 16 &gt;::get_num_on_bits 0 1 225 0</span>
<span class="s0">64</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::get_num_on_bits(void) const;</span>

<span class="s0">1195 16 get_num_off_bits 0 4 1967 41 BitMask&lt; uint16_t, 16 &gt;::get_num_off_bits 0 1 226 0</span>
<span class="s0">65</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::get_num_off_bits(void) const;</span>

<span class="s0">1196 17 get_lowest_on_bit 0 4 1967 42 BitMask&lt; uint16_t, 16 &gt;::get_lowest_on_bit 0 1 227 0</span>
<span class="s0">66</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::get_lowest_on_bit(void) const;</span>

<span class="s0">1197 18 get_lowest_off_bit 0 4 1967 43 BitMask&lt; uint16_t, 16 &gt;::get_lowest_off_bit 0 1 228 0</span>
<span class="s0">67</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::get_lowest_off_bit(void) const;</span>

<span class="s0">1198 18 get_highest_on_bit 0 4 1967 43 BitMask&lt; uint16_t, 16 &gt;::get_highest_on_bit 0 1 229 0</span>
<span class="s0">67</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::get_highest_on_bit(void) const;</span>

<span class="s0">1199 19 get_highest_off_bit 0 4 1967 44 BitMask&lt; uint16_t, 16 &gt;::get_highest_off_bit 0 1 230 0</span>
<span class="s0">68</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::get_highest_off_bit(void) const;</span>

<span class="s0">1200 29 get_next_higher_different_bit 0 4 1967 54 BitMask&lt; uint16_t, 16 &gt;::get_next_higher_different_bit 0 1 231 0</span>
<span class="s0">85</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::get_next_higher_different_bit(int low_bit) const;</span>

<span class="s0">1201 15 invert_in_place 0 4 1967 40 BitMask&lt; uint16_t, 16 &gt;::invert_in_place 0 1 232 0</span>
<span class="s0">59</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::invert_in_place(void);</span>

<span class="s0">1202 18 has_bits_in_common 0 4 1967 43 BitMask&lt; uint16_t, 16 &gt;::has_bits_in_common 0 1 233 0</span>
<span class="s0">100</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::has_bits_in_common(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1203 5 clear 0 4 1967 30 BitMask&lt; uint16_t, 16 &gt;::clear 0 1 234 0</span>
<span class="s0">49</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::clear(void);</span>

<span class="s0">1204 6 output 0 4 1967 31 BitMask&lt; uint16_t, 16 &gt;::output 0 1 235 0</span>
<span class="s0">62</span>
<span class="s0">void BitMask&lt; uint16_t, 16 &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">1205 13 output_binary 0 4 1967 38 BitMask&lt; uint16_t, 16 &gt;::output_binary 0 1 236 0</span>
<span class="s0">91</span>
<span class="s0">void BitMask&lt; uint16_t, 16 &gt;::output_binary(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1206 10 output_hex 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::output_hex 0 1 237 0</span>
<span class="s0">88</span>
<span class="s0">void BitMask&lt; uint16_t, 16 &gt;::output_hex(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1207 5 write 0 4 1967 30 BitMask&lt; uint16_t, 16 &gt;::write 0 1 238 0</span>
<span class="s0">83</span>
<span class="s0">void BitMask&lt; uint16_t, 16 &gt;::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1208 11 operator == 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::operator == 0 1 239 0</span>
<span class="s0">93</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::operator ==(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1209 11 operator != 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::operator != 0 1 240 0</span>
<span class="s0">93</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::operator !=(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1210 10 operator &lt; 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::operator &lt; 0 1 241 0</span>
<span class="s0">92</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::operator &lt;(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1211 10 compare_to 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::compare_to 0 1 242 0</span>
<span class="s0">91</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::compare_to(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1212 10 operator &amp; 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::operator &amp; 0 1 243 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::operator &amp;(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1213 10 operator | 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::operator | 0 1 244 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::operator |(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1214 10 operator ^ 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::operator ^ 0 1 245 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::operator ^(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1215 10 operator ~ 0 68 1967 35 BitMask&lt; uint16_t, 16 &gt;::operator ~ 0 1 246 0</span>
<span class="s0">79</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::operator ~(void) const;</span>

<span class="s0">1216 11 operator &lt;&lt; 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::operator &lt;&lt; 0 1 247 0</span>
<span class="s0">85</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::operator &lt;&lt;(int shift) const;</span>

<span class="s0">1217 11 operator &gt;&gt; 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::operator &gt;&gt; 0 1 248 0</span>
<span class="s0">85</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::operator &gt;&gt;(int shift) const;</span>

<span class="s0">1218 11 operator &amp;= 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::operator &amp;= 0 1 249 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::operator &amp;=(BitMask&lt; uint16_t, 16 &gt; const &amp;other);</span>

<span class="s0">1219 11 operator |= 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::operator |= 0 1 250 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::operator |=(BitMask&lt; uint16_t, 16 &gt; const &amp;other);</span>

<span class="s0">1220 11 operator ^= 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::operator ^= 0 1 251 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::operator ^=(BitMask&lt; uint16_t, 16 &gt; const &amp;other);</span>

<span class="s0">1221 12 operator &lt;&lt;= 0 4 1967 37 BitMask&lt; uint16_t, 16 &gt;::operator &lt;&lt;= 0 1 252 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::operator &lt;&lt;=(int shift);</span>

<span class="s0">1222 12 operator &gt;&gt;= 0 4 1967 37 BitMask&lt; uint16_t, 16 &gt;::operator &gt;&gt;= 0 1 253 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::operator &gt;&gt;=(int shift);</span>

<span class="s0">1223 19 flood_down_in_place 0 4 1967 44 BitMask&lt; uint16_t, 16 &gt;::flood_down_in_place 0 1 254 0</span>
<span class="s0">63</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::flood_down_in_place(void);</span>

<span class="s0">1224 17 flood_up_in_place 0 4 1967 42 BitMask&lt; uint16_t, 16 &gt;::flood_up_in_place 0 1 255 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint16_t, 16 &gt;::flood_up_in_place(void);</span>

<span class="s0">1225 15 flood_bits_down 0 4 1967 40 BitMask&lt; uint16_t, 16 &gt;::flood_bits_down 0 1 256 0</span>
<span class="s0">84</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::flood_bits_down(void) const;</span>

<span class="s0">1226 13 flood_bits_up 0 4 1967 38 BitMask&lt; uint16_t, 16 &gt;::flood_bits_up 0 1 257 0</span>
<span class="s0">82</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::flood_bits_up(void) const;</span>

<span class="s0">1227 21 keep_next_highest_bit 0 4 1967 46 BitMask&lt; uint16_t, 16 &gt;::keep_next_highest_bit 0 3 258 259 260 0</span>
<span class="s0">309</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::keep_next_highest_bit(void) const;</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::keep_next_highest_bit(int index) const;</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::keep_next_highest_bit(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1228 20 keep_next_lowest_bit 0 4 1967 45 BitMask&lt; uint16_t, 16 &gt;::keep_next_lowest_bit 0 3 261 262 263 0</span>
<span class="s0">306</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::keep_next_lowest_bit(void) const;</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::keep_next_lowest_bit(int index) const;</span>
<span class="s0">inline BitMask&lt; uint16_t, 16 &gt; BitMask&lt; uint16_t, 16 &gt;::keep_next_lowest_bit(BitMask&lt; uint16_t, 16 &gt; const &amp;other) const;</span>

<span class="s0">1229 7 get_key 0 4 1967 32 BitMask&lt; uint16_t, 16 &gt;::get_key 0 1 264 0</span>
<span class="s0">56</span>
<span class="s0">inline int BitMask&lt; uint16_t, 16 &gt;::get_key(void) const;</span>

<span class="s0">1230 11 __nonzero__ 0 4 1967 36 BitMask&lt; uint16_t, 16 &gt;::__nonzero__ 0 1 265 0</span>
<span class="s0">61</span>
<span class="s0">inline bool BitMask&lt; uint16_t, 16 &gt;::__nonzero__(void) const;</span>

<span class="s0">1231 10 __reduce__ 0 4 1967 35 BitMask&lt; uint16_t, 16 &gt;::__reduce__ 0 1 266 0</span>
<span class="s0">68</span>
<span class="s0">PyObject *BitMask&lt; uint16_t, 16 &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">1232 14 get_class_type 0 4 1967 39 BitMask&lt; uint16_t, 16 &gt;::get_class_type 0 1 267 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle BitMask&lt; uint16_t, 16 &gt;::get_class_type(void);</span>

<span class="s0">1233 8 ~BitMask 0 516 1967 33 BitMask&lt; uint16_t, 16 &gt;::~BitMask 0 0 0</span>
<span class="s0">40</span>
<span class="s0">BitMask&lt; uint16_t, 16 &gt;::~BitMask(void);</span>

<span class="s0">1234 7 BitMask 0 260 1969 32 BitMask&lt; uint32_t, 32 &gt;::BitMask 0 3 268 269 270 0</span>
<span class="s0">215</span>
<span class="s0">constexpr BitMask&lt; uint32_t, 32 &gt;::BitMask(void) = default;</span>
<span class="s0">inline constexpr BitMask&lt; uint32_t, 32 &gt;::BitMask(uint32_t init_value);</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt;::BitMask(BitMask&lt; uint32_t, 32 &gt; const &amp;) = default;</span>

<span class="s0">1235 6 all_on 0 4 1969 31 BitMask&lt; uint32_t, 32 &gt;::all_on 0 1 271 0</span>
<span class="s0">76</span>
<span class="s0">static inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::all_on(void);</span>

<span class="s0">1236 7 all_off 0 4 1969 32 BitMask&lt; uint32_t, 32 &gt;::all_off 0 1 272 0</span>
<span class="s0">77</span>
<span class="s0">static inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::all_off(void);</span>

<span class="s0">1237 8 lower_on 0 4 1969 33 BitMask&lt; uint32_t, 32 &gt;::lower_on 0 1 273 0</span>
<span class="s0">85</span>
<span class="s0">static inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::lower_on(int on_bits);</span>

<span class="s0">1238 3 bit 0 4 1969 28 BitMask&lt; uint32_t, 32 &gt;::bit 0 1 274 0</span>
<span class="s0">78</span>
<span class="s0">static inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::bit(int index);</span>

<span class="s0">1239 5 range 0 4 1969 30 BitMask&lt; uint32_t, 32 &gt;::range 0 1 275 0</span>
<span class="s0">92</span>
<span class="s0">static inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::range(int low_bit, int size);</span>

<span class="s0">1240 16 has_max_num_bits 0 4 1969 41 BitMask&lt; uint32_t, 32 &gt;::has_max_num_bits 0 1 276 0</span>
<span class="s0">70</span>
<span class="s0">static constexpr bool BitMask&lt; uint32_t, 32 &gt;::has_max_num_bits(void);</span>

<span class="s0">1241 16 get_max_num_bits 0 4 1969 41 BitMask&lt; uint32_t, 32 &gt;::get_max_num_bits 0 1 277 0</span>
<span class="s0">69</span>
<span class="s0">static constexpr int BitMask&lt; uint32_t, 32 &gt;::get_max_num_bits(void);</span>

<span class="s0">1242 12 get_num_bits 0 4 1969 37 BitMask&lt; uint32_t, 32 &gt;::get_num_bits 0 1 278 0</span>
<span class="s0">64</span>
<span class="s0">constexpr int BitMask&lt; uint32_t, 32 &gt;::get_num_bits(void) const;</span>

<span class="s0">1243 7 get_bit 0 4 1969 32 BitMask&lt; uint32_t, 32 &gt;::get_bit 0 1 279 0</span>
<span class="s0">62</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::get_bit(int index) const;</span>

<span class="s0">1244 7 set_bit 0 4 1969 32 BitMask&lt; uint32_t, 32 &gt;::set_bit 0 1 280 0</span>
<span class="s0">56</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::set_bit(int index);</span>

<span class="s0">1245 9 clear_bit 0 4 1969 34 BitMask&lt; uint32_t, 32 &gt;::clear_bit 0 1 281 0</span>
<span class="s0">58</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::clear_bit(int index);</span>

<span class="s0">1246 10 set_bit_to 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::set_bit_to 0 1 282 0</span>
<span class="s0">71</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::set_bit_to(int index, bool value);</span>

<span class="s0">1247 7 is_zero 0 4 1969 32 BitMask&lt; uint32_t, 32 &gt;::is_zero 0 1 283 0</span>
<span class="s0">57</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::is_zero(void) const;</span>

<span class="s0">1248 9 is_all_on 0 4 1969 34 BitMask&lt; uint32_t, 32 &gt;::is_all_on 0 1 284 0</span>
<span class="s0">59</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::is_all_on(void) const;</span>

<span class="s0">1249 7 extract 0 4 1969 32 BitMask&lt; uint32_t, 32 &gt;::extract 0 1 285 0</span>
<span class="s0">78</span>
<span class="s0">inline uint32_t BitMask&lt; uint32_t, 32 &gt;::extract(int low_bit, int size) const;</span>

<span class="s0">1250 5 store 0 4 1969 30 BitMask&lt; uint32_t, 32 &gt;::store 0 1 286 0</span>
<span class="s0">82</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::store(uint32_t value, int low_bit, int size);</span>

<span class="s0">1251 10 has_any_of 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::has_any_of 0 1 287 0</span>
<span class="s0">77</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::has_any_of(int low_bit, int size) const;</span>

<span class="s0">1252 10 has_all_of 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::has_all_of 0 1 288 0</span>
<span class="s0">77</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::has_all_of(int low_bit, int size) const;</span>

<span class="s0">1253 9 set_range 0 4 1969 34 BitMask&lt; uint32_t, 32 &gt;::set_range 0 1 289 0</span>
<span class="s0">70</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::set_range(int low_bit, int size);</span>

<span class="s0">1254 11 clear_range 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::clear_range 0 1 290 0</span>
<span class="s0">72</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::clear_range(int low_bit, int size);</span>

<span class="s0">1255 12 set_range_to 0 4 1969 37 BitMask&lt; uint32_t, 32 &gt;::set_range_to 0 1 291 0</span>
<span class="s0">85</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::set_range_to(bool value, int low_bit, int size);</span>

<span class="s0">1256 8 get_word 0 4 1969 33 BitMask&lt; uint32_t, 32 &gt;::get_word 0 1 292 0</span>
<span class="s0">62</span>
<span class="s0">inline uint32_t BitMask&lt; uint32_t, 32 &gt;::get_word(void) const;</span>

<span class="s0">1257 8 set_word 0 4 1969 33 BitMask&lt; uint32_t, 32 &gt;::set_word 0 1 293 0</span>
<span class="s0">62</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::set_word(uint32_t value);</span>

<span class="s0">1258 15 get_num_on_bits 0 4 1969 40 BitMask&lt; uint32_t, 32 &gt;::get_num_on_bits 0 1 294 0</span>
<span class="s0">64</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::get_num_on_bits(void) const;</span>

<span class="s0">1259 16 get_num_off_bits 0 4 1969 41 BitMask&lt; uint32_t, 32 &gt;::get_num_off_bits 0 1 295 0</span>
<span class="s0">65</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::get_num_off_bits(void) const;</span>

<span class="s0">1260 17 get_lowest_on_bit 0 4 1969 42 BitMask&lt; uint32_t, 32 &gt;::get_lowest_on_bit 0 1 296 0</span>
<span class="s0">66</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::get_lowest_on_bit(void) const;</span>

<span class="s0">1261 18 get_lowest_off_bit 0 4 1969 43 BitMask&lt; uint32_t, 32 &gt;::get_lowest_off_bit 0 1 297 0</span>
<span class="s0">67</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::get_lowest_off_bit(void) const;</span>

<span class="s0">1262 18 get_highest_on_bit 0 4 1969 43 BitMask&lt; uint32_t, 32 &gt;::get_highest_on_bit 0 1 298 0</span>
<span class="s0">67</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::get_highest_on_bit(void) const;</span>

<span class="s0">1263 19 get_highest_off_bit 0 4 1969 44 BitMask&lt; uint32_t, 32 &gt;::get_highest_off_bit 0 1 299 0</span>
<span class="s0">68</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::get_highest_off_bit(void) const;</span>

<span class="s0">1264 29 get_next_higher_different_bit 0 4 1969 54 BitMask&lt; uint32_t, 32 &gt;::get_next_higher_different_bit 0 1 300 0</span>
<span class="s0">85</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::get_next_higher_different_bit(int low_bit) const;</span>

<span class="s0">1265 15 invert_in_place 0 4 1969 40 BitMask&lt; uint32_t, 32 &gt;::invert_in_place 0 1 301 0</span>
<span class="s0">59</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::invert_in_place(void);</span>

<span class="s0">1266 18 has_bits_in_common 0 4 1969 43 BitMask&lt; uint32_t, 32 &gt;::has_bits_in_common 0 1 302 0</span>
<span class="s0">100</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::has_bits_in_common(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1267 5 clear 0 4 1969 30 BitMask&lt; uint32_t, 32 &gt;::clear 0 1 303 0</span>
<span class="s0">49</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::clear(void);</span>

<span class="s0">1268 6 output 0 4 1969 31 BitMask&lt; uint32_t, 32 &gt;::output 0 1 304 0</span>
<span class="s0">62</span>
<span class="s0">void BitMask&lt; uint32_t, 32 &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">1269 13 output_binary 0 4 1969 38 BitMask&lt; uint32_t, 32 &gt;::output_binary 0 1 305 0</span>
<span class="s0">91</span>
<span class="s0">void BitMask&lt; uint32_t, 32 &gt;::output_binary(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1270 10 output_hex 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::output_hex 0 1 306 0</span>
<span class="s0">88</span>
<span class="s0">void BitMask&lt; uint32_t, 32 &gt;::output_hex(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1271 5 write 0 4 1969 30 BitMask&lt; uint32_t, 32 &gt;::write 0 1 307 0</span>
<span class="s0">83</span>
<span class="s0">void BitMask&lt; uint32_t, 32 &gt;::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1272 11 operator == 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::operator == 0 1 308 0</span>
<span class="s0">93</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::operator ==(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1273 11 operator != 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::operator != 0 1 309 0</span>
<span class="s0">93</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::operator !=(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1274 10 operator &lt; 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::operator &lt; 0 1 310 0</span>
<span class="s0">92</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::operator &lt;(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1275 10 compare_to 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::compare_to 0 1 311 0</span>
<span class="s0">91</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::compare_to(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1276 10 operator &amp; 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::operator &amp; 0 1 312 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::operator &amp;(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1277 10 operator | 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::operator | 0 1 313 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::operator |(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1278 10 operator ^ 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::operator ^ 0 1 314 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::operator ^(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1279 10 operator ~ 0 68 1969 35 BitMask&lt; uint32_t, 32 &gt;::operator ~ 0 1 315 0</span>
<span class="s0">79</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::operator ~(void) const;</span>

<span class="s0">1280 11 operator &lt;&lt; 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::operator &lt;&lt; 0 1 316 0</span>
<span class="s0">85</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::operator &lt;&lt;(int shift) const;</span>

<span class="s0">1281 11 operator &gt;&gt; 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::operator &gt;&gt; 0 1 317 0</span>
<span class="s0">85</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::operator &gt;&gt;(int shift) const;</span>

<span class="s0">1282 11 operator &amp;= 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::operator &amp;= 0 1 318 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::operator &amp;=(BitMask&lt; uint32_t, 32 &gt; const &amp;other);</span>

<span class="s0">1283 11 operator |= 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::operator |= 0 1 319 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::operator |=(BitMask&lt; uint32_t, 32 &gt; const &amp;other);</span>

<span class="s0">1284 11 operator ^= 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::operator ^= 0 1 320 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::operator ^=(BitMask&lt; uint32_t, 32 &gt; const &amp;other);</span>

<span class="s0">1285 12 operator &lt;&lt;= 0 4 1969 37 BitMask&lt; uint32_t, 32 &gt;::operator &lt;&lt;= 0 1 321 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::operator &lt;&lt;=(int shift);</span>

<span class="s0">1286 12 operator &gt;&gt;= 0 4 1969 37 BitMask&lt; uint32_t, 32 &gt;::operator &gt;&gt;= 0 1 322 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::operator &gt;&gt;=(int shift);</span>

<span class="s0">1287 19 flood_down_in_place 0 4 1969 44 BitMask&lt; uint32_t, 32 &gt;::flood_down_in_place 0 1 323 0</span>
<span class="s0">63</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::flood_down_in_place(void);</span>

<span class="s0">1288 17 flood_up_in_place 0 4 1969 42 BitMask&lt; uint32_t, 32 &gt;::flood_up_in_place 0 1 324 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint32_t, 32 &gt;::flood_up_in_place(void);</span>

<span class="s0">1289 15 flood_bits_down 0 4 1969 40 BitMask&lt; uint32_t, 32 &gt;::flood_bits_down 0 1 325 0</span>
<span class="s0">84</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::flood_bits_down(void) const;</span>

<span class="s0">1290 13 flood_bits_up 0 4 1969 38 BitMask&lt; uint32_t, 32 &gt;::flood_bits_up 0 1 326 0</span>
<span class="s0">82</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::flood_bits_up(void) const;</span>

<span class="s0">1291 21 keep_next_highest_bit 0 4 1969 46 BitMask&lt; uint32_t, 32 &gt;::keep_next_highest_bit 0 3 327 328 329 0</span>
<span class="s0">309</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::keep_next_highest_bit(void) const;</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::keep_next_highest_bit(int index) const;</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::keep_next_highest_bit(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1292 20 keep_next_lowest_bit 0 4 1969 45 BitMask&lt; uint32_t, 32 &gt;::keep_next_lowest_bit 0 3 330 331 332 0</span>
<span class="s0">306</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::keep_next_lowest_bit(void) const;</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::keep_next_lowest_bit(int index) const;</span>
<span class="s0">inline BitMask&lt; uint32_t, 32 &gt; BitMask&lt; uint32_t, 32 &gt;::keep_next_lowest_bit(BitMask&lt; uint32_t, 32 &gt; const &amp;other) const;</span>

<span class="s0">1293 7 get_key 0 4 1969 32 BitMask&lt; uint32_t, 32 &gt;::get_key 0 1 333 0</span>
<span class="s0">56</span>
<span class="s0">inline int BitMask&lt; uint32_t, 32 &gt;::get_key(void) const;</span>

<span class="s0">1294 11 __nonzero__ 0 4 1969 36 BitMask&lt; uint32_t, 32 &gt;::__nonzero__ 0 1 334 0</span>
<span class="s0">61</span>
<span class="s0">inline bool BitMask&lt; uint32_t, 32 &gt;::__nonzero__(void) const;</span>

<span class="s0">1295 10 __reduce__ 0 4 1969 35 BitMask&lt; uint32_t, 32 &gt;::__reduce__ 0 1 335 0</span>
<span class="s0">68</span>
<span class="s0">PyObject *BitMask&lt; uint32_t, 32 &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">1296 14 get_class_type 0 4 1969 39 BitMask&lt; uint32_t, 32 &gt;::get_class_type 0 1 336 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle BitMask&lt; uint32_t, 32 &gt;::get_class_type(void);</span>

<span class="s0">1297 8 ~BitMask 0 516 1969 33 BitMask&lt; uint32_t, 32 &gt;::~BitMask 0 0 0</span>
<span class="s0">40</span>
<span class="s0">BitMask&lt; uint32_t, 32 &gt;::~BitMask(void);</span>

<span class="s0">1298 7 BitMask 0 260 1971 32 BitMask&lt; uint64_t, 64 &gt;::BitMask 0 3 337 338 339 0</span>
<span class="s0">215</span>
<span class="s0">constexpr BitMask&lt; uint64_t, 64 &gt;::BitMask(void) = default;</span>
<span class="s0">inline constexpr BitMask&lt; uint64_t, 64 &gt;::BitMask(uint64_t init_value);</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt;::BitMask(BitMask&lt; uint64_t, 64 &gt; const &amp;) = default;</span>

<span class="s0">1299 6 all_on 0 4 1971 31 BitMask&lt; uint64_t, 64 &gt;::all_on 0 1 340 0</span>
<span class="s0">76</span>
<span class="s0">static inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::all_on(void);</span>

<span class="s0">1300 7 all_off 0 4 1971 32 BitMask&lt; uint64_t, 64 &gt;::all_off 0 1 341 0</span>
<span class="s0">77</span>
<span class="s0">static inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::all_off(void);</span>

<span class="s0">1301 8 lower_on 0 4 1971 33 BitMask&lt; uint64_t, 64 &gt;::lower_on 0 1 342 0</span>
<span class="s0">85</span>
<span class="s0">static inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::lower_on(int on_bits);</span>

<span class="s0">1302 3 bit 0 4 1971 28 BitMask&lt; uint64_t, 64 &gt;::bit 0 1 343 0</span>
<span class="s0">78</span>
<span class="s0">static inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::bit(int index);</span>

<span class="s0">1303 5 range 0 4 1971 30 BitMask&lt; uint64_t, 64 &gt;::range 0 1 344 0</span>
<span class="s0">92</span>
<span class="s0">static inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::range(int low_bit, int size);</span>

<span class="s0">1304 16 has_max_num_bits 0 4 1971 41 BitMask&lt; uint64_t, 64 &gt;::has_max_num_bits 0 1 345 0</span>
<span class="s0">70</span>
<span class="s0">static constexpr bool BitMask&lt; uint64_t, 64 &gt;::has_max_num_bits(void);</span>

<span class="s0">1305 16 get_max_num_bits 0 4 1971 41 BitMask&lt; uint64_t, 64 &gt;::get_max_num_bits 0 1 346 0</span>
<span class="s0">69</span>
<span class="s0">static constexpr int BitMask&lt; uint64_t, 64 &gt;::get_max_num_bits(void);</span>

<span class="s0">1306 12 get_num_bits 0 4 1971 37 BitMask&lt; uint64_t, 64 &gt;::get_num_bits 0 1 347 0</span>
<span class="s0">64</span>
<span class="s0">constexpr int BitMask&lt; uint64_t, 64 &gt;::get_num_bits(void) const;</span>

<span class="s0">1307 7 get_bit 0 4 1971 32 BitMask&lt; uint64_t, 64 &gt;::get_bit 0 1 348 0</span>
<span class="s0">62</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::get_bit(int index) const;</span>

<span class="s0">1308 7 set_bit 0 4 1971 32 BitMask&lt; uint64_t, 64 &gt;::set_bit 0 1 349 0</span>
<span class="s0">56</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::set_bit(int index);</span>

<span class="s0">1309 9 clear_bit 0 4 1971 34 BitMask&lt; uint64_t, 64 &gt;::clear_bit 0 1 350 0</span>
<span class="s0">58</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::clear_bit(int index);</span>

<span class="s0">1310 10 set_bit_to 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::set_bit_to 0 1 351 0</span>
<span class="s0">71</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::set_bit_to(int index, bool value);</span>

<span class="s0">1311 7 is_zero 0 4 1971 32 BitMask&lt; uint64_t, 64 &gt;::is_zero 0 1 352 0</span>
<span class="s0">57</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::is_zero(void) const;</span>

<span class="s0">1312 9 is_all_on 0 4 1971 34 BitMask&lt; uint64_t, 64 &gt;::is_all_on 0 1 353 0</span>
<span class="s0">59</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::is_all_on(void) const;</span>

<span class="s0">1313 7 extract 0 4 1971 32 BitMask&lt; uint64_t, 64 &gt;::extract 0 1 354 0</span>
<span class="s0">78</span>
<span class="s0">inline uint64_t BitMask&lt; uint64_t, 64 &gt;::extract(int low_bit, int size) const;</span>

<span class="s0">1314 5 store 0 4 1971 30 BitMask&lt; uint64_t, 64 &gt;::store 0 1 355 0</span>
<span class="s0">82</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::store(uint64_t value, int low_bit, int size);</span>

<span class="s0">1315 10 has_any_of 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::has_any_of 0 1 356 0</span>
<span class="s0">77</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::has_any_of(int low_bit, int size) const;</span>

<span class="s0">1316 10 has_all_of 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::has_all_of 0 1 357 0</span>
<span class="s0">77</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::has_all_of(int low_bit, int size) const;</span>

<span class="s0">1317 9 set_range 0 4 1971 34 BitMask&lt; uint64_t, 64 &gt;::set_range 0 1 358 0</span>
<span class="s0">70</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::set_range(int low_bit, int size);</span>

<span class="s0">1318 11 clear_range 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::clear_range 0 1 359 0</span>
<span class="s0">72</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::clear_range(int low_bit, int size);</span>

<span class="s0">1319 12 set_range_to 0 4 1971 37 BitMask&lt; uint64_t, 64 &gt;::set_range_to 0 1 360 0</span>
<span class="s0">85</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::set_range_to(bool value, int low_bit, int size);</span>

<span class="s0">1320 8 get_word 0 4 1971 33 BitMask&lt; uint64_t, 64 &gt;::get_word 0 1 361 0</span>
<span class="s0">62</span>
<span class="s0">inline uint64_t BitMask&lt; uint64_t, 64 &gt;::get_word(void) const;</span>

<span class="s0">1321 8 set_word 0 4 1971 33 BitMask&lt; uint64_t, 64 &gt;::set_word 0 1 362 0</span>
<span class="s0">62</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::set_word(uint64_t value);</span>

<span class="s0">1322 15 get_num_on_bits 0 4 1971 40 BitMask&lt; uint64_t, 64 &gt;::get_num_on_bits 0 1 363 0</span>
<span class="s0">64</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::get_num_on_bits(void) const;</span>

<span class="s0">1323 16 get_num_off_bits 0 4 1971 41 BitMask&lt; uint64_t, 64 &gt;::get_num_off_bits 0 1 364 0</span>
<span class="s0">65</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::get_num_off_bits(void) const;</span>

<span class="s0">1324 17 get_lowest_on_bit 0 4 1971 42 BitMask&lt; uint64_t, 64 &gt;::get_lowest_on_bit 0 1 365 0</span>
<span class="s0">66</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::get_lowest_on_bit(void) const;</span>

<span class="s0">1325 18 get_lowest_off_bit 0 4 1971 43 BitMask&lt; uint64_t, 64 &gt;::get_lowest_off_bit 0 1 366 0</span>
<span class="s0">67</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::get_lowest_off_bit(void) const;</span>

<span class="s0">1326 18 get_highest_on_bit 0 4 1971 43 BitMask&lt; uint64_t, 64 &gt;::get_highest_on_bit 0 1 367 0</span>
<span class="s0">67</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::get_highest_on_bit(void) const;</span>

<span class="s0">1327 19 get_highest_off_bit 0 4 1971 44 BitMask&lt; uint64_t, 64 &gt;::get_highest_off_bit 0 1 368 0</span>
<span class="s0">68</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::get_highest_off_bit(void) const;</span>

<span class="s0">1328 29 get_next_higher_different_bit 0 4 1971 54 BitMask&lt; uint64_t, 64 &gt;::get_next_higher_different_bit 0 1 369 0</span>
<span class="s0">85</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::get_next_higher_different_bit(int low_bit) const;</span>

<span class="s0">1329 15 invert_in_place 0 4 1971 40 BitMask&lt; uint64_t, 64 &gt;::invert_in_place 0 1 370 0</span>
<span class="s0">59</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::invert_in_place(void);</span>

<span class="s0">1330 18 has_bits_in_common 0 4 1971 43 BitMask&lt; uint64_t, 64 &gt;::has_bits_in_common 0 1 371 0</span>
<span class="s0">100</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::has_bits_in_common(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1331 5 clear 0 4 1971 30 BitMask&lt; uint64_t, 64 &gt;::clear 0 1 372 0</span>
<span class="s0">49</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::clear(void);</span>

<span class="s0">1332 6 output 0 4 1971 31 BitMask&lt; uint64_t, 64 &gt;::output 0 1 373 0</span>
<span class="s0">62</span>
<span class="s0">void BitMask&lt; uint64_t, 64 &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">1333 13 output_binary 0 4 1971 38 BitMask&lt; uint64_t, 64 &gt;::output_binary 0 1 374 0</span>
<span class="s0">91</span>
<span class="s0">void BitMask&lt; uint64_t, 64 &gt;::output_binary(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1334 10 output_hex 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::output_hex 0 1 375 0</span>
<span class="s0">88</span>
<span class="s0">void BitMask&lt; uint64_t, 64 &gt;::output_hex(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1335 5 write 0 4 1971 30 BitMask&lt; uint64_t, 64 &gt;::write 0 1 376 0</span>
<span class="s0">83</span>
<span class="s0">void BitMask&lt; uint64_t, 64 &gt;::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1336 11 operator == 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::operator == 0 1 377 0</span>
<span class="s0">93</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::operator ==(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1337 11 operator != 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::operator != 0 1 378 0</span>
<span class="s0">93</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::operator !=(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1338 10 operator &lt; 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::operator &lt; 0 1 379 0</span>
<span class="s0">92</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::operator &lt;(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1339 10 compare_to 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::compare_to 0 1 380 0</span>
<span class="s0">91</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::compare_to(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1340 10 operator &amp; 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::operator &amp; 0 1 381 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::operator &amp;(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1341 10 operator | 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::operator | 0 1 382 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::operator |(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1342 10 operator ^ 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::operator ^ 0 1 383 0</span>
<span class="s0">111</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::operator ^(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1343 10 operator ~ 0 68 1971 35 BitMask&lt; uint64_t, 64 &gt;::operator ~ 0 1 384 0</span>
<span class="s0">79</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::operator ~(void) const;</span>

<span class="s0">1344 11 operator &lt;&lt; 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::operator &lt;&lt; 0 1 385 0</span>
<span class="s0">85</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::operator &lt;&lt;(int shift) const;</span>

<span class="s0">1345 11 operator &gt;&gt; 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::operator &gt;&gt; 0 1 386 0</span>
<span class="s0">85</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::operator &gt;&gt;(int shift) const;</span>

<span class="s0">1346 11 operator &amp;= 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::operator &amp;= 0 1 387 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::operator &amp;=(BitMask&lt; uint64_t, 64 &gt; const &amp;other);</span>

<span class="s0">1347 11 operator |= 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::operator |= 0 1 388 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::operator |=(BitMask&lt; uint64_t, 64 &gt; const &amp;other);</span>

<span class="s0">1348 11 operator ^= 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::operator ^= 0 1 389 0</span>
<span class="s0">87</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::operator ^=(BitMask&lt; uint64_t, 64 &gt; const &amp;other);</span>

<span class="s0">1349 12 operator &lt;&lt;= 0 4 1971 37 BitMask&lt; uint64_t, 64 &gt;::operator &lt;&lt;= 0 1 390 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::operator &lt;&lt;=(int shift);</span>

<span class="s0">1350 12 operator &gt;&gt;= 0 4 1971 37 BitMask&lt; uint64_t, 64 &gt;::operator &gt;&gt;= 0 1 391 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::operator &gt;&gt;=(int shift);</span>

<span class="s0">1351 19 flood_down_in_place 0 4 1971 44 BitMask&lt; uint64_t, 64 &gt;::flood_down_in_place 0 1 392 0</span>
<span class="s0">63</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::flood_down_in_place(void);</span>

<span class="s0">1352 17 flood_up_in_place 0 4 1971 42 BitMask&lt; uint64_t, 64 &gt;::flood_up_in_place 0 1 393 0</span>
<span class="s0">61</span>
<span class="s0">inline void BitMask&lt; uint64_t, 64 &gt;::flood_up_in_place(void);</span>

<span class="s0">1353 15 flood_bits_down 0 4 1971 40 BitMask&lt; uint64_t, 64 &gt;::flood_bits_down 0 1 394 0</span>
<span class="s0">84</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::flood_bits_down(void) const;</span>

<span class="s0">1354 13 flood_bits_up 0 4 1971 38 BitMask&lt; uint64_t, 64 &gt;::flood_bits_up 0 1 395 0</span>
<span class="s0">82</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::flood_bits_up(void) const;</span>

<span class="s0">1355 21 keep_next_highest_bit 0 4 1971 46 BitMask&lt; uint64_t, 64 &gt;::keep_next_highest_bit 0 3 396 397 398 0</span>
<span class="s0">309</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::keep_next_highest_bit(void) const;</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::keep_next_highest_bit(int index) const;</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::keep_next_highest_bit(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1356 20 keep_next_lowest_bit 0 4 1971 45 BitMask&lt; uint64_t, 64 &gt;::keep_next_lowest_bit 0 3 399 400 401 0</span>
<span class="s0">306</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::keep_next_lowest_bit(void) const;</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::keep_next_lowest_bit(int index) const;</span>
<span class="s0">inline BitMask&lt; uint64_t, 64 &gt; BitMask&lt; uint64_t, 64 &gt;::keep_next_lowest_bit(BitMask&lt; uint64_t, 64 &gt; const &amp;other) const;</span>

<span class="s0">1357 7 get_key 0 4 1971 32 BitMask&lt; uint64_t, 64 &gt;::get_key 0 1 402 0</span>
<span class="s0">56</span>
<span class="s0">inline int BitMask&lt; uint64_t, 64 &gt;::get_key(void) const;</span>

<span class="s0">1358 11 __nonzero__ 0 4 1971 36 BitMask&lt; uint64_t, 64 &gt;::__nonzero__ 0 1 403 0</span>
<span class="s0">61</span>
<span class="s0">inline bool BitMask&lt; uint64_t, 64 &gt;::__nonzero__(void) const;</span>

<span class="s0">1359 10 __reduce__ 0 4 1971 35 BitMask&lt; uint64_t, 64 &gt;::__reduce__ 0 1 404 0</span>
<span class="s0">68</span>
<span class="s0">PyObject *BitMask&lt; uint64_t, 64 &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">1360 14 get_class_type 0 4 1971 39 BitMask&lt; uint64_t, 64 &gt;::get_class_type 0 1 405 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle BitMask&lt; uint64_t, 64 &gt;::get_class_type(void);</span>

<span class="s0">1361 8 ~BitMask 0 516 1971 33 BitMask&lt; uint64_t, 64 &gt;::~BitMask 0 0 0</span>
<span class="s0">40</span>
<span class="s0">BitMask&lt; uint64_t, 64 &gt;::~BitMask(void);</span>

<span class="s0">1362 8 BitArray 0 260 1974 18 BitArray::BitArray 0 4 406 407 408 409 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">190</span>
<span class="s0">inline BitArray::BitArray(void);</span>
<span class="s0">inline BitArray::BitArray(BitArray::WordType init_value);</span>
<span class="s0">BitArray::BitArray(SparseArray const &amp;from);</span>
<span class="s0">inline BitArray::BitArray(BitArray const &amp;) = default;</span>

<span class="s0">1363 6 all_on 0 4 1974 16 BitArray::all_on 0 1 410 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a BitArray with an infinite array of bits, all on.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">static inline BitArray BitArray::all_on(void);</span>

<span class="s0">1364 7 all_off 0 4 1974 17 BitArray::all_off 0 1 411 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a BitArray whose bits are all off.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static inline BitArray BitArray::all_off(void);</span>

<span class="s0">1365 8 lower_on 0 4 1974 18 BitArray::lower_on 0 1 412 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a BitArray whose lower on_bits bits are on.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline BitArray BitArray::lower_on(int on_bits);</span>

<span class="s0">1366 3 bit 0 4 1974 13 BitArray::bit 0 1 413 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a BitArray with only the indicated bit on.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">static inline BitArray BitArray::bit(int index);</span>

<span class="s0">1367 5 range 0 4 1974 15 BitArray::range 0 1 414 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a BitArray whose size bits, beginning at low_bit, are on.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline BitArray BitArray::range(int low_bit, int size);</span>

<span class="s0">1368 16 has_max_num_bits 0 4 1974 26 BitArray::has_max_num_bits 0 1 415 0</span>
<span class="s0">55</span>
<span class="s0">static constexpr bool BitArray::has_max_num_bits(void);</span>

<span class="s0">1369 16 get_max_num_bits 0 4 1974 26 BitArray::get_max_num_bits 0 1 416 0</span>
<span class="s0">54</span>
<span class="s0">static constexpr int BitArray::get_max_num_bits(void);</span>

<span class="s0">1370 21 get_num_bits_per_word 0 4 1974 31 BitArray::get_num_bits_per_word 0 1 417 0</span>
<span class="s0">59</span>
<span class="s0">static constexpr int BitArray::get_num_bits_per_word(void);</span>

<span class="s0">1371 12 get_num_bits 0 4 1974 22 BitArray::get_num_bits 0 1 418 300</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current number of possibly different bits in this array.  There</span>
 <span class="s0">* are actually an infinite number of bits, but every bit higher than this bit</span>
 <span class="s0">* will have the same value, either 0 or 1 (see get_highest_bits()).</span>
 <span class="s0">*</span>
 <span class="s0">* This number may grow and/or shrink automatically as needed.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline std::size_t BitArray::get_num_bits(void) const;</span>

<span class="s0">1372 7 get_bit 0 4 1974 17 BitArray::get_bit 0 1 419 191</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the nth bit is set, false if it is cleared.  It is valid</span>
 <span class="s0">* for n to increase beyond get_num_bits(), but the return value</span>
 <span class="s0">* get_num_bits() will always be the same.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool BitArray::get_bit(int index) const;</span>

<span class="s0">1373 7 set_bit 0 4 1974 17 BitArray::set_bit 0 1 420 97</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth bit on.  If n &gt;= get_num_bits(), this automatically extends</span>
 <span class="s0">* the array.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void BitArray::set_bit(int index);</span>

<span class="s0">1374 9 clear_bit 0 4 1974 19 BitArray::clear_bit 0 1 421 98</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth bit off.  If n &gt;= get_num_bits(), this automatically extends</span>
 <span class="s0">* the array.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void BitArray::clear_bit(int index);</span>

<span class="s0">1375 10 set_bit_to 0 4 1974 20 BitArray::set_bit_to 0 1 422 84</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth bit either on or off, according to the indicated bool value.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void BitArray::set_bit_to(int index, bool value);</span>

<span class="s0">1376 16 get_highest_bits 0 4 1974 26 BitArray::get_highest_bits 0 1 423 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the infinite set of bits beyond get_num_bits() are all on,</span>
 <span class="s0">* or false of they are all off.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool BitArray::get_highest_bits(void) const;</span>

<span class="s0">1377 7 is_zero 0 4 1974 17 BitArray::is_zero 0 1 424 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the entire bitmask is zero, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">bool BitArray::is_zero(void) const;</span>

<span class="s0">1378 9 is_all_on 0 4 1974 19 BitArray::is_all_on 0 1 425 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the entire bitmask is one, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">bool BitArray::is_all_on(void) const;</span>

<span class="s0">1379 7 extract 0 4 1974 17 BitArray::extract 0 1 426 187</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a word that represents only the indicated range of bits within this</span>
 <span class="s0">* BitArray, shifted to the least-significant position.  size must be &lt;=</span>
 <span class="s0">* get_num_bits_per_word().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline BitArray::WordType BitArray::extract(int low_bit, int size) const;</span>

<span class="s0">1380 5 store 0 4 1974 15 BitArray::store 0 1 427 92</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the indicated word into the indicated range of bits with this</span>
 <span class="s0">* BitArray.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void BitArray::store(BitArray::WordType value, int low_bit, int size);</span>

<span class="s0">1381 10 has_any_of 0 4 1974 20 BitArray::has_any_of 0 1 428 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any bit in the indicated range is set, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool BitArray::has_any_of(int low_bit, int size) const;</span>

<span class="s0">1382 10 has_all_of 0 4 1974 20 BitArray::has_all_of 0 1 429 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all bits in the indicated range are set, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool BitArray::has_all_of(int low_bit, int size) const;</span>

<span class="s0">1383 9 set_range 0 4 1974 19 BitArray::set_range 0 1 430 47</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the indicated range of bits on.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void BitArray::set_range(int low_bit, int size);</span>

<span class="s0">1384 11 clear_range 0 4 1974 21 BitArray::clear_range 0 1 431 48</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the indicated range of bits off.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void BitArray::clear_range(int low_bit, int size);</span>

<span class="s0">1385 12 set_range_to 0 4 1974 22 BitArray::set_range_to 0 1 432 64</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the indicated range of bits to either on or off.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void BitArray::set_range_to(bool value, int low_bit, int size);</span>

<span class="s0">1386 15 get_num_on_bits 0 4 1974 25 BitArray::get_num_on_bits 0 1 433 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bits that are set to 1 in the array.  Returns -1 if</span>
 <span class="s0">* there are an infinite number of 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">int BitArray::get_num_on_bits(void) const;</span>

<span class="s0">1387 16 get_num_off_bits 0 4 1974 26 BitArray::get_num_off_bits 0 1 434 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bits that are set to 0 in the array.  Returns -1 if</span>
 <span class="s0">* there are an infinite number of 0 bits.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">int BitArray::get_num_off_bits(void) const;</span>

<span class="s0">1388 17 get_lowest_on_bit 0 4 1974 27 BitArray::get_lowest_on_bit 0 1 435 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the lowest 1 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">int BitArray::get_lowest_on_bit(void) const;</span>

<span class="s0">1389 18 get_lowest_off_bit 0 4 1974 28 BitArray::get_lowest_off_bit 0 1 436 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the lowest 0 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 0 bits.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int BitArray::get_lowest_off_bit(void) const;</span>

<span class="s0">1390 18 get_highest_on_bit 0 4 1974 28 BitArray::get_highest_on_bit 0 1 437 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the highest 1 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 1 bits or if there an infinite number of 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int BitArray::get_highest_on_bit(void) const;</span>

<span class="s0">1391 19 get_highest_off_bit 0 4 1974 29 BitArray::get_highest_off_bit 0 1 438 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the highest 0 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 0 bits or if there an infinite number of 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">int BitArray::get_highest_off_bit(void) const;</span>

<span class="s0">1392 29 get_next_higher_different_bit 0 4 1974 39 BitArray::get_next_higher_different_bit 0 1 439 287</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the next bit in the array, above low_bit, whose value</span>
 <span class="s0">* is different that the value of low_bit.  Returns low_bit again if all bits</span>
 <span class="s0">* higher than low_bit have the same value.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to quickly iterate through all of the bits in the array.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">int BitArray::get_next_higher_different_bit(int low_bit) const;</span>

<span class="s0">1393 13 get_num_words 0 4 1974 23 BitArray::get_num_words 0 1 440 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of possibly-unique words stored in the array.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline std::size_t BitArray::get_num_words(void) const;</span>

<span class="s0">1394 8 get_word 0 4 1974 18 BitArray::get_word 0 1 441 175</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth word in the array.  It is valid for n to be greater than</span>
 <span class="s0">* get_num_words(), but the return value beyond get_num_words() will always be</span>
 <span class="s0">* the same.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline BitArray::MaskType BitArray::get_word(std::size_t n) const;</span>

<span class="s0">1395 8 set_word 0 4 1974 18 BitArray::set_word 0 1 442 113</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the nth word in the array.  If n &gt;= get_num_words(), this</span>
 <span class="s0">* automatically extends the array.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void BitArray::set_word(std::size_t n, BitArray::WordType value);</span>

<span class="s0">1396 15 invert_in_place 0 4 1974 25 BitArray::invert_in_place 0 1 443 90</span>
<span class="s0">/**</span>
 <span class="s0">* Inverts all the bits in the BitArray.  This is equivalent to array =</span>
 <span class="s0">* ~array.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void BitArray::invert_in_place(void);</span>

<span class="s0">1397 18 has_bits_in_common 0 4 1974 28 BitArray::has_bits_in_common 0 1 444 178</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this BitArray has any &quot;one&quot; bits in common with the other</span>
 <span class="s0">* one, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is equivalent to (array &amp; other) != 0, but may be faster.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">bool BitArray::has_bits_in_common(BitArray const &amp;other) const;</span>

<span class="s0">1398 5 clear 0 4 1974 15 BitArray::clear 0 1 445 49</span>
<span class="s0">/**</span>
 <span class="s0">* Sets all the bits in the BitArray off.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">inline void BitArray::clear(void);</span>

<span class="s0">1399 6 output 0 4 1974 16 BitArray::output 0 1 446 193</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the BitArray out as a hex number.  For a BitArray, this is always</span>
 <span class="s0">* the same as output_hex(); it's too confusing for the output format to</span>
 <span class="s0">* change back and forth at runtime.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void BitArray::output(std::ostream &amp;out) const;</span>

<span class="s0">1400 13 output_binary 0 4 1974 23 BitArray::output_binary 0 1 447 83</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the BitArray out as a binary number, with spaces every four bits.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void BitArray::output_binary(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1401 10 output_hex 0 4 1974 20 BitArray::output_hex 0 1 448 93</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the BitArray out as a hexadecimal number, with spaces every four</span>
 <span class="s0">* digits.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">void BitArray::output_hex(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1402 5 write 0 4 1974 15 BitArray::write 0 1 449 99</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the BitArray out as a binary or a hex number, according to the</span>
 <span class="s0">* number of bits.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void BitArray::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1403 11 operator == 0 4 1974 21 BitArray::operator == 0 1 450 0</span>
<span class="s0">63</span>
<span class="s0">inline bool BitArray::operator ==(BitArray const &amp;other) const;</span>

<span class="s0">1404 11 operator != 0 4 1974 21 BitArray::operator != 0 1 451 0</span>
<span class="s0">63</span>
<span class="s0">inline bool BitArray::operator !=(BitArray const &amp;other) const;</span>

<span class="s0">1405 10 operator &lt; 0 4 1974 20 BitArray::operator &lt; 0 1 452 0</span>
<span class="s0">62</span>
<span class="s0">inline bool BitArray::operator &lt;(BitArray const &amp;other) const;</span>

<span class="s0">1406 10 compare_to 0 4 1974 20 BitArray::compare_to 0 1 453 233</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this BitArray sorts before the indicated</span>
 <span class="s0">* other BitArray, greater than zero if it sorts after, or 0 if they are</span>
 <span class="s0">* equivalent.  This is based on the same ordering defined by operator &lt;.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int BitArray::compare_to(BitArray const &amp;other) const;</span>

<span class="s0">1407 10 operator &amp; 0 4 1974 20 BitArray::operator &amp; 0 1 454 0</span>
<span class="s0">66</span>
<span class="s0">inline BitArray BitArray::operator &amp;(BitArray const &amp;other) const;</span>

<span class="s0">1408 10 operator | 0 4 1974 20 BitArray::operator | 0 1 455 0</span>
<span class="s0">66</span>
<span class="s0">inline BitArray BitArray::operator |(BitArray const &amp;other) const;</span>

<span class="s0">1409 10 operator ^ 0 4 1974 20 BitArray::operator ^ 0 1 456 0</span>
<span class="s0">66</span>
<span class="s0">inline BitArray BitArray::operator ^(BitArray const &amp;other) const;</span>

<span class="s0">1410 10 operator ~ 0 68 1974 20 BitArray::operator ~ 0 1 457 0</span>
<span class="s0">49</span>
<span class="s0">inline BitArray BitArray::operator ~(void) const;</span>

<span class="s0">1411 11 operator &lt;&lt; 0 4 1974 21 BitArray::operator &lt;&lt; 0 1 458 0</span>
<span class="s0">55</span>
<span class="s0">inline BitArray BitArray::operator &lt;&lt;(int shift) const;</span>

<span class="s0">1412 11 operator &gt;&gt; 0 4 1974 21 BitArray::operator &gt;&gt; 0 1 459 0</span>
<span class="s0">55</span>
<span class="s0">inline BitArray BitArray::operator &gt;&gt;(int shift) const;</span>

<span class="s0">1413 11 operator &amp;= 0 4 1974 21 BitArray::operator &amp;= 0 1 460 0</span>
<span class="s0">50</span>
<span class="s0">void BitArray::operator &amp;=(BitArray const &amp;other);</span>

<span class="s0">1414 11 operator |= 0 4 1974 21 BitArray::operator |= 0 1 461 0</span>
<span class="s0">50</span>
<span class="s0">void BitArray::operator |=(BitArray const &amp;other);</span>

<span class="s0">1415 11 operator ^= 0 4 1974 21 BitArray::operator ^= 0 1 462 0</span>
<span class="s0">50</span>
<span class="s0">void BitArray::operator ^=(BitArray const &amp;other);</span>

<span class="s0">1416 12 operator &lt;&lt;= 0 4 1974 22 BitArray::operator &lt;&lt;= 0 1 463 0</span>
<span class="s0">39</span>
<span class="s0">void BitArray::operator &lt;&lt;=(int shift);</span>

<span class="s0">1417 12 operator &gt;&gt;= 0 4 1974 22 BitArray::operator &gt;&gt;= 0 1 464 0</span>
<span class="s0">39</span>
<span class="s0">void BitArray::operator &gt;&gt;=(int shift);</span>

<span class="s0">1418 12 __getstate__ 0 4 1974 22 BitArray::__getstate__ 0 1 465 0</span>
<span class="s0">45</span>
<span class="s0">PyObject *BitArray::__getstate__(void) const;</span>

<span class="s0">1419 12 __setstate__ 0 4 1974 22 BitArray::__setstate__ 0 1 466 0</span>
<span class="s0">45</span>
<span class="s0">void BitArray::__setstate__(PyObject *state);</span>

<span class="s0">1420 14 get_class_type 0 4 1974 24 BitArray::get_class_type 0 1 467 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle BitArray::get_class_type(void);</span>

<span class="s0">1421 9 ~BitArray 0 516 1974 19 BitArray::~BitArray 0 0 0</span>
<span class="s0">26</span>
<span class="s0">BitArray::~BitArray(void);</span>

<span class="s0">1422 12 ButtonHandle 0 260 1976 26 ButtonHandle::ButtonHandle 0 4 468 469 470 471 758</span>
<span class="s0">// The default constructor must do nothing, because we can't guarantee</span>
<span class="s0">// ordering of static initializers.  If the constructor tried to initialize</span>
<span class="s0">// its value, it  might happen after the value had already been set</span>
<span class="s0">// previously by another static initializer!</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a ButtonHandle with the corresponding index number, which may</span>
 <span class="s0">* have been returned by an earlier call to ButtonHandle::get_index().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a ButtonHandle with the corresponding name, which is looked up</span>
 <span class="s0">* in the ButtonRegistry.  This exists for the purpose of being able to</span>
 <span class="s0">* automatically coerce a string into a ButtonHandle; for most purposes, you</span>
 <span class="s0">* should use either the static KeyboardButton/MouseButton getters or</span>
 <span class="s0">* ButtonRegistry::register_button().</span>
 <span class="s0">*/</span>
<span class="s0">219</span>
<span class="s0">inline ButtonHandle::ButtonHandle(void) = default;</span>
<span class="s0">constexpr ButtonHandle::ButtonHandle(int index);</span>
<span class="s0">ButtonHandle::ButtonHandle(std::string const &amp;name);</span>
<span class="s0">inline ButtonHandle::ButtonHandle(ButtonHandle const &amp;) = default;</span>

<span class="s0">1423 11 operator == 0 4 1976 25 ButtonHandle::operator == 0 1 472 0</span>
<span class="s0">71</span>
<span class="s0">inline bool ButtonHandle::operator ==(ButtonHandle const &amp;other) const;</span>

<span class="s0">1424 11 operator != 0 4 1976 25 ButtonHandle::operator != 0 1 473 0</span>
<span class="s0">71</span>
<span class="s0">inline bool ButtonHandle::operator !=(ButtonHandle const &amp;other) const;</span>

<span class="s0">1425 10 operator &lt; 0 4 1976 24 ButtonHandle::operator &lt; 0 1 474 0</span>
<span class="s0">70</span>
<span class="s0">inline bool ButtonHandle::operator &lt;(ButtonHandle const &amp;other) const;</span>

<span class="s0">1426 11 operator &lt;= 0 4 1976 25 ButtonHandle::operator &lt;= 0 1 475 0</span>
<span class="s0">71</span>
<span class="s0">inline bool ButtonHandle::operator &lt;=(ButtonHandle const &amp;other) const;</span>

<span class="s0">1427 10 operator &gt; 0 4 1976 24 ButtonHandle::operator &gt; 0 1 476 0</span>
<span class="s0">70</span>
<span class="s0">inline bool ButtonHandle::operator &gt;(ButtonHandle const &amp;other) const;</span>

<span class="s0">1428 11 operator &gt;= 0 4 1976 25 ButtonHandle::operator &gt;= 0 1 477 0</span>
<span class="s0">71</span>
<span class="s0">inline bool ButtonHandle::operator &gt;=(ButtonHandle const &amp;other) const;</span>

<span class="s0">1429 10 compare_to 0 4 1976 24 ButtonHandle::compare_to 0 1 478 209</span>
<span class="s0">/**</span>
 <span class="s0">* Sorts ButtonHandles arbitrarily (according to &lt;, &gt;, etc.).  Returns a</span>
 <span class="s0">* number less than 0 if this type sorts before the other one, greater than</span>
 <span class="s0">* zero if it sorts after, 0 if they are equivalent.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline int ButtonHandle::compare_to(ButtonHandle const &amp;other) const;</span>

<span class="s0">1430 8 get_hash 0 4 1976 22 ButtonHandle::get_hash 0 1 479 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a hash code suitable for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline std::size_t ButtonHandle::get_hash(void) const;</span>

<span class="s0">1431 8 get_name 0 4 1976 22 ButtonHandle::get_name 0 1 480 42</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the button.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">std::string ButtonHandle::get_name(void) const;</span>

<span class="s0">1432 20 has_ascii_equivalent 0 4 1976 34 ButtonHandle::has_ascii_equivalent 0 1 481 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the button was created with an ASCII equivalent code (e.g.</span>
 <span class="s0">* for a standard keyboard button).</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool ButtonHandle::has_ascii_equivalent(void) const;</span>

<span class="s0">1433 20 get_ascii_equivalent 0 4 1976 34 ButtonHandle::get_ascii_equivalent 0 1 482 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the character code associated with the button, or '\0' if no ASCII</span>
 <span class="s0">* code was associated.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline char ButtonHandle::get_ascii_equivalent(void) const;</span>

<span class="s0">1434 9 get_alias 0 4 1976 23 ButtonHandle::get_alias 0 1 483 373</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alias (alternate name) associated with the button, if any, or</span>
 <span class="s0">* ButtonHandle::none() if the button has no alias.</span>
 <span class="s0">*</span>
 <span class="s0">* Each button is allowed to have one alias, and multiple different buttons</span>
 <span class="s0">* can refer to the same alias.  The alias should be the more general name for</span>
 <span class="s0">* the button, for instance, shift is an alias for lshift, but not vice-versa.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">ButtonHandle ButtonHandle::get_alias(void) const;</span>

<span class="s0">1435 7 matches 0 4 1976 21 ButtonHandle::matches 0 1 484 263</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this ButtonHandle is the same as the other one, or if the</span>
 <span class="s0">* other one is an alias for this one.  (Does not return true if this button</span>
 <span class="s0">* is an alias for the other one, however.)</span>
 <span class="s0">*</span>
 <span class="s0">* This is a more general comparison than operator ==.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline bool ButtonHandle::matches(ButtonHandle const &amp;other) const;</span>

<span class="s0">1436 9 get_index 0 4 1976 23 ButtonHandle::get_index 0 1 485 363</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the integer index associated with this ButtonHandle.  Each</span>
 <span class="s0">* different ButtonHandle will have a different index.  However, you probably</span>
 <span class="s0">* shouldn't be using this method; you should just treat the ButtonHandles as</span>
 <span class="s0">* opaque classes.  This is provided for the convenience of non-C++ scripting</span>
 <span class="s0">* languages to build a hashtable of ButtonHandles.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">constexpr int ButtonHandle::get_index(void) const;</span>

<span class="s0">1437 6 output 0 4 1976 20 ButtonHandle::output 0 1 486 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void ButtonHandle::output(std::ostream &amp;out) const;</span>

<span class="s0">1438 4 none 0 4 1976 18 ButtonHandle::none 0 1 487 0</span>
<span class="s0">55</span>
<span class="s0">static constexpr ButtonHandle ButtonHandle::none(void);</span>

<span class="s0">1439 22 operator typecast bool 0 132 1976 36 ButtonHandle::operator typecast bool 0 1 489 0</span>
<span class="s0">34</span>
<span class="s0">inline operator bool (void) const;</span>

<span class="s0">1440 14 get_class_type 0 4 1976 28 ButtonHandle::get_class_type 0 1 488 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle ButtonHandle::get_class_type(void);</span>

<span class="s0">1441 13 ~ButtonHandle 0 516 1976 27 ButtonHandle::~ButtonHandle 0 0 0</span>
<span class="s0">34</span>
<span class="s0">ButtonHandle::~ButtonHandle(void);</span>

<span class="s0">1442 10 get_button 0 4 1980 26 ButtonRegistry::get_button 0 1 491 150</span>
<span class="s0">/**</span>
 <span class="s0">* Finds a ButtonHandle in the registry matching the indicated name.  If there</span>
 <span class="s0">* is no such ButtonHandle, registers a new one and returns it.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">ButtonHandle ButtonRegistry::get_button(std::string const &amp;name);</span>

<span class="s0">1443 11 find_button 0 4 1980 27 ButtonRegistry::find_button 0 1 492 144</span>
<span class="s0">/**</span>
 <span class="s0">* Finds a ButtonHandle in the registry matching the indicated name.  If there</span>
 <span class="s0">* is no such ButtonHandle, returns ButtonHandle::none().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">ButtonHandle ButtonRegistry::find_button(std::string const &amp;name);</span>

<span class="s0">1444 17 find_ascii_button 0 4 1980 33 ButtonRegistry::find_ascii_button 0 1 493 169</span>
<span class="s0">/**</span>
 <span class="s0">* Finds a ButtonHandle in the registry matching the indicated ASCII</span>
 <span class="s0">* equivalent character.  If there is no such ButtonHandle, returns</span>
 <span class="s0">* ButtonHandle::none().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const;</span>

<span class="s0">1445 5 write 0 4 1980 21 ButtonRegistry::write 0 1 494 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void ButtonRegistry::write(std::ostream &amp;out) const;</span>

<span class="s0">1446 3 ptr 0 4 1980 19 ButtonRegistry::ptr 0 1 495 134</span>
<span class="s0">// ptr() returns the pointer to the global ButtonRegistry object.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the global ButtonRegistry object.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static inline ButtonRegistry *ButtonRegistry::ptr(void);</span>

<span class="s0">1447 14 ButtonRegistry 0 260 1980 30 ButtonRegistry::ButtonRegistry 0 1 490 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline ButtonRegistry::ButtonRegistry(ButtonRegistry const &amp;) = default;</span>

<span class="s0">1448 15 ~ButtonRegistry 0 516 1980 31 ButtonRegistry::~ButtonRegistry 0 0 0</span>
<span class="s0">38</span>
<span class="s0">ButtonRegistry::~ButtonRegistry(void);</span>

<span class="s0">1449 15 get_num_buttons 0 4 1981 26 ButtonMap::get_num_buttons 0 1 498 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of buttons that this button mapping specifies.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline std::size_t ButtonMap::get_num_buttons(void) const;</span>

<span class="s0">1450 14 get_raw_button 0 4 1981 25 ButtonMap::get_raw_button 0 1 499 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the underlying raw button associated with the nth button.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline ButtonHandle ButtonMap::get_raw_button(std::size_t i) const;</span>

<span class="s0">1451 17 get_mapped_button 0 4 1981 28 ButtonMap::get_mapped_button 0 3 500 501 502 437</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth mapped button, meaning the button that the nth raw button</span>
 <span class="s0">* is mapped to.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the button that the given button is mapped to, or</span>
 <span class="s0">* ButtonHandle::none() if this map does not specify a mapped button for the</span>
 <span class="s0">* given raw button.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the button that the given button is mapped to, or</span>
 <span class="s0">* ButtonHandle::none() if this map does not specify a mapped button for the</span>
 <span class="s0">* given raw button.</span>
 <span class="s0">*/</span>
<span class="s0">229</span>
<span class="s0">inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const;</span>
<span class="s0">inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const;</span>
<span class="s0">inline ButtonHandle ButtonMap::get_mapped_button(std::string const &amp;raw_name) const;</span>

<span class="s0">1452 23 get_mapped_button_label 0 4 1981 34 ButtonMap::get_mapped_button_label 0 3 503 504 505 837</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the label associated with the nth mapped button, meaning the button</span>
 <span class="s0">* that the nth raw button is mapped to.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* If the button map specifies a special name for the button (eg.  if the</span>
 <span class="s0">* operating system or keyboard device has a localized name describing the</span>
 <span class="s0">* key), returns it, or the empty string otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this is not the same as get_mapped_button().get_name(), which</span>
 <span class="s0">* returns the name of the Panda event associated with the button.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* If the button map specifies a special name for the button (eg.  if the</span>
 <span class="s0">* operating system or keyboard device has a localized name describing the</span>
 <span class="s0">* key), returns it, or the empty string otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this is not the same as get_mapped_button().get_name(), which</span>
 <span class="s0">* returns the name of the Panda event associated with the button.</span>
 <span class="s0">*/</span>
<span class="s0">265</span>
<span class="s0">inline std::string const &amp;ButtonMap::get_mapped_button_label(std::size_t i) const;</span>
<span class="s0">inline std::string const &amp;ButtonMap::get_mapped_button_label(ButtonHandle raw) const;</span>
<span class="s0">inline std::string const &amp;ButtonMap::get_mapped_button_label(std::string const &amp;raw_name) const;</span>

<span class="s0">1453 6 output 0 4 1981 17 ButtonMap::output 0 1 506 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void ButtonMap::output(std::ostream &amp;out) const;</span>

<span class="s0">1454 5 write 0 4 1981 16 ButtonMap::write 0 1 507 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void ButtonMap::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1455 14 get_class_type 0 4 1981 25 ButtonMap::get_class_type 0 1 508 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle ButtonMap::get_class_type(void);</span>

<span class="s0">1456 9 ButtonMap 0 260 1981 20 ButtonMap::ButtonMap 0 2 496 497 0</span>
<span class="s0">102</span>
<span class="s0">inline ButtonMap::ButtonMap(void) = default;</span>
<span class="s0">inline ButtonMap::ButtonMap(ButtonMap const &amp;) = default;</span>

<span class="s0">1457 10 ~ButtonMap 0 516 1981 21 ButtonMap::~ButtonMap 0 0 0</span>
<span class="s0">28</span>
<span class="s0">ButtonMap::~ButtonMap(void);</span>

<span class="s0">1458 6 output 0 6 1983 22 CallbackObject::output 0 1 510 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual void CallbackObject::output(std::ostream &amp;out) const;</span>

<span class="s0">1459 4 make 0 4 1983 20 CallbackObject::make 0 1 511 0</span>
<span class="s0">76</span>
<span class="s0">static PointerTo&lt; CallbackObject &gt; CallbackObject::make(PyObject *function);</span>

<span class="s0">1460 14 get_class_type 0 4 1983 30 CallbackObject::get_class_type 0 1 512 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle CallbackObject::get_class_type(void);</span>

<span class="s0">1461 14 CallbackObject 0 260 1983 30 CallbackObject::CallbackObject 0 1 509 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline CallbackObject::CallbackObject(CallbackObject const &amp;) = default;</span>

<span class="s0">1462 15 ~CallbackObject 0 516 1983 31 CallbackObject::~CallbackObject 0 0 0</span>
<span class="s0">38</span>
<span class="s0">CallbackObject::~CallbackObject(void);</span>

<span class="s0">1463 19 get_cache_ref_count 0 4 1984 54 CachedTypedWritableReferenceCount::get_cache_ref_count 0 1 513 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current reference count.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const;</span>

<span class="s0">1464 9 cache_ref 0 4 1984 44 CachedTypedWritableReferenceCount::cache_ref 0 1 514 108</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly increments the cache reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void CachedTypedWritableReferenceCount::cache_ref(void) const;</span>

<span class="s0">1465 11 cache_unref 0 4 1984 46 CachedTypedWritableReferenceCount::cache_unref 0 1 515 202</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly decrements the cache reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the new reference count is nonzero, false if it</span>
 <span class="s0">* is zero.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline bool CachedTypedWritableReferenceCount::cache_unref(void) const;</span>

<span class="s0">1466 24 test_ref_count_integrity 0 4 1984 59 CachedTypedWritableReferenceCount::test_ref_count_integrity 0 1 516 97</span>
<span class="s0">/**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't</span>
 <span class="s0">* completely bogus.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const;</span>

<span class="s0">1467 14 get_class_type 0 4 1984 49 CachedTypedWritableReferenceCount::get_class_type 0 1 517 0</span>
<span class="s0">74</span>
<span class="s0">static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void);</span>

<span class="s0">1468 6 output 0 6 1985 20 CallbackData::output 0 1 518 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual void CallbackData::output(std::ostream &amp;out) const;</span>

<span class="s0">1469 6 upcall 0 6 1985 20 CallbackData::upcall 0 1 519 159</span>
<span class="s0">/**</span>
 <span class="s0">* You should make this call during the callback if you want to continue the</span>
 <span class="s0">* normal function that would have been done in the absence of a callback.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">virtual void CallbackData::upcall(void);</span>

<span class="s0">1470 14 get_class_type 0 4 1985 28 CallbackData::get_class_type 0 1 520 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle CallbackData::get_class_type(void);</span>

<span class="s0">1471 13 ~CallbackData 0 516 1985 27 CallbackData::~CallbackData 0 0 0</span>
<span class="s0">34</span>
<span class="s0">CallbackData::~CallbackData(void);</span>

<span class="s0">1472 20 PythonCallbackObject 0 260 1986 42 PythonCallbackObject::PythonCallbackObject 0 2 521 522 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">177</span>
<span class="s0">PythonCallbackObject::PythonCallbackObject(PyObject *function = (&amp; ::_Py_NoneStruct));</span>
<span class="s0">inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &amp;) = default;</span>

<span class="s0">1473 12 operator new 0 4 1986 34 PythonCallbackObject::operator new 0 1 523 0</span>
<span class="s0">144</span>
<span class="s0">inline void *PythonCallbackObject::operator new(std::size_t size);</span>
<span class="s0">inline void *PythonCallbackObject::operator new(std::size_t size, void *ptr);</span>

<span class="s0">1474 15 operator delete 0 4 1986 37 PythonCallbackObject::operator delete 0 0 0</span>
<span class="s0">128</span>
<span class="s0">inline void PythonCallbackObject::operator delete(void *ptr);</span>
<span class="s0">inline void PythonCallbackObject::operator delete(void *, void *);</span>

<span class="s0">1475 12 validate_ptr 0 4 1986 34 PythonCallbackObject::validate_ptr 0 0 0</span>
<span class="s0">71</span>
<span class="s0">static inline bool PythonCallbackObject::validate_ptr(void const *ptr);</span>

<span class="s0">1476 12 set_function 0 4 1986 34 PythonCallbackObject::set_function 0 1 524 126</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the function that is called for the callback.  runs.  The</span>
 <span class="s0">* parameter should be a Python callable object.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void PythonCallbackObject::set_function(PyObject *function);</span>

<span class="s0">1477 12 get_function 0 4 1986 34 PythonCallbackObject::get_function 0 1 525 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the function that is called for the callback.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">PyObject *PythonCallbackObject::get_function(void);</span>

<span class="s0">1478 14 get_class_type 0 4 1986 36 PythonCallbackObject::get_class_type 0 1 526 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle PythonCallbackObject::get_class_type(void);</span>

<span class="s0">1479 7 TimeVal 0 260 1987 16 TimeVal::TimeVal 0 2 527 528 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline TimeVal::TimeVal(void);</span>
<span class="s0">inline TimeVal::TimeVal(TimeVal const &amp;) = default;</span>

<span class="s0">1480 7 get_sec 0 4 1987 16 TimeVal::get_sec 0 1 529 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline ulong TimeVal::get_sec(void) const;</span>

<span class="s0">1481 8 get_usec 0 4 1987 17 TimeVal::get_usec 0 1 530 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline ulong TimeVal::get_usec(void) const;</span>

<span class="s0">1482 6 get_tv 0 20 1987 15 TimeVal::get_tv 0 0 32</span>
<span class="s0">getter for ulong TimeVal::tv[2];</span>
<span class="s0">35</span>
<span class="s0">ulong *TimeVal::get_tv(void) const;</span>

<span class="s0">1483 6 set_tv 0 36 1987 15 TimeVal::set_tv 0 0 32</span>
<span class="s0">setter for ulong TimeVal::tv[2];</span>
<span class="s0">37</span>
<span class="s0">void TimeVal::set_tv(ulong value[2]);</span>

<span class="s0">1484 8 ~TimeVal 0 516 1987 17 TimeVal::~TimeVal 0 0 0</span>
<span class="s0">24</span>
<span class="s0">TimeVal::~TimeVal(void);</span>

<span class="s0">1485 11 ClockObject 0 260 1991 24 ClockObject::ClockObject 0 2 531 532 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">ClockObject::ClockObject(ClockObject::Mode mode = ::ClockObject::M_normal);</span>
<span class="s0">ClockObject::ClockObject(ClockObject const &amp;copy);</span>

<span class="s0">1486 8 set_mode 0 4 1991 21 ClockObject::set_mode 0 1 533 1841</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the mode of the clock.  Normally, the clock is in mode M_normal.</span>
 <span class="s0">* In this mode, each call to tick() will set the value returned by</span>
 <span class="s0">* get_frame_time() to the current real time; thus, the clock simply reports</span>
 <span class="s0">* time advancing.</span>
 <span class="s0">*</span>
 <span class="s0">* Other possible modes:</span>
 <span class="s0">*</span>
 <span class="s0">* M_non_real_time - the clock ignores real time completely; at each call to</span>
 <span class="s0">* tick(), it pretends that exactly dt seconds have elapsed since the last</span>
 <span class="s0">* call to tick().  You may set the value of dt with set_dt() or</span>
 <span class="s0">* set_frame_rate().</span>
 <span class="s0">*</span>
 <span class="s0">* M_limited - the clock will run as fast as it can, as in M_normal, but will</span>
 <span class="s0">* not run faster than the rate specified by set_frame_rate().  If the</span>
 <span class="s0">* application would run faster than this rate, the clock will slow down the</span>
 <span class="s0">* application.</span>
 <span class="s0">*</span>
 <span class="s0">* M_integer - the clock will run as fast as it can, but the rate will be</span>
 <span class="s0">* constrained to be an integer multiple or divisor of the rate specified by</span>
 <span class="s0">* set_frame_rate().  The clock will slow down the application a bit to</span>
 <span class="s0">* guarantee this.</span>
 <span class="s0">*</span>
 <span class="s0">* M_integer_limited - a combination of M_limited and M_integer; the clock</span>
 <span class="s0">* will not run faster than set_frame_rate(), and if it runs slower, it will</span>
 <span class="s0">* run at a integer divisor of that rate.</span>
 <span class="s0">*</span>
 <span class="s0">* M_forced - the clock forces the application to run at the rate specified by</span>
 <span class="s0">* set_frame_rate().  If the application would run faster than this rate, the</span>
 <span class="s0">* clock will slow down the application; if the application would run slower</span>
 <span class="s0">* than this rate, the clock slows down time so that the application believes</span>
 <span class="s0">* it is running at the given rate.</span>
 <span class="s0">*</span>
 <span class="s0">* M_degrade - the clock runs at real time, but the application is slowed down</span>
 <span class="s0">* by a set factor of its frame rate, specified by set_degrade_factor().</span>
 <span class="s0">*</span>
 <span class="s0">* M_slave - the clock does not advance, but relies on the user to call</span>
 <span class="s0">* set_frame_time() and/or set_frame_count() each frame.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void ClockObject::set_mode(ClockObject::Mode mode);</span>

<span class="s0">1487 8 get_mode 0 4 1991 21 ClockObject::get_mode 0 1 534 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current mode of the clock.  See set_mode().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline ClockObject::Mode ClockObject::get_mode(void) const;</span>

<span class="s0">1488 14 get_frame_time 0 4 1991 27 ClockObject::get_frame_time 0 1 535 350</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time in seconds as of the last time tick() was called</span>
 <span class="s0">* (typically, this will be as of the start of the current frame).</span>
 <span class="s0">*</span>
 <span class="s0">* This is generally the kind of time you want to ask for in most rendering</span>
 <span class="s0">* and animation contexts, since it's important that all of the animation for</span>
 <span class="s0">* a given frame remains in sync with each other.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">inline double ClockObject::get_frame_time(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1489 13 get_real_time 0 4 1991 26 ClockObject::get_real_time 0 1 536 434</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the actual number of seconds elapsed since the ClockObject was</span>
 <span class="s0">* created, or since it was last reset.  This is useful for doing real timing</span>
 <span class="s0">* measurements, e.g.  for performance statistics.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the most precise timer we have for short time intervals, but</span>
 <span class="s0">* it may tend to drift over the long haul.  If more accurate timekeeping is</span>
 <span class="s0">* needed over a long period of time, use get_long_time() instead.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double ClockObject::get_real_time(void) const;</span>

<span class="s0">1490 13 get_long_time 0 4 1991 26 ClockObject::get_long_time 0 1 537 440</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the actual number of seconds elapsed since the ClockObject was</span>
 <span class="s0">* created, or since it was last reset.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to get_real_time(), except that it uses the most accurate</span>
 <span class="s0">* counter we have over a long period of time, and so it is less likely to</span>
 <span class="s0">* drift.  However, it may not be very precise for measuring short intervals.</span>
 <span class="s0">* On Windows, for instace, this is only accurate to within about 55</span>
 <span class="s0">* milliseconds.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double ClockObject::get_long_time(void) const;</span>

<span class="s0">1491 5 reset 0 4 1991 18 ClockObject::reset 0 1 538 75</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously resets both the time and the frame count to zero.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline void ClockObject::reset(void);</span>

<span class="s0">1492 13 set_real_time 0 4 1991 26 ClockObject::set_real_time 0 1 539 316</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the clock to the indicated time.  This changes only the real time of</span>
 <span class="s0">* the clock as reported by get_real_time(), but does not immediately change</span>
 <span class="s0">* the time reported by get_frame_time()--that will change after the next call</span>
 <span class="s0">* to tick().  Also see reset(), set_frame_time(), and set_frame_count().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void ClockObject::set_real_time(double time);</span>

<span class="s0">1493 14 set_frame_time 0 4 1991 27 ClockObject::set_frame_time 0 1 540 215</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the time as reported for the current frame to the indicated time.</span>
 <span class="s0">* Normally, the way to adjust the frame time is via tick(); this function is</span>
 <span class="s0">* provided only for occasional special adjustments.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">void ClockObject::set_frame_time(double time, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">1494 15 set_frame_count 0 4 1991 28 ClockObject::set_frame_count 0 1 541 132</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the number of frames counted to the indicated number.  Also see</span>
 <span class="s0">* reset(), set_real_time(), and set_frame_time().</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">void ClockObject::set_frame_count(int frame_count, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">1495 15 get_frame_count 0 4 1991 28 ClockObject::get_frame_count 0 1 542 195</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of times tick() has been called since the ClockObject</span>
 <span class="s0">* was created, or since it was last reset.  This is generally the number of</span>
 <span class="s0">* frames that have been rendered.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">inline int ClockObject::get_frame_count(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1496 18 get_net_frame_rate 0 4 1991 31 ClockObject::get_net_frame_rate 0 1 543 245</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the average frame rate since the last reset.  This is simply the</span>
 <span class="s0">* total number of frames divided by the total elapsed time.  This reports the</span>
 <span class="s0">* virtual frame rate if the clock is in (or has been in) M_non_real_time</span>
 <span class="s0">* mode.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline double ClockObject::get_net_frame_rate(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1497 6 get_dt 0 4 1991 19 ClockObject::get_dt 0 1 544 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the elapsed time for the previous frame: the number of seconds</span>
 <span class="s0">* elapsed between the last two calls to tick().</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline double ClockObject::get_dt(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1498 6 set_dt 0 4 1991 19 ClockObject::set_dt 0 1 545 291</span>
<span class="s0">/**</span>
 <span class="s0">* In non-real-time mode, sets the number of seconds that should appear to</span>
 <span class="s0">* elapse between frames.  In forced mode or limited mode, sets our target dt.</span>
 <span class="s0">* In normal mode, this has no effect.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_frame_rate(), which is a different way to specify the same</span>
 <span class="s0">* quantity.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void ClockObject::set_dt(double dt);</span>

<span class="s0">1499 14 set_frame_rate 0 4 1991 27 ClockObject::set_frame_rate 0 1 546 291</span>
<span class="s0">/**</span>
 <span class="s0">* In non-real-time mode, sets the number of frames per second that we should</span>
 <span class="s0">* appear to be running.  In forced mode or limited mode, sets our target</span>
 <span class="s0">* frame rate.  In normal mode, this has no effect.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_dt(), which is a different way to specify the same quantity.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void ClockObject::set_frame_rate(double frame_rate);</span>

<span class="s0">1500 10 get_max_dt 0 4 1991 23 ClockObject::get_max_dt 0 1 547 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current maximum allowable time elapsed between any two frames.</span>
 <span class="s0">* See set_max_dt().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline double ClockObject::get_max_dt(void) const;</span>

<span class="s0">1501 10 set_max_dt 0 4 1991 23 ClockObject::set_max_dt 0 1 548 511</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a limit on the value returned by get_dt().  If this value is less than</span>
 <span class="s0">* zero, no limit is imposed; otherwise, this is the maximum value that will</span>
 <span class="s0">* ever be returned by get_dt(), regardless of how much time has actually</span>
 <span class="s0">* elapsed between frames.</span>
 <span class="s0">*</span>
 <span class="s0">* This limit is only imposed in real-time mode; in non-real-time mode, the dt</span>
 <span class="s0">* is fixed anyway and max_dt is ignored.</span>
 <span class="s0">*</span>
 <span class="s0">* This is generally used to guarantee reasonable behavior even in the</span>
 <span class="s0">* presence of a very slow or chuggy frame rame.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void ClockObject::set_max_dt(double max_dt);</span>

<span class="s0">1502 18 get_degrade_factor 0 4 1991 31 ClockObject::get_degrade_factor 0 1 549 265</span>
<span class="s0">/**</span>
 <span class="s0">* In degrade mode, returns the ratio by which the performance is degraded.  A</span>
 <span class="s0">* value of 2.0 causes the clock to be slowed down by a factor of two</span>
 <span class="s0">* (reducing performance to 1/2 what would be otherwise).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no effect if mode is not M_degrade.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline double ClockObject::get_degrade_factor(void) const;</span>

<span class="s0">1503 18 set_degrade_factor 0 4 1991 31 ClockObject::set_degrade_factor 0 1 550 262</span>
<span class="s0">/**</span>
 <span class="s0">* In degrade mode, sets the ratio by which the performance is degraded.  A</span>
 <span class="s0">* value of 2.0 causes the clock to be slowed down by a factor of two</span>
 <span class="s0">* (reducing performance to 1/2 what would be otherwise).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no effect if mode is not M_degrade.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void ClockObject::set_degrade_factor(double degrade_factor);</span>

<span class="s0">1504 31 set_average_frame_rate_interval 0 4 1991 44 ClockObject::set_average_frame_rate_interval 0 1 551 393</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the interval of time (in seconds) over which</span>
 <span class="s0">* get_average_frame_rate() averages the number of frames per second to</span>
 <span class="s0">* compute the frame rate.  Changing this does not necessarily immediately</span>
 <span class="s0">* change the result of get_average_frame_rate(), until this interval of time</span>
 <span class="s0">* has elapsed again.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this to zero disables the computation of get_average_frame_rate().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void ClockObject::set_average_frame_rate_interval(double time);</span>

<span class="s0">1505 31 get_average_frame_rate_interval 0 4 1991 44 ClockObject::get_average_frame_rate_interval 0 1 552 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the interval of time (in seconds) over which</span>
 <span class="s0">* get_average_frame_rate() averages the number of frames per second to</span>
 <span class="s0">* compute the frame rate.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline double ClockObject::get_average_frame_rate_interval(void) const;</span>

<span class="s0">1506 22 get_average_frame_rate 0 4 1991 35 ClockObject::get_average_frame_rate 0 1 553 214</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the average frame rate in number of frames per second over the last</span>
 <span class="s0">* get_average_frame_rate_interval() seconds.  This measures the virtual frame</span>
 <span class="s0">* rate if the clock is in M_non_real_time mode.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">double ClockObject::get_average_frame_rate(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1507 22 get_max_frame_duration 0 4 1991 35 ClockObject::get_max_frame_duration 0 1 554 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum frame duration over the last</span>
 <span class="s0">* get_average_frame_rate_interval() seconds.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">double ClockObject::get_max_frame_duration(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1508 25 calc_frame_rate_deviation 0 4 1991 38 ClockObject::calc_frame_rate_deviation 0 1 555 539</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard deviation of the frame times of the frames rendered</span>
 <span class="s0">* over the past get_average_frame_rate_interval() seconds.  This number gives</span>
 <span class="s0">* an estimate of the chugginess of the frame rate; if it is large, there is a</span>
 <span class="s0">* large variation in the frame rate; if is small, all of the frames are</span>
 <span class="s0">* consistent in length.</span>
 <span class="s0">*</span>
 <span class="s0">* A large value might also represent just a recent change in frame rate, for</span>
 <span class="s0">* instance, because the camera has just rotated from looking at a simple</span>
 <span class="s0">* scene to looking at a more complex scene.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">double ClockObject::calc_frame_rate_deviation(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1509 4 tick 0 4 1991 17 ClockObject::tick 0 1 556 285</span>
<span class="s0">/**</span>
 <span class="s0">* Instructs the clock that a new frame has just begun.  In normal, real-time</span>
 <span class="s0">* mode, get_frame_time() will henceforth report the time as of this instant</span>
 <span class="s0">* as the current start-of-frame time.  In non-real-time mode,</span>
 <span class="s0">* get_frame_time() will be incremented by the value of dt.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void ClockObject::tick(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">1510 15 sync_frame_time 0 4 1991 28 ClockObject::sync_frame_time 0 1 557 417</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the frame time to the current real time.  This is similar to tick(),</span>
 <span class="s0">* except that it does not advance the frame counter and does not affect dt.</span>
 <span class="s0">* This is intended to be used in the middle of a particularly long frame to</span>
 <span class="s0">* compensate for the time that has already elapsed.</span>
 <span class="s0">*</span>
 <span class="s0">* In non-real-time mode, this function has no effect (because in this mode</span>
 <span class="s0">* all frames take the same length of time).</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void ClockObject::sync_frame_time(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">1511 12 check_errors 0 4 1991 25 ClockObject::check_errors 0 1 558 322</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a clock error was detected since the last time</span>
 <span class="s0">* check_errors() was called.  A clock error means that something happened, an</span>
 <span class="s0">* OS or BIOS bug, for instance, that makes the current value of the clock</span>
 <span class="s0">* somewhat suspect, and an application may wish to resynchronize with any</span>
 <span class="s0">* external clocks.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool ClockObject::check_errors(Thread *current_thread);</span>

<span class="s0">1512 16 get_global_clock 0 4 1991 29 ClockObject::get_global_clock 0 1 559 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global ClockObject.  This is the ClockObject that</span>
 <span class="s0">* most code should use for handling scene graph rendering and animation.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static inline ClockObject *ClockObject::get_global_clock(void);</span>

<span class="s0">1513 14 get_class_type 0 4 1991 27 ClockObject::get_class_type 0 1 560 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle ClockObject::get_class_type(void);</span>

<span class="s0">1514 24 parse_color_space_string 0 1 0 24 parse_color_space_string 0 1 959 0</span>
<span class="s0">60</span>
<span class="s0">ColorSpace parse_color_space_string(std::string const &amp;str);</span>

<span class="s0">1515 18 format_color_space 0 1 0 18 format_color_space 0 1 960 0</span>
<span class="s0">46</span>
<span class="s0">std::string format_color_space(ColorSpace cs);</span>

<span class="s0">1516 14 get_model_path 0 1 0 14 get_model_path 0 1 961 0</span>
<span class="s0">47</span>
<span class="s0">ConfigVariableSearchPath &amp;get_model_path(void);</span>

<span class="s0">1517 15 get_plugin_path 0 1 0 15 get_plugin_path 0 1 962 0</span>
<span class="s0">48</span>
<span class="s0">ConfigVariableSearchPath &amp;get_plugin_path(void);</span>

<span class="s0">1518 9 cache_ref 0 4 1995 28 CopyOnWriteObject::cache_ref 0 1 561 62</span>
<span class="s0">/**</span>
 <span class="s0">* @see CachedTypedWritableReferenceCount::cache_ref()</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void CopyOnWriteObject::cache_ref(void) const;</span>

<span class="s0">1519 11 cache_unref 0 4 1995 30 CopyOnWriteObject::cache_unref 0 1 562 64</span>
<span class="s0">/**</span>
 <span class="s0">* @see CachedTypedWritableReferenceCount::cache_unref()</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool CopyOnWriteObject::cache_unref(void) const;</span>

<span class="s0">1520 14 get_class_type 0 4 1995 33 CopyOnWriteObject::get_class_type 0 1 563 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle CopyOnWriteObject::get_class_type(void);</span>

<span class="s0">1521 18 ~CopyOnWriteObject 0 516 1995 37 CopyOnWriteObject::~CopyOnWriteObject 0 0 0</span>
<span class="s0">44</span>
<span class="s0">CopyOnWriteObject::~CopyOnWriteObject(void);</span>

<span class="s0">1522 22 upcast_to_DatagramSink 0 12 1996 38 DatagramBuffer::upcast_to_DatagramSink 0 1 567 42</span>
<span class="s0">upcast from DatagramBuffer to DatagramSink</span>
<span class="s0">59</span>
<span class="s0">DatagramSink *DatagramBuffer::upcast_to_DatagramSink(void);</span>

<span class="s0">1523 26 downcast_to_DatagramBuffer 0 12 1966 40 DatagramSink::downcast_to_DatagramBuffer 0 0 44</span>
<span class="s0">downcast from DatagramSink to DatagramBuffer</span>
<span class="s0">63</span>
<span class="s0">DatagramBuffer *DatagramSink::downcast_to_DatagramBuffer(void);</span>

<span class="s0">1524 27 upcast_to_DatagramGenerator 0 12 1996 43 DatagramBuffer::upcast_to_DatagramGenerator 0 1 568 47</span>
<span class="s0">upcast from DatagramBuffer to DatagramGenerator</span>
<span class="s0">69</span>
<span class="s0">DatagramGenerator *DatagramBuffer::upcast_to_DatagramGenerator(void);</span>

<span class="s0">1525 26 downcast_to_DatagramBuffer 0 12 1959 45 DatagramGenerator::downcast_to_DatagramBuffer 0 0 49</span>
<span class="s0">downcast from DatagramGenerator to DatagramBuffer</span>
<span class="s0">68</span>
<span class="s0">DatagramBuffer *DatagramGenerator::downcast_to_DatagramBuffer(void);</span>

<span class="s0">1526 14 DatagramBuffer 0 260 1996 30 DatagramBuffer::DatagramBuffer 0 2 564 565 104</span>
<span class="s0">/**</span>
 <span class="s0">* Initializes an empty datagram buffer.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Initializes the buffer with the given data.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">inline DatagramBuffer::DatagramBuffer(void);</span>
<span class="s0">inline explicit DatagramBuffer::DatagramBuffer(vector_uchar data);</span>

<span class="s0">1527 5 clear 0 4 1996 21 DatagramBuffer::clear 0 1 566 38</span>
<span class="s0">/**</span>
 <span class="s0">* Clears the internal buffer.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline void DatagramBuffer::clear(void);</span>

<span class="s0">1528 8 get_data 0 4 1996 24 DatagramBuffer::get_data 0 0 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the internal buffer.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline vector_uchar const &amp;DatagramBuffer::get_data(void) const;</span>

<span class="s0">1529 8 set_data 0 4 1996 24 DatagramBuffer::set_data 0 0 52</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the data in the internal buffer.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void DatagramBuffer::set_data(vector_uchar data);</span>

<span class="s0">1530 15 ~DatagramBuffer 0 516 1996 31 DatagramBuffer::~DatagramBuffer 0 0 0</span>
<span class="s0">38</span>
<span class="s0">DatagramBuffer::~DatagramBuffer(void);</span>

<span class="s0">1531 17 DatagramInputFile 0 260 2000 36 DatagramInputFile::DatagramInputFile 0 1 569 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline DatagramInputFile::DatagramInputFile(void);</span>

<span class="s0">1532 4 open 0 4 2000 23 DatagramInputFile::open 0 3 570 571 572 432</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the indicated filename for reading.  Returns true on success, false</span>
 <span class="s0">* on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Opens the indicated filename for reading.  Returns true on success, false</span>
 <span class="s0">* on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Starts reading from the indicated stream.  Returns true on success, false</span>
 <span class="s0">* on failure.  The DatagramInputFile does not take ownership of the stream;</span>
 <span class="s0">* you are responsible for closing or deleting it when you are done.</span>
 <span class="s0">*/</span>
<span class="s0">206</span>
<span class="s0">bool DatagramInputFile::open(FileReference const *file);</span>
<span class="s0">inline bool DatagramInputFile::open(Filename const &amp;filename);</span>
<span class="s0">bool DatagramInputFile::open(std::istream &amp;in, Filename const &amp;filename = Filename());</span>

<span class="s0">1533 10 get_stream 0 4 2000 29 DatagramInputFile::get_stream 0 1 573 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the istream represented by the input file.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline std::istream &amp;DatagramInputFile::get_stream(void);</span>

<span class="s0">1534 5 close 0 4 2000 24 DatagramInputFile::close 0 1 574 98</span>
<span class="s0">/**</span>
 <span class="s0">* Closes the file.  This is also implicitly done when the DatagramInputFile</span>
 <span class="s0">* destructs.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void DatagramInputFile::close(void);</span>

<span class="s0">1535 11 read_header 0 4 2000 30 DatagramInputFile::read_header 0 0 257</span>
<span class="s0">/**</span>
 <span class="s0">* Reads a sequence of bytes from the beginning of the datagram file.  This</span>
 <span class="s0">* may be called any number of times after the file has been opened and before</span>
 <span class="s0">* the first datagram is read.  It may not be called once the first datagram</span>
 <span class="s0">* has been read.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">bool DatagramInputFile::read_header(std::string &amp;header, std::size_t num_bytes);</span>

<span class="s0">1536 18 DatagramOutputFile 0 260 2001 38 DatagramOutputFile::DatagramOutputFile 0 1 575 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline DatagramOutputFile::DatagramOutputFile(void);</span>

<span class="s0">1537 4 open 0 4 2001 24 DatagramOutputFile::open 0 3 576 577 578 434</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the indicated filename for writing.  Returns true on success, false</span>
 <span class="s0">* on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Opens the indicated filename for writing.  Returns true if successful,</span>
 <span class="s0">* false on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Starts writing to the indicated stream.  Returns true on success, false on</span>
 <span class="s0">* failure.  The DatagramOutputFile does not take ownership of the stream; you</span>
 <span class="s0">* are responsible for closing or deleting it when you are done.</span>
 <span class="s0">*/</span>
<span class="s0">210</span>
<span class="s0">bool DatagramOutputFile::open(FileReference const *file);</span>
<span class="s0">inline bool DatagramOutputFile::open(Filename const &amp;filename);</span>
<span class="s0">bool DatagramOutputFile::open(std::ostream &amp;out, Filename const &amp;filename = Filename());</span>

<span class="s0">1538 5 close 0 4 2001 25 DatagramOutputFile::close 0 1 579 99</span>
<span class="s0">/**</span>
 <span class="s0">* Closes the file.  This is also implicitly done when the DatagramOutputFile</span>
 <span class="s0">* destructs.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void DatagramOutputFile::close(void);</span>

<span class="s0">1539 12 write_header 0 4 2001 32 DatagramOutputFile::write_header 0 1 580 256</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a sequence of bytes to the beginning of the datagram file.  This may</span>
 <span class="s0">* be called any number of times after the file has been opened and before the</span>
 <span class="s0">* first datagram is written.  It may not be called once the first datagram is</span>
 <span class="s0">* written.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool DatagramOutputFile::write_header(std::string const &amp;header);</span>

<span class="s0">1540 10 get_stream 0 4 2001 30 DatagramOutputFile::get_stream 0 0 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ostream represented by the output file.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline std::ostream &amp;DatagramOutputFile::get_stream(void);</span>

<span class="s0">1541 13 DoubleBitMask 0 260 2003 45 DoubleBitMask&lt; BitMaskNative &gt;::DoubleBitMask 0 3 581 582 583 0</span>
<span class="s0">245</span>
<span class="s0">constexpr DoubleBitMask&lt; BitMaskNative &gt;::DoubleBitMask(void) = default;</span>
<span class="s0">DoubleBitMask&lt; BitMaskNative &gt;::DoubleBitMask(PyObject *init_value);</span>
<span class="s0">inline DoubleBitMask&lt; BitMaskNative &gt;::DoubleBitMask(DoubleBitMask&lt; BitMaskNative &gt; const &amp;) = default;</span>

<span class="s0">1542 6 all_on 0 4 2003 38 DoubleBitMask&lt; BitMaskNative &gt;::all_on 0 1 584 0</span>
<span class="s0">90</span>
<span class="s0">static inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::all_on(void);</span>

<span class="s0">1543 7 all_off 0 4 2003 39 DoubleBitMask&lt; BitMaskNative &gt;::all_off 0 1 585 0</span>
<span class="s0">91</span>
<span class="s0">static inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::all_off(void);</span>

<span class="s0">1544 8 lower_on 0 4 2003 40 DoubleBitMask&lt; BitMaskNative &gt;::lower_on 0 1 586 0</span>
<span class="s0">99</span>
<span class="s0">static inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::lower_on(int on_bits);</span>

<span class="s0">1545 3 bit 0 4 2003 35 DoubleBitMask&lt; BitMaskNative &gt;::bit 0 1 587 0</span>
<span class="s0">92</span>
<span class="s0">static inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::bit(int index);</span>

<span class="s0">1546 5 range 0 4 2003 37 DoubleBitMask&lt; BitMaskNative &gt;::range 0 1 588 0</span>
<span class="s0">106</span>
<span class="s0">static inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::range(int low_bit, int size);</span>

<span class="s0">1547 16 has_max_num_bits 0 4 2003 48 DoubleBitMask&lt; BitMaskNative &gt;::has_max_num_bits 0 1 589 0</span>
<span class="s0">77</span>
<span class="s0">static constexpr bool DoubleBitMask&lt; BitMaskNative &gt;::has_max_num_bits(void);</span>

<span class="s0">1548 16 get_max_num_bits 0 4 2003 48 DoubleBitMask&lt; BitMaskNative &gt;::get_max_num_bits 0 1 590 0</span>
<span class="s0">76</span>
<span class="s0">static constexpr int DoubleBitMask&lt; BitMaskNative &gt;::get_max_num_bits(void);</span>

<span class="s0">1549 12 get_num_bits 0 4 2003 44 DoubleBitMask&lt; BitMaskNative &gt;::get_num_bits 0 1 591 0</span>
<span class="s0">71</span>
<span class="s0">constexpr int DoubleBitMask&lt; BitMaskNative &gt;::get_num_bits(void) const;</span>

<span class="s0">1550 7 get_bit 0 4 2003 39 DoubleBitMask&lt; BitMaskNative &gt;::get_bit 0 1 592 0</span>
<span class="s0">69</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::get_bit(int index) const;</span>

<span class="s0">1551 7 set_bit 0 4 2003 39 DoubleBitMask&lt; BitMaskNative &gt;::set_bit 0 1 593 0</span>
<span class="s0">63</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::set_bit(int index);</span>

<span class="s0">1552 9 clear_bit 0 4 2003 41 DoubleBitMask&lt; BitMaskNative &gt;::clear_bit 0 1 594 0</span>
<span class="s0">65</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::clear_bit(int index);</span>

<span class="s0">1553 10 set_bit_to 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::set_bit_to 0 1 595 0</span>
<span class="s0">78</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::set_bit_to(int index, bool value);</span>

<span class="s0">1554 7 is_zero 0 4 2003 39 DoubleBitMask&lt; BitMaskNative &gt;::is_zero 0 1 596 0</span>
<span class="s0">64</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::is_zero(void) const;</span>

<span class="s0">1555 9 is_all_on 0 4 2003 41 DoubleBitMask&lt; BitMaskNative &gt;::is_all_on 0 1 597 0</span>
<span class="s0">66</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::is_all_on(void) const;</span>

<span class="s0">1556 7 extract 0 4 2003 39 DoubleBitMask&lt; BitMaskNative &gt;::extract 0 1 598 0</span>
<span class="s0">85</span>
<span class="s0">inline uint64_t DoubleBitMask&lt; BitMaskNative &gt;::extract(int low_bit, int size) const;</span>

<span class="s0">1557 5 store 0 4 2003 37 DoubleBitMask&lt; BitMaskNative &gt;::store 0 1 599 0</span>
<span class="s0">89</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::store(uint64_t value, int low_bit, int size);</span>

<span class="s0">1558 10 has_any_of 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::has_any_of 0 1 600 0</span>
<span class="s0">84</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::has_any_of(int low_bit, int size) const;</span>

<span class="s0">1559 10 has_all_of 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::has_all_of 0 1 601 0</span>
<span class="s0">84</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::has_all_of(int low_bit, int size) const;</span>

<span class="s0">1560 9 set_range 0 4 2003 41 DoubleBitMask&lt; BitMaskNative &gt;::set_range 0 1 602 0</span>
<span class="s0">77</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::set_range(int low_bit, int size);</span>

<span class="s0">1561 11 clear_range 0 4 2003 43 DoubleBitMask&lt; BitMaskNative &gt;::clear_range 0 1 603 0</span>
<span class="s0">79</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::clear_range(int low_bit, int size);</span>

<span class="s0">1562 12 set_range_to 0 4 2003 44 DoubleBitMask&lt; BitMaskNative &gt;::set_range_to 0 1 604 0</span>
<span class="s0">92</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::set_range_to(bool value, int low_bit, int size);</span>

<span class="s0">1563 15 get_num_on_bits 0 4 2003 47 DoubleBitMask&lt; BitMaskNative &gt;::get_num_on_bits 0 1 605 0</span>
<span class="s0">71</span>
<span class="s0">inline int DoubleBitMask&lt; BitMaskNative &gt;::get_num_on_bits(void) const;</span>

<span class="s0">1564 16 get_num_off_bits 0 4 2003 48 DoubleBitMask&lt; BitMaskNative &gt;::get_num_off_bits 0 1 606 0</span>
<span class="s0">72</span>
<span class="s0">inline int DoubleBitMask&lt; BitMaskNative &gt;::get_num_off_bits(void) const;</span>

<span class="s0">1565 17 get_lowest_on_bit 0 4 2003 49 DoubleBitMask&lt; BitMaskNative &gt;::get_lowest_on_bit 0 1 607 0</span>
<span class="s0">73</span>
<span class="s0">inline int DoubleBitMask&lt; BitMaskNative &gt;::get_lowest_on_bit(void) const;</span>

<span class="s0">1566 18 get_lowest_off_bit 0 4 2003 50 DoubleBitMask&lt; BitMaskNative &gt;::get_lowest_off_bit 0 1 608 0</span>
<span class="s0">74</span>
<span class="s0">inline int DoubleBitMask&lt; BitMaskNative &gt;::get_lowest_off_bit(void) const;</span>

<span class="s0">1567 18 get_highest_on_bit 0 4 2003 50 DoubleBitMask&lt; BitMaskNative &gt;::get_highest_on_bit 0 1 609 0</span>
<span class="s0">74</span>
<span class="s0">inline int DoubleBitMask&lt; BitMaskNative &gt;::get_highest_on_bit(void) const;</span>

<span class="s0">1568 19 get_highest_off_bit 0 4 2003 51 DoubleBitMask&lt; BitMaskNative &gt;::get_highest_off_bit 0 1 610 0</span>
<span class="s0">75</span>
<span class="s0">inline int DoubleBitMask&lt; BitMaskNative &gt;::get_highest_off_bit(void) const;</span>

<span class="s0">1569 29 get_next_higher_different_bit 0 4 2003 61 DoubleBitMask&lt; BitMaskNative &gt;::get_next_higher_different_bit 0 1 611 0</span>
<span class="s0">92</span>
<span class="s0">inline int DoubleBitMask&lt; BitMaskNative &gt;::get_next_higher_different_bit(int low_bit) const;</span>

<span class="s0">1570 15 invert_in_place 0 4 2003 47 DoubleBitMask&lt; BitMaskNative &gt;::invert_in_place 0 1 612 0</span>
<span class="s0">66</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::invert_in_place(void);</span>

<span class="s0">1571 18 has_bits_in_common 0 4 2003 50 DoubleBitMask&lt; BitMaskNative &gt;::has_bits_in_common 0 1 613 0</span>
<span class="s0">114</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::has_bits_in_common(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1572 5 clear 0 4 2003 37 DoubleBitMask&lt; BitMaskNative &gt;::clear 0 1 614 0</span>
<span class="s0">56</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::clear(void);</span>

<span class="s0">1573 6 output 0 4 2003 38 DoubleBitMask&lt; BitMaskNative &gt;::output 0 1 615 0</span>
<span class="s0">69</span>
<span class="s0">void DoubleBitMask&lt; BitMaskNative &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">1574 13 output_binary 0 4 2003 45 DoubleBitMask&lt; BitMaskNative &gt;::output_binary 0 1 616 0</span>
<span class="s0">98</span>
<span class="s0">void DoubleBitMask&lt; BitMaskNative &gt;::output_binary(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1575 10 output_hex 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::output_hex 0 1 617 0</span>
<span class="s0">95</span>
<span class="s0">void DoubleBitMask&lt; BitMaskNative &gt;::output_hex(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1576 5 write 0 4 2003 37 DoubleBitMask&lt; BitMaskNative &gt;::write 0 1 618 0</span>
<span class="s0">90</span>
<span class="s0">void DoubleBitMask&lt; BitMaskNative &gt;::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1577 11 operator == 0 4 2003 43 DoubleBitMask&lt; BitMaskNative &gt;::operator == 0 1 619 0</span>
<span class="s0">107</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::operator ==(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1578 11 operator != 0 4 2003 43 DoubleBitMask&lt; BitMaskNative &gt;::operator != 0 1 620 0</span>
<span class="s0">107</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::operator !=(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1579 10 operator &lt; 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::operator &lt; 0 1 621 0</span>
<span class="s0">106</span>
<span class="s0">inline bool DoubleBitMask&lt; BitMaskNative &gt;::operator &lt;(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1580 10 compare_to 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::compare_to 0 1 622 0</span>
<span class="s0">105</span>
<span class="s0">inline int DoubleBitMask&lt; BitMaskNative &gt;::compare_to(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1581 10 operator &amp; 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::operator &amp; 0 1 623 0</span>
<span class="s0">132</span>
<span class="s0">inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::operator &amp;(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1582 10 operator | 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::operator | 0 1 624 0</span>
<span class="s0">132</span>
<span class="s0">inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::operator |(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1583 10 operator ^ 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::operator ^ 0 1 625 0</span>
<span class="s0">132</span>
<span class="s0">inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::operator ^(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1584 10 operator ~ 0 68 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::operator ~ 0 1 626 0</span>
<span class="s0">93</span>
<span class="s0">inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::operator ~(void) const;</span>

<span class="s0">1585 11 operator &lt;&lt; 0 4 2003 43 DoubleBitMask&lt; BitMaskNative &gt;::operator &lt;&lt; 0 1 627 0</span>
<span class="s0">99</span>
<span class="s0">inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::operator &lt;&lt;(int shift) const;</span>

<span class="s0">1586 11 operator &gt;&gt; 0 4 2003 43 DoubleBitMask&lt; BitMaskNative &gt;::operator &gt;&gt; 0 1 628 0</span>
<span class="s0">99</span>
<span class="s0">inline DoubleBitMask&lt; BitMaskNative &gt; DoubleBitMask&lt; BitMaskNative &gt;::operator &gt;&gt;(int shift) const;</span>

<span class="s0">1587 11 operator &amp;= 0 4 2003 43 DoubleBitMask&lt; BitMaskNative &gt;::operator &amp;= 0 1 629 0</span>
<span class="s0">101</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::operator &amp;=(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other);</span>

<span class="s0">1588 11 operator |= 0 4 2003 43 DoubleBitMask&lt; BitMaskNative &gt;::operator |= 0 1 630 0</span>
<span class="s0">101</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::operator |=(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other);</span>

<span class="s0">1589 11 operator ^= 0 4 2003 43 DoubleBitMask&lt; BitMaskNative &gt;::operator ^= 0 1 631 0</span>
<span class="s0">101</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::operator ^=(DoubleBitMask&lt; BitMaskNative &gt; const &amp;other);</span>

<span class="s0">1590 12 operator &lt;&lt;= 0 4 2003 44 DoubleBitMask&lt; BitMaskNative &gt;::operator &lt;&lt;= 0 1 632 0</span>
<span class="s0">68</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::operator &lt;&lt;=(int shift);</span>

<span class="s0">1591 12 operator &gt;&gt;= 0 4 2003 44 DoubleBitMask&lt; BitMaskNative &gt;::operator &gt;&gt;= 0 1 633 0</span>
<span class="s0">68</span>
<span class="s0">inline void DoubleBitMask&lt; BitMaskNative &gt;::operator &gt;&gt;=(int shift);</span>

<span class="s0">1592 10 __reduce__ 0 4 2003 42 DoubleBitMask&lt; BitMaskNative &gt;::__reduce__ 0 1 634 0</span>
<span class="s0">75</span>
<span class="s0">PyObject *DoubleBitMask&lt; BitMaskNative &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">1593 14 get_class_type 0 4 2003 46 DoubleBitMask&lt; BitMaskNative &gt;::get_class_type 0 1 635 0</span>
<span class="s0">71</span>
<span class="s0">static TypeHandle DoubleBitMask&lt; BitMaskNative &gt;::get_class_type(void);</span>

<span class="s0">1594 14 ~DoubleBitMask 0 516 2003 46 DoubleBitMask&lt; BitMaskNative &gt;::~DoubleBitMask 0 0 0</span>
<span class="s0">53</span>
<span class="s0">DoubleBitMask&lt; BitMaskNative &gt;::~DoubleBitMask(void);</span>

<span class="s0">1595 13 DoubleBitMask 0 260 2005 51 DoubleBitMask&lt; DoubleBitMaskNative &gt;::DoubleBitMask 0 3 636 637 638 0</span>
<span class="s0">269</span>
<span class="s0">constexpr DoubleBitMask&lt; DoubleBitMaskNative &gt;::DoubleBitMask(void) = default;</span>
<span class="s0">DoubleBitMask&lt; DoubleBitMaskNative &gt;::DoubleBitMask(PyObject *init_value);</span>
<span class="s0">inline DoubleBitMask&lt; DoubleBitMaskNative &gt;::DoubleBitMask(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;) = default;</span>

<span class="s0">1596 6 all_on 0 4 2005 44 DoubleBitMask&lt; DoubleBitMaskNative &gt;::all_on 0 1 639 0</span>
<span class="s0">102</span>
<span class="s0">static inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::all_on(void);</span>

<span class="s0">1597 7 all_off 0 4 2005 45 DoubleBitMask&lt; DoubleBitMaskNative &gt;::all_off 0 1 640 0</span>
<span class="s0">103</span>
<span class="s0">static inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::all_off(void);</span>

<span class="s0">1598 8 lower_on 0 4 2005 46 DoubleBitMask&lt; DoubleBitMaskNative &gt;::lower_on 0 1 641 0</span>
<span class="s0">111</span>
<span class="s0">static inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::lower_on(int on_bits);</span>

<span class="s0">1599 3 bit 0 4 2005 41 DoubleBitMask&lt; DoubleBitMaskNative &gt;::bit 0 1 642 0</span>
<span class="s0">104</span>
<span class="s0">static inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::bit(int index);</span>

<span class="s0">1600 5 range 0 4 2005 43 DoubleBitMask&lt; DoubleBitMaskNative &gt;::range 0 1 643 0</span>
<span class="s0">118</span>
<span class="s0">static inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::range(int low_bit, int size);</span>

<span class="s0">1601 16 has_max_num_bits 0 4 2005 54 DoubleBitMask&lt; DoubleBitMaskNative &gt;::has_max_num_bits 0 1 644 0</span>
<span class="s0">83</span>
<span class="s0">static constexpr bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::has_max_num_bits(void);</span>

<span class="s0">1602 16 get_max_num_bits 0 4 2005 54 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_max_num_bits 0 1 645 0</span>
<span class="s0">82</span>
<span class="s0">static constexpr int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_max_num_bits(void);</span>

<span class="s0">1603 12 get_num_bits 0 4 2005 50 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_num_bits 0 1 646 0</span>
<span class="s0">77</span>
<span class="s0">constexpr int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_num_bits(void) const;</span>

<span class="s0">1604 7 get_bit 0 4 2005 45 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_bit 0 1 647 0</span>
<span class="s0">75</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_bit(int index) const;</span>

<span class="s0">1605 7 set_bit 0 4 2005 45 DoubleBitMask&lt; DoubleBitMaskNative &gt;::set_bit 0 1 648 0</span>
<span class="s0">69</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::set_bit(int index);</span>

<span class="s0">1606 9 clear_bit 0 4 2005 47 DoubleBitMask&lt; DoubleBitMaskNative &gt;::clear_bit 0 1 649 0</span>
<span class="s0">71</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::clear_bit(int index);</span>

<span class="s0">1607 10 set_bit_to 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::set_bit_to 0 1 650 0</span>
<span class="s0">84</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::set_bit_to(int index, bool value);</span>

<span class="s0">1608 7 is_zero 0 4 2005 45 DoubleBitMask&lt; DoubleBitMaskNative &gt;::is_zero 0 1 651 0</span>
<span class="s0">70</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::is_zero(void) const;</span>

<span class="s0">1609 9 is_all_on 0 4 2005 47 DoubleBitMask&lt; DoubleBitMaskNative &gt;::is_all_on 0 1 652 0</span>
<span class="s0">72</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::is_all_on(void) const;</span>

<span class="s0">1610 7 extract 0 4 2005 45 DoubleBitMask&lt; DoubleBitMaskNative &gt;::extract 0 1 653 0</span>
<span class="s0">91</span>
<span class="s0">inline uint64_t DoubleBitMask&lt; DoubleBitMaskNative &gt;::extract(int low_bit, int size) const;</span>

<span class="s0">1611 5 store 0 4 2005 43 DoubleBitMask&lt; DoubleBitMaskNative &gt;::store 0 1 654 0</span>
<span class="s0">95</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::store(uint64_t value, int low_bit, int size);</span>

<span class="s0">1612 10 has_any_of 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::has_any_of 0 1 655 0</span>
<span class="s0">90</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::has_any_of(int low_bit, int size) const;</span>

<span class="s0">1613 10 has_all_of 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::has_all_of 0 1 656 0</span>
<span class="s0">90</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::has_all_of(int low_bit, int size) const;</span>

<span class="s0">1614 9 set_range 0 4 2005 47 DoubleBitMask&lt; DoubleBitMaskNative &gt;::set_range 0 1 657 0</span>
<span class="s0">83</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::set_range(int low_bit, int size);</span>

<span class="s0">1615 11 clear_range 0 4 2005 49 DoubleBitMask&lt; DoubleBitMaskNative &gt;::clear_range 0 1 658 0</span>
<span class="s0">85</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::clear_range(int low_bit, int size);</span>

<span class="s0">1616 12 set_range_to 0 4 2005 50 DoubleBitMask&lt; DoubleBitMaskNative &gt;::set_range_to 0 1 659 0</span>
<span class="s0">98</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::set_range_to(bool value, int low_bit, int size);</span>

<span class="s0">1617 15 get_num_on_bits 0 4 2005 53 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_num_on_bits 0 1 660 0</span>
<span class="s0">77</span>
<span class="s0">inline int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_num_on_bits(void) const;</span>

<span class="s0">1618 16 get_num_off_bits 0 4 2005 54 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_num_off_bits 0 1 661 0</span>
<span class="s0">78</span>
<span class="s0">inline int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_num_off_bits(void) const;</span>

<span class="s0">1619 17 get_lowest_on_bit 0 4 2005 55 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_lowest_on_bit 0 1 662 0</span>
<span class="s0">79</span>
<span class="s0">inline int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_lowest_on_bit(void) const;</span>

<span class="s0">1620 18 get_lowest_off_bit 0 4 2005 56 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_lowest_off_bit 0 1 663 0</span>
<span class="s0">80</span>
<span class="s0">inline int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_lowest_off_bit(void) const;</span>

<span class="s0">1621 18 get_highest_on_bit 0 4 2005 56 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_highest_on_bit 0 1 664 0</span>
<span class="s0">80</span>
<span class="s0">inline int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_highest_on_bit(void) const;</span>

<span class="s0">1622 19 get_highest_off_bit 0 4 2005 57 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_highest_off_bit 0 1 665 0</span>
<span class="s0">81</span>
<span class="s0">inline int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_highest_off_bit(void) const;</span>

<span class="s0">1623 29 get_next_higher_different_bit 0 4 2005 67 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_next_higher_different_bit 0 1 666 0</span>
<span class="s0">98</span>
<span class="s0">inline int DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_next_higher_different_bit(int low_bit) const;</span>

<span class="s0">1624 15 invert_in_place 0 4 2005 53 DoubleBitMask&lt; DoubleBitMaskNative &gt;::invert_in_place 0 1 667 0</span>
<span class="s0">72</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::invert_in_place(void);</span>

<span class="s0">1625 18 has_bits_in_common 0 4 2005 56 DoubleBitMask&lt; DoubleBitMaskNative &gt;::has_bits_in_common 0 1 668 0</span>
<span class="s0">126</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::has_bits_in_common(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1626 5 clear 0 4 2005 43 DoubleBitMask&lt; DoubleBitMaskNative &gt;::clear 0 1 669 0</span>
<span class="s0">62</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::clear(void);</span>

<span class="s0">1627 6 output 0 4 2005 44 DoubleBitMask&lt; DoubleBitMaskNative &gt;::output 0 1 670 0</span>
<span class="s0">75</span>
<span class="s0">void DoubleBitMask&lt; DoubleBitMaskNative &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">1628 13 output_binary 0 4 2005 51 DoubleBitMask&lt; DoubleBitMaskNative &gt;::output_binary 0 1 671 0</span>
<span class="s0">104</span>
<span class="s0">void DoubleBitMask&lt; DoubleBitMaskNative &gt;::output_binary(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1629 10 output_hex 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::output_hex 0 1 672 0</span>
<span class="s0">101</span>
<span class="s0">void DoubleBitMask&lt; DoubleBitMaskNative &gt;::output_hex(std::ostream &amp;out, int spaces_every = 4) const;</span>

<span class="s0">1630 5 write 0 4 2005 43 DoubleBitMask&lt; DoubleBitMaskNative &gt;::write 0 1 673 0</span>
<span class="s0">96</span>
<span class="s0">void DoubleBitMask&lt; DoubleBitMaskNative &gt;::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1631 11 operator == 0 4 2005 49 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator == 0 1 674 0</span>
<span class="s0">119</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator ==(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1632 11 operator != 0 4 2005 49 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator != 0 1 675 0</span>
<span class="s0">119</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator !=(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1633 10 operator &lt; 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &lt; 0 1 676 0</span>
<span class="s0">118</span>
<span class="s0">inline bool DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &lt;(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1634 10 compare_to 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::compare_to 0 1 677 0</span>
<span class="s0">117</span>
<span class="s0">inline int DoubleBitMask&lt; DoubleBitMaskNative &gt;::compare_to(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1635 10 operator &amp; 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &amp; 0 1 678 0</span>
<span class="s0">150</span>
<span class="s0">inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &amp;(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1636 10 operator | 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator | 0 1 679 0</span>
<span class="s0">150</span>
<span class="s0">inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator |(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1637 10 operator ^ 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator ^ 0 1 680 0</span>
<span class="s0">150</span>
<span class="s0">inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator ^(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other) const;</span>

<span class="s0">1638 10 operator ~ 0 68 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator ~ 0 1 681 0</span>
<span class="s0">105</span>
<span class="s0">inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator ~(void) const;</span>

<span class="s0">1639 11 operator &lt;&lt; 0 4 2005 49 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &lt;&lt; 0 1 682 0</span>
<span class="s0">111</span>
<span class="s0">inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &lt;&lt;(int shift) const;</span>

<span class="s0">1640 11 operator &gt;&gt; 0 4 2005 49 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &gt;&gt; 0 1 683 0</span>
<span class="s0">111</span>
<span class="s0">inline DoubleBitMask&lt; DoubleBitMaskNative &gt; DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &gt;&gt;(int shift) const;</span>

<span class="s0">1641 11 operator &amp;= 0 4 2005 49 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &amp;= 0 1 684 0</span>
<span class="s0">113</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &amp;=(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other);</span>

<span class="s0">1642 11 operator |= 0 4 2005 49 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator |= 0 1 685 0</span>
<span class="s0">113</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator |=(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other);</span>

<span class="s0">1643 11 operator ^= 0 4 2005 49 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator ^= 0 1 686 0</span>
<span class="s0">113</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator ^=(DoubleBitMask&lt; DoubleBitMaskNative &gt; const &amp;other);</span>

<span class="s0">1644 12 operator &lt;&lt;= 0 4 2005 50 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &lt;&lt;= 0 1 687 0</span>
<span class="s0">74</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &lt;&lt;=(int shift);</span>

<span class="s0">1645 12 operator &gt;&gt;= 0 4 2005 50 DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &gt;&gt;= 0 1 688 0</span>
<span class="s0">74</span>
<span class="s0">inline void DoubleBitMask&lt; DoubleBitMaskNative &gt;::operator &gt;&gt;=(int shift);</span>

<span class="s0">1646 10 __reduce__ 0 4 2005 48 DoubleBitMask&lt; DoubleBitMaskNative &gt;::__reduce__ 0 1 689 0</span>
<span class="s0">81</span>
<span class="s0">PyObject *DoubleBitMask&lt; DoubleBitMaskNative &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">1647 14 get_class_type 0 4 2005 52 DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_class_type 0 1 690 0</span>
<span class="s0">77</span>
<span class="s0">static TypeHandle DoubleBitMask&lt; DoubleBitMaskNative &gt;::get_class_type(void);</span>

<span class="s0">1648 14 ~DoubleBitMask 0 516 2005 52 DoubleBitMask&lt; DoubleBitMaskNative &gt;::~DoubleBitMask 0 0 0</span>
<span class="s0">59</span>
<span class="s0">DoubleBitMask&lt; DoubleBitMaskNative &gt;::~DoubleBitMask(void);</span>

<span class="s0">1649 6 lstick 0 4 2008 21 GamepadButton::lstick 0 1 693 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::lstick(void);</span>

<span class="s0">1650 6 rstick 0 4 2008 21 GamepadButton::rstick 0 1 694 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::rstick(void);</span>

<span class="s0">1651 9 lshoulder 0 4 2008 24 GamepadButton::lshoulder 0 1 695 0</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle GamepadButton::lshoulder(void);</span>

<span class="s0">1652 9 rshoulder 0 4 2008 24 GamepadButton::rshoulder 0 1 696 0</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle GamepadButton::rshoulder(void);</span>

<span class="s0">1653 8 ltrigger 0 4 2008 23 GamepadButton::ltrigger 0 1 697 0</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle GamepadButton::ltrigger(void);</span>

<span class="s0">1654 8 rtrigger 0 4 2008 23 GamepadButton::rtrigger 0 1 698 0</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle GamepadButton::rtrigger(void);</span>

<span class="s0">1655 5 lgrip 0 4 2008 20 GamepadButton::lgrip 0 1 699 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle GamepadButton::lgrip(void);</span>

<span class="s0">1656 5 rgrip 0 4 2008 20 GamepadButton::rgrip 0 1 700 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle GamepadButton::rgrip(void);</span>

<span class="s0">1657 9 dpad_left 0 4 2008 24 GamepadButton::dpad_left 0 1 701 0</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle GamepadButton::dpad_left(void);</span>

<span class="s0">1658 10 dpad_right 0 4 2008 25 GamepadButton::dpad_right 0 1 702 0</span>
<span class="s0">52</span>
<span class="s0">static ButtonHandle GamepadButton::dpad_right(void);</span>

<span class="s0">1659 7 dpad_up 0 4 2008 22 GamepadButton::dpad_up 0 1 703 0</span>
<span class="s0">49</span>
<span class="s0">static ButtonHandle GamepadButton::dpad_up(void);</span>

<span class="s0">1660 9 dpad_down 0 4 2008 24 GamepadButton::dpad_down 0 1 704 0</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle GamepadButton::dpad_down(void);</span>

<span class="s0">1661 4 back 0 4 2008 19 GamepadButton::back 0 1 705 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle GamepadButton::back(void);</span>

<span class="s0">1662 5 guide 0 4 2008 20 GamepadButton::guide 0 1 706 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle GamepadButton::guide(void);</span>

<span class="s0">1663 5 start 0 4 2008 20 GamepadButton::start 0 1 707 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle GamepadButton::start(void);</span>

<span class="s0">1664 4 next 0 4 2008 19 GamepadButton::next 0 1 708 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle GamepadButton::next(void);</span>

<span class="s0">1665 8 previous 0 4 2008 23 GamepadButton::previous 0 1 709 0</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle GamepadButton::previous(void);</span>

<span class="s0">1666 6 face_a 0 4 2008 21 GamepadButton::face_a 0 1 710 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::face_a(void);</span>

<span class="s0">1667 6 face_b 0 4 2008 21 GamepadButton::face_b 0 1 711 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::face_b(void);</span>

<span class="s0">1668 6 face_c 0 4 2008 21 GamepadButton::face_c 0 1 712 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::face_c(void);</span>

<span class="s0">1669 6 face_x 0 4 2008 21 GamepadButton::face_x 0 1 713 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::face_x(void);</span>

<span class="s0">1670 6 face_y 0 4 2008 21 GamepadButton::face_y 0 1 714 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::face_y(void);</span>

<span class="s0">1671 6 face_z 0 4 2008 21 GamepadButton::face_z 0 1 715 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::face_z(void);</span>

<span class="s0">1672 6 face_1 0 4 2008 21 GamepadButton::face_1 0 1 716 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::face_1(void);</span>

<span class="s0">1673 6 face_2 0 4 2008 21 GamepadButton::face_2 0 1 717 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::face_2(void);</span>

<span class="s0">1674 7 trigger 0 4 2008 22 GamepadButton::trigger 0 1 718 74</span>
<span class="s0">// Flight stick buttons, takes zero-based index.  First is always trigger.</span>
<span class="s0">49</span>
<span class="s0">static ButtonHandle GamepadButton::trigger(void);</span>

<span class="s0">1675 8 joystick 0 4 2008 23 GamepadButton::joystick 0 1 719 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle associated with the particular numbered joystick</span>
 <span class="s0">* button (zero-based), if there is one, or ButtonHandle::none() if there is</span>
 <span class="s0">* not.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static ButtonHandle GamepadButton::joystick(int button_number);</span>

<span class="s0">1676 6 hat_up 0 4 2008 21 GamepadButton::hat_up 0 1 720 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle GamepadButton::hat_up(void);</span>

<span class="s0">1677 8 hat_down 0 4 2008 23 GamepadButton::hat_down 0 1 721 0</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle GamepadButton::hat_down(void);</span>

<span class="s0">1678 8 hat_left 0 4 2008 23 GamepadButton::hat_left 0 1 722 0</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle GamepadButton::hat_left(void);</span>

<span class="s0">1679 9 hat_right 0 4 2008 24 GamepadButton::hat_right 0 1 723 0</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle GamepadButton::hat_right(void);</span>

<span class="s0">1680 13 GamepadButton 0 260 2008 28 GamepadButton::GamepadButton 0 2 691 692 0</span>
<span class="s0">122</span>
<span class="s0">inline GamepadButton::GamepadButton(void) = default;</span>
<span class="s0">inline GamepadButton::GamepadButton(GamepadButton const &amp;) = default;</span>

<span class="s0">1681 14 ~GamepadButton 0 516 2008 29 GamepadButton::~GamepadButton 0 0 0</span>
<span class="s0">36</span>
<span class="s0">GamepadButton::~GamepadButton(void);</span>

<span class="s0">1682 9 ascii_key 0 4 2009 25 KeyboardButton::ascii_key 0 1 726 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle associated with the particular ASCII character, if</span>
 <span class="s0">* there is one, or ButtonHandle::none() if there is not.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent);</span>

<span class="s0">1683 5 space 0 4 2009 21 KeyboardButton::space 0 1 727 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle KeyboardButton::space(void);</span>

<span class="s0">1684 9 backspace 0 4 2009 25 KeyboardButton::backspace 0 1 728 0</span>
<span class="s0">52</span>
<span class="s0">static ButtonHandle KeyboardButton::backspace(void);</span>

<span class="s0">1685 3 tab 0 4 2009 19 KeyboardButton::tab 0 1 729 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::tab(void);</span>

<span class="s0">1686 5 enter 0 4 2009 21 KeyboardButton::enter 0 1 730 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle KeyboardButton::enter(void);</span>

<span class="s0">1687 6 escape 0 4 2009 22 KeyboardButton::escape 0 1 731 0</span>
<span class="s0">49</span>
<span class="s0">static ButtonHandle KeyboardButton::escape(void);</span>

<span class="s0">1688 2 f1 0 4 2009 18 KeyboardButton::f1 0 1 732 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f1(void);</span>

<span class="s0">1689 2 f2 0 4 2009 18 KeyboardButton::f2 0 1 733 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f2(void);</span>

<span class="s0">1690 2 f3 0 4 2009 18 KeyboardButton::f3 0 1 734 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f3(void);</span>

<span class="s0">1691 2 f4 0 4 2009 18 KeyboardButton::f4 0 1 735 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f4(void);</span>

<span class="s0">1692 2 f5 0 4 2009 18 KeyboardButton::f5 0 1 736 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f5(void);</span>

<span class="s0">1693 2 f6 0 4 2009 18 KeyboardButton::f6 0 1 737 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f6(void);</span>

<span class="s0">1694 2 f7 0 4 2009 18 KeyboardButton::f7 0 1 738 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f7(void);</span>

<span class="s0">1695 2 f8 0 4 2009 18 KeyboardButton::f8 0 1 739 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f8(void);</span>

<span class="s0">1696 2 f9 0 4 2009 18 KeyboardButton::f9 0 1 740 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::f9(void);</span>

<span class="s0">1697 3 f10 0 4 2009 19 KeyboardButton::f10 0 1 741 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::f10(void);</span>

<span class="s0">1698 3 f11 0 4 2009 19 KeyboardButton::f11 0 1 742 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::f11(void);</span>

<span class="s0">1699 3 f12 0 4 2009 19 KeyboardButton::f12 0 1 743 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::f12(void);</span>

<span class="s0">1700 3 f13 0 4 2009 19 KeyboardButton::f13 0 1 744 59</span>
<span class="s0">// PC keyboards don't have these four buttons, but Macs do.</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::f13(void);</span>

<span class="s0">1701 3 f14 0 4 2009 19 KeyboardButton::f14 0 1 745 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::f14(void);</span>

<span class="s0">1702 3 f15 0 4 2009 19 KeyboardButton::f15 0 1 746 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::f15(void);</span>

<span class="s0">1703 3 f16 0 4 2009 19 KeyboardButton::f16 0 1 747 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::f16(void);</span>

<span class="s0">1704 4 left 0 4 2009 20 KeyboardButton::left 0 1 748 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle KeyboardButton::left(void);</span>

<span class="s0">1705 5 right 0 4 2009 21 KeyboardButton::right 0 1 749 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle KeyboardButton::right(void);</span>

<span class="s0">1706 2 up 0 4 2009 18 KeyboardButton::up 0 1 750 0</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle KeyboardButton::up(void);</span>

<span class="s0">1707 4 down 0 4 2009 20 KeyboardButton::down 0 1 751 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle KeyboardButton::down(void);</span>

<span class="s0">1708 7 page_up 0 4 2009 23 KeyboardButton::page_up 0 1 752 0</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle KeyboardButton::page_up(void);</span>

<span class="s0">1709 9 page_down 0 4 2009 25 KeyboardButton::page_down 0 1 753 0</span>
<span class="s0">52</span>
<span class="s0">static ButtonHandle KeyboardButton::page_down(void);</span>

<span class="s0">1710 4 home 0 4 2009 20 KeyboardButton::home 0 1 754 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle KeyboardButton::home(void);</span>

<span class="s0">1711 3 end 0 4 2009 19 KeyboardButton::end 0 1 755 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::end(void);</span>

<span class="s0">1712 6 insert 0 4 2009 22 KeyboardButton::insert 0 1 756 0</span>
<span class="s0">49</span>
<span class="s0">static ButtonHandle KeyboardButton::insert(void);</span>

<span class="s0">1713 3 del 0 4 2009 19 KeyboardButton::del 0 1 757 27</span>
<span class="s0">// delete is a C++ keyword.</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::del(void);</span>

<span class="s0">1714 4 help 0 4 2009 20 KeyboardButton::help 0 1 758 27</span>
<span class="s0">// delete is a C++ keyword.</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle KeyboardButton::help(void);</span>

<span class="s0">1715 4 menu 0 4 2009 20 KeyboardButton::menu 0 1 759 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle KeyboardButton::menu(void);</span>

<span class="s0">1716 5 shift 0 4 2009 21 KeyboardButton::shift 0 1 760 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle KeyboardButton::shift(void);</span>

<span class="s0">1717 7 control 0 4 2009 23 KeyboardButton::control 0 1 761 0</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle KeyboardButton::control(void);</span>

<span class="s0">1718 3 alt 0 4 2009 19 KeyboardButton::alt 0 1 762 0</span>
<span class="s0">46</span>
<span class="s0">static ButtonHandle KeyboardButton::alt(void);</span>

<span class="s0">1719 4 meta 0 4 2009 20 KeyboardButton::meta 0 1 763 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle KeyboardButton::meta(void);</span>

<span class="s0">1720 9 caps_lock 0 4 2009 25 KeyboardButton::caps_lock 0 1 764 0</span>
<span class="s0">52</span>
<span class="s0">static ButtonHandle KeyboardButton::caps_lock(void);</span>

<span class="s0">1721 10 shift_lock 0 4 2009 26 KeyboardButton::shift_lock 0 1 765 0</span>
<span class="s0">53</span>
<span class="s0">static ButtonHandle KeyboardButton::shift_lock(void);</span>

<span class="s0">1722 8 num_lock 0 4 2009 24 KeyboardButton::num_lock 0 1 766 0</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle KeyboardButton::num_lock(void);</span>

<span class="s0">1723 11 scroll_lock 0 4 2009 27 KeyboardButton::scroll_lock 0 1 767 0</span>
<span class="s0">54</span>
<span class="s0">static ButtonHandle KeyboardButton::scroll_lock(void);</span>

<span class="s0">1724 12 print_screen 0 4 2009 28 KeyboardButton::print_screen 0 1 768 0</span>
<span class="s0">55</span>
<span class="s0">static ButtonHandle KeyboardButton::print_screen(void);</span>

<span class="s0">1725 5 pause 0 4 2009 21 KeyboardButton::pause 0 1 769 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle KeyboardButton::pause(void);</span>

<span class="s0">1726 6 lshift 0 4 2009 22 KeyboardButton::lshift 0 1 770 0</span>
<span class="s0">49</span>
<span class="s0">static ButtonHandle KeyboardButton::lshift(void);</span>

<span class="s0">1727 6 rshift 0 4 2009 22 KeyboardButton::rshift 0 1 771 0</span>
<span class="s0">49</span>
<span class="s0">static ButtonHandle KeyboardButton::rshift(void);</span>

<span class="s0">1728 8 lcontrol 0 4 2009 24 KeyboardButton::lcontrol 0 1 772 0</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle KeyboardButton::lcontrol(void);</span>

<span class="s0">1729 8 rcontrol 0 4 2009 24 KeyboardButton::rcontrol 0 1 773 0</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle KeyboardButton::rcontrol(void);</span>

<span class="s0">1730 4 lalt 0 4 2009 20 KeyboardButton::lalt 0 1 774 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle KeyboardButton::lalt(void);</span>

<span class="s0">1731 4 ralt 0 4 2009 20 KeyboardButton::ralt 0 1 775 0</span>
<span class="s0">47</span>
<span class="s0">static ButtonHandle KeyboardButton::ralt(void);</span>

<span class="s0">1732 5 lmeta 0 4 2009 21 KeyboardButton::lmeta 0 1 776 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle KeyboardButton::lmeta(void);</span>

<span class="s0">1733 5 rmeta 0 4 2009 21 KeyboardButton::rmeta 0 1 777 0</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle KeyboardButton::rmeta(void);</span>

<span class="s0">1734 14 KeyboardButton 0 260 2009 30 KeyboardButton::KeyboardButton 0 2 724 725 0</span>
<span class="s0">127</span>
<span class="s0">inline KeyboardButton::KeyboardButton(void) = default;</span>
<span class="s0">inline KeyboardButton::KeyboardButton(KeyboardButton const &amp;) = default;</span>

<span class="s0">1735 15 ~KeyboardButton 0 516 2009 31 KeyboardButton::~KeyboardButton 0 0 0</span>
<span class="s0">38</span>
<span class="s0">KeyboardButton::~KeyboardButton(void);</span>

<span class="s0">1736 13 load_prc_file 0 1 0 13 load_prc_file 0 1 963 1206</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function for loading explicit prc files from a disk file or</span>
 <span class="s0">* from within a multifile (via the virtual file system).  Save the return</span>
 <span class="s0">* value and pass it to unload_prc_file() if you ever want to unload this file</span>
 <span class="s0">* later.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is first searched along the default prc search path, and then</span>
 <span class="s0">* also along the model path, for convenience.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is defined in putil instead of in dtool with the read of the</span>
 <span class="s0">* prc stuff, so that it can take advantage of the virtual file system (which</span>
 <span class="s0">* is defined in express), and the model path (which is in putil).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* A convenience function for loading explicit prc files from a disk file or</span>
 <span class="s0">* from within a multifile (via the virtual file system).  Save the return</span>
 <span class="s0">* value and pass it to unload_prc_file() if you ever want to unload this file</span>
 <span class="s0">* later.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is first searched along the default prc search path, and then</span>
 <span class="s0">* also along the model path, for convenience.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is defined in putil instead of in dtool with the read of the</span>
 <span class="s0">* prc stuff, so that it can take advantage of the virtual file system (which</span>
 <span class="s0">* is defined in express), and the model path (which is in putil).</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">ConfigPage *load_prc_file(Filename const &amp;filename);</span>

<span class="s0">1737 18 load_prc_file_data 0 1 0 18 load_prc_file_data 0 1 964 794</span>
<span class="s0">/**</span>
 <span class="s0">* Another convenience function to load a prc file from an explicit string,</span>
 <span class="s0">* which represents the contents of the prc file.</span>
 <span class="s0">*</span>
 <span class="s0">* The first parameter is an arbitrary name to assign to this in-memory prc</span>
 <span class="s0">* file.  Supply a filename if the data was read from a file, or use any other</span>
 <span class="s0">* name that is meaningful to you.  The name is only used when the set of</span>
 <span class="s0">* loaded prc files is listed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Another convenience function to load a prc file from an explicit string,</span>
 <span class="s0">* which represents the contents of the prc file.</span>
 <span class="s0">*</span>
 <span class="s0">* The first parameter is an arbitrary name to assign to this in-memory prc</span>
 <span class="s0">* file.  Supply a filename if the data was read from a file, or use any other</span>
 <span class="s0">* name that is meaningful to you.  The name is only used when the set of</span>
 <span class="s0">* loaded prc files is listed.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">ConfigPage *load_prc_file_data(std::string const &amp;name, std::string const &amp;data);</span>

<span class="s0">1738 15 unload_prc_file 0 1 0 15 unload_prc_file 0 1 965 0</span>
<span class="s0">39</span>
<span class="s0">bool unload_prc_file(ConfigPage *page);</span>

<span class="s0">1739 18 hash_prc_variables 0 1 0 18 hash_prc_variables 0 1 966 0</span>
<span class="s0">39</span>
<span class="s0">void hash_prc_variables(HashVal &amp;hash);</span>

<span class="s0">1740 15 ModifierButtons 0 260 2010 32 ModifierButtons::ModifierButtons 0 2 778 779 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">ModifierButtons::ModifierButtons(void);</span>
<span class="s0">ModifierButtons::ModifierButtons(ModifierButtons const &amp;copy);</span>

<span class="s0">1741 16 ~ModifierButtons 0 516 2010 33 ModifierButtons::~ModifierButtons 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">ModifierButtons::~ModifierButtons(void);</span>

<span class="s0">1742 10 operator = 0 4 2010 27 ModifierButtons::operator = 0 1 780 0</span>
<span class="s0">69</span>
<span class="s0">inline void ModifierButtons::operator =(ModifierButtons const &amp;copy);</span>

<span class="s0">1743 11 operator == 0 4 2010 28 ModifierButtons::operator == 0 1 781 0</span>
<span class="s0">77</span>
<span class="s0">inline bool ModifierButtons::operator ==(ModifierButtons const &amp;other) const;</span>

<span class="s0">1744 11 operator != 0 4 2010 28 ModifierButtons::operator != 0 1 782 0</span>
<span class="s0">77</span>
<span class="s0">inline bool ModifierButtons::operator !=(ModifierButtons const &amp;other) const;</span>

<span class="s0">1745 10 operator &lt; 0 4 2010 27 ModifierButtons::operator &lt; 0 1 783 0</span>
<span class="s0">76</span>
<span class="s0">inline bool ModifierButtons::operator &lt;(ModifierButtons const &amp;other) const;</span>

<span class="s0">1746 10 operator &amp; 0 4 2010 27 ModifierButtons::operator &amp; 0 1 784 0</span>
<span class="s0">87</span>
<span class="s0">inline ModifierButtons ModifierButtons::operator &amp;(ModifierButtons const &amp;other) const;</span>

<span class="s0">1747 10 operator | 0 4 2010 27 ModifierButtons::operator | 0 1 785 0</span>
<span class="s0">87</span>
<span class="s0">inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &amp;other) const;</span>

<span class="s0">1748 11 operator &amp;= 0 4 2010 28 ModifierButtons::operator &amp;= 0 1 786 0</span>
<span class="s0">64</span>
<span class="s0">void ModifierButtons::operator &amp;=(ModifierButtons const &amp;other);</span>

<span class="s0">1749 11 operator |= 0 4 2010 28 ModifierButtons::operator |= 0 1 787 0</span>
<span class="s0">64</span>
<span class="s0">void ModifierButtons::operator |=(ModifierButtons const &amp;other);</span>

<span class="s0">1750 15 set_button_list 0 4 2010 32 ModifierButtons::set_button_list 0 1 788 374</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the list of buttons to watch to be the same as that of the other</span>
 <span class="s0">* ModifierButtons object.  This makes the lists pointer equivalent (until one</span>
 <span class="s0">* or the other is later modified).</span>
 <span class="s0">*</span>
 <span class="s0">* This will preserve the state of any button that was on the original list</span>
 <span class="s0">* and is also on the new lists.  Any other buttons will get reset to the</span>
 <span class="s0">* default state of &quot;up&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void ModifierButtons::set_button_list(ModifierButtons const &amp;other);</span>

<span class="s0">1751 7 matches 0 4 2010 24 ModifierButtons::matches 0 1 789 232</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the set of buttons indicated as down by this</span>
 <span class="s0">* ModifierButtons object is the same set of buttons indicated as down by the</span>
 <span class="s0">* other ModifierButtons object.  The buttons indicated as up are not</span>
 <span class="s0">* relevant.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">bool ModifierButtons::matches(ModifierButtons const &amp;other) const;</span>

<span class="s0">1752 10 add_button 0 4 2010 27 ModifierButtons::add_button 0 1 790 248</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated button to the set of buttons that will be monitored for</span>
 <span class="s0">* upness and downness.  Returns true if the button was added, false if it was</span>
 <span class="s0">* already being monitored or if too many buttons are currently being</span>
 <span class="s0">* monitored.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">bool ModifierButtons::add_button(ButtonHandle button);</span>

<span class="s0">1753 10 has_button 0 4 2010 27 ModifierButtons::has_button 0 1 791 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated button is in the set of buttons being</span>
 <span class="s0">* monitored, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool ModifierButtons::has_button(ButtonHandle button) const;</span>

<span class="s0">1754 13 remove_button 0 4 2010 30 ModifierButtons::remove_button 0 1 792 313</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated button from the set of buttons being monitored.</span>
 <span class="s0">* Returns true if the button was removed, false if it was not being monitored</span>
 <span class="s0">* in the first place.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the other methods, you cannot remove a button by removing its alias;</span>
 <span class="s0">* you have to remove exactly the button itself.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">bool ModifierButtons::remove_button(ButtonHandle button);</span>

<span class="s0">1755 15 get_num_buttons 0 4 2010 32 ModifierButtons::get_num_buttons 0 1 793 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of buttons that the ModifierButtons object is monitoring</span>
 <span class="s0">* (e.g.  the number of buttons passed to add_button()).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int ModifierButtons::get_num_buttons(void) const;</span>

<span class="s0">1756 10 get_button 0 4 2010 27 ModifierButtons::get_button 0 1 794 185</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth button that the ModifierButtons object is monitoring (the</span>
 <span class="s0">* nth button passed to add_button()).  This must be in the range 0 &lt;= index &lt;</span>
 <span class="s0">* get_num_buttons().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline ButtonHandle ModifierButtons::get_button(int index) const;</span>

<span class="s0">1757 11 button_down 0 4 2010 28 ModifierButtons::button_down 0 1 795 305</span>
<span class="s0">/**</span>
 <span class="s0">* Records that a particular button has been pressed.  If the given button is</span>
 <span class="s0">* one of the buttons that is currently being monitored, this will update the</span>
 <span class="s0">* internal state appropriately; otherwise, it will do nothing.  Returns true</span>
 <span class="s0">* if the button is one that was monitored, or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool ModifierButtons::button_down(ButtonHandle button);</span>

<span class="s0">1758 9 button_up 0 4 2010 26 ModifierButtons::button_up 0 1 796 306</span>
<span class="s0">/**</span>
 <span class="s0">* Records that a particular button has been released.  If the given button is</span>
 <span class="s0">* one of the buttons that is currently being monitored, this will update the</span>
 <span class="s0">* internal state appropriately; otherwise, it will do nothing.  Returns true</span>
 <span class="s0">* if the button is one that was monitored, or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">bool ModifierButtons::button_up(ButtonHandle button);</span>

<span class="s0">1759 14 all_buttons_up 0 4 2010 31 ModifierButtons::all_buttons_up 0 1 797 66</span>
<span class="s0">/**</span>
 <span class="s0">* Marks all monitored buttons as being in the &quot;up&quot; state.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void ModifierButtons::all_buttons_up(void);</span>

<span class="s0">1760 7 is_down 0 4 2010 24 ModifierButtons::is_down 0 2 798 799 264</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated button is known to be down, or false if it is</span>
 <span class="s0">* known to be up.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated button is known to be down, or false if it is</span>
 <span class="s0">* known to be up or if it is not in the set of buttons being tracked.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">bool ModifierButtons::is_down(ButtonHandle button) const;</span>
<span class="s0">inline bool ModifierButtons::is_down(int index) const;</span>

<span class="s0">1761 11 is_any_down 0 4 2010 28 ModifierButtons::is_any_down 0 1 800 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any of the tracked button are known to be down, or false if</span>
 <span class="s0">* all of them are up.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool ModifierButtons::is_any_down(void) const;</span>

<span class="s0">1762 10 get_prefix 0 4 2010 27 ModifierButtons::get_prefix 0 1 801 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string which can be used to prefix any button name or event name</span>
 <span class="s0">* with the unique set of modifier buttons currently being held.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">std::string ModifierButtons::get_prefix(void) const;</span>

<span class="s0">1763 6 output 0 4 2010 23 ModifierButtons::output 0 1 802 69</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a one-line summary of the buttons known to be down.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void ModifierButtons::output(std::ostream &amp;out) const;</span>

<span class="s0">1764 5 write 0 4 2010 22 ModifierButtons::write 0 1 803 123</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a multi-line summary including all of the buttons being monitored</span>
 <span class="s0">* and which ones are known to be down.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void ModifierButtons::write(std::ostream &amp;out) const;</span>

<span class="s0">1765 6 button 0 4 2011 19 MouseButton::button 0 1 806 166</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle associated with the particular numbered mouse</span>
 <span class="s0">* button (zero-based), if there is one, or ButtonHandle::none() if there is</span>
 <span class="s0">* not.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">static ButtonHandle MouseButton::button(int button_number);</span>

<span class="s0">1766 3 one 0 4 2011 16 MouseButton::one 0 1 807 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle associated with the first mouse button.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">static ButtonHandle MouseButton::one(void);</span>

<span class="s0">1767 3 two 0 4 2011 16 MouseButton::two 0 1 808 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle associated with the second mouse button.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">static ButtonHandle MouseButton::two(void);</span>

<span class="s0">1768 5 three 0 4 2011 18 MouseButton::three 0 1 809 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle associated with the third mouse button.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static ButtonHandle MouseButton::three(void);</span>

<span class="s0">1769 4 four 0 4 2011 17 MouseButton::four 0 1 810 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle associated with the fourth mouse button.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">static ButtonHandle MouseButton::four(void);</span>

<span class="s0">1770 4 five 0 4 2011 17 MouseButton::five 0 1 811 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle associated with the fifth mouse button.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">static ButtonHandle MouseButton::five(void);</span>

<span class="s0">1771 8 wheel_up 0 4 2011 21 MouseButton::wheel_up 0 1 812 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle generated when the mouse wheel is rolled one notch</span>
 <span class="s0">* upwards.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">static ButtonHandle MouseButton::wheel_up(void);</span>

<span class="s0">1772 10 wheel_down 0 4 2011 23 MouseButton::wheel_down 0 1 813 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle generated when the mouse wheel is rolled one notch</span>
 <span class="s0">* downwards.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle MouseButton::wheel_down(void);</span>

<span class="s0">1773 10 wheel_left 0 4 2011 23 MouseButton::wheel_left 0 1 814 148</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle generated when the mouse is scrolled to the left.</span>
 <span class="s0">* Usually, you'll only find the horizontal scroll on laptops.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static ButtonHandle MouseButton::wheel_left(void);</span>

<span class="s0">1774 11 wheel_right 0 4 2011 24 MouseButton::wheel_right 0 1 815 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ButtonHandle generated when the mouse is scrolled to the right.</span>
 <span class="s0">* Usually, you'll only find the horizontal scroll on laptops.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static ButtonHandle MouseButton::wheel_right(void);</span>

<span class="s0">1775 15 is_mouse_button 0 4 2011 28 MouseButton::is_mouse_button 0 1 816 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated ButtonHandle is a mouse button, false if it</span>
 <span class="s0">* is some other kind of button.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static bool MouseButton::is_mouse_button(ButtonHandle button);</span>

<span class="s0">1776 11 MouseButton 0 260 2011 24 MouseButton::MouseButton 0 2 804 805 0</span>
<span class="s0">112</span>
<span class="s0">inline MouseButton::MouseButton(void) = default;</span>
<span class="s0">inline MouseButton::MouseButton(MouseButton const &amp;) = default;</span>

<span class="s0">1777 12 ~MouseButton 0 516 2011 25 MouseButton::~MouseButton 0 0 0</span>
<span class="s0">32</span>
<span class="s0">MouseButton::~MouseButton(void);</span>

<span class="s0">1778 5 get_x 0 4 2013 18 PointerData::get_x 0 1 819 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline double PointerData::get_x(void) const;</span>

<span class="s0">1779 5 get_y 0 4 2013 18 PointerData::get_y 0 1 820 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline double PointerData::get_y(void) const;</span>

<span class="s0">1780 13 get_in_window 0 4 2013 26 PointerData::get_in_window 0 1 821 157</span>
<span class="s0">/**</span>
 <span class="s0">* If this returns false, the pointer is not currently present in the window</span>
 <span class="s0">* and the values returned by get_x() and get_y() may not be meaningful.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool PointerData::get_in_window(void) const;</span>

<span class="s0">1781 8 get_type 0 4 2013 21 PointerData::get_type 0 0 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of pointing device.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PointerType PointerData::get_type(void) const;</span>

<span class="s0">1782 6 get_id 0 4 2013 19 PointerData::get_id 0 0 273</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a unique identifier for this pointer.  This is for tracking</span>
 <span class="s0">* individual fingers.  This value should not be assumed to have a specific</span>
 <span class="s0">* meaning other than that there will not be two different pointers active</span>
 <span class="s0">* simultaneously with the same identifier.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int PointerData::get_id(void) const;</span>

<span class="s0">1783 12 get_pressure 0 4 2013 25 PointerData::get_pressure 0 0 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pressure of the pointer.  For mice, this will be 1.0 if any</span>
 <span class="s0">* button is pressed, 0.0 otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline double PointerData::get_pressure(void) const;</span>

<span class="s0">1784 11 PointerData 0 260 2013 24 PointerData::PointerData 0 2 817 818 0</span>
<span class="s0">112</span>
<span class="s0">inline PointerData::PointerData(void) = default;</span>
<span class="s0">inline PointerData::PointerData(PointerData const &amp;) = default;</span>

<span class="s0">1785 12 ~PointerData 0 516 2013 25 PointerData::~PointerData 0 0 0</span>
<span class="s0">32</span>
<span class="s0">PointerData::~PointerData(void);</span>

<span class="s0">1786 18 get_node_ref_count 0 4 2015 44 NodeCachedReferenceCount::get_node_ref_count 0 1 822 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current reference count.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline int NodeCachedReferenceCount::get_node_ref_count(void) const;</span>

<span class="s0">1787 8 node_ref 0 4 2015 34 NodeCachedReferenceCount::node_ref 0 1 823 349</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly increments the reference count.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is const, even though it changes the object, because</span>
 <span class="s0">* generally fiddling with an object's reference count isn't considered part</span>
 <span class="s0">* of fiddling with the object.  An object might be const in other ways, but</span>
 <span class="s0">* we still need to accurately count the number of references to it.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void NodeCachedReferenceCount::node_ref(void) const;</span>

<span class="s0">1788 10 node_unref 0 4 2015 36 NodeCachedReferenceCount::node_unref 0 1 824 201</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly decrements the node reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the new reference count is nonzero, false if it</span>
 <span class="s0">* is zero.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool NodeCachedReferenceCount::node_unref(void) const;</span>

<span class="s0">1789 24 test_ref_count_integrity 0 4 2015 50 NodeCachedReferenceCount::test_ref_count_integrity 0 1 825 97</span>
<span class="s0">/**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't</span>
 <span class="s0">* completely bogus.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const;</span>

<span class="s0">1790 19 get_referenced_bits 0 4 2015 45 NodeCachedReferenceCount::get_referenced_bits 0 1 826 293</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of the values defined in the Referenced enum that</span>
 <span class="s0">* represents the various things that appear to be holding a pointer to this</span>
 <span class="s0">* object.</span>
 <span class="s0">*</span>
 <span class="s0">* If R_node is included, at least one node is holding a pointer; if R_cache</span>
 <span class="s0">* is included, at least one cache element is.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline int NodeCachedReferenceCount::get_referenced_bits(void) const;</span>

<span class="s0">1791 14 get_class_type 0 4 2015 40 NodeCachedReferenceCount::get_class_type 0 1 827 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle NodeCachedReferenceCount::get_class_type(void);</span>

<span class="s0">1792 11 SparseArray 0 260 2017 24 SparseArray::SparseArray 0 3 828 829 830 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">150</span>
<span class="s0">inline SparseArray::SparseArray(void);</span>
<span class="s0">SparseArray::SparseArray(BitArray const &amp;from);</span>
<span class="s0">inline SparseArray::SparseArray(SparseArray const &amp;) = default;</span>

<span class="s0">1793 6 all_on 0 4 2017 19 SparseArray::all_on 0 1 831 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a SparseArray with an infinite array of bits, all on.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static inline SparseArray SparseArray::all_on(void);</span>

<span class="s0">1794 7 all_off 0 4 2017 20 SparseArray::all_off 0 1 832 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a SparseArray whose bits are all off.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline SparseArray SparseArray::all_off(void);</span>

<span class="s0">1795 8 lower_on 0 4 2017 21 SparseArray::lower_on 0 1 833 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a SparseArray whose lower on_bits bits are on.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">static inline SparseArray SparseArray::lower_on(int on_bits);</span>

<span class="s0">1796 3 bit 0 4 2017 16 SparseArray::bit 0 1 834 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a SparseArray with only the indicated bit on.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">static inline SparseArray SparseArray::bit(int index);</span>

<span class="s0">1797 5 range 0 4 2017 18 SparseArray::range 0 1 835 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a SparseArray whose size bits, beginning at low_bit, are on.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static inline SparseArray SparseArray::range(int low_bit, int size);</span>

<span class="s0">1798 16 has_max_num_bits 0 4 2017 29 SparseArray::has_max_num_bits 0 1 836 393</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a maximum number of bits that may be stored in</span>
 <span class="s0">* this structure, false otherwise.  If this returns true, the number may be</span>
 <span class="s0">* queried in get_max_num_bits().</span>
 <span class="s0">*</span>
 <span class="s0">* This method always returns false.  The SparseArray has no maximum number of</span>
 <span class="s0">* bits.  This method is defined so generic programming algorithms can use</span>
 <span class="s0">* BitMask or SparseArray interchangeably.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline bool SparseArray::has_max_num_bits(void);</span>

<span class="s0">1799 16 get_max_num_bits 0 4 2017 29 SparseArray::get_max_num_bits 0 1 837 428</span>
<span class="s0">/**</span>
 <span class="s0">* If get_max_num_bits() returned true, this method may be called to return</span>
 <span class="s0">* the maximum number of bits that may be stored in this structure.  It is an</span>
 <span class="s0">* error to call this if get_max_num_bits() return false.</span>
 <span class="s0">*</span>
 <span class="s0">* It is always an error to call this method.  The SparseArray has no maximum</span>
 <span class="s0">* number of bits.  This method is defined so generic programming algorithms</span>
 <span class="s0">* can use BitMask or SparseArray interchangeably.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">static inline int SparseArray::get_max_num_bits(void);</span>

<span class="s0">1800 12 get_num_bits 0 4 2017 25 SparseArray::get_num_bits 0 1 838 300</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current number of possibly different bits in this array.  There</span>
 <span class="s0">* are actually an infinite number of bits, but every bit higher than this bit</span>
 <span class="s0">* will have the same value, either 0 or 1 (see get_highest_bits()).</span>
 <span class="s0">*</span>
 <span class="s0">* This number may grow and/or shrink automatically as needed.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int SparseArray::get_num_bits(void) const;</span>

<span class="s0">1801 7 get_bit 0 4 2017 20 SparseArray::get_bit 0 1 839 191</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the nth bit is set, false if it is cleared.  It is valid</span>
 <span class="s0">* for n to increase beyond get_num_bits(), but the return value</span>
 <span class="s0">* get_num_bits() will always be the same.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool SparseArray::get_bit(int index) const;</span>

<span class="s0">1802 7 set_bit 0 4 2017 20 SparseArray::set_bit 0 1 840 97</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth bit on.  If n &gt;= get_num_bits(), this automatically extends</span>
 <span class="s0">* the array.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void SparseArray::set_bit(int index);</span>

<span class="s0">1803 9 clear_bit 0 4 2017 22 SparseArray::clear_bit 0 1 841 98</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth bit off.  If n &gt;= get_num_bits(), this automatically extends</span>
 <span class="s0">* the array.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void SparseArray::clear_bit(int index);</span>

<span class="s0">1804 10 set_bit_to 0 4 2017 23 SparseArray::set_bit_to 0 1 842 84</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth bit either on or off, according to the indicated bool value.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void SparseArray::set_bit_to(int index, bool value);</span>

<span class="s0">1805 16 get_highest_bits 0 4 2017 29 SparseArray::get_highest_bits 0 1 843 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the infinite set of bits beyond get_num_bits() are all on,</span>
 <span class="s0">* or false of they are all off.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool SparseArray::get_highest_bits(void) const;</span>

<span class="s0">1806 7 is_zero 0 4 2017 20 SparseArray::is_zero 0 1 844 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the entire bitmask is zero, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool SparseArray::is_zero(void) const;</span>

<span class="s0">1807 9 is_all_on 0 4 2017 22 SparseArray::is_all_on 0 1 845 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the entire bitmask is one, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool SparseArray::is_all_on(void) const;</span>

<span class="s0">1808 10 has_any_of 0 4 2017 23 SparseArray::has_any_of 0 1 846 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any bit in the indicated range is set, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool SparseArray::has_any_of(int low_bit, int size) const;</span>

<span class="s0">1809 10 has_all_of 0 4 2017 23 SparseArray::has_all_of 0 1 847 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all bits in the indicated range are set, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool SparseArray::has_all_of(int low_bit, int size) const;</span>

<span class="s0">1810 9 set_range 0 4 2017 22 SparseArray::set_range 0 1 848 47</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the indicated range of bits on.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void SparseArray::set_range(int low_bit, int size);</span>

<span class="s0">1811 11 clear_range 0 4 2017 24 SparseArray::clear_range 0 1 849 48</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the indicated range of bits off.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void SparseArray::clear_range(int low_bit, int size);</span>

<span class="s0">1812 12 set_range_to 0 4 2017 25 SparseArray::set_range_to 0 1 850 64</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the indicated range of bits to either on or off.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void SparseArray::set_range_to(bool value, int low_bit, int size);</span>

<span class="s0">1813 15 get_num_on_bits 0 4 2017 28 SparseArray::get_num_on_bits 0 1 851 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bits that are set to 1 in the array.  Returns -1 if</span>
 <span class="s0">* there are an infinite number of 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int SparseArray::get_num_on_bits(void) const;</span>

<span class="s0">1814 16 get_num_off_bits 0 4 2017 29 SparseArray::get_num_off_bits 0 1 852 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bits that are set to 0 in the array.  Returns -1 if</span>
 <span class="s0">* there are an infinite number of 0 bits.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">int SparseArray::get_num_off_bits(void) const;</span>

<span class="s0">1815 17 get_lowest_on_bit 0 4 2017 30 SparseArray::get_lowest_on_bit 0 1 853 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the lowest 1 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 1 bits or if there are an infinite number of 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">int SparseArray::get_lowest_on_bit(void) const;</span>

<span class="s0">1816 18 get_lowest_off_bit 0 4 2017 31 SparseArray::get_lowest_off_bit 0 1 854 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the lowest 0 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 0 bits or if there are an infinite number of 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int SparseArray::get_lowest_off_bit(void) const;</span>

<span class="s0">1817 18 get_highest_on_bit 0 4 2017 31 SparseArray::get_highest_on_bit 0 1 855 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the highest 1 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 1 bits or if there an infinite number of 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int SparseArray::get_highest_on_bit(void) const;</span>

<span class="s0">1818 19 get_highest_off_bit 0 4 2017 32 SparseArray::get_highest_off_bit 0 1 856 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the highest 0 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 0 bits or if there an infinite number of 1 bits.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">int SparseArray::get_highest_off_bit(void) const;</span>

<span class="s0">1819 29 get_next_higher_different_bit 0 4 2017 42 SparseArray::get_next_higher_different_bit 0 1 857 287</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the next bit in the array, above low_bit, whose value</span>
 <span class="s0">* is different that the value of low_bit.  Returns low_bit again if all bits</span>
 <span class="s0">* higher than low_bit have the same value.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to quickly iterate through all of the bits in the array.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">int SparseArray::get_next_higher_different_bit(int low_bit) const;</span>

<span class="s0">1820 15 invert_in_place 0 4 2017 28 SparseArray::invert_in_place 0 1 858 93</span>
<span class="s0">/**</span>
 <span class="s0">* Inverts all the bits in the SparseArray.  This is equivalent to array =</span>
 <span class="s0">* ~array.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void SparseArray::invert_in_place(void);</span>

<span class="s0">1821 18 has_bits_in_common 0 4 2017 31 SparseArray::has_bits_in_common 0 1 859 181</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this SparseArray has any &quot;one&quot; bits in common with the</span>
 <span class="s0">* other one, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is equivalent to (array &amp; other) != 0, but may be faster.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool SparseArray::has_bits_in_common(SparseArray const &amp;other) const;</span>

<span class="s0">1822 5 clear 0 4 2017 18 SparseArray::clear 0 1 860 52</span>
<span class="s0">/**</span>
 <span class="s0">* Sets all the bits in the SparseArray off.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline void SparseArray::clear(void);</span>

<span class="s0">1823 6 output 0 4 2017 19 SparseArray::output 0 1 861 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void SparseArray::output(std::ostream &amp;out) const;</span>

<span class="s0">1824 11 operator == 0 4 2017 24 SparseArray::operator == 0 1 862 0</span>
<span class="s0">69</span>
<span class="s0">inline bool SparseArray::operator ==(SparseArray const &amp;other) const;</span>

<span class="s0">1825 11 operator != 0 4 2017 24 SparseArray::operator != 0 1 863 0</span>
<span class="s0">69</span>
<span class="s0">inline bool SparseArray::operator !=(SparseArray const &amp;other) const;</span>

<span class="s0">1826 10 operator &lt; 0 4 2017 23 SparseArray::operator &lt; 0 1 864 0</span>
<span class="s0">68</span>
<span class="s0">inline bool SparseArray::operator &lt;(SparseArray const &amp;other) const;</span>

<span class="s0">1827 10 compare_to 0 4 2017 23 SparseArray::compare_to 0 1 865 242</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this SparseArray sorts before the</span>
 <span class="s0">* indicated other SparseArray, greater than zero if it sorts after, or 0 if</span>
 <span class="s0">* they are equivalent.  This is based on the same ordering defined by</span>
 <span class="s0">* operator &lt;.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">int SparseArray::compare_to(SparseArray const &amp;other) const;</span>

<span class="s0">1828 10 operator &amp; 0 4 2017 23 SparseArray::operator &amp; 0 1 866 0</span>
<span class="s0">75</span>
<span class="s0">inline SparseArray SparseArray::operator &amp;(SparseArray const &amp;other) const;</span>

<span class="s0">1829 10 operator | 0 4 2017 23 SparseArray::operator | 0 1 867 0</span>
<span class="s0">75</span>
<span class="s0">inline SparseArray SparseArray::operator |(SparseArray const &amp;other) const;</span>

<span class="s0">1830 10 operator ^ 0 4 2017 23 SparseArray::operator ^ 0 1 868 0</span>
<span class="s0">75</span>
<span class="s0">inline SparseArray SparseArray::operator ^(SparseArray const &amp;other) const;</span>

<span class="s0">1831 10 operator ~ 0 68 2017 23 SparseArray::operator ~ 0 1 869 0</span>
<span class="s0">55</span>
<span class="s0">inline SparseArray SparseArray::operator ~(void) const;</span>

<span class="s0">1832 11 operator &lt;&lt; 0 4 2017 24 SparseArray::operator &lt;&lt; 0 1 870 0</span>
<span class="s0">61</span>
<span class="s0">inline SparseArray SparseArray::operator &lt;&lt;(int shift) const;</span>

<span class="s0">1833 11 operator &gt;&gt; 0 4 2017 24 SparseArray::operator &gt;&gt; 0 1 871 0</span>
<span class="s0">61</span>
<span class="s0">inline SparseArray SparseArray::operator &gt;&gt;(int shift) const;</span>

<span class="s0">1834 11 operator &amp;= 0 4 2017 24 SparseArray::operator &amp;= 0 1 872 0</span>
<span class="s0">56</span>
<span class="s0">void SparseArray::operator &amp;=(SparseArray const &amp;other);</span>

<span class="s0">1835 11 operator |= 0 4 2017 24 SparseArray::operator |= 0 1 873 0</span>
<span class="s0">56</span>
<span class="s0">void SparseArray::operator |=(SparseArray const &amp;other);</span>

<span class="s0">1836 11 operator ^= 0 4 2017 24 SparseArray::operator ^= 0 1 874 0</span>
<span class="s0">56</span>
<span class="s0">void SparseArray::operator ^=(SparseArray const &amp;other);</span>

<span class="s0">1837 12 operator &lt;&lt;= 0 4 2017 25 SparseArray::operator &lt;&lt;= 0 1 875 0</span>
<span class="s0">49</span>
<span class="s0">inline void SparseArray::operator &lt;&lt;=(int shift);</span>

<span class="s0">1838 12 operator &gt;&gt;= 0 4 2017 25 SparseArray::operator &gt;&gt;= 0 1 876 0</span>
<span class="s0">49</span>
<span class="s0">inline void SparseArray::operator &gt;&gt;=(int shift);</span>

<span class="s0">1839 10 is_inverse 0 4 2017 23 SparseArray::is_inverse 0 1 877 330</span>
<span class="s0">/**</span>
 <span class="s0">* If this is true, the SparseArray is actually defined as a list of subranges</span>
 <span class="s0">* of integers that are *not* in the set.  If this is false (the default),</span>
 <span class="s0">* then the subranges define the integers that *are* in the set.  This affects</span>
 <span class="s0">* the interpretation of the values returned by iterating through</span>
 <span class="s0">* get_num_subranges().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool SparseArray::is_inverse(void) const;</span>

<span class="s0">1840 17 get_num_subranges 0 4 2017 30 SparseArray::get_num_subranges 0 1 878 237</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of separate subranges stored in the SparseArray.  You</span>
 <span class="s0">* can use this limit to iterate through the subranges, calling</span>
 <span class="s0">* get_subrange_begin() and get_subrange_end() for each one.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see is_inverse().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t SparseArray::get_num_subranges(void) const;</span>

<span class="s0">1841 18 get_subrange_begin 0 4 2017 31 SparseArray::get_subrange_begin 0 1 879 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first numeric element in the nth subrange.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see is_inverse().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline int SparseArray::get_subrange_begin(std::size_t n) const;</span>

<span class="s0">1842 16 get_subrange_end 0 4 2017 29 SparseArray::get_subrange_end 0 1 880 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the last numeric element, plus one, in the nth subrange.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see is_inverse().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int SparseArray::get_subrange_end(std::size_t n) const;</span>

<span class="s0">1843 12 __getstate__ 0 4 2017 25 SparseArray::__getstate__ 0 1 881 0</span>
<span class="s0">48</span>
<span class="s0">PyObject *SparseArray::__getstate__(void) const;</span>

<span class="s0">1844 12 __setstate__ 0 4 2017 25 SparseArray::__setstate__ 0 1 882 0</span>
<span class="s0">48</span>
<span class="s0">void SparseArray::__setstate__(PyObject *state);</span>

<span class="s0">1845 14 get_class_type 0 4 2017 27 SparseArray::get_class_type 0 1 883 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle SparseArray::get_class_type(void);</span>

<span class="s0">1846 12 ~SparseArray 0 516 2017 25 SparseArray::~SparseArray 0 0 0</span>
<span class="s0">32</span>
<span class="s0">SparseArray::~SparseArray(void);</span>

<span class="s0">1847 14 get_value_type 0 6 2018 30 ParamValueBase::get_value_type 0 1 884 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of the underlying value.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">virtual inline TypeHandle ParamValueBase::get_value_type(void) const;</span>

<span class="s0">1848 6 output 0 6 2018 22 ParamValueBase::output 0 1 885 0</span>
<span class="s0">65</span>
<span class="s0">virtual void ParamValueBase::output(std::ostream &amp;out) const = 0;</span>

<span class="s0">1849 14 get_class_type 0 4 2018 30 ParamValueBase::get_class_type 0 1 886 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle ParamValueBase::get_class_type(void);</span>

<span class="s0">1850 18 ParamTypedRefCount 0 260 2019 38 ParamTypedRefCount::ParamTypedRefCount 0 1 887 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value);</span>

<span class="s0">1851 9 get_value 0 4 2019 29 ParamTypedRefCount::get_value 0 1 888 55</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the value stored in the parameter.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const;</span>

<span class="s0">1852 14 get_class_type 0 4 2019 34 ParamTypedRefCount::get_class_type 0 1 889 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle ParamTypedRefCount::get_class_type(void);</span>

<span class="s0">1853 10 ParamValue 0 260 2021 32 ParamValue&lt; string &gt;::ParamValue 0 1 890 0</span>
<span class="s0">66</span>
<span class="s0">inline ParamValue&lt; string &gt;::ParamValue(std::string const &amp;value);</span>

<span class="s0">1854 9 set_value 0 4 2021 31 ParamValue&lt; string &gt;::set_value 0 1 891 0</span>
<span class="s0">134</span>
<span class="s0">inline void ParamValue&lt; string &gt;::set_value(std::string const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; string &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1855 9 get_value 0 4 2021 31 ParamValue&lt; string &gt;::get_value 0 1 892 0</span>
<span class="s0">70</span>
<span class="s0">inline std::string const &amp;ParamValue&lt; string &gt;::get_value(void) const;</span>

<span class="s0">1856 14 get_class_type 0 4 2021 36 ParamValue&lt; string &gt;::get_class_type 0 1 893 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle ParamValue&lt; string &gt;::get_class_type(void);</span>

<span class="s0">1857 10 ParamValue 0 260 2024 33 ParamValue&lt; wstring &gt;::ParamValue 0 1 894 0</span>
<span class="s0">68</span>
<span class="s0">inline ParamValue&lt; wstring &gt;::ParamValue(std::wstring const &amp;value);</span>

<span class="s0">1858 9 set_value 0 4 2024 32 ParamValue&lt; wstring &gt;::set_value 0 1 895 0</span>
<span class="s0">137</span>
<span class="s0">inline void ParamValue&lt; wstring &gt;::set_value(std::wstring const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; wstring &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1859 9 get_value 0 4 2024 32 ParamValue&lt; wstring &gt;::get_value 0 1 896 0</span>
<span class="s0">72</span>
<span class="s0">inline std::wstring const &amp;ParamValue&lt; wstring &gt;::get_value(void) const;</span>

<span class="s0">1860 14 get_class_type 0 4 2024 37 ParamValue&lt; wstring &gt;::get_class_type 0 1 897 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle ParamValue&lt; wstring &gt;::get_class_type(void);</span>

<span class="s0">1861 10 ParamValue 0 260 2026 36 ParamValue&lt; LVecBase2d &gt;::ParamValue 0 1 898 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase2d &gt;::ParamValue(LVecBase2d const &amp;value);</span>

<span class="s0">1862 9 set_value 0 4 2026 35 ParamValue&lt; LVecBase2d &gt;::set_value 0 1 899 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase2d &gt;::set_value(LVecBase2d const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase2d &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1863 9 get_value 0 4 2026 35 ParamValue&lt; LVecBase2d &gt;::get_value 0 1 900 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase2d const &amp;ParamValue&lt; LVecBase2d &gt;::get_value(void) const;</span>

<span class="s0">1864 14 get_class_type 0 4 2026 40 ParamValue&lt; LVecBase2d &gt;::get_class_type 0 1 901 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase2d &gt;::get_class_type(void);</span>

<span class="s0">1865 10 ParamValue 0 260 2028 36 ParamValue&lt; LVecBase2f &gt;::ParamValue 0 1 902 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase2f &gt;::ParamValue(LVecBase2f const &amp;value);</span>

<span class="s0">1866 9 set_value 0 4 2028 35 ParamValue&lt; LVecBase2f &gt;::set_value 0 1 903 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase2f &gt;::set_value(LVecBase2f const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase2f &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1867 9 get_value 0 4 2028 35 ParamValue&lt; LVecBase2f &gt;::get_value 0 1 904 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase2f const &amp;ParamValue&lt; LVecBase2f &gt;::get_value(void) const;</span>

<span class="s0">1868 14 get_class_type 0 4 2028 40 ParamValue&lt; LVecBase2f &gt;::get_class_type 0 1 905 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase2f &gt;::get_class_type(void);</span>

<span class="s0">1869 10 ParamValue 0 260 2030 36 ParamValue&lt; LVecBase2i &gt;::ParamValue 0 1 906 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase2i &gt;::ParamValue(LVecBase2i const &amp;value);</span>

<span class="s0">1870 9 set_value 0 4 2030 35 ParamValue&lt; LVecBase2i &gt;::set_value 0 1 907 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase2i &gt;::set_value(LVecBase2i const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase2i &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1871 9 get_value 0 4 2030 35 ParamValue&lt; LVecBase2i &gt;::get_value 0 1 908 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase2i const &amp;ParamValue&lt; LVecBase2i &gt;::get_value(void) const;</span>

<span class="s0">1872 14 get_class_type 0 4 2030 40 ParamValue&lt; LVecBase2i &gt;::get_class_type 0 1 909 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase2i &gt;::get_class_type(void);</span>

<span class="s0">1873 10 ParamValue 0 260 2032 36 ParamValue&lt; LVecBase3d &gt;::ParamValue 0 1 910 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase3d &gt;::ParamValue(LVecBase3d const &amp;value);</span>

<span class="s0">1874 9 set_value 0 4 2032 35 ParamValue&lt; LVecBase3d &gt;::set_value 0 1 911 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase3d &gt;::set_value(LVecBase3d const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase3d &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1875 9 get_value 0 4 2032 35 ParamValue&lt; LVecBase3d &gt;::get_value 0 1 912 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase3d const &amp;ParamValue&lt; LVecBase3d &gt;::get_value(void) const;</span>

<span class="s0">1876 14 get_class_type 0 4 2032 40 ParamValue&lt; LVecBase3d &gt;::get_class_type 0 1 913 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase3d &gt;::get_class_type(void);</span>

<span class="s0">1877 10 ParamValue 0 260 2034 36 ParamValue&lt; LVecBase3f &gt;::ParamValue 0 1 914 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase3f &gt;::ParamValue(LVecBase3f const &amp;value);</span>

<span class="s0">1878 9 set_value 0 4 2034 35 ParamValue&lt; LVecBase3f &gt;::set_value 0 1 915 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase3f &gt;::set_value(LVecBase3f const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase3f &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1879 9 get_value 0 4 2034 35 ParamValue&lt; LVecBase3f &gt;::get_value 0 1 916 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase3f const &amp;ParamValue&lt; LVecBase3f &gt;::get_value(void) const;</span>

<span class="s0">1880 14 get_class_type 0 4 2034 40 ParamValue&lt; LVecBase3f &gt;::get_class_type 0 1 917 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase3f &gt;::get_class_type(void);</span>

<span class="s0">1881 10 ParamValue 0 260 2036 36 ParamValue&lt; LVecBase3i &gt;::ParamValue 0 1 918 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase3i &gt;::ParamValue(LVecBase3i const &amp;value);</span>

<span class="s0">1882 9 set_value 0 4 2036 35 ParamValue&lt; LVecBase3i &gt;::set_value 0 1 919 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase3i &gt;::set_value(LVecBase3i const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase3i &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1883 9 get_value 0 4 2036 35 ParamValue&lt; LVecBase3i &gt;::get_value 0 1 920 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase3i const &amp;ParamValue&lt; LVecBase3i &gt;::get_value(void) const;</span>

<span class="s0">1884 14 get_class_type 0 4 2036 40 ParamValue&lt; LVecBase3i &gt;::get_class_type 0 1 921 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase3i &gt;::get_class_type(void);</span>

<span class="s0">1885 10 ParamValue 0 260 2038 36 ParamValue&lt; LVecBase4d &gt;::ParamValue 0 1 922 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase4d &gt;::ParamValue(LVecBase4d const &amp;value);</span>

<span class="s0">1886 9 set_value 0 4 2038 35 ParamValue&lt; LVecBase4d &gt;::set_value 0 1 923 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase4d &gt;::set_value(LVecBase4d const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase4d &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1887 9 get_value 0 4 2038 35 ParamValue&lt; LVecBase4d &gt;::get_value 0 1 924 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase4d const &amp;ParamValue&lt; LVecBase4d &gt;::get_value(void) const;</span>

<span class="s0">1888 14 get_class_type 0 4 2038 40 ParamValue&lt; LVecBase4d &gt;::get_class_type 0 1 925 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase4d &gt;::get_class_type(void);</span>

<span class="s0">1889 10 ParamValue 0 260 2040 36 ParamValue&lt; LVecBase4f &gt;::ParamValue 0 1 926 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase4f &gt;::ParamValue(LVecBase4f const &amp;value);</span>

<span class="s0">1890 9 set_value 0 4 2040 35 ParamValue&lt; LVecBase4f &gt;::set_value 0 1 927 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase4f &gt;::set_value(LVecBase4f const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase4f &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1891 9 get_value 0 4 2040 35 ParamValue&lt; LVecBase4f &gt;::get_value 0 1 928 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase4f const &amp;ParamValue&lt; LVecBase4f &gt;::get_value(void) const;</span>

<span class="s0">1892 14 get_class_type 0 4 2040 40 ParamValue&lt; LVecBase4f &gt;::get_class_type 0 1 929 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase4f &gt;::get_class_type(void);</span>

<span class="s0">1893 10 ParamValue 0 260 2042 36 ParamValue&lt; LVecBase4i &gt;::ParamValue 0 1 930 0</span>
<span class="s0">69</span>
<span class="s0">inline ParamValue&lt; LVecBase4i &gt;::ParamValue(LVecBase4i const &amp;value);</span>

<span class="s0">1894 9 set_value 0 4 2042 35 ParamValue&lt; LVecBase4i &gt;::set_value 0 1 931 0</span>
<span class="s0">141</span>
<span class="s0">inline void ParamValue&lt; LVecBase4i &gt;::set_value(LVecBase4i const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LVecBase4i &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1895 9 get_value 0 4 2042 35 ParamValue&lt; LVecBase4i &gt;::get_value 0 1 932 0</span>
<span class="s0">73</span>
<span class="s0">inline LVecBase4i const &amp;ParamValue&lt; LVecBase4i &gt;::get_value(void) const;</span>

<span class="s0">1896 14 get_class_type 0 4 2042 40 ParamValue&lt; LVecBase4i &gt;::get_class_type 0 1 933 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle ParamValue&lt; LVecBase4i &gt;::get_class_type(void);</span>

<span class="s0">1897 10 ParamValue 0 260 2044 35 ParamValue&lt; LMatrix3d &gt;::ParamValue 0 1 934 0</span>
<span class="s0">67</span>
<span class="s0">inline ParamValue&lt; LMatrix3d &gt;::ParamValue(LMatrix3d const &amp;value);</span>

<span class="s0">1898 9 set_value 0 4 2044 34 ParamValue&lt; LMatrix3d &gt;::set_value 0 1 935 0</span>
<span class="s0">138</span>
<span class="s0">inline void ParamValue&lt; LMatrix3d &gt;::set_value(LMatrix3d const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LMatrix3d &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1899 9 get_value 0 4 2044 34 ParamValue&lt; LMatrix3d &gt;::get_value 0 1 936 0</span>
<span class="s0">71</span>
<span class="s0">inline LMatrix3d const &amp;ParamValue&lt; LMatrix3d &gt;::get_value(void) const;</span>

<span class="s0">1900 14 get_class_type 0 4 2044 39 ParamValue&lt; LMatrix3d &gt;::get_class_type 0 1 937 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle ParamValue&lt; LMatrix3d &gt;::get_class_type(void);</span>

<span class="s0">1901 10 ParamValue 0 260 2046 35 ParamValue&lt; LMatrix3f &gt;::ParamValue 0 1 938 0</span>
<span class="s0">67</span>
<span class="s0">inline ParamValue&lt; LMatrix3f &gt;::ParamValue(LMatrix3f const &amp;value);</span>

<span class="s0">1902 9 set_value 0 4 2046 34 ParamValue&lt; LMatrix3f &gt;::set_value 0 1 939 0</span>
<span class="s0">138</span>
<span class="s0">inline void ParamValue&lt; LMatrix3f &gt;::set_value(LMatrix3f const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LMatrix3f &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1903 9 get_value 0 4 2046 34 ParamValue&lt; LMatrix3f &gt;::get_value 0 1 940 0</span>
<span class="s0">71</span>
<span class="s0">inline LMatrix3f const &amp;ParamValue&lt; LMatrix3f &gt;::get_value(void) const;</span>

<span class="s0">1904 14 get_class_type 0 4 2046 39 ParamValue&lt; LMatrix3f &gt;::get_class_type 0 1 941 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle ParamValue&lt; LMatrix3f &gt;::get_class_type(void);</span>

<span class="s0">1905 10 ParamValue 0 260 2048 35 ParamValue&lt; LMatrix4d &gt;::ParamValue 0 1 942 0</span>
<span class="s0">67</span>
<span class="s0">inline ParamValue&lt; LMatrix4d &gt;::ParamValue(LMatrix4d const &amp;value);</span>

<span class="s0">1906 9 set_value 0 4 2048 34 ParamValue&lt; LMatrix4d &gt;::set_value 0 1 943 0</span>
<span class="s0">138</span>
<span class="s0">inline void ParamValue&lt; LMatrix4d &gt;::set_value(LMatrix4d const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LMatrix4d &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1907 9 get_value 0 4 2048 34 ParamValue&lt; LMatrix4d &gt;::get_value 0 1 944 0</span>
<span class="s0">71</span>
<span class="s0">inline LMatrix4d const &amp;ParamValue&lt; LMatrix4d &gt;::get_value(void) const;</span>

<span class="s0">1908 14 get_class_type 0 4 2048 39 ParamValue&lt; LMatrix4d &gt;::get_class_type 0 1 945 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle ParamValue&lt; LMatrix4d &gt;::get_class_type(void);</span>

<span class="s0">1909 10 ParamValue 0 260 2050 35 ParamValue&lt; LMatrix4f &gt;::ParamValue 0 1 946 0</span>
<span class="s0">67</span>
<span class="s0">inline ParamValue&lt; LMatrix4f &gt;::ParamValue(LMatrix4f const &amp;value);</span>

<span class="s0">1910 9 set_value 0 4 2050 34 ParamValue&lt; LMatrix4f &gt;::set_value 0 1 947 0</span>
<span class="s0">138</span>
<span class="s0">inline void ParamValue&lt; LMatrix4f &gt;::set_value(LMatrix4f const &amp;value);</span>
<span class="s0">inline void ParamValue&lt; LMatrix4f &gt;::set_value(Type const &amp;value);</span>

<span class="s0">1911 9 get_value 0 4 2050 34 ParamValue&lt; LMatrix4f &gt;::get_value 0 1 948 0</span>
<span class="s0">71</span>
<span class="s0">inline LMatrix4f const &amp;ParamValue&lt; LMatrix4f &gt;::get_value(void) const;</span>

<span class="s0">1912 14 get_class_type 0 4 2050 39 ParamValue&lt; LMatrix4f &gt;::get_class_type 0 1 949 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle ParamValue&lt; LMatrix4f &gt;::get_class_type(void);</span>

<span class="s0">1913 14 get_class_type 0 4 2057 36 WritableConfigurable::get_class_type 0 1 950 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle WritableConfigurable::get_class_type(void);</span>

<span class="s0">1914 21 ~WritableConfigurable 0 516 2057 43 WritableConfigurable::~WritableConfigurable 0 0 0</span>
<span class="s0">50</span>
<span class="s0">WritableConfigurable::~WritableConfigurable(void);</span>

<span class="s0">1915 17 UniqueIdAllocator 0 260 2058 36 UniqueIdAllocator::UniqueIdAllocator 0 2 951 952 56</span>
<span class="s0">/**</span>
 <span class="s0">* Create a free id pool in the range [min:max].</span>
 <span class="s0">*/</span>
<span class="s0">165</span>
<span class="s0">explicit UniqueIdAllocator::UniqueIdAllocator(uint32_t min = 0, uint32_t max = 20);</span>
<span class="s0">inline UniqueIdAllocator::UniqueIdAllocator(UniqueIdAllocator const &amp;) = default;</span>

<span class="s0">1916 18 ~UniqueIdAllocator 0 516 2058 37 UniqueIdAllocator::~UniqueIdAllocator 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">UniqueIdAllocator::~UniqueIdAllocator(void);</span>

<span class="s0">1917 8 allocate 0 4 2058 27 UniqueIdAllocator::allocate 0 1 953 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an id between _min and _max (that were passed to the constructor).</span>
 <span class="s0">* IndexEnd is returned if no ids are available.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">uint32_t UniqueIdAllocator::allocate(void);</span>

<span class="s0">1918 18 initial_reserve_id 0 4 2058 37 UniqueIdAllocator::initial_reserve_id 0 1 954 518</span>
<span class="s0">/**</span>
 <span class="s0">* This may be called to mark a particular id as having already been allocated</span>
 <span class="s0">* (for instance, by a prior pass).  The specified id is removed from the</span>
 <span class="s0">* available pool.</span>
 <span class="s0">*</span>
 <span class="s0">* Because of the limitations of this algorithm, this is most efficient when</span>
 <span class="s0">* it is called before the first call to allocate(), and when all the calls to</span>
 <span class="s0">* initial_reserve_id() are made in descending order by id.  However, this is</span>
 <span class="s0">* a performance warning only; if performance is not an issue, any id may be</span>
 <span class="s0">* reserved at any time.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void UniqueIdAllocator::initial_reserve_id(uint32_t id);</span>

<span class="s0">1919 4 free 0 4 2058 23 UniqueIdAllocator::free 0 1 955 112</span>
<span class="s0">/**</span>
 <span class="s0">* Free an allocated index (index must be between _min and _max that were</span>
 <span class="s0">* passed to the constructor).</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void UniqueIdAllocator::free(uint32_t index);</span>

<span class="s0">1920 13 fraction_used 0 4 2058 32 UniqueIdAllocator::fraction_used 0 1 956 117</span>
<span class="s0">/**</span>
 <span class="s0">* return the decimal fraction of the pool that is used.  The range is 0 to</span>
 <span class="s0">* 1.0 (e.g.  75% would be 0.75).</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">PN_stdfloat UniqueIdAllocator::fraction_used(void) const;</span>

<span class="s0">1921 6 output 0 4 2058 25 UniqueIdAllocator::output 0 1 957 42</span>
<span class="s0">/**</span>
 <span class="s0">* ...intended for debugging only.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void UniqueIdAllocator::output(std::ostream &amp;out) const;</span>

<span class="s0">1922 5 write 0 4 2058 24 UniqueIdAllocator::write 0 1 958 42</span>
<span class="s0">/**</span>
 <span class="s0">* ...intended for debugging only.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void UniqueIdAllocator::write(std::ostream &amp;out) const;</span>

<span class="s0">1923 39 py_decode_TypedWritable_from_bam_stream 0 1 0 39 py_decode_TypedWritable_from_bam_stream 0 1 967 203</span>
<span class="s0">/**</span>
 <span class="s0">* This wrapper is defined as a global function to suit pickle's needs.</span>
 <span class="s0">*</span>
 <span class="s0">* This hooks into the native pickle and cPickle modules, but it cannot</span>
 <span class="s0">* properly handle self-referential BAM objects.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, vector_uchar const &amp;data);</span>

<span class="s0">1924 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 0 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 968 398</span>
<span class="s0">/**</span>
 <span class="s0">* This wrapper is defined as a global function to suit pickle's needs.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to py_decode_TypedWritable_from_bam_stream, but it provides</span>
 <span class="s0">* additional support for the missing persistent-state object needed to</span>
 <span class="s0">* properly support self-referential BAM objects written to the pickle stream.</span>
 <span class="s0">* This hooks into the pickle and cPickle modules implemented in</span>
 <span class="s0">* direct/src/stdpy.</span>
 <span class="s0">*/</span>
<span class="s0">127</span>
<span class="s0">PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, vector_uchar const &amp;data);</span>

<span class="s0">968</span>
<span class="s0">1 0 0 15 10 2062 988 0 0 1 4 copy 1 2060  </span>
<span class="s0">2 0 0 23 10 2062 988 0 0 1 4 copy 1 2063  </span>
<span class="s0">3 0 0 4 11 2065 0 0 0 1 4 this 3 2062  </span>
<span class="s0">4 0 0 6 12 2066 0 0 0 1 4 this 3 2060  </span>
<span class="s0">5 0 0 6 13 2067 0 0 0 2 4 this 3 2060  1 n 1 2066  </span>
<span class="s0">6 0 0 38 14 2067 0 0 0 2 4 this 3 2060  1 n 1 2066  </span>
<span class="s0">7 0 0 38 15 1961 0 0 0 1 4 this 3 2060  </span>
<span class="s0">8 0 0 38 16 1961 0 0 0 3 4 this 3 2060  1 n 1 2066  5 count 1 2066  </span>
<span class="s0">9 0 0 6 17 1932 0 0 0 1 4 this 3 2060  </span>
<span class="s0">10 0 0 6 18 1932 0 0 0 1 4 this 3 2060  </span>
<span class="s0">11 0 0 6 19 2066 0 0 0 2 4 this 3 2060  6 param0 0 2067  </span>
<span class="s0">12 0 0 38 20 1961 0 0 0 1 4 this 3 2060  </span>
<span class="s0">13 0 0 38 21 1932 0 0 0 3 4 this 3 2060  4 view 1 2069  5 flags 1 1932  </span>
<span class="s0">14 0 0 36 22 2065 0 0 0 2 4 this 3 2060  4 view 1 2069  </span>
<span class="s0">15 0 0 39 23 2062 988 0 0 2 4 this 3 2060  4 memo 1 1961  </span>
<span class="s0">16 0 0 6 8 1933 0 0 64 // These are implemented in PointerToVoid, but expose them here. 2 4 this 3 2072  5 other 1 2072  </span>
<span class="s0">17 0 0 6 9 1933 0 0 0 2 4 this 3 2072  5 other 1 2072  </span>
<span class="s0">18 0 0 4 5 2065 0 0 0 1 4 this 3 2074  </span>
<span class="s0">19 0 0 4 6 2065 0 0 0 2 4 this 3 2075  3 out 1 2077  </span>
<span class="s0">20 0 0 15 26 2078 1010 0 0 1 4 copy 1 2063  </span>
<span class="s0">21 0 0 55 26 2078 1010 0 0 1 6 source 1 1961  </span>
<span class="s0">22 0 0 23 26 2078 1010 0 0 1 11 type_handle 5 2079  </span>
<span class="s0">23 0 0 7 27 2078 1010 0 0 2 1 n 1 2066  11 type_handle 5 2079  </span>
<span class="s0">24 0 0 4 28 2065 0 0 0 1 4 this 3 2078  </span>
<span class="s0">25 0 0 6 29 2066 0 0 0 1 4 this 3 2063  </span>
<span class="s0">26 0 0 4 30 2065 0 0 0 2 4 this 3 2078  1 x 1 2067  </span>
<span class="s0">27 0 0 4 31 2065 0 0 0 1 4 this 3 2078  </span>
<span class="s0">28 0 0 6 32 2067 0 0 0 2 4 this 3 2063  1 n 1 2066  </span>
<span class="s0">29 0 0 4 33 2065 0 0 0 3 4 this 3 2078  1 n 1 2066  5 value 1 2067  </span>
<span class="s0">30 0 0 38 34 2067 0 0 0 2 4 this 3 2063  1 n 1 2066  </span>
<span class="s0">31 0 0 36 35 2065 0 0 0 3 4 this 3 2078  1 n 1 2066  5 value 1 2067  </span>
<span class="s0">32 0 0 38 36 1961 0 0 0 1 4 this 3 2063  </span>
<span class="s0">33 0 0 36 37 2065 0 0 0 2 4 this 3 2078  4 data 1 1961  </span>
<span class="s0">34 0 0 38 38 1961 0 0 0 3 4 this 3 2063  1 n 1 2066  5 count 1 2066  </span>
<span class="s0">35 0 0 4 39 2065 0 0 0 4 4 this 3 2078  1 n 1 2066  5 count 1 2066  4 data 1 2081  </span>
<span class="s0">36 0 0 6 40 1932 0 0 0 1 4 this 3 2063  </span>
<span class="s0">37 0 0 6 41 1932 0 0 0 1 4 this 3 2063  </span>
<span class="s0">38 0 0 6 42 2066 0 0 0 2 4 this 3 2063  6 param0 0 2067  </span>
<span class="s0">39 0 0 38 43 1961 0 0 0 1 4 this 3 2063  </span>
<span class="s0">40 0 0 38 44 1932 0 0 0 3 4 this 3 2078  4 view 1 2069  5 flags 1 1932  </span>
<span class="s0">41 0 0 36 45 2065 0 0 0 2 4 this 3 2063  4 view 1 2069  </span>
<span class="s0">42 0 0 39 46 2078 1010 0 0 2 4 this 3 2063  4 memo 1 1961  </span>
<span class="s0">43 0 0 4 50 2065 0 0 69 /**</span>
 <span class="s0">* Runs the entire animation from beginning to end and stops.</span>
 <span class="s0">*/ 1 4 this 3 2082  </span>
<span class="s0">44 0 0 4 50 2065 0 0 406 /**</span>
 <span class="s0">* Runs the animation from the frame &quot;from&quot; to and including the frame &quot;to&quot;,</span>
 <span class="s0">* at which point the animation is stopped.  Both &quot;from&quot; and &quot;to&quot; frame</span>
 <span class="s0">* numbers may be outside the range (0, get_num_frames()) and the animation</span>
 <span class="s0">* will follow the range correctly, reporting numbers modulo get_num_frames().</span>
 <span class="s0">* For instance, play(0, get_num_frames() * 2) will play the animation twice</span>
 <span class="s0">* and then stop.</span>
 <span class="s0">*/ 3 4 this 3 2082  4 from 1 1931  2 to 1 1931  </span>
<span class="s0">45 0 0 4 51 2065 0 0 169 /**</span>
 <span class="s0">* Starts the entire animation looping.  If restart is true, the animation is</span>
 <span class="s0">* restarted from the beginning; otherwise, it continues from the current</span>
 <span class="s0">* frame.</span>
 <span class="s0">*/ 2 4 this 3 2082  7 restart 1 1933  </span>
<span class="s0">46 0 0 4 51 2065 0 0 221 /**</span>
 <span class="s0">* Loops the animation from the frame &quot;from&quot; to and including the frame &quot;to&quot;,</span>
 <span class="s0">* indefinitely.  If restart is true, the animation is restarted from the</span>
 <span class="s0">* beginning; otherwise, it continues from the current frame.</span>
 <span class="s0">*/ 4 4 this 3 2082  7 restart 1 1933  4 from 1 1931  2 to 1 1931  </span>
<span class="s0">47 0 0 4 52 2065 0 0 224 /**</span>
 <span class="s0">* Starts the entire animation bouncing back and forth between its first frame</span>
 <span class="s0">* and last frame.  If restart is true, the animation is restarted from the</span>
 <span class="s0">* beginning; otherwise, it continues from the current frame.</span>
 <span class="s0">*/ 2 4 this 3 2082  7 restart 1 1933  </span>
<span class="s0">48 0 0 4 52 2065 0 0 143 /**</span>
 <span class="s0">* Loops the animation from the frame &quot;from&quot; to and including the frame &quot;to&quot;,</span>
 <span class="s0">* and then back in the opposite direction, indefinitely.</span>
 <span class="s0">*/ 4 4 this 3 2082  7 restart 1 1933  4 from 1 1931  2 to 1 1931  </span>
<span class="s0">49 0 0 4 53 2065 0 0 130 /**</span>
 <span class="s0">* Stops a currently playing or looping animation right where it is.  The</span>
 <span class="s0">* animation remains posed at the current frame.</span>
 <span class="s0">*/ 1 4 this 3 2082  </span>
<span class="s0">50 0 0 4 54 2065 0 0 72 /**</span>
 <span class="s0">* Sets the animation to the indicated frame and holds it there.</span>
 <span class="s0">*/ 2 4 this 3 2082  5 frame 1 1931  </span>
<span class="s0">51 0 0 4 55 2065 0 0 243 /**</span>
 <span class="s0">* Changes the rate at which the animation plays.  1.0 is the normal speed,</span>
 <span class="s0">* 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to</span>
 <span class="s0">* pause the animation, and a negative value will play the animation</span>
 <span class="s0">* backwards.</span>
 <span class="s0">*/ 2 4 this 3 2082  9 play_rate 1 1931  </span>
<span class="s0">52 0 0 6 56 1931 0 0 79 /**</span>
 <span class="s0">* Returns the rate at which the animation plays.  See set_play_rate().</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">53 0 0 6 57 1931 0 0 234 /**</span>
 <span class="s0">* Returns the native frame rate of the animation.  This is the number of</span>
 <span class="s0">* frames per second that will elapse when the play_rate is set to 1.0.  It is</span>
 <span class="s0">* a fixed property of the animation and may not be adjusted by the user.</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">54 0 0 6 58 1932 0 0 278 /**</span>
 <span class="s0">* Returns the number of frames in the animation.  This is a property of the</span>
 <span class="s0">* animation and may not be directly adjusted by the user (although it may</span>
 <span class="s0">* change without warning with certain kinds of animations, since this is a</span>
 <span class="s0">* virtual method that may be overridden).</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">55 0 0 6 59 1932 0 0 116 /**</span>
 <span class="s0">* Returns the current integer frame number.  This number will be in the range</span>
 <span class="s0">* 0 &lt;= f &lt; get_num_frames().</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">56 0 0 6 60 1932 0 0 330 /**</span>
 <span class="s0">* Returns the current integer frame number + 1, constrained to the range 0 &lt;=</span>
 <span class="s0">* f &lt; get_num_frames().</span>
 <span class="s0">*</span>
 <span class="s0">* If the play mode is PM_play, this will clamp to the same value as</span>
 <span class="s0">* get_frame() at the end of the animation.  If the play mode is any other</span>
 <span class="s0">* value, this will wrap around to frame 0 at the end of the animation.</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">57 0 0 6 61 1931 0 0 314 /**</span>
 <span class="s0">* Returns the fractional part of the current frame.  Normally, this is in the</span>
 <span class="s0">* range 0.0 &lt;= f &lt; 1.0, but in the one special case of an animation playing</span>
 <span class="s0">* to its end frame and stopping, it might exactly equal 1.0.</span>
 <span class="s0">*</span>
 <span class="s0">* It will always be true that get_full_frame() + get_frac() ==</span>
 <span class="s0">* get_full_fframe().</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">58 0 0 6 62 1932 0 0 372 /**</span>
 <span class="s0">* Returns the current integer frame number.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the value returned by get_frame(), this frame number may extend</span>
 <span class="s0">* beyond the range of get_num_frames() if the frame range passed to play(),</span>
 <span class="s0">* loop(), etc.  did.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the value returned by get_full_fframe(), this return value will</span>
 <span class="s0">* never exceed the value passed to to_frame in the play() method.</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">59 0 0 6 63 1931 0 0 490 /**</span>
 <span class="s0">* Returns the current floating-point frame number.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the value returned by get_frame(), this frame number may extend</span>
 <span class="s0">* beyond the range of get_num_frames() if the frame range passed to play(),</span>
 <span class="s0">* loop(), etc.  did.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the value returned by get_full_frame(), this return value may equal</span>
 <span class="s0">* (to_frame + 1.0), when the animation has played to its natural end.</span>
 <span class="s0">* However, in this case the return value of get_full_frame() will be</span>
 <span class="s0">* to_frame, not (to_frame + 1).</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">60 0 0 6 64 1933 0 0 208 /**</span>
 <span class="s0">* Returns true if the animation is currently playing, false if it is stopped</span>
 <span class="s0">* (e.g.  because stop() or pose() was called, or because it reached the end</span>
 <span class="s0">* of the animation after play() was called).</span>
 <span class="s0">*/ 1 4 this 3 2083  </span>
<span class="s0">61 0 0 4 65 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2083  3 out 1 2077  </span>
<span class="s0">62 0 0 7 78 2079 0 0 0 0 </span>
<span class="s0">63 0 0 7 81 2085 1049 0 55 /**</span>
 <span class="s0">* Creates an UpdateSeq in the 'initial' state.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">64 0 0 15 81 2085 1049 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 2086  </span>
<span class="s0">65 0 0 7 82 2085 1049 0 0 0 </span>
<span class="s0">66 0 0 7 83 2085 1049 0 0 0 </span>
<span class="s0">67 0 0 7 84 2085 1049 0 0 0 </span>
<span class="s0">68 0 0 6 85 2085 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2085  4 copy 1 2086  </span>
<span class="s0">69 0 0 4 86 2065 0 0 55 /**</span>
 <span class="s0">* Resets the UpdateSeq to the 'initial' state.</span>
 <span class="s0">*/ 1 4 this 3 2085  </span>
<span class="s0">70 0 0 6 87 1933 0 0 67 /**</span>
 <span class="s0">* Returns true if the UpdateSeq is in the 'initial' state.</span>
 <span class="s0">*/ 1 4 this 3 2086  </span>
<span class="s0">71 0 0 6 88 1933 0 0 63 /**</span>
 <span class="s0">* Returns true if the UpdateSeq is in the 'old' state.</span>
 <span class="s0">*/ 1 4 this 3 2086  </span>
<span class="s0">72 0 0 6 89 1933 0 0 65 /**</span>
 <span class="s0">* Returns true if the UpdateSeq is in the 'fresh' state.</span>
 <span class="s0">*/ 1 4 this 3 2086  </span>
<span class="s0">73 0 0 6 90 1933 0 0 105 /**</span>
 <span class="s0">* Returns true if the UpdateSeq is in any special states, i.e.  'initial',</span>
 <span class="s0">* 'old', or 'fresh'.</span>
 <span class="s0">*/ 1 4 this 3 2086  </span>
<span class="s0">74 0 0 6 91 1933 0 0 0 2 4 this 3 2086  5 other 1 2086  </span>
<span class="s0">75 0 0 6 92 1933 0 0 0 2 4 this 3 2086  5 other 1 2086  </span>
<span class="s0">76 0 0 6 93 1933 0 0 0 2 4 this 3 2086  5 other 1 2086  </span>
<span class="s0">77 0 0 6 94 1933 0 0 0 2 4 this 3 2086  5 other 1 2086  </span>
<span class="s0">78 0 0 6 95 1933 0 0 0 2 4 this 3 2086  5 other 1 2086  </span>
<span class="s0">79 0 0 6 96 1933 0 0 0 2 4 this 3 2086  5 other 1 2086  </span>
<span class="s0">80 0 0 7 97 2085 1049 0 0 1 4 this 3 2085  </span>
<span class="s0">81 0 0 7 98 2085 1049 0 0 2 4 this 3 2085  6 param0 0 1932  </span>
<span class="s0">82 0 0 6 99 1936 0 0 107 /**</span>
 <span class="s0">* Returns the internal integer value associated with the UpdateSeq.  Useful</span>
 <span class="s0">* for debugging only.</span>
 <span class="s0">*/ 1 4 this 3 2086  </span>
<span class="s0">83 0 0 4 104 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2086  3 out 1 2077  </span>
<span class="s0">84 0 0 4 108 2065 0 0 308 /**</span>
 <span class="s0">* This internal function is intended to be called by each class's</span>
 <span class="s0">* make_from_bam() method to read in all of the relevant data from the BamFile</span>
 <span class="s0">* for the new object.  It is also called directly by the BamReader to re-read</span>
 <span class="s0">* the data for an object that has been placed on the stream for an update.</span>
 <span class="s0">*/ 3 4 this 3 1948  4 scan 1 2088  7 manager 1 2090  </span>
<span class="s0">85 0 0 4 109 2065 0 0 345 /**</span>
 <span class="s0">* Increments the bam_modified counter, so that this object will be</span>
 <span class="s0">* invalidated and retransmitted on any open bam streams.  This should</span>
 <span class="s0">* normally not need to be called by user code; it should be called internally</span>
 <span class="s0">* when the object has been changed in a way that legitimately requires its</span>
 <span class="s0">* retransmission to any connected clients.</span>
 <span class="s0">*/ 1 4 this 3 1948  </span>
<span class="s0">86 0 0 7 110 2085 1049 0 140 /**</span>
 <span class="s0">* Returns the current bam_modified counter.  This counter is normally</span>
 <span class="s0">* incremented automatically whenever the object is modified.</span>
 <span class="s0">*/ 1 4 this 3 2091  </span>
<span class="s0">87 0 0 38 111 1961 0 0 0 1 4 this 3 2091  </span>
<span class="s0">88 0 0 38 112 1961 0 0 0 2 4 this 3 2091  7 pickler 1 1961  </span>
<span class="s0">89 0 0 6 113 1998 0 0 423 /**</span>
 <span class="s0">* Converts the TypedWritable object into a single stream of data using a</span>
 <span class="s0">* BamWriter, and returns that data as a bytes object.  Returns an empty bytes</span>
 <span class="s0">* object on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a convenience method particularly useful for cases when you are</span>
 <span class="s0">* only serializing a single object.  If you have many objects to process, it</span>
 <span class="s0">* is more efficient to use the same BamWriter to serialize all of them</span>
 <span class="s0">* together.</span>
 <span class="s0">*/ 1 4 this 3 2091  </span>
<span class="s0">90 0 0 6 113 1933 0 0 429 /**</span>
 <span class="s0">* Converts the TypedWritable object into a single stream of data using a</span>
 <span class="s0">* BamWriter, and stores that data in the indicated string.  Returns true on</span>
 <span class="s0">* success, false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a convenience method particularly useful for cases when you are</span>
 <span class="s0">* only serializing a single object.  If you have many objects to process, it</span>
 <span class="s0">* is more efficient to use the same BamWriter to serialize all of them</span>
 <span class="s0">* together.</span>
 <span class="s0">*/ 3 4 this 3 2091  4 data 1 2093  6 writer 5 2094  </span>
<span class="s0">91 0 0 7 115 2079 0 0 0 0 </span>
<span class="s0">92 0 0 7 122 2095 1064 0 491 /**</span>
 <span class="s0">* Reads the bytes created by a previous call to encode_to_bam_stream(), and</span>
 <span class="s0">* extracts and returns the single object on those bytes.  Returns NULL on</span>
 <span class="s0">* error.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended to replace decode_raw_from_bam_stream() when you</span>
 <span class="s0">* know the stream in question returns an object of type</span>
 <span class="s0">* TypedWritableReferenceCount, allowing for easier reference count</span>
 <span class="s0">* management.  Note that the caller is still responsible for maintaining the</span>
 <span class="s0">* reference count on the return value.</span>
 <span class="s0">*/ 2 4 data 1 1998  6 reader 5 2090  </span>
<span class="s0">93 0 0 7 123 2079 0 0 0 0 </span>
<span class="s0">94 0 0 6 117 1948 0 0 0 1 4 this 3 2095  </span>
<span class="s0">95 0 0 7 120 2096 0 0 0 1 4 this 3 2095  </span>
<span class="s0">96 0 0 7 132 2099 1069 0 179 /**</span>
 <span class="s0">* Returns a duplicate of the BamCacheRecord.  The duplicate will not have a</span>
 <span class="s0">* data pointer set, even though one may have been assigned to the original</span>
 <span class="s0">* via set_data().</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">97 0 0 6 133 1933 0 0 0 2 4 this 3 2097  5 other 1 2097  </span>
<span class="s0">98 0 0 6 134 2100 0 0 237 /**</span>
 <span class="s0">* Returns the full pathname to the source file that originally generated this</span>
 <span class="s0">* cache request.  In some cases, for instance in the case of a of a multipage</span>
 <span class="s0">* texture like &quot;cube_#.png&quot;, this may not not a true filename on disk.</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">99 0 0 6 135 2100 0 0 230 /**</span>
 <span class="s0">* Returns the name of the cache file as hashed from the source_pathname.</span>
 <span class="s0">* This will be relative to the root of the cache directory, and it will not</span>
 <span class="s0">* include any suffixes that may be appended to resolve hash conflicts.</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">100 0 0 6 136 1947 0 0 204 /**</span>
 <span class="s0">* Returns the file timestamp of the original source file that generated this</span>
 <span class="s0">* cache record, if available.  In some cases the original file timestamp is</span>
 <span class="s0">* not available, and this will return 0.</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">101 0 0 6 137 1947 0 0 84 /**</span>
 <span class="s0">* Returns the time at which this particular record was recorded or updated.</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">102 0 0 6 145 1932 0 0 75 /**</span>
 <span class="s0">* Returns the number of source files that contribute to the cache.</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">103 0 0 6 146 2100 0 0 94 /**</span>
 <span class="s0">* Returns the full pathname of the nth source files that contributes to the</span>
 <span class="s0">* cache.</span>
 <span class="s0">*/ 2 4 this 3 2097  1 n 1 1932  </span>
<span class="s0">104 0 0 6 147 1933 0 0 124 /**</span>
 <span class="s0">* Returns true if all of the dependent files are still the same as when the</span>
 <span class="s0">* cache was recorded, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">105 0 0 4 148 2065 0 0 80 /**</span>
 <span class="s0">* Empties the list of files that contribute to the data in this record.</span>
 <span class="s0">*/ 1 4 this 3 2099  </span>
<span class="s0">106 0 0 4 149 2065 0 0 225 /**</span>
 <span class="s0">* Adds the indicated file to the list of files that will be loaded to</span>
 <span class="s0">* generate the data in this record.  This should be called once for the</span>
 <span class="s0">* primary source file, and again for each secondary source file, if any.</span>
 <span class="s0">*/ 2 4 this 3 2099  8 pathname 1 2100  </span>
<span class="s0">107 0 0 4 149 2065 0 0 82 /**</span>
 <span class="s0">* Variant of add_dependent_file that takes an already opened VirtualFile.</span>
 <span class="s0">*/ 2 4 this 3 2099  4 file 1 2101  </span>
<span class="s0">108 0 0 6 150 1933 0 0 130 /**</span>
 <span class="s0">* Returns true if this cache record has an in-memory data object associated--</span>
 <span class="s0">* that is, the object stored in the cache.</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">109 0 0 4 151 2065 0 0 147 /**</span>
 <span class="s0">* Removes the in-memory data object associated with this record, if any.</span>
 <span class="s0">* This does not affect the on-disk representation of the record.</span>
 <span class="s0">*/ 1 4 this 3 2099  </span>
<span class="s0">110 0 0 6 152 1948 0 0 139 /**</span>
 <span class="s0">* Returns a pointer to the data stored in the record, or NULL if there is no</span>
 <span class="s0">* data.  The pointer is not removed from the record.</span>
 <span class="s0">*/ 1 4 this 3 2097  </span>
<span class="s0">111 0 0 4 154 2065 0 0 104 /**</span>
 <span class="s0">* This variant on set_data() is provided to easily pass objects deriving from</span>
 <span class="s0">* TypedWritable.</span>
 <span class="s0">*/ 2 4 this 3 2099  3 ptr 1 1948  </span>
<span class="s0">112 0 0 4 154 2065 0 0 573 /**</span>
 <span class="s0">* Stores a new data object on the record.  You should pass the same pointer</span>
 <span class="s0">* twice, to both parameters; this allows the C++ typecasting to automatically</span>
 <span class="s0">* convert the pointer into both a TypedWritable and a ReferenceCount pointer,</span>
 <span class="s0">* so that the BamCacheRecord object can reliably manage the reference counts.</span>
 <span class="s0">*</span>
 <span class="s0">* You may pass 0 or NULL as the second parameter.  If you do this, the</span>
 <span class="s0">* BamCacheRecord will not manage the object's reference count; it will be up</span>
 <span class="s0">* to you to ensure the object is not deleted during the lifetime of the</span>
 <span class="s0">* BamCacheRecord object.</span>
 <span class="s0">*/ 3 4 this 3 2099  3 ptr 1 1948  7 ref_ptr 1 2096  </span>
<span class="s0">113 0 0 4 154 2065 0 0 115 /**</span>
 <span class="s0">* This variant on set_data() is provided just to allow Python code to pass a</span>
 <span class="s0">* 0 as the second parameter.</span>
 <span class="s0">*/ 3 4 this 3 2099  3 ptr 1 1948  5 dummy 1 1932  </span>
<span class="s0">114 0 0 4 154 2065 0 0 118 /**</span>
 <span class="s0">* This variant on set_data() is provided to easily pass objects deriving from</span>
 <span class="s0">* TypedWritableReferenceCount.</span>
 <span class="s0">*/ 2 4 this 3 2099  3 ptr 1 2095  </span>
<span class="s0">115 0 0 4 157 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2097  3 out 1 2077  </span>
<span class="s0">116 0 0 4 158 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 2097  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">117 0 0 7 159 2079 0 0 0 0 </span>
<span class="s0">118 0 0 7 126 2095 1064 0 0 1 4 this 3 2099  </span>
<span class="s0">119 0 0 7 161 2104 1090 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">120 0 0 4 163 2065 0 0 347 /**</span>
 <span class="s0">* Changes the state of the active flag.  &quot;active&quot; means that the cache should</span>
 <span class="s0">* be consulted automatically on loads, &quot;not active&quot; means that objects should</span>
 <span class="s0">* be loaded directly without consulting the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* This represents the global flag.  Also see the individual cache_models,</span>
 <span class="s0">* cache_textures, cache_compressed_textures flags.</span>
 <span class="s0">*/ 2 4 this 3 2104  4 flag 1 1933  </span>
<span class="s0">121 0 0 6 164 1933 0 0 381 /**</span>
 <span class="s0">* Returns true if the BamCache is currently active, false if it is not.</span>
 <span class="s0">* &quot;active&quot; means that the cache should be consulted automatically on loads,</span>
 <span class="s0">* &quot;not active&quot; means that objects should be loaded directly without</span>
 <span class="s0">* consulting the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* This represents the global flag.  Also see the individual cache_models,</span>
 <span class="s0">* cache_textures, cache_compressed_textures flags.</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">122 0 0 4 165 2065 0 0 118 /**</span>
 <span class="s0">* Indicates whether model files (e.g.  egg files and bam files) will be</span>
 <span class="s0">* stored in the cache, as bam files.</span>
 <span class="s0">*/ 2 4 this 3 2104  4 flag 1 1933  </span>
<span class="s0">123 0 0 6 166 1933 0 0 172 /**</span>
 <span class="s0">* Returns whether model files (e.g.  egg files and bam files) will be stored</span>
 <span class="s0">* in the cache, as bam files.</span>
 <span class="s0">*</span>
 <span class="s0">* This also returns false if get_active() is false.</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">124 0 0 4 167 2065 0 0 101 /**</span>
 <span class="s0">* Indicates whether texture files will be stored in the cache, as</span>
 <span class="s0">* uncompressed txo files.</span>
 <span class="s0">*/ 2 4 this 3 2104  4 flag 1 1933  </span>
<span class="s0">125 0 0 6 168 1933 0 0 174 /**</span>
 <span class="s0">* Returns whether texture files (e.g.  egg files and bam files) will be</span>
 <span class="s0">* stored in the cache, as txo files.</span>
 <span class="s0">*</span>
 <span class="s0">* This also returns false if get_active() is false.</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">126 0 0 4 169 2065 0 0 722 /**</span>
 <span class="s0">* Indicates whether compressed texture files will be stored in the cache, as</span>
 <span class="s0">* compressed txo files.  The compressed data may either be generated in-CPU,</span>
 <span class="s0">* via the squish library, or it may be extracted from the GSG after the</span>
 <span class="s0">* texture has been loaded.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be set in conjunction with set_cache_textures(), or independently</span>
 <span class="s0">* of it.  If set_cache_textures() is true and this is false, all textures</span>
 <span class="s0">* will be cached in their uncompressed form.  If set_cache_textures() is</span>
 <span class="s0">* false and this is true, only compressed textures will be cached, and they</span>
 <span class="s0">* will be cached in their compressed form.  If both are true, all textures</span>
 <span class="s0">* will be cached, in their uncompressed or compressed form appropriately.</span>
 <span class="s0">*/ 2 4 this 3 2104  4 flag 1 1933  </span>
<span class="s0">127 0 0 6 170 1933 0 0 202 /**</span>
 <span class="s0">* Returns whether compressed texture files will be stored in the cache, as</span>
 <span class="s0">* compressed txo files.  See set_cache_compressed_textures().</span>
 <span class="s0">*</span>
 <span class="s0">* This also returns false if get_active() is false.</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">128 0 0 4 171 2065 0 0 184 /**</span>
 <span class="s0">* Indicates whether compiled shader programs will be stored in the cache, as</span>
 <span class="s0">* binary .sho files.  This may not be supported by all shader languages or</span>
 <span class="s0">* graphics renderers.</span>
 <span class="s0">*/ 2 4 this 3 2104  4 flag 1 1933  </span>
<span class="s0">129 0 0 6 172 1933 0 0 196 /**</span>
 <span class="s0">* Returns whether compiled shader programs will be stored in the cache, as</span>
 <span class="s0">* binary .txo files.  See set_cache_compiled_shaders().</span>
 <span class="s0">*</span>
 <span class="s0">* This also returns false if get_active() is false.</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">130 0 0 4 173 2065 0 0 372 /**</span>
 <span class="s0">* Changes the current root pathname of the cache.  This specifies where the</span>
 <span class="s0">* cache files are stored on disk.  This should name a directory that is on a</span>
 <span class="s0">* disk local to the machine (not on a network-mounted disk), for instance,</span>
 <span class="s0">* /tmp/panda-cache or /c/panda-cache.</span>
 <span class="s0">*</span>
 <span class="s0">* If the directory does not already exist, it will be created as a result of</span>
 <span class="s0">* this call.</span>
 <span class="s0">*/ 2 4 this 3 2104  4 root 1 2100  </span>
<span class="s0">131 0 0 7 174 2107 0 0 75 /**</span>
 <span class="s0">* Returns the current root pathname of the cache.  See set_root().</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">132 0 0 4 175 2065 0 0 86 /**</span>
 <span class="s0">* Specifies the time in seconds between automatic flushes of the cache index.</span>
 <span class="s0">*/ 2 4 this 3 2104  10 flush_time 1 1932  </span>
<span class="s0">133 0 0 6 176 1932 0 0 84 /**</span>
 <span class="s0">* Returns the time in seconds between automatic flushes of the cache index.</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">134 0 0 4 177 2065 0 0 430 /**</span>
 <span class="s0">* Specifies the maximum size, in kilobytes, which the cache is allowed to</span>
 <span class="s0">* grow to.  If a newly cached file would exceed this size, an older file is</span>
 <span class="s0">* removed from the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that in the case of multiple different processes simultaneously</span>
 <span class="s0">* operating on the same cache directory, the actual cache size may slightly</span>
 <span class="s0">* exceed this value from time to time due to latency in checking between the</span>
 <span class="s0">* processes.</span>
 <span class="s0">*/ 2 4 this 3 2104  10 max_kbytes 1 1932  </span>
<span class="s0">135 0 0 6 178 1932 0 0 121 /**</span>
 <span class="s0">* Returns the maximum size, in kilobytes, which the cache is allowed to grow</span>
 <span class="s0">* to.  See set_cache_max_kbytes().</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">136 0 0 4 179 2065 0 0 252 /**</span>
 <span class="s0">* Can be used to put the cache in read-only mode, or take it out of read-only</span>
 <span class="s0">* mode.  Note that if you put it into read-write mode, and it discovers that</span>
 <span class="s0">* it does not have write access, it will put itself right back into read-only</span>
 <span class="s0">* mode.</span>
 <span class="s0">*/ 2 4 this 3 2104  2 ro 1 1933  </span>
<span class="s0">137 0 0 6 180 1933 0 0 230 /**</span>
 <span class="s0">* Returns true if the cache is in read-only mode.  Normally, the cache starts</span>
 <span class="s0">* in read-write mode.  It can put itself into read-only mode automatically if</span>
 <span class="s0">* it discovers that it does not have write access to the cache.</span>
 <span class="s0">*/ 1 4 this 3 2105  </span>
<span class="s0">138 0 0 7 181 2099 1069 0 782 /**</span>
 <span class="s0">* Looks up a file in the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is cacheable, then regardless of whether the file is found in</span>
 <span class="s0">* the cache or not, this returns a BamCacheRecord.  On the other hand, if the</span>
 <span class="s0">* file cannot be cached, returns NULL.</span>
 <span class="s0">*</span>
 <span class="s0">* If record-&gt;has_data() returns true, then the file was found in the cache,</span>
 <span class="s0">* and you may call record-&gt;extract_data() to get the object.  If</span>
 <span class="s0">* record-&gt;has_data() returns false, then the file was not found in the cache</span>
 <span class="s0">* or the cache was stale; and you should reload the source file (calling</span>
 <span class="s0">* record-&gt;add_dependent_file() for each file loaded, including the original</span>
 <span class="s0">* source file), and then call record-&gt;set_data() to record the resulting</span>
 <span class="s0">* loaded object; and finally, you should call store() to write the cached</span>
 <span class="s0">* record to disk.</span>
 <span class="s0">*/ 3 4 this 3 2104  15 source_filename 1 2100  15 cache_extension 1 2081  </span>
<span class="s0">139 0 0 6 182 1933 0 0 212 /**</span>
 <span class="s0">* Flushes a cache entry to disk.  You must have retrieved the cache record</span>
 <span class="s0">* via a prior call to lookup(), and then stored the data via</span>
 <span class="s0">* record-&gt;set_data().  Returns true on success, false on failure.</span>
 <span class="s0">*/ 2 4 this 3 2104  6 record 1 2099  </span>
<span class="s0">140 0 0 4 183 2065 0 0 92 /**</span>
 <span class="s0">* Flushes the index if enough time has elapsed since the index was last</span>
 <span class="s0">* flushed.</span>
 <span class="s0">*/ 1 4 this 3 2104  </span>
<span class="s0">141 0 0 4 184 2065 0 0 48 /**</span>
 <span class="s0">* Ensures the index is written to disk.</span>
 <span class="s0">*/ 1 4 this 3 2104  </span>
<span class="s0">142 0 0 4 185 2065 0 0 63 /**</span>
 <span class="s0">* Writes the contents of the index to standard output.</span>
 <span class="s0">*/ 3 4 this 3 2105  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">143 0 0 6 186 2104 0 0 124 /**</span>
 <span class="s0">* Returns a pointer to the global BamCache object, which is used</span>
 <span class="s0">* automatically by the ModelPool and TexturePool.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">144 0 0 4 187 2065 0 0 84 /**</span>
 <span class="s0">* If there is a global BamCache object, calls consider_flush_index() on it.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">145 0 0 4 188 2065 0 0 75 /**</span>
 <span class="s0">* If there is a global BamCache object, calls flush_index() on it.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">146 0 0 7 202 2108 1118 0 0 0 </span>
<span class="s0">147 0 0 15 202 2108 1118 0 0 1 6 param0 0 2109  </span>
<span class="s0">148 0 0 15 207 2112 1129 0 0 1 6 param0 0 2111  </span>
<span class="s0">149 0 0 23 207 2112 1129 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 flags 5 1932  </span>
<span class="s0">150 0 0 23 207 2112 1129 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 5 flags 1 1932  13 texture_flags 1 1932  </span>
<span class="s0">151 0 0 4 208 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2112  5 flags 1 1932  </span>
<span class="s0">152 0 0 6 209 1932 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 2111  </span>
<span class="s0">153 0 0 4 211 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2112  5 flags 1 1932  </span>
<span class="s0">154 0 0 6 212 1932 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 2111  </span>
<span class="s0">155 0 0 4 213 2065 0 0 459 /**</span>
 <span class="s0">* Specifies the expected number of views to load for the texture.  This is</span>
 <span class="s0">* ignored unless TF_multiview is included in texture_flags.  This must be</span>
 <span class="s0">* specified when loading a 3-d multiview texture or 2-d texture array, in</span>
 <span class="s0">* which case it is used to differentiate z levels from separate views; it</span>
 <span class="s0">* may be zero in the case of 2-d textures or cube maps, in which case the</span>
 <span class="s0">* number of views can be inferred from the number of images found on disk.</span>
 <span class="s0">*/ 2 4 this 3 2112  9 num_views 1 1932  </span>
<span class="s0">156 0 0 6 214 1932 0 0 39 /**</span>
 <span class="s0">* See set_texture_num_views().</span>
 <span class="s0">*/ 1 4 this 3 2111  </span>
<span class="s0">157 0 0 4 217 2065 0 0 209 /**</span>
 <span class="s0">* Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a</span>
 <span class="s0">* texture is scaled from disk when it is subsequently loaded.  Set it to</span>
 <span class="s0">* ATS_unspecified to restore the default behavior.</span>
 <span class="s0">*/ 2 4 this 3 2112  5 scale 1 1934  </span>
<span class="s0">158 0 0 6 218 1934 0 0 40 /**</span>
 <span class="s0">* See set_auto_texture_scale().</span>
 <span class="s0">*/ 1 4 this 3 2111  </span>
<span class="s0">159 0 0 4 220 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2111  3 out 1 2077  </span>
<span class="s0">160 0 0 7 223 2090 1131 0 38 // The primary interface for a caller. 1 6 source 5 1958  </span>
<span class="s0">161 0 0 4 225 2065 0 0 142 /**</span>
 <span class="s0">* Changes the source of future datagrams for this BamReader.  This also</span>
 <span class="s0">* implicitly calls init() if it has not already been called.</span>
 <span class="s0">*/ 2 4 this 3 2090  6 source 1 1958  </span>
<span class="s0">162 0 0 6 226 1958 0 0 100 /**</span>
 <span class="s0">* Returns the current source of the BamReader as set by set_source() or the</span>
 <span class="s0">* constructor.</span>
 <span class="s0">*/ 1 4 this 3 2090  </span>
<span class="s0">163 0 0 6 227 1933 0 0 210 /**</span>
 <span class="s0">* Initializes the BamReader prior to reading any objects from its source.</span>
 <span class="s0">* This includes reading the Bam header.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns true if the BamReader successfully initialized, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 2090  </span>
<span class="s0">164 0 0 4 228 2065 0 0 1007 /**</span>
 <span class="s0">* Associates an arbitrary block of data with the indicated object (or NULL),</span>
 <span class="s0">* and the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* This is intended to provide a place for temporary storage for objects</span>
 <span class="s0">* reading themselves from the bam file.  To use it, inherit from</span>
 <span class="s0">* BamReader::AuxData and store whatever data you like there.  Then associate</span>
 <span class="s0">* your AuxData with the object as it is being read with set_aux_data().  You</span>
 <span class="s0">* may later set the aux data to NULL to remove it; or it will automatically</span>
 <span class="s0">* be removed (and deleted) after finalize() is called for the object in</span>
 <span class="s0">* question.</span>
 <span class="s0">*</span>
 <span class="s0">* If the TypedWritable pointer is NULL, the the aux data is stored globally</span>
 <span class="s0">* for the BamReader in general.  This pointer is available to any bam</span>
 <span class="s0">* objects, and will not be automatically removed until the BamReader itself</span>
 <span class="s0">* destructs.</span>
 <span class="s0">*</span>
 <span class="s0">* In either case, the name is just an arbitrary user-defined key.  If there</span>
 <span class="s0">* is already a data pointer stored for the obj/name pair, that data pointer</span>
 <span class="s0">* will be replaced (and deleted).</span>
 <span class="s0">*/ 4 4 this 3 2090  3 obj 1 1948  4 name 1 2081  4 data 1 2113  </span>
<span class="s0">165 0 0 7 229 2113 0 0 173 /**</span>
 <span class="s0">* Returns the pointer previously associated with the bam reader by a previous</span>
 <span class="s0">* call to set_aux_data(), or NULL if data with the indicated key has not been</span>
 <span class="s0">* set.</span>
 <span class="s0">*/ 3 4 this 3 2115  3 obj 1 1948  4 name 1 2081  </span>
<span class="s0">166 0 0 6 230 2100 0 0 199 /**</span>
 <span class="s0">* If a BAM is a file, then the BamReader should contain the name of the file.</span>
 <span class="s0">* This enables the reader to interpret pathnames in the BAM as relative to</span>
 <span class="s0">* the directory containing the BAM.</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">167 0 0 6 231 2111 0 0 98 /**</span>
 <span class="s0">* Returns the LoaderOptions passed to the loader when the model was</span>
 <span class="s0">* requested, if any.</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">168 0 0 4 232 2065 0 0 58 /**</span>
 <span class="s0">* Specifies the LoaderOptions for this BamReader.</span>
 <span class="s0">*/ 2 4 this 3 2090  7 options 1 2111  </span>
<span class="s0">169 0 0 6 233 1948 0 0 1059 /**</span>
 <span class="s0">* Reads a single object from the Bam file.  If the object type is known, a</span>
 <span class="s0">* new object of the appropriate type is created and returned; otherwise, NULL</span>
 <span class="s0">* is returned.  NULL is also returned when the end of the file is reached.</span>
 <span class="s0">* is_eof() may be called to differentiate between these two cases.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be called repeatedly to extract out all the objects in the Bam</span>
 <span class="s0">* file, but typically (especially for scene graph files, indicated with the</span>
 <span class="s0">* .bam extension), only one object is retrieved directly from the Bam file:</span>
 <span class="s0">* the root of the scene graph.  The remaining objects will all be retrieved</span>
 <span class="s0">* recursively by the first object.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the object returned may not yet be complete.  In particular, some</span>
 <span class="s0">* of its pointers may not be filled in; you must call resolve() to fill in</span>
 <span class="s0">* all the available pointers before you can safely use any objects returned</span>
 <span class="s0">* by read_object().</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of read_object() requires the caller to know what type of</span>
 <span class="s0">* object it has received in order to properly manage the reference counts.</span>
 <span class="s0">*/ 1 4 this 3 2090  </span>
<span class="s0">170 0 0 6 234 1933 0 0 138 /**</span>
 <span class="s0">* Returns true if the reader has reached end-of-file, false otherwise.  This</span>
 <span class="s0">* call is only valid after a call to read_object().</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">171 0 0 6 235 1933 0 0 565 /**</span>
 <span class="s0">* This may be called at any time during processing of the Bam file to resolve</span>
 <span class="s0">* all the known pointers so far.  It is usually called at the end of the</span>
 <span class="s0">* processing, after all objects have been read, which is generally the best</span>
 <span class="s0">* time to call it.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called at least once after reading a particular object via</span>
 <span class="s0">* get_object() in order to validate that object.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if all objects have been resolved, or false if</span>
 <span class="s0">* some objects are still outstanding (in which case you will need to call</span>
 <span class="s0">* resolve() again later).</span>
 <span class="s0">*/ 1 4 this 3 2090  </span>
<span class="s0">172 0 0 6 236 1933 0 0 406 /**</span>
 <span class="s0">* Indicates that an object recently read from the bam stream should be</span>
 <span class="s0">* replaced with a new object.  Any future occurrences of the original object</span>
 <span class="s0">* in the stream will henceforth return the new object instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the replacement was successfully made, or false</span>
 <span class="s0">* if the object was not read from the stream (or if change_pointer had</span>
 <span class="s0">* already been called on it).</span>
 <span class="s0">*/ 3 4 this 3 2090  12 orig_pointer 1 2091  11 new_pointer 1 2091  </span>
<span class="s0">173 0 0 6 237 1932 0 0 81 /**</span>
 <span class="s0">* Returns the major version number of the Bam file currently being read.</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">174 0 0 6 238 1932 0 0 81 /**</span>
 <span class="s0">* Returns the minor version number of the Bam file currently being read.</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">175 0 0 6 239 1951 0 0 254 /**</span>
 <span class="s0">* Returns the endian preference indicated by the Bam file currently being</span>
 <span class="s0">* read.  This does not imply that every number is stored using the indicated</span>
 <span class="s0">* convention, but individual objects may choose to respect this flag when</span>
 <span class="s0">* recording data.</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">176 0 0 6 240 1933 0 0 220 /**</span>
 <span class="s0">* Returns true if the file stores all &quot;standard&quot; floats as 64-bit doubles, or</span>
 <span class="s0">* false if they are 32-bit floats.  This is determined by the compilation</span>
 <span class="s0">* flags of the version of Panda that generated this file.</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">177 0 0 6 241 1932 0 0 174 /**</span>
 <span class="s0">* Returns the major version number of Bam files supported by the current code</span>
 <span class="s0">* base.  This must match get_file_major_ver() in order to successfully read a</span>
 <span class="s0">* file.</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">178 0 0 6 242 1932 0 0 184 /**</span>
 <span class="s0">* Returns the minor version number of Bam files supported by the current code</span>
 <span class="s0">* base.  This must match or exceed get_file_minor_ver() in order to</span>
 <span class="s0">* successfully read a file.</span>
 <span class="s0">*/ 1 4 this 3 2115  </span>
<span class="s0">179 0 0 38 243 1961 0 0 0 1 4 this 3 2115  </span>
<span class="s0">180 0 0 36 256 2065 0 0 0 2 6 handle 1 2079  4 func 1 1961  </span>
<span class="s0">181 0 0 15 258 2094 1153 0 0 1 6 param0 0 2117  </span>
<span class="s0">182 0 0 7 258 2094 1153 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 6 target 5 1965  </span>
<span class="s0">183 0 0 4 260 2065 0 0 153 /**</span>
 <span class="s0">* Changes the destination of future datagrams written by the BamWriter.  This</span>
 <span class="s0">* also implicitly calls init() if it has not already been called.</span>
 <span class="s0">*/ 2 4 this 3 2094  6 target 1 1965  </span>
<span class="s0">184 0 0 6 261 1965 0 0 100 /**</span>
 <span class="s0">* Returns the current target of the BamWriter as set by set_target() or the</span>
 <span class="s0">* constructor.</span>
 <span class="s0">*/ 1 4 this 3 2094  </span>
<span class="s0">185 0 0 6 262 1933 0 0 220 /**</span>
 <span class="s0">* Initializes the BamWriter prior to writing any objects to its output</span>
 <span class="s0">* stream.  This includes writing out the Bam header.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns true if the BamWriter successfully initialized, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 2094  </span>
<span class="s0">186 0 0 6 263 2100 0 0 197 /**</span>
 <span class="s0">* If a BAM is a file, then the BamWriter should contain the name of the file.</span>
 <span class="s0">* This enables the writer to convert pathnames in the BAM to relative to the</span>
 <span class="s0">* directory containing the BAM.</span>
 <span class="s0">*/ 1 4 this 3 2117  </span>
<span class="s0">187 0 0 6 264 1933 0 0 736 /**</span>
 <span class="s0">* Writes a single object to the Bam file, so that the</span>
 <span class="s0">* BamReader::read_object() can later correctly restore the object and all its</span>
 <span class="s0">* pointers.</span>
 <span class="s0">*</span>
 <span class="s0">* This implicitly also writes any additional objects this object references</span>
 <span class="s0">* (if they haven't already been written), so that pointers may be fully</span>
 <span class="s0">* resolved.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be called repeatedly to write a sequence of objects to the Bam</span>
 <span class="s0">* file, but typically (especially for scene graph files, indicated with the</span>
 <span class="s0">* .bam extension), only one object is written directly from the Bam file: the</span>
 <span class="s0">* root of the scene graph.  The remaining objects will all be written</span>
 <span class="s0">* recursively by the first object.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the object is successfully written, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 2094  3 obj 1 2091  </span>
<span class="s0">188 0 0 6 265 1933 0 0 170 /**</span>
 <span class="s0">* Returns true if the object has previously been written (or at least</span>
 <span class="s0">* requested to be written) to the bam file, or false if we've never heard of</span>
 <span class="s0">* it before.</span>
 <span class="s0">*/ 2 4 this 3 2117  3 obj 1 2091  </span>
<span class="s0">189 0 0 4 266 2065 0 0 85 /**</span>
 <span class="s0">* Ensures that all data written thus far is manifested on the output stream.</span>
 <span class="s0">*/ 1 4 this 3 2094  </span>
<span class="s0">190 0 0 6 267 1932 0 0 84 /**</span>
 <span class="s0">* Returns the major version number of the Bam file currently being written.</span>
 <span class="s0">*/ 1 4 this 3 2117  </span>
<span class="s0">191 0 0 6 268 1932 0 0 84 /**</span>
 <span class="s0">* Returns the minor version number of the Bam file currently being written.</span>
 <span class="s0">*/ 1 4 this 3 2117  </span>
<span class="s0">192 0 0 4 269 2065 0 0 232 /**</span>
 <span class="s0">* Changes the minor .bam version to write.  This should be called before</span>
 <span class="s0">* init().  Each Panda version has only a fairly narrow range of versions it</span>
 <span class="s0">* is able to write; consult the .bam documentation for more information.</span>
 <span class="s0">*/ 2 4 this 3 2094  9 minor_ver 1 1932  </span>
<span class="s0">193 0 0 6 270 1951 0 0 257 /**</span>
 <span class="s0">* Returns the endian preference indicated by the Bam file currently being</span>
 <span class="s0">* written.  This does not imply that every number is stored using the</span>
 <span class="s0">* indicated convention, but individual objects may choose to respect this</span>
 <span class="s0">* flag when recording data.</span>
 <span class="s0">*/ 1 4 this 3 2117  </span>
<span class="s0">194 0 0 6 271 1933 0 0 248 /**</span>
 <span class="s0">* Returns true if the file will store all &quot;standard&quot; floats as 64-bit</span>
 <span class="s0">* doubles, or false if they are 32-bit floats.  This isn't runtime settable;</span>
 <span class="s0">* it's based on the compilation flags of the version of Panda that generated</span>
 <span class="s0">* this file.</span>
 <span class="s0">*/ 1 4 this 3 2117  </span>
<span class="s0">195 0 0 6 272 1953 0 0 196 /**</span>
 <span class="s0">* Returns the BamTextureMode preference indicated by the Bam file currently</span>
 <span class="s0">* being written.  Texture objects written to this Bam file will be encoded</span>
 <span class="s0">* according to the specified mode.</span>
 <span class="s0">*/ 1 4 this 3 2117  </span>
<span class="s0">196 0 0 4 273 2065 0 0 187 /**</span>
 <span class="s0">* Changes the BamTextureMode preference for the Bam file currently being</span>
 <span class="s0">* written.  Texture objects written to this Bam file will be encoded</span>
 <span class="s0">* according to the specified mode.</span>
 <span class="s0">*/ 2 4 this 3 2094  17 file_texture_mode 1 1953  </span>
<span class="s0">197 0 0 6 274 1948 0 0 165 /**</span>
 <span class="s0">* Returns the root node of the part of the scene graph we are currently</span>
 <span class="s0">* writing out.  This is used for determining what to make NodePaths relative</span>
 <span class="s0">* to.</span>
 <span class="s0">*/ 1 4 this 3 2117  </span>
<span class="s0">198 0 0 4 275 2065 0 0 160 /**</span>
 <span class="s0">* Sets the root node of the part of the scene graph we are currently writing</span>
 <span class="s0">* out.  NodePaths written to this bam file will be relative to this node.</span>
 <span class="s0">*/ 2 4 this 3 2094  9 root_node 1 1948  </span>
<span class="s0">199 0 0 7 285 2119 1233 0 0 0 </span>
<span class="s0">200 0 0 15 285 2119 1233 0 0 1 6 param0 0 2120  </span>
<span class="s0">201 0 0 23 285 2119 1233 0 0 1 10 init_value 1 2122  </span>
<span class="s0">202 0 0 7 286 2119 1233 0 0 0 </span>
<span class="s0">203 0 0 7 287 2119 1233 0 0 0 </span>
<span class="s0">204 0 0 7 288 2119 1233 0 0 1 7 on_bits 1 1932  </span>
<span class="s0">205 0 0 7 289 2119 1233 0 0 1 5 index 1 1932  </span>
<span class="s0">206 0 0 7 290 2119 1233 0 0 2 7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">207 0 0 6 291 1933 0 0 0 0 </span>
<span class="s0">208 0 0 6 292 1932 0 0 0 0 </span>
<span class="s0">209 0 0 6 293 1932 0 0 0 1 4 this 3 2120  </span>
<span class="s0">210 0 0 6 294 1933 0 0 0 2 4 this 3 2120  5 index 1 1932  </span>
<span class="s0">211 0 0 4 295 2065 0 0 0 2 4 this 3 2119  5 index 1 1932  </span>
<span class="s0">212 0 0 4 296 2065 0 0 0 2 4 this 3 2119  5 index 1 1932  </span>
<span class="s0">213 0 0 4 297 2065 0 0 0 3 4 this 3 2119  5 index 1 1932  5 value 1 1933  </span>
<span class="s0">214 0 0 6 298 1933 0 0 0 1 4 this 3 2120  </span>
<span class="s0">215 0 0 6 299 1933 0 0 0 1 4 this 3 2120  </span>
<span class="s0">216 0 0 6 300 2122 0 0 0 3 4 this 3 2120  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">217 0 0 4 301 2065 0 0 0 4 4 this 3 2119  5 value 1 2122  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">218 0 0 6 302 1933 0 0 0 3 4 this 3 2120  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">219 0 0 6 303 1933 0 0 0 3 4 this 3 2120  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">220 0 0 4 304 2065 0 0 0 3 4 this 3 2119  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">221 0 0 4 305 2065 0 0 0 3 4 this 3 2119  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">222 0 0 4 306 2065 0 0 0 4 4 this 3 2119  5 value 1 1933  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">223 0 0 6 307 2122 0 0 0 1 4 this 3 2120  </span>
<span class="s0">224 0 0 4 308 2065 0 0 0 2 4 this 3 2119  5 value 1 2122  </span>
<span class="s0">225 0 0 6 309 1932 0 0 0 1 4 this 3 2120  </span>
<span class="s0">226 0 0 6 310 1932 0 0 0 1 4 this 3 2120  </span>
<span class="s0">227 0 0 6 311 1932 0 0 0 1 4 this 3 2120  </span>
<span class="s0">228 0 0 6 312 1932 0 0 0 1 4 this 3 2120  </span>
<span class="s0">229 0 0 6 313 1932 0 0 0 1 4 this 3 2120  </span>
<span class="s0">230 0 0 6 314 1932 0 0 0 1 4 this 3 2120  </span>
<span class="s0">231 0 0 6 315 1932 0 0 0 2 4 this 3 2120  7 low_bit 1 1932  </span>
<span class="s0">232 0 0 4 316 2065 0 0 0 1 4 this 3 2119  </span>
<span class="s0">233 0 0 6 317 1933 0 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">234 0 0 4 318 2065 0 0 0 1 4 this 3 2119  </span>
<span class="s0">235 0 0 4 319 2065 0 0 0 2 4 this 3 2120  3 out 1 2077  </span>
<span class="s0">236 0 0 4 320 2065 0 0 0 3 4 this 3 2120  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">237 0 0 4 321 2065 0 0 0 3 4 this 3 2120  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">238 0 0 4 322 2065 0 0 0 3 4 this 3 2120  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">239 0 0 6 323 1933 0 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">240 0 0 6 324 1933 0 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">241 0 0 6 325 1933 0 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">242 0 0 6 326 1932 0 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">243 0 0 7 327 2119 1233 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">244 0 0 7 328 2119 1233 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">245 0 0 7 329 2119 1233 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">246 0 0 7 330 2119 1233 0 0 1 4 this 3 2120  </span>
<span class="s0">247 0 0 7 331 2119 1233 0 0 2 4 this 3 2120  5 shift 1 1932  </span>
<span class="s0">248 0 0 7 332 2119 1233 0 0 2 4 this 3 2120  5 shift 1 1932  </span>
<span class="s0">249 0 0 6 333 2119 0 0 0 2 4 this 3 2119  5 other 1 2120  </span>
<span class="s0">250 0 0 6 334 2119 0 0 0 2 4 this 3 2119  5 other 1 2120  </span>
<span class="s0">251 0 0 6 335 2119 0 0 0 2 4 this 3 2119  5 other 1 2120  </span>
<span class="s0">252 0 0 6 336 2119 0 0 0 2 4 this 3 2119  5 shift 1 1932  </span>
<span class="s0">253 0 0 6 337 2119 0 0 0 2 4 this 3 2119  5 shift 1 1932  </span>
<span class="s0">254 0 0 4 338 2065 0 0 0 1 4 this 3 2119  </span>
<span class="s0">255 0 0 4 339 2065 0 0 0 1 4 this 3 2119  </span>
<span class="s0">256 0 0 7 340 2119 1233 0 0 1 4 this 3 2120  </span>
<span class="s0">257 0 0 7 341 2119 1233 0 0 1 4 this 3 2120  </span>
<span class="s0">258 0 0 7 342 2119 1233 0 0 1 4 this 3 2120  </span>
<span class="s0">259 0 0 7 342 2119 1233 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">260 0 0 7 342 2119 1233 0 0 2 4 this 3 2120  5 index 1 1932  </span>
<span class="s0">261 0 0 7 343 2119 1233 0 0 1 4 this 3 2120  </span>
<span class="s0">262 0 0 7 343 2119 1233 0 0 2 4 this 3 2120  5 other 1 2120  </span>
<span class="s0">263 0 0 7 343 2119 1233 0 0 2 4 this 3 2120  5 index 1 1932  </span>
<span class="s0">264 0 0 6 344 1932 0 0 0 1 4 this 3 2120  </span>
<span class="s0">265 0 0 6 345 1933 0 0 0 1 4 this 3 2120  </span>
<span class="s0">266 0 0 38 346 1961 0 0 0 1 4 this 3 2120  </span>
<span class="s0">267 0 0 7 347 2079 0 0 0 0 </span>
<span class="s0">268 0 0 7 351 2123 1297 0 0 0 </span>
<span class="s0">269 0 0 15 351 2123 1297 0 0 1 6 param0 0 2124  </span>
<span class="s0">270 0 0 23 351 2123 1297 0 0 1 10 init_value 1 2126  </span>
<span class="s0">271 0 0 7 352 2123 1297 0 0 0 </span>
<span class="s0">272 0 0 7 353 2123 1297 0 0 0 </span>
<span class="s0">273 0 0 7 354 2123 1297 0 0 1 7 on_bits 1 1932  </span>
<span class="s0">274 0 0 7 355 2123 1297 0 0 1 5 index 1 1932  </span>
<span class="s0">275 0 0 7 356 2123 1297 0 0 2 7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">276 0 0 6 357 1933 0 0 0 0 </span>
<span class="s0">277 0 0 6 358 1932 0 0 0 0 </span>
<span class="s0">278 0 0 6 359 1932 0 0 0 1 4 this 3 2124  </span>
<span class="s0">279 0 0 6 360 1933 0 0 0 2 4 this 3 2124  5 index 1 1932  </span>
<span class="s0">280 0 0 4 361 2065 0 0 0 2 4 this 3 2123  5 index 1 1932  </span>
<span class="s0">281 0 0 4 362 2065 0 0 0 2 4 this 3 2123  5 index 1 1932  </span>
<span class="s0">282 0 0 4 363 2065 0 0 0 3 4 this 3 2123  5 index 1 1932  5 value 1 1933  </span>
<span class="s0">283 0 0 6 364 1933 0 0 0 1 4 this 3 2124  </span>
<span class="s0">284 0 0 6 365 1933 0 0 0 1 4 this 3 2124  </span>
<span class="s0">285 0 0 6 366 2126 0 0 0 3 4 this 3 2124  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">286 0 0 4 367 2065 0 0 0 4 4 this 3 2123  5 value 1 2126  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">287 0 0 6 368 1933 0 0 0 3 4 this 3 2124  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">288 0 0 6 369 1933 0 0 0 3 4 this 3 2124  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">289 0 0 4 370 2065 0 0 0 3 4 this 3 2123  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">290 0 0 4 371 2065 0 0 0 3 4 this 3 2123  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">291 0 0 4 372 2065 0 0 0 4 4 this 3 2123  5 value 1 1933  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">292 0 0 6 373 2126 0 0 0 1 4 this 3 2124  </span>
<span class="s0">293 0 0 4 374 2065 0 0 0 2 4 this 3 2123  5 value 1 2126  </span>
<span class="s0">294 0 0 6 375 1932 0 0 0 1 4 this 3 2124  </span>
<span class="s0">295 0 0 6 376 1932 0 0 0 1 4 this 3 2124  </span>
<span class="s0">296 0 0 6 377 1932 0 0 0 1 4 this 3 2124  </span>
<span class="s0">297 0 0 6 378 1932 0 0 0 1 4 this 3 2124  </span>
<span class="s0">298 0 0 6 379 1932 0 0 0 1 4 this 3 2124  </span>
<span class="s0">299 0 0 6 380 1932 0 0 0 1 4 this 3 2124  </span>
<span class="s0">300 0 0 6 381 1932 0 0 0 2 4 this 3 2124  7 low_bit 1 1932  </span>
<span class="s0">301 0 0 4 382 2065 0 0 0 1 4 this 3 2123  </span>
<span class="s0">302 0 0 6 383 1933 0 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">303 0 0 4 384 2065 0 0 0 1 4 this 3 2123  </span>
<span class="s0">304 0 0 4 385 2065 0 0 0 2 4 this 3 2124  3 out 1 2077  </span>
<span class="s0">305 0 0 4 386 2065 0 0 0 3 4 this 3 2124  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">306 0 0 4 387 2065 0 0 0 3 4 this 3 2124  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">307 0 0 4 388 2065 0 0 0 3 4 this 3 2124  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">308 0 0 6 389 1933 0 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">309 0 0 6 390 1933 0 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">310 0 0 6 391 1933 0 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">311 0 0 6 392 1932 0 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">312 0 0 7 393 2123 1297 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">313 0 0 7 394 2123 1297 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">314 0 0 7 395 2123 1297 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">315 0 0 7 396 2123 1297 0 0 1 4 this 3 2124  </span>
<span class="s0">316 0 0 7 397 2123 1297 0 0 2 4 this 3 2124  5 shift 1 1932  </span>
<span class="s0">317 0 0 7 398 2123 1297 0 0 2 4 this 3 2124  5 shift 1 1932  </span>
<span class="s0">318 0 0 6 399 2123 0 0 0 2 4 this 3 2123  5 other 1 2124  </span>
<span class="s0">319 0 0 6 400 2123 0 0 0 2 4 this 3 2123  5 other 1 2124  </span>
<span class="s0">320 0 0 6 401 2123 0 0 0 2 4 this 3 2123  5 other 1 2124  </span>
<span class="s0">321 0 0 6 402 2123 0 0 0 2 4 this 3 2123  5 shift 1 1932  </span>
<span class="s0">322 0 0 6 403 2123 0 0 0 2 4 this 3 2123  5 shift 1 1932  </span>
<span class="s0">323 0 0 4 404 2065 0 0 0 1 4 this 3 2123  </span>
<span class="s0">324 0 0 4 405 2065 0 0 0 1 4 this 3 2123  </span>
<span class="s0">325 0 0 7 406 2123 1297 0 0 1 4 this 3 2124  </span>
<span class="s0">326 0 0 7 407 2123 1297 0 0 1 4 this 3 2124  </span>
<span class="s0">327 0 0 7 408 2123 1297 0 0 1 4 this 3 2124  </span>
<span class="s0">328 0 0 7 408 2123 1297 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">329 0 0 7 408 2123 1297 0 0 2 4 this 3 2124  5 index 1 1932  </span>
<span class="s0">330 0 0 7 409 2123 1297 0 0 1 4 this 3 2124  </span>
<span class="s0">331 0 0 7 409 2123 1297 0 0 2 4 this 3 2124  5 other 1 2124  </span>
<span class="s0">332 0 0 7 409 2123 1297 0 0 2 4 this 3 2124  5 index 1 1932  </span>
<span class="s0">333 0 0 6 410 1932 0 0 0 1 4 this 3 2124  </span>
<span class="s0">334 0 0 6 411 1933 0 0 0 1 4 this 3 2124  </span>
<span class="s0">335 0 0 38 412 1961 0 0 0 1 4 this 3 2124  </span>
<span class="s0">336 0 0 7 413 2079 0 0 0 0 </span>
<span class="s0">337 0 0 7 417 2128 1361 0 0 0 </span>
<span class="s0">338 0 0 15 417 2128 1361 0 0 1 6 param0 0 2129  </span>
<span class="s0">339 0 0 23 417 2128 1361 0 0 1 10 init_value 1 2131  </span>
<span class="s0">340 0 0 7 418 2128 1361 0 0 0 </span>
<span class="s0">341 0 0 7 419 2128 1361 0 0 0 </span>
<span class="s0">342 0 0 7 420 2128 1361 0 0 1 7 on_bits 1 1932  </span>
<span class="s0">343 0 0 7 421 2128 1361 0 0 1 5 index 1 1932  </span>
<span class="s0">344 0 0 7 422 2128 1361 0 0 2 7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">345 0 0 6 423 1933 0 0 0 0 </span>
<span class="s0">346 0 0 6 424 1932 0 0 0 0 </span>
<span class="s0">347 0 0 6 425 1932 0 0 0 1 4 this 3 2129  </span>
<span class="s0">348 0 0 6 426 1933 0 0 0 2 4 this 3 2129  5 index 1 1932  </span>
<span class="s0">349 0 0 4 427 2065 0 0 0 2 4 this 3 2128  5 index 1 1932  </span>
<span class="s0">350 0 0 4 428 2065 0 0 0 2 4 this 3 2128  5 index 1 1932  </span>
<span class="s0">351 0 0 4 429 2065 0 0 0 3 4 this 3 2128  5 index 1 1932  5 value 1 1933  </span>
<span class="s0">352 0 0 6 430 1933 0 0 0 1 4 this 3 2129  </span>
<span class="s0">353 0 0 6 431 1933 0 0 0 1 4 this 3 2129  </span>
<span class="s0">354 0 0 6 432 2131 0 0 0 3 4 this 3 2129  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">355 0 0 4 433 2065 0 0 0 4 4 this 3 2128  5 value 1 2131  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">356 0 0 6 434 1933 0 0 0 3 4 this 3 2129  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">357 0 0 6 435 1933 0 0 0 3 4 this 3 2129  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">358 0 0 4 436 2065 0 0 0 3 4 this 3 2128  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">359 0 0 4 437 2065 0 0 0 3 4 this 3 2128  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">360 0 0 4 438 2065 0 0 0 4 4 this 3 2128  5 value 1 1933  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">361 0 0 6 439 2131 0 0 0 1 4 this 3 2129  </span>
<span class="s0">362 0 0 4 440 2065 0 0 0 2 4 this 3 2128  5 value 1 2131  </span>
<span class="s0">363 0 0 6 441 1932 0 0 0 1 4 this 3 2129  </span>
<span class="s0">364 0 0 6 442 1932 0 0 0 1 4 this 3 2129  </span>
<span class="s0">365 0 0 6 443 1932 0 0 0 1 4 this 3 2129  </span>
<span class="s0">366 0 0 6 444 1932 0 0 0 1 4 this 3 2129  </span>
<span class="s0">367 0 0 6 445 1932 0 0 0 1 4 this 3 2129  </span>
<span class="s0">368 0 0 6 446 1932 0 0 0 1 4 this 3 2129  </span>
<span class="s0">369 0 0 6 447 1932 0 0 0 2 4 this 3 2129  7 low_bit 1 1932  </span>
<span class="s0">370 0 0 4 448 2065 0 0 0 1 4 this 3 2128  </span>
<span class="s0">371 0 0 6 449 1933 0 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">372 0 0 4 450 2065 0 0 0 1 4 this 3 2128  </span>
<span class="s0">373 0 0 4 451 2065 0 0 0 2 4 this 3 2129  3 out 1 2077  </span>
<span class="s0">374 0 0 4 452 2065 0 0 0 3 4 this 3 2129  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">375 0 0 4 453 2065 0 0 0 3 4 this 3 2129  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">376 0 0 4 454 2065 0 0 0 3 4 this 3 2129  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">377 0 0 6 455 1933 0 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">378 0 0 6 456 1933 0 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">379 0 0 6 457 1933 0 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">380 0 0 6 458 1932 0 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">381 0 0 7 459 2128 1361 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">382 0 0 7 460 2128 1361 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">383 0 0 7 461 2128 1361 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">384 0 0 7 462 2128 1361 0 0 1 4 this 3 2129  </span>
<span class="s0">385 0 0 7 463 2128 1361 0 0 2 4 this 3 2129  5 shift 1 1932  </span>
<span class="s0">386 0 0 7 464 2128 1361 0 0 2 4 this 3 2129  5 shift 1 1932  </span>
<span class="s0">387 0 0 6 465 2128 0 0 0 2 4 this 3 2128  5 other 1 2129  </span>
<span class="s0">388 0 0 6 466 2128 0 0 0 2 4 this 3 2128  5 other 1 2129  </span>
<span class="s0">389 0 0 6 467 2128 0 0 0 2 4 this 3 2128  5 other 1 2129  </span>
<span class="s0">390 0 0 6 468 2128 0 0 0 2 4 this 3 2128  5 shift 1 1932  </span>
<span class="s0">391 0 0 6 469 2128 0 0 0 2 4 this 3 2128  5 shift 1 1932  </span>
<span class="s0">392 0 0 4 470 2065 0 0 0 1 4 this 3 2128  </span>
<span class="s0">393 0 0 4 471 2065 0 0 0 1 4 this 3 2128  </span>
<span class="s0">394 0 0 7 472 2128 1361 0 0 1 4 this 3 2129  </span>
<span class="s0">395 0 0 7 473 2128 1361 0 0 1 4 this 3 2129  </span>
<span class="s0">396 0 0 7 474 2128 1361 0 0 1 4 this 3 2129  </span>
<span class="s0">397 0 0 7 474 2128 1361 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">398 0 0 7 474 2128 1361 0 0 2 4 this 3 2129  5 index 1 1932  </span>
<span class="s0">399 0 0 7 475 2128 1361 0 0 1 4 this 3 2129  </span>
<span class="s0">400 0 0 7 475 2128 1361 0 0 2 4 this 3 2129  5 other 1 2129  </span>
<span class="s0">401 0 0 7 475 2128 1361 0 0 2 4 this 3 2129  5 index 1 1932  </span>
<span class="s0">402 0 0 6 476 1932 0 0 0 1 4 this 3 2129  </span>
<span class="s0">403 0 0 6 477 1933 0 0 0 1 4 this 3 2129  </span>
<span class="s0">404 0 0 38 478 1961 0 0 0 1 4 this 3 2129  </span>
<span class="s0">405 0 0 7 479 2079 0 0 0 0 </span>
<span class="s0">406 0 0 7 485 2132 1421 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">407 0 0 15 485 2132 1421 0 0 1 6 param0 0 2133  </span>
<span class="s0">408 0 0 23 485 2132 1421 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 init_value 1 2135  </span>
<span class="s0">409 0 0 23 485 2132 1421 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 from 1 2136  </span>
<span class="s0">410 0 0 7 486 2132 1421 0 69 /**</span>
 <span class="s0">* Returns a BitArray with an infinite array of bits, all on.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">411 0 0 7 487 2132 1421 0 53 /**</span>
 <span class="s0">* Returns a BitArray whose bits are all off.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">412 0 0 7 488 2132 1421 0 62 /**</span>
 <span class="s0">* Returns a BitArray whose lower on_bits bits are on.</span>
 <span class="s0">*/ 1 7 on_bits 1 1932  </span>
<span class="s0">413 0 0 7 489 2132 1421 0 61 /**</span>
 <span class="s0">* Returns a BitArray with only the indicated bit on.</span>
 <span class="s0">*/ 1 5 index 1 1932  </span>
<span class="s0">414 0 0 7 490 2132 1421 0 76 /**</span>
 <span class="s0">* Returns a BitArray whose size bits, beginning at low_bit, are on.</span>
 <span class="s0">*/ 2 7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">415 0 0 6 491 1933 0 0 0 0 </span>
<span class="s0">416 0 0 6 492 1932 0 0 0 0 </span>
<span class="s0">417 0 0 6 493 1932 0 0 0 0 </span>
<span class="s0">418 0 0 6 494 2138 0 0 300 /**</span>
 <span class="s0">* Returns the current number of possibly different bits in this array.  There</span>
 <span class="s0">* are actually an infinite number of bits, but every bit higher than this bit</span>
 <span class="s0">* will have the same value, either 0 or 1 (see get_highest_bits()).</span>
 <span class="s0">*</span>
 <span class="s0">* This number may grow and/or shrink automatically as needed.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">419 0 0 6 495 1933 0 0 191 /**</span>
 <span class="s0">* Returns true if the nth bit is set, false if it is cleared.  It is valid</span>
 <span class="s0">* for n to increase beyond get_num_bits(), but the return value</span>
 <span class="s0">* get_num_bits() will always be the same.</span>
 <span class="s0">*/ 2 4 this 3 2133  5 index 1 1932  </span>
<span class="s0">420 0 0 4 496 2065 0 0 97 /**</span>
 <span class="s0">* Sets the nth bit on.  If n &gt;= get_num_bits(), this automatically extends</span>
 <span class="s0">* the array.</span>
 <span class="s0">*/ 2 4 this 3 2132  5 index 1 1932  </span>
<span class="s0">421 0 0 4 497 2065 0 0 98 /**</span>
 <span class="s0">* Sets the nth bit off.  If n &gt;= get_num_bits(), this automatically extends</span>
 <span class="s0">* the array.</span>
 <span class="s0">*/ 2 4 this 3 2132  5 index 1 1932  </span>
<span class="s0">422 0 0 4 498 2065 0 0 84 /**</span>
 <span class="s0">* Sets the nth bit either on or off, according to the indicated bool value.</span>
 <span class="s0">*/ 3 4 this 3 2132  5 index 1 1932  5 value 1 1933  </span>
<span class="s0">423 0 0 6 499 1933 0 0 118 /**</span>
 <span class="s0">* Returns true if the infinite set of bits beyond get_num_bits() are all on,</span>
 <span class="s0">* or false of they are all off.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">424 0 0 6 500 1933 0 0 71 /**</span>
 <span class="s0">* Returns true if the entire bitmask is zero, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">425 0 0 6 501 1933 0 0 70 /**</span>
 <span class="s0">* Returns true if the entire bitmask is one, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">426 0 0 6 502 2135 0 0 187 /**</span>
 <span class="s0">* Returns a word that represents only the indicated range of bits within this</span>
 <span class="s0">* BitArray, shifted to the least-significant position.  size must be &lt;=</span>
 <span class="s0">* get_num_bits_per_word().</span>
 <span class="s0">*/ 3 4 this 3 2133  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">427 0 0 4 503 2065 0 0 92 /**</span>
 <span class="s0">* Stores the indicated word into the indicated range of bits with this</span>
 <span class="s0">* BitArray.</span>
 <span class="s0">*/ 4 4 this 3 2132  5 value 1 2135  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">428 0 0 6 504 1933 0 0 82 /**</span>
 <span class="s0">* Returns true if any bit in the indicated range is set, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 2133  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">429 0 0 6 505 1933 0 0 84 /**</span>
 <span class="s0">* Returns true if all bits in the indicated range are set, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 2133  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">430 0 0 4 506 2065 0 0 47 /**</span>
 <span class="s0">* Sets the indicated range of bits on.</span>
 <span class="s0">*/ 3 4 this 3 2132  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">431 0 0 4 507 2065 0 0 48 /**</span>
 <span class="s0">* Sets the indicated range of bits off.</span>
 <span class="s0">*/ 3 4 this 3 2132  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">432 0 0 4 508 2065 0 0 64 /**</span>
 <span class="s0">* Sets the indicated range of bits to either on or off.</span>
 <span class="s0">*/ 4 4 this 3 2132  5 value 1 1933  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">433 0 0 6 509 1932 0 0 127 /**</span>
 <span class="s0">* Returns the number of bits that are set to 1 in the array.  Returns -1 if</span>
 <span class="s0">* there are an infinite number of 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">434 0 0 6 510 1932 0 0 127 /**</span>
 <span class="s0">* Returns the number of bits that are set to 0 in the array.  Returns -1 if</span>
 <span class="s0">* there are an infinite number of 0 bits.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">435 0 0 6 511 1932 0 0 101 /**</span>
 <span class="s0">* Returns the index of the lowest 1 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">436 0 0 6 512 1932 0 0 101 /**</span>
 <span class="s0">* Returns the index of the lowest 0 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 0 bits.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">437 0 0 6 513 1932 0 0 143 /**</span>
 <span class="s0">* Returns the index of the highest 1 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 1 bits or if there an infinite number of 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">438 0 0 6 514 1932 0 0 143 /**</span>
 <span class="s0">* Returns the index of the highest 0 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 0 bits or if there an infinite number of 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">439 0 0 6 515 1932 0 0 287 /**</span>
 <span class="s0">* Returns the index of the next bit in the array, above low_bit, whose value</span>
 <span class="s0">* is different that the value of low_bit.  Returns low_bit again if all bits</span>
 <span class="s0">* higher than low_bit have the same value.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to quickly iterate through all of the bits in the array.</span>
 <span class="s0">*/ 2 4 this 3 2133  7 low_bit 1 1932  </span>
<span class="s0">440 0 0 6 516 2138 0 0 75 /**</span>
 <span class="s0">* Returns the number of possibly-unique words stored in the array.</span>
 <span class="s0">*/ 1 4 this 3 2133  </span>
<span class="s0">441 0 0 7 517 2140 0 0 175 /**</span>
 <span class="s0">* Returns the nth word in the array.  It is valid for n to be greater than</span>
 <span class="s0">* get_num_words(), but the return value beyond get_num_words() will always be</span>
 <span class="s0">* the same.</span>
 <span class="s0">*/ 2 4 this 3 2133  1 n 1 2138  </span>
<span class="s0">442 0 0 4 518 2065 0 0 113 /**</span>
 <span class="s0">* Replaces the nth word in the array.  If n &gt;= get_num_words(), this</span>
 <span class="s0">* automatically extends the array.</span>
 <span class="s0">*/ 3 4 this 3 2132  1 n 1 2138  5 value 1 2135  </span>
<span class="s0">443 0 0 4 519 2065 0 0 90 /**</span>
 <span class="s0">* Inverts all the bits in the BitArray.  This is equivalent to array =</span>
 <span class="s0">* ~array.</span>
 <span class="s0">*/ 1 4 this 3 2132  </span>
<span class="s0">444 0 0 6 520 1933 0 0 178 /**</span>
 <span class="s0">* Returns true if this BitArray has any &quot;one&quot; bits in common with the other</span>
 <span class="s0">* one, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is equivalent to (array &amp; other) != 0, but may be faster.</span>
 <span class="s0">*/ 2 4 this 3 2133  5 other 1 2133  </span>
<span class="s0">445 0 0 4 521 2065 0 0 49 /**</span>
 <span class="s0">* Sets all the bits in the BitArray off.</span>
 <span class="s0">*/ 1 4 this 3 2132  </span>
<span class="s0">446 0 0 4 522 2065 0 0 193 /**</span>
 <span class="s0">* Writes the BitArray out as a hex number.  For a BitArray, this is always</span>
 <span class="s0">* the same as output_hex(); it's too confusing for the output format to</span>
 <span class="s0">* change back and forth at runtime.</span>
 <span class="s0">*/ 2 4 this 3 2133  3 out 1 2077  </span>
<span class="s0">447 0 0 4 523 2065 0 0 83 /**</span>
 <span class="s0">* Writes the BitArray out as a binary number, with spaces every four bits.</span>
 <span class="s0">*/ 3 4 this 3 2133  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">448 0 0 4 524 2065 0 0 93 /**</span>
 <span class="s0">* Writes the BitArray out as a hexadecimal number, with spaces every four</span>
 <span class="s0">* digits.</span>
 <span class="s0">*/ 3 4 this 3 2133  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">449 0 0 4 525 2065 0 0 99 /**</span>
 <span class="s0">* Writes the BitArray out as a binary or a hex number, according to the</span>
 <span class="s0">* number of bits.</span>
 <span class="s0">*/ 3 4 this 3 2133  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">450 0 0 6 526 1933 0 0 0 2 4 this 3 2133  5 other 1 2133  </span>
<span class="s0">451 0 0 6 527 1933 0 0 0 2 4 this 3 2133  5 other 1 2133  </span>
<span class="s0">452 0 0 6 528 1933 0 0 0 2 4 this 3 2133  5 other 1 2133  </span>
<span class="s0">453 0 0 6 529 1932 0 0 233 /**</span>
 <span class="s0">* Returns a number less than zero if this BitArray sorts before the indicated</span>
 <span class="s0">* other BitArray, greater than zero if it sorts after, or 0 if they are</span>
 <span class="s0">* equivalent.  This is based on the same ordering defined by operator &lt;.</span>
 <span class="s0">*/ 2 4 this 3 2133  5 other 1 2133  </span>
<span class="s0">454 0 0 7 530 2132 1421 0 0 2 4 this 3 2133  5 other 1 2133  </span>
<span class="s0">455 0 0 7 531 2132 1421 0 0 2 4 this 3 2133  5 other 1 2133  </span>
<span class="s0">456 0 0 7 532 2132 1421 0 0 2 4 this 3 2133  5 other 1 2133  </span>
<span class="s0">457 0 0 7 533 2132 1421 0 0 1 4 this 3 2133  </span>
<span class="s0">458 0 0 7 534 2132 1421 0 0 2 4 this 3 2133  5 shift 1 1932  </span>
<span class="s0">459 0 0 7 535 2132 1421 0 0 2 4 this 3 2133  5 shift 1 1932  </span>
<span class="s0">460 0 0 6 536 2132 0 0 0 2 4 this 3 2132  5 other 1 2133  </span>
<span class="s0">461 0 0 6 537 2132 0 0 0 2 4 this 3 2132  5 other 1 2133  </span>
<span class="s0">462 0 0 6 538 2132 0 0 0 2 4 this 3 2132  5 other 1 2133  </span>
<span class="s0">463 0 0 6 539 2132 0 0 0 2 4 this 3 2132  5 shift 1 1932  </span>
<span class="s0">464 0 0 6 540 2132 0 0 0 2 4 this 3 2132  5 shift 1 1932  </span>
<span class="s0">465 0 0 38 541 1961 0 0 0 1 4 this 3 2133  </span>
<span class="s0">466 0 0 36 542 2065 0 0 0 2 4 this 3 2132  5 state 1 1961  </span>
<span class="s0">467 0 0 7 543 2079 0 0 0 0 </span>
<span class="s0">468 0 0 7 546 2141 1441 0 259 // The default constructor must do nothing, because we can't guarantee</span>
<span class="s0">// ordering of static initializers.  If the constructor tried to initialize</span>
<span class="s0">// its value, it  might happen after the value had already been set</span>
<span class="s0">// previously by another static initializer! 0 </span>
<span class="s0">469 0 0 15 546 2141 1441 0 0 1 6 param0 0 2142  </span>
<span class="s0">470 0 0 23 546 2141 1441 0 154 /**</span>
 <span class="s0">* Constructs a ButtonHandle with the corresponding index number, which may</span>
 <span class="s0">* have been returned by an earlier call to ButtonHandle::get_index().</span>
 <span class="s0">*/ 1 5 index 1 1932  </span>
<span class="s0">471 0 0 23 546 2141 1441 0 341 /**</span>
 <span class="s0">* Constructs a ButtonHandle with the corresponding name, which is looked up</span>
 <span class="s0">* in the ButtonRegistry.  This exists for the purpose of being able to</span>
 <span class="s0">* automatically coerce a string into a ButtonHandle; for most purposes, you</span>
 <span class="s0">* should use either the static KeyboardButton/MouseButton getters or</span>
 <span class="s0">* ButtonRegistry::register_button().</span>
 <span class="s0">*/ 1 4 name 1 2081  </span>
<span class="s0">472 0 0 6 547 1933 0 0 0 2 4 this 3 2142  5 other 1 2142  </span>
<span class="s0">473 0 0 6 548 1933 0 0 0 2 4 this 3 2142  5 other 1 2142  </span>
<span class="s0">474 0 0 6 549 1933 0 0 0 2 4 this 3 2142  5 other 1 2142  </span>
<span class="s0">475 0 0 6 550 1933 0 0 0 2 4 this 3 2142  5 other 1 2142  </span>
<span class="s0">476 0 0 6 551 1933 0 0 0 2 4 this 3 2142  5 other 1 2142  </span>
<span class="s0">477 0 0 6 552 1933 0 0 0 2 4 this 3 2142  5 other 1 2142  </span>
<span class="s0">478 0 0 6 553 1932 0 0 209 /**</span>
 <span class="s0">* Sorts ButtonHandles arbitrarily (according to &lt;, &gt;, etc.).  Returns a</span>
 <span class="s0">* number less than 0 if this type sorts before the other one, greater than</span>
 <span class="s0">* zero if it sorts after, 0 if they are equivalent.</span>
 <span class="s0">*/ 2 4 this 3 2142  5 other 1 2142  </span>
<span class="s0">479 0 0 6 554 2138 0 0 54 /**</span>
 <span class="s0">* Returns a hash code suitable for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 2142  </span>
<span class="s0">480 0 0 6 555 2081 0 0 42 /**</span>
 <span class="s0">* Returns the name of the button.</span>
 <span class="s0">*/ 1 4 this 3 2142  </span>
<span class="s0">481 0 0 6 556 1933 0 0 121 /**</span>
 <span class="s0">* Returns true if the button was created with an ASCII equivalent code (e.g.</span>
 <span class="s0">* for a standard keyboard button).</span>
 <span class="s0">*/ 1 4 this 3 2142  </span>
<span class="s0">482 0 0 6 557 1979 0 0 109 /**</span>
 <span class="s0">* Returns the character code associated with the button, or '\0' if no ASCII</span>
 <span class="s0">* code was associated.</span>
 <span class="s0">*/ 1 4 this 3 2142  </span>
<span class="s0">483 0 0 7 558 2141 1441 0 373 /**</span>
 <span class="s0">* Returns the alias (alternate name) associated with the button, if any, or</span>
 <span class="s0">* ButtonHandle::none() if the button has no alias.</span>
 <span class="s0">*</span>
 <span class="s0">* Each button is allowed to have one alias, and multiple different buttons</span>
 <span class="s0">* can refer to the same alias.  The alias should be the more general name for</span>
 <span class="s0">* the button, for instance, shift is an alias for lshift, but not vice-versa.</span>
 <span class="s0">*/ 1 4 this 3 2142  </span>
<span class="s0">484 0 0 6 559 1933 0 0 263 /**</span>
 <span class="s0">* Returns true if this ButtonHandle is the same as the other one, or if the</span>
 <span class="s0">* other one is an alias for this one.  (Does not return true if this button</span>
 <span class="s0">* is an alias for the other one, however.)</span>
 <span class="s0">*</span>
 <span class="s0">* This is a more general comparison than operator ==.</span>
 <span class="s0">*/ 2 4 this 3 2142  5 other 1 2142  </span>
<span class="s0">485 0 0 6 560 1932 0 0 363 /**</span>
 <span class="s0">* Returns the integer index associated with this ButtonHandle.  Each</span>
 <span class="s0">* different ButtonHandle will have a different index.  However, you probably</span>
 <span class="s0">* shouldn't be using this method; you should just treat the ButtonHandles as</span>
 <span class="s0">* opaque classes.  This is provided for the convenience of non-C++ scripting</span>
 <span class="s0">* languages to build a hashtable of ButtonHandles.</span>
 <span class="s0">*/ 1 4 this 3 2142  </span>
<span class="s0">486 0 0 4 561 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2142  3 out 1 2077  </span>
<span class="s0">487 0 0 7 562 2141 1441 0 0 0 </span>
<span class="s0">488 0 0 7 571 2079 0 0 0 0 </span>
<span class="s0">489 0 0 6 563 1933 0 0 0 1 4 this 3 2142  </span>
<span class="s0">490 0 0 15 579 2146 1448 0 0 1 6 param0 0 2144  </span>
<span class="s0">491 0 0 7 574 2141 1441 0 150 /**</span>
 <span class="s0">* Finds a ButtonHandle in the registry matching the indicated name.  If there</span>
 <span class="s0">* is no such ButtonHandle, registers a new one and returns it.</span>
 <span class="s0">*/ 2 4 this 3 2146  4 name 1 2081  </span>
<span class="s0">492 0 0 7 575 2141 1441 0 144 /**</span>
 <span class="s0">* Finds a ButtonHandle in the registry matching the indicated name.  If there</span>
 <span class="s0">* is no such ButtonHandle, returns ButtonHandle::none().</span>
 <span class="s0">*/ 2 4 this 3 2146  4 name 1 2081  </span>
<span class="s0">493 0 0 7 576 2141 1441 0 169 /**</span>
 <span class="s0">* Finds a ButtonHandle in the registry matching the indicated ASCII</span>
 <span class="s0">* equivalent character.  If there is no such ButtonHandle, returns</span>
 <span class="s0">* ButtonHandle::none().</span>
 <span class="s0">*/ 2 4 this 3 2144  16 ascii_equivalent 1 1979  </span>
<span class="s0">494 0 0 4 577 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2144  3 out 1 2077  </span>
<span class="s0">495 0 0 6 578 2146 0 0 67 /**</span>
 <span class="s0">* Returns the pointer to the global ButtonRegistry object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">496 0 0 7 590 2147 1457 0 0 0 </span>
<span class="s0">497 0 0 15 590 2147 1457 0 0 1 6 param0 0 2148  </span>
<span class="s0">498 0 0 6 583 2138 0 0 76 /**</span>
 <span class="s0">* Returns the number of buttons that this button mapping specifies.</span>
 <span class="s0">*/ 1 4 this 3 2148  </span>
<span class="s0">499 0 0 7 584 2141 1441 0 76 /**</span>
 <span class="s0">* Returns the underlying raw button associated with the nth button.</span>
 <span class="s0">*/ 2 4 this 3 2148  1 i 1 2138  </span>
<span class="s0">500 0 0 7 585 2141 1441 0 166 /**</span>
 <span class="s0">* Returns the button that the given button is mapped to, or</span>
 <span class="s0">* ButtonHandle::none() if this map does not specify a mapped button for the</span>
 <span class="s0">* given raw button.</span>
 <span class="s0">*/ 2 4 this 3 2148  3 raw 1 2141  </span>
<span class="s0">501 0 0 7 585 2141 1441 0 101 /**</span>
 <span class="s0">* Returns the nth mapped button, meaning the button that the nth raw button</span>
 <span class="s0">* is mapped to.</span>
 <span class="s0">*/ 2 4 this 3 2148  1 i 1 2138  </span>
<span class="s0">502 0 0 7 585 2141 1441 0 166 /**</span>
 <span class="s0">* Returns the button that the given button is mapped to, or</span>
 <span class="s0">* ButtonHandle::none() if this map does not specify a mapped button for the</span>
 <span class="s0">* given raw button.</span>
 <span class="s0">*/ 2 4 this 3 2148  8 raw_name 1 2081  </span>
<span class="s0">503 0 0 6 586 2081 0 0 353 /**</span>
 <span class="s0">* If the button map specifies a special name for the button (eg.  if the</span>
 <span class="s0">* operating system or keyboard device has a localized name describing the</span>
 <span class="s0">* key), returns it, or the empty string otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this is not the same as get_mapped_button().get_name(), which</span>
 <span class="s0">* returns the name of the Panda event associated with the button.</span>
 <span class="s0">*/ 2 4 this 3 2148  3 raw 1 2141  </span>
<span class="s0">504 0 0 6 586 2081 0 0 127 /**</span>
 <span class="s0">* Returns the label associated with the nth mapped button, meaning the button</span>
 <span class="s0">* that the nth raw button is mapped to.</span>
 <span class="s0">*/ 2 4 this 3 2148  1 i 1 2138  </span>
<span class="s0">505 0 0 6 586 2081 0 0 353 /**</span>
 <span class="s0">* If the button map specifies a special name for the button (eg.  if the</span>
 <span class="s0">* operating system or keyboard device has a localized name describing the</span>
 <span class="s0">* key), returns it, or the empty string otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this is not the same as get_mapped_button().get_name(), which</span>
 <span class="s0">* returns the name of the Panda event associated with the button.</span>
 <span class="s0">*/ 2 4 this 3 2148  8 raw_name 1 2081  </span>
<span class="s0">506 0 0 4 587 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2148  3 out 1 2077  </span>
<span class="s0">507 0 0 4 588 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 2148  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">508 0 0 7 589 2079 0 0 0 0 </span>
<span class="s0">509 0 0 15 596 2152 1462 0 0 1 6 param0 0 2150  </span>
<span class="s0">510 0 0 4 593 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2150  3 out 1 2077  </span>
<span class="s0">511 0 0 55 594 2152 1462 0 0 1 8 function 1 1961  </span>
<span class="s0">512 0 0 7 595 2079 0 0 0 0 </span>
<span class="s0">513 0 0 6 599 1932 0 0 47 /**</span>
 <span class="s0">* Returns the current reference count.</span>
 <span class="s0">*/ 1 4 this 3 2153  </span>
<span class="s0">514 0 0 4 600 2065 0 0 108 /**</span>
 <span class="s0">* Explicitly increments the cache reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*/ 1 4 this 3 2153  </span>
<span class="s0">515 0 0 6 601 1933 0 0 202 /**</span>
 <span class="s0">* Explicitly decrements the cache reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the new reference count is nonzero, false if it</span>
 <span class="s0">* is zero.</span>
 <span class="s0">*/ 1 4 this 3 2153  </span>
<span class="s0">516 0 0 6 602 1933 0 0 97 /**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't</span>
 <span class="s0">* completely bogus.</span>
 <span class="s0">*/ 1 4 this 3 2153  </span>
<span class="s0">517 0 0 7 604 2079 0 0 0 0 </span>
<span class="s0">518 0 0 4 606 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2155  3 out 1 2077  </span>
<span class="s0">519 0 0 4 607 2065 0 0 159 /**</span>
 <span class="s0">* You should make this call during the callback if you want to continue the</span>
 <span class="s0">* normal function that would have been done in the absence of a callback.</span>
 <span class="s0">*/ 1 4 this 3 2157  </span>
<span class="s0">520 0 0 7 608 2079 0 0 0 0 </span>
<span class="s0">521 0 0 23 611 2158 1462 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 8 function 5 1961  </span>
<span class="s0">522 0 0 15 611 2158 1462 0 0 1 6 param0 0 2159  </span>
<span class="s0">523 0 0 4 612 2065 0 0 0 2 4 this 3 2158  4 size 1 2138  </span>
<span class="s0">524 0 0 4 615 2065 0 0 126 /**</span>
 <span class="s0">* Replaces the function that is called for the callback.  runs.  The</span>
 <span class="s0">* parameter should be a Python callable object.</span>
 <span class="s0">*/ 2 4 this 3 2158  8 function 1 1961  </span>
<span class="s0">525 0 0 6 616 1961 0 0 64 /**</span>
 <span class="s0">* Returns the function that is called for the callback.</span>
 <span class="s0">*/ 1 4 this 3 2158  </span>
<span class="s0">526 0 0 7 618 2079 0 0 0 0 </span>
<span class="s0">527 0 0 7 620 2161 1484 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">528 0 0 15 620 2161 1484 0 0 1 6 param0 0 2162  </span>
<span class="s0">529 0 0 6 621 1989 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 2162  </span>
<span class="s0">530 0 0 6 622 1989 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 2162  </span>
<span class="s0">531 0 0 15 632 2166 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 2164  </span>
<span class="s0">532 0 0 23 632 2166 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 mode 5 1992  </span>
<span class="s0">533 0 0 4 633 2065 0 0 1841 /**</span>
 <span class="s0">* Changes the mode of the clock.  Normally, the clock is in mode M_normal.</span>
 <span class="s0">* In this mode, each call to tick() will set the value returned by</span>
 <span class="s0">* get_frame_time() to the current real time; thus, the clock simply reports</span>
 <span class="s0">* time advancing.</span>
 <span class="s0">*</span>
 <span class="s0">* Other possible modes:</span>
 <span class="s0">*</span>
 <span class="s0">* M_non_real_time - the clock ignores real time completely; at each call to</span>
 <span class="s0">* tick(), it pretends that exactly dt seconds have elapsed since the last</span>
 <span class="s0">* call to tick().  You may set the value of dt with set_dt() or</span>
 <span class="s0">* set_frame_rate().</span>
 <span class="s0">*</span>
 <span class="s0">* M_limited - the clock will run as fast as it can, as in M_normal, but will</span>
 <span class="s0">* not run faster than the rate specified by set_frame_rate().  If the</span>
 <span class="s0">* application would run faster than this rate, the clock will slow down the</span>
 <span class="s0">* application.</span>
 <span class="s0">*</span>
 <span class="s0">* M_integer - the clock will run as fast as it can, but the rate will be</span>
 <span class="s0">* constrained to be an integer multiple or divisor of the rate specified by</span>
 <span class="s0">* set_frame_rate().  The clock will slow down the application a bit to</span>
 <span class="s0">* guarantee this.</span>
 <span class="s0">*</span>
 <span class="s0">* M_integer_limited - a combination of M_limited and M_integer; the clock</span>
 <span class="s0">* will not run faster than set_frame_rate(), and if it runs slower, it will</span>
 <span class="s0">* run at a integer divisor of that rate.</span>
 <span class="s0">*</span>
 <span class="s0">* M_forced - the clock forces the application to run at the rate specified by</span>
 <span class="s0">* set_frame_rate().  If the application would run faster than this rate, the</span>
 <span class="s0">* clock will slow down the application; if the application would run slower</span>
 <span class="s0">* than this rate, the clock slows down time so that the application believes</span>
 <span class="s0">* it is running at the given rate.</span>
 <span class="s0">*</span>
 <span class="s0">* M_degrade - the clock runs at real time, but the application is slowed down</span>
 <span class="s0">* by a set factor of its frame rate, specified by set_degrade_factor().</span>
 <span class="s0">*</span>
 <span class="s0">* M_slave - the clock does not advance, but relies on the user to call</span>
 <span class="s0">* set_frame_time() and/or set_frame_count() each frame.</span>
 <span class="s0">*/ 2 4 this 3 2166  4 mode 1 1992  </span>
<span class="s0">534 0 0 6 634 1992 0 0 66 /**</span>
 <span class="s0">* Returns the current mode of the clock.  See set_mode().</span>
 <span class="s0">*/ 1 4 this 3 2164  </span>
<span class="s0">535 0 0 6 636 1931 0 0 350 /**</span>
 <span class="s0">* Returns the time in seconds as of the last time tick() was called</span>
 <span class="s0">* (typically, this will be as of the start of the current frame).</span>
 <span class="s0">*</span>
 <span class="s0">* This is generally the kind of time you want to ask for in most rendering</span>
 <span class="s0">* and animation contexts, since it's important that all of the animation for</span>
 <span class="s0">* a given frame remains in sync with each other.</span>
 <span class="s0">*/ 2 4 this 3 2164  14 current_thread 5 2167  </span>
<span class="s0">536 0 0 6 637 1931 0 0 434 /**</span>
 <span class="s0">* Returns the actual number of seconds elapsed since the ClockObject was</span>
 <span class="s0">* created, or since it was last reset.  This is useful for doing real timing</span>
 <span class="s0">* measurements, e.g.  for performance statistics.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the most precise timer we have for short time intervals, but</span>
 <span class="s0">* it may tend to drift over the long haul.  If more accurate timekeeping is</span>
 <span class="s0">* needed over a long period of time, use get_long_time() instead.</span>
 <span class="s0">*/ 1 4 this 3 2164  </span>
<span class="s0">537 0 0 6 638 1931 0 0 440 /**</span>
 <span class="s0">* Returns the actual number of seconds elapsed since the ClockObject was</span>
 <span class="s0">* created, or since it was last reset.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to get_real_time(), except that it uses the most accurate</span>
 <span class="s0">* counter we have over a long period of time, and so it is less likely to</span>
 <span class="s0">* drift.  However, it may not be very precise for measuring short intervals.</span>
 <span class="s0">* On Windows, for instace, this is only accurate to within about 55</span>
 <span class="s0">* milliseconds.</span>
 <span class="s0">*/ 1 4 this 3 2164  </span>
<span class="s0">538 0 0 4 639 2065 0 0 75 /**</span>
 <span class="s0">* Simultaneously resets both the time and the frame count to zero.</span>
 <span class="s0">*/ 1 4 this 3 2166  </span>
<span class="s0">539 0 0 4 640 2065 0 0 316 /**</span>
 <span class="s0">* Resets the clock to the indicated time.  This changes only the real time of</span>
 <span class="s0">* the clock as reported by get_real_time(), but does not immediately change</span>
 <span class="s0">* the time reported by get_frame_time()--that will change after the next call</span>
 <span class="s0">* to tick().  Also see reset(), set_frame_time(), and set_frame_count().</span>
 <span class="s0">*/ 2 4 this 3 2166  4 time 1 1931  </span>
<span class="s0">540 0 0 4 641 2065 0 0 215 /**</span>
 <span class="s0">* Changes the time as reported for the current frame to the indicated time.</span>
 <span class="s0">* Normally, the way to adjust the frame time is via tick(); this function is</span>
 <span class="s0">* provided only for occasional special adjustments.</span>
 <span class="s0">*/ 3 4 this 3 2166  4 time 1 1931  14 current_thread 5 2167  </span>
<span class="s0">541 0 0 4 642 2065 0 0 132 /**</span>
 <span class="s0">* Resets the number of frames counted to the indicated number.  Also see</span>
 <span class="s0">* reset(), set_real_time(), and set_frame_time().</span>
 <span class="s0">*/ 3 4 this 3 2166  11 frame_count 1 1932  14 current_thread 5 2167  </span>
<span class="s0">542 0 0 6 643 1932 0 0 195 /**</span>
 <span class="s0">* Returns the number of times tick() has been called since the ClockObject</span>
 <span class="s0">* was created, or since it was last reset.  This is generally the number of</span>
 <span class="s0">* frames that have been rendered.</span>
 <span class="s0">*/ 2 4 this 3 2164  14 current_thread 5 2167  </span>
<span class="s0">543 0 0 6 644 1931 0 0 245 /**</span>
 <span class="s0">* Returns the average frame rate since the last reset.  This is simply the</span>
 <span class="s0">* total number of frames divided by the total elapsed time.  This reports the</span>
 <span class="s0">* virtual frame rate if the clock is in (or has been in) M_non_real_time</span>
 <span class="s0">* mode.</span>
 <span class="s0">*/ 2 4 this 3 2164  14 current_thread 5 2167  </span>
<span class="s0">544 0 0 6 649 1931 0 0 130 /**</span>
 <span class="s0">* Returns the elapsed time for the previous frame: the number of seconds</span>
 <span class="s0">* elapsed between the last two calls to tick().</span>
 <span class="s0">*/ 2 4 this 3 2164  14 current_thread 5 2167  </span>
<span class="s0">545 0 0 4 650 2065 0 0 291 /**</span>
 <span class="s0">* In non-real-time mode, sets the number of seconds that should appear to</span>
 <span class="s0">* elapse between frames.  In forced mode or limited mode, sets our target dt.</span>
 <span class="s0">* In normal mode, this has no effect.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_frame_rate(), which is a different way to specify the same</span>
 <span class="s0">* quantity.</span>
 <span class="s0">*/ 2 4 this 3 2166  2 dt 1 1931  </span>
<span class="s0">546 0 0 4 651 2065 0 0 291 /**</span>
 <span class="s0">* In non-real-time mode, sets the number of frames per second that we should</span>
 <span class="s0">* appear to be running.  In forced mode or limited mode, sets our target</span>
 <span class="s0">* frame rate.  In normal mode, this has no effect.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_dt(), which is a different way to specify the same quantity.</span>
 <span class="s0">*/ 2 4 this 3 2166  10 frame_rate 1 1931  </span>
<span class="s0">547 0 0 6 653 1931 0 0 106 /**</span>
 <span class="s0">* Returns the current maximum allowable time elapsed between any two frames.</span>
 <span class="s0">* See set_max_dt().</span>
 <span class="s0">*/ 1 4 this 3 2164  </span>
<span class="s0">548 0 0 4 654 2065 0 0 511 /**</span>
 <span class="s0">* Sets a limit on the value returned by get_dt().  If this value is less than</span>
 <span class="s0">* zero, no limit is imposed; otherwise, this is the maximum value that will</span>
 <span class="s0">* ever be returned by get_dt(), regardless of how much time has actually</span>
 <span class="s0">* elapsed between frames.</span>
 <span class="s0">*</span>
 <span class="s0">* This limit is only imposed in real-time mode; in non-real-time mode, the dt</span>
 <span class="s0">* is fixed anyway and max_dt is ignored.</span>
 <span class="s0">*</span>
 <span class="s0">* This is generally used to guarantee reasonable behavior even in the</span>
 <span class="s0">* presence of a very slow or chuggy frame rame.</span>
 <span class="s0">*/ 2 4 this 3 2166  6 max_dt 1 1931  </span>
<span class="s0">549 0 0 6 656 1931 0 0 265 /**</span>
 <span class="s0">* In degrade mode, returns the ratio by which the performance is degraded.  A</span>
 <span class="s0">* value of 2.0 causes the clock to be slowed down by a factor of two</span>
 <span class="s0">* (reducing performance to 1/2 what would be otherwise).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no effect if mode is not M_degrade.</span>
 <span class="s0">*/ 1 4 this 3 2164  </span>
<span class="s0">550 0 0 4 657 2065 0 0 262 /**</span>
 <span class="s0">* In degrade mode, sets the ratio by which the performance is degraded.  A</span>
 <span class="s0">* value of 2.0 causes the clock to be slowed down by a factor of two</span>
 <span class="s0">* (reducing performance to 1/2 what would be otherwise).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no effect if mode is not M_degrade.</span>
 <span class="s0">*/ 2 4 this 3 2166  14 degrade_factor 1 1931  </span>
<span class="s0">551 0 0 4 659 2065 0 0 393 /**</span>
 <span class="s0">* Specifies the interval of time (in seconds) over which</span>
 <span class="s0">* get_average_frame_rate() averages the number of frames per second to</span>
 <span class="s0">* compute the frame rate.  Changing this does not necessarily immediately</span>
 <span class="s0">* change the result of get_average_frame_rate(), until this interval of time</span>
 <span class="s0">* has elapsed again.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this to zero disables the computation of get_average_frame_rate().</span>
 <span class="s0">*/ 2 4 this 3 2166  4 time 1 1931  </span>
<span class="s0">552 0 0 6 660 1931 0 0 162 /**</span>
 <span class="s0">* Returns the interval of time (in seconds) over which</span>
 <span class="s0">* get_average_frame_rate() averages the number of frames per second to</span>
 <span class="s0">* compute the frame rate.</span>
 <span class="s0">*/ 1 4 this 3 2164  </span>
<span class="s0">553 0 0 6 662 1931 0 0 214 /**</span>
 <span class="s0">* Returns the average frame rate in number of frames per second over the last</span>
 <span class="s0">* get_average_frame_rate_interval() seconds.  This measures the virtual frame</span>
 <span class="s0">* rate if the clock is in M_non_real_time mode.</span>
 <span class="s0">*/ 2 4 this 3 2164  14 current_thread 5 2167  </span>
<span class="s0">554 0 0 6 663 1931 0 0 105 /**</span>
 <span class="s0">* Returns the maximum frame duration over the last</span>
 <span class="s0">* get_average_frame_rate_interval() seconds.</span>
 <span class="s0">*/ 2 4 this 3 2164  14 current_thread 5 2167  </span>
<span class="s0">555 0 0 6 664 1931 0 0 539 /**</span>
 <span class="s0">* Returns the standard deviation of the frame times of the frames rendered</span>
 <span class="s0">* over the past get_average_frame_rate_interval() seconds.  This number gives</span>
 <span class="s0">* an estimate of the chugginess of the frame rate; if it is large, there is a</span>
 <span class="s0">* large variation in the frame rate; if is small, all of the frames are</span>
 <span class="s0">* consistent in length.</span>
 <span class="s0">*</span>
 <span class="s0">* A large value might also represent just a recent change in frame rate, for</span>
 <span class="s0">* instance, because the camera has just rotated from looking at a simple</span>
 <span class="s0">* scene to looking at a more complex scene.</span>
 <span class="s0">*/ 2 4 this 3 2164  14 current_thread 5 2167  </span>
<span class="s0">556 0 0 4 667 2065 0 0 285 /**</span>
 <span class="s0">* Instructs the clock that a new frame has just begun.  In normal, real-time</span>
 <span class="s0">* mode, get_frame_time() will henceforth report the time as of this instant</span>
 <span class="s0">* as the current start-of-frame time.  In non-real-time mode,</span>
 <span class="s0">* get_frame_time() will be incremented by the value of dt.</span>
 <span class="s0">*/ 2 4 this 3 2166  14 current_thread 5 2167  </span>
<span class="s0">557 0 0 4 668 2065 0 0 417 /**</span>
 <span class="s0">* Resets the frame time to the current real time.  This is similar to tick(),</span>
 <span class="s0">* except that it does not advance the frame counter and does not affect dt.</span>
 <span class="s0">* This is intended to be used in the middle of a particularly long frame to</span>
 <span class="s0">* compensate for the time that has already elapsed.</span>
 <span class="s0">*</span>
 <span class="s0">* In non-real-time mode, this function has no effect (because in this mode</span>
 <span class="s0">* all frames take the same length of time).</span>
 <span class="s0">*/ 2 4 this 3 2166  14 current_thread 5 2167  </span>
<span class="s0">558 0 0 6 669 1933 0 0 322 /**</span>
 <span class="s0">* Returns true if a clock error was detected since the last time</span>
 <span class="s0">* check_errors() was called.  A clock error means that something happened, an</span>
 <span class="s0">* OS or BIOS bug, for instance, that makes the current value of the clock</span>
 <span class="s0">* somewhat suspect, and an application may wish to resynchronize with any</span>
 <span class="s0">* external clocks.</span>
 <span class="s0">*/ 2 4 this 3 2166  14 current_thread 1 2167  </span>
<span class="s0">559 0 0 7 670 2166 0 0 159 /**</span>
 <span class="s0">* Returns a pointer to the global ClockObject.  This is the ClockObject that</span>
 <span class="s0">* most code should use for handling scene graph rendering and animation.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">560 0 0 7 671 2079 0 0 0 0 </span>
<span class="s0">561 0 0 4 679 2065 0 0 62 /**</span>
 <span class="s0">* @see CachedTypedWritableReferenceCount::cache_ref()</span>
 <span class="s0">*/ 1 4 this 3 2169  </span>
<span class="s0">562 0 0 6 680 1933 0 0 64 /**</span>
 <span class="s0">* @see CachedTypedWritableReferenceCount::cache_unref()</span>
 <span class="s0">*/ 1 4 this 3 2169  </span>
<span class="s0">563 0 0 7 681 2079 0 0 0 0 </span>
<span class="s0">564 0 0 7 688 2171 1530 0 48 /**</span>
 <span class="s0">* Initializes an empty datagram buffer.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">565 0 0 7 688 2171 1530 0 54 /**</span>
 <span class="s0">* Initializes the buffer with the given data.</span>
 <span class="s0">*/ 1 4 data 1 1998  </span>
<span class="s0">566 0 0 4 689 2065 0 0 38 /**</span>
 <span class="s0">* Clears the internal buffer.</span>
 <span class="s0">*/ 1 4 this 3 2171  </span>
<span class="s0">567 0 0 6 684 1965 0 0 0 1 4 this 3 2171  </span>
<span class="s0">568 0 0 6 686 1958 0 0 0 1 4 this 3 2171  </span>
<span class="s0">569 0 0 7 698 2172 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">570 0 0 6 699 1933 0 0 99 /**</span>
 <span class="s0">* Opens the indicated filename for reading.  Returns true on success, false</span>
 <span class="s0">* on failure.</span>
 <span class="s0">*/ 2 4 this 3 2172  4 file 1 2173  </span>
<span class="s0">571 0 0 6 699 1933 0 0 99 /**</span>
 <span class="s0">* Opens the indicated filename for reading.  Returns true on success, false</span>
 <span class="s0">* on failure.</span>
 <span class="s0">*/ 2 4 this 3 2172  8 filename 1 2100  </span>
<span class="s0">572 0 0 6 699 1933 0 0 230 /**</span>
 <span class="s0">* Starts reading from the indicated stream.  Returns true on success, false</span>
 <span class="s0">* on failure.  The DatagramInputFile does not take ownership of the stream;</span>
 <span class="s0">* you are responsible for closing or deleting it when you are done.</span>
 <span class="s0">*/ 3 4 this 3 2172  2 in 1 2176  8 filename 5 2100  </span>
<span class="s0">573 0 0 6 700 2176 0 0 61 /**</span>
 <span class="s0">* Returns the istream represented by the input file.</span>
 <span class="s0">*/ 1 4 this 3 2172  </span>
<span class="s0">574 0 0 4 701 2065 0 0 98 /**</span>
 <span class="s0">* Closes the file.  This is also implicitly done when the DatagramInputFile</span>
 <span class="s0">* destructs.</span>
 <span class="s0">*/ 1 4 this 3 2172  </span>
<span class="s0">575 0 0 7 704 2178 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">576 0 0 6 705 1933 0 0 102 /**</span>
 <span class="s0">* Opens the indicated filename for writing.  Returns true if successful,</span>
 <span class="s0">* false on failure.</span>
 <span class="s0">*/ 2 4 this 3 2178  4 file 1 2173  </span>
<span class="s0">577 0 0 6 705 1933 0 0 99 /**</span>
 <span class="s0">* Opens the indicated filename for writing.  Returns true on success, false</span>
 <span class="s0">* on failure.</span>
 <span class="s0">*/ 2 4 this 3 2178  8 filename 1 2100  </span>
<span class="s0">578 0 0 6 705 1933 0 0 229 /**</span>
 <span class="s0">* Starts writing to the indicated stream.  Returns true on success, false on</span>
 <span class="s0">* failure.  The DatagramOutputFile does not take ownership of the stream; you</span>
 <span class="s0">* are responsible for closing or deleting it when you are done.</span>
 <span class="s0">*/ 3 4 this 3 2178  3 out 1 2077  8 filename 5 2100  </span>
<span class="s0">579 0 0 4 706 2065 0 0 99 /**</span>
 <span class="s0">* Closes the file.  This is also implicitly done when the DatagramOutputFile</span>
 <span class="s0">* destructs.</span>
 <span class="s0">*/ 1 4 this 3 2178  </span>
<span class="s0">580 0 0 6 707 1933 0 0 256 /**</span>
 <span class="s0">* Writes a sequence of bytes to the beginning of the datagram file.  This may</span>
 <span class="s0">* be called any number of times after the file has been opened and before the</span>
 <span class="s0">* first datagram is written.  It may not be called once the first datagram is</span>
 <span class="s0">* written.</span>
 <span class="s0">*/ 2 4 this 3 2178  6 header 1 2081  </span>
<span class="s0">581 0 0 7 712 2179 1594 0 0 0 </span>
<span class="s0">582 0 0 15 712 2179 1594 0 0 1 6 param0 0 2180  </span>
<span class="s0">583 0 0 55 712 2179 1594 0 0 1 10 init_value 1 1961  </span>
<span class="s0">584 0 0 7 713 2179 1594 0 0 0 </span>
<span class="s0">585 0 0 7 714 2179 1594 0 0 0 </span>
<span class="s0">586 0 0 7 715 2179 1594 0 0 1 7 on_bits 1 1932  </span>
<span class="s0">587 0 0 7 716 2179 1594 0 0 1 5 index 1 1932  </span>
<span class="s0">588 0 0 7 717 2179 1594 0 0 2 7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">589 0 0 6 718 1933 0 0 0 0 </span>
<span class="s0">590 0 0 6 719 1932 0 0 0 0 </span>
<span class="s0">591 0 0 6 720 1932 0 0 0 1 4 this 3 2180  </span>
<span class="s0">592 0 0 6 721 1933 0 0 0 2 4 this 3 2180  5 index 1 1932  </span>
<span class="s0">593 0 0 4 722 2065 0 0 0 2 4 this 3 2179  5 index 1 1932  </span>
<span class="s0">594 0 0 4 723 2065 0 0 0 2 4 this 3 2179  5 index 1 1932  </span>
<span class="s0">595 0 0 4 724 2065 0 0 0 3 4 this 3 2179  5 index 1 1932  5 value 1 1933  </span>
<span class="s0">596 0 0 6 725 1933 0 0 0 1 4 this 3 2180  </span>
<span class="s0">597 0 0 6 726 1933 0 0 0 1 4 this 3 2180  </span>
<span class="s0">598 0 0 6 727 2131 0 0 0 3 4 this 3 2180  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">599 0 0 4 728 2065 0 0 0 4 4 this 3 2179  5 value 1 2131  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">600 0 0 6 729 1933 0 0 0 3 4 this 3 2180  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">601 0 0 6 730 1933 0 0 0 3 4 this 3 2180  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">602 0 0 4 731 2065 0 0 0 3 4 this 3 2179  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">603 0 0 4 732 2065 0 0 0 3 4 this 3 2179  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">604 0 0 4 733 2065 0 0 0 4 4 this 3 2179  5 value 1 1933  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">605 0 0 6 734 1932 0 0 0 1 4 this 3 2180  </span>
<span class="s0">606 0 0 6 735 1932 0 0 0 1 4 this 3 2180  </span>
<span class="s0">607 0 0 6 736 1932 0 0 0 1 4 this 3 2180  </span>
<span class="s0">608 0 0 6 737 1932 0 0 0 1 4 this 3 2180  </span>
<span class="s0">609 0 0 6 738 1932 0 0 0 1 4 this 3 2180  </span>
<span class="s0">610 0 0 6 739 1932 0 0 0 1 4 this 3 2180  </span>
<span class="s0">611 0 0 6 740 1932 0 0 0 2 4 this 3 2180  7 low_bit 1 1932  </span>
<span class="s0">612 0 0 4 741 2065 0 0 0 1 4 this 3 2179  </span>
<span class="s0">613 0 0 6 742 1933 0 0 0 2 4 this 3 2180  5 other 1 2180  </span>
<span class="s0">614 0 0 4 743 2065 0 0 0 1 4 this 3 2179  </span>
<span class="s0">615 0 0 4 744 2065 0 0 0 2 4 this 3 2180  3 out 1 2077  </span>
<span class="s0">616 0 0 4 745 2065 0 0 0 3 4 this 3 2180  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">617 0 0 4 746 2065 0 0 0 3 4 this 3 2180  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">618 0 0 4 747 2065 0 0 0 3 4 this 3 2180  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">619 0 0 6 748 1933 0 0 0 2 4 this 3 2180  5 other 1 2180  </span>
<span class="s0">620 0 0 6 749 1933 0 0 0 2 4 this 3 2180  5 other 1 2180  </span>
<span class="s0">621 0 0 6 750 1933 0 0 0 2 4 this 3 2180  5 other 1 2180  </span>
<span class="s0">622 0 0 6 751 1932 0 0 0 2 4 this 3 2180  5 other 1 2180  </span>
<span class="s0">623 0 0 7 752 2179 1594 0 0 2 4 this 3 2180  5 other 1 2180  </span>
<span class="s0">624 0 0 7 753 2179 1594 0 0 2 4 this 3 2180  5 other 1 2180  </span>
<span class="s0">625 0 0 7 754 2179 1594 0 0 2 4 this 3 2180  5 other 1 2180  </span>
<span class="s0">626 0 0 7 755 2179 1594 0 0 1 4 this 3 2180  </span>
<span class="s0">627 0 0 7 756 2179 1594 0 0 2 4 this 3 2180  5 shift 1 1932  </span>
<span class="s0">628 0 0 7 757 2179 1594 0 0 2 4 this 3 2180  5 shift 1 1932  </span>
<span class="s0">629 0 0 6 758 2179 0 0 0 2 4 this 3 2179  5 other 1 2180  </span>
<span class="s0">630 0 0 6 759 2179 0 0 0 2 4 this 3 2179  5 other 1 2180  </span>
<span class="s0">631 0 0 6 760 2179 0 0 0 2 4 this 3 2179  5 other 1 2180  </span>
<span class="s0">632 0 0 6 761 2179 0 0 0 2 4 this 3 2179  5 shift 1 1932  </span>
<span class="s0">633 0 0 6 762 2179 0 0 0 2 4 this 3 2179  5 shift 1 1932  </span>
<span class="s0">634 0 0 38 763 1961 0 0 0 1 4 this 3 2180  </span>
<span class="s0">635 0 0 7 764 2079 0 0 0 0 </span>
<span class="s0">636 0 0 7 768 2182 1648 0 0 0 </span>
<span class="s0">637 0 0 15 768 2182 1648 0 0 1 6 param0 0 2183  </span>
<span class="s0">638 0 0 55 768 2182 1648 0 0 1 10 init_value 1 1961  </span>
<span class="s0">639 0 0 7 769 2182 1648 0 0 0 </span>
<span class="s0">640 0 0 7 770 2182 1648 0 0 0 </span>
<span class="s0">641 0 0 7 771 2182 1648 0 0 1 7 on_bits 1 1932  </span>
<span class="s0">642 0 0 7 772 2182 1648 0 0 1 5 index 1 1932  </span>
<span class="s0">643 0 0 7 773 2182 1648 0 0 2 7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">644 0 0 6 774 1933 0 0 0 0 </span>
<span class="s0">645 0 0 6 775 1932 0 0 0 0 </span>
<span class="s0">646 0 0 6 776 1932 0 0 0 1 4 this 3 2183  </span>
<span class="s0">647 0 0 6 777 1933 0 0 0 2 4 this 3 2183  5 index 1 1932  </span>
<span class="s0">648 0 0 4 778 2065 0 0 0 2 4 this 3 2182  5 index 1 1932  </span>
<span class="s0">649 0 0 4 779 2065 0 0 0 2 4 this 3 2182  5 index 1 1932  </span>
<span class="s0">650 0 0 4 780 2065 0 0 0 3 4 this 3 2182  5 index 1 1932  5 value 1 1933  </span>
<span class="s0">651 0 0 6 781 1933 0 0 0 1 4 this 3 2183  </span>
<span class="s0">652 0 0 6 782 1933 0 0 0 1 4 this 3 2183  </span>
<span class="s0">653 0 0 6 783 2131 0 0 0 3 4 this 3 2183  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">654 0 0 4 784 2065 0 0 0 4 4 this 3 2182  5 value 1 2131  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">655 0 0 6 785 1933 0 0 0 3 4 this 3 2183  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">656 0 0 6 786 1933 0 0 0 3 4 this 3 2183  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">657 0 0 4 787 2065 0 0 0 3 4 this 3 2182  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">658 0 0 4 788 2065 0 0 0 3 4 this 3 2182  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">659 0 0 4 789 2065 0 0 0 4 4 this 3 2182  5 value 1 1933  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">660 0 0 6 790 1932 0 0 0 1 4 this 3 2183  </span>
<span class="s0">661 0 0 6 791 1932 0 0 0 1 4 this 3 2183  </span>
<span class="s0">662 0 0 6 792 1932 0 0 0 1 4 this 3 2183  </span>
<span class="s0">663 0 0 6 793 1932 0 0 0 1 4 this 3 2183  </span>
<span class="s0">664 0 0 6 794 1932 0 0 0 1 4 this 3 2183  </span>
<span class="s0">665 0 0 6 795 1932 0 0 0 1 4 this 3 2183  </span>
<span class="s0">666 0 0 6 796 1932 0 0 0 2 4 this 3 2183  7 low_bit 1 1932  </span>
<span class="s0">667 0 0 4 797 2065 0 0 0 1 4 this 3 2182  </span>
<span class="s0">668 0 0 6 798 1933 0 0 0 2 4 this 3 2183  5 other 1 2183  </span>
<span class="s0">669 0 0 4 799 2065 0 0 0 1 4 this 3 2182  </span>
<span class="s0">670 0 0 4 800 2065 0 0 0 2 4 this 3 2183  3 out 1 2077  </span>
<span class="s0">671 0 0 4 801 2065 0 0 0 3 4 this 3 2183  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">672 0 0 4 802 2065 0 0 0 3 4 this 3 2183  3 out 1 2077  12 spaces_every 5 1932  </span>
<span class="s0">673 0 0 4 803 2065 0 0 0 3 4 this 3 2183  3 out 1 2077  12 indent_level 5 1932  </span>
<span class="s0">674 0 0 6 804 1933 0 0 0 2 4 this 3 2183  5 other 1 2183  </span>
<span class="s0">675 0 0 6 805 1933 0 0 0 2 4 this 3 2183  5 other 1 2183  </span>
<span class="s0">676 0 0 6 806 1933 0 0 0 2 4 this 3 2183  5 other 1 2183  </span>
<span class="s0">677 0 0 6 807 1932 0 0 0 2 4 this 3 2183  5 other 1 2183  </span>
<span class="s0">678 0 0 7 808 2182 1648 0 0 2 4 this 3 2183  5 other 1 2183  </span>
<span class="s0">679 0 0 7 809 2182 1648 0 0 2 4 this 3 2183  5 other 1 2183  </span>
<span class="s0">680 0 0 7 810 2182 1648 0 0 2 4 this 3 2183  5 other 1 2183  </span>
<span class="s0">681 0 0 7 811 2182 1648 0 0 1 4 this 3 2183  </span>
<span class="s0">682 0 0 7 812 2182 1648 0 0 2 4 this 3 2183  5 shift 1 1932  </span>
<span class="s0">683 0 0 7 813 2182 1648 0 0 2 4 this 3 2183  5 shift 1 1932  </span>
<span class="s0">684 0 0 6 814 2182 0 0 0 2 4 this 3 2182  5 other 1 2183  </span>
<span class="s0">685 0 0 6 815 2182 0 0 0 2 4 this 3 2182  5 other 1 2183  </span>
<span class="s0">686 0 0 6 816 2182 0 0 0 2 4 this 3 2182  5 other 1 2183  </span>
<span class="s0">687 0 0 6 817 2182 0 0 0 2 4 this 3 2182  5 shift 1 1932  </span>
<span class="s0">688 0 0 6 818 2182 0 0 0 2 4 this 3 2182  5 shift 1 1932  </span>
<span class="s0">689 0 0 38 819 1961 0 0 0 1 4 this 3 2183  </span>
<span class="s0">690 0 0 7 820 2079 0 0 0 0 </span>
<span class="s0">691 0 0 7 856 2185 1681 0 0 0 </span>
<span class="s0">692 0 0 15 856 2185 1681 0 0 1 6 param0 0 2186  </span>
<span class="s0">693 0 0 7 825 2141 1441 0 0 0 </span>
<span class="s0">694 0 0 7 826 2141 1441 0 0 0 </span>
<span class="s0">695 0 0 7 827 2141 1441 0 0 0 </span>
<span class="s0">696 0 0 7 828 2141 1441 0 0 0 </span>
<span class="s0">697 0 0 7 829 2141 1441 0 0 0 </span>
<span class="s0">698 0 0 7 830 2141 1441 0 0 0 </span>
<span class="s0">699 0 0 7 831 2141 1441 0 0 0 </span>
<span class="s0">700 0 0 7 832 2141 1441 0 0 0 </span>
<span class="s0">701 0 0 7 833 2141 1441 0 0 0 </span>
<span class="s0">702 0 0 7 834 2141 1441 0 0 0 </span>
<span class="s0">703 0 0 7 835 2141 1441 0 0 0 </span>
<span class="s0">704 0 0 7 836 2141 1441 0 0 0 </span>
<span class="s0">705 0 0 7 837 2141 1441 0 0 0 </span>
<span class="s0">706 0 0 7 838 2141 1441 0 0 0 </span>
<span class="s0">707 0 0 7 839 2141 1441 0 0 0 </span>
<span class="s0">708 0 0 7 840 2141 1441 0 0 0 </span>
<span class="s0">709 0 0 7 841 2141 1441 0 0 0 </span>
<span class="s0">710 0 0 7 842 2141 1441 0 0 0 </span>
<span class="s0">711 0 0 7 843 2141 1441 0 0 0 </span>
<span class="s0">712 0 0 7 844 2141 1441 0 0 0 </span>
<span class="s0">713 0 0 7 845 2141 1441 0 0 0 </span>
<span class="s0">714 0 0 7 846 2141 1441 0 0 0 </span>
<span class="s0">715 0 0 7 847 2141 1441 0 0 0 </span>
<span class="s0">716 0 0 7 848 2141 1441 0 0 0 </span>
<span class="s0">717 0 0 7 849 2141 1441 0 0 0 </span>
<span class="s0">718 0 0 7 850 2141 1441 0 74 // Flight stick buttons, takes zero-based index.  First is always trigger. 0 </span>
<span class="s0">719 0 0 7 851 2141 1441 0 169 /**</span>
 <span class="s0">* Returns the ButtonHandle associated with the particular numbered joystick</span>
 <span class="s0">* button (zero-based), if there is one, or ButtonHandle::none() if there is</span>
 <span class="s0">* not.</span>
 <span class="s0">*/ 1 13 button_number 1 1932  </span>
<span class="s0">720 0 0 7 852 2141 1441 0 0 0 </span>
<span class="s0">721 0 0 7 853 2141 1441 0 0 0 </span>
<span class="s0">722 0 0 7 854 2141 1441 0 0 0 </span>
<span class="s0">723 0 0 7 855 2141 1441 0 0 0 </span>
<span class="s0">724 0 0 7 911 2188 1735 0 0 0 </span>
<span class="s0">725 0 0 15 911 2188 1735 0 0 1 6 param0 0 2189  </span>
<span class="s0">726 0 0 7 859 2141 1441 0 144 /**</span>
 <span class="s0">* Returns the ButtonHandle associated with the particular ASCII character, if</span>
 <span class="s0">* there is one, or ButtonHandle::none() if there is not.</span>
 <span class="s0">*/ 1 16 ascii_equivalent 1 1979  </span>
<span class="s0">727 0 0 7 860 2141 1441 0 0 0 </span>
<span class="s0">728 0 0 7 861 2141 1441 0 0 0 </span>
<span class="s0">729 0 0 7 862 2141 1441 0 0 0 </span>
<span class="s0">730 0 0 7 863 2141 1441 0 0 0 </span>
<span class="s0">731 0 0 7 864 2141 1441 0 0 0 </span>
<span class="s0">732 0 0 7 865 2141 1441 0 0 0 </span>
<span class="s0">733 0 0 7 866 2141 1441 0 0 0 </span>
<span class="s0">734 0 0 7 867 2141 1441 0 0 0 </span>
<span class="s0">735 0 0 7 868 2141 1441 0 0 0 </span>
<span class="s0">736 0 0 7 869 2141 1441 0 0 0 </span>
<span class="s0">737 0 0 7 870 2141 1441 0 0 0 </span>
<span class="s0">738 0 0 7 871 2141 1441 0 0 0 </span>
<span class="s0">739 0 0 7 872 2141 1441 0 0 0 </span>
<span class="s0">740 0 0 7 873 2141 1441 0 0 0 </span>
<span class="s0">741 0 0 7 874 2141 1441 0 0 0 </span>
<span class="s0">742 0 0 7 875 2141 1441 0 0 0 </span>
<span class="s0">743 0 0 7 876 2141 1441 0 0 0 </span>
<span class="s0">744 0 0 7 877 2141 1441 0 59 // PC keyboards don't have these four buttons, but Macs do. 0 </span>
<span class="s0">745 0 0 7 878 2141 1441 0 0 0 </span>
<span class="s0">746 0 0 7 879 2141 1441 0 0 0 </span>
<span class="s0">747 0 0 7 880 2141 1441 0 0 0 </span>
<span class="s0">748 0 0 7 881 2141 1441 0 0 0 </span>
<span class="s0">749 0 0 7 882 2141 1441 0 0 0 </span>
<span class="s0">750 0 0 7 883 2141 1441 0 0 0 </span>
<span class="s0">751 0 0 7 884 2141 1441 0 0 0 </span>
<span class="s0">752 0 0 7 885 2141 1441 0 0 0 </span>
<span class="s0">753 0 0 7 886 2141 1441 0 0 0 </span>
<span class="s0">754 0 0 7 887 2141 1441 0 0 0 </span>
<span class="s0">755 0 0 7 888 2141 1441 0 0 0 </span>
<span class="s0">756 0 0 7 889 2141 1441 0 0 0 </span>
<span class="s0">757 0 0 7 890 2141 1441 0 27 // delete is a C++ keyword. 0 </span>
<span class="s0">758 0 0 7 891 2141 1441 0 27 // delete is a C++ keyword. 0 </span>
<span class="s0">759 0 0 7 892 2141 1441 0 0 0 </span>
<span class="s0">760 0 0 7 893 2141 1441 0 0 0 </span>
<span class="s0">761 0 0 7 894 2141 1441 0 0 0 </span>
<span class="s0">762 0 0 7 895 2141 1441 0 0 0 </span>
<span class="s0">763 0 0 7 896 2141 1441 0 0 0 </span>
<span class="s0">764 0 0 7 897 2141 1441 0 0 0 </span>
<span class="s0">765 0 0 7 898 2141 1441 0 0 0 </span>
<span class="s0">766 0 0 7 899 2141 1441 0 0 0 </span>
<span class="s0">767 0 0 7 900 2141 1441 0 0 0 </span>
<span class="s0">768 0 0 7 901 2141 1441 0 0 0 </span>
<span class="s0">769 0 0 7 902 2141 1441 0 0 0 </span>
<span class="s0">770 0 0 7 903 2141 1441 0 0 0 </span>
<span class="s0">771 0 0 7 904 2141 1441 0 0 0 </span>
<span class="s0">772 0 0 7 905 2141 1441 0 0 0 </span>
<span class="s0">773 0 0 7 906 2141 1441 0 0 0 </span>
<span class="s0">774 0 0 7 907 2141 1441 0 0 0 </span>
<span class="s0">775 0 0 7 908 2141 1441 0 0 0 </span>
<span class="s0">776 0 0 7 909 2141 1441 0 0 0 </span>
<span class="s0">777 0 0 7 910 2141 1441 0 0 0 </span>
<span class="s0">778 0 0 7 918 2191 1741 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">779 0 0 15 918 2191 1741 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 2192  </span>
<span class="s0">780 0 0 6 920 2191 0 0 0 2 4 this 3 2191  4 copy 1 2192  </span>
<span class="s0">781 0 0 6 921 1933 0 0 0 2 4 this 3 2192  5 other 1 2192  </span>
<span class="s0">782 0 0 6 922 1933 0 0 0 2 4 this 3 2192  5 other 1 2192  </span>
<span class="s0">783 0 0 6 923 1933 0 0 0 2 4 this 3 2192  5 other 1 2192  </span>
<span class="s0">784 0 0 7 924 2191 1741 0 0 2 4 this 3 2192  5 other 1 2192  </span>
<span class="s0">785 0 0 7 925 2191 1741 0 0 2 4 this 3 2192  5 other 1 2192  </span>
<span class="s0">786 0 0 6 926 2191 0 0 0 2 4 this 3 2191  5 other 1 2192  </span>
<span class="s0">787 0 0 6 927 2191 0 0 0 2 4 this 3 2191  5 other 1 2192  </span>
<span class="s0">788 0 0 4 928 2065 0 0 374 /**</span>
 <span class="s0">* Sets the list of buttons to watch to be the same as that of the other</span>
 <span class="s0">* ModifierButtons object.  This makes the lists pointer equivalent (until one</span>
 <span class="s0">* or the other is later modified).</span>
 <span class="s0">*</span>
 <span class="s0">* This will preserve the state of any button that was on the original list</span>
 <span class="s0">* and is also on the new lists.  Any other buttons will get reset to the</span>
 <span class="s0">* default state of &quot;up&quot;.</span>
 <span class="s0">*/ 2 4 this 3 2191  5 other 1 2192  </span>
<span class="s0">789 0 0 6 929 1933 0 0 232 /**</span>
 <span class="s0">* Returns true if the set of buttons indicated as down by this</span>
 <span class="s0">* ModifierButtons object is the same set of buttons indicated as down by the</span>
 <span class="s0">* other ModifierButtons object.  The buttons indicated as up are not</span>
 <span class="s0">* relevant.</span>
 <span class="s0">*/ 2 4 this 3 2192  5 other 1 2192  </span>
<span class="s0">790 0 0 6 930 1933 0 0 248 /**</span>
 <span class="s0">* Adds the indicated button to the set of buttons that will be monitored for</span>
 <span class="s0">* upness and downness.  Returns true if the button was added, false if it was</span>
 <span class="s0">* already being monitored or if too many buttons are currently being</span>
 <span class="s0">* monitored.</span>
 <span class="s0">*/ 2 4 this 3 2191  6 button 1 2141  </span>
<span class="s0">791 0 0 6 931 1933 0 0 109 /**</span>
 <span class="s0">* Returns true if the indicated button is in the set of buttons being</span>
 <span class="s0">* monitored, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 2192  6 button 1 2141  </span>
<span class="s0">792 0 0 6 932 1933 0 0 313 /**</span>
 <span class="s0">* Removes the indicated button from the set of buttons being monitored.</span>
 <span class="s0">* Returns true if the button was removed, false if it was not being monitored</span>
 <span class="s0">* in the first place.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the other methods, you cannot remove a button by removing its alias;</span>
 <span class="s0">* you have to remove exactly the button itself.</span>
 <span class="s0">*/ 2 4 this 3 2191  6 button 1 2141  </span>
<span class="s0">793 0 0 6 933 1932 0 0 143 /**</span>
 <span class="s0">* Returns the number of buttons that the ModifierButtons object is monitoring</span>
 <span class="s0">* (e.g.  the number of buttons passed to add_button()).</span>
 <span class="s0">*/ 1 4 this 3 2192  </span>
<span class="s0">794 0 0 7 934 2141 1441 0 185 /**</span>
 <span class="s0">* Returns the nth button that the ModifierButtons object is monitoring (the</span>
 <span class="s0">* nth button passed to add_button()).  This must be in the range 0 &lt;= index &lt;</span>
 <span class="s0">* get_num_buttons().</span>
 <span class="s0">*/ 2 4 this 3 2192  5 index 1 1932  </span>
<span class="s0">795 0 0 6 937 1933 0 0 305 /**</span>
 <span class="s0">* Records that a particular button has been pressed.  If the given button is</span>
 <span class="s0">* one of the buttons that is currently being monitored, this will update the</span>
 <span class="s0">* internal state appropriately; otherwise, it will do nothing.  Returns true</span>
 <span class="s0">* if the button is one that was monitored, or false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 2191  6 button 1 2141  </span>
<span class="s0">796 0 0 6 938 1933 0 0 306 /**</span>
 <span class="s0">* Records that a particular button has been released.  If the given button is</span>
 <span class="s0">* one of the buttons that is currently being monitored, this will update the</span>
 <span class="s0">* internal state appropriately; otherwise, it will do nothing.  Returns true</span>
 <span class="s0">* if the button is one that was monitored, or false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 2191  6 button 1 2141  </span>
<span class="s0">797 0 0 4 939 2065 0 0 66 /**</span>
 <span class="s0">* Marks all monitored buttons as being in the &quot;up&quot; state.</span>
 <span class="s0">*/ 1 4 this 3 2191  </span>
<span class="s0">798 0 0 6 940 1933 0 0 157 /**</span>
 <span class="s0">* Returns true if the indicated button is known to be down, or false if it is</span>
 <span class="s0">* known to be up or if it is not in the set of buttons being tracked.</span>
 <span class="s0">*/ 2 4 this 3 2192  6 button 1 2141  </span>
<span class="s0">799 0 0 6 940 1933 0 0 105 /**</span>
 <span class="s0">* Returns true if the indicated button is known to be down, or false if it is</span>
 <span class="s0">* known to be up.</span>
 <span class="s0">*/ 2 4 this 3 2192  5 index 1 1932  </span>
<span class="s0">800 0 0 6 941 1933 0 0 109 /**</span>
 <span class="s0">* Returns true if any of the tracked button are known to be down, or false if</span>
 <span class="s0">* all of them are up.</span>
 <span class="s0">*/ 1 4 this 3 2192  </span>
<span class="s0">801 0 0 6 942 2081 0 0 150 /**</span>
 <span class="s0">* Returns a string which can be used to prefix any button name or event name</span>
 <span class="s0">* with the unique set of modifier buttons currently being held.</span>
 <span class="s0">*/ 1 4 this 3 2192  </span>
<span class="s0">802 0 0 4 943 2065 0 0 69 /**</span>
 <span class="s0">* Writes a one-line summary of the buttons known to be down.</span>
 <span class="s0">*/ 2 4 this 3 2192  3 out 1 2077  </span>
<span class="s0">803 0 0 4 944 2065 0 0 123 /**</span>
 <span class="s0">* Writes a multi-line summary including all of the buttons being monitored</span>
 <span class="s0">* and which ones are known to be down.</span>
 <span class="s0">*/ 2 4 this 3 2192  3 out 1 2077  </span>
<span class="s0">804 0 0 7 957 2194 1777 0 0 0 </span>
<span class="s0">805 0 0 15 957 2194 1777 0 0 1 6 param0 0 2195  </span>
<span class="s0">806 0 0 7 946 2141 1441 0 166 /**</span>
 <span class="s0">* Returns the ButtonHandle associated with the particular numbered mouse</span>
 <span class="s0">* button (zero-based), if there is one, or ButtonHandle::none() if there is</span>
 <span class="s0">* not.</span>
 <span class="s0">*/ 1 13 button_number 1 1932  </span>
<span class="s0">807 0 0 7 947 2141 1441 0 75 /**</span>
 <span class="s0">* Returns the ButtonHandle associated with the first mouse button.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">808 0 0 7 948 2141 1441 0 76 /**</span>
 <span class="s0">* Returns the ButtonHandle associated with the second mouse button.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">809 0 0 7 949 2141 1441 0 75 /**</span>
 <span class="s0">* Returns the ButtonHandle associated with the third mouse button.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">810 0 0 7 950 2141 1441 0 76 /**</span>
 <span class="s0">* Returns the ButtonHandle associated with the fourth mouse button.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">811 0 0 7 951 2141 1441 0 75 /**</span>
 <span class="s0">* Returns the ButtonHandle associated with the fifth mouse button.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">812 0 0 7 952 2141 1441 0 98 /**</span>
 <span class="s0">* Returns the ButtonHandle generated when the mouse wheel is rolled one notch</span>
 <span class="s0">* upwards.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">813 0 0 7 953 2141 1441 0 100 /**</span>
 <span class="s0">* Returns the ButtonHandle generated when the mouse wheel is rolled one notch</span>
 <span class="s0">* downwards.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">814 0 0 7 954 2141 1441 0 148 /**</span>
 <span class="s0">* Returns the ButtonHandle generated when the mouse is scrolled to the left.</span>
 <span class="s0">* Usually, you'll only find the horizontal scroll on laptops.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">815 0 0 7 955 2141 1441 0 149 /**</span>
 <span class="s0">* Returns the ButtonHandle generated when the mouse is scrolled to the right.</span>
 <span class="s0">* Usually, you'll only find the horizontal scroll on laptops.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">816 0 0 6 956 1933 0 0 117 /**</span>
 <span class="s0">* Returns true if the indicated ButtonHandle is a mouse button, false if it</span>
 <span class="s0">* is some other kind of button.</span>
 <span class="s0">*/ 1 6 button 1 2141  </span>
<span class="s0">817 0 0 7 973 2197 1785 0 0 0 </span>
<span class="s0">818 0 0 15 973 2197 1785 0 0 1 6 param0 0 2198  </span>
<span class="s0">819 0 0 6 961 1931 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 2198  </span>
<span class="s0">820 0 0 6 962 1931 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 2198  </span>
<span class="s0">821 0 0 6 963 1933 0 0 157 /**</span>
 <span class="s0">* If this returns false, the pointer is not currently present in the window</span>
 <span class="s0">* and the values returned by get_x() and get_y() may not be meaningful.</span>
 <span class="s0">*/ 1 4 this 3 2198  </span>
<span class="s0">822 0 0 6 977 1932 0 0 47 /**</span>
 <span class="s0">* Returns the current reference count.</span>
 <span class="s0">*/ 1 4 this 3 2200  </span>
<span class="s0">823 0 0 4 978 2065 0 0 349 /**</span>
 <span class="s0">* Explicitly increments the reference count.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is const, even though it changes the object, because</span>
 <span class="s0">* generally fiddling with an object's reference count isn't considered part</span>
 <span class="s0">* of fiddling with the object.  An object might be const in other ways, but</span>
 <span class="s0">* we still need to accurately count the number of references to it.</span>
 <span class="s0">*/ 1 4 this 3 2200  </span>
<span class="s0">824 0 0 6 979 1933 0 0 201 /**</span>
 <span class="s0">* Explicitly decrements the node reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the new reference count is nonzero, false if it</span>
 <span class="s0">* is zero.</span>
 <span class="s0">*/ 1 4 this 3 2200  </span>
<span class="s0">825 0 0 6 980 1933 0 0 97 /**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't</span>
 <span class="s0">* completely bogus.</span>
 <span class="s0">*/ 1 4 this 3 2200  </span>
<span class="s0">826 0 0 6 982 1932 0 0 293 /**</span>
 <span class="s0">* Returns the union of the values defined in the Referenced enum that</span>
 <span class="s0">* represents the various things that appear to be holding a pointer to this</span>
 <span class="s0">* object.</span>
 <span class="s0">*</span>
 <span class="s0">* If R_node is included, at least one node is holding a pointer; if R_cache</span>
 <span class="s0">* is included, at least one cache element is.</span>
 <span class="s0">*/ 1 4 this 3 2200  </span>
<span class="s0">827 0 0 7 983 2079 0 0 0 0 </span>
<span class="s0">828 0 0 7 985 2202 1846 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">829 0 0 23 985 2202 1846 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 from 1 2133  </span>
<span class="s0">830 0 0 15 985 2202 1846 0 0 1 6 param0 0 2136  </span>
<span class="s0">831 0 0 7 986 2202 1846 0 72 /**</span>
 <span class="s0">* Returns a SparseArray with an infinite array of bits, all on.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">832 0 0 7 987 2202 1846 0 56 /**</span>
 <span class="s0">* Returns a SparseArray whose bits are all off.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">833 0 0 7 988 2202 1846 0 65 /**</span>
 <span class="s0">* Returns a SparseArray whose lower on_bits bits are on.</span>
 <span class="s0">*/ 1 7 on_bits 1 1932  </span>
<span class="s0">834 0 0 7 989 2202 1846 0 64 /**</span>
 <span class="s0">* Returns a SparseArray with only the indicated bit on.</span>
 <span class="s0">*/ 1 5 index 1 1932  </span>
<span class="s0">835 0 0 7 990 2202 1846 0 79 /**</span>
 <span class="s0">* Returns a SparseArray whose size bits, beginning at low_bit, are on.</span>
 <span class="s0">*/ 2 7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">836 0 0 6 991 1933 0 0 393 /**</span>
 <span class="s0">* Returns true if there is a maximum number of bits that may be stored in</span>
 <span class="s0">* this structure, false otherwise.  If this returns true, the number may be</span>
 <span class="s0">* queried in get_max_num_bits().</span>
 <span class="s0">*</span>
 <span class="s0">* This method always returns false.  The SparseArray has no maximum number of</span>
 <span class="s0">* bits.  This method is defined so generic programming algorithms can use</span>
 <span class="s0">* BitMask or SparseArray interchangeably.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">837 0 0 6 992 1932 0 0 428 /**</span>
 <span class="s0">* If get_max_num_bits() returned true, this method may be called to return</span>
 <span class="s0">* the maximum number of bits that may be stored in this structure.  It is an</span>
 <span class="s0">* error to call this if get_max_num_bits() return false.</span>
 <span class="s0">*</span>
 <span class="s0">* It is always an error to call this method.  The SparseArray has no maximum</span>
 <span class="s0">* number of bits.  This method is defined so generic programming algorithms</span>
 <span class="s0">* can use BitMask or SparseArray interchangeably.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">838 0 0 6 993 1932 0 0 300 /**</span>
 <span class="s0">* Returns the current number of possibly different bits in this array.  There</span>
 <span class="s0">* are actually an infinite number of bits, but every bit higher than this bit</span>
 <span class="s0">* will have the same value, either 0 or 1 (see get_highest_bits()).</span>
 <span class="s0">*</span>
 <span class="s0">* This number may grow and/or shrink automatically as needed.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">839 0 0 6 994 1933 0 0 191 /**</span>
 <span class="s0">* Returns true if the nth bit is set, false if it is cleared.  It is valid</span>
 <span class="s0">* for n to increase beyond get_num_bits(), but the return value</span>
 <span class="s0">* get_num_bits() will always be the same.</span>
 <span class="s0">*/ 2 4 this 3 2136  5 index 1 1932  </span>
<span class="s0">840 0 0 4 995 2065 0 0 97 /**</span>
 <span class="s0">* Sets the nth bit on.  If n &gt;= get_num_bits(), this automatically extends</span>
 <span class="s0">* the array.</span>
 <span class="s0">*/ 2 4 this 3 2202  5 index 1 1932  </span>
<span class="s0">841 0 0 4 996 2065 0 0 98 /**</span>
 <span class="s0">* Sets the nth bit off.  If n &gt;= get_num_bits(), this automatically extends</span>
 <span class="s0">* the array.</span>
 <span class="s0">*/ 2 4 this 3 2202  5 index 1 1932  </span>
<span class="s0">842 0 0 4 997 2065 0 0 84 /**</span>
 <span class="s0">* Sets the nth bit either on or off, according to the indicated bool value.</span>
 <span class="s0">*/ 3 4 this 3 2202  5 index 1 1932  5 value 1 1933  </span>
<span class="s0">843 0 0 6 998 1933 0 0 118 /**</span>
 <span class="s0">* Returns true if the infinite set of bits beyond get_num_bits() are all on,</span>
 <span class="s0">* or false of they are all off.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">844 0 0 6 999 1933 0 0 71 /**</span>
 <span class="s0">* Returns true if the entire bitmask is zero, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">845 0 0 6 1000 1933 0 0 70 /**</span>
 <span class="s0">* Returns true if the entire bitmask is one, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">846 0 0 6 1001 1933 0 0 82 /**</span>
 <span class="s0">* Returns true if any bit in the indicated range is set, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 2136  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">847 0 0 6 1002 1933 0 0 84 /**</span>
 <span class="s0">* Returns true if all bits in the indicated range are set, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 2136  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">848 0 0 4 1003 2065 0 0 47 /**</span>
 <span class="s0">* Sets the indicated range of bits on.</span>
 <span class="s0">*/ 3 4 this 3 2202  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">849 0 0 4 1004 2065 0 0 48 /**</span>
 <span class="s0">* Sets the indicated range of bits off.</span>
 <span class="s0">*/ 3 4 this 3 2202  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">850 0 0 4 1005 2065 0 0 64 /**</span>
 <span class="s0">* Sets the indicated range of bits to either on or off.</span>
 <span class="s0">*/ 4 4 this 3 2202  5 value 1 1933  7 low_bit 1 1932  4 size 1 1932  </span>
<span class="s0">851 0 0 6 1006 1932 0 0 127 /**</span>
 <span class="s0">* Returns the number of bits that are set to 1 in the array.  Returns -1 if</span>
 <span class="s0">* there are an infinite number of 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">852 0 0 6 1007 1932 0 0 127 /**</span>
 <span class="s0">* Returns the number of bits that are set to 0 in the array.  Returns -1 if</span>
 <span class="s0">* there are an infinite number of 0 bits.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">853 0 0 6 1008 1932 0 0 146 /**</span>
 <span class="s0">* Returns the index of the lowest 1 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 1 bits or if there are an infinite number of 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">854 0 0 6 1009 1932 0 0 146 /**</span>
 <span class="s0">* Returns the index of the lowest 0 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 0 bits or if there are an infinite number of 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">855 0 0 6 1010 1932 0 0 143 /**</span>
 <span class="s0">* Returns the index of the highest 1 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 1 bits or if there an infinite number of 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">856 0 0 6 1011 1932 0 0 143 /**</span>
 <span class="s0">* Returns the index of the highest 0 bit in the array.  Returns -1 if there</span>
 <span class="s0">* are no 0 bits or if there an infinite number of 1 bits.</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">857 0 0 6 1012 1932 0 0 287 /**</span>
 <span class="s0">* Returns the index of the next bit in the array, above low_bit, whose value</span>
 <span class="s0">* is different that the value of low_bit.  Returns low_bit again if all bits</span>
 <span class="s0">* higher than low_bit have the same value.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to quickly iterate through all of the bits in the array.</span>
 <span class="s0">*/ 2 4 this 3 2136  7 low_bit 1 1932  </span>
<span class="s0">858 0 0 4 1013 2065 0 0 93 /**</span>
 <span class="s0">* Inverts all the bits in the SparseArray.  This is equivalent to array =</span>
 <span class="s0">* ~array.</span>
 <span class="s0">*/ 1 4 this 3 2202  </span>
<span class="s0">859 0 0 6 1014 1933 0 0 181 /**</span>
 <span class="s0">* Returns true if this SparseArray has any &quot;one&quot; bits in common with the</span>
 <span class="s0">* other one, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is equivalent to (array &amp; other) != 0, but may be faster.</span>
 <span class="s0">*/ 2 4 this 3 2136  5 other 1 2136  </span>
<span class="s0">860 0 0 4 1015 2065 0 0 52 /**</span>
 <span class="s0">* Sets all the bits in the SparseArray off.</span>
 <span class="s0">*/ 1 4 this 3 2202  </span>
<span class="s0">861 0 0 4 1016 2065 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 2136  3 out 1 2077  </span>
<span class="s0">862 0 0 6 1017 1933 0 0 0 2 4 this 3 2136  5 other 1 2136  </span>
<span class="s0">863 0 0 6 1018 1933 0 0 0 2 4 this 3 2136  5 other 1 2136  </span>
<span class="s0">864 0 0 6 1019 1933 0 0 0 2 4 this 3 2136  5 other 1 2136  </span>
<span class="s0">865 0 0 6 1020 1932 0 0 242 /**</span>
 <span class="s0">* Returns a number less than zero if this SparseArray sorts before the</span>
 <span class="s0">* indicated other SparseArray, greater than zero if it sorts after, or 0 if</span>
 <span class="s0">* they are equivalent.  This is based on the same ordering defined by</span>
 <span class="s0">* operator &lt;.</span>
 <span class="s0">*/ 2 4 this 3 2136  5 other 1 2136  </span>
<span class="s0">866 0 0 7 1021 2202 1846 0 0 2 4 this 3 2136  5 other 1 2136  </span>
<span class="s0">867 0 0 7 1022 2202 1846 0 0 2 4 this 3 2136  5 other 1 2136  </span>
<span class="s0">868 0 0 7 1023 2202 1846 0 0 2 4 this 3 2136  5 other 1 2136  </span>
<span class="s0">869 0 0 7 1024 2202 1846 0 0 1 4 this 3 2136  </span>
<span class="s0">870 0 0 7 1025 2202 1846 0 0 2 4 this 3 2136  5 shift 1 1932  </span>
<span class="s0">871 0 0 7 1026 2202 1846 0 0 2 4 this 3 2136  5 shift 1 1932  </span>
<span class="s0">872 0 0 6 1027 2202 0 0 0 2 4 this 3 2202  5 other 1 2136  </span>
<span class="s0">873 0 0 6 1028 2202 0 0 0 2 4 this 3 2202  5 other 1 2136  </span>
<span class="s0">874 0 0 6 1029 2202 0 0 0 2 4 this 3 2202  5 other 1 2136  </span>
<span class="s0">875 0 0 6 1030 2202 0 0 0 2 4 this 3 2202  5 shift 1 1932  </span>
<span class="s0">876 0 0 6 1031 2202 0 0 0 2 4 this 3 2202  5 shift 1 1932  </span>
<span class="s0">877 0 0 6 1032 1933 0 0 330 /**</span>
 <span class="s0">* If this is true, the SparseArray is actually defined as a list of subranges</span>
 <span class="s0">* of integers that are *not* in the set.  If this is false (the default),</span>
 <span class="s0">* then the subranges define the integers that *are* in the set.  This affects</span>
 <span class="s0">* the interpretation of the values returned by iterating through</span>
 <span class="s0">* get_num_subranges().</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">878 0 0 6 1033 2138 0 0 237 /**</span>
 <span class="s0">* Returns the number of separate subranges stored in the SparseArray.  You</span>
 <span class="s0">* can use this limit to iterate through the subranges, calling</span>
 <span class="s0">* get_subrange_begin() and get_subrange_end() for each one.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see is_inverse().</span>
 <span class="s0">*/ 1 4 this 3 2136  </span>
<span class="s0">879 0 0 6 1034 1932 0 0 94 /**</span>
 <span class="s0">* Returns the first numeric element in the nth subrange.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see is_inverse().</span>
 <span class="s0">*/ 2 4 this 3 2136  1 n 1 2138  </span>
<span class="s0">880 0 0 6 1035 1932 0 0 104 /**</span>
 <span class="s0">* Returns the last numeric element, plus one, in the nth subrange.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see is_inverse().</span>
 <span class="s0">*/ 2 4 this 3 2136  1 n 1 2138  </span>
<span class="s0">881 0 0 38 1036 1961 0 0 0 1 4 this 3 2136  </span>
<span class="s0">882 0 0 36 1037 2065 0 0 0 2 4 this 3 2202  5 state 1 1961  </span>
<span class="s0">883 0 0 7 1038 2079 0 0 0 0 </span>
<span class="s0">884 0 0 7 1041 2079 0 0 52 /**</span>
 <span class="s0">* Returns the type of the underlying value.</span>
 <span class="s0">*/ 1 4 this 3 2203  </span>
<span class="s0">885 0 0 4 1042 2065 0 0 0 2 4 this 3 2203  3 out 1 2077  </span>
<span class="s0">886 0 0 7 1043 2079 0 0 0 0 </span>
<span class="s0">887 0 0 23 1045 2207 1064 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 value 1 2205  </span>
<span class="s0">888 0 0 7 1046 2020 0 0 55 /**</span>
 <span class="s0">* Retrieves the value stored in the parameter.</span>
 <span class="s0">*/ 1 4 this 3 2208  </span>
<span class="s0">889 0 0 7 1049 2079 0 0 0 0 </span>
<span class="s0">890 0 0 23 1051 2210 1064 0 0 1 5 value 1 2081  </span>
<span class="s0">891 0 0 4 1052 2065 0 0 0 2 4 this 3 2210  5 value 1 2081  </span>
<span class="s0">892 0 0 6 1053 2081 0 0 0 1 4 this 3 2211  </span>
<span class="s0">893 0 0 7 1057 2079 0 0 0 0 </span>
<span class="s0">894 0 0 23 1060 2213 1064 0 0 1 5 value 1 2081  </span>
<span class="s0">895 0 0 4 1061 2065 0 0 0 2 4 this 3 2213  5 value 1 2081  </span>
<span class="s0">896 0 0 6 1062 2081 0 0 0 1 4 this 3 2214  </span>
<span class="s0">897 0 0 7 1064 2079 0 0 0 0 </span>
<span class="s0">898 0 0 23 1067 2219 1064 0 0 1 5 value 1 2216  </span>
<span class="s0">899 0 0 4 1068 2065 0 0 0 2 4 this 3 2219  5 value 1 2216  </span>
<span class="s0">900 0 0 6 1069 2216 0 0 0 1 4 this 3 2220  </span>
<span class="s0">901 0 0 7 1071 2079 0 0 0 0 </span>
<span class="s0">902 0 0 23 1074 2225 1064 0 0 1 5 value 1 2222  </span>
<span class="s0">903 0 0 4 1075 2065 0 0 0 2 4 this 3 2225  5 value 1 2222  </span>
<span class="s0">904 0 0 6 1076 2222 0 0 0 1 4 this 3 2226  </span>
<span class="s0">905 0 0 7 1078 2079 0 0 0 0 </span>
<span class="s0">906 0 0 23 1081 2231 1064 0 0 1 5 value 1 2228  </span>
<span class="s0">907 0 0 4 1082 2065 0 0 0 2 4 this 3 2231  5 value 1 2228  </span>
<span class="s0">908 0 0 6 1083 2228 0 0 0 1 4 this 3 2232  </span>
<span class="s0">909 0 0 7 1085 2079 0 0 0 0 </span>
<span class="s0">910 0 0 23 1088 2237 1064 0 0 1 5 value 1 2234  </span>
<span class="s0">911 0 0 4 1089 2065 0 0 0 2 4 this 3 2237  5 value 1 2234  </span>
<span class="s0">912 0 0 6 1090 2234 0 0 0 1 4 this 3 2238  </span>
<span class="s0">913 0 0 7 1092 2079 0 0 0 0 </span>
<span class="s0">914 0 0 23 1095 2243 1064 0 0 1 5 value 1 2240  </span>
<span class="s0">915 0 0 4 1096 2065 0 0 0 2 4 this 3 2243  5 value 1 2240  </span>
<span class="s0">916 0 0 6 1097 2240 0 0 0 1 4 this 3 2244  </span>
<span class="s0">917 0 0 7 1099 2079 0 0 0 0 </span>
<span class="s0">918 0 0 23 1102 2249 1064 0 0 1 5 value 1 2246  </span>
<span class="s0">919 0 0 4 1103 2065 0 0 0 2 4 this 3 2249  5 value 1 2246  </span>
<span class="s0">920 0 0 6 1104 2246 0 0 0 1 4 this 3 2250  </span>
<span class="s0">921 0 0 7 1106 2079 0 0 0 0 </span>
<span class="s0">922 0 0 23 1109 2255 1064 0 0 1 5 value 1 2252  </span>
<span class="s0">923 0 0 4 1110 2065 0 0 0 2 4 this 3 2255  5 value 1 2252  </span>
<span class="s0">924 0 0 6 1111 2252 0 0 0 1 4 this 3 2256  </span>
<span class="s0">925 0 0 7 1113 2079 0 0 0 0 </span>
<span class="s0">926 0 0 23 1116 2261 1064 0 0 1 5 value 1 2258  </span>
<span class="s0">927 0 0 4 1117 2065 0 0 0 2 4 this 3 2261  5 value 1 2258  </span>
<span class="s0">928 0 0 6 1118 2258 0 0 0 1 4 this 3 2262  </span>
<span class="s0">929 0 0 7 1120 2079 0 0 0 0 </span>
<span class="s0">930 0 0 23 1123 2267 1064 0 0 1 5 value 1 2264  </span>
<span class="s0">931 0 0 4 1124 2065 0 0 0 2 4 this 3 2267  5 value 1 2264  </span>
<span class="s0">932 0 0 6 1125 2264 0 0 0 1 4 this 3 2268  </span>
<span class="s0">933 0 0 7 1127 2079 0 0 0 0 </span>
<span class="s0">934 0 0 23 1130 2273 1064 0 0 1 5 value 1 2270  </span>
<span class="s0">935 0 0 4 1131 2065 0 0 0 2 4 this 3 2273  5 value 1 2270  </span>
<span class="s0">936 0 0 6 1132 2270 0 0 0 1 4 this 3 2274  </span>
<span class="s0">937 0 0 7 1134 2079 0 0 0 0 </span>
<span class="s0">938 0 0 23 1137 2279 1064 0 0 1 5 value 1 2276  </span>
<span class="s0">939 0 0 4 1138 2065 0 0 0 2 4 this 3 2279  5 value 1 2276  </span>
<span class="s0">940 0 0 6 1139 2276 0 0 0 1 4 this 3 2280  </span>
<span class="s0">941 0 0 7 1141 2079 0 0 0 0 </span>
<span class="s0">942 0 0 23 1144 2285 1064 0 0 1 5 value 1 2282  </span>
<span class="s0">943 0 0 4 1145 2065 0 0 0 2 4 this 3 2285  5 value 1 2282  </span>
<span class="s0">944 0 0 6 1146 2282 0 0 0 1 4 this 3 2286  </span>
<span class="s0">945 0 0 7 1148 2079 0 0 0 0 </span>
<span class="s0">946 0 0 23 1151 2291 1064 0 0 1 5 value 1 2288  </span>
<span class="s0">947 0 0 4 1152 2065 0 0 0 2 4 this 3 2291  5 value 1 2288  </span>
<span class="s0">948 0 0 6 1153 2288 0 0 0 1 4 this 3 2292  </span>
<span class="s0">949 0 0 7 1155 2079 0 0 0 0 </span>
<span class="s0">950 0 0 7 1163 2079 0 0 0 0 </span>
<span class="s0">951 0 0 15 1166 2296 1916 0 0 1 6 param0 0 2294  </span>
<span class="s0">952 0 0 7 1166 2296 1916 0 56 /**</span>
 <span class="s0">* Create a free id pool in the range [min:max].</span>
 <span class="s0">*/ 2 3 min 5 2126  3 max 5 2126  </span>
<span class="s0">953 0 0 6 1168 2126 0 0 134 /**</span>
 <span class="s0">* Returns an id between _min and _max (that were passed to the constructor).</span>
 <span class="s0">* IndexEnd is returned if no ids are available.</span>
 <span class="s0">*/ 1 4 this 3 2296  </span>
<span class="s0">954 0 0 4 1169 2065 0 0 518 /**</span>
 <span class="s0">* This may be called to mark a particular id as having already been allocated</span>
 <span class="s0">* (for instance, by a prior pass).  The specified id is removed from the</span>
 <span class="s0">* available pool.</span>
 <span class="s0">*</span>
 <span class="s0">* Because of the limitations of this algorithm, this is most efficient when</span>
 <span class="s0">* it is called before the first call to allocate(), and when all the calls to</span>
 <span class="s0">* initial_reserve_id() are made in descending order by id.  However, this is</span>
 <span class="s0">* a performance warning only; if performance is not an issue, any id may be</span>
 <span class="s0">* reserved at any time.</span>
 <span class="s0">*/ 2 4 this 3 2296  2 id 1 2126  </span>
<span class="s0">955 0 0 4 1170 2065 0 0 112 /**</span>
 <span class="s0">* Free an allocated index (index must be between _min and _max that were</span>
 <span class="s0">* passed to the constructor).</span>
 <span class="s0">*/ 2 4 this 3 2296  5 index 1 2126  </span>
<span class="s0">956 0 0 6 1171 2297 0 0 117 /**</span>
 <span class="s0">* return the decimal fraction of the pool that is used.  The range is 0 to</span>
 <span class="s0">* 1.0 (e.g.  75% would be 0.75).</span>
 <span class="s0">*/ 1 4 this 3 2294  </span>
<span class="s0">957 0 0 4 1172 2065 0 0 42 /**</span>
 <span class="s0">* ...intended for debugging only.</span>
 <span class="s0">*/ 2 4 this 3 2294  3 out 1 2077  </span>
<span class="s0">958 0 0 4 1173 2065 0 0 42 /**</span>
 <span class="s0">* ...intended for debugging only.</span>
 <span class="s0">*/ 2 4 this 3 2294  3 out 1 2077  </span>
<span class="s0">959 0 0 6 674 1994 0 0 0 1 3 str 1 2081  </span>
<span class="s0">960 0 0 6 675 2081 0 0 0 1 2 cs 1 1994  </span>
<span class="s0">961 0 0 6 676 2299 0 0 0 0 </span>
<span class="s0">962 0 0 6 677 2299 0 0 0 0 </span>
<span class="s0">963 0 0 6 913 2301 0 0 602 /**</span>
 <span class="s0">* A convenience function for loading explicit prc files from a disk file or</span>
 <span class="s0">* from within a multifile (via the virtual file system).  Save the return</span>
 <span class="s0">* value and pass it to unload_prc_file() if you ever want to unload this file</span>
 <span class="s0">* later.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is first searched along the default prc search path, and then</span>
 <span class="s0">* also along the model path, for convenience.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is defined in putil instead of in dtool with the read of the</span>
 <span class="s0">* prc stuff, so that it can take advantage of the virtual file system (which</span>
 <span class="s0">* is defined in express), and the model path (which is in putil).</span>
 <span class="s0">*/ 1 8 filename 1 2100  </span>
<span class="s0">964 0 0 6 914 2301 0 0 396 /**</span>
 <span class="s0">* Another convenience function to load a prc file from an explicit string,</span>
 <span class="s0">* which represents the contents of the prc file.</span>
 <span class="s0">*</span>
 <span class="s0">* The first parameter is an arbitrary name to assign to this in-memory prc</span>
 <span class="s0">* file.  Supply a filename if the data was read from a file, or use any other</span>
 <span class="s0">* name that is meaningful to you.  The name is only used when the set of</span>
 <span class="s0">* loaded prc files is listed.</span>
 <span class="s0">*/ 2 4 name 1 2081  4 data 1 2081  </span>
<span class="s0">965 0 0 6 915 1933 0 0 0 1 4 page 1 2301  </span>
<span class="s0">966 0 0 4 916 2065 0 0 0 1 4 hash 1 2303  </span>
<span class="s0">967 0 0 6 1174 1961 0 0 203 /**</span>
 <span class="s0">* This wrapper is defined as a global function to suit pickle's needs.</span>
 <span class="s0">*</span>
 <span class="s0">* This hooks into the native pickle and cPickle modules, but it cannot</span>
 <span class="s0">* properly handle self-referential BAM objects.</span>
 <span class="s0">*/ 2 10 this_class 1 1961  4 data 1 1998  </span>
<span class="s0">968 0 0 6 1175 1961 0 0 398 /**</span>
 <span class="s0">* This wrapper is defined as a global function to suit pickle's needs.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to py_decode_TypedWritable_from_bam_stream, but it provides</span>
 <span class="s0">* additional support for the missing persistent-state object needed to</span>
 <span class="s0">* properly support self-referential BAM objects written to the pickle stream.</span>
 <span class="s0">* This hooks into the pickle and cPickle modules implemented in</span>
 <span class="s0">* direct/src/stdpy.</span>
 <span class="s0">*/ 3 9 unpickler 1 1961  10 this_class 1 1961  4 data 1 1998  </span>
<span class="s0">380</span>
<span class="s0">1925 29 ConstPointerToArray&lt; ushort &gt; 0 141313 29 ConstPointerToArray&lt; ushort &gt; 29 ConstPointerToArray&lt; ushort &gt; 0 0 0 1 974 988 0 13 975 976 977 978 979 980 981 982 983 984 985 986 987 0 0 1 0 1926 0 0 0 0 0</span>

<span class="s0">1926 28 PointerToArrayBase&lt; ushort &gt; 0 26625 28 PointerToArrayBase&lt; ushort &gt; 28 PointerToArrayBase&lt; ushort &gt; 0 0 0 0 971 0 2 972 973 0 0 1 0 1927 0 0 0 0 0</span>

<span class="s0">1927 49 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; 0 43009 49 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; 49 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; 0 0 0 0 0 0 2 969 970 0 0 1 0 1928 0 0 0 0 0</span>

<span class="s0">1928 13 PointerToVoid 0 2048 13 PointerToVoid 13 PointerToVoid 0 0 0 0 0 0 0 0 0 0 0 0 373</span>
<span class="s0">/**</span>
 <span class="s0">* This is the non-template part of the base class for PointerTo and</span>
 <span class="s0">* ConstPointerTo.  It is necessary so we can keep a pointer to a non-template</span>
 <span class="s0">* class within the ReferenceCount object, to implement weak reference</span>
 <span class="s0">* pointers--we need to have something to clean up when the ReferenceCount</span>
 <span class="s0">* object destructs.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the base class for PointerToBase&lt;T&gt;.</span>
 <span class="s0">*/</span>

<span class="s0">1929 24 PointerToArray&lt; ushort &gt; 0 141313 24 PointerToArray&lt; ushort &gt; 24 PointerToArray&lt; ushort &gt; 0 0 0 1 989 1010 0 20 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 0 0 1 0 1926 0 0 0 0 0</span>

<span class="s0">1930 13 AnimInterface 0 26625 13 AnimInterface 13 AnimInterface 0 0 0 0 1011 9 2305 2306 2307 2308 2309 2310 2311 2312 2313 17 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 0 0 0 0 0 226</span>
<span class="s0">/**</span>
 <span class="s0">* This is the fundamental interface for things that have a play/loop/stop</span>
 <span class="s0">* type interface for frame-based animation, such as animated characters.</span>
 <span class="s0">* This is the base class for AnimControl and other, similar classes.</span>
 <span class="s0">*/</span>

<span class="s0">1931 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1932 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1933 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1934 16 AutoTextureScale 0 532481 16 AutoTextureScale 16 AutoTextureScale 0 0 0 0 0 0 0 0 0 0 5 8 ATS_none 8 ATS_none 0</span>
<span class="s0">0 8 ATS_down 8 ATS_down 0</span>
<span class="s0">1 6 ATS_up 6 ATS_up 0</span>
<span class="s0">2 7 ATS_pad 7 ATS_pad 0</span>
<span class="s0">3 15 ATS_unspecified 15 ATS_unspecified 0</span>
<span class="s0">4 0 0</span>

<span class="s0">1935 9 UpdateSeq 0 141313 9 UpdateSeq 9 UpdateSeq 0 0 0 1 1029 1049 1 2314 19 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 0 0 0 0 0 761</span>
<span class="s0">/**</span>
 <span class="s0">* This is a sequence number that increments monotonically.  It can be used to</span>
 <span class="s0">* track cache updates, or serve as a kind of timestamp for any changing</span>
 <span class="s0">* properties.</span>
 <span class="s0">*</span>
 <span class="s0">* A special class is used instead of simply an int, so we can elegantly</span>
 <span class="s0">* handle such things as wraparound and special cases.  There are two special</span>
 <span class="s0">* cases.  Firstly, a sequence number is 'initial' when it is first created.</span>
 <span class="s0">* This sequence is older than any other sequence number.  Secondly, a</span>
 <span class="s0">* sequence number may be explicitly set to 'old'.  This is older than any</span>
 <span class="s0">* other sequence number except 'initial'.  Finally, we have the explicit</span>
 <span class="s0">* number 'fresh', which is newer than any other sequence number.  All other</span>
 <span class="s0">* sequences are numeric and are monotonically increasing.</span>
 <span class="s0">*/</span>

<span class="s0">1936 7 Integer 0 2367488 21 AtomicAdjust::Integer 21 AtomicAdjust::Integer 1937 0 1938 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1937 12 AtomicAdjust 0 1024 12 AtomicAdjust 12 AtomicAdjust 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1938 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1939 13 TypedWritable 0 75777 13 TypedWritable 13 TypedWritable 0 0 0 0 0 0 8 1050 1051 1052 1053 1054 1055 1056 1057 0 0 1 0 1940 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* Base class for objects that can be written to and read from Bam files.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">1940 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">1941 27 TypedWritableReferenceCount 0 141313 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 1064 0 2 1062 1063 0 0 2 3 1939 1058 1059 3 1942 1060 1061 0 0 414</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedWritable and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedWritables and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">1942 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">1943 14 BamCacheRecord 0 26625 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 1069 5 2315 2316 2317 2318 2319 19 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 0 0 2 3 1941 1065 1066 3 1944 1067 1068 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* An instance of this class is written to the front of a Bam or Txo file to</span>
 <span class="s0">* make the file a cached instance of some other loadable resource.  This</span>
 <span class="s0">* record contains information needed to test the validity of the cache.</span>
 <span class="s0">*/</span>

<span class="s0">1944 14 LinkedListNode 0 1050624 14 LinkedListNode 14 LinkedListNode 0 0 0 0 0 0 0 0 0 0 0 0 468</span>
<span class="s0">/**</span>
 <span class="s0">* This just stores the pointers to implement a doubly-linked list of some</span>
 <span class="s0">* kind of object.  There are occasions when a hand-rolled linked list is more</span>
 <span class="s0">* appropriate than an STL container.</span>
 <span class="s0">*</span>
 <span class="s0">* Typically, each node of the linked list, as well as the root of the list,</span>
 <span class="s0">* will inherit from this class.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this class is not inherently thread-safe; derived classes are</span>
 <span class="s0">* responsible for protecting any calls into it within mutexes, if necessary.</span>
 <span class="s0">*/</span>

<span class="s0">1945 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 1946 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1946 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">1947 6 time_t 0 2105344 6 time_t 6 time_t 0 0 1938 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1948 15 TypedWritable * 0 8576 15 TypedWritable * 15 TypedWritable * 0 0 1939 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1949 8 BamCache 0 26625 8 BamCache 8 BamCache 0 0 0 1 1089 1090 9 2320 2321 2322 2323 2324 2325 2326 2327 2328 26 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 0 0 0 0 0 615</span>
<span class="s0">/**</span>
 <span class="s0">* This class maintains a cache of Bam and/or Txo objects generated from model</span>
 <span class="s0">* files and texture images (as well as possibly other kinds of loadable</span>
 <span class="s0">* objects that can be stored in bam file format).</span>
 <span class="s0">*</span>
 <span class="s0">* This class also maintains a persistent index that lists all of the cached</span>
 <span class="s0">* objects (see BamCacheIndex). We go through some considerable effort to make</span>
 <span class="s0">* sure this index gets saved correctly to disk, even in the presence of</span>
 <span class="s0">* multiple different processes writing to the same index, and without relying</span>
 <span class="s0">* too heavily on low-level os-provided file locks (which work poorly with C++</span>
 <span class="s0">* iostreams).</span>
 <span class="s0">*/</span>

<span class="s0">1950 8 BamEnums 0 141313 8 BamEnums 8 BamEnums 0 0 0 1 1117 1118 0 0 0 0 0 0 3 1951 1952 1953 104</span>
<span class="s0">/**</span>
 <span class="s0">* This class exists just to provide scoping for the enums shared by BamReader</span>
 <span class="s0">* and BamWriter.</span>
 <span class="s0">*/</span>

<span class="s0">1951 9 BamEndian 0 794624 19 BamEnums::BamEndian 19 BamEnums::BamEndian 1950 0 0 0 0 0 0 0 0 0 3 12 BE_bigendian 22 BamEnums::BE_bigendian 0</span>
<span class="s0">0 15 BE_littleendian 25 BamEnums::BE_littleendian 0</span>
<span class="s0">1 9 BE_native 19 BamEnums::BE_native 0</span>
<span class="s0">1 0 365</span>
<span class="s0">/**</span>
   <span class="s0">* This defines an enumerated type used to represent the endianness of</span>
   <span class="s0">* certain numeric values stored in a Bam file.  It really has only two</span>
   <span class="s0">* possible values, either BE_bigendian or BE_littleendian; but through a</span>
   <span class="s0">* preprocessor trick we also add BE_native, which is the same numerically</span>
   <span class="s0">* as whichever value the hardware supports natively.</span>
   <span class="s0">*/</span>

<span class="s0">1952 13 BamObjectCode 0 794624 23 BamEnums::BamObjectCode 23 BamEnums::BamObjectCode 1950 0 0 0 0 0 0 0 0 0 5 8 BOC_push 18 BamEnums::BOC_push 107</span>
<span class="s0">// Indicates an object definition, and will always be eventually paired</span>
<span class="s0">// with a BOC_pop (which does not).</span>
<span class="s0">0 7 BOC_pop 17 BamEnums::BOC_pop 0</span>
<span class="s0">1 11 BOC_adjunct 21 BamEnums::BOC_adjunct 105</span>
<span class="s0">// Includes an object definition but does not push the level; it is</span>
<span class="s0">// associated with the current level.</span>
<span class="s0">2 10 BOC_remove 20 BamEnums::BOC_remove 65</span>
<span class="s0">// Lists object IDs that have been deallocated on the sender end.</span>
<span class="s0">3 13 BOC_file_data 23 BamEnums::BOC_file_data 137</span>
<span class="s0">// May appear at any level and indicates the following datagram contains</span>
<span class="s0">// auxiliary file data that may be referenced by a later object.</span>
<span class="s0">4 0 107</span>
<span class="s0">/**</span>
   <span class="s0">* This is the code written along with each object.  It is used to control</span>
   <span class="s0">* object scoping.</span>
   <span class="s0">*/</span>

<span class="s0">1953 14 BamTextureMode 0 794624 24 BamEnums::BamTextureMode 24 BamEnums::BamTextureMode 1950 0 0 0 0 0 0 0 0 0 5 13 BTM_unchanged 23 BamEnums::BTM_unchanged 0</span>
<span class="s0">0 12 BTM_fullpath 22 BamEnums::BTM_fullpath 0</span>
<span class="s0">1 12 BTM_relative 22 BamEnums::BTM_relative 0</span>
<span class="s0">2 12 BTM_basename 22 BamEnums::BTM_basename 0</span>
<span class="s0">3 11 BTM_rawdata 21 BamEnums::BTM_rawdata 0</span>
<span class="s0">4 0 73</span>
<span class="s0">// This enum is used to control how textures are written to a bam stream.</span>

<span class="s0">1954 13 LoaderOptions 0 141313 13 LoaderOptions 13 LoaderOptions 0 0 0 1 1119 1129 4 2329 2330 2331 2332 9 1120 1121 1122 1123 1124 1125 1126 1127 1128 0 0 0 0 2 1955 1956 65</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies parameters that may be passed to the loader.</span>
 <span class="s0">*/</span>

<span class="s0">1955 11 LoaderFlags 0 794624 26 LoaderOptions::LoaderFlags 26 LoaderOptions::LoaderFlags 1954 0 0 0 0 0 0 0 0 0 10 9 LF_search 24 LoaderOptions::LF_search 0</span>
<span class="s0">1 16 LF_report_errors 31 LoaderOptions::LF_report_errors 0</span>
<span class="s0">2 19 LF_convert_skeleton 34 LoaderOptions::LF_convert_skeleton 0</span>
<span class="s0">4 19 LF_convert_channels 34 LoaderOptions::LF_convert_channels 0</span>
<span class="s0">8 15 LF_convert_anim 30 LoaderOptions::LF_convert_anim 22</span>
<span class="s0">// skeleton + channels</span>
<span class="s0">12 16 LF_no_disk_cache 31 LoaderOptions::LF_no_disk_cache 20</span>
<span class="s0">// disallow BamCache</span>
<span class="s0">16 15 LF_no_ram_cache 30 LoaderOptions::LF_no_ram_cache 21</span>
<span class="s0">// disallow ModelPool</span>
<span class="s0">32 11 LF_no_cache 26 LoaderOptions::LF_no_cache 19</span>
<span class="s0">// no_disk + no_ram</span>
<span class="s0">48 13 LF_cache_only 28 LoaderOptions::LF_cache_only 23</span>
<span class="s0">// fail if not in cache</span>
<span class="s0">64 17 LF_allow_instance 32 LoaderOptions::LF_allow_instance 35</span>
<span class="s0">// returned pointer might be shared</span>
<span class="s0">128 0 33</span>
<span class="s0">// Flags for loading model files.</span>

<span class="s0">1956 12 TextureFlags 0 794624 27 LoaderOptions::TextureFlags 27 LoaderOptions::TextureFlags 1954 0 0 0 0 0 0 0 0 0 8 10 TF_preload 25 LoaderOptions::TF_preload 30</span>
<span class="s0">// Texture will have RAM image</span>
<span class="s0">4 17 TF_preload_simple 32 LoaderOptions::TF_preload_simple 37</span>
<span class="s0">// Texture will have simple RAM image</span>
<span class="s0">8 11 TF_allow_1d 26 LoaderOptions::TF_allow_1d 40</span>
<span class="s0">// If texture is Nx1, make a 1-d texture</span>
<span class="s0">16 19 TF_generate_mipmaps 34 LoaderOptions::TF_generate_mipmaps 30</span>
<span class="s0">// Consider generating mipmaps</span>
<span class="s0">32 12 TF_multiview 27 LoaderOptions::TF_multiview 36</span>
<span class="s0">// Load a multiview texture in pages</span>
<span class="s0">64 10 TF_integer 25 LoaderOptions::TF_integer 35</span>
<span class="s0">// Load as an integer (RGB) texture</span>
<span class="s0">128 8 TF_float 23 LoaderOptions::TF_float 43</span>
<span class="s0">// Load as a floating-point (depth) texture</span>
<span class="s0">256 20 TF_allow_compression 35 LoaderOptions::TF_allow_compression 33</span>
<span class="s0">// Consider compressing RAM image</span>
<span class="s0">512 0 35</span>
<span class="s0">// Flags for loading texture files.</span>

<span class="s0">1957 9 BamReader 0 26625 9 BamReader 9 BamReader 0 0 0 1 1130 1131 6 2333 2334 2335 2336 2337 2338 20 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 0 0 1 0 1950 0 0 0 0 1311</span>
<span class="s0">/**</span>
 <span class="s0">* This is the fundamental interface for extracting binary objects from a Bam</span>
 <span class="s0">* file, as generated by a BamWriter.</span>
 <span class="s0">*</span>
 <span class="s0">* A Bam file can be thought of as a linear collection of objects.  Each</span>
 <span class="s0">* object is an instance of a class that inherits, directly or indirectly,</span>
 <span class="s0">* from TypedWritable.  The objects may include pointers to other objects</span>
 <span class="s0">* within the Bam file; the BamReader automatically manages these (with help</span>
 <span class="s0">* from code within each class) and restores the pointers correctly.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the abstract interface and does not specifically deal with disk</span>
 <span class="s0">* files, but rather with a DatagramGenerator of some kind, which is simply a</span>
 <span class="s0">* linear source of Datagrams.  It is probably from a disk file, but it might</span>
 <span class="s0">* conceivably be streamed directly from a network or some such nonsense.</span>
 <span class="s0">*</span>
 <span class="s0">* Bam files are most often used to store scene graphs or subgraphs, and by</span>
 <span class="s0">* convention they are given filenames ending in the extension &quot;.bam&quot; when</span>
 <span class="s0">* they are used for this purpose.  However, a Bam file may store any</span>
 <span class="s0">* arbitrary list of TypedWritable objects; in this more general usage, they</span>
 <span class="s0">* are given filenames ending in &quot;.boo&quot; to differentiate them from the more</span>
 <span class="s0">* common scene graph files.</span>
 <span class="s0">*</span>
 <span class="s0">* See also BamFile, which defines a higher-level interface to read and write</span>
 <span class="s0">* Bam files on disk.</span>
 <span class="s0">*/</span>

<span class="s0">1958 19 DatagramGenerator * 0 8576 19 DatagramGenerator * 19 DatagramGenerator * 0 0 1959 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1959 17 DatagramGenerator 0 2048 17 DatagramGenerator 17 DatagramGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* This class defines the abstract interace to any source of datagrams,</span>
 <span class="s0">* whether it be from a file or from the net.</span>
 <span class="s0">*/</span>

<span class="s0">1960 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 1954 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1961 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 1962 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1962 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 1963 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1963 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1964 9 BamWriter 0 26625 9 BamWriter 9 BamWriter 0 0 0 1 1152 1153 6 2339 2340 2341 2342 2343 2344 16 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 0 0 1 0 1950 0 0 0 0 1376</span>
<span class="s0">/**</span>
 <span class="s0">* This is the fundamental interface for writing binary objects to a Bam file,</span>
 <span class="s0">* to be extracted later by a BamReader.</span>
 <span class="s0">*</span>
 <span class="s0">* A Bam file can be thought of as a linear collection of objects.  Each</span>
 <span class="s0">* object is an instance of a class that inherits, directly or indirectly,</span>
 <span class="s0">* from TypedWritable.  The objects may include pointers to other objects; the</span>
 <span class="s0">* BamWriter automatically manages these (with help from code within each</span>
 <span class="s0">* class) and writes all referenced objects to the file in such a way that the</span>
 <span class="s0">* pointers may be correctly restored later.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the abstract interface and does not specifically deal with disk</span>
 <span class="s0">* files, but rather with a DatagramSink of some kind, which simply accepts a</span>
 <span class="s0">* linear stream of Datagrams.  It is probably written to a disk file, but it</span>
 <span class="s0">* might conceivably be streamed directly to a network or some such nonsense.</span>
 <span class="s0">*</span>
 <span class="s0">* Bam files are most often used to store scene graphs or subgraphs, and by</span>
 <span class="s0">* convention they are given filenames ending in the extension &quot;.bam&quot; when</span>
 <span class="s0">* they are used for this purpose.  However, a Bam file may store any</span>
 <span class="s0">* arbitrary list of TypedWritable objects; in this more general usage, they</span>
 <span class="s0">* are given filenames ending in &quot;.boo&quot; to differentiate them from the more</span>
 <span class="s0">* common scene graph files.</span>
 <span class="s0">*</span>
 <span class="s0">* See also BamFile, which defines a higher-level interface to read and write</span>
 <span class="s0">* Bam files on disk.</span>
 <span class="s0">*/</span>

<span class="s0">1965 14 DatagramSink * 0 8576 14 DatagramSink * 14 DatagramSink * 0 0 1966 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1966 12 DatagramSink 0 2048 12 DatagramSink 12 DatagramSink 0 0 0 0 0 0 0 0 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* This class defines the abstract interface to sending datagrams to any</span>
 <span class="s0">* target, whether it be into a file or across the net</span>
 <span class="s0">*/</span>

<span class="s0">1967 23 BitMask&lt; uint16_t, 16 &gt; 0 141313 23 BitMask&lt; uint16_t, 16 &gt; 23 BitMask&lt; uint16_t, 16 &gt; 0 0 0 1 1170 1233 0 62 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 0 0 0 0 0 0</span>

<span class="s0">1968 9 BitMask16 0 2105345 9 BitMask16 9 BitMask16 0 0 1967 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1969 23 BitMask&lt; uint32_t, 32 &gt; 0 141313 23 BitMask&lt; uint32_t, 32 &gt; 23 BitMask&lt; uint32_t, 32 &gt; 0 0 0 1 1234 1297 0 62 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 0 0 0 0 0 0</span>

<span class="s0">1970 9 BitMask32 0 2105345 9 BitMask32 9 BitMask32 0 0 1969 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1971 23 BitMask&lt; uint64_t, 64 &gt; 0 141313 23 BitMask&lt; uint64_t, 64 &gt; 23 BitMask&lt; uint64_t, 64 &gt; 0 0 0 1 1298 1361 0 62 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 0 0 0 0 0 0</span>

<span class="s0">1972 9 BitMask64 0 2105345 9 BitMask64 9 BitMask64 0 0 1971 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1973 13 BitMaskNative 0 1 13 BitMaskNative 13 BitMaskNative 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1974 8 BitArray 0 141313 8 BitArray 8 BitArray 0 0 0 1 1362 1421 0 58 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 0 0 0 0 1 1975 210</span>
<span class="s0">/**</span>
 <span class="s0">* A dynamic array with an unlimited number of bits.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to a BitMask, except it appears to contain an infinite</span>
 <span class="s0">* number of bits.  You can use it very much as you would use a BitMask.</span>
 <span class="s0">*/</span>

<span class="s0">1975 0 0 794624 10 BitArray:: 0 1974 0 0 0 0 0 0 0 0 0 1 17 num_bits_per_word 27 BitArray::num_bits_per_word 0</span>
<span class="s0">64 0 0</span>

<span class="s0">1976 12 ButtonHandle 0 16918529 12 ButtonHandle 12 ButtonHandle 0 0 0 1 1422 1441 4 2345 2346 2347 2348 17 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1440 0 1 1439 0 0 0 162</span>
<span class="s0">/**</span>
 <span class="s0">* A ButtonHandle represents a single button from any device, including</span>
 <span class="s0">* keyboard buttons and mouse buttons (but see KeyboardButton and</span>
 <span class="s0">* MouseButton).</span>
 <span class="s0">*/</span>

<span class="s0">1977 6 string 0 2105344 11 std::string 11 std::string 0 0 1978 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1978 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1979 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1980 14 ButtonRegistry 0 141313 14 ButtonRegistry 14 ButtonRegistry 0 0 0 1 1447 1448 0 5 1442 1443 1444 1445 1446 0 0 0 0 0 188</span>
<span class="s0">/**</span>
 <span class="s0">* The ButtonRegistry class maintains all the assigned ButtonHandles in a</span>
 <span class="s0">* given system.  There should be only one ButtonRegistry class during the</span>
 <span class="s0">* lifetime of the application.</span>
 <span class="s0">*/</span>

<span class="s0">1981 9 ButtonMap 0 141313 9 ButtonMap 9 ButtonMap 0 0 0 1 1456 1457 0 7 1449 1450 1451 1452 1453 1454 1455 0 0 1 0 1982 0 0 0 0 328</span>
<span class="s0">/**</span>
 <span class="s0">* This class represents a map containing all of the buttons of a (keyboard)</span>
 <span class="s0">* device, though it can also be used as a generic mapping between</span>
 <span class="s0">* ButtonHandles.  It maps an underlying 'raw' button to a 'virtual' button,</span>
 <span class="s0">* which may optionally be associated with an appropriate platform-specific</span>
 <span class="s0">* name for the button.</span>
 <span class="s0">*/</span>

<span class="s0">1982 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">1983 14 CallbackObject 0 141313 14 CallbackObject 14 CallbackObject 0 0 0 1 1461 1462 0 3 1458 1459 1460 0 0 1 0 1982 0 0 0 0 276</span>
<span class="s0">/**</span>
 <span class="s0">* This is a generic object that can be assigned to a callback at various</span>
 <span class="s0">* points in the rendering process.  This is actually a base class for a</span>
 <span class="s0">* handful of specialized callback object types.  You can also subclass it</span>
 <span class="s0">* yourself to make your own callback handler.</span>
 <span class="s0">*/</span>

<span class="s0">1984 33 CachedTypedWritableReferenceCount 0 43009 33 CachedTypedWritableReferenceCount 33 CachedTypedWritableReferenceCount 0 0 0 0 0 1 2349 5 1463 1464 1465 1466 1467 0 0 1 0 1941 0 0 0 0 722</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special extension to ReferenceCount that includes dual reference</span>
 <span class="s0">* counts: the standard reference count number, which includes all references</span>
 <span class="s0">* to the object, and a separate number (the cache reference count) that</span>
 <span class="s0">* counts the number of references to the object just within its cache alone.</span>
 <span class="s0">* When get_ref_count() == get_cache_ref_count(), the object is not referenced</span>
 <span class="s0">* outside the cache.</span>
 <span class="s0">*</span>
 <span class="s0">* The cache refs must be explicitly maintained; there is no PointerTo&lt;&gt; class</span>
 <span class="s0">* to maintain the cache reference counts automatically.  The cache reference</span>
 <span class="s0">* count is automatically included in the overall reference count: calling</span>
 <span class="s0">* cache_ref() and cache_unref() automatically calls ref() and unref().</span>
 <span class="s0">*/</span>

<span class="s0">1985 12 CallbackData 0 141313 12 CallbackData 12 CallbackData 0 0 0 0 1471 0 3 1468 1469 1470 0 0 1 0 1940 0 0 0 0 348</span>
<span class="s0">/**</span>
 <span class="s0">* This is a generic data block that is passed along to a CallbackObject when</span>
 <span class="s0">* a callback is made.  It contains data specific to the particular callback</span>
 <span class="s0">* type in question.</span>
 <span class="s0">*</span>
 <span class="s0">* This is actually an abstract base class and contains no data.</span>
 <span class="s0">* Specializations of this class will contain the actual data relevant to each</span>
 <span class="s0">* callback type.</span>
 <span class="s0">*/</span>

<span class="s0">1986 20 PythonCallbackObject 0 75777 20 PythonCallbackObject 20 PythonCallbackObject 0 0 0 1 1472 1462 1 2350 6 1473 1474 1475 1476 1477 1478 0 0 1 0 1983 0 0 0 0 157</span>
<span class="s0">/**</span>
 <span class="s0">* This is a specialization on CallbackObject to allow a callback to directly</span>
 <span class="s0">* call an arbitrary Python function.  Powerful!  But use with caution.</span>
 <span class="s0">*/</span>

<span class="s0">1987 7 TimeVal 0 141313 7 TimeVal 7 TimeVal 0 0 0 1 1479 1484 1 2351 2 1480 1481 0 0 0 0 0 0</span>

<span class="s0">1988 9 ulong [2] 0 4202496 9 ulong [2] 9 ulong [2] 0 0 1989 2 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1989 5 ulong 0 2105344 5 ulong 5 ulong 0 0 1990 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1990 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1991 11 ClockObject 0 75777 11 ClockObject 11 ClockObject 0 0 0 1 1485 0 11 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 28 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 0 0 1 0 1942 0 0 0 1 1992 1000</span>
<span class="s0">/**</span>
 <span class="s0">* A ClockObject keeps track of elapsed real time and discrete time.  In</span>
 <span class="s0">* normal mode, get_frame_time() returns the time as of the last time tick()</span>
 <span class="s0">* was called.  This is the &quot;discrete&quot; time, and is usually used to get the</span>
 <span class="s0">* time as of, for instance, the beginning of the current frame.</span>
 <span class="s0">*</span>
 <span class="s0">* In other modes, as set by set_mode() or the clock-mode config variable,</span>
 <span class="s0">* get_frame_time() may return other values to simulate different timing</span>
 <span class="s0">* effects, for instance to perform non-real-time animation.  See set_mode().</span>
 <span class="s0">*</span>
 <span class="s0">* In all modes, get_real_time() always returns the elapsed real time in</span>
 <span class="s0">* seconds since the ClockObject was constructed, or since it was last reset.</span>
 <span class="s0">*</span>
 <span class="s0">* You can create your own ClockObject whenever you want to have your own</span>
 <span class="s0">* local timer.  There is also a default, global ClockObject intended to</span>
 <span class="s0">* represent global time for the application; this is normally set up to tick</span>
 <span class="s0">* every frame so that its get_frame_time() will return the time for the</span>
 <span class="s0">* current frame.</span>
 <span class="s0">*/</span>

<span class="s0">1992 4 Mode 0 794624 17 ClockObject::Mode 17 ClockObject::Mode 1991 0 0 0 0 0 0 0 0 0 8 8 M_normal 21 ClockObject::M_normal 0</span>
<span class="s0">0 15 M_non_real_time 28 ClockObject::M_non_real_time 0</span>
<span class="s0">1 8 M_forced 21 ClockObject::M_forced 0</span>
<span class="s0">2 9 M_degrade 22 ClockObject::M_degrade 0</span>
<span class="s0">3 7 M_slave 20 ClockObject::M_slave 0</span>
<span class="s0">4 9 M_limited 22 ClockObject::M_limited 0</span>
<span class="s0">5 9 M_integer 22 ClockObject::M_integer 0</span>
<span class="s0">6 17 M_integer_limited 30 ClockObject::M_integer_limited 0</span>
<span class="s0">7 0 0</span>

<span class="s0">1993 11 CollideMask 0 2105345 11 CollideMask 11 CollideMask 0 0 1970 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1994 10 ColorSpace 0 532481 10 ColorSpace 10 ColorSpace 0 0 0 0 0 0 0 0 0 0 4 14 CS_unspecified 14 CS_unspecified 105</span>
<span class="s0">// This value is not a color space, but is used to indicate that a color</span>
<span class="s0">// space has not been specified.</span>
<span class="s0">0 9 CS_linear 9 CS_linear 389</span>
<span class="s0">// CS_linear is not a color space per se, but represents the working color</span>
<span class="s0">// space of graphics APIs, which is linearized.  Since the conversion from</span>
<span class="s0">// sRGB to linear is defined, one could posit that it has the ITU-R BT.709</span>
<span class="s0">// primaries, but this isn't meaningful as modern graphics APIs do not</span>
<span class="s0">// perform color management.  All colors in Panda3D are linear unless</span>
<span class="s0">// otherwise specified.</span>
<span class="s0">1 7 CS_sRGB 7 CS_sRGB 107</span>
<span class="s0">// This is the standard, gamma-2.2-corrected sRGB color space, as used by</span>
<span class="s0">// the majority of image formats.</span>
<span class="s0">2 8 CS_scRGB 8 CS_scRGB 110</span>
<span class="s0">// This is a 16-bit encoded linear color space capable of encoding color</span>
<span class="s0">// values in the -0.5...7.4999 range.</span>
<span class="s0">3 0 0</span>

<span class="s0">1995 17 CopyOnWriteObject 0 141313 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 1521 0 3 1518 1519 1520 0 0 1 0 1984 0 0 0 0 169</span>
<span class="s0">/**</span>
 <span class="s0">* This base class provides basic reference counting, but also can be used</span>
 <span class="s0">* with a CopyOnWritePointer to provide get_read_pointer() and</span>
 <span class="s0">* get_write_pointer().</span>
 <span class="s0">*/</span>

<span class="s0">1996 14 DatagramBuffer 0 141313 14 DatagramBuffer 14 DatagramBuffer 0 0 0 1 1526 1530 1 2363 1 1527 0 0 2 3 1966 1522 1523 3 1959 1524 1525 0 0 355</span>
<span class="s0">/**</span>
 <span class="s0">* This class can be used to write a series of datagrams into a memory buffer.</span>
 <span class="s0">* It acts as both a datagram sink and generator; you can fill it up with</span>
 <span class="s0">* datagrams and then read as many datagrams from it.</span>
 <span class="s0">*</span>
 <span class="s0">* This uses the same format as DatagramInputFile and DatagramOutputFile,</span>
 <span class="s0">* meaning that Datagram sizes are always stored little-endian.</span>
 <span class="s0">*/</span>

<span class="s0">1997 18 vector_uchar const 0 8832 18 vector_uchar const 18 vector_uchar const 0 0 1998 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1998 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 1999 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1999 24 pvector&lt; unsigned char &gt; 0 2048 24 pvector&lt; unsigned char &gt; 24 pvector&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2000 17 DatagramInputFile 0 75777 17 DatagramInputFile 17 DatagramInputFile 0 0 0 1 1531 0 0 4 1532 1533 1534 1535 0 0 1 0 1959 0 0 0 0 130</span>
<span class="s0">/**</span>
 <span class="s0">* This class can be used to read a binary file that consists of an arbitrary</span>
 <span class="s0">* header followed by a number of datagrams.</span>
 <span class="s0">*/</span>

<span class="s0">2001 18 DatagramOutputFile 0 75777 18 DatagramOutputFile 18 DatagramOutputFile 0 0 0 1 1536 0 1 2364 3 1537 1538 1539 0 0 1 0 1966 0 0 0 0 131</span>
<span class="s0">/**</span>
 <span class="s0">* This class can be used to write a binary file that consists of an arbitrary</span>
 <span class="s0">* header followed by a number of datagrams.</span>
 <span class="s0">*/</span>

<span class="s0">2002 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2003 30 DoubleBitMask&lt; BitMaskNative &gt; 0 141313 30 DoubleBitMask&lt; BitMaskNative &gt; 30 DoubleBitMask&lt; BitMaskNative &gt; 0 0 0 1 1541 1594 0 52 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 0 0 0 0 0 0</span>

<span class="s0">2004 19 DoubleBitMaskNative 0 2105345 19 DoubleBitMaskNative 19 DoubleBitMaskNative 0 0 2003 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2005 36 DoubleBitMask&lt; DoubleBitMaskNative &gt; 0 141313 36 DoubleBitMask&lt; DoubleBitMaskNative &gt; 36 DoubleBitMask&lt; DoubleBitMaskNative &gt; 0 0 0 1 1595 1648 0 52 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 0 0 0 0 0 0</span>

<span class="s0">2006 17 QuadBitMaskNative 0 2105345 17 QuadBitMaskNative 17 QuadBitMaskNative 0 0 2005 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2007 8 DrawMask 0 2105345 8 DrawMask 8 DrawMask 0 0 1970 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2008 13 GamepadButton 0 141313 13 GamepadButton 13 GamepadButton 0 0 0 1 1680 1681 0 31 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 0 0 0 0 0 155</span>
<span class="s0">/**</span>
 <span class="s0">* This class is just used as a convenient namespace for grouping all of these</span>
 <span class="s0">* handy functions that return buttons which map to gamepad buttons.</span>
 <span class="s0">*/</span>

<span class="s0">2009 14 KeyboardButton 0 141313 14 KeyboardButton 14 KeyboardButton 0 0 0 1 1734 1735 0 52 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 0 0 0 0 0 162</span>
<span class="s0">/**</span>
 <span class="s0">* This class is just used as a convenient namespace for grouping all of these</span>
 <span class="s0">* handy functions that return buttons which map to standard keyboard keys.</span>
 <span class="s0">*/</span>

<span class="s0">2010 15 ModifierButtons 0 26625 15 ModifierButtons 15 ModifierButtons 0 0 0 1 1740 1741 1 2365 23 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1 2388 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* This class monitors the state of a number of individual buttons and tracks</span>
 <span class="s0">* whether each button is known to be down or up.</span>
 <span class="s0">*/</span>

<span class="s0">2011 11 MouseButton 0 141313 11 MouseButton 11 MouseButton 0 0 0 1 1776 1777 0 11 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 0 0 0 0 0 162</span>
<span class="s0">/**</span>
 <span class="s0">* This class is just used as a convenient namespace for grouping all of these</span>
 <span class="s0">* handy functions that return buttons which map to standard mouse buttons.</span>
 <span class="s0">*/</span>

<span class="s0">2012 11 PointerType 0 8921089 11 PointerType 11 PointerType 0 0 0 0 0 0 0 0 0 0 5 7 unknown 7 unknown 0</span>
<span class="s0">0 5 mouse 5 mouse 0</span>
<span class="s0">1 6 finger 6 finger 0</span>
<span class="s0">2 6 stylus 6 stylus 0</span>
<span class="s0">3 6 eraser 6 eraser 0</span>
<span class="s0">4 0 48</span>
<span class="s0">/**</span>
 <span class="s0">* Contains the types of pointer device.</span>
 <span class="s0">*/</span>

<span class="s0">2013 11 PointerData 0 141313 11 PointerData 11 PointerData 0 0 0 1 1784 1785 6 2366 2367 2368 2369 2370 2371 3 1778 1779 1780 0 0 0 0 0 124</span>
<span class="s0">/**</span>
 <span class="s0">* Holds the data that might be generated by a 2-d pointer input device, such</span>
 <span class="s0">* as the mouse in the GraphicsWindow.</span>
 <span class="s0">*/</span>

<span class="s0">2014 9 MouseData 0 2105345 9 MouseData 9 MouseData 0 0 2013 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2015 24 NodeCachedReferenceCount 0 43009 24 NodeCachedReferenceCount 24 NodeCachedReferenceCount 0 0 0 0 0 0 6 1786 1787 1788 1789 1790 1791 0 0 1 0 1984 0 0 0 1 2016 1495</span>
<span class="s0">/**</span>
 <span class="s0">* This class further specializes CachedTypedWritableReferenceCount to also</span>
 <span class="s0">* add a node_ref_count, for the purposes of counting the number of times the</span>
 <span class="s0">* object is referenced by a &quot;node&quot;, presumably a PandaNode.</span>
 <span class="s0">*</span>
 <span class="s0">* This essentially combines the functionality of NodeReferenceCount and</span>
 <span class="s0">* CachedTypedWritableReferenceCount, so that a derivative of this object</span>
 <span class="s0">* actually has three counters: the standard reference count, the &quot;cache&quot;</span>
 <span class="s0">* reference count, and the &quot;node&quot; reference count.  Rather than multiply</span>
 <span class="s0">* inheriting from the two reference count classes, we inherit only from</span>
 <span class="s0">* CachedTypedWritableReferenceCount and simply duplicate the functionality of</span>
 <span class="s0">* NodeReferenceCount, to avoid all of the problems associated with multiple</span>
 <span class="s0">* inheritance.</span>
 <span class="s0">*</span>
 <span class="s0">* The intended design is to use this as a base class for RenderState and</span>
 <span class="s0">* TransformState, both of which are held by PandaNodes, and also have caches</span>
 <span class="s0">* which are independently maintained.  By keeping track of how many nodes</span>
 <span class="s0">* hold a pointer to a particular object, we can classify each object into</span>
 <span class="s0">* node-referenced, cache-referenced, or other, which is primarily useful for</span>
 <span class="s0">* PStats reporting.</span>
 <span class="s0">*</span>
 <span class="s0">* As with CachedTypedWritableReferenceCount's cache_ref() and cache_unref(),</span>
 <span class="s0">* the new methods node_ref() and node_unref() automatically increment and</span>
 <span class="s0">* decrement the primary reference count as well.  In this case, however,</span>
 <span class="s0">* there does exist a NodePointerTo&lt;&gt; class to maintain the node_ref counters</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*/</span>

<span class="s0">2016 10 Referenced 0 794624 36 NodeCachedReferenceCount::Referenced 36 NodeCachedReferenceCount::Referenced 2015 0 0 0 0 0 0 0 0 0 2 6 R_node 32 NodeCachedReferenceCount::R_node 0</span>
<span class="s0">1 7 R_cache 33 NodeCachedReferenceCount::R_cache 0</span>
<span class="s0">2 0 0</span>

<span class="s0">2017 11 SparseArray 0 141313 11 SparseArray 11 SparseArray 0 0 0 1 1792 1846 0 53 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 0 0 0 0 0 736</span>
<span class="s0">/**</span>
 <span class="s0">* This class records a set of integers, where each integer is either present</span>
 <span class="s0">* or not present in the set.</span>
 <span class="s0">*</span>
 <span class="s0">* It is similar in principle and in interface to a BitArray (which can be</span>
 <span class="s0">* thought of as a set of integers, one integer corresponding to each</span>
 <span class="s0">* different bit position), but the SparseArray is implemented as a list of</span>
 <span class="s0">* min/max subrange lists, rather than as a bitmask.</span>
 <span class="s0">*</span>
 <span class="s0">* This makes it particularly efficient for storing sets which consist of</span>
 <span class="s0">* large sections of consecutively included or consecutively excluded</span>
 <span class="s0">* elements, with arbitrarily large integers, but particularly inefficient for</span>
 <span class="s0">* doing boolean operations such as &amp; or |.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, unlike BitArray, the SparseArray can store negative integers.</span>
 <span class="s0">*/</span>

<span class="s0">2018 14 ParamValueBase 0 75777 14 ParamValueBase 14 ParamValueBase 0 0 0 0 1064 0 3 1847 1848 1849 0 0 1 0 1941 0 0 0 0 141</span>
<span class="s0">/**</span>
 <span class="s0">* A non-template base class of ParamValue (below), which serves mainly to</span>
 <span class="s0">* define the placeholder for the virtual output function.</span>
 <span class="s0">*/</span>

<span class="s0">2019 18 ParamTypedRefCount 0 75777 18 ParamTypedRefCount 18 ParamTypedRefCount 0 0 0 1 1850 1064 1 2372 2 1851 1852 0 0 1 0 2018 0 0 0 0 143</span>
<span class="s0">/**</span>
 <span class="s0">* A class object for storing specifically objects of type</span>
 <span class="s0">* TypedReferenceCount, which is different than TypedWritableReferenceCount.</span>
 <span class="s0">*/</span>

<span class="s0">2020 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 1982 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2021 20 ParamValue&lt; string &gt; 0 75777 25 ParamValue&lt; std::string &gt; 25 ParamValue&lt; std::string &gt; 0 0 0 1 1853 1064 1 2373 3 1854 1855 1856 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2022 10 Type const 0 8832 10 Type const 10 Type const 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2023 11 ParamString 0 2105345 11 ParamString 11 ParamString 0 0 2021 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2024 21 ParamValue&lt; wstring &gt; 0 75777 26 ParamValue&lt; std::wstring &gt; 26 ParamValue&lt; std::wstring &gt; 0 0 0 1 1857 1064 1 2374 3 1858 1859 1860 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2025 12 ParamWstring 0 2105345 12 ParamWstring 12 ParamWstring 0 0 2024 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2026 24 ParamValue&lt; LVecBase2d &gt; 0 75777 24 ParamValue&lt; LVecBase2d &gt; 24 ParamValue&lt; LVecBase2d &gt; 0 0 0 1 1861 1064 1 2375 3 1862 1863 1864 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2027 14 ParamVecBase2d 0 2105345 14 ParamVecBase2d 14 ParamVecBase2d 0 0 2026 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2028 24 ParamValue&lt; LVecBase2f &gt; 0 75777 24 ParamValue&lt; LVecBase2f &gt; 24 ParamValue&lt; LVecBase2f &gt; 0 0 0 1 1865 1064 1 2376 3 1866 1867 1868 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2029 14 ParamVecBase2f 0 2105345 14 ParamVecBase2f 14 ParamVecBase2f 0 0 2028 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2030 24 ParamValue&lt; LVecBase2i &gt; 0 75777 24 ParamValue&lt; LVecBase2i &gt; 24 ParamValue&lt; LVecBase2i &gt; 0 0 0 1 1869 1064 1 2377 3 1870 1871 1872 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2031 14 ParamVecBase2i 0 2105345 14 ParamVecBase2i 14 ParamVecBase2i 0 0 2030 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2032 24 ParamValue&lt; LVecBase3d &gt; 0 75777 24 ParamValue&lt; LVecBase3d &gt; 24 ParamValue&lt; LVecBase3d &gt; 0 0 0 1 1873 1064 1 2378 3 1874 1875 1876 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2033 14 ParamVecBase3d 0 2105345 14 ParamVecBase3d 14 ParamVecBase3d 0 0 2032 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2034 24 ParamValue&lt; LVecBase3f &gt; 0 75777 24 ParamValue&lt; LVecBase3f &gt; 24 ParamValue&lt; LVecBase3f &gt; 0 0 0 1 1877 1064 1 2379 3 1878 1879 1880 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2035 14 ParamVecBase3f 0 2105345 14 ParamVecBase3f 14 ParamVecBase3f 0 0 2034 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2036 24 ParamValue&lt; LVecBase3i &gt; 0 75777 24 ParamValue&lt; LVecBase3i &gt; 24 ParamValue&lt; LVecBase3i &gt; 0 0 0 1 1881 1064 1 2380 3 1882 1883 1884 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2037 14 ParamVecBase3i 0 2105345 14 ParamVecBase3i 14 ParamVecBase3i 0 0 2036 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2038 24 ParamValue&lt; LVecBase4d &gt; 0 75777 24 ParamValue&lt; LVecBase4d &gt; 24 ParamValue&lt; LVecBase4d &gt; 0 0 0 1 1885 1064 1 2381 3 1886 1887 1888 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2039 14 ParamVecBase4d 0 2105345 14 ParamVecBase4d 14 ParamVecBase4d 0 0 2038 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2040 24 ParamValue&lt; LVecBase4f &gt; 0 75777 24 ParamValue&lt; LVecBase4f &gt; 24 ParamValue&lt; LVecBase4f &gt; 0 0 0 1 1889 1064 1 2382 3 1890 1891 1892 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2041 14 ParamVecBase4f 0 2105345 14 ParamVecBase4f 14 ParamVecBase4f 0 0 2040 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2042 24 ParamValue&lt; LVecBase4i &gt; 0 75777 24 ParamValue&lt; LVecBase4i &gt; 24 ParamValue&lt; LVecBase4i &gt; 0 0 0 1 1893 1064 1 2383 3 1894 1895 1896 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2043 14 ParamVecBase4i 0 2105345 14 ParamVecBase4i 14 ParamVecBase4i 0 0 2042 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2044 23 ParamValue&lt; LMatrix3d &gt; 0 75777 23 ParamValue&lt; LMatrix3d &gt; 23 ParamValue&lt; LMatrix3d &gt; 0 0 0 1 1897 1064 1 2384 3 1898 1899 1900 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2045 13 ParamMatrix3d 0 2105345 13 ParamMatrix3d 13 ParamMatrix3d 0 0 2044 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2046 23 ParamValue&lt; LMatrix3f &gt; 0 75777 23 ParamValue&lt; LMatrix3f &gt; 23 ParamValue&lt; LMatrix3f &gt; 0 0 0 1 1901 1064 1 2385 3 1902 1903 1904 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2047 13 ParamMatrix3f 0 2105345 13 ParamMatrix3f 13 ParamMatrix3f 0 0 2046 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2048 23 ParamValue&lt; LMatrix4d &gt; 0 75777 23 ParamValue&lt; LMatrix4d &gt; 23 ParamValue&lt; LMatrix4d &gt; 0 0 0 1 1905 1064 1 2386 3 1906 1907 1908 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2049 13 ParamMatrix4d 0 2105345 13 ParamMatrix4d 13 ParamMatrix4d 0 0 2048 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2050 23 ParamValue&lt; LMatrix4f &gt; 0 75777 23 ParamValue&lt; LMatrix4f &gt; 23 ParamValue&lt; LMatrix4f &gt; 0 0 0 1 1909 1064 1 2387 3 1910 1911 1912 0 0 1 0 2018 0 0 0 0 0</span>

<span class="s0">2051 13 ParamMatrix4f 0 2105345 13 ParamMatrix4f 13 ParamMatrix4f 0 0 2050 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2052 13 ParamVecBase2 0 2105345 13 ParamVecBase2 13 ParamVecBase2 0 0 2029 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2053 13 ParamVecBase3 0 2105345 13 ParamVecBase3 13 ParamVecBase3 0 0 2035 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2054 13 ParamVecBase4 0 2105345 13 ParamVecBase4 13 ParamVecBase4 0 0 2041 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2055 12 ParamMatrix3 0 2105345 12 ParamMatrix3 12 ParamMatrix3 0 0 2047 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2056 12 ParamMatrix4 0 2105345 12 ParamMatrix4 12 ParamMatrix4 0 0 2051 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2057 20 WritableConfigurable 0 141313 20 WritableConfigurable 20 WritableConfigurable 0 0 0 0 1914 0 1 1913 0 0 1 0 1939 0 0 0 0 379</span>
<span class="s0">/**</span>
 <span class="s0">* Defined as a fix to allow creating Configurable and Writable objects.</span>
 <span class="s0">* Otherwise the compiler gets confused since both TypedWritable and</span>
 <span class="s0">* Configurable inherit from TypedObject.</span>
 <span class="s0">*</span>
 <span class="s0">* An object that has data or parameters that are set less frequently (at</span>
 <span class="s0">* least occasionally) than every frame.  We can cache the configuration info</span>
 <span class="s0">* by by using the &quot;dirty&quot; flag.</span>
 <span class="s0">*/</span>

<span class="s0">2058 17 UniqueIdAllocator 0 26625 17 UniqueIdAllocator 17 UniqueIdAllocator 0 0 0 1 1915 1916 0 6 1917 1918 1919 1920 1921 1922 0 0 0 0 0 812</span>
<span class="s0">/**</span>
 <span class="s0">* Manage a set of ID values from min to max inclusive.  The ID numbers that</span>
 <span class="s0">* are freed will be allocated (reused) in the same order.  I.e.  the oldest</span>
 <span class="s0">* ID numbers will be allocated.</span>
 <span class="s0">*</span>
 <span class="s0">* This implementation will use 4 bytes per id number, plus a few bytes of</span>
 <span class="s0">* management data.  e.g.  10,000 ID numbers will use 40KB.</span>
 <span class="s0">*</span>
 <span class="s0">* Also be advised that ID -1 and -2 are used internally by the allocator.  If</span>
 <span class="s0">* allocate returns IndexEnd (-1) then the allocator is out of free ID</span>
 <span class="s0">* numbers.</span>
 <span class="s0">*</span>
 <span class="s0">* There are other implementations that can better leverage runs of used or</span>
 <span class="s0">* unused IDs or use bit arrays for the IDs.  But, it takes extra work to</span>
 <span class="s0">* track the age of freed IDs, which is required for what we wanted.  If you</span>
 <span class="s0">* would like to kick around other implementation ideas, please contact</span>
 <span class="s0">* Schuyler.</span>
 <span class="s0">*/</span>

<span class="s0">2059 10 PortalMask 0 2105345 10 PortalMask 10 PortalMask 0 0 1970 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2060 37 ConstPointerToArray&lt; ushort &gt; const * 0 8576 37 ConstPointerToArray&lt; ushort &gt; const * 37 ConstPointerToArray&lt; ushort &gt; const * 0 0 2061 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2061 35 ConstPointerToArray&lt; ushort &gt; const 0 8832 35 ConstPointerToArray&lt; ushort &gt; const 35 ConstPointerToArray&lt; ushort &gt; const 0 0 1925 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2062 31 ConstPointerToArray&lt; ushort &gt; * 0 8576 31 ConstPointerToArray&lt; ushort &gt; * 31 ConstPointerToArray&lt; ushort &gt; * 0 0 1925 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2063 32 PointerToArray&lt; ushort &gt; const * 0 8576 32 PointerToArray&lt; ushort &gt; const * 32 PointerToArray&lt; ushort &gt; const * 0 0 2064 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2064 30 PointerToArray&lt; ushort &gt; const 0 8832 30 PointerToArray&lt; ushort &gt; const 30 PointerToArray&lt; ushort &gt; const 0 0 1929 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2065 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2066 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2067 6 ushort 0 2105344 6 ushort 6 ushort 0 0 2068 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2068 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2069 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 2070 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2070 9 Py_buffer 0 2105344 9 Py_buffer 9 Py_buffer 0 0 2071 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2071 10 bufferinfo 0 1024 10 bufferinfo 10 bufferinfo 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2072 36 PointerToArrayBase&lt; ushort &gt; const * 0 8576 36 PointerToArrayBase&lt; ushort &gt; const * 36 PointerToArrayBase&lt; ushort &gt; const * 0 0 2073 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2073 34 PointerToArrayBase&lt; ushort &gt; const 0 8832 34 PointerToArrayBase&lt; ushort &gt; const 34 PointerToArrayBase&lt; ushort &gt; const 0 0 1926 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2074 51 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; * 0 8576 51 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; * 51 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; * 0 0 1927 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2075 57 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; const * 0 8576 57 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; const * 57 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; const * 0 0 2076 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2076 55 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; const 0 8832 55 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; const 55 PointerToBase&lt; ReferenceCountedVector&lt; ushort &gt; &gt; const 0 0 1927 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2077 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 2002 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2078 26 PointerToArray&lt; ushort &gt; * 0 8576 26 PointerToArray&lt; ushort &gt; * 26 PointerToArray&lt; ushort &gt; * 0 0 1929 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2079 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 2080 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2080 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">2081 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2082 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 1930 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2083 21 AnimInterface const * 0 8576 21 AnimInterface const * 21 AnimInterface const * 0 0 2084 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2084 19 AnimInterface const 0 8832 19 AnimInterface const 19 AnimInterface const 0 0 1930 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2085 11 UpdateSeq * 0 8576 11 UpdateSeq * 11 UpdateSeq * 0 0 1935 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2086 17 UpdateSeq const * 0 8576 17 UpdateSeq const * 17 UpdateSeq const * 0 0 2087 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2087 15 UpdateSeq const 0 8832 15 UpdateSeq const 15 UpdateSeq const 0 0 1935 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2088 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 2089 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2089 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2090 11 BamReader * 0 8576 11 BamReader * 11 BamReader * 0 0 1957 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2091 21 TypedWritable const * 0 8576 21 TypedWritable const * 21 TypedWritable const * 0 0 2092 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2092 19 TypedWritable const 0 8832 19 TypedWritable const 19 TypedWritable const 0 0 1939 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2093 14 vector_uchar * 0 8576 14 vector_uchar * 14 vector_uchar * 0 0 1998 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2094 11 BamWriter * 0 8576 11 BamWriter * 11 BamWriter * 0 0 1964 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2095 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 1941 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2096 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 1942 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2097 22 BamCacheRecord const * 0 8576 22 BamCacheRecord const * 22 BamCacheRecord const * 0 0 2098 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2098 20 BamCacheRecord const 0 8832 20 BamCacheRecord const 20 BamCacheRecord const 0 0 1943 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2099 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 1943 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2100 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 1945 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2101 19 VirtualFile const * 0 8576 19 VirtualFile const * 19 VirtualFile const * 0 0 2102 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2102 17 VirtualFile const 0 8832 17 VirtualFile const 17 VirtualFile const 0 0 2103 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2103 11 VirtualFile 0 2048 11 VirtualFile 11 VirtualFile 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2104 10 BamCache * 0 8576 10 BamCache * 10 BamCache * 0 0 1949 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2105 16 BamCache const * 0 8576 16 BamCache const * 16 BamCache const * 0 0 2106 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2106 14 BamCache const 0 8832 14 BamCache const 14 BamCache const 0 0 1949 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2107 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 1946 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2108 10 BamEnums * 0 8576 10 BamEnums * 10 BamEnums * 0 0 1950 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2109 16 BamEnums const * 0 8576 16 BamEnums const * 16 BamEnums const * 0 0 2110 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2110 14 BamEnums const 0 8832 14 BamEnums const 14 BamEnums const 0 0 1950 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2111 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 1960 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2112 15 LoaderOptions * 0 8576 15 LoaderOptions * 15 LoaderOptions * 0 0 1954 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2113 9 AuxData * 0 8576 20 BamReader::AuxData * 20 BamReader::AuxData * 0 0 2114 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2114 7 AuxData 0 1312768 18 BamReader::AuxData 18 BamReader::AuxData 1957 0 0 0 0 0 0 0 0 0 0 0 187</span>
<span class="s0">// Inherit from this class to piggyback additional temporary data on the</span>
<span class="s0">// bamReader (via set_aux_data() and get_aux_data()) for any particular</span>
<span class="s0">// objects during the bam reading process.</span>

<span class="s0">2115 17 BamReader const * 0 8576 17 BamReader const * 17 BamReader const * 0 0 2116 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2116 15 BamReader const 0 8832 15 BamReader const 15 BamReader const 0 0 1957 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2117 17 BamWriter const * 0 8576 17 BamWriter const * 17 BamWriter const * 0 0 2118 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2118 15 BamWriter const 0 8832 15 BamWriter const 15 BamWriter const 0 0 1964 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2119 25 BitMask&lt; uint16_t, 16 &gt; * 0 8576 25 BitMask&lt; uint16_t, 16 &gt; * 25 BitMask&lt; uint16_t, 16 &gt; * 0 0 1967 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2120 31 BitMask&lt; uint16_t, 16 &gt; const * 0 8576 31 BitMask&lt; uint16_t, 16 &gt; const * 31 BitMask&lt; uint16_t, 16 &gt; const * 0 0 2121 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2121 29 BitMask&lt; uint16_t, 16 &gt; const 0 8832 29 BitMask&lt; uint16_t, 16 &gt; const 29 BitMask&lt; uint16_t, 16 &gt; const 0 0 1967 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2122 8 uint16_t 0 2105344 8 uint16_t 8 uint16_t 0 0 2068 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2123 25 BitMask&lt; uint32_t, 32 &gt; * 0 8576 25 BitMask&lt; uint32_t, 32 &gt; * 25 BitMask&lt; uint32_t, 32 &gt; * 0 0 1969 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2124 31 BitMask&lt; uint32_t, 32 &gt; const * 0 8576 31 BitMask&lt; uint32_t, 32 &gt; const * 31 BitMask&lt; uint32_t, 32 &gt; const * 0 0 2125 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2125 29 BitMask&lt; uint32_t, 32 &gt; const 0 8832 29 BitMask&lt; uint32_t, 32 &gt; const 29 BitMask&lt; uint32_t, 32 &gt; const 0 0 1969 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2126 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 2127 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2127 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2128 25 BitMask&lt; uint64_t, 64 &gt; * 0 8576 25 BitMask&lt; uint64_t, 64 &gt; * 25 BitMask&lt; uint64_t, 64 &gt; * 0 0 1971 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2129 31 BitMask&lt; uint64_t, 64 &gt; const * 0 8576 31 BitMask&lt; uint64_t, 64 &gt; const * 31 BitMask&lt; uint64_t, 64 &gt; const * 0 0 2130 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2130 29 BitMask&lt; uint64_t, 64 &gt; const 0 8832 29 BitMask&lt; uint64_t, 64 &gt; const 29 BitMask&lt; uint64_t, 64 &gt; const 0 0 1971 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2131 8 uint64_t 0 2105344 8 uint64_t 8 uint64_t 0 0 2066 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2132 10 BitArray * 0 8576 10 BitArray * 10 BitArray * 0 0 1974 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2133 16 BitArray const * 0 8576 16 BitArray const * 16 BitArray const * 0 0 2134 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2134 14 BitArray const 0 8832 14 BitArray const 14 BitArray const 0 0 1974 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2135 8 WordType 0 2367488 18 BitArray::WordType 18 BitArray::WordType 1974 0 2131 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2136 19 SparseArray const * 0 8576 19 SparseArray const * 19 SparseArray const * 0 0 2137 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2137 17 SparseArray const 0 8832 17 SparseArray const 17 SparseArray const 0 0 2017 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2138 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 2066 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2139 8 MaskType 0 2367488 18 BitArray::MaskType 18 BitArray::MaskType 1974 0 1973 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2140 10 MaskType * 0 8576 20 BitArray::MaskType * 20 BitArray::MaskType * 0 0 2139 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2141 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 1976 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2142 20 ButtonHandle const * 0 8576 20 ButtonHandle const * 20 ButtonHandle const * 0 0 2143 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2143 18 ButtonHandle const 0 8832 18 ButtonHandle const 18 ButtonHandle const 0 0 1976 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2144 22 ButtonRegistry const * 0 8576 22 ButtonRegistry const * 22 ButtonRegistry const * 0 0 2145 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2145 20 ButtonRegistry const 0 8832 20 ButtonRegistry const 20 ButtonRegistry const 0 0 1980 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2146 16 ButtonRegistry * 0 8576 16 ButtonRegistry * 16 ButtonRegistry * 0 0 1980 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2147 11 ButtonMap * 0 8576 11 ButtonMap * 11 ButtonMap * 0 0 1981 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2148 17 ButtonMap const * 0 8576 17 ButtonMap const * 17 ButtonMap const * 0 0 2149 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2149 15 ButtonMap const 0 8832 15 ButtonMap const 15 ButtonMap const 0 0 1981 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2150 22 CallbackObject const * 0 8576 22 CallbackObject const * 22 CallbackObject const * 0 0 2151 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2151 20 CallbackObject const 0 8832 20 CallbackObject const 20 CallbackObject const 0 0 1983 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2152 16 CallbackObject * 0 8576 16 CallbackObject * 16 CallbackObject * 0 0 1983 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2153 41 CachedTypedWritableReferenceCount const * 0 8576 41 CachedTypedWritableReferenceCount const * 41 CachedTypedWritableReferenceCount const * 0 0 2154 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2154 39 CachedTypedWritableReferenceCount const 0 8832 39 CachedTypedWritableReferenceCount const 39 CachedTypedWritableReferenceCount const 0 0 1984 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2155 20 CallbackData const * 0 8576 20 CallbackData const * 20 CallbackData const * 0 0 2156 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2156 18 CallbackData const 0 8832 18 CallbackData const 18 CallbackData const 0 0 1985 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2157 14 CallbackData * 0 8576 14 CallbackData * 14 CallbackData * 0 0 1985 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2158 22 PythonCallbackObject * 0 8576 22 PythonCallbackObject * 22 PythonCallbackObject * 0 0 1986 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2159 28 PythonCallbackObject const * 0 8576 28 PythonCallbackObject const * 28 PythonCallbackObject const * 0 0 2160 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2160 26 PythonCallbackObject const 0 8832 26 PythonCallbackObject const 26 PythonCallbackObject const 0 0 1986 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2161 9 TimeVal * 0 8576 9 TimeVal * 9 TimeVal * 0 0 1987 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2162 15 TimeVal const * 0 8576 15 TimeVal const * 15 TimeVal const * 0 0 2163 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2163 13 TimeVal const 0 8832 13 TimeVal const 13 TimeVal const 0 0 1987 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2164 19 ClockObject const * 0 8576 19 ClockObject const * 19 ClockObject const * 0 0 2165 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2165 17 ClockObject const 0 8832 17 ClockObject const 17 ClockObject const 0 0 1991 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2166 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 1991 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2167 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 2168 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2168 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 396</span>
<span class="s0">/**</span>
 <span class="s0">* A thread; that is, a lightweight process.  This is an abstract base class;</span>
 <span class="s0">* to use it, you must subclass from it and redefine thread_main().</span>
 <span class="s0">*</span>
 <span class="s0">* The thread itself will keep a reference count on the Thread object while it</span>
 <span class="s0">* is running; when the thread returns from its root function, the Thread</span>
 <span class="s0">* object will automatically be destructed if no other pointers are</span>
 <span class="s0">* referencing it.</span>
 <span class="s0">*/</span>

<span class="s0">2169 25 CopyOnWriteObject const * 0 8576 25 CopyOnWriteObject const * 25 CopyOnWriteObject const * 0 0 2170 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2170 23 CopyOnWriteObject const 0 8832 23 CopyOnWriteObject const 23 CopyOnWriteObject const 0 0 1995 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2171 16 DatagramBuffer * 0 8576 16 DatagramBuffer * 16 DatagramBuffer * 0 0 1996 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2172 19 DatagramInputFile * 0 8576 19 DatagramInputFile * 19 DatagramInputFile * 0 0 2000 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2173 21 FileReference const * 0 8576 21 FileReference const * 21 FileReference const * 0 0 2174 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2174 19 FileReference const 0 8832 19 FileReference const 19 FileReference const 0 0 2175 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2175 13 FileReference 0 2048 13 FileReference 13 FileReference 0 0 0 0 0 0 0 0 0 0 0 0 149</span>
<span class="s0">/**</span>
 <span class="s0">* Keeps a reference-counted pointer to a file on disk.  As long as the</span>
 <span class="s0">* FileReference is held, someone presumably has a use for this file.</span>
 <span class="s0">*/</span>

<span class="s0">2176 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 2177 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2177 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2178 20 DatagramOutputFile * 0 8576 20 DatagramOutputFile * 20 DatagramOutputFile * 0 0 2001 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2179 32 DoubleBitMask&lt; BitMaskNative &gt; * 0 8576 32 DoubleBitMask&lt; BitMaskNative &gt; * 32 DoubleBitMask&lt; BitMaskNative &gt; * 0 0 2003 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2180 38 DoubleBitMask&lt; BitMaskNative &gt; const * 0 8576 38 DoubleBitMask&lt; BitMaskNative &gt; const * 38 DoubleBitMask&lt; BitMaskNative &gt; const * 0 0 2181 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2181 36 DoubleBitMask&lt; BitMaskNative &gt; const 0 8832 36 DoubleBitMask&lt; BitMaskNative &gt; const 36 DoubleBitMask&lt; BitMaskNative &gt; const 0 0 2003 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2182 38 DoubleBitMask&lt; DoubleBitMaskNative &gt; * 0 8576 38 DoubleBitMask&lt; DoubleBitMaskNative &gt; * 38 DoubleBitMask&lt; DoubleBitMaskNative &gt; * 0 0 2005 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2183 44 DoubleBitMask&lt; DoubleBitMaskNative &gt; const * 0 8576 44 DoubleBitMask&lt; DoubleBitMaskNative &gt; const * 44 DoubleBitMask&lt; DoubleBitMaskNative &gt; const * 0 0 2184 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2184 42 DoubleBitMask&lt; DoubleBitMaskNative &gt; const 0 8832 42 DoubleBitMask&lt; DoubleBitMaskNative &gt; const 42 DoubleBitMask&lt; DoubleBitMaskNative &gt; const 0 0 2005 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2185 15 GamepadButton * 0 8576 15 GamepadButton * 15 GamepadButton * 0 0 2008 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2186 21 GamepadButton const * 0 8576 21 GamepadButton const * 21 GamepadButton const * 0 0 2187 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2187 19 GamepadButton const 0 8832 19 GamepadButton const 19 GamepadButton const 0 0 2008 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2188 16 KeyboardButton * 0 8576 16 KeyboardButton * 16 KeyboardButton * 0 0 2009 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2189 22 KeyboardButton const * 0 8576 22 KeyboardButton const * 22 KeyboardButton const * 0 0 2190 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2190 20 KeyboardButton const 0 8832 20 KeyboardButton const 20 KeyboardButton const 0 0 2009 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2191 17 ModifierButtons * 0 8576 17 ModifierButtons * 17 ModifierButtons * 0 0 2010 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2192 23 ModifierButtons const * 0 8576 23 ModifierButtons const * 23 ModifierButtons const * 0 0 2193 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2193 21 ModifierButtons const 0 8832 21 ModifierButtons const 21 ModifierButtons const 0 0 2010 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2194 13 MouseButton * 0 8576 13 MouseButton * 13 MouseButton * 0 0 2011 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2195 19 MouseButton const * 0 8576 19 MouseButton const * 19 MouseButton const * 0 0 2196 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2196 17 MouseButton const 0 8832 17 MouseButton const 17 MouseButton const 0 0 2011 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2197 13 PointerData * 0 8576 13 PointerData * 13 PointerData * 0 0 2013 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2198 19 PointerData const * 0 8576 19 PointerData const * 19 PointerData const * 0 0 2199 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2199 17 PointerData const 0 8832 17 PointerData const 17 PointerData const 0 0 2013 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2200 32 NodeCachedReferenceCount const * 0 8576 32 NodeCachedReferenceCount const * 32 NodeCachedReferenceCount const * 0 0 2201 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2201 30 NodeCachedReferenceCount const 0 8832 30 NodeCachedReferenceCount const 30 NodeCachedReferenceCount const 0 0 2015 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2202 13 SparseArray * 0 8576 13 SparseArray * 13 SparseArray * 0 0 2017 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2203 22 ParamValueBase const * 0 8576 22 ParamValueBase const * 22 ParamValueBase const * 0 0 2204 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2204 20 ParamValueBase const 0 8832 20 ParamValueBase const 20 ParamValueBase const 0 0 2018 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2205 27 TypedReferenceCount const * 0 8576 27 TypedReferenceCount const * 27 TypedReferenceCount const * 0 0 2206 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2206 25 TypedReferenceCount const 0 8832 25 TypedReferenceCount const 25 TypedReferenceCount const 0 0 1982 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2207 20 ParamTypedRefCount * 0 8576 20 ParamTypedRefCount * 20 ParamTypedRefCount * 0 0 2019 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2208 26 ParamTypedRefCount const * 0 8576 26 ParamTypedRefCount const * 26 ParamTypedRefCount const * 0 0 2209 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2209 24 ParamTypedRefCount const 0 8832 24 ParamTypedRefCount const 24 ParamTypedRefCount const 0 0 2019 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2210 22 ParamValue&lt; string &gt; * 0 8576 27 ParamValue&lt; std::string &gt; * 27 ParamValue&lt; std::string &gt; * 0 0 2021 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2211 28 ParamValue&lt; string &gt; const * 0 8576 33 ParamValue&lt; std::string &gt; const * 33 ParamValue&lt; std::string &gt; const * 0 0 2212 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2212 26 ParamValue&lt; string &gt; const 0 8832 31 ParamValue&lt; std::string &gt; const 31 ParamValue&lt; std::string &gt; const 0 0 2021 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2213 23 ParamValue&lt; wstring &gt; * 0 8576 28 ParamValue&lt; std::wstring &gt; * 28 ParamValue&lt; std::wstring &gt; * 0 0 2024 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2214 29 ParamValue&lt; wstring &gt; const * 0 8576 34 ParamValue&lt; std::wstring &gt; const * 34 ParamValue&lt; std::wstring &gt; const * 0 0 2215 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2215 27 ParamValue&lt; wstring &gt; const 0 8832 32 ParamValue&lt; std::wstring &gt; const 32 ParamValue&lt; std::wstring &gt; const 0 0 2024 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2216 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 2217 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2217 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 2218 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2218 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2219 26 ParamValue&lt; LVecBase2d &gt; * 0 8576 26 ParamValue&lt; LVecBase2d &gt; * 26 ParamValue&lt; LVecBase2d &gt; * 0 0 2026 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2220 32 ParamValue&lt; LVecBase2d &gt; const * 0 8576 32 ParamValue&lt; LVecBase2d &gt; const * 32 ParamValue&lt; LVecBase2d &gt; const * 0 0 2221 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2221 30 ParamValue&lt; LVecBase2d &gt; const 0 8832 30 ParamValue&lt; LVecBase2d &gt; const 30 ParamValue&lt; LVecBase2d &gt; const 0 0 2026 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2222 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 2223 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2223 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 2224 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2224 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2225 26 ParamValue&lt; LVecBase2f &gt; * 0 8576 26 ParamValue&lt; LVecBase2f &gt; * 26 ParamValue&lt; LVecBase2f &gt; * 0 0 2028 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2226 32 ParamValue&lt; LVecBase2f &gt; const * 0 8576 32 ParamValue&lt; LVecBase2f &gt; const * 32 ParamValue&lt; LVecBase2f &gt; const * 0 0 2227 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2227 30 ParamValue&lt; LVecBase2f &gt; const 0 8832 30 ParamValue&lt; LVecBase2f &gt; const 30 ParamValue&lt; LVecBase2f &gt; const 0 0 2028 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2228 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 2229 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2229 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 2230 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2230 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2231 26 ParamValue&lt; LVecBase2i &gt; * 0 8576 26 ParamValue&lt; LVecBase2i &gt; * 26 ParamValue&lt; LVecBase2i &gt; * 0 0 2030 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2232 32 ParamValue&lt; LVecBase2i &gt; const * 0 8576 32 ParamValue&lt; LVecBase2i &gt; const * 32 ParamValue&lt; LVecBase2i &gt; const * 0 0 2233 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2233 30 ParamValue&lt; LVecBase2i &gt; const 0 8832 30 ParamValue&lt; LVecBase2i &gt; const 30 ParamValue&lt; LVecBase2i &gt; const 0 0 2030 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2234 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 2235 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2235 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 2236 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2236 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2237 26 ParamValue&lt; LVecBase3d &gt; * 0 8576 26 ParamValue&lt; LVecBase3d &gt; * 26 ParamValue&lt; LVecBase3d &gt; * 0 0 2032 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2238 32 ParamValue&lt; LVecBase3d &gt; const * 0 8576 32 ParamValue&lt; LVecBase3d &gt; const * 32 ParamValue&lt; LVecBase3d &gt; const * 0 0 2239 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2239 30 ParamValue&lt; LVecBase3d &gt; const 0 8832 30 ParamValue&lt; LVecBase3d &gt; const 30 ParamValue&lt; LVecBase3d &gt; const 0 0 2032 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2240 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 2241 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2241 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 2242 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2242 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2243 26 ParamValue&lt; LVecBase3f &gt; * 0 8576 26 ParamValue&lt; LVecBase3f &gt; * 26 ParamValue&lt; LVecBase3f &gt; * 0 0 2034 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2244 32 ParamValue&lt; LVecBase3f &gt; const * 0 8576 32 ParamValue&lt; LVecBase3f &gt; const * 32 ParamValue&lt; LVecBase3f &gt; const * 0 0 2245 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2245 30 ParamValue&lt; LVecBase3f &gt; const 0 8832 30 ParamValue&lt; LVecBase3f &gt; const 30 ParamValue&lt; LVecBase3f &gt; const 0 0 2034 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2246 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 2247 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2247 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 2248 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2248 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2249 26 ParamValue&lt; LVecBase3i &gt; * 0 8576 26 ParamValue&lt; LVecBase3i &gt; * 26 ParamValue&lt; LVecBase3i &gt; * 0 0 2036 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2250 32 ParamValue&lt; LVecBase3i &gt; const * 0 8576 32 ParamValue&lt; LVecBase3i &gt; const * 32 ParamValue&lt; LVecBase3i &gt; const * 0 0 2251 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2251 30 ParamValue&lt; LVecBase3i &gt; const 0 8832 30 ParamValue&lt; LVecBase3i &gt; const 30 ParamValue&lt; LVecBase3i &gt; const 0 0 2036 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2252 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 2253 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2253 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 2254 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2254 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2255 26 ParamValue&lt; LVecBase4d &gt; * 0 8576 26 ParamValue&lt; LVecBase4d &gt; * 26 ParamValue&lt; LVecBase4d &gt; * 0 0 2038 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2256 32 ParamValue&lt; LVecBase4d &gt; const * 0 8576 32 ParamValue&lt; LVecBase4d &gt; const * 32 ParamValue&lt; LVecBase4d &gt; const * 0 0 2257 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2257 30 ParamValue&lt; LVecBase4d &gt; const 0 8832 30 ParamValue&lt; LVecBase4d &gt; const 30 ParamValue&lt; LVecBase4d &gt; const 0 0 2038 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2258 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 2259 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2259 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 2260 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2260 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2261 26 ParamValue&lt; LVecBase4f &gt; * 0 8576 26 ParamValue&lt; LVecBase4f &gt; * 26 ParamValue&lt; LVecBase4f &gt; * 0 0 2040 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2262 32 ParamValue&lt; LVecBase4f &gt; const * 0 8576 32 ParamValue&lt; LVecBase4f &gt; const * 32 ParamValue&lt; LVecBase4f &gt; const * 0 0 2263 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2263 30 ParamValue&lt; LVecBase4f &gt; const 0 8832 30 ParamValue&lt; LVecBase4f &gt; const 30 ParamValue&lt; LVecBase4f &gt; const 0 0 2040 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2264 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 2265 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2265 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 2266 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2266 10 LVecBase4i 0 2048 10 LVecBase4i 10 LVecBase4i 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">2267 26 ParamValue&lt; LVecBase4i &gt; * 0 8576 26 ParamValue&lt; LVecBase4i &gt; * 26 ParamValue&lt; LVecBase4i &gt; * 0 0 2042 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2268 32 ParamValue&lt; LVecBase4i &gt; const * 0 8576 32 ParamValue&lt; LVecBase4i &gt; const * 32 ParamValue&lt; LVecBase4i &gt; const * 0 0 2269 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2269 30 ParamValue&lt; LVecBase4i &gt; const 0 8832 30 ParamValue&lt; LVecBase4i &gt; const 30 ParamValue&lt; LVecBase4i &gt; const 0 0 2042 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2270 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 2271 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2271 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 2272 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2272 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 3-by-3 transform matrix.  It typically will represent either a</span>
 <span class="s0">* rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix</span>
 <span class="s0">* (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.</span>
 <span class="s0">*/</span>

<span class="s0">2273 25 ParamValue&lt; LMatrix3d &gt; * 0 8576 25 ParamValue&lt; LMatrix3d &gt; * 25 ParamValue&lt; LMatrix3d &gt; * 0 0 2044 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2274 31 ParamValue&lt; LMatrix3d &gt; const * 0 8576 31 ParamValue&lt; LMatrix3d &gt; const * 31 ParamValue&lt; LMatrix3d &gt; const * 0 0 2275 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2275 29 ParamValue&lt; LMatrix3d &gt; const 0 8832 29 ParamValue&lt; LMatrix3d &gt; const 29 ParamValue&lt; LMatrix3d &gt; const 0 0 2044 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2276 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 2277 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2277 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 2278 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2278 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 3-by-3 transform matrix.  It typically will represent either a</span>
 <span class="s0">* rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix</span>
 <span class="s0">* (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.</span>
 <span class="s0">*/</span>

<span class="s0">2279 25 ParamValue&lt; LMatrix3f &gt; * 0 8576 25 ParamValue&lt; LMatrix3f &gt; * 25 ParamValue&lt; LMatrix3f &gt; * 0 0 2046 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2280 31 ParamValue&lt; LMatrix3f &gt; const * 0 8576 31 ParamValue&lt; LMatrix3f &gt; const * 31 ParamValue&lt; LMatrix3f &gt; const * 0 0 2281 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2281 29 ParamValue&lt; LMatrix3f &gt; const 0 8832 29 ParamValue&lt; LMatrix3f &gt; const 29 ParamValue&lt; LMatrix3f &gt; const 0 0 2046 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2282 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 2283 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2283 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 2284 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2284 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">2285 25 ParamValue&lt; LMatrix4d &gt; * 0 8576 25 ParamValue&lt; LMatrix4d &gt; * 25 ParamValue&lt; LMatrix4d &gt; * 0 0 2048 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2286 31 ParamValue&lt; LMatrix4d &gt; const * 0 8576 31 ParamValue&lt; LMatrix4d &gt; const * 31 ParamValue&lt; LMatrix4d &gt; const * 0 0 2287 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2287 29 ParamValue&lt; LMatrix4d &gt; const 0 8832 29 ParamValue&lt; LMatrix4d &gt; const 29 ParamValue&lt; LMatrix4d &gt; const 0 0 2048 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2288 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 2289 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2289 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 2290 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2290 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">2291 25 ParamValue&lt; LMatrix4f &gt; * 0 8576 25 ParamValue&lt; LMatrix4f &gt; * 25 ParamValue&lt; LMatrix4f &gt; * 0 0 2050 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2292 31 ParamValue&lt; LMatrix4f &gt; const * 0 8576 31 ParamValue&lt; LMatrix4f &gt; const * 31 ParamValue&lt; LMatrix4f &gt; const * 0 0 2293 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2293 29 ParamValue&lt; LMatrix4f &gt; const 0 8832 29 ParamValue&lt; LMatrix4f &gt; const 29 ParamValue&lt; LMatrix4f &gt; const 0 0 2050 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2294 25 UniqueIdAllocator const * 0 8576 25 UniqueIdAllocator const * 25 UniqueIdAllocator const * 0 0 2295 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2295 23 UniqueIdAllocator const 0 8832 23 UniqueIdAllocator const 23 UniqueIdAllocator const 0 0 2058 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2296 19 UniqueIdAllocator * 0 8576 19 UniqueIdAllocator * 19 UniqueIdAllocator * 0 0 2058 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2297 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 2298 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2298 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2299 26 ConfigVariableSearchPath * 0 8576 26 ConfigVariableSearchPath * 26 ConfigVariableSearchPath * 0 0 2300 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2300 24 ConfigVariableSearchPath 0 2048 24 ConfigVariableSearchPath 24 ConfigVariableSearchPath 0 0 0 0 0 0 0 0 0 0 0 0 731</span>
<span class="s0">/**</span>
 <span class="s0">* This is similar to a ConfigVariableList, but it returns its list as a</span>
 <span class="s0">* DSearchPath, as a list of directories.</span>
 <span class="s0">*</span>
 <span class="s0">* You may locally append directories to the end of the search path with the</span>
 <span class="s0">* methods here, or prepend them to the beginning.  Use these methods to make</span>
 <span class="s0">* adjustments to the path; do not attempt to directly modify the const</span>
 <span class="s0">* DSearchPath object returned by get_value().</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike other ConfigVariable types, local changes (made by calling</span>
 <span class="s0">* append_directory() and prepend_directory()) are specific to this particular</span>
 <span class="s0">* instance of the ConfigVariableSearchPath.  A separate instance of the same</span>
 <span class="s0">* variable, created by using the same name to the constructor, will not</span>
 <span class="s0">* reflect the local changes.</span>
 <span class="s0">*/</span>

<span class="s0">2301 12 ConfigPage * 0 8576 12 ConfigPage * 12 ConfigPage * 0 0 2302 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2302 10 ConfigPage 0 2048 10 ConfigPage 10 ConfigPage 0 0 0 0 0 0 0 0 0 0 0 0 262</span>
<span class="s0">/**</span>
 <span class="s0">* A page of ConfigDeclarations that may be loaded or unloaded.  Typically</span>
 <span class="s0">* this represents a single .prc file that is read from disk at runtime, but</span>
 <span class="s0">* it may also represent a list of declarations built up by application code</span>
 <span class="s0">* and explicitly loaded.</span>
 <span class="s0">*/</span>

<span class="s0">2303 9 HashVal * 0 8576 9 HashVal * 9 HashVal * 0 0 2304 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">2304 7 HashVal 0 2048 7 HashVal 7 HashVal 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">83</span>
<span class="s0">2305 9 play_rate 0 6 1931 1018 1017 0 0 0 0 0 0 24 AnimInterface::play_rate 0</span>

<span class="s0">2306 10 frame_rate 0 2 1931 1019 0 0 0 0 0 0 0 25 AnimInterface::frame_rate 0</span>

<span class="s0">2307 10 num_frames 0 2 1932 1020 0 0 0 0 0 0 0 25 AnimInterface::num_frames 0</span>

<span class="s0">2308 5 frame 0 2 1932 1021 0 0 0 0 0 0 0 20 AnimInterface::frame 0</span>

<span class="s0">2309 10 next_frame 0 2 1932 1022 0 0 0 0 0 0 0 25 AnimInterface::next_frame 0</span>

<span class="s0">2310 4 frac 0 2 1931 1023 0 0 0 0 0 0 0 19 AnimInterface::frac 0</span>

<span class="s0">2311 10 full_frame 0 2 1932 1024 0 0 0 0 0 0 0 25 AnimInterface::full_frame 0</span>

<span class="s0">2312 11 full_fframe 0 2 1931 1025 0 0 0 0 0 0 0 26 AnimInterface::full_fframe 0</span>

<span class="s0">2313 7 playing 0 2 1933 1026 0 0 0 0 0 0 0 22 AnimInterface::playing 0</span>

<span class="s0">2314 3 seq 0 2 1936 1047 0 0 0 0 0 0 0 14 UpdateSeq::seq 0</span>

<span class="s0">2315 15 source_pathname 0 2 1945 1072 0 0 0 0 0 0 0 31 BamCacheRecord::source_pathname 0</span>

<span class="s0">2316 14 cache_filename 0 2 1945 1073 0 0 0 0 0 0 0 30 BamCacheRecord::cache_filename 0</span>

<span class="s0">2317 16 source_timestamp 0 2 1947 1074 0 0 0 0 0 0 0 32 BamCacheRecord::source_timestamp 0</span>

<span class="s0">2318 13 recorded_time 0 2 1947 1075 0 0 0 0 0 0 0 29 BamCacheRecord::recorded_time 0</span>

<span class="s0">2319 4 data 0 30 1948 1083 1085 1081 1082 0 0 0 0 20 BamCacheRecord::data 0</span>

<span class="s0">2320 6 active 0 6 1933 1092 1091 0 0 0 0 0 0 16 BamCache::active 0</span>

<span class="s0">2321 12 cache_models 0 6 1933 1094 1093 0 0 0 0 0 0 22 BamCache::cache_models 0</span>

<span class="s0">2322 14 cache_textures 0 6 1933 1096 1095 0 0 0 0 0 0 24 BamCache::cache_textures 0</span>

<span class="s0">2323 25 cache_compressed_textures 0 6 1933 1098 1097 0 0 0 0 0 0 35 BamCache::cache_compressed_textures 0</span>

<span class="s0">2324 22 cache_compiled_shaders 0 6 1933 1100 1099 0 0 0 0 0 0 32 BamCache::cache_compiled_shaders 0</span>

<span class="s0">2325 4 root 0 6 1946 1102 1101 0 0 0 0 0 0 14 BamCache::root 0</span>

<span class="s0">2326 10 flush_time 0 6 1932 1104 1103 0 0 0 0 0 0 20 BamCache::flush_time 0</span>

<span class="s0">2327 16 cache_max_kbytes 0 6 1932 1106 1105 0 0 0 0 0 0 26 BamCache::cache_max_kbytes 0</span>

<span class="s0">2328 9 read_only 0 6 1933 1108 1107 0 0 0 0 0 0 19 BamCache::read_only 0</span>

<span class="s0">2329 5 flags 0 6 1932 1121 1120 0 0 0 0 0 0 20 LoaderOptions::flags 0</span>

<span class="s0">2330 13 texture_flags 0 6 1932 1123 1122 0 0 0 0 0 0 28 LoaderOptions::texture_flags 0</span>

<span class="s0">2331 17 texture_num_views 0 6 1932 1125 1124 0 0 0 0 0 0 32 LoaderOptions::texture_num_views 0</span>

<span class="s0">2332 18 auto_texture_scale 0 6 1934 1127 1126 0 0 0 0 0 0 33 LoaderOptions::auto_texture_scale 0</span>

<span class="s0">2333 6 source 0 6 1958 1133 1132 0 0 0 0 0 0 17 BamReader::source 0</span>

<span class="s0">2334 8 filename 0 2 1945 1137 0 0 0 0 0 0 0 19 BamReader::filename 0</span>

<span class="s0">2335 14 loader_options 0 6 1960 1138 1139 0 0 0 0 0 0 25 BamReader::loader_options 0</span>

<span class="s0">2336 12 file_version 0 2 1961 1150 0 0 0 0 0 0 0 23 BamReader::file_version 0</span>

<span class="s0">2337 11 file_endian 0 2 1951 1146 0 0 0 0 0 0 0 22 BamReader::file_endian 0</span>

<span class="s0">2338 20 file_stdfloat_double 0 2 1933 1147 0 0 0 0 0 0 0 31 BamReader::file_stdfloat_double 0</span>

<span class="s0">2339 6 target 0 6 1965 1155 1154 0 0 0 0 0 0 17 BamWriter::target 0</span>

<span class="s0">2340 8 filename 0 2 1945 1157 0 0 0 0 0 0 0 19 BamWriter::filename 0</span>

<span class="s0">2341 11 file_endian 0 2 1951 1164 0 0 0 0 0 0 0 22 BamWriter::file_endian 0</span>

<span class="s0">2342 20 file_stdfloat_double 0 2 1933 1165 0 0 0 0 0 0 0 31 BamWriter::file_stdfloat_double 0</span>

<span class="s0">2343 17 file_texture_mode 0 2 1953 1166 0 0 0 0 0 0 0 28 BamWriter::file_texture_mode 0</span>

<span class="s0">2344 9 root_node 0 6 1948 1168 1169 0 0 0 0 0 0 20 BamWriter::root_node 0</span>

<span class="s0">2345 5 index 0 2 1932 1436 0 0 0 0 0 0 0 19 ButtonHandle::index 0</span>

<span class="s0">2346 4 name 0 2 1977 1431 0 0 0 0 0 0 0 18 ButtonHandle::name 0</span>

<span class="s0">2347 16 ascii_equivalent 0 10 1979 1433 0 1432 0 0 0 0 0 30 ButtonHandle::ascii_equivalent 0</span>

<span class="s0">2348 5 alias 0 2 1976 1434 0 0 0 0 0 0 0 19 ButtonHandle::alias 0</span>

<span class="s0">2349 15 cache_ref_count 0 2 1932 1463 0 0 0 0 0 0 0 50 CachedTypedWritableReferenceCount::cache_ref_count 0</span>

<span class="s0">2350 8 function 0 6 1961 1477 1476 0 0 0 0 0 0 30 PythonCallbackObject::function 0</span>

<span class="s0">2351 2 tv 0 6 1988 1482 1483 0 0 0 0 0 0 11 TimeVal::tv 0</span>

<span class="s0">2352 4 mode 0 6 1992 1487 1486 0 0 0 0 0 0 17 ClockObject::mode 0</span>

<span class="s0">2353 10 frame_time 0 6 1931 1488 1493 0 0 0 0 0 0 23 ClockObject::frame_time 0</span>

<span class="s0">2354 9 real_time 0 6 1931 1489 1492 0 0 0 0 0 0 22 ClockObject::real_time 0</span>

<span class="s0">2355 9 long_time 0 2 1931 1490 0 0 0 0 0 0 0 22 ClockObject::long_time 0</span>

<span class="s0">2356 11 frame_count 0 6 1932 1495 1494 0 0 0 0 0 0 24 ClockObject::frame_count 0</span>

<span class="s0">2357 2 dt 0 6 1931 1497 1498 0 0 0 0 0 0 15 ClockObject::dt 0</span>

<span class="s0">2358 6 max_dt 0 6 1931 1500 1501 0 0 0 0 0 0 19 ClockObject::max_dt 0</span>

<span class="s0">2359 14 degrade_factor 0 6 1931 1502 1503 0 0 0 0 0 0 27 ClockObject::degrade_factor 0</span>

<span class="s0">2360 27 average_frame_rate_interval 0 6 1931 1505 1504 0 0 0 0 0 0 40 ClockObject::average_frame_rate_interval 0</span>

<span class="s0">2361 18 average_frame_rate 0 2 1931 1506 0 0 0 0 0 0 0 31 ClockObject::average_frame_rate 0</span>

<span class="s0">2362 18 max_frame_duration 0 2 1931 1507 0 0 0 0 0 0 0 31 ClockObject::max_frame_duration 0</span>

<span class="s0">2363 4 data 0 6 1997 1528 1529 0 0 0 0 0 0 20 DatagramBuffer::data 0</span>

<span class="s0">2364 6 stream 0 2 2002 1540 0 0 0 0 0 0 0 26 DatagramOutputFile::stream 0</span>

<span class="s0">2365 7 buttons 0 66 1976 1756 0 0 0 0 1755 0 0 24 ModifierButtons::buttons 0</span>

<span class="s0">2366 1 x 0 2 1931 1778 0 0 0 0 0 0 0 14 PointerData::x 0</span>

<span class="s0">2367 1 y 0 2 1931 1779 0 0 0 0 0 0 0 14 PointerData::y 0</span>

<span class="s0">2368 4 type 0 2 2012 1781 0 0 0 0 0 0 0 17 PointerData::type 0</span>

<span class="s0">2369 2 id 0 2 1932 1782 0 0 0 0 0 0 0 15 PointerData::id 0</span>

<span class="s0">2370 9 in_window 0 2 1933 1780 0 0 0 0 0 0 0 22 PointerData::in_window 0</span>

<span class="s0">2371 8 pressure 0 2 1931 1783 0 0 0 0 0 0 0 21 PointerData::pressure 0</span>

<span class="s0">2372 5 value 0 2 2020 1851 0 0 0 0 0 0 0 25 ParamTypedRefCount::value 0</span>

<span class="s0">2373 5 value 0 6 2022 1855 1854 0 0 0 0 0 0 27 ParamValue&lt; string &gt;::value 0</span>

<span class="s0">2374 5 value 0 6 2022 1859 1858 0 0 0 0 0 0 28 ParamValue&lt; wstring &gt;::value 0</span>

<span class="s0">2375 5 value 0 6 2022 1863 1862 0 0 0 0 0 0 31 ParamValue&lt; LVecBase2d &gt;::value 0</span>

<span class="s0">2376 5 value 0 6 2022 1867 1866 0 0 0 0 0 0 31 ParamValue&lt; LVecBase2f &gt;::value 0</span>

<span class="s0">2377 5 value 0 6 2022 1871 1870 0 0 0 0 0 0 31 ParamValue&lt; LVecBase2i &gt;::value 0</span>

<span class="s0">2378 5 value 0 6 2022 1875 1874 0 0 0 0 0 0 31 ParamValue&lt; LVecBase3d &gt;::value 0</span>

<span class="s0">2379 5 value 0 6 2022 1879 1878 0 0 0 0 0 0 31 ParamValue&lt; LVecBase3f &gt;::value 0</span>

<span class="s0">2380 5 value 0 6 2022 1883 1882 0 0 0 0 0 0 31 ParamValue&lt; LVecBase3i &gt;::value 0</span>

<span class="s0">2381 5 value 0 6 2022 1887 1886 0 0 0 0 0 0 31 ParamValue&lt; LVecBase4d &gt;::value 0</span>

<span class="s0">2382 5 value 0 6 2022 1891 1890 0 0 0 0 0 0 31 ParamValue&lt; LVecBase4f &gt;::value 0</span>

<span class="s0">2383 5 value 0 6 2022 1895 1894 0 0 0 0 0 0 31 ParamValue&lt; LVecBase4i &gt;::value 0</span>

<span class="s0">2384 5 value 0 6 2022 1899 1898 0 0 0 0 0 0 30 ParamValue&lt; LMatrix3d &gt;::value 0</span>

<span class="s0">2385 5 value 0 6 2022 1903 1902 0 0 0 0 0 0 30 ParamValue&lt; LMatrix3f &gt;::value 0</span>

<span class="s0">2386 5 value 0 6 2022 1907 1906 0 0 0 0 0 0 30 ParamValue&lt; LMatrix4d &gt;::value 0</span>

<span class="s0">2387 5 value 0 6 2022 1911 1910 0 0 0 0 0 0 30 ParamValue&lt; LMatrix4f &gt;::value 0</span>

<span class="s0">1</span>
<span class="s0">2388 11 get_buttons 0 1755 1756 28 ModifierButtons::get_buttons 0</span>

</pre>
</body>
</html>