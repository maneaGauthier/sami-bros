<html>
<head>
<title>libp3interval.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3interval.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">13 libp3interval 4 ceEZ 14 panda3d.direct </span>
<span class="s0">165</span>
<span class="s0">167 8 get_name 0 4 332 19 CInterval::get_name 0 1 2 39</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the interval's name.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline std::string const &amp;CInterval::get_name(void) const;</span>

<span class="s0">168 12 get_duration 0 4 332 23 CInterval::get_duration 0 1 3 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the duration of the interval in seconds.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline double CInterval::get_duration(void) const;</span>

<span class="s0">169 14 get_open_ended 0 4 332 25 CInterval::get_open_ended 0 1 4 381</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the state of the &quot;open_ended&quot; flag.  This is primarily intended for</span>
 <span class="s0">* instantaneous intervals like FunctionIntervals; it indicates true if the</span>
 <span class="s0">* interval has some lasting effect that should be applied even if the</span>
 <span class="s0">* interval doesn't get started until after its finish time, or false if the</span>
 <span class="s0">* interval is a transitive thing that doesn't need to be called late.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool CInterval::get_open_ended(void) const;</span>

<span class="s0">170 9 get_state 0 4 332 20 CInterval::get_state 0 1 5 145</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the state the interval believes it is in: whether it has been</span>
 <span class="s0">* started, is currently in the middle, or has been finalized.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline CInterval::State CInterval::get_state(void) const;</span>

<span class="s0">171 10 is_stopped 0 4 332 21 CInterval::is_stopped 0 1 6 123</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the interval is in either its initial or final states (but</span>
 <span class="s0">* not in a running or paused state).</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool CInterval::is_stopped(void) const;</span>

<span class="s0">172 14 set_done_event 0 4 332 25 CInterval::set_done_event 0 1 7 167</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the event that is generated whenever the interval reaches its final</span>
 <span class="s0">* state, whether it is explicitly finished or whether it gets there on its</span>
 <span class="s0">* own.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void CInterval::set_done_event(std::string const &amp;event);</span>

<span class="s0">173 14 get_done_event 0 4 332 25 CInterval::get_done_event 0 1 8 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the event that is generated whenever the interval reaches its final</span>
 <span class="s0">* state, whether it is explicitly finished or whether it gets there on its</span>
 <span class="s0">* own.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::string const &amp;CInterval::get_done_event(void) const;</span>

<span class="s0">174 5 set_t 0 4 332 16 CInterval::set_t 0 1 9 201</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly sets the time within the interval.  Normally, you would use</span>
 <span class="s0">* start() .. finish() to let the time play normally, but this may be used to</span>
 <span class="s0">* set the time to some particular value.</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">void CInterval::set_t(double t);</span>

<span class="s0">175 5 get_t 0 4 332 16 CInterval::get_t 0 1 10 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current time of the interval: the last value of t passed to</span>
 <span class="s0">* priv_initialize(), priv_step(), or priv_finalize().</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline double CInterval::get_t(void) const;</span>

<span class="s0">176 14 set_auto_pause 0 4 332 25 CInterval::set_auto_pause 0 1 11 317</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the state of the 'auto_pause' flag.  If this is true, the interval</span>
 <span class="s0">* may be arbitrarily interrupted when the system needs to reset due to some</span>
 <span class="s0">* external event by calling CIntervalManager::interrupt().  If this is false</span>
 <span class="s0">* (the default), the interval must always be explicitly finished or paused.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void CInterval::set_auto_pause(bool auto_pause);</span>

<span class="s0">177 14 get_auto_pause 0 4 332 25 CInterval::get_auto_pause 0 1 12 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the state of the 'auto_pause' flag.  See set_auto_pause().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool CInterval::get_auto_pause(void) const;</span>

<span class="s0">178 15 set_auto_finish 0 4 332 26 CInterval::set_auto_finish 0 1 13 315</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the state of the 'auto_finish' flag.  If this is true, the interval</span>
 <span class="s0">* may be arbitrarily finished when the system needs to reset due to some</span>
 <span class="s0">* external event by calling CIntervalManager::interrupt().  If this is false</span>
 <span class="s0">* (the default), the interval must always be explicitly finished or paused.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void CInterval::set_auto_finish(bool auto_finish);</span>

<span class="s0">179 15 get_auto_finish 0 4 332 26 CInterval::get_auto_finish 0 1 14 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the state of the 'auto_finish' flag.  See set_auto_finish().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool CInterval::get_auto_finish(void) const;</span>

<span class="s0">180 20 set_wants_t_callback 0 4 332 31 CInterval::set_wants_t_callback 0 1 15 254</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the state of the 'wants_t_callback' flag.  If this is true, the</span>
 <span class="s0">* interval will be returned by CIntervalManager::get_event() each time the</span>
 <span class="s0">* interval's time value has been changed, regardless of whether it has any</span>
 <span class="s0">* external events.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void CInterval::set_wants_t_callback(bool wants_t_callback);</span>

<span class="s0">181 20 get_wants_t_callback 0 4 332 31 CInterval::get_wants_t_callback 0 1 16 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the state of the 'wants_t_callback' flag.  See</span>
 <span class="s0">* set_wants_t_callback().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool CInterval::get_wants_t_callback(void) const;</span>

<span class="s0">182 11 set_manager 0 4 332 22 CInterval::set_manager 0 1 17 253</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the CIntervalManager object which will be responsible for playing</span>
 <span class="s0">* this interval.  This defaults to the global CIntervalManager; you should</span>
 <span class="s0">* need to change this only if you have special requirements for playing this</span>
 <span class="s0">* interval.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void CInterval::set_manager(CIntervalManager *manager);</span>

<span class="s0">183 11 get_manager 0 4 332 22 CInterval::get_manager 0 1 18 320</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CIntervalManager object which will be responsible for playing</span>
 <span class="s0">* this interval.  Note that this can only return a C++ object; if the</span>
 <span class="s0">* particular CIntervalManager object has been extended in the scripting</span>
 <span class="s0">* language, this will return the encapsulated C++ object, not the full</span>
 <span class="s0">* extended object.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline CIntervalManager *CInterval::get_manager(void) const;</span>

<span class="s0">184 5 start 0 4 332 16 CInterval::start 0 1 19 211</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the interval playing by registering it with the current</span>
 <span class="s0">* CIntervalManager.  The interval will play to the end and stop.</span>
 <span class="s0">*</span>
 <span class="s0">* If end_t is less than zero, it indicates the end of the interval.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void CInterval::start(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0);</span>

<span class="s0">185 4 loop 0 4 332 15 CInterval::loop 0 1 20 290</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the interval playing by registering it with the current</span>
 <span class="s0">* CIntervalManager.  The interval will play until it is interrupted with</span>
 <span class="s0">* finish() or pause(), looping back to start_t when it reaches end_t.</span>
 <span class="s0">*</span>
 <span class="s0">* If end_t is less than zero, it indicates the end of the interval.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">void CInterval::loop(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0);</span>

<span class="s0">186 5 pause 0 4 332 16 CInterval::pause 0 1 21 143</span>
<span class="s0">/**</span>
 <span class="s0">* Stops the interval from playing but leaves it in its current state.  It may</span>
 <span class="s0">* later be resumed from this point by calling resume().</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">double CInterval::pause(void);</span>

<span class="s0">187 6 resume 0 4 332 17 CInterval::resume 0 2 22 23 188</span>
<span class="s0">/**</span>
 <span class="s0">* Restarts the interval from its current point after a previous call to</span>
 <span class="s0">* pause().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Restarts the interval from the indicated point after a previous call to</span>
 <span class="s0">* pause().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void CInterval::resume(void);</span>
<span class="s0">void CInterval::resume(double start_t);</span>

<span class="s0">188 12 resume_until 0 4 332 23 CInterval::resume_until 0 1 24 183</span>
<span class="s0">/**</span>
 <span class="s0">* Restarts the interval from the current point after a previous call to</span>
 <span class="s0">* pause() (or a previous play-to-point-and-stop), to play until the indicated</span>
 <span class="s0">* point and then stop.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void CInterval::resume_until(double end_t);</span>

<span class="s0">189 6 finish 0 4 332 17 CInterval::finish 0 1 25 74</span>
<span class="s0">/**</span>
 <span class="s0">* Stops the interval from playing and sets it to its final state.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">void CInterval::finish(void);</span>

<span class="s0">190 16 clear_to_initial 0 4 332 27 CInterval::clear_to_initial 0 1 26 276</span>
<span class="s0">/**</span>
 <span class="s0">* Pauses the interval, if it is playing, and resets its state to its initial</span>
 <span class="s0">* state, abandoning any state changes already in progress in the middle of</span>
 <span class="s0">* the interval.  Calling this is like pausing the interval and discarding it,</span>
 <span class="s0">* creating a new one in its place.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void CInterval::clear_to_initial(void);</span>

<span class="s0">191 10 is_playing 0 4 332 21 CInterval::is_playing 0 1 27 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the interval is currently playing, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">bool CInterval::is_playing(void) const;</span>

<span class="s0">192 13 get_play_rate 0 4 332 24 CInterval::get_play_rate 0 1 28 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the play rate as set by the last call to start(), loop(), or</span>
 <span class="s0">* set_play_rate().</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">double CInterval::get_play_rate(void) const;</span>

<span class="s0">193 13 set_play_rate 0 4 332 24 CInterval::set_play_rate 0 1 29 257</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the play rate of the interval.  If the interval is already started,</span>
 <span class="s0">* this changes its speed on-the-fly.  Note that since play_rate is a</span>
 <span class="s0">* parameter to start() and loop(), the next call to start() or loop() will</span>
 <span class="s0">* reset this parameter.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void CInterval::set_play_rate(double play_rate);</span>

<span class="s0">194 13 priv_do_event 0 4 332 24 CInterval::priv_do_event 0 1 30 276</span>
<span class="s0">// These cannot be declared private because they must be accessible to</span>
<span class="s0">// Python, but the method names are prefixed with priv_ to remind you that</span>
<span class="s0">// you probably don't want to be using them directly.</span>

<span class="s0">/**</span>
 <span class="s0">* Calls the appropriate event function indicated by the EventType.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void CInterval::priv_do_event(double t, CInterval::EventType event);</span>

<span class="s0">195 15 priv_initialize 0 6 332 26 CInterval::priv_initialize 0 1 31 216</span>
<span class="s0">/**</span>
 <span class="s0">* This replaces the first call to priv_step(), and indicates that the</span>
 <span class="s0">* interval has just begun.  This may be overridden by derived classes that</span>
 <span class="s0">* need to do some explicit initialization on the first call.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">virtual void CInterval::priv_initialize(double t);</span>

<span class="s0">196 12 priv_instant 0 6 332 23 CInterval::priv_instant 0 1 32 220</span>
<span class="s0">/**</span>
 <span class="s0">* This is called in lieu of priv_initialize() .. priv_step() ..</span>
 <span class="s0">* priv_finalize(), when everything is to happen within one frame.  The</span>
 <span class="s0">* interval should initialize itself, then leave itself in the final state.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">virtual void CInterval::priv_instant(void);</span>

<span class="s0">197 9 priv_step 0 6 332 20 CInterval::priv_step 0 1 33 164</span>
<span class="s0">/**</span>
 <span class="s0">* Advances the time on the interval.  The time may either increase (the</span>
 <span class="s0">* normal case) or decrease (e.g.  if the interval is being played by a</span>
 <span class="s0">* slider).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual void CInterval::priv_step(double t);</span>

<span class="s0">198 13 priv_finalize 0 6 332 24 CInterval::priv_finalize 0 1 34 172</span>
<span class="s0">/**</span>
 <span class="s0">* This is called to stop an interval, forcing it to whatever state it would</span>
 <span class="s0">* be after it played all the way through.  It's generally invoked by</span>
 <span class="s0">* set_final_t().</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual void CInterval::priv_finalize(void);</span>

<span class="s0">199 23 priv_reverse_initialize 0 6 332 34 CInterval::priv_reverse_initialize 0 1 35 213</span>
<span class="s0">/**</span>
 <span class="s0">* Similar to priv_initialize(), but this is called when the interval is being</span>
 <span class="s0">* played backwards; it indicates that the interval should start at the</span>
 <span class="s0">* finishing state and undo any intervening intervals.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual void CInterval::priv_reverse_initialize(double t);</span>

<span class="s0">200 20 priv_reverse_instant 0 6 332 31 CInterval::priv_reverse_instant 0 1 36 240</span>
<span class="s0">/**</span>
 <span class="s0">* This is called in lieu of priv_reverse_initialize() .. priv_step() ..</span>
 <span class="s0">* priv_reverse_finalize(), when everything is to happen within one frame.</span>
 <span class="s0">* The interval should initialize itself, then leave itself in the initial</span>
 <span class="s0">* state.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">virtual void CInterval::priv_reverse_instant(void);</span>

<span class="s0">201 21 priv_reverse_finalize 0 6 332 32 CInterval::priv_reverse_finalize 0 1 37 137</span>
<span class="s0">/**</span>
 <span class="s0">* Called generally following a priv_reverse_initialize(), this indicates the</span>
 <span class="s0">* interval should set itself to the initial state.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">virtual void CInterval::priv_reverse_finalize(void);</span>

<span class="s0">202 14 priv_interrupt 0 6 332 25 CInterval::priv_interrupt 0 1 38 471</span>
<span class="s0">/**</span>
 <span class="s0">* This is called while the interval is playing to indicate that it is about</span>
 <span class="s0">* to be interrupted; that is, priv_step() will not be called for a length of</span>
 <span class="s0">* time.  But the interval should remain in its current state in anticipation</span>
 <span class="s0">* of being eventually restarted when the calls to priv_step() eventually</span>
 <span class="s0">* resume.</span>
 <span class="s0">*</span>
 <span class="s0">* The purpose of this function is to allow self-running intervals like sound</span>
 <span class="s0">* intervals to stop the actual sound playback during the pause.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">virtual void CInterval::priv_interrupt(void);</span>

<span class="s0">203 6 output 0 6 332 17 CInterval::output 0 1 39 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual void CInterval::output(std::ostream &amp;out) const;</span>

<span class="s0">204 5 write 0 6 332 16 CInterval::write 0 1 40 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">virtual void CInterval::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">205 10 setup_play 0 4 332 21 CInterval::setup_play 0 1 41 487</span>
<span class="s0">/**</span>
 <span class="s0">* Called to prepare the interval for automatic timed playback, e.g.  via a</span>
 <span class="s0">* Python task.  The interval will be played from start_t to end_t, at a time</span>
 <span class="s0">* factor specified by play_rate.  start_t must always be less than end_t</span>
 <span class="s0">* (except for the exception for end_t == -1, below), but if play_rate is</span>
 <span class="s0">* negative the interval will be played backwards.</span>
 <span class="s0">*</span>
 <span class="s0">* Specify end_t of -1 to play the entire interval from start_t.</span>
 <span class="s0">*</span>
 <span class="s0">* Call step_play() repeatedly to execute the interval.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop);</span>

<span class="s0">206 12 setup_resume 0 4 332 23 CInterval::setup_resume 0 1 42 123</span>
<span class="s0">/**</span>
 <span class="s0">* Called to prepare the interval for restarting at the current point within</span>
 <span class="s0">* the interval after an interruption.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">void CInterval::setup_resume(void);</span>

<span class="s0">207 18 setup_resume_until 0 4 332 29 CInterval::setup_resume_until 0 1 43 207</span>
<span class="s0">/**</span>
 <span class="s0">* Called to prepare the interval for restarting from the current point after</span>
 <span class="s0">* a previous call to pause() (or a previous play-to-point-and-stop), to play</span>
 <span class="s0">* until the indicated point and then stop.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void CInterval::setup_resume_until(double end_t);</span>

<span class="s0">208 9 step_play 0 4 332 20 CInterval::step_play 0 1 44 202</span>
<span class="s0">/**</span>
 <span class="s0">* Should be called once per frame to execute the automatic timed playback</span>
 <span class="s0">* begun with setup_play().</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the interval should continue, false if it is done and</span>
 <span class="s0">* should stop.</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">bool CInterval::step_play(void);</span>

<span class="s0">209 9 __await__ 0 4 332 20 CInterval::__await__ 0 1 45 0</span>
<span class="s0">47</span>
<span class="s0">PyObject *CInterval::__await__(PyObject *self);</span>

<span class="s0">210 16 CIntervalManager 0 260 342 34 CIntervalManager::CIntervalManager 0 1 47 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">CIntervalManager::CIntervalManager(void);</span>

<span class="s0">211 17 ~CIntervalManager 0 516 342 35 CIntervalManager::~CIntervalManager 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">CIntervalManager::~CIntervalManager(void);</span>

<span class="s0">212 15 set_event_queue 0 4 342 33 CIntervalManager::set_event_queue 0 1 48 378</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a custom event queue to be used for throwing done events from</span>
 <span class="s0">* intervals as they finish.  If this is not specified, the global event queue</span>
 <span class="s0">* is used.</span>
 <span class="s0">*</span>
 <span class="s0">* The caller maintains ownership of the EventQueue object; it is the caller's</span>
 <span class="s0">* responsibility to ensure that the supplied EventQueue does not destruct</span>
 <span class="s0">* during the lifetime of the CIntervalManager.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void CIntervalManager::set_event_queue(EventQueue *event_queue);</span>

<span class="s0">213 15 get_event_queue 0 4 342 33 CIntervalManager::get_event_queue 0 1 49 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the custom event queue to be used for throwing done events from</span>
 <span class="s0">* intervals as they finish.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline EventQueue *CIntervalManager::get_event_queue(void) const;</span>

<span class="s0">214 14 add_c_interval 0 4 342 32 CIntervalManager::add_c_interval 0 1 50 663</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the interval to the manager, and returns a unique index for the</span>
 <span class="s0">* interval.  This index will be unique among all the currently added</span>
 <span class="s0">* intervals, but not unique across all intervals ever added to the manager.</span>
 <span class="s0">* The maximum index value will never exceed the maximum number of intervals</span>
 <span class="s0">* added at any given time.</span>
 <span class="s0">*</span>
 <span class="s0">* If the external flag is true, the interval is understood to also be stored</span>
 <span class="s0">* in the scripting language data structures.  In this case, it will be</span>
 <span class="s0">* available for information returned by get_next_event() and</span>
 <span class="s0">* get_next_removal().  If external is false, the interval's index will never</span>
 <span class="s0">* be returned by these two functions.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">int CIntervalManager::add_c_interval(CInterval *interval, bool external);</span>

<span class="s0">215 15 find_c_interval 0 4 342 33 CIntervalManager::find_c_interval 0 1 51 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index associated with the named interval, if there is such an</span>
 <span class="s0">* interval, or -1 if there is not.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">int CIntervalManager::find_c_interval(std::string const &amp;name) const;</span>

<span class="s0">216 14 get_c_interval 0 4 342 32 CIntervalManager::get_c_interval 0 1 52 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the interval associated with the given index.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">CInterval *CIntervalManager::get_c_interval(int index) const;</span>

<span class="s0">217 17 remove_c_interval 0 4 342 35 CIntervalManager::remove_c_interval 0 1 53 203</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated interval from the queue immediately.  It will not be</span>
 <span class="s0">* returned from get_next_removal(), and none of its pending events, if any,</span>
 <span class="s0">* will be returned by get_next_event().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void CIntervalManager::remove_c_interval(int index);</span>

<span class="s0">218 9 interrupt 0 4 342 27 CIntervalManager::interrupt 0 1 54 316</span>
<span class="s0">/**</span>
 <span class="s0">* Pauses or finishes (removes from the active queue) all intervals tagged</span>
 <span class="s0">* with auto_pause or auto_finish set to true.  These are intervals that</span>
 <span class="s0">* someone fired up but won't necessarily expect to clean up; they can be</span>
 <span class="s0">* interrupted at will when necessary.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the number of intervals affected.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">int CIntervalManager::interrupt(void);</span>

<span class="s0">219 17 get_num_intervals 0 4 342 35 CIntervalManager::get_num_intervals 0 1 55 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of currently active intervals.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">int CIntervalManager::get_num_intervals(void) const;</span>

<span class="s0">220 13 get_max_index 0 4 342 31 CIntervalManager::get_max_index 0 1 56 295</span>
<span class="s0">/**</span>
 <span class="s0">* Returns one more than the largest interval index number in the manager.  If</span>
 <span class="s0">* you walk through all the values between (0, get_max_index()] and call</span>
 <span class="s0">* get_c_interval() on each number, you will retrieve all of the managed</span>
 <span class="s0">* intervals (and possibly a number of NULL pointers as well).</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int CIntervalManager::get_max_index(void) const;</span>

<span class="s0">221 4 step 0 4 342 22 CIntervalManager::step 0 1 57 444</span>
<span class="s0">/**</span>
 <span class="s0">* This should be called every frame to do the processing for all the active</span>
 <span class="s0">* intervals.  It will call step_play() for each interval that has been added</span>
 <span class="s0">* and that has not yet been removed.</span>
 <span class="s0">*</span>
 <span class="s0">* After each call to step(), the scripting language should call</span>
 <span class="s0">* get_next_event() and get_next_removal() repeatedly to process all the high-</span>
 <span class="s0">* level (e.g.  Python-interval-based) events and to manage the high-level</span>
 <span class="s0">* list of intervals.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void CIntervalManager::step(void);</span>

<span class="s0">222 14 get_next_event 0 4 342 32 CIntervalManager::get_next_event 0 1 58 540</span>
<span class="s0">/**</span>
 <span class="s0">* This should be called by the scripting language after each call to step().</span>
 <span class="s0">* It returns the index number of the next interval that has events requiring</span>
 <span class="s0">* servicing by the scripting language, or -1 if no more intervals have any</span>
 <span class="s0">* events pending.</span>
 <span class="s0">*</span>
 <span class="s0">* If this function returns something other than -1, it is the scripting</span>
 <span class="s0">* language's responsibility to query the indicated interval for its next</span>
 <span class="s0">* event via get_event_index(), and eventually pop_event().</span>
 <span class="s0">*</span>
 <span class="s0">* Then get_next_event() should be called again until it returns -1.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">int CIntervalManager::get_next_event(void);</span>

<span class="s0">223 16 get_next_removal 0 4 342 34 CIntervalManager::get_next_removal 0 1 59 366</span>
<span class="s0">/**</span>
 <span class="s0">* This should be called by the scripting language after each call to step().</span>
 <span class="s0">* It returns the index number of an interval that was recently removed, or -1</span>
 <span class="s0">* if no intervals were removed.</span>
 <span class="s0">*</span>
 <span class="s0">* If this returns something other than -1, the scripting language should</span>
 <span class="s0">* clean up its own data structures accordingly, and then call</span>
 <span class="s0">* get_next_removal() again.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int CIntervalManager::get_next_removal(void);</span>

<span class="s0">224 6 output 0 4 342 24 CIntervalManager::output 0 1 60 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void CIntervalManager::output(std::ostream &amp;out) const;</span>

<span class="s0">225 5 write 0 4 342 23 CIntervalManager::write 0 1 61 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void CIntervalManager::write(std::ostream &amp;out) const;</span>

<span class="s0">226 14 get_global_ptr 0 4 342 32 CIntervalManager::get_global_ptr 0 1 62 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the one global CIntervalManager object.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">static CIntervalManager *CIntervalManager::get_global_ptr(void);</span>

<span class="s0">227 14 get_class_type 0 4 332 25 CInterval::get_class_type 0 1 46 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle CInterval::get_class_type(void);</span>

<span class="s0">228 9 CInterval 0 260 332 20 CInterval::CInterval 0 1 1 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline CInterval::CInterval(CInterval const &amp;) = default;</span>

<span class="s0">229 18 get_bogus_variable 0 20 343 39 CConstraintInterval::get_bogus_variable 0 0 52</span>
<span class="s0">getter for bool CConstraintInterval::bogus_variable;</span>
<span class="s0">57</span>
<span class="s0">bool CConstraintInterval::get_bogus_variable(void) const;</span>

<span class="s0">230 18 set_bogus_variable 0 36 343 39 CConstraintInterval::set_bogus_variable 0 0 52</span>
<span class="s0">setter for bool CConstraintInterval::bogus_variable;</span>
<span class="s0">57</span>
<span class="s0">void CConstraintInterval::set_bogus_variable(bool value);</span>

<span class="s0">231 14 get_class_type 0 4 343 35 CConstraintInterval::get_class_type 0 1 64 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle CConstraintInterval::get_class_type(void);</span>

<span class="s0">232 19 CConstraintInterval 0 260 343 40 CConstraintInterval::CConstraintInterval 0 1 63 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline CConstraintInterval::CConstraintInterval(CConstraintInterval const &amp;) = default;</span>

<span class="s0">233 20 ~CConstraintInterval 0 516 343 41 CConstraintInterval::~CConstraintInterval 0 0 0</span>
<span class="s0">48</span>
<span class="s0">CConstraintInterval::~CConstraintInterval(void);</span>

<span class="s0">234 21 CConstrainHprInterval 0 260 344 44 CConstrainHprInterval::CConstrainHprInterval 0 2 65 66 369</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a constraint interval that will constrain the orientation of one</span>
 <span class="s0">* node to the orientation of another, possibly with an added rotation.</span>
 <span class="s0">*</span>
 <span class="s0">* If wrt is true, the node's orientation will be transformed into the target</span>
 <span class="s0">* node's parent's  space before being copied.  If wrt is false, the target</span>
 <span class="s0">* node's local orientation will be copied unaltered.</span>
 <span class="s0">*/</span>
<span class="s0">292</span>
<span class="s0">explicit CConstrainHprInterval::CConstrainHprInterval(std::string const &amp;name, double duration, NodePath const &amp;node, NodePath const &amp;target, bool wrt, LVecBase3 const hprOffset = LVector3::zero());</span>
<span class="s0">inline CConstrainHprInterval::CConstrainHprInterval(CConstrainHprInterval const &amp;) = default;</span>

<span class="s0">235 8 get_node 0 4 344 31 CConstrainHprInterval::get_node 0 1 67 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;source&quot; node.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline NodePath const &amp;CConstrainHprInterval::get_node(void) const;</span>

<span class="s0">236 10 get_target 0 4 344 33 CConstrainHprInterval::get_target 0 1 68 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;target&quot; node.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline NodePath const &amp;CConstrainHprInterval::get_target(void) const;</span>

<span class="s0">237 14 get_class_type 0 4 344 37 CConstrainHprInterval::get_class_type 0 1 69 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle CConstrainHprInterval::get_class_type(void);</span>

<span class="s0">238 22 ~CConstrainHprInterval 0 516 344 45 CConstrainHprInterval::~CConstrainHprInterval 0 0 0</span>
<span class="s0">52</span>
<span class="s0">CConstrainHprInterval::~CConstrainHprInterval(void);</span>

<span class="s0">239 24 CConstrainPosHprInterval 0 260 345 50 CConstrainPosHprInterval::CConstrainPosHprInterval 0 2 70 71 390</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a constraint interval that will constrain the position and</span>
 <span class="s0">* orientation of one node to the position and orientation of another.</span>
 <span class="s0">*</span>
 <span class="s0">* If wrt is true, the node's position and orientation will be transformed</span>
 <span class="s0">* into the target node's parent's space before being copied.  If wrt is</span>
 <span class="s0">* false, the target node's local position and orientation will be copied</span>
 <span class="s0">* unaltered.</span>
 <span class="s0">*/</span>
<span class="s0">353</span>
<span class="s0">explicit CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &amp;name, double duration, NodePath const &amp;node, NodePath const &amp;target, bool wrt, LVecBase3 const posOffset = LVector3::zero(), LVecBase3 const hprOffset = LVector3::zero());</span>
<span class="s0">inline CConstrainPosHprInterval::CConstrainPosHprInterval(CConstrainPosHprInterval const &amp;) = default;</span>

<span class="s0">240 8 get_node 0 4 345 34 CConstrainPosHprInterval::get_node 0 1 72 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;source&quot; node.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline NodePath const &amp;CConstrainPosHprInterval::get_node(void) const;</span>

<span class="s0">241 10 get_target 0 4 345 36 CConstrainPosHprInterval::get_target 0 1 73 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;target&quot; node.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline NodePath const &amp;CConstrainPosHprInterval::get_target(void) const;</span>

<span class="s0">242 14 get_class_type 0 4 345 40 CConstrainPosHprInterval::get_class_type 0 1 74 0</span>
<span class="s0">65</span>
<span class="s0">static TypeHandle CConstrainPosHprInterval::get_class_type(void);</span>

<span class="s0">243 25 ~CConstrainPosHprInterval 0 516 345 51 CConstrainPosHprInterval::~CConstrainPosHprInterval 0 0 0</span>
<span class="s0">58</span>
<span class="s0">CConstrainPosHprInterval::~CConstrainPosHprInterval(void);</span>

<span class="s0">244 21 CConstrainPosInterval 0 260 346 44 CConstrainPosInterval::CConstrainPosInterval 0 2 75 76 324</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a constraint interval that will constrain the position of one</span>
 <span class="s0">* node to the position of another.</span>
 <span class="s0">*</span>
 <span class="s0">* If wrt is true, the node's position will be transformed into the target</span>
 <span class="s0">* node's parent's  space before being copied.  If wrt is false, the target</span>
 <span class="s0">* node's local position will be copied unaltered.</span>
 <span class="s0">*/</span>
<span class="s0">292</span>
<span class="s0">explicit CConstrainPosInterval::CConstrainPosInterval(std::string const &amp;name, double duration, NodePath const &amp;node, NodePath const &amp;target, bool wrt, LVecBase3 const posOffset = LVector3::zero());</span>
<span class="s0">inline CConstrainPosInterval::CConstrainPosInterval(CConstrainPosInterval const &amp;) = default;</span>

<span class="s0">245 8 get_node 0 4 346 31 CConstrainPosInterval::get_node 0 1 77 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;source&quot; node.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline NodePath const &amp;CConstrainPosInterval::get_node(void) const;</span>

<span class="s0">246 10 get_target 0 4 346 33 CConstrainPosInterval::get_target 0 1 78 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;target&quot; node.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline NodePath const &amp;CConstrainPosInterval::get_target(void) const;</span>

<span class="s0">247 14 get_class_type 0 4 346 37 CConstrainPosInterval::get_class_type 0 1 79 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle CConstrainPosInterval::get_class_type(void);</span>

<span class="s0">248 22 ~CConstrainPosInterval 0 516 346 45 CConstrainPosInterval::~CConstrainPosInterval 0 0 0</span>
<span class="s0">52</span>
<span class="s0">CConstrainPosInterval::~CConstrainPosInterval(void);</span>

<span class="s0">249 27 CConstrainTransformInterval 0 260 347 56 CConstrainTransformInterval::CConstrainTransformInterval 0 2 80 81 385</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a constraint interval that will constrain the transform of one</span>
 <span class="s0">* node to the transform of another.  To clarify, the transform of node will</span>
 <span class="s0">* be copied to target.</span>
 <span class="s0">*</span>
 <span class="s0">* If wrt is true, the node's transform will be transformed into the target</span>
 <span class="s0">* node's parent's  space before being copied.  If wrt is false, the node's</span>
 <span class="s0">* local transform will be copied unaltered.</span>
 <span class="s0">*/</span>
<span class="s0">276</span>
<span class="s0">explicit CConstrainTransformInterval::CConstrainTransformInterval(std::string const &amp;name, double duration, NodePath const &amp;node, NodePath const &amp;target, bool wrt);</span>
<span class="s0">inline CConstrainTransformInterval::CConstrainTransformInterval(CConstrainTransformInterval const &amp;) = default;</span>

<span class="s0">250 8 get_node 0 4 347 37 CConstrainTransformInterval::get_node 0 1 82 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;source&quot; node.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline NodePath const &amp;CConstrainTransformInterval::get_node(void) const;</span>

<span class="s0">251 10 get_target 0 4 347 39 CConstrainTransformInterval::get_target 0 1 83 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;target&quot; node.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline NodePath const &amp;CConstrainTransformInterval::get_target(void) const;</span>

<span class="s0">252 14 get_class_type 0 4 347 43 CConstrainTransformInterval::get_class_type 0 1 84 0</span>
<span class="s0">68</span>
<span class="s0">static TypeHandle CConstrainTransformInterval::get_class_type(void);</span>

<span class="s0">253 28 ~CConstrainTransformInterval 0 516 347 57 CConstrainTransformInterval::~CConstrainTransformInterval 0 0 0</span>
<span class="s0">64</span>
<span class="s0">CConstrainTransformInterval::~CConstrainTransformInterval(void);</span>

<span class="s0">254 14 get_blend_type 0 4 348 29 CLerpInterval::get_blend_type 0 1 86 163</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the blend type specified for the interval.  This controls how the</span>
 <span class="s0">* linear interpolation behaves near the beginning and end of the lerp period.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const;</span>

<span class="s0">255 17 string_blend_type 0 4 348 32 CLerpInterval::string_blend_type 0 1 87 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the BlendType enumerated value corresponding to the indicated</span>
 <span class="s0">* string, or BT_invalid if the string doesn't match anything.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">static CLerpInterval::BlendType CLerpInterval::string_blend_type(std::string const &amp;blend_type);</span>

<span class="s0">256 14 get_class_type 0 4 348 29 CLerpInterval::get_class_type 0 1 88 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle CLerpInterval::get_class_type(void);</span>

<span class="s0">257 13 CLerpInterval 0 260 348 28 CLerpInterval::CLerpInterval 0 1 85 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline CLerpInterval::CLerpInterval(CLerpInterval const &amp;) = default;</span>

<span class="s0">258 14 ~CLerpInterval 0 516 348 29 CLerpInterval::~CLerpInterval 0 0 0</span>
<span class="s0">36</span>
<span class="s0">CLerpInterval::~CLerpInterval(void);</span>

<span class="s0">259 23 CLerpAnimEffectInterval 0 260 350 48 CLerpAnimEffectInterval::CLerpAnimEffectInterval 0 2 89 90 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">244</span>
<span class="s0">inline explicit CLerpAnimEffectInterval::CLerpAnimEffectInterval(std::string const &amp;name, double duration, CLerpInterval::BlendType blend_type);</span>
<span class="s0">inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(CLerpAnimEffectInterval const &amp;) = default;</span>

<span class="s0">260 11 add_control 0 4 350 36 CLerpAnimEffectInterval::add_control 0 1 91 274</span>
<span class="s0">/**</span>
 <span class="s0">* Adds another AnimControl to the list of AnimControls affected by the lerp.</span>
 <span class="s0">* This control will be lerped from begin_effect to end_effect over the period</span>
 <span class="s0">* of the lerp.</span>
 <span class="s0">*</span>
 <span class="s0">* The AnimControl name parameter is only used when formatting the interval</span>
 <span class="s0">* for output.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">inline void CLerpAnimEffectInterval::add_control(AnimControl *control, std::string const &amp;name, float begin_effect, float end_effect);</span>

<span class="s0">261 14 get_class_type 0 4 350 39 CLerpAnimEffectInterval::get_class_type 0 1 92 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle CLerpAnimEffectInterval::get_class_type(void);</span>

<span class="s0">262 24 ~CLerpAnimEffectInterval 0 516 350 49 CLerpAnimEffectInterval::~CLerpAnimEffectInterval 0 0 0</span>
<span class="s0">56</span>
<span class="s0">CLerpAnimEffectInterval::~CLerpAnimEffectInterval(void);</span>

<span class="s0">263 21 CLerpNodePathInterval 0 260 351 44 CLerpNodePathInterval::CLerpNodePathInterval 0 2 93 94 1229</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a lerp interval that will lerp some properties on the indicated</span>
 <span class="s0">* node, possibly relative to the indicated other node (if other is nonempty).</span>
 <span class="s0">*</span>
 <span class="s0">* You must call set_end_pos(), etc.  for the various properties you wish to</span>
 <span class="s0">* lerp before the first call to priv_initialize().  If you want to set a</span>
 <span class="s0">* starting value for any of the properties, you may call set_start_pos(),</span>
 <span class="s0">* etc.; otherwise, the starting value is taken from the actual node's value</span>
 <span class="s0">* at the time the lerp is performed.</span>
 <span class="s0">*</span>
 <span class="s0">* The starting values may be explicitly specified or omitted.  The value of</span>
 <span class="s0">* bake_in_start determines the behavior if the starting values are omitted.</span>
 <span class="s0">* If bake_in_start is true, the values are obtained the first time the lerp</span>
 <span class="s0">* runs, and thenceforth are stored within the interval.  If bake_in_start is</span>
 <span class="s0">* false, the starting value is computed each frame, based on assuming the</span>
 <span class="s0">* current value represents the value set from the last time the interval was</span>
 <span class="s0">* run.  This &quot;smart&quot; behavior allows code to manipulate the object event</span>
 <span class="s0">* while it is being lerped, and the lerp continues to apply in a sensible</span>
 <span class="s0">* way.</span>
 <span class="s0">*</span>
 <span class="s0">* If fluid is true, the prev_transform is not adjusted by the lerp;</span>
 <span class="s0">* otherwise, it is reset.</span>
 <span class="s0">*/</span>
<span class="s0">304</span>
<span class="s0">explicit CLerpNodePathInterval::CLerpNodePathInterval(std::string const &amp;name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &amp;node, NodePath const &amp;other);</span>
<span class="s0">inline CLerpNodePathInterval::CLerpNodePathInterval(CLerpNodePathInterval const &amp;) = default;</span>

<span class="s0">264 8 get_node 0 4 351 31 CLerpNodePathInterval::get_node 0 1 95 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node being lerped.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline NodePath const &amp;CLerpNodePathInterval::get_node(void) const;</span>

<span class="s0">265 9 get_other 0 4 351 32 CLerpNodePathInterval::get_other 0 1 96 184</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;other&quot; node, which the lerped node is being moved relative to.</span>
 <span class="s0">* If this is an empty node path, the lerped node is being moved in its own</span>
 <span class="s0">* coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline NodePath const &amp;CLerpNodePathInterval::get_other(void) const;</span>

<span class="s0">266 13 set_start_pos 0 4 351 36 CLerpNodePathInterval::set_start_pos 0 1 97 264</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial position of the lerped node.  This is meaningful only</span>
 <span class="s0">* if set_end_pos() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual position at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_pos(LVecBase3 const &amp;pos);</span>

<span class="s0">267 11 set_end_pos 0 4 351 34 CLerpNodePathInterval::set_end_pos 0 1 98 250</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the position of the node should be lerped, and specifies the</span>
 <span class="s0">* final position of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's position will not be</span>
 <span class="s0">* affected by the lerp.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_pos(LVecBase3 const &amp;pos);</span>

<span class="s0">268 13 set_start_hpr 0 4 351 36 CLerpNodePathInterval::set_start_hpr 0 1 99 289</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial rotation of the lerped node.  This is meaningful only</span>
 <span class="s0">* if either set_end_hpr() or set_end_quat() is also called.  This parameter</span>
 <span class="s0">* is optional; if unspecified, the value will be taken from the node's actual</span>
 <span class="s0">* rotation at the time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_hpr(LVecBase3 const &amp;hpr);</span>

<span class="s0">269 11 set_end_hpr 0 4 351 34 CLerpNodePathInterval::set_end_hpr 0 2 100 101 754</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the rotation of the node should be lerped, and specifies the</span>
 <span class="s0">* final rotation of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().</span>
 <span class="s0">*</span>
 <span class="s0">* This replaces a previous call to set_end_quat().  If neither set_end_hpr()</span>
 <span class="s0">* nor set_end_quat() is called, the node's rotation will not be affected by</span>
 <span class="s0">* the lerp.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Indicates that the rotation of the node should be lerped, and specifies the</span>
 <span class="s0">* final rotation of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().</span>
 <span class="s0">*</span>
 <span class="s0">* This special function is overloaded to accept a quaternion, even though the</span>
 <span class="s0">* function name is set_end_hpr().  The quaternion will be implicitly</span>
 <span class="s0">* converted to a HPR trio, and the lerp will be performed in HPR space,</span>
 <span class="s0">* componentwise.</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_hpr(LVecBase3 const &amp;hpr);</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_hpr(LQuaternion const &amp;quat);</span>

<span class="s0">270 14 set_start_quat 0 4 351 37 CLerpNodePathInterval::set_start_quat 0 1 102 340</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial rotation of the lerped node.  This is meaningful only</span>
 <span class="s0">* if either set_end_quat() or set_end_hpr() is also called.  This parameter</span>
 <span class="s0">* is optional; if unspecified, the value will be taken from the node's actual</span>
 <span class="s0">* rotation at the time the lerp is performed.</span>
 <span class="s0">*</span>
 <span class="s0">* The given quaternion needs to be normalized.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_quat(LQuaternion const &amp;quat);</span>

<span class="s0">271 12 set_end_quat 0 4 351 35 CLerpNodePathInterval::set_end_quat 0 2 103 104 981</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the rotation of the node should be lerped, and specifies the</span>
 <span class="s0">* final rotation of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().</span>
 <span class="s0">*</span>
 <span class="s0">* This replaces a previous call to set_end_hpr().  If neither set_end_quat()</span>
 <span class="s0">* nor set_end_hpr() is called, the node's rotation will not be affected by</span>
 <span class="s0">* the lerp.</span>
 <span class="s0">*</span>
 <span class="s0">* This special function is overloaded to accept a HPR trio, even though the</span>
 <span class="s0">* function name is set_end_quat().  The HPR will be implicitly converted to a</span>
 <span class="s0">* quaternion, and the lerp will be performed in quaternion space, as a</span>
 <span class="s0">* spherical lerp.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Indicates that the rotation of the node should be lerped, and specifies the</span>
 <span class="s0">* final rotation of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().</span>
 <span class="s0">*</span>
 <span class="s0">* This replaces a previous call to set_end_hpr().  If neither set_end_quat()</span>
 <span class="s0">* nor set_end_hpr() is called, the node's rotation will not be affected by</span>
 <span class="s0">* the lerp.</span>
 <span class="s0">*</span>
 <span class="s0">* The given quaternion needs to be normalized.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_quat(LVecBase3 const &amp;hpr);</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_quat(LQuaternion const &amp;quat);</span>

<span class="s0">272 15 set_start_scale 0 4 351 38 CLerpNodePathInterval::set_start_scale 0 2 105 106 522</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial scale of the lerped node.  This is meaningful only if</span>
 <span class="s0">* set_end_scale() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual scale at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Indicates the initial scale of the lerped node.  This is meaningful only if</span>
 <span class="s0">* set_end_scale() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual scale at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_scale(LVecBase3 const &amp;scale);</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_scale(PN_stdfloat scale);</span>

<span class="s0">273 13 set_end_scale 0 4 351 36 CLerpNodePathInterval::set_end_scale 0 2 107 108 476</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the scale of the node should be lerped, and specifies the</span>
 <span class="s0">* final scale of the node.  This should be called before priv_initialize().</span>
 <span class="s0">* If this is not called, the node's scale will not be affected by the lerp.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Indicates that the scale of the node should be lerped, and specifies the</span>
 <span class="s0">* final scale of the node.  This should be called before priv_initialize().</span>
 <span class="s0">* If this is not called, the node's scale will not be affected by the lerp.</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_scale(LVecBase3 const &amp;scale);</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_scale(PN_stdfloat scale);</span>

<span class="s0">274 15 set_start_shear 0 4 351 38 CLerpNodePathInterval::set_start_shear 0 1 109 260</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial shear of the lerped node.  This is meaningful only if</span>
 <span class="s0">* set_end_shear() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual shear at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_shear(LVecBase3 const &amp;shear);</span>

<span class="s0">275 13 set_end_shear 0 4 351 36 CLerpNodePathInterval::set_end_shear 0 1 110 237</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the shear of the node should be lerped, and specifies the</span>
 <span class="s0">* final shear of the node.  This should be called before priv_initialize().</span>
 <span class="s0">* If this is not called, the node's shear will not be affected by the lerp.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_shear(LVecBase3 const &amp;shear);</span>

<span class="s0">276 15 set_start_color 0 4 351 38 CLerpNodePathInterval::set_start_color 0 1 111 260</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial color of the lerped node.  This is meaningful only if</span>
 <span class="s0">* set_end_color() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual color at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_color(LVecBase4 const &amp;color);</span>

<span class="s0">277 13 set_end_color 0 4 351 36 CLerpNodePathInterval::set_end_color 0 1 112 237</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the color of the node should be lerped, and specifies the</span>
 <span class="s0">* final color of the node.  This should be called before priv_initialize().</span>
 <span class="s0">* If this is not called, the node's color will not be affected by the lerp.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_color(LVecBase4 const &amp;color);</span>

<span class="s0">278 21 set_start_color_scale 0 4 351 44 CLerpNodePathInterval::set_start_color_scale 0 1 113 278</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial color scale of the lerped node.  This is meaningful</span>
 <span class="s0">* only if set_end_color_scale() is also called.  This parameter is optional;</span>
 <span class="s0">* if unspecified, the value will be taken from the node's actual color scale</span>
 <span class="s0">* at the time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4 const &amp;color_scale);</span>

<span class="s0">279 19 set_end_color_scale 0 4 351 42 CLerpNodePathInterval::set_end_color_scale 0 1 114 259</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the color scale of the node should be lerped, and specifies</span>
 <span class="s0">* the final color scale of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's color scale will not</span>
 <span class="s0">* be affected by the lerp.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4 const &amp;color_scale);</span>

<span class="s0">280 17 set_texture_stage 0 4 351 40 CLerpNodePathInterval::set_texture_stage 0 1 115 169</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the texture stage that is adjusted by tex_offset, tex_rotate,</span>
 <span class="s0">* and/or tex_scale.  If this is not set, the default is the default texture</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage);</span>

<span class="s0">281 20 set_start_tex_offset 0 4 351 43 CLerpNodePathInterval::set_start_tex_offset 0 1 116 273</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial UV offset of the lerped node.  This is meaningful</span>
 <span class="s0">* only if set_end_tex_offset() is also called.  This parameter is optional;</span>
 <span class="s0">* if unspecified, the value will be taken from the node's actual UV offset at</span>
 <span class="s0">* the time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2 const &amp;tex_offset);</span>

<span class="s0">282 18 set_end_tex_offset 0 4 351 41 CLerpNodePathInterval::set_end_tex_offset 0 1 117 253</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the UV offset of the node should be lerped, and specifies</span>
 <span class="s0">* the final UV offset of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's UV offset will not be</span>
 <span class="s0">* affected by the lerp.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2 const &amp;tex_offset);</span>

<span class="s0">283 20 set_start_tex_rotate 0 4 351 43 CLerpNodePathInterval::set_start_tex_rotate 0 1 118 273</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial UV rotate of the lerped node.  This is meaningful</span>
 <span class="s0">* only if set_end_tex_rotate() is also called.  This parameter is optional;</span>
 <span class="s0">* if unspecified, the value will be taken from the node's actual UV rotate at</span>
 <span class="s0">* the time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_tex_rotate(PN_stdfloat tex_rotate);</span>

<span class="s0">284 18 set_end_tex_rotate 0 4 351 41 CLerpNodePathInterval::set_end_tex_rotate 0 1 119 253</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the UV rotate of the node should be lerped, and specifies</span>
 <span class="s0">* the final UV rotate of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's UV rotate will not be</span>
 <span class="s0">* affected by the lerp.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_tex_rotate(PN_stdfloat tex_rotate);</span>

<span class="s0">285 19 set_start_tex_scale 0 4 351 42 CLerpNodePathInterval::set_start_tex_scale 0 1 120 270</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the initial UV scale of the lerped node.  This is meaningful only</span>
 <span class="s0">* if set_end_tex_scale() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual UV scale at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2 const &amp;tex_scale);</span>

<span class="s0">286 17 set_end_tex_scale 0 4 351 40 CLerpNodePathInterval::set_end_tex_scale 0 1 121 250</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the UV scale of the node should be lerped, and specifies the</span>
 <span class="s0">* final UV scale of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's UV scale will not be</span>
 <span class="s0">* affected by the lerp.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2 const &amp;tex_scale);</span>

<span class="s0">287 12 set_override 0 4 351 35 CLerpNodePathInterval::set_override 0 1 122 326</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the override value that will be associated with any state changes</span>
 <span class="s0">* applied by the lerp.  If this lerp is changing state (for instance, a color</span>
 <span class="s0">* lerp or a tex matrix lerp), then the new attributes created by this lerp</span>
 <span class="s0">* will be assigned the indicated override value when they are applied to the</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void CLerpNodePathInterval::set_override(int override);</span>

<span class="s0">288 12 get_override 0 4 351 35 CLerpNodePathInterval::get_override 0 1 123 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the override value that will be associated with any state changes</span>
 <span class="s0">* applied by the lerp.  See set_override().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int CLerpNodePathInterval::get_override(void) const;</span>

<span class="s0">289 14 get_class_type 0 4 351 37 CLerpNodePathInterval::get_class_type 0 1 124 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle CLerpNodePathInterval::get_class_type(void);</span>

<span class="s0">290 22 ~CLerpNodePathInterval 0 516 351 45 CLerpNodePathInterval::~CLerpNodePathInterval 0 0 0</span>
<span class="s0">52</span>
<span class="s0">CLerpNodePathInterval::~CLerpNodePathInterval(void);</span>

<span class="s0">291 13 CMetaInterval 0 260 352 28 CMetaInterval::CMetaInterval 0 2 125 126 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">explicit CMetaInterval::CMetaInterval(std::string const &amp;name);</span>
<span class="s0">inline CMetaInterval::CMetaInterval(CMetaInterval const &amp;) = default;</span>

<span class="s0">292 13 set_precision 0 4 352 28 CMetaInterval::set_precision 0 1 127 392</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the precision with which time measurements are compared.  For</span>
 <span class="s0">* numerical accuracy, all floating-point time values are converted to integer</span>
 <span class="s0">* values internally by scaling by the precision factor.  The larger the</span>
 <span class="s0">* number given here, the smaller the delta of time that can be</span>
 <span class="s0">* differentiated; the limit is the maximum integer that can be represented in</span>
 <span class="s0">* the system.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void CMetaInterval::set_precision(double precision);</span>

<span class="s0">293 13 get_precision 0 4 352 28 CMetaInterval::get_precision 0 1 128 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the precision with which time measurements are compared.  See</span>
 <span class="s0">* set_precision().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline double CMetaInterval::get_precision(void) const;</span>

<span class="s0">294 15 clear_intervals 0 4 352 30 CMetaInterval::clear_intervals 0 1 129 78</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the list of intervals and prepares for receiving a new list.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void CMetaInterval::clear_intervals(void);</span>

<span class="s0">295 10 push_level 0 4 352 25 CMetaInterval::push_level 0 1 130 343</span>
<span class="s0">/**</span>
 <span class="s0">* Marks the beginning of a nested level of child intervals.  Within the</span>
 <span class="s0">* nested level, a RelativeStart time of RS_level_begin refers to the start of</span>
 <span class="s0">* the level, and the first interval added within the level is always relative</span>
 <span class="s0">* to the start of the level.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index of the def entry created by this push.</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">int CMetaInterval::push_level(std::string const &amp;name, double rel_time, CMetaInterval::RelativeStart rel_to);</span>

<span class="s0">296 14 add_c_interval 0 4 352 29 CMetaInterval::add_c_interval 0 1 131 235</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new CInterval to the list.  The interval will be played when the</span>
 <span class="s0">* indicated time (relative to the given point) has been reached.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index of the def entry representing the new</span>
 <span class="s0">* interval.</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = 0.0, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_previous_end);</span>

<span class="s0">297 13 add_ext_index 0 4 352 28 CMetaInterval::add_ext_index 0 1 132 731</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new external interval to the list.  This represents some object in</span>
 <span class="s0">* the external scripting language that has properties similar to a CInterval</span>
 <span class="s0">* (for instance, a Python Interval object).</span>
 <span class="s0">*</span>
 <span class="s0">* The CMetaInterval object cannot play this external interval directly, but</span>
 <span class="s0">* it records a placeholder for it and will ask the scripting language to play</span>
 <span class="s0">* it when it is time, via is_event_ready() and related methods.</span>
 <span class="s0">*</span>
 <span class="s0">* The ext_index number itself is simply a handle that the scripting language</span>
 <span class="s0">* makes up and associates with its interval object somehow.  The</span>
 <span class="s0">* CMetaInterval object does not attempt to interpret this value.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index of the def entry representing the new</span>
 <span class="s0">* interval.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">int CMetaInterval::add_ext_index(int ext_index, std::string const &amp;name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to);</span>

<span class="s0">298 9 pop_level 0 4 352 24 CMetaInterval::pop_level 0 1 133 342</span>
<span class="s0">/**</span>
 <span class="s0">* Finishes a level marked by a previous call to push_level(), and returns to</span>
 <span class="s0">* the previous level.</span>
 <span class="s0">*</span>
 <span class="s0">* If the duration is not negative, it represents a phony duration to assign</span>
 <span class="s0">* to the level, for the purposes of sequencing later intervals.  Otherwise,</span>
 <span class="s0">* the level's duration is computed based on the intervals within the level.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">int CMetaInterval::pop_level(double duration = -1.0);</span>

<span class="s0">299 23 set_interval_start_time 0 4 352 38 CMetaInterval::set_interval_start_time 0 1 134 458</span>
<span class="s0">/**</span>
 <span class="s0">* Adjusts the start time of the child interval with the given name, if found.</span>
 <span class="s0">* This may be either a C++ interval added via add_c_interval(), or an</span>
 <span class="s0">* external interval added via add_ext_index(); the name must match exactly.</span>
 <span class="s0">*</span>
 <span class="s0">* If the interval is found, its start time is adjusted, and all subsequent</span>
 <span class="s0">* intervals are adjusting accordingly, and true is returned.  If a matching</span>
 <span class="s0">* interval is not found, nothing is changed and false is returned.</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">bool CMetaInterval::set_interval_start_time(std::string const &amp;name, double rel_time, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_level_begin);</span>

<span class="s0">300 23 get_interval_start_time 0 4 352 38 CMetaInterval::get_interval_start_time 0 1 135 179</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the actual start time, relative to the beginning of the interval,</span>
 <span class="s0">* of the child interval with the given name, if found, or -1 if the interval</span>
 <span class="s0">* is not found.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">double CMetaInterval::get_interval_start_time(std::string const &amp;name) const;</span>

<span class="s0">301 21 get_interval_end_time 0 4 352 36 CMetaInterval::get_interval_end_time 0 1 136 177</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the actual end time, relative to the beginning of the interval, of</span>
 <span class="s0">* the child interval with the given name, if found, or -1 if the interval is</span>
 <span class="s0">* not found.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">double CMetaInterval::get_interval_end_time(std::string const &amp;name) const;</span>

<span class="s0">302 12 get_num_defs 0 4 352 27 CMetaInterval::get_num_defs 0 1 137 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of interval and push/pop definitions that have been</span>
 <span class="s0">* added to the meta interval.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int CMetaInterval::get_num_defs(void) const;</span>

<span class="s0">303 12 get_def_type 0 4 352 27 CMetaInterval::get_def_type 0 1 138 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of the nth interval definition that has been added.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const;</span>

<span class="s0">304 14 get_c_interval 0 4 352 29 CMetaInterval::get_c_interval 0 1 139 159</span>
<span class="s0">/**</span>
 <span class="s0">* Return the CInterval pointer associated with the nth interval definition.</span>
 <span class="s0">* It is only valid to call this if get_def_type(n) returns DT_c_interval.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline CInterval *CMetaInterval::get_c_interval(int n) const;</span>

<span class="s0">305 13 get_ext_index 0 4 352 28 CMetaInterval::get_ext_index 0 1 140 175</span>
<span class="s0">/**</span>
 <span class="s0">* Return the external interval index number associated with the nth interval</span>
 <span class="s0">* definition.  It is only valid to call this if get_def_type(n) returns</span>
 <span class="s0">* DT_ext_index.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int CMetaInterval::get_ext_index(int n) const;</span>

<span class="s0">306 14 is_event_ready 0 4 352 29 CMetaInterval::is_event_ready 0 1 141 267</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a recent call to priv_initialize(), priv_step(), or</span>
 <span class="s0">* priv_finalize() has left some external intervals ready to play.  If this</span>
 <span class="s0">* returns true, call get_event_index(), get_event_t(), and pop_event() to</span>
 <span class="s0">* retrieve the relevant information.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool CMetaInterval::is_event_ready(void);</span>

<span class="s0">307 15 get_event_index 0 4 352 30 CMetaInterval::get_event_index 0 1 142 180</span>
<span class="s0">/**</span>
 <span class="s0">* If a previous call to is_event_ready() returned true, this returns the</span>
 <span class="s0">* index number (added via add_event_index()) of the external interval that</span>
 <span class="s0">* needs to be played.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int CMetaInterval::get_event_index(void) const;</span>

<span class="s0">308 11 get_event_t 0 4 352 26 CMetaInterval::get_event_t 0 1 143 134</span>
<span class="s0">/**</span>
 <span class="s0">* If a previous call to is_event_ready() returned true, this returns the t</span>
 <span class="s0">* value that should be fed to the given interval.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double CMetaInterval::get_event_t(void) const;</span>

<span class="s0">309 14 get_event_type 0 4 352 29 CMetaInterval::get_event_type 0 1 144 161</span>
<span class="s0">/**</span>
 <span class="s0">* If a previous call to is_event_ready() returned true, this returns the type</span>
 <span class="s0">* of the event (initialize, step, finalize, etc.) for the given interval.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline CInterval::EventType CMetaInterval::get_event_type(void) const;</span>

<span class="s0">310 9 pop_event 0 4 352 24 CMetaInterval::pop_event 0 1 145 302</span>
<span class="s0">/**</span>
 <span class="s0">* Acknowledges that the external interval on the top of the queue has been</span>
 <span class="s0">* extracted, and is about to be serviced by the scripting language.  This</span>
 <span class="s0">* prepares the interval so the next call to is_event_ready() will return</span>
 <span class="s0">* information about the next external interval on the queue, if any.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void CMetaInterval::pop_event(void);</span>

<span class="s0">311 8 timeline 0 4 352 23 CMetaInterval::timeline 0 1 146 73</span>
<span class="s0">/**</span>
 <span class="s0">* Outputs a list of all events in the order in which they occur.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void CMetaInterval::timeline(std::ostream &amp;out) const;</span>

<span class="s0">312 14 get_class_type 0 4 352 29 CMetaInterval::get_class_type 0 1 147 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle CMetaInterval::get_class_type(void);</span>

<span class="s0">313 12 HideInterval 0 260 355 26 HideInterval::HideInterval 0 2 148 149 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">explicit HideInterval::HideInterval(NodePath const &amp;node, std::string const &amp;name = string());</span>
<span class="s0">inline HideInterval::HideInterval(HideInterval const &amp;) = default;</span>

<span class="s0">314 14 get_class_type 0 4 355 28 HideInterval::get_class_type 0 1 150 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle HideInterval::get_class_type(void);</span>

<span class="s0">315 13 ~HideInterval 0 516 355 27 HideInterval::~HideInterval 0 0 0</span>
<span class="s0">34</span>
<span class="s0">HideInterval::~HideInterval(void);</span>

<span class="s0">316 11 operator () 0 6 356 26 LerpBlendType::operator () 0 1 151 0</span>
<span class="s0">65</span>
<span class="s0">virtual PN_stdfloat LerpBlendType::operator ()(PN_stdfloat ) = 0;</span>

<span class="s0">317 14 get_class_type 0 4 356 29 LerpBlendType::get_class_type 0 1 152 27</span>
<span class="s0">// now for typehandle stuff</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle LerpBlendType::get_class_type(void);</span>

<span class="s0">318 15 EaseInBlendType 0 260 357 32 EaseInBlendType::EaseInBlendType 0 1 153 0</span>
<span class="s0">39</span>
<span class="s0">EaseInBlendType::EaseInBlendType(void);</span>

<span class="s0">319 14 get_class_type 0 4 357 31 EaseInBlendType::get_class_type 0 1 154 27</span>
<span class="s0">// now for typehandle stuff</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle EaseInBlendType::get_class_type(void);</span>

<span class="s0">320 16 EaseOutBlendType 0 260 358 34 EaseOutBlendType::EaseOutBlendType 0 1 155 0</span>
<span class="s0">41</span>
<span class="s0">EaseOutBlendType::EaseOutBlendType(void);</span>

<span class="s0">321 14 get_class_type 0 4 358 32 EaseOutBlendType::get_class_type 0 1 156 27</span>
<span class="s0">// now for typehandle stuff</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle EaseOutBlendType::get_class_type(void);</span>

<span class="s0">322 18 EaseInOutBlendType 0 260 359 38 EaseInOutBlendType::EaseInOutBlendType 0 1 157 0</span>
<span class="s0">45</span>
<span class="s0">EaseInOutBlendType::EaseInOutBlendType(void);</span>

<span class="s0">323 14 get_class_type 0 4 359 34 EaseInOutBlendType::get_class_type 0 1 158 27</span>
<span class="s0">// now for typehandle stuff</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle EaseInOutBlendType::get_class_type(void);</span>

<span class="s0">324 11 NoBlendType 0 260 360 24 NoBlendType::NoBlendType 0 1 159 0</span>
<span class="s0">31</span>
<span class="s0">NoBlendType::NoBlendType(void);</span>

<span class="s0">325 14 get_class_type 0 4 360 27 NoBlendType::get_class_type 0 1 160 27</span>
<span class="s0">// now for typehandle stuff</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle NoBlendType::get_class_type(void);</span>

<span class="s0">326 12 ShowInterval 0 260 361 26 ShowInterval::ShowInterval 0 2 161 162 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">explicit ShowInterval::ShowInterval(NodePath const &amp;node, std::string const &amp;name = string());</span>
<span class="s0">inline ShowInterval::ShowInterval(ShowInterval const &amp;) = default;</span>

<span class="s0">327 14 get_class_type 0 4 361 28 ShowInterval::get_class_type 0 1 163 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle ShowInterval::get_class_type(void);</span>

<span class="s0">328 13 ~ShowInterval 0 516 361 27 ShowInterval::~ShowInterval 0 0 0</span>
<span class="s0">34</span>
<span class="s0">ShowInterval::~ShowInterval(void);</span>

<span class="s0">329 12 WaitInterval 0 260 362 26 WaitInterval::WaitInterval 0 2 164 165 111</span>
<span class="s0">/**</span>
 <span class="s0">* All Wait intervals have the same name.  No one really cares if their names</span>
 <span class="s0">* are unique, after all.</span>
 <span class="s0">*/</span>
<span class="s0">127</span>
<span class="s0">inline explicit WaitInterval::WaitInterval(double duration);</span>
<span class="s0">inline WaitInterval::WaitInterval(WaitInterval const &amp;) = default;</span>

<span class="s0">330 14 get_class_type 0 4 362 28 WaitInterval::get_class_type 0 1 166 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle WaitInterval::get_class_type(void);</span>

<span class="s0">331 13 ~WaitInterval 0 516 362 27 WaitInterval::~WaitInterval 0 0 0</span>
<span class="s0">34</span>
<span class="s0">WaitInterval::~WaitInterval(void);</span>

<span class="s0">166</span>
<span class="s0">1 0 0 15 85 365 0 0 0 1 6 param0 0 363  </span>
<span class="s0">2 0 0 6 3 366 0 0 39 /**</span>
 <span class="s0">* Returns the interval's name.</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">3 0 0 6 4 339 0 0 59 /**</span>
 <span class="s0">* Returns the duration of the interval in seconds.</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">4 0 0 6 5 340 0 0 381 /**</span>
 <span class="s0">* Returns the state of the &quot;open_ended&quot; flag.  This is primarily intended for</span>
 <span class="s0">* instantaneous intervals like FunctionIntervals; it indicates true if the</span>
 <span class="s0">* interval has some lasting effect that should be applied even if the</span>
 <span class="s0">* interval doesn't get started until after its finish time, or false if the</span>
 <span class="s0">* interval is a transitive thing that doesn't need to be called late.</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">5 0 0 6 8 335 0 0 145 /**</span>
 <span class="s0">* Indicates the state the interval believes it is in: whether it has been</span>
 <span class="s0">* started, is currently in the middle, or has been finalized.</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">6 0 0 6 9 340 0 0 123 /**</span>
 <span class="s0">* Returns true if the interval is in either its initial or final states (but</span>
 <span class="s0">* not in a running or paused state).</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">7 0 0 4 10 367 0 0 167 /**</span>
 <span class="s0">* Sets the event that is generated whenever the interval reaches its final</span>
 <span class="s0">* state, whether it is explicitly finished or whether it gets there on its</span>
 <span class="s0">* own.</span>
 <span class="s0">*/ 2 4 this 3 365  5 event 1 366  </span>
<span class="s0">8 0 0 6 11 366 0 0 170 /**</span>
 <span class="s0">* Returns the event that is generated whenever the interval reaches its final</span>
 <span class="s0">* state, whether it is explicitly finished or whether it gets there on its</span>
 <span class="s0">* own.</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">9 0 0 4 12 367 0 0 201 /**</span>
 <span class="s0">* Explicitly sets the time within the interval.  Normally, you would use</span>
 <span class="s0">* start() .. finish() to let the time play normally, but this may be used to</span>
 <span class="s0">* set the time to some particular value.</span>
 <span class="s0">*/ 2 4 this 3 365  1 t 1 339  </span>
<span class="s0">10 0 0 6 13 339 0 0 137 /**</span>
 <span class="s0">* Returns the current time of the interval: the last value of t passed to</span>
 <span class="s0">* priv_initialize(), priv_step(), or priv_finalize().</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">11 0 0 4 14 367 0 0 317 /**</span>
 <span class="s0">* Changes the state of the 'auto_pause' flag.  If this is true, the interval</span>
 <span class="s0">* may be arbitrarily interrupted when the system needs to reset due to some</span>
 <span class="s0">* external event by calling CIntervalManager::interrupt().  If this is false</span>
 <span class="s0">* (the default), the interval must always be explicitly finished or paused.</span>
 <span class="s0">*/ 2 4 this 3 365  10 auto_pause 1 340  </span>
<span class="s0">12 0 0 6 15 340 0 0 77 /**</span>
 <span class="s0">* Returns the state of the 'auto_pause' flag.  See set_auto_pause().</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">13 0 0 4 16 367 0 0 315 /**</span>
 <span class="s0">* Changes the state of the 'auto_finish' flag.  If this is true, the interval</span>
 <span class="s0">* may be arbitrarily finished when the system needs to reset due to some</span>
 <span class="s0">* external event by calling CIntervalManager::interrupt().  If this is false</span>
 <span class="s0">* (the default), the interval must always be explicitly finished or paused.</span>
 <span class="s0">*/ 2 4 this 3 365  11 auto_finish 1 340  </span>
<span class="s0">14 0 0 6 17 340 0 0 79 /**</span>
 <span class="s0">* Returns the state of the 'auto_finish' flag.  See set_auto_finish().</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">15 0 0 4 18 367 0 0 254 /**</span>
 <span class="s0">* Changes the state of the 'wants_t_callback' flag.  If this is true, the</span>
 <span class="s0">* interval will be returned by CIntervalManager::get_event() each time the</span>
 <span class="s0">* interval's time value has been changed, regardless of whether it has any</span>
 <span class="s0">* external events.</span>
 <span class="s0">*/ 2 4 this 3 365  16 wants_t_callback 1 340  </span>
<span class="s0">16 0 0 6 19 340 0 0 92 /**</span>
 <span class="s0">* Returns the state of the 'wants_t_callback' flag.  See</span>
 <span class="s0">* set_wants_t_callback().</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">17 0 0 4 20 367 0 0 253 /**</span>
 <span class="s0">* Indicates the CIntervalManager object which will be responsible for playing</span>
 <span class="s0">* this interval.  This defaults to the global CIntervalManager; you should</span>
 <span class="s0">* need to change this only if you have special requirements for playing this</span>
 <span class="s0">* interval.</span>
 <span class="s0">*/ 2 4 this 3 365  7 manager 1 341  </span>
<span class="s0">18 0 0 6 21 341 0 0 320 /**</span>
 <span class="s0">* Returns the CIntervalManager object which will be responsible for playing</span>
 <span class="s0">* this interval.  Note that this can only return a C++ object; if the</span>
 <span class="s0">* particular CIntervalManager object has been extended in the scripting</span>
 <span class="s0">* language, this will return the encapsulated C++ object, not the full</span>
 <span class="s0">* extended object.</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">19 0 0 4 22 367 0 0 211 /**</span>
 <span class="s0">* Starts the interval playing by registering it with the current</span>
 <span class="s0">* CIntervalManager.  The interval will play to the end and stop.</span>
 <span class="s0">*</span>
 <span class="s0">* If end_t is less than zero, it indicates the end of the interval.</span>
 <span class="s0">*/ 4 4 this 3 365  7 start_t 5 339  5 end_t 5 339  9 play_rate 5 339  </span>
<span class="s0">20 0 0 4 23 367 0 0 290 /**</span>
 <span class="s0">* Starts the interval playing by registering it with the current</span>
 <span class="s0">* CIntervalManager.  The interval will play until it is interrupted with</span>
 <span class="s0">* finish() or pause(), looping back to start_t when it reaches end_t.</span>
 <span class="s0">*</span>
 <span class="s0">* If end_t is less than zero, it indicates the end of the interval.</span>
 <span class="s0">*/ 4 4 this 3 365  7 start_t 5 339  5 end_t 5 339  9 play_rate 5 339  </span>
<span class="s0">21 0 0 6 24 339 0 0 143 /**</span>
 <span class="s0">* Stops the interval from playing but leaves it in its current state.  It may</span>
 <span class="s0">* later be resumed from this point by calling resume().</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">22 0 0 4 25 367 0 0 92 /**</span>
 <span class="s0">* Restarts the interval from its current point after a previous call to</span>
 <span class="s0">* pause().</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">23 0 0 4 25 367 0 0 94 /**</span>
 <span class="s0">* Restarts the interval from the indicated point after a previous call to</span>
 <span class="s0">* pause().</span>
 <span class="s0">*/ 2 4 this 3 365  7 start_t 1 339  </span>
<span class="s0">24 0 0 4 26 367 0 0 183 /**</span>
 <span class="s0">* Restarts the interval from the current point after a previous call to</span>
 <span class="s0">* pause() (or a previous play-to-point-and-stop), to play until the indicated</span>
 <span class="s0">* point and then stop.</span>
 <span class="s0">*/ 2 4 this 3 365  5 end_t 1 339  </span>
<span class="s0">25 0 0 4 27 367 0 0 74 /**</span>
 <span class="s0">* Stops the interval from playing and sets it to its final state.</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">26 0 0 4 28 367 0 0 276 /**</span>
 <span class="s0">* Pauses the interval, if it is playing, and resets its state to its initial</span>
 <span class="s0">* state, abandoning any state changes already in progress in the middle of</span>
 <span class="s0">* the interval.  Calling this is like pausing the interval and discarding it,</span>
 <span class="s0">* creating a new one in its place.</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">27 0 0 6 29 340 0 0 78 /**</span>
 <span class="s0">* Returns true if the interval is currently playing, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">28 0 0 6 30 339 0 0 99 /**</span>
 <span class="s0">* Returns the play rate as set by the last call to start(), loop(), or</span>
 <span class="s0">* set_play_rate().</span>
 <span class="s0">*/ 1 4 this 3 363  </span>
<span class="s0">29 0 0 4 31 367 0 0 257 /**</span>
 <span class="s0">* Changes the play rate of the interval.  If the interval is already started,</span>
 <span class="s0">* this changes its speed on-the-fly.  Note that since play_rate is a</span>
 <span class="s0">* parameter to start() and loop(), the next call to start() or loop() will</span>
 <span class="s0">* reset this parameter.</span>
 <span class="s0">*/ 2 4 this 3 365  9 play_rate 1 339  </span>
<span class="s0">30 0 0 4 32 367 0 0 199 // These cannot be declared private because they must be accessible to</span>
<span class="s0">// Python, but the method names are prefixed with priv_ to remind you that</span>
<span class="s0">// you probably don't want to be using them directly. 3 4 this 3 365  1 t 1 339  5 event 1 334  </span>
<span class="s0">31 0 0 4 33 367 0 0 216 /**</span>
 <span class="s0">* This replaces the first call to priv_step(), and indicates that the</span>
 <span class="s0">* interval has just begun.  This may be overridden by derived classes that</span>
 <span class="s0">* need to do some explicit initialization on the first call.</span>
 <span class="s0">*/ 2 4 this 3 365  1 t 1 339  </span>
<span class="s0">32 0 0 4 34 367 0 0 220 /**</span>
 <span class="s0">* This is called in lieu of priv_initialize() .. priv_step() ..</span>
 <span class="s0">* priv_finalize(), when everything is to happen within one frame.  The</span>
 <span class="s0">* interval should initialize itself, then leave itself in the final state.</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">33 0 0 4 35 367 0 0 164 /**</span>
 <span class="s0">* Advances the time on the interval.  The time may either increase (the</span>
 <span class="s0">* normal case) or decrease (e.g.  if the interval is being played by a</span>
 <span class="s0">* slider).</span>
 <span class="s0">*/ 2 4 this 3 365  1 t 1 339  </span>
<span class="s0">34 0 0 4 36 367 0 0 172 /**</span>
 <span class="s0">* This is called to stop an interval, forcing it to whatever state it would</span>
 <span class="s0">* be after it played all the way through.  It's generally invoked by</span>
 <span class="s0">* set_final_t().</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">35 0 0 4 37 367 0 0 213 /**</span>
 <span class="s0">* Similar to priv_initialize(), but this is called when the interval is being</span>
 <span class="s0">* played backwards; it indicates that the interval should start at the</span>
 <span class="s0">* finishing state and undo any intervening intervals.</span>
 <span class="s0">*/ 2 4 this 3 365  1 t 1 339  </span>
<span class="s0">36 0 0 4 38 367 0 0 240 /**</span>
 <span class="s0">* This is called in lieu of priv_reverse_initialize() .. priv_step() ..</span>
 <span class="s0">* priv_reverse_finalize(), when everything is to happen within one frame.</span>
 <span class="s0">* The interval should initialize itself, then leave itself in the initial</span>
 <span class="s0">* state.</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">37 0 0 4 39 367 0 0 137 /**</span>
 <span class="s0">* Called generally following a priv_reverse_initialize(), this indicates the</span>
 <span class="s0">* interval should set itself to the initial state.</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">38 0 0 4 40 367 0 0 471 /**</span>
 <span class="s0">* This is called while the interval is playing to indicate that it is about</span>
 <span class="s0">* to be interrupted; that is, priv_step() will not be called for a length of</span>
 <span class="s0">* time.  But the interval should remain in its current state in anticipation</span>
 <span class="s0">* of being eventually restarted when the calls to priv_step() eventually</span>
 <span class="s0">* resume.</span>
 <span class="s0">*</span>
 <span class="s0">* The purpose of this function is to allow self-running intervals like sound</span>
 <span class="s0">* intervals to stop the actual sound playback during the pause.</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">39 0 0 4 41 367 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 363  3 out 1 368  </span>
<span class="s0">40 0 0 4 42 367 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 363  3 out 1 368  12 indent_level 1 370  </span>
<span class="s0">41 0 0 4 43 367 0 0 487 /**</span>
 <span class="s0">* Called to prepare the interval for automatic timed playback, e.g.  via a</span>
 <span class="s0">* Python task.  The interval will be played from start_t to end_t, at a time</span>
 <span class="s0">* factor specified by play_rate.  start_t must always be less than end_t</span>
 <span class="s0">* (except for the exception for end_t == -1, below), but if play_rate is</span>
 <span class="s0">* negative the interval will be played backwards.</span>
 <span class="s0">*</span>
 <span class="s0">* Specify end_t of -1 to play the entire interval from start_t.</span>
 <span class="s0">*</span>
 <span class="s0">* Call step_play() repeatedly to execute the interval.</span>
 <span class="s0">*/ 5 4 this 3 365  10 start_time 1 339  8 end_time 1 339  9 play_rate 1 339  7 do_loop 1 340  </span>
<span class="s0">42 0 0 4 44 367 0 0 123 /**</span>
 <span class="s0">* Called to prepare the interval for restarting at the current point within</span>
 <span class="s0">* the interval after an interruption.</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">43 0 0 4 45 367 0 0 207 /**</span>
 <span class="s0">* Called to prepare the interval for restarting from the current point after</span>
 <span class="s0">* a previous call to pause() (or a previous play-to-point-and-stop), to play</span>
 <span class="s0">* until the indicated point and then stop.</span>
 <span class="s0">*/ 2 4 this 3 365  5 end_t 1 339  </span>
<span class="s0">44 0 0 6 46 340 0 0 202 /**</span>
 <span class="s0">* Should be called once per frame to execute the automatic timed playback</span>
 <span class="s0">* begun with setup_play().</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the interval should continue, false if it is done and</span>
 <span class="s0">* should stop.</span>
 <span class="s0">*/ 1 4 this 3 365  </span>
<span class="s0">45 0 0 38 47 371 0 0 0 1 4 this 3 365  </span>
<span class="s0">46 0 0 7 84 375 0 0 0 0 </span>
<span class="s0">47 0 0 7 65 341 211 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">48 0 0 4 67 367 0 0 378 /**</span>
 <span class="s0">* Specifies a custom event queue to be used for throwing done events from</span>
 <span class="s0">* intervals as they finish.  If this is not specified, the global event queue</span>
 <span class="s0">* is used.</span>
 <span class="s0">*</span>
 <span class="s0">* The caller maintains ownership of the EventQueue object; it is the caller's</span>
 <span class="s0">* responsibility to ensure that the supplied EventQueue does not destruct</span>
 <span class="s0">* during the lifetime of the CIntervalManager.</span>
 <span class="s0">*/ 2 4 this 3 341  11 event_queue 1 376  </span>
<span class="s0">49 0 0 6 68 376 0 0 111 /**</span>
 <span class="s0">* Returns the custom event queue to be used for throwing done events from</span>
 <span class="s0">* intervals as they finish.</span>
 <span class="s0">*/ 1 4 this 3 378  </span>
<span class="s0">50 0 0 6 69 370 0 0 663 /**</span>
 <span class="s0">* Adds the interval to the manager, and returns a unique index for the</span>
 <span class="s0">* interval.  This index will be unique among all the currently added</span>
 <span class="s0">* intervals, but not unique across all intervals ever added to the manager.</span>
 <span class="s0">* The maximum index value will never exceed the maximum number of intervals</span>
 <span class="s0">* added at any given time.</span>
 <span class="s0">*</span>
 <span class="s0">* If the external flag is true, the interval is understood to also be stored</span>
 <span class="s0">* in the scripting language data structures.  In this case, it will be</span>
 <span class="s0">* available for information returned by get_next_event() and</span>
 <span class="s0">* get_next_removal().  If external is false, the interval's index will never</span>
 <span class="s0">* be returned by these two functions.</span>
 <span class="s0">*/ 3 4 this 3 341  8 interval 1 365  8 external 1 340  </span>
<span class="s0">51 0 0 6 70 370 0 0 120 /**</span>
 <span class="s0">* Returns the index associated with the named interval, if there is such an</span>
 <span class="s0">* interval, or -1 if there is not.</span>
 <span class="s0">*/ 2 4 this 3 378  4 name 1 366  </span>
<span class="s0">52 0 0 7 71 365 0 0 64 /**</span>
 <span class="s0">* Returns the interval associated with the given index.</span>
 <span class="s0">*/ 2 4 this 3 378  5 index 1 370  </span>
<span class="s0">53 0 0 4 72 367 0 0 203 /**</span>
 <span class="s0">* Removes the indicated interval from the queue immediately.  It will not be</span>
 <span class="s0">* returned from get_next_removal(), and none of its pending events, if any,</span>
 <span class="s0">* will be returned by get_next_event().</span>
 <span class="s0">*/ 2 4 this 3 341  5 index 1 370  </span>
<span class="s0">54 0 0 6 73 370 0 0 316 /**</span>
 <span class="s0">* Pauses or finishes (removes from the active queue) all intervals tagged</span>
 <span class="s0">* with auto_pause or auto_finish set to true.  These are intervals that</span>
 <span class="s0">* someone fired up but won't necessarily expect to clean up; they can be</span>
 <span class="s0">* interrupted at will when necessary.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the number of intervals affected.</span>
 <span class="s0">*/ 1 4 this 3 341  </span>
<span class="s0">55 0 0 6 74 370 0 0 60 /**</span>
 <span class="s0">* Returns the number of currently active intervals.</span>
 <span class="s0">*/ 1 4 this 3 378  </span>
<span class="s0">56 0 0 6 75 370 0 0 295 /**</span>
 <span class="s0">* Returns one more than the largest interval index number in the manager.  If</span>
 <span class="s0">* you walk through all the values between (0, get_max_index()] and call</span>
 <span class="s0">* get_c_interval() on each number, you will retrieve all of the managed</span>
 <span class="s0">* intervals (and possibly a number of NULL pointers as well).</span>
 <span class="s0">*/ 1 4 this 3 378  </span>
<span class="s0">57 0 0 4 76 367 0 0 444 /**</span>
 <span class="s0">* This should be called every frame to do the processing for all the active</span>
 <span class="s0">* intervals.  It will call step_play() for each interval that has been added</span>
 <span class="s0">* and that has not yet been removed.</span>
 <span class="s0">*</span>
 <span class="s0">* After each call to step(), the scripting language should call</span>
 <span class="s0">* get_next_event() and get_next_removal() repeatedly to process all the high-</span>
 <span class="s0">* level (e.g.  Python-interval-based) events and to manage the high-level</span>
 <span class="s0">* list of intervals.</span>
 <span class="s0">*/ 1 4 this 3 341  </span>
<span class="s0">58 0 0 6 77 370 0 0 540 /**</span>
 <span class="s0">* This should be called by the scripting language after each call to step().</span>
 <span class="s0">* It returns the index number of the next interval that has events requiring</span>
 <span class="s0">* servicing by the scripting language, or -1 if no more intervals have any</span>
 <span class="s0">* events pending.</span>
 <span class="s0">*</span>
 <span class="s0">* If this function returns something other than -1, it is the scripting</span>
 <span class="s0">* language's responsibility to query the indicated interval for its next</span>
 <span class="s0">* event via get_event_index(), and eventually pop_event().</span>
 <span class="s0">*</span>
 <span class="s0">* Then get_next_event() should be called again until it returns -1.</span>
 <span class="s0">*/ 1 4 this 3 341  </span>
<span class="s0">59 0 0 6 78 370 0 0 366 /**</span>
 <span class="s0">* This should be called by the scripting language after each call to step().</span>
 <span class="s0">* It returns the index number of an interval that was recently removed, or -1</span>
 <span class="s0">* if no intervals were removed.</span>
 <span class="s0">*</span>
 <span class="s0">* If this returns something other than -1, the scripting language should</span>
 <span class="s0">* clean up its own data structures accordingly, and then call</span>
 <span class="s0">* get_next_removal() again.</span>
 <span class="s0">*/ 1 4 this 3 341  </span>
<span class="s0">60 0 0 4 79 367 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 378  3 out 1 368  </span>
<span class="s0">61 0 0 4 80 367 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 378  3 out 1 368  </span>
<span class="s0">62 0 0 6 81 341 0 0 73 /**</span>
 <span class="s0">* Returns the pointer to the one global CIntervalManager object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">63 0 0 15 91 382 233 0 0 1 6 param0 0 380  </span>
<span class="s0">64 0 0 7 90 375 0 0 0 0 </span>
<span class="s0">65 0 0 15 94 385 238 0 0 1 6 param0 0 383  </span>
<span class="s0">66 0 0 7 94 385 238 0 369 /**</span>
 <span class="s0">* Constructs a constraint interval that will constrain the orientation of one</span>
 <span class="s0">* node to the orientation of another, possibly with an added rotation.</span>
 <span class="s0">*</span>
 <span class="s0">* If wrt is true, the node's orientation will be transformed into the target</span>
 <span class="s0">* node's parent's  space before being copied.  If wrt is false, the target</span>
 <span class="s0">* node's local orientation will be copied unaltered.</span>
 <span class="s0">*/ 6 4 name 1 366  8 duration 1 339  4 node 1 386  6 target 1 386  3 wrt 1 340  9 hprOffset 5 389  </span>
<span class="s0">67 0 0 6 95 386 0 0 37 /**</span>
 <span class="s0">* Returns the &quot;source&quot; node.</span>
 <span class="s0">*/ 1 4 this 3 383  </span>
<span class="s0">68 0 0 6 96 386 0 0 37 /**</span>
 <span class="s0">* Returns the &quot;target&quot; node.</span>
 <span class="s0">*/ 1 4 this 3 383  </span>
<span class="s0">69 0 0 7 97 375 0 0 0 0 </span>
<span class="s0">70 0 0 15 100 395 243 0 0 1 6 param0 0 393  </span>
<span class="s0">71 0 0 7 100 395 243 0 390 /**</span>
 <span class="s0">* Constructs a constraint interval that will constrain the position and</span>
 <span class="s0">* orientation of one node to the position and orientation of another.</span>
 <span class="s0">*</span>
 <span class="s0">* If wrt is true, the node's position and orientation will be transformed</span>
 <span class="s0">* into the target node's parent's space before being copied.  If wrt is</span>
 <span class="s0">* false, the target node's local position and orientation will be copied</span>
 <span class="s0">* unaltered.</span>
 <span class="s0">*/ 7 4 name 1 366  8 duration 1 339  4 node 1 386  6 target 1 386  3 wrt 1 340  9 posOffset 5 389  9 hprOffset 5 389  </span>
<span class="s0">72 0 0 6 101 386 0 0 37 /**</span>
 <span class="s0">* Returns the &quot;source&quot; node.</span>
 <span class="s0">*/ 1 4 this 3 393  </span>
<span class="s0">73 0 0 6 102 386 0 0 37 /**</span>
 <span class="s0">* Returns the &quot;target&quot; node.</span>
 <span class="s0">*/ 1 4 this 3 393  </span>
<span class="s0">74 0 0 7 103 375 0 0 0 0 </span>
<span class="s0">75 0 0 15 106 398 248 0 0 1 6 param0 0 396  </span>
<span class="s0">76 0 0 7 106 398 248 0 324 /**</span>
 <span class="s0">* Constructs a constraint interval that will constrain the position of one</span>
 <span class="s0">* node to the position of another.</span>
 <span class="s0">*</span>
 <span class="s0">* If wrt is true, the node's position will be transformed into the target</span>
 <span class="s0">* node's parent's  space before being copied.  If wrt is false, the target</span>
 <span class="s0">* node's local position will be copied unaltered.</span>
 <span class="s0">*/ 6 4 name 1 366  8 duration 1 339  4 node 1 386  6 target 1 386  3 wrt 1 340  9 posOffset 5 389  </span>
<span class="s0">77 0 0 6 107 386 0 0 37 /**</span>
 <span class="s0">* Returns the &quot;source&quot; node.</span>
 <span class="s0">*/ 1 4 this 3 396  </span>
<span class="s0">78 0 0 6 108 386 0 0 37 /**</span>
 <span class="s0">* Returns the &quot;target&quot; node.</span>
 <span class="s0">*/ 1 4 this 3 396  </span>
<span class="s0">79 0 0 7 109 375 0 0 0 0 </span>
<span class="s0">80 0 0 15 112 401 253 0 0 1 6 param0 0 399  </span>
<span class="s0">81 0 0 7 112 401 253 0 385 /**</span>
 <span class="s0">* Constructs a constraint interval that will constrain the transform of one</span>
 <span class="s0">* node to the transform of another.  To clarify, the transform of node will</span>
 <span class="s0">* be copied to target.</span>
 <span class="s0">*</span>
 <span class="s0">* If wrt is true, the node's transform will be transformed into the target</span>
 <span class="s0">* node's parent's  space before being copied.  If wrt is false, the node's</span>
 <span class="s0">* local transform will be copied unaltered.</span>
 <span class="s0">*/ 5 4 name 1 366  8 duration 1 339  4 node 1 386  6 target 1 386  3 wrt 1 340  </span>
<span class="s0">82 0 0 6 113 386 0 0 37 /**</span>
 <span class="s0">* Returns the &quot;source&quot; node.</span>
 <span class="s0">*/ 1 4 this 3 399  </span>
<span class="s0">83 0 0 6 114 386 0 0 37 /**</span>
 <span class="s0">* Returns the &quot;target&quot; node.</span>
 <span class="s0">*/ 1 4 this 3 399  </span>
<span class="s0">84 0 0 7 115 375 0 0 0 0 </span>
<span class="s0">85 0 0 15 122 404 258 0 0 1 6 param0 0 402  </span>
<span class="s0">86 0 0 6 119 349 0 0 163 /**</span>
 <span class="s0">* Returns the blend type specified for the interval.  This controls how the</span>
 <span class="s0">* linear interpolation behaves near the beginning and end of the lerp period.</span>
 <span class="s0">*/ 1 4 this 3 402  </span>
<span class="s0">87 0 0 6 120 349 0 0 143 /**</span>
 <span class="s0">* Returns the BlendType enumerated value corresponding to the indicated</span>
 <span class="s0">* string, or BT_invalid if the string doesn't match anything.</span>
 <span class="s0">*/ 1 10 blend_type 1 366  </span>
<span class="s0">88 0 0 7 121 375 0 0 0 0 </span>
<span class="s0">89 0 0 15 125 407 262 0 0 1 6 param0 0 405  </span>
<span class="s0">90 0 0 7 125 407 262 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 name 1 366  8 duration 1 339  10 blend_type 1 349  </span>
<span class="s0">91 0 0 4 126 367 0 0 274 /**</span>
 <span class="s0">* Adds another AnimControl to the list of AnimControls affected by the lerp.</span>
 <span class="s0">* This control will be lerped from begin_effect to end_effect over the period</span>
 <span class="s0">* of the lerp.</span>
 <span class="s0">*</span>
 <span class="s0">* The AnimControl name parameter is only used when formatting the interval</span>
 <span class="s0">* for output.</span>
 <span class="s0">*/ 5 4 this 3 407  7 control 1 408  4 name 1 366  12 begin_effect 1 410  10 end_effect 1 410  </span>
<span class="s0">92 0 0 7 127 375 0 0 0 0 </span>
<span class="s0">93 0 0 15 130 413 290 0 0 1 6 param0 0 411  </span>
<span class="s0">94 0 0 7 130 413 290 0 1229 /**</span>
 <span class="s0">* Constructs a lerp interval that will lerp some properties on the indicated</span>
 <span class="s0">* node, possibly relative to the indicated other node (if other is nonempty).</span>
 <span class="s0">*</span>
 <span class="s0">* You must call set_end_pos(), etc.  for the various properties you wish to</span>
 <span class="s0">* lerp before the first call to priv_initialize().  If you want to set a</span>
 <span class="s0">* starting value for any of the properties, you may call set_start_pos(),</span>
 <span class="s0">* etc.; otherwise, the starting value is taken from the actual node's value</span>
 <span class="s0">* at the time the lerp is performed.</span>
 <span class="s0">*</span>
 <span class="s0">* The starting values may be explicitly specified or omitted.  The value of</span>
 <span class="s0">* bake_in_start determines the behavior if the starting values are omitted.</span>
 <span class="s0">* If bake_in_start is true, the values are obtained the first time the lerp</span>
 <span class="s0">* runs, and thenceforth are stored within the interval.  If bake_in_start is</span>
 <span class="s0">* false, the starting value is computed each frame, based on assuming the</span>
 <span class="s0">* current value represents the value set from the last time the interval was</span>
 <span class="s0">* run.  This &quot;smart&quot; behavior allows code to manipulate the object event</span>
 <span class="s0">* while it is being lerped, and the lerp continues to apply in a sensible</span>
 <span class="s0">* way.</span>
 <span class="s0">*</span>
 <span class="s0">* If fluid is true, the prev_transform is not adjusted by the lerp;</span>
 <span class="s0">* otherwise, it is reset.</span>
 <span class="s0">*/ 7 4 name 1 366  8 duration 1 339  10 blend_type 1 349  13 bake_in_start 1 340  5 fluid 1 340  4 node 1 386  5 other 1 386  </span>
<span class="s0">95 0 0 6 131 386 0 0 41 /**</span>
 <span class="s0">* Returns the node being lerped.</span>
 <span class="s0">*/ 1 4 this 3 411  </span>
<span class="s0">96 0 0 6 132 386 0 0 184 /**</span>
 <span class="s0">* Returns the &quot;other&quot; node, which the lerped node is being moved relative to.</span>
 <span class="s0">* If this is an empty node path, the lerped node is being moved in its own</span>
 <span class="s0">* coordinate system.</span>
 <span class="s0">*/ 1 4 this 3 411  </span>
<span class="s0">97 0 0 4 133 367 0 0 264 /**</span>
 <span class="s0">* Indicates the initial position of the lerped node.  This is meaningful only</span>
 <span class="s0">* if set_end_pos() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual position at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  3 pos 1 389  </span>
<span class="s0">98 0 0 4 134 367 0 0 250 /**</span>
 <span class="s0">* Indicates that the position of the node should be lerped, and specifies the</span>
 <span class="s0">* final position of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's position will not be</span>
 <span class="s0">* affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  3 pos 1 389  </span>
<span class="s0">99 0 0 4 135 367 0 0 289 /**</span>
 <span class="s0">* Indicates the initial rotation of the lerped node.  This is meaningful only</span>
 <span class="s0">* if either set_end_hpr() or set_end_quat() is also called.  This parameter</span>
 <span class="s0">* is optional; if unspecified, the value will be taken from the node's actual</span>
 <span class="s0">* rotation at the time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  3 hpr 1 389  </span>
<span class="s0">100 0 0 4 136 367 0 0 412 /**</span>
 <span class="s0">* Indicates that the rotation of the node should be lerped, and specifies the</span>
 <span class="s0">* final rotation of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().</span>
 <span class="s0">*</span>
 <span class="s0">* This special function is overloaded to accept a quaternion, even though the</span>
 <span class="s0">* function name is set_end_hpr().  The quaternion will be implicitly</span>
 <span class="s0">* converted to a HPR trio, and the lerp will be performed in HPR space,</span>
 <span class="s0">* componentwise.</span>
 <span class="s0">*/ 2 4 this 3 413  4 quat 1 414  </span>
<span class="s0">101 0 0 4 136 367 0 0 340 /**</span>
 <span class="s0">* Indicates that the rotation of the node should be lerped, and specifies the</span>
 <span class="s0">* final rotation of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().</span>
 <span class="s0">*</span>
 <span class="s0">* This replaces a previous call to set_end_quat().  If neither set_end_hpr()</span>
 <span class="s0">* nor set_end_quat() is called, the node's rotation will not be affected by</span>
 <span class="s0">* the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  3 hpr 1 389  </span>
<span class="s0">102 0 0 4 137 367 0 0 340 /**</span>
 <span class="s0">* Indicates the initial rotation of the lerped node.  This is meaningful only</span>
 <span class="s0">* if either set_end_quat() or set_end_hpr() is also called.  This parameter</span>
 <span class="s0">* is optional; if unspecified, the value will be taken from the node's actual</span>
 <span class="s0">* rotation at the time the lerp is performed.</span>
 <span class="s0">*</span>
 <span class="s0">* The given quaternion needs to be normalized.</span>
 <span class="s0">*/ 2 4 this 3 413  4 quat 1 414  </span>
<span class="s0">103 0 0 4 138 367 0 0 390 /**</span>
 <span class="s0">* Indicates that the rotation of the node should be lerped, and specifies the</span>
 <span class="s0">* final rotation of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().</span>
 <span class="s0">*</span>
 <span class="s0">* This replaces a previous call to set_end_hpr().  If neither set_end_quat()</span>
 <span class="s0">* nor set_end_hpr() is called, the node's rotation will not be affected by</span>
 <span class="s0">* the lerp.</span>
 <span class="s0">*</span>
 <span class="s0">* The given quaternion needs to be normalized.</span>
 <span class="s0">*/ 2 4 this 3 413  4 quat 1 414  </span>
<span class="s0">104 0 0 4 138 367 0 0 589 /**</span>
 <span class="s0">* Indicates that the rotation of the node should be lerped, and specifies the</span>
 <span class="s0">* final rotation of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().</span>
 <span class="s0">*</span>
 <span class="s0">* This replaces a previous call to set_end_hpr().  If neither set_end_quat()</span>
 <span class="s0">* nor set_end_hpr() is called, the node's rotation will not be affected by</span>
 <span class="s0">* the lerp.</span>
 <span class="s0">*</span>
 <span class="s0">* This special function is overloaded to accept a HPR trio, even though the</span>
 <span class="s0">* function name is set_end_quat().  The HPR will be implicitly converted to a</span>
 <span class="s0">* quaternion, and the lerp will be performed in quaternion space, as a</span>
 <span class="s0">* spherical lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  3 hpr 1 389  </span>
<span class="s0">105 0 0 4 139 367 0 0 260 /**</span>
 <span class="s0">* Indicates the initial scale of the lerped node.  This is meaningful only if</span>
 <span class="s0">* set_end_scale() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual scale at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  5 scale 1 389  </span>
<span class="s0">106 0 0 4 139 367 0 0 260 /**</span>
 <span class="s0">* Indicates the initial scale of the lerped node.  This is meaningful only if</span>
 <span class="s0">* set_end_scale() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual scale at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  5 scale 1 418  </span>
<span class="s0">107 0 0 4 140 367 0 0 237 /**</span>
 <span class="s0">* Indicates that the scale of the node should be lerped, and specifies the</span>
 <span class="s0">* final scale of the node.  This should be called before priv_initialize().</span>
 <span class="s0">* If this is not called, the node's scale will not be affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  5 scale 1 389  </span>
<span class="s0">108 0 0 4 140 367 0 0 237 /**</span>
 <span class="s0">* Indicates that the scale of the node should be lerped, and specifies the</span>
 <span class="s0">* final scale of the node.  This should be called before priv_initialize().</span>
 <span class="s0">* If this is not called, the node's scale will not be affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  5 scale 1 418  </span>
<span class="s0">109 0 0 4 141 367 0 0 260 /**</span>
 <span class="s0">* Indicates the initial shear of the lerped node.  This is meaningful only if</span>
 <span class="s0">* set_end_shear() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual shear at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  5 shear 1 389  </span>
<span class="s0">110 0 0 4 142 367 0 0 237 /**</span>
 <span class="s0">* Indicates that the shear of the node should be lerped, and specifies the</span>
 <span class="s0">* final shear of the node.  This should be called before priv_initialize().</span>
 <span class="s0">* If this is not called, the node's shear will not be affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  5 shear 1 389  </span>
<span class="s0">111 0 0 4 143 367 0 0 260 /**</span>
 <span class="s0">* Indicates the initial color of the lerped node.  This is meaningful only if</span>
 <span class="s0">* set_end_color() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual color at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  5 color 1 419  </span>
<span class="s0">112 0 0 4 144 367 0 0 237 /**</span>
 <span class="s0">* Indicates that the color of the node should be lerped, and specifies the</span>
 <span class="s0">* final color of the node.  This should be called before priv_initialize().</span>
 <span class="s0">* If this is not called, the node's color will not be affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  5 color 1 419  </span>
<span class="s0">113 0 0 4 145 367 0 0 278 /**</span>
 <span class="s0">* Indicates the initial color scale of the lerped node.  This is meaningful</span>
 <span class="s0">* only if set_end_color_scale() is also called.  This parameter is optional;</span>
 <span class="s0">* if unspecified, the value will be taken from the node's actual color scale</span>
 <span class="s0">* at the time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  11 color_scale 1 419  </span>
<span class="s0">114 0 0 4 146 367 0 0 259 /**</span>
 <span class="s0">* Indicates that the color scale of the node should be lerped, and specifies</span>
 <span class="s0">* the final color scale of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's color scale will not</span>
 <span class="s0">* be affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  11 color_scale 1 419  </span>
<span class="s0">115 0 0 4 147 367 0 0 169 /**</span>
 <span class="s0">* Indicates the texture stage that is adjusted by tex_offset, tex_rotate,</span>
 <span class="s0">* and/or tex_scale.  If this is not set, the default is the default texture</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/ 2 4 this 3 413  5 stage 1 423  </span>
<span class="s0">116 0 0 4 148 367 0 0 273 /**</span>
 <span class="s0">* Indicates the initial UV offset of the lerped node.  This is meaningful</span>
 <span class="s0">* only if set_end_tex_offset() is also called.  This parameter is optional;</span>
 <span class="s0">* if unspecified, the value will be taken from the node's actual UV offset at</span>
 <span class="s0">* the time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  10 tex_offset 1 425  </span>
<span class="s0">117 0 0 4 149 367 0 0 253 /**</span>
 <span class="s0">* Indicates that the UV offset of the node should be lerped, and specifies</span>
 <span class="s0">* the final UV offset of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's UV offset will not be</span>
 <span class="s0">* affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  10 tex_offset 1 425  </span>
<span class="s0">118 0 0 4 150 367 0 0 273 /**</span>
 <span class="s0">* Indicates the initial UV rotate of the lerped node.  This is meaningful</span>
 <span class="s0">* only if set_end_tex_rotate() is also called.  This parameter is optional;</span>
 <span class="s0">* if unspecified, the value will be taken from the node's actual UV rotate at</span>
 <span class="s0">* the time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  10 tex_rotate 1 418  </span>
<span class="s0">119 0 0 4 151 367 0 0 253 /**</span>
 <span class="s0">* Indicates that the UV rotate of the node should be lerped, and specifies</span>
 <span class="s0">* the final UV rotate of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's UV rotate will not be</span>
 <span class="s0">* affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  10 tex_rotate 1 418  </span>
<span class="s0">120 0 0 4 152 367 0 0 270 /**</span>
 <span class="s0">* Indicates the initial UV scale of the lerped node.  This is meaningful only</span>
 <span class="s0">* if set_end_tex_scale() is also called.  This parameter is optional; if</span>
 <span class="s0">* unspecified, the value will be taken from the node's actual UV scale at the</span>
 <span class="s0">* time the lerp is performed.</span>
 <span class="s0">*/ 2 4 this 3 413  9 tex_scale 1 425  </span>
<span class="s0">121 0 0 4 153 367 0 0 250 /**</span>
 <span class="s0">* Indicates that the UV scale of the node should be lerped, and specifies the</span>
 <span class="s0">* final UV scale of the node.  This should be called before</span>
 <span class="s0">* priv_initialize().  If this is not called, the node's UV scale will not be</span>
 <span class="s0">* affected by the lerp.</span>
 <span class="s0">*/ 2 4 this 3 413  9 tex_scale 1 425  </span>
<span class="s0">122 0 0 4 154 367 0 0 326 /**</span>
 <span class="s0">* Changes the override value that will be associated with any state changes</span>
 <span class="s0">* applied by the lerp.  If this lerp is changing state (for instance, a color</span>
 <span class="s0">* lerp or a tex matrix lerp), then the new attributes created by this lerp</span>
 <span class="s0">* will be assigned the indicated override value when they are applied to the</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 2 4 this 3 413  8 override 1 370  </span>
<span class="s0">123 0 0 6 155 370 0 0 129 /**</span>
 <span class="s0">* Returns the override value that will be associated with any state changes</span>
 <span class="s0">* applied by the lerp.  See set_override().</span>
 <span class="s0">*/ 1 4 this 3 411  </span>
<span class="s0">124 0 0 7 156 375 0 0 0 0 </span>
<span class="s0">125 0 0 15 159 431 0 0 0 1 6 param0 0 429  </span>
<span class="s0">126 0 0 7 159 431 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 366  </span>
<span class="s0">127 0 0 4 161 367 0 0 392 /**</span>
 <span class="s0">* Indicates the precision with which time measurements are compared.  For</span>
 <span class="s0">* numerical accuracy, all floating-point time values are converted to integer</span>
 <span class="s0">* values internally by scaling by the precision factor.  The larger the</span>
 <span class="s0">* number given here, the smaller the delta of time that can be</span>
 <span class="s0">* differentiated; the limit is the maximum integer that can be represented in</span>
 <span class="s0">* the system.</span>
 <span class="s0">*/ 2 4 this 3 431  9 precision 1 339  </span>
<span class="s0">128 0 0 6 162 339 0 0 100 /**</span>
 <span class="s0">* Returns the precision with which time measurements are compared.  See</span>
 <span class="s0">* set_precision().</span>
 <span class="s0">*/ 1 4 this 3 429  </span>
<span class="s0">129 0 0 4 163 367 0 0 78 /**</span>
 <span class="s0">* Resets the list of intervals and prepares for receiving a new list.</span>
 <span class="s0">*/ 1 4 this 3 431  </span>
<span class="s0">130 0 0 6 164 370 0 0 343 /**</span>
 <span class="s0">* Marks the beginning of a nested level of child intervals.  Within the</span>
 <span class="s0">* nested level, a RelativeStart time of RS_level_begin refers to the start of</span>
 <span class="s0">* the level, and the first interval added within the level is always relative</span>
 <span class="s0">* to the start of the level.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index of the def entry created by this push.</span>
 <span class="s0">*/ 4 4 this 3 431  4 name 1 366  8 rel_time 1 339  6 rel_to 1 353  </span>
<span class="s0">131 0 0 6 165 370 0 0 235 /**</span>
 <span class="s0">* Adds a new CInterval to the list.  The interval will be played when the</span>
 <span class="s0">* indicated time (relative to the given point) has been reached.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index of the def entry representing the new</span>
 <span class="s0">* interval.</span>
 <span class="s0">*/ 4 4 this 3 431  10 c_interval 1 365  8 rel_time 5 339  6 rel_to 5 353  </span>
<span class="s0">132 0 0 6 166 370 0 0 731 /**</span>
 <span class="s0">* Adds a new external interval to the list.  This represents some object in</span>
 <span class="s0">* the external scripting language that has properties similar to a CInterval</span>
 <span class="s0">* (for instance, a Python Interval object).</span>
 <span class="s0">*</span>
 <span class="s0">* The CMetaInterval object cannot play this external interval directly, but</span>
 <span class="s0">* it records a placeholder for it and will ask the scripting language to play</span>
 <span class="s0">* it when it is time, via is_event_ready() and related methods.</span>
 <span class="s0">*</span>
 <span class="s0">* The ext_index number itself is simply a handle that the scripting language</span>
 <span class="s0">* makes up and associates with its interval object somehow.  The</span>
 <span class="s0">* CMetaInterval object does not attempt to interpret this value.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index of the def entry representing the new</span>
 <span class="s0">* interval.</span>
 <span class="s0">*/ 7 4 this 3 431  9 ext_index 1 370  4 name 1 366  8 duration 1 339  10 open_ended 1 340  8 rel_time 1 339  6 rel_to 1 353  </span>
<span class="s0">133 0 0 6 167 370 0 0 342 /**</span>
 <span class="s0">* Finishes a level marked by a previous call to push_level(), and returns to</span>
 <span class="s0">* the previous level.</span>
 <span class="s0">*</span>
 <span class="s0">* If the duration is not negative, it represents a phony duration to assign</span>
 <span class="s0">* to the level, for the purposes of sequencing later intervals.  Otherwise,</span>
 <span class="s0">* the level's duration is computed based on the intervals within the level.</span>
 <span class="s0">*/ 2 4 this 3 431  8 duration 5 339  </span>
<span class="s0">134 0 0 6 168 340 0 0 458 /**</span>
 <span class="s0">* Adjusts the start time of the child interval with the given name, if found.</span>
 <span class="s0">* This may be either a C++ interval added via add_c_interval(), or an</span>
 <span class="s0">* external interval added via add_ext_index(); the name must match exactly.</span>
 <span class="s0">*</span>
 <span class="s0">* If the interval is found, its start time is adjusted, and all subsequent</span>
 <span class="s0">* intervals are adjusting accordingly, and true is returned.  If a matching</span>
 <span class="s0">* interval is not found, nothing is changed and false is returned.</span>
 <span class="s0">*/ 4 4 this 3 431  4 name 1 366  8 rel_time 1 339  6 rel_to 5 353  </span>
<span class="s0">135 0 0 6 169 339 0 0 179 /**</span>
 <span class="s0">* Returns the actual start time, relative to the beginning of the interval,</span>
 <span class="s0">* of the child interval with the given name, if found, or -1 if the interval</span>
 <span class="s0">* is not found.</span>
 <span class="s0">*/ 2 4 this 3 429  4 name 1 366  </span>
<span class="s0">136 0 0 6 170 339 0 0 177 /**</span>
 <span class="s0">* Returns the actual end time, relative to the beginning of the interval, of</span>
 <span class="s0">* the child interval with the given name, if found, or -1 if the interval is</span>
 <span class="s0">* not found.</span>
 <span class="s0">*/ 2 4 this 3 429  4 name 1 366  </span>
<span class="s0">137 0 0 6 172 370 0 0 112 /**</span>
 <span class="s0">* Returns the number of interval and push/pop definitions that have been</span>
 <span class="s0">* added to the meta interval.</span>
 <span class="s0">*/ 1 4 this 3 429  </span>
<span class="s0">138 0 0 6 173 354 0 0 79 /**</span>
 <span class="s0">* Returns the type of the nth interval definition that has been added.</span>
 <span class="s0">*/ 2 4 this 3 429  1 n 1 370  </span>
<span class="s0">139 0 0 7 174 365 0 0 159 /**</span>
 <span class="s0">* Return the CInterval pointer associated with the nth interval definition.</span>
 <span class="s0">* It is only valid to call this if get_def_type(n) returns DT_c_interval.</span>
 <span class="s0">*/ 2 4 this 3 429  1 n 1 370  </span>
<span class="s0">140 0 0 6 175 370 0 0 175 /**</span>
 <span class="s0">* Return the external interval index number associated with the nth interval</span>
 <span class="s0">* definition.  It is only valid to call this if get_def_type(n) returns</span>
 <span class="s0">* DT_ext_index.</span>
 <span class="s0">*/ 2 4 this 3 429  1 n 1 370  </span>
<span class="s0">141 0 0 6 176 340 0 0 267 /**</span>
 <span class="s0">* Returns true if a recent call to priv_initialize(), priv_step(), or</span>
 <span class="s0">* priv_finalize() has left some external intervals ready to play.  If this</span>
 <span class="s0">* returns true, call get_event_index(), get_event_t(), and pop_event() to</span>
 <span class="s0">* retrieve the relevant information.</span>
 <span class="s0">*/ 1 4 this 3 431  </span>
<span class="s0">142 0 0 6 177 370 0 0 180 /**</span>
 <span class="s0">* If a previous call to is_event_ready() returned true, this returns the</span>
 <span class="s0">* index number (added via add_event_index()) of the external interval that</span>
 <span class="s0">* needs to be played.</span>
 <span class="s0">*/ 1 4 this 3 429  </span>
<span class="s0">143 0 0 6 178 339 0 0 134 /**</span>
 <span class="s0">* If a previous call to is_event_ready() returned true, this returns the t</span>
 <span class="s0">* value that should be fed to the given interval.</span>
 <span class="s0">*/ 1 4 this 3 429  </span>
<span class="s0">144 0 0 6 179 334 0 0 161 /**</span>
 <span class="s0">* If a previous call to is_event_ready() returned true, this returns the type</span>
 <span class="s0">* of the event (initialize, step, finalize, etc.) for the given interval.</span>
 <span class="s0">*/ 1 4 this 3 429  </span>
<span class="s0">145 0 0 4 180 367 0 0 302 /**</span>
 <span class="s0">* Acknowledges that the external interval on the top of the queue has been</span>
 <span class="s0">* extracted, and is about to be serviced by the scripting language.  This</span>
 <span class="s0">* prepares the interval so the next call to is_event_ready() will return</span>
 <span class="s0">* information about the next external interval on the queue, if any.</span>
 <span class="s0">*/ 1 4 this 3 431  </span>
<span class="s0">146 0 0 4 181 367 0 0 73 /**</span>
 <span class="s0">* Outputs a list of all events in the order in which they occur.</span>
 <span class="s0">*/ 2 4 this 3 429  3 out 1 368  </span>
<span class="s0">147 0 0 7 182 375 0 0 0 0 </span>
<span class="s0">148 0 0 15 184 434 315 0 0 1 6 param0 0 432  </span>
<span class="s0">149 0 0 7 184 434 315 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 node 1 386  4 name 5 366  </span>
<span class="s0">150 0 0 7 185 375 0 0 0 0 </span>
<span class="s0">151 0 0 6 188 418 0 0 0 2 4 this 3 435  6 param0 0 418  </span>
<span class="s0">152 0 0 7 189 375 0 0 27 // now for typehandle stuff 0 </span>
<span class="s0">153 0 0 7 191 436 0 0 0 0 </span>
<span class="s0">154 0 0 7 192 375 0 0 27 // now for typehandle stuff 0 </span>
<span class="s0">155 0 0 7 194 437 0 0 0 0 </span>
<span class="s0">156 0 0 7 195 375 0 0 27 // now for typehandle stuff 0 </span>
<span class="s0">157 0 0 7 197 438 0 0 0 0 </span>
<span class="s0">158 0 0 7 198 375 0 0 27 // now for typehandle stuff 0 </span>
<span class="s0">159 0 0 7 200 439 0 0 0 0 </span>
<span class="s0">160 0 0 7 201 375 0 0 27 // now for typehandle stuff 0 </span>
<span class="s0">161 0 0 7 203 440 328 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 node 1 386  4 name 5 366  </span>
<span class="s0">162 0 0 15 203 440 328 0 0 1 6 param0 0 441  </span>
<span class="s0">163 0 0 7 204 375 0 0 0 0 </span>
<span class="s0">164 0 0 15 207 445 331 0 0 1 6 param0 0 443  </span>
<span class="s0">165 0 0 7 207 445 331 0 111 /**</span>
 <span class="s0">* All Wait intervals have the same name.  No one really cares if their names</span>
 <span class="s0">* are unique, after all.</span>
 <span class="s0">*/ 1 8 duration 1 339  </span>
<span class="s0">166 0 0 7 208 375 0 0 0 0 </span>
<span class="s0">114</span>
<span class="s0">332 9 CInterval 0 75777 9 CInterval 9 CInterval 0 0 0 1 228 0 12 446 447 448 449 450 451 452 453 454 455 456 457 44 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 227 0 0 1 0 333 0 0 0 2 334 335 491</span>
<span class="s0">/**</span>
 <span class="s0">* The base class for timeline components.  A CInterval represents a single</span>
 <span class="s0">* action, event, or collection of nested intervals that will be performed at</span>
 <span class="s0">* some specific time or over a period of time.</span>
 <span class="s0">*</span>
 <span class="s0">* This is essentially similar to the Python &quot;Interval&quot; class, but it is</span>
 <span class="s0">* implemented in C++ (hence the name). Intervals that may be implemented in</span>
 <span class="s0">* C++ will inherit from this class; Intervals that must be implemented in</span>
 <span class="s0">* Python will inherit from the similar Python class.</span>
 <span class="s0">*/</span>

<span class="s0">333 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">334 9 EventType 0 794624 20 CInterval::EventType 20 CInterval::EventType 332 0 0 0 0 0 0 0 0 0 8 13 ET_initialize 24 CInterval::ET_initialize 0</span>
<span class="s0">0 10 ET_instant 21 CInterval::ET_instant 0</span>
<span class="s0">1 7 ET_step 18 CInterval::ET_step 0</span>
<span class="s0">2 11 ET_finalize 22 CInterval::ET_finalize 0</span>
<span class="s0">3 21 ET_reverse_initialize 32 CInterval::ET_reverse_initialize 0</span>
<span class="s0">4 18 ET_reverse_instant 29 CInterval::ET_reverse_instant 0</span>
<span class="s0">5 19 ET_reverse_finalize 30 CInterval::ET_reverse_finalize 0</span>
<span class="s0">6 12 ET_interrupt 23 CInterval::ET_interrupt 0</span>
<span class="s0">7 0 0</span>

<span class="s0">335 5 State 0 794624 16 CInterval::State 16 CInterval::State 332 0 0 0 0 0 0 0 0 0 4 9 S_initial 20 CInterval::S_initial 0</span>
<span class="s0">0 9 S_started 20 CInterval::S_started 0</span>
<span class="s0">1 8 S_paused 19 CInterval::S_paused 0</span>
<span class="s0">2 7 S_final 18 CInterval::S_final 0</span>
<span class="s0">3 0 0</span>

<span class="s0">336 12 string const 0 8832 17 std::string const 17 std::string const 0 0 337 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">337 6 string 0 2105344 11 std::string 11 std::string 0 0 338 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">338 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">339 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">340 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">341 18 CIntervalManager * 0 8576 18 CIntervalManager * 18 CIntervalManager * 0 0 342 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">342 16 CIntervalManager 0 26625 16 CIntervalManager 16 CIntervalManager 0 0 0 1 210 211 0 15 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 0 0 0 0 0 465</span>
<span class="s0">/**</span>
 <span class="s0">* This object holds a number of currently-playing intervals and is</span>
 <span class="s0">* responsible for advancing them each frame as needed.</span>
 <span class="s0">*</span>
 <span class="s0">* There is normally only one IntervalManager object in the world, and it is</span>
 <span class="s0">* the responsibility of the scripting language to call step() on this object</span>
 <span class="s0">* once each frame, and to then process the events indicated by</span>
 <span class="s0">* get_next_event().</span>
 <span class="s0">*</span>
 <span class="s0">* It is also possible to create multiple IntervalManager objects for special</span>
 <span class="s0">* needs.</span>
 <span class="s0">*/</span>

<span class="s0">343 19 CConstraintInterval 0 141313 19 CConstraintInterval 19 CConstraintInterval 0 0 0 1 232 233 1 458 1 231 0 0 1 0 332 0 0 0 0 105</span>
<span class="s0">/**</span>
 <span class="s0">* The base class for a family of intervals that constrain some property to a</span>
 <span class="s0">* value over time.</span>
 <span class="s0">*/</span>

<span class="s0">344 21 CConstrainHprInterval 0 141313 21 CConstrainHprInterval 21 CConstrainHprInterval 0 0 0 1 234 238 0 3 235 236 237 0 0 1 0 343 0 0 0 0 114</span>
<span class="s0">/**</span>
 <span class="s0">* A constraint interval that will constrain the orientation of one node to</span>
 <span class="s0">* the orientation of another.</span>
 <span class="s0">*/</span>

<span class="s0">345 24 CConstrainPosHprInterval 0 141313 24 CConstrainPosHprInterval 24 CConstrainPosHprInterval 0 0 0 1 239 243 0 3 240 241 242 0 0 1 0 343 0 0 0 0 140</span>
<span class="s0">/**</span>
 <span class="s0">* A constraint interval that will constrain the position and orientation of</span>
 <span class="s0">* one node to the position and orientation of another.</span>
 <span class="s0">*/</span>

<span class="s0">346 21 CConstrainPosInterval 0 141313 21 CConstrainPosInterval 21 CConstrainPosInterval 0 0 0 1 244 248 0 3 245 246 247 0 0 1 0 343 0 0 0 0 108</span>
<span class="s0">/**</span>
 <span class="s0">* A constraint interval that will constrain the position of one node to the</span>
 <span class="s0">* position of another.</span>
 <span class="s0">*/</span>

<span class="s0">347 27 CConstrainTransformInterval 0 141313 27 CConstrainTransformInterval 27 CConstrainTransformInterval 0 0 0 1 249 253 0 3 250 251 252 0 0 1 0 343 0 0 0 0 110</span>
<span class="s0">/**</span>
 <span class="s0">* A constraint interval that will constrain the transform of one node to the</span>
 <span class="s0">* transform of another.</span>
 <span class="s0">*/</span>

<span class="s0">348 13 CLerpInterval 0 141313 13 CLerpInterval 13 CLerpInterval 0 0 0 1 257 258 0 3 254 255 256 0 0 1 0 332 0 0 0 1 349 118</span>
<span class="s0">/**</span>
 <span class="s0">* The base class for a family of intervals that linearly interpolate one or</span>
 <span class="s0">* more numeric values over time.</span>
 <span class="s0">*/</span>

<span class="s0">349 9 BlendType 0 794624 24 CLerpInterval::BlendType 24 CLerpInterval::BlendType 348 0 0 0 0 0 0 0 0 0 5 11 BT_no_blend 26 CLerpInterval::BT_no_blend 0</span>
<span class="s0">0 10 BT_ease_in 25 CLerpInterval::BT_ease_in 0</span>
<span class="s0">1 11 BT_ease_out 26 CLerpInterval::BT_ease_out 0</span>
<span class="s0">2 14 BT_ease_in_out 29 CLerpInterval::BT_ease_in_out 0</span>
<span class="s0">3 10 BT_invalid 25 CLerpInterval::BT_invalid 0</span>
<span class="s0">4 0 0</span>

<span class="s0">350 23 CLerpAnimEffectInterval 0 141313 23 CLerpAnimEffectInterval 23 CLerpAnimEffectInterval 0 0 0 1 259 262 0 2 260 261 0 0 1 0 348 0 0 0 0 377</span>
<span class="s0">/**</span>
 <span class="s0">* This interval lerps between different amounts of control effects for</span>
 <span class="s0">* various AnimControls that might be playing on an actor.  It's used to</span>
 <span class="s0">* change the blending amount between multiple animations.</span>
 <span class="s0">*</span>
 <span class="s0">* The idea is to start all the animations playing first, then use a</span>
 <span class="s0">* CLerpAnimEffectInterval to adjust the degree to which each animation</span>
 <span class="s0">* affects the actor.</span>
 <span class="s0">*/</span>

<span class="s0">351 21 CLerpNodePathInterval 0 141313 21 CLerpNodePathInterval 21 CLerpNodePathInterval 0 0 0 1 263 290 0 26 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 0 0 1 0 348 0 0 0 0 106</span>
<span class="s0">/**</span>
 <span class="s0">* An interval that lerps one or more properties (like pos, hpr, etc.) on a</span>
 <span class="s0">* NodePath over time.</span>
 <span class="s0">*/</span>

<span class="s0">352 13 CMetaInterval 0 75777 13 CMetaInterval 13 CMetaInterval 0 0 0 1 291 0 0 21 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 0 0 1 0 332 0 0 0 2 353 354 166</span>
<span class="s0">/**</span>
 <span class="s0">* This interval contains a list of nested intervals, each of which has its</span>
 <span class="s0">* own begin and end times.  Some of them may overlap and some of them may</span>
 <span class="s0">* not.</span>
 <span class="s0">*/</span>

<span class="s0">353 13 RelativeStart 0 794624 28 CMetaInterval::RelativeStart 28 CMetaInterval::RelativeStart 352 0 0 0 0 0 0 0 0 0 3 15 RS_previous_end 30 CMetaInterval::RS_previous_end 0</span>
<span class="s0">0 17 RS_previous_begin 32 CMetaInterval::RS_previous_begin 0</span>
<span class="s0">1 14 RS_level_begin 29 CMetaInterval::RS_level_begin 0</span>
<span class="s0">2 0 0</span>

<span class="s0">354 7 DefType 0 794624 22 CMetaInterval::DefType 22 CMetaInterval::DefType 352 0 0 0 0 0 0 0 0 0 4 13 DT_c_interval 28 CMetaInterval::DT_c_interval 0</span>
<span class="s0">0 12 DT_ext_index 27 CMetaInterval::DT_ext_index 0</span>
<span class="s0">1 13 DT_push_level 28 CMetaInterval::DT_push_level 0</span>
<span class="s0">2 12 DT_pop_level 27 CMetaInterval::DT_pop_level 0</span>
<span class="s0">3 0 0</span>

<span class="s0">355 12 HideInterval 0 141313 12 HideInterval 12 HideInterval 0 0 0 1 313 315 0 1 314 0 0 1 0 332 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* An interval that calls NodePath::hide().</span>
 <span class="s0">*/</span>

<span class="s0">356 13 LerpBlendType 0 75777 13 LerpBlendType 13 LerpBlendType 0 0 0 0 0 0 2 316 317 0 0 1 0 333 0 0 0 0 0</span>

<span class="s0">357 15 EaseInBlendType 0 75777 15 EaseInBlendType 15 EaseInBlendType 0 0 0 1 318 0 0 1 319 0 0 1 0 356 0 0 0 0 0</span>

<span class="s0">358 16 EaseOutBlendType 0 75777 16 EaseOutBlendType 16 EaseOutBlendType 0 0 0 1 320 0 0 1 321 0 0 1 0 356 0 0 0 0 0</span>

<span class="s0">359 18 EaseInOutBlendType 0 75777 18 EaseInOutBlendType 18 EaseInOutBlendType 0 0 0 1 322 0 0 1 323 0 0 1 0 356 0 0 0 0 0</span>

<span class="s0">360 11 NoBlendType 0 75777 11 NoBlendType 11 NoBlendType 0 0 0 1 324 0 0 1 325 0 0 1 0 356 0 0 0 0 0</span>

<span class="s0">361 12 ShowInterval 0 141313 12 ShowInterval 12 ShowInterval 0 0 0 1 326 328 0 1 327 0 0 1 0 332 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* An interval that calls NodePath::show().</span>
 <span class="s0">*/</span>

<span class="s0">362 12 WaitInterval 0 141313 12 WaitInterval 12 WaitInterval 0 0 0 1 329 331 0 1 330 0 0 1 0 332 0 0 0 0 133</span>
<span class="s0">/**</span>
 <span class="s0">* This interval does absolutely nothing, and is mainly useful for marking</span>
 <span class="s0">* time between other intervals within a sequence.</span>
 <span class="s0">*/</span>

<span class="s0">363 17 CInterval const * 0 8576 17 CInterval const * 17 CInterval const * 0 0 364 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">364 15 CInterval const 0 8832 15 CInterval const 15 CInterval const 0 0 332 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">365 11 CInterval * 0 8576 11 CInterval * 11 CInterval * 0 0 332 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">366 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">367 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">368 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 369 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">369 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">370 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">371 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 372 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">372 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 373 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">373 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">374 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">375 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 374 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">376 12 EventQueue * 0 8576 12 EventQueue * 12 EventQueue * 0 0 377 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">377 10 EventQueue 0 2048 10 EventQueue 10 EventQueue 0 0 0 0 0 0 0 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A queue of pending events.  As events are thrown, they are added to this</span>
 <span class="s0">* queue; eventually, they will be extracted out again by an EventHandler and</span>
 <span class="s0">* processed.</span>
 <span class="s0">*/</span>

<span class="s0">378 24 CIntervalManager const * 0 8576 24 CIntervalManager const * 24 CIntervalManager const * 0 0 379 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">379 22 CIntervalManager const 0 8832 22 CIntervalManager const 22 CIntervalManager const 0 0 342 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">380 27 CConstraintInterval const * 0 8576 27 CConstraintInterval const * 27 CConstraintInterval const * 0 0 381 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">381 25 CConstraintInterval const 0 8832 25 CConstraintInterval const 25 CConstraintInterval const 0 0 343 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">382 21 CConstraintInterval * 0 8576 21 CConstraintInterval * 21 CConstraintInterval * 0 0 343 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">383 29 CConstrainHprInterval const * 0 8576 29 CConstrainHprInterval const * 29 CConstrainHprInterval const * 0 0 384 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">384 27 CConstrainHprInterval const 0 8832 27 CConstrainHprInterval const 27 CConstrainHprInterval const 0 0 344 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">385 23 CConstrainHprInterval * 0 8576 23 CConstrainHprInterval * 23 CConstrainHprInterval * 0 0 344 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">386 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 387 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">387 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 388 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">388 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">389 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 390 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">390 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 391 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">391 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 392 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">392 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">393 32 CConstrainPosHprInterval const * 0 8576 32 CConstrainPosHprInterval const * 32 CConstrainPosHprInterval const * 0 0 394 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">394 30 CConstrainPosHprInterval const 0 8832 30 CConstrainPosHprInterval const 30 CConstrainPosHprInterval const 0 0 345 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">395 26 CConstrainPosHprInterval * 0 8576 26 CConstrainPosHprInterval * 26 CConstrainPosHprInterval * 0 0 345 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">396 29 CConstrainPosInterval const * 0 8576 29 CConstrainPosInterval const * 29 CConstrainPosInterval const * 0 0 397 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">397 27 CConstrainPosInterval const 0 8832 27 CConstrainPosInterval const 27 CConstrainPosInterval const 0 0 346 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">398 23 CConstrainPosInterval * 0 8576 23 CConstrainPosInterval * 23 CConstrainPosInterval * 0 0 346 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">399 35 CConstrainTransformInterval const * 0 8576 35 CConstrainTransformInterval const * 35 CConstrainTransformInterval const * 0 0 400 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">400 33 CConstrainTransformInterval const 0 8832 33 CConstrainTransformInterval const 33 CConstrainTransformInterval const 0 0 347 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">401 29 CConstrainTransformInterval * 0 8576 29 CConstrainTransformInterval * 29 CConstrainTransformInterval * 0 0 347 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">402 21 CLerpInterval const * 0 8576 21 CLerpInterval const * 21 CLerpInterval const * 0 0 403 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">403 19 CLerpInterval const 0 8832 19 CLerpInterval const 19 CLerpInterval const 0 0 348 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">404 15 CLerpInterval * 0 8576 15 CLerpInterval * 15 CLerpInterval * 0 0 348 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">405 31 CLerpAnimEffectInterval const * 0 8576 31 CLerpAnimEffectInterval const * 31 CLerpAnimEffectInterval const * 0 0 406 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">406 29 CLerpAnimEffectInterval const 0 8832 29 CLerpAnimEffectInterval const 29 CLerpAnimEffectInterval const 0 0 350 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">407 25 CLerpAnimEffectInterval * 0 8576 25 CLerpAnimEffectInterval * 25 CLerpAnimEffectInterval * 0 0 350 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">408 13 AnimControl * 0 8576 13 AnimControl * 13 AnimControl * 0 0 409 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">409 11 AnimControl 0 2048 11 AnimControl 11 AnimControl 0 0 0 0 0 0 0 0 0 0 0 0 255</span>
<span class="s0">/**</span>
 <span class="s0">* Controls the timing of a character animation.  An AnimControl object is</span>
 <span class="s0">* created for each character/bundle binding and manages the state of the</span>
 <span class="s0">* animation: whether started, stopped, or looping, and the current frame</span>
 <span class="s0">* number and play rate.</span>
 <span class="s0">*/</span>

<span class="s0">410 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">411 29 CLerpNodePathInterval const * 0 8576 29 CLerpNodePathInterval const * 29 CLerpNodePathInterval const * 0 0 412 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">412 27 CLerpNodePathInterval const 0 8832 27 CLerpNodePathInterval const 27 CLerpNodePathInterval const 0 0 351 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">413 23 CLerpNodePathInterval * 0 8576 23 CLerpNodePathInterval * 23 CLerpNodePathInterval * 0 0 351 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">414 19 LQuaternion const * 0 8576 19 LQuaternion const * 19 LQuaternion const * 0 0 415 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">415 17 LQuaternion const 0 8832 17 LQuaternion const 17 LQuaternion const 0 0 416 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">416 11 LQuaternion 0 2105344 11 LQuaternion 11 LQuaternion 0 0 417 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">417 12 LQuaternionf 0 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 0 44</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base quaternion class</span>
 <span class="s0">*/</span>

<span class="s0">418 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 410 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">419 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 420 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">420 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 421 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">421 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 422 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">422 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">423 14 TextureStage * 0 8576 14 TextureStage * 14 TextureStage * 0 0 424 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">424 12 TextureStage 0 2048 12 TextureStage 12 TextureStage 0 0 0 0 0 0 0 0 0 0 0 0 336</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the properties of a named stage of the multitexture pipeline.  The</span>
 <span class="s0">* TextureAttrib will associated a number of these stages with Texture</span>
 <span class="s0">* objects, and the GSG will render geometry by sorting all of the currently</span>
 <span class="s0">* active TextureStages in order and then issuing the appropriate rendering</span>
 <span class="s0">* calls to activate them.</span>
 <span class="s0">*/</span>

<span class="s0">425 17 LVecBase2 const * 0 8576 17 LVecBase2 const * 17 LVecBase2 const * 0 0 426 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">426 15 LVecBase2 const 0 8832 15 LVecBase2 const 15 LVecBase2 const 0 0 427 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">427 9 LVecBase2 0 2105344 9 LVecBase2 9 LVecBase2 0 0 428 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">428 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">429 21 CMetaInterval const * 0 8576 21 CMetaInterval const * 21 CMetaInterval const * 0 0 430 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">430 19 CMetaInterval const 0 8832 19 CMetaInterval const 19 CMetaInterval const 0 0 352 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">431 15 CMetaInterval * 0 8576 15 CMetaInterval * 15 CMetaInterval * 0 0 352 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">432 20 HideInterval const * 0 8576 20 HideInterval const * 20 HideInterval const * 0 0 433 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">433 18 HideInterval const 0 8832 18 HideInterval const 18 HideInterval const 0 0 355 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">434 14 HideInterval * 0 8576 14 HideInterval * 14 HideInterval * 0 0 355 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">435 15 LerpBlendType * 0 8576 15 LerpBlendType * 15 LerpBlendType * 0 0 356 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">436 17 EaseInBlendType * 0 8576 17 EaseInBlendType * 17 EaseInBlendType * 0 0 357 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">437 18 EaseOutBlendType * 0 8576 18 EaseOutBlendType * 18 EaseOutBlendType * 0 0 358 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">438 20 EaseInOutBlendType * 0 8576 20 EaseInOutBlendType * 20 EaseInOutBlendType * 0 0 359 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">439 13 NoBlendType * 0 8576 13 NoBlendType * 13 NoBlendType * 0 0 360 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">440 14 ShowInterval * 0 8576 14 ShowInterval * 14 ShowInterval * 0 0 361 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">441 20 ShowInterval const * 0 8576 20 ShowInterval const * 20 ShowInterval const * 0 0 442 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">442 18 ShowInterval const 0 8832 18 ShowInterval const 18 ShowInterval const 0 0 361 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">443 20 WaitInterval const * 0 8576 20 WaitInterval const * 20 WaitInterval const * 0 0 444 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">444 18 WaitInterval const 0 8832 18 WaitInterval const 18 WaitInterval const 0 0 362 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">445 14 WaitInterval * 0 8576 14 WaitInterval * 14 WaitInterval * 0 0 362 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">13</span>
<span class="s0">446 4 name 0 2 336 167 0 0 0 0 0 0 0 15 CInterval::name 0</span>

<span class="s0">447 8 duration 0 2 339 168 0 0 0 0 0 0 0 19 CInterval::duration 0</span>

<span class="s0">448 10 open_ended 0 2 340 169 0 0 0 0 0 0 0 21 CInterval::open_ended 0</span>

<span class="s0">449 5 state 0 2 335 170 0 0 0 0 0 0 0 16 CInterval::state 0</span>

<span class="s0">450 7 stopped 0 2 340 171 0 0 0 0 0 0 0 18 CInterval::stopped 0</span>

<span class="s0">451 10 done_event 0 6 336 173 172 0 0 0 0 0 0 21 CInterval::done_event 0</span>

<span class="s0">452 1 t 0 6 339 175 174 0 0 0 0 0 0 12 CInterval::t 0</span>

<span class="s0">453 10 auto_pause 0 6 340 177 176 0 0 0 0 0 0 21 CInterval::auto_pause 0</span>

<span class="s0">454 11 auto_finish 0 6 340 179 178 0 0 0 0 0 0 22 CInterval::auto_finish 0</span>

<span class="s0">455 7 manager 0 6 341 183 182 0 0 0 0 0 0 18 CInterval::manager 0</span>

<span class="s0">456 9 play_rate 0 6 339 192 193 0 0 0 0 0 0 20 CInterval::play_rate 0</span>

<span class="s0">457 7 playing 0 2 340 191 0 0 0 0 0 0 0 18 CInterval::playing 0</span>

<span class="s0">458 14 bogus_variable 0 6 340 229 230 0 0 0 0 0 0 35 CConstraintInterval::bogus_variable 0</span>

<span class="s0">0</span>
</pre>
</body>
</html>