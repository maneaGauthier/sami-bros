<html>
<head>
<title>libp3pnmimage.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3pnmimage.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">13 libp3pnmimage 4 BCNh 12 panda3d.core </span>
<span class="s0">305</span>
<span class="s0">371 5 pixel 0 260 676 12 pixel::pixel 0 4 1 2 3 4 0</span>
<span class="s0">138</span>
<span class="s0">pixel::pixel(void) = default;</span>
<span class="s0">pixel::pixel(gray fill);</span>
<span class="s0">pixel::pixel(gray r, gray g, gray b);</span>
<span class="s0">inline pixel::pixel(pixel const &amp;) = default;</span>

<span class="s0">372 11 operator [] 0 4 676 18 pixel::operator [] 0 2 5 6 0</span>
<span class="s0">70</span>
<span class="s0">gray pixel::operator [](int i) const;</span>
<span class="s0">gray &amp;pixel::operator [](int i);</span>

<span class="s0">373 10 operator + 0 4 676 17 pixel::operator + 0 1 7 0</span>
<span class="s0">50</span>
<span class="s0">pixel pixel::operator +(pixel const &amp;other) const;</span>

<span class="s0">374 10 operator - 0 4 676 17 pixel::operator - 0 1 8 0</span>
<span class="s0">50</span>
<span class="s0">pixel pixel::operator -(pixel const &amp;other) const;</span>

<span class="s0">375 10 operator * 0 4 676 17 pixel::operator * 0 1 9 0</span>
<span class="s0">49</span>
<span class="s0">pixel pixel::operator *(double const mult) const;</span>

<span class="s0">376 11 operator += 0 4 676 18 pixel::operator += 0 1 10 0</span>
<span class="s0">44</span>
<span class="s0">void pixel::operator +=(pixel const &amp;other);</span>

<span class="s0">377 11 operator -= 0 4 676 18 pixel::operator -= 0 1 11 0</span>
<span class="s0">44</span>
<span class="s0">void pixel::operator -=(pixel const &amp;other);</span>

<span class="s0">378 11 operator *= 0 4 676 18 pixel::operator *= 0 1 12 0</span>
<span class="s0">43</span>
<span class="s0">void pixel::operator *=(double const mult);</span>

<span class="s0">379 11 operator == 0 4 676 18 pixel::operator == 0 1 13 0</span>
<span class="s0">44</span>
<span class="s0">bool pixel::operator ==(pixel const &amp;other);</span>

<span class="s0">380 11 operator != 0 4 676 18 pixel::operator != 0 1 14 0</span>
<span class="s0">44</span>
<span class="s0">bool pixel::operator !=(pixel const &amp;other);</span>

<span class="s0">381 10 operator &lt; 0 4 676 17 pixel::operator &lt; 0 1 15 0</span>
<span class="s0">49</span>
<span class="s0">bool pixel::operator &lt;(pixel const &amp;other) const;</span>

<span class="s0">382 4 size 0 4 676 11 pixel::size 0 1 16 0</span>
<span class="s0">29</span>
<span class="s0">static int pixel::size(void);</span>

<span class="s0">383 6 output 0 4 676 13 pixel::output 0 1 17 0</span>
<span class="s0">38</span>
<span class="s0">void pixel::output(std::ostream &amp;out);</span>

<span class="s0">384 5 get_b 0 20 676 12 pixel::get_b 0 0 25</span>
<span class="s0">getter for gray pixel::b;</span>
<span class="s0">30</span>
<span class="s0">gray pixel::get_b(void) const;</span>

<span class="s0">385 5 set_b 0 36 676 12 pixel::set_b 0 0 25</span>
<span class="s0">setter for gray pixel::b;</span>
<span class="s0">30</span>
<span class="s0">void pixel::set_b(gray value);</span>

<span class="s0">386 5 get_g 0 20 676 12 pixel::get_g 0 0 25</span>
<span class="s0">getter for gray pixel::g;</span>
<span class="s0">30</span>
<span class="s0">gray pixel::get_g(void) const;</span>

<span class="s0">387 5 set_g 0 36 676 12 pixel::set_g 0 0 25</span>
<span class="s0">setter for gray pixel::g;</span>
<span class="s0">30</span>
<span class="s0">void pixel::set_g(gray value);</span>

<span class="s0">388 5 get_r 0 20 676 12 pixel::get_r 0 0 25</span>
<span class="s0">getter for gray pixel::r;</span>
<span class="s0">30</span>
<span class="s0">gray pixel::get_r(void) const;</span>

<span class="s0">389 5 set_r 0 36 676 12 pixel::set_r 0 0 25</span>
<span class="s0">setter for gray pixel::r;</span>
<span class="s0">30</span>
<span class="s0">void pixel::set_r(gray value);</span>

<span class="s0">390 6 ~pixel 0 516 676 13 pixel::~pixel 0 0 0</span>
<span class="s0">20</span>
<span class="s0">pixel::~pixel(void);</span>

<span class="s0">391 17 decode_sRGB_float 0 1 0 17 decode_sRGB_float 0 2 363 364 0</span>
<span class="s0">93</span>
<span class="s0">inline float decode_sRGB_float(unsigned char val);</span>
<span class="s0">inline float decode_sRGB_float(float val);</span>

<span class="s0">392 17 decode_sRGB_uchar 0 1 0 17 decode_sRGB_uchar 0 2 365 366 0</span>
<span class="s0">109</span>
<span class="s0">inline unsigned char decode_sRGB_uchar(unsigned char val);</span>
<span class="s0">inline unsigned char decode_sRGB_uchar(float val);</span>

<span class="s0">393 17 encode_sRGB_float 0 1 0 17 encode_sRGB_float 0 2 367 368 0</span>
<span class="s0">93</span>
<span class="s0">inline float encode_sRGB_float(unsigned char val);</span>
<span class="s0">inline float encode_sRGB_float(float val);</span>

<span class="s0">394 17 encode_sRGB_uchar 0 1 0 17 encode_sRGB_uchar 0 2 369 370 0</span>
<span class="s0">109</span>
<span class="s0">inline unsigned char encode_sRGB_uchar(unsigned char val);</span>
<span class="s0">inline unsigned char encode_sRGB_uchar(float val);</span>

<span class="s0">395 8 get_name 0 6 680 21 PNMFileType::get_name 0 1 18 0</span>
<span class="s0">58</span>
<span class="s0">virtual std::string PNMFileType::get_name(void) const = 0;</span>

<span class="s0">396 18 get_num_extensions 0 6 680 31 PNMFileType::get_num_extensions 0 1 19 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of different possible filename extensions associated</span>
 <span class="s0">* with this particular file type.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual int PNMFileType::get_num_extensions(void) const;</span>

<span class="s0">397 13 get_extension 0 6 680 26 PNMFileType::get_extension 0 1 20 123</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth possible filename extension associated with this particular</span>
 <span class="s0">* file type, without a leading dot.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual std::string PNMFileType::get_extension(int n) const;</span>

<span class="s0">398 23 get_suggested_extension 0 6 680 36 PNMFileType::get_suggested_extension 0 1 21 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable filename extension (without a leading dot) to suggest</span>
 <span class="s0">* for files of this type, or empty string if no suggestions are available.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">virtual std::string PNMFileType::get_suggested_extension(void) const;</span>

<span class="s0">399 14 get_class_type 0 4 680 27 PNMFileType::get_class_type 0 1 22 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle PNMFileType::get_class_type(void);</span>

<span class="s0">400 20 ~PNMFileTypeRegistry 0 516 684 41 PNMFileTypeRegistry::~PNMFileTypeRegistry 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">PNMFileTypeRegistry::~PNMFileTypeRegistry(void);</span>

<span class="s0">401 13 get_num_types 0 4 684 34 PNMFileTypeRegistry::get_num_types 0 1 24 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of types registered.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">int PNMFileTypeRegistry::get_num_types(void) const;</span>

<span class="s0">402 8 get_type 0 4 684 29 PNMFileTypeRegistry::get_type 0 1 25 43</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth type registered.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">PNMFileType *PNMFileTypeRegistry::get_type(int n) const;</span>

<span class="s0">403 23 get_type_from_extension 0 4 684 44 PNMFileTypeRegistry::get_type_from_extension 0 1 26 203</span>
<span class="s0">/**</span>
 <span class="s0">* Tries to determine what the PNMFileType is likely to be for a particular</span>
 <span class="s0">* image file based on its extension.  Returns a suitable PNMFileType pointer,</span>
 <span class="s0">* or NULL if no type can be determined.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">PNMFileType *PNMFileTypeRegistry::get_type_from_extension(std::string const &amp;filename) const;</span>

<span class="s0">404 26 get_type_from_magic_number 0 4 684 47 PNMFileTypeRegistry::get_type_from_magic_number 0 1 27 249</span>
<span class="s0">/**</span>
 <span class="s0">* Tries to determine what the PNMFileType is likely to be for a particular</span>
 <span class="s0">* image file based on its magic number, the first two bytes read from the</span>
 <span class="s0">* file.  Returns a suitable PNMFileType pointer, or NULL if no type can be</span>
 <span class="s0">* determined.</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">PNMFileType *PNMFileTypeRegistry::get_type_from_magic_number(std::string const &amp;magic_number) const;</span>

<span class="s0">405 18 get_type_by_handle 0 4 684 39 PNMFileTypeRegistry::get_type_by_handle 0 1 28 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the PNMFileType instance stored in the registry for the given</span>
 <span class="s0">* TypeHandle, e.g.  as retrieved by a previous call to get_type() on the type</span>
 <span class="s0">* instance.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">PNMFileType *PNMFileTypeRegistry::get_type_by_handle(TypeHandle handle) const;</span>

<span class="s0">406 5 write 0 4 684 26 PNMFileTypeRegistry::write 0 1 29 103</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a list of supported image file types to the indicated output stream,</span>
 <span class="s0">* one per line.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void PNMFileTypeRegistry::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">407 14 get_global_ptr 0 4 684 35 PNMFileTypeRegistry::get_global_ptr 0 1 30 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global PNMFileTypeRegistry object.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static PNMFileTypeRegistry *PNMFileTypeRegistry::get_global_ptr(void);</span>

<span class="s0">408 19 PNMFileTypeRegistry 0 260 684 40 PNMFileTypeRegistry::PNMFileTypeRegistry 0 1 23 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline PNMFileTypeRegistry::PNMFileTypeRegistry(PNMFileTypeRegistry const &amp;) = default;</span>

<span class="s0">409 14 PNMImageHeader 0 260 686 30 PNMImageHeader::PNMImageHeader 0 2 31 32 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">inline PNMImageHeader::PNMImageHeader(void);</span>
<span class="s0">inline PNMImageHeader::PNMImageHeader(PNMImageHeader const &amp;copy);</span>

<span class="s0">410 10 operator = 0 4 686 26 PNMImageHeader::operator = 0 1 33 0</span>
<span class="s0">67</span>
<span class="s0">inline void PNMImageHeader::operator =(PNMImageHeader const &amp;copy);</span>

<span class="s0">411 15 ~PNMImageHeader 0 516 686 31 PNMImageHeader::~PNMImageHeader 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline PNMImageHeader::~PNMImageHeader(void);</span>

<span class="s0">412 14 get_color_type 0 4 686 30 PNMImageHeader::get_color_type 0 1 34 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the image type of the image, as an enumerated value.  This is</span>
 <span class="s0">* really just the number of channels cast to the enumerated type.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline PNMImageHeader::ColorType PNMImageHeader::get_color_type(void) const;</span>

<span class="s0">413 16 get_num_channels 0 4 686 32 PNMImageHeader::get_num_channels 0 1 35 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of channels in the image.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int PNMImageHeader::get_num_channels(void) const;</span>

<span class="s0">414 12 is_grayscale 0 4 686 28 PNMImageHeader::is_grayscale 0 2 36 37 416</span>
<span class="s0">/**</span>
 <span class="s0">* This static variant of is_grayscale() returns true if the indicated image</span>
 <span class="s0">* type represents a grayscale image, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns false if the image is a full-color image, and has red, green, and</span>
 <span class="s0">* blue components; true if it is a grayscale image and has only a gray</span>
 <span class="s0">* component.  (The gray color is actually stored in the blue channel, and the</span>
 <span class="s0">* red and green channels are ignored.)</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">static inline bool PNMImageHeader::is_grayscale(PNMImageHeader::ColorType color_type);</span>
<span class="s0">inline bool PNMImageHeader::is_grayscale(void) const;</span>

<span class="s0">415 9 has_alpha 0 4 686 25 PNMImageHeader::has_alpha 0 2 38 39 339</span>
<span class="s0">/**</span>
 <span class="s0">* This static variant of has_alpha() returns true if the indicated image type</span>
 <span class="s0">* includes an alpha channel, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the image includes an alpha channel, false otherwise.</span>
 <span class="s0">* Unlike is_grayscale(), if this returns false it is an error to call any of</span>
 <span class="s0">* the functions accessing the alpha channel.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">static inline bool PNMImageHeader::has_alpha(PNMImageHeader::ColorType color_type);</span>
<span class="s0">inline bool PNMImageHeader::has_alpha(void) const;</span>

<span class="s0">416 10 get_maxval 0 4 686 26 PNMImageHeader::get_maxval 0 1 40 183</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum channel value allowable for any pixel in this image;</span>
 <span class="s0">* for instance, 255 for a typical 8-bit-per-channel image.  A pixel with this</span>
 <span class="s0">* value is full on.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline xelval PNMImageHeader::get_maxval(void) const;</span>

<span class="s0">417 15 get_color_space 0 4 686 31 PNMImageHeader::get_color_space 0 1 41 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color space that the image is encoded in, or CS_unspecified if</span>
 <span class="s0">* unknown.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline ColorSpace PNMImageHeader::get_color_space(void) const;</span>

<span class="s0">418 10 get_x_size 0 4 686 26 PNMImageHeader::get_x_size 0 1 42 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of pixels in the X direction.  This is one more than the</span>
 <span class="s0">* largest allowable X coordinate.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int PNMImageHeader::get_x_size(void) const;</span>

<span class="s0">419 10 get_y_size 0 4 686 26 PNMImageHeader::get_y_size 0 1 43 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of pixels in the Y direction.  This is one more than the</span>
 <span class="s0">* largest allowable Y coordinate.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int PNMImageHeader::get_y_size(void) const;</span>

<span class="s0">420 8 get_size 0 4 686 24 PNMImageHeader::get_size 0 1 44 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of pixels in each direction.  This is one more than the</span>
 <span class="s0">* largest allowable coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LVecBase2i PNMImageHeader::get_size(void) const;</span>

<span class="s0">421 11 get_comment 0 4 686 27 PNMImageHeader::get_comment 0 1 45 47</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the user comment from the file.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::string PNMImageHeader::get_comment(void) const;</span>

<span class="s0">422 11 set_comment 0 4 686 27 PNMImageHeader::set_comment 0 1 46 62</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a user comment string to the image (header).</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void PNMImageHeader::set_comment(std::string const &amp;comment);</span>

<span class="s0">423 8 has_type 0 4 686 24 PNMImageHeader::has_type 0 1 47 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the PNMImageHeader knows what type it is, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool PNMImageHeader::has_type(void) const;</span>

<span class="s0">424 8 get_type 0 4 686 24 PNMImageHeader::get_type 0 1 48 130</span>
<span class="s0">/**</span>
 <span class="s0">* If the file type is known (e.g.  has_type() returns true), returns its</span>
 <span class="s0">* PNMFileType pointer; otherwise, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PNMFileType *PNMImageHeader::get_type(void) const;</span>

<span class="s0">425 8 set_type 0 4 686 24 PNMImageHeader::set_type 0 1 49 294</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the file type of this PNMImage.  This will be the default type used</span>
 <span class="s0">* when an image is read, if the type cannot be determined by magic number or</span>
 <span class="s0">* inferred by extension, or the type used when the image is written, if the</span>
 <span class="s0">* type cannot be inferred from the filename extension.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void PNMImageHeader::set_type(PNMFileType *type);</span>

<span class="s0">426 11 read_header 0 4 686 27 PNMImageHeader::read_header 0 2 50 51 619</span>
<span class="s0">/**</span>
 <span class="s0">* Opens up the image file and tries to read its header information to</span>
 <span class="s0">* determine its size, number of channels, etc.  If successful, updates the</span>
 <span class="s0">* header information and returns true; otherwise, returns false.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads the image header information only from the indicated stream.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is advisory only, and may be used to suggest a type if it has</span>
 <span class="s0">* a known extension.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the type of file it is (and a</span>
 <span class="s0">* non-NULL type will override any magic number test or filename extension</span>
 <span class="s0">* lookup).</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false on error.</span>
 <span class="s0">*/</span>
<span class="s0">277</span>
<span class="s0">bool PNMImageHeader::read_header(Filename const &amp;filename, PNMFileType *type = nullptr, bool report_unknown_type = true);</span>
<span class="s0">bool PNMImageHeader::read_header(std::istream &amp;data, std::string const &amp;filename = string(), PNMFileType *type = nullptr, bool report_unknown_type = true);</span>

<span class="s0">427 11 make_reader 0 4 686 27 PNMImageHeader::make_reader 0 2 52 53 1285</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated PNMReader of the suitable type for reading from</span>
 <span class="s0">* the indicated image filename, or NULL if the filename cannot be read for</span>
 <span class="s0">* some reason.  The filename &quot;-&quot; always stands for standard input.  If type</span>
 <span class="s0">* is specified, it is a suggestion for the file type to use.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMReader should be deleted when it is no longer needed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated PNMReader of the suitable type for reading from</span>
 <span class="s0">* the already-opened image file, or NULL if the file cannot be read for some</span>
 <span class="s0">* reason.</span>
 <span class="s0">*</span>
 <span class="s0">* owns_file should be set true if the PNMReader is to be considered the owner</span>
 <span class="s0">* of the stream pointer (in which case the stream will be deleted on</span>
 <span class="s0">* completion, whether successful or not), or false if it should not delete</span>
 <span class="s0">* it.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename parameter is optional here, since the file has already been</span>
 <span class="s0">* opened; it is only used to examine the extension and attempt to guess the</span>
 <span class="s0">* file type.</span>
 <span class="s0">*</span>
 <span class="s0">* If magic_number is nonempty, it is assumed to represent the first few bytes</span>
 <span class="s0">* that have already been read from the file.  Some file types may have</span>
 <span class="s0">* difficulty if this is more than two bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the file type to use.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMReader should be deleted when it is no longer needed.</span>
 <span class="s0">*/</span>
<span class="s0">360</span>
<span class="s0">PNMReader *PNMImageHeader::make_reader(Filename const &amp;filename, PNMFileType *type = nullptr, bool report_unknown_type = true) const;</span>
<span class="s0">PNMReader *PNMImageHeader::make_reader(std::istream *file, bool owns_file = true, Filename const &amp;filename = Filename(), std::string magic_number = string(), PNMFileType *type = nullptr, bool report_unknown_type = true) const;</span>

<span class="s0">428 11 make_writer 0 4 686 27 PNMImageHeader::make_writer 0 2 54 55 1100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated PNMWriter of the suitable type for writing an</span>
 <span class="s0">* image to the indicated filename, or NULL if the filename cannot be written</span>
 <span class="s0">* for some reason.  The filename &quot;-&quot; always stands for standard output.  If</span>
 <span class="s0">* type is specified, it is a suggestion for the file type to use.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMWriter should be deleted when it is no longer needed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated PNMWriter of the suitable type for writing to the</span>
 <span class="s0">* already-opened image file, or NULL if the file cannot be written for some</span>
 <span class="s0">* reason.</span>
 <span class="s0">*</span>
 <span class="s0">* owns_file should be set true if the PNMWriter is to be considered the owner</span>
 <span class="s0">* of the stream pointer (in which case the stream will be deleted on</span>
 <span class="s0">* completion, whether successful or not), or false if it should not delete</span>
 <span class="s0">* it.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename parameter is optional here, since the file has already been</span>
 <span class="s0">* opened; it is only used to examine the extension and attempt to guess the</span>
 <span class="s0">* intended file type.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the file type to use.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMWriter should be deleted when it is no longer needed.</span>
 <span class="s0">*/</span>
<span class="s0">257</span>
<span class="s0">PNMWriter *PNMImageHeader::make_writer(Filename const &amp;filename, PNMFileType *type = nullptr) const;</span>
<span class="s0">PNMWriter *PNMImageHeader::make_writer(std::ostream *file, bool owns_file = true, Filename const &amp;filename = Filename(), PNMFileType *type = nullptr) const;</span>

<span class="s0">429 17 read_magic_number 0 4 686 33 PNMImageHeader::read_magic_number 0 0 296</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that the first n bytes of the file are read into magic_number.  If</span>
 <span class="s0">* magic_number is initially nonempty, assumes these represent the first few</span>
 <span class="s0">* bytes already extracted.  Returns true if successful, false if an end of</span>
 <span class="s0">* file or error occurred before num_bytes could be read.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">static bool PNMImageHeader::read_magic_number(std::istream *file, std::string &amp;magic_number, int num_bytes);</span>

<span class="s0">430 6 output 0 4 686 22 PNMImageHeader::output 0 1 56 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void PNMImageHeader::output(std::ostream &amp;out) const;</span>

<span class="s0">431 9 PixelSpec 0 260 692 36 PNMImageHeader::PixelSpec::PixelSpec 0 7 57 58 59 60 61 62 63 70</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">549</span>
<span class="s0">inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value);</span>
<span class="s0">inline PNMImageHeader::PixelSpec::PixelSpec(xelval gray_value, xelval alpha);</span>
<span class="s0">inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue);</span>
<span class="s0">inline PNMImageHeader::PixelSpec::PixelSpec(xelval red, xelval green, xelval blue, xelval alpha);</span>
<span class="s0">inline PNMImageHeader::PixelSpec::PixelSpec(xel const &amp;rgb);</span>
<span class="s0">inline PNMImageHeader::PixelSpec::PixelSpec(xel const &amp;rgb, xelval alpha);</span>
<span class="s0">inline PNMImageHeader::PixelSpec::PixelSpec(PNMImageHeader::PixelSpec const &amp;) = default;</span>

<span class="s0">432 10 operator &lt; 0 4 692 37 PNMImageHeader::PixelSpec::operator &lt; 0 1 64 0</span>
<span class="s0">96</span>
<span class="s0">inline bool PNMImageHeader::PixelSpec::operator &lt;(PNMImageHeader::PixelSpec const &amp;other) const;</span>

<span class="s0">433 11 operator == 0 4 692 38 PNMImageHeader::PixelSpec::operator == 0 1 65 0</span>
<span class="s0">97</span>
<span class="s0">inline bool PNMImageHeader::PixelSpec::operator ==(PNMImageHeader::PixelSpec const &amp;other) const;</span>

<span class="s0">434 11 operator != 0 4 692 38 PNMImageHeader::PixelSpec::operator != 0 1 66 0</span>
<span class="s0">97</span>
<span class="s0">inline bool PNMImageHeader::PixelSpec::operator !=(PNMImageHeader::PixelSpec const &amp;other) const;</span>

<span class="s0">435 10 compare_to 0 4 692 37 PNMImageHeader::PixelSpec::compare_to 0 1 67 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline int PNMImageHeader::PixelSpec::compare_to(PNMImageHeader::PixelSpec const &amp;other) const;</span>

<span class="s0">436 7 get_red 0 4 692 34 PNMImageHeader::PixelSpec::get_red 0 1 68 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline xelval PNMImageHeader::PixelSpec::get_red(void) const;</span>

<span class="s0">437 9 get_green 0 4 692 36 PNMImageHeader::PixelSpec::get_green 0 1 69 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline xelval PNMImageHeader::PixelSpec::get_green(void) const;</span>

<span class="s0">438 8 get_blue 0 4 692 35 PNMImageHeader::PixelSpec::get_blue 0 1 70 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline xelval PNMImageHeader::PixelSpec::get_blue(void) const;</span>

<span class="s0">439 9 get_alpha 0 4 692 36 PNMImageHeader::PixelSpec::get_alpha 0 1 71 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline xelval PNMImageHeader::PixelSpec::get_alpha(void) const;</span>

<span class="s0">440 7 set_red 0 4 692 34 PNMImageHeader::PixelSpec::set_red 0 1 72 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void PNMImageHeader::PixelSpec::set_red(xelval red);</span>

<span class="s0">441 9 set_green 0 4 692 36 PNMImageHeader::PixelSpec::set_green 0 1 73 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void PNMImageHeader::PixelSpec::set_green(xelval green);</span>

<span class="s0">442 8 set_blue 0 4 692 35 PNMImageHeader::PixelSpec::set_blue 0 1 74 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void PNMImageHeader::PixelSpec::set_blue(xelval blue);</span>

<span class="s0">443 9 set_alpha 0 4 692 36 PNMImageHeader::PixelSpec::set_alpha 0 1 75 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void PNMImageHeader::PixelSpec::set_alpha(xelval alpha);</span>

<span class="s0">444 11 operator [] 0 4 692 38 PNMImageHeader::PixelSpec::operator [] 0 1 76 0</span>
<span class="s0">66</span>
<span class="s0">inline xelval PNMImageHeader::PixelSpec::operator [](int n) const;</span>

<span class="s0">445 4 size 0 4 692 31 PNMImageHeader::PixelSpec::size 0 1 77 135</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of components in the PixelSpec; this is always 4,</span>
 <span class="s0">* regardless of the type of image it was taken from.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static inline int PNMImageHeader::PixelSpec::size(void);</span>

<span class="s0">446 6 output 0 4 692 33 PNMImageHeader::PixelSpec::output 0 1 78 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void PNMImageHeader::PixelSpec::output(std::ostream &amp;out) const;</span>

<span class="s0">447 10 ~PixelSpec 0 516 692 37 PNMImageHeader::PixelSpec::~PixelSpec 0 0 0</span>
<span class="s0">44</span>
<span class="s0">PNMImageHeader::PixelSpec::~PixelSpec(void);</span>

<span class="s0">448 14 PixelSpecCount 0 260 693 46 PNMImageHeader::PixelSpecCount::PixelSpecCount 0 1 79 0</span>
<span class="s0">104</span>
<span class="s0">inline PNMImageHeader::PixelSpecCount::PixelSpecCount(PNMImageHeader::PixelSpecCount const &amp;) = default;</span>

<span class="s0">449 15 ~PixelSpecCount 0 516 693 47 PNMImageHeader::PixelSpecCount::~PixelSpecCount 0 0 0</span>
<span class="s0">54</span>
<span class="s0">PNMImageHeader::PixelSpecCount::~PixelSpecCount(void);</span>

<span class="s0">450 9 Histogram 0 260 700 36 PNMImageHeader::Histogram::Histogram 0 2 80 81 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">inline PNMImageHeader::Histogram::Histogram(void);</span>
<span class="s0">inline PNMImageHeader::Histogram::Histogram(PNMImageHeader::Histogram const &amp;) = default;</span>

<span class="s0">451 14 get_num_pixels 0 4 700 41 PNMImageHeader::Histogram::get_num_pixels 0 1 82 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of unique pixel colors in the histogram.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int PNMImageHeader::Histogram::get_num_pixels(void) const;</span>

<span class="s0">452 9 get_pixel 0 4 700 36 PNMImageHeader::Histogram::get_pixel 0 1 83 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth unique pixel color in the histogram.  These are ordered by</span>
 <span class="s0">* default from most common to least common.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">inline PNMImageHeader::PixelSpec const &amp;PNMImageHeader::Histogram::get_pixel(int n) const;</span>

<span class="s0">453 9 get_count 0 4 700 36 PNMImageHeader::Histogram::get_count 0 2 84 85 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of occurrences in the image of the nth unique pixel</span>
 <span class="s0">* color in the histogram.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the number of occurrences in the image of the indicated pixel</span>
 <span class="s0">* color.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">inline int PNMImageHeader::Histogram::get_count(int n) const;</span>
<span class="s0">inline int PNMImageHeader::Histogram::get_count(PNMImageHeader::PixelSpec const &amp;pixel) const;</span>

<span class="s0">454 5 write 0 4 700 32 PNMImageHeader::Histogram::write 0 1 86 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void PNMImageHeader::Histogram::write(std::ostream &amp;out) const;</span>

<span class="s0">455 10 ~Histogram 0 516 700 37 PNMImageHeader::Histogram::~Histogram 0 0 0</span>
<span class="s0">44</span>
<span class="s0">PNMImageHeader::Histogram::~Histogram(void);</span>

<span class="s0">456 7 PfmFile 0 260 701 16 PfmFile::PfmFile 0 2 87 88 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">PfmFile::PfmFile(void);</span>
<span class="s0">PfmFile::PfmFile(PfmFile const &amp;copy);</span>

<span class="s0">457 10 operator = 0 4 701 19 PfmFile::operator = 0 1 89 0</span>
<span class="s0">46</span>
<span class="s0">void PfmFile::operator =(PfmFile const &amp;copy);</span>

<span class="s0">458 5 clear 0 4 701 14 PfmFile::clear 0 2 90 91 252</span>
<span class="s0">/**</span>
 <span class="s0">* Eliminates all data in the file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Resets to an empty table with a specific size.  The case of num_channels ==</span>
 <span class="s0">* 0 is allowed only in the case that x_size and y_size are also == 0; and</span>
 <span class="s0">* this makes an empty (and invalid) PfmFile.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void PfmFile::clear(void);</span>
<span class="s0">void PfmFile::clear(int x_size, int y_size, int num_channels);</span>

<span class="s0">459 4 read 0 4 701 13 PfmFile::read 0 3 92 93 94 628</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the PFM data from the indicated file, returning true on success,</span>
 <span class="s0">* false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This can also handle reading a standard image file supported by PNMImage;</span>
 <span class="s0">* it will be quietly converted to a floating-point type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads the PFM data from the indicated stream, returning true on success,</span>
 <span class="s0">* false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This can also handle reading a standard image file supported by PNMImage;</span>
 <span class="s0">* it will be quietly converted to a floating-point type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads the PFM data using the indicated PNMReader.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMReader is always deleted upon completion, whether successful or not.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">bool PfmFile::read(Filename const &amp;fullpath);</span>
<span class="s0">bool PfmFile::read(std::istream &amp;in, Filename const &amp;fullpath = Filename());</span>
<span class="s0">bool PfmFile::read(PNMReader *reader);</span>

<span class="s0">460 5 write 0 4 701 14 PfmFile::write 0 3 95 96 97 563</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the PFM data to the indicated file, returning true on success, false</span>
 <span class="s0">* on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* If the type implied by the filename extension supports floating-point, the</span>
 <span class="s0">* data will be written directly; otherwise, the floating-point data will be</span>
 <span class="s0">* quietly converted to the appropriate integer type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes the PFM data to the indicated stream, returning true on success,</span>
 <span class="s0">* false on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes the PFM data using the indicated PNMWriter.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMWriter is always deleted upon completion, whether successful or not.</span>
 <span class="s0">*/</span>
<span class="s0">165</span>
<span class="s0">bool PfmFile::write(Filename const &amp;fullpath);</span>
<span class="s0">bool PfmFile::write(std::ostream &amp;out, Filename const &amp;fullpath = Filename());</span>
<span class="s0">bool PfmFile::write(PNMWriter *writer);</span>

<span class="s0">461 4 load 0 4 701 13 PfmFile::load 0 1 98 110</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the PfmFile with the data from the indicated PNMImage, converted to</span>
 <span class="s0">* floating-point values.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">bool PfmFile::load(PNMImage const &amp;pnmimage);</span>

<span class="s0">462 5 store 0 4 701 14 PfmFile::store 0 1 99 79</span>
<span class="s0">/**</span>
 <span class="s0">* Copies the data to the indicated PNMImage, converting to RGB values.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">bool PfmFile::store(PNMImage &amp;pnmimage) const;</span>

<span class="s0">463 10 store_mask 0 4 701 19 PfmFile::store_mask 0 2 100 101 606</span>
<span class="s0">/**</span>
 <span class="s0">* Stores 1 or 0 values into the indicated PNMImage, according to has_point()</span>
 <span class="s0">* for each pixel.  Each valid point gets a 1 value; each nonexistent point</span>
 <span class="s0">* gets a 0 value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores 1 or 0 values into the indicated PNMImage, according to has_point()</span>
 <span class="s0">* for each pixel.  Each valid point gets a 1 value; each nonexistent point</span>
 <span class="s0">* gets a 0 value.</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of store_mask also checks whether the valid points are within</span>
 <span class="s0">* the specified min/max range.  Any valid points without the condition</span>
 <span class="s0">* min_point[c] &lt;= value[c] &lt;= max_point[c], for any c, are stored with a 0 in</span>
 <span class="s0">* the mask.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">bool PfmFile::store_mask(PNMImage &amp;pnmimage) const;</span>
<span class="s0">bool PfmFile::store_mask(PNMImage &amp;pnmimage, LVecBase4f const &amp;min_point, LVecBase4f const &amp;max_point) const;</span>

<span class="s0">464 8 is_valid 0 4 701 17 PfmFile::is_valid 0 1 102 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool PfmFile::is_valid(void) const;</span>

<span class="s0">465 9 get_scale 0 4 701 18 PfmFile::get_scale 0 1 103 81</span>
<span class="s0">/**</span>
 <span class="s0">* The &quot;scale&quot; is reported in the pfm header and is probably meaningless.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline PN_float32 PfmFile::get_scale(void) const;</span>

<span class="s0">466 9 set_scale 0 4 701 18 PfmFile::set_scale 0 1 104 81</span>
<span class="s0">/**</span>
 <span class="s0">* The &quot;scale&quot; is reported in the pfm header and is probably meaningless.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void PfmFile::set_scale(PN_float32 scale);</span>

<span class="s0">467 9 has_point 0 4 701 18 PfmFile::has_point 0 1 105 205</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a valid point at x, y.  This always returns true</span>
 <span class="s0">* unless a &quot;no data&quot; value has been set, in which case it returns false if</span>
 <span class="s0">* the point at x, y is the &quot;no data&quot; value.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool PfmFile::has_point(int x, int y) const;</span>

<span class="s0">468 11 get_channel 0 4 701 20 PfmFile::get_channel 0 1 106 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the cth channel of the point value at the indicated point.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline PN_float32 PfmFile::get_channel(int x, int y, int c) const;</span>

<span class="s0">469 11 set_channel 0 4 701 20 PfmFile::set_channel 0 1 107 78</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the cth channel of the point value at the indicated point.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void PfmFile::set_channel(int x, int y, int c, PN_float32 value);</span>

<span class="s0">470 10 get_point1 0 4 701 19 PfmFile::get_point1 0 1 108 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 1-component point value at the indicated point.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline PN_float32 PfmFile::get_point1(int x, int y) const;</span>

<span class="s0">471 10 set_point1 0 4 701 19 PfmFile::set_point1 0 1 109 71</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the 1-component point value at the indicated point.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void PfmFile::set_point1(int x, int y, PN_float32 point);</span>

<span class="s0">472 10 get_point2 0 4 701 19 PfmFile::get_point2 0 1 110 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 2-component point value at the indicated point.  In a 1-channel</span>
 <span class="s0">* image, the channel value is in the x component.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LPoint2f const &amp;PfmFile::get_point2(int x, int y) const;</span>

<span class="s0">473 10 set_point2 0 4 701 19 PfmFile::set_point2 0 2 111 112 278</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the 2-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the 2-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void PfmFile::set_point2(int x, int y, LVecBase2f const &amp;point);</span>
<span class="s0">inline void PfmFile::set_point2(int x, int y, LVecBase2d const &amp;point);</span>

<span class="s0">474 13 modify_point2 0 4 701 22 PfmFile::modify_point2 0 1 113 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable 2-component point value at the indicated point.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LPoint2f &amp;PfmFile::modify_point2(int x, int y);</span>

<span class="s0">475 9 get_point 0 4 701 18 PfmFile::get_point 0 1 114 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 3-component point value at the indicated point.  In a 1-channel</span>
 <span class="s0">* image, the channel value is in the x component.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LPoint3f const &amp;PfmFile::get_point(int x, int y) const;</span>

<span class="s0">476 9 set_point 0 4 701 18 PfmFile::set_point 0 2 115 116 278</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the 3-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the 3-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/</span>
<span class="s0">141</span>
<span class="s0">inline void PfmFile::set_point(int x, int y, LVecBase3f const &amp;point);</span>
<span class="s0">inline void PfmFile::set_point(int x, int y, LVecBase3d const &amp;point);</span>

<span class="s0">477 12 modify_point 0 4 701 21 PfmFile::modify_point 0 1 117 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable 3-component point value at the indicated point.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LPoint3f &amp;PfmFile::modify_point(int x, int y);</span>

<span class="s0">478 10 get_point3 0 4 701 19 PfmFile::get_point3 0 1 118 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 3-component point value at the indicated point.  In a 1-channel</span>
 <span class="s0">* image, the channel value is in the x component.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LPoint3f const &amp;PfmFile::get_point3(int x, int y) const;</span>

<span class="s0">479 10 set_point3 0 4 701 19 PfmFile::set_point3 0 2 119 120 278</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the 3-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the 3-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void PfmFile::set_point3(int x, int y, LVecBase3f const &amp;point);</span>
<span class="s0">inline void PfmFile::set_point3(int x, int y, LVecBase3d const &amp;point);</span>

<span class="s0">480 13 modify_point3 0 4 701 22 PfmFile::modify_point3 0 1 121 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable 3-component point value at the indicated point.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LPoint3f &amp;PfmFile::modify_point3(int x, int y);</span>

<span class="s0">481 10 get_point4 0 4 701 19 PfmFile::get_point4 0 1 122 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 4-component point value at the indicated point.  In a 1-channel</span>
 <span class="s0">* image, the channel value is in the x component.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LPoint4f const &amp;PfmFile::get_point4(int x, int y) const;</span>

<span class="s0">482 10 set_point4 0 4 701 19 PfmFile::set_point4 0 2 123 124 278</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the 4-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the 4-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void PfmFile::set_point4(int x, int y, LVecBase4f const &amp;point);</span>
<span class="s0">inline void PfmFile::set_point4(int x, int y, LVecBase4d const &amp;point);</span>

<span class="s0">483 13 modify_point4 0 4 701 22 PfmFile::modify_point4 0 1 125 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable 4-component point value at the indicated point.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LPoint4f &amp;PfmFile::modify_point4(int x, int y);</span>

<span class="s0">484 4 fill 0 4 701 13 PfmFile::fill 0 4 126 127 128 129 222</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the table with all of the same value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills the table with all of the same value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills the table with all of the same value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills the table with all of the same value.</span>
 <span class="s0">*/</span>
<span class="s0">187</span>
<span class="s0">inline void PfmFile::fill(PN_float32 value);</span>
<span class="s0">inline void PfmFile::fill(LPoint2f const &amp;value);</span>
<span class="s0">inline void PfmFile::fill(LPoint3f const &amp;value);</span>
<span class="s0">void PfmFile::fill(LPoint4f const &amp;value);</span>

<span class="s0">485 8 fill_nan 0 4 701 17 PfmFile::fill_nan 0 1 130 40</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the table with all NaN.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">void PfmFile::fill_nan(void);</span>

<span class="s0">486 18 fill_no_data_value 0 4 701 27 PfmFile::fill_no_data_value 0 1 131 86</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the table with the current no_data value, so that the table is empty.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void PfmFile::fill_no_data_value(void);</span>

<span class="s0">487 12 fill_channel 0 4 701 21 PfmFile::fill_channel 0 1 132 107</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the indicated channel with all of the same value, leaving the other</span>
 <span class="s0">* channels unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void PfmFile::fill_channel(int channel, PN_float32 value);</span>

<span class="s0">488 16 fill_channel_nan 0 4 701 25 PfmFile::fill_channel_nan 0 1 133 86</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the indicated channel with NaN, leaving the other channels unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void PfmFile::fill_channel_nan(int channel);</span>

<span class="s0">489 19 fill_channel_masked 0 4 701 28 PfmFile::fill_channel_masked 0 1 134 152</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the indicated channel with all of the same value, but only where the</span>
 <span class="s0">* table already has a data point.  Leaves empty points unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">void PfmFile::fill_channel_masked(int channel, PN_float32 value);</span>

<span class="s0">490 23 fill_channel_masked_nan 0 4 701 32 PfmFile::fill_channel_masked_nan 0 1 135 134</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the indicated channel with NaN, but only where the table already has</span>
 <span class="s0">* a data point.  Leaves empty points unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void PfmFile::fill_channel_masked_nan(int channel);</span>

<span class="s0">491 18 calc_average_point 0 4 701 27 PfmFile::calc_average_point 0 1 136 296</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the unweighted average point of all points within the box centered</span>
 <span class="s0">* at (x, y) with the indicated Manhattan-distance radius.  Missing points are</span>
 <span class="s0">* assigned the value of their nearest neighbor.  Returns true if successful,</span>
 <span class="s0">* or false if the point value cannot be determined.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">bool PfmFile::calc_average_point(LPoint3f &amp;result, PN_float32 x, PN_float32 y, PN_float32 radius) const;</span>

<span class="s0">492 19 calc_bilinear_point 0 4 701 28 PfmFile::calc_bilinear_point 0 1 137 190</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the weighted average of the four nearest points to the floating-</span>
 <span class="s0">* point index (x, y).  Returns true if the point has any contributors, false</span>
 <span class="s0">* if the point is unknown.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">bool PfmFile::calc_bilinear_point(LPoint3f &amp;result, PN_float32 x, PN_float32 y) const;</span>

<span class="s0">493 12 calc_min_max 0 4 701 21 PfmFile::calc_min_max 0 1 138 246</span>
<span class="s0">/**</span>
 <span class="s0">* Calculates the minimum and maximum x, y, and z depth component values,</span>
 <span class="s0">* representing the bounding box of depth values, and places them in the</span>
 <span class="s0">* indicated vectors.  Returns true if successful, false if the mesh contains</span>
 <span class="s0">* no points.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">bool PfmFile::calc_min_max(LVecBase3f &amp;min_points, LVecBase3f &amp;max_points) const;</span>

<span class="s0">494 13 calc_autocrop 0 4 701 22 PfmFile::calc_autocrop 0 2 139 140 754</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the minimum range of x and y across the PFM file that include all</span>
 <span class="s0">* points.  If there are no points with no_data_value in the grid--that is,</span>
 <span class="s0">* all points are included--then this will return (0, get_x_size(), 0,</span>
 <span class="s0">* get_y_size()).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Computes the minimum range of x and y across the PFM file that include all</span>
 <span class="s0">* points.  If there are no points with no_data_value in the grid--that is,</span>
 <span class="s0">* all points are included--then this will return (0, get_x_size(), 0,</span>
 <span class="s0">* get_y_size()).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Computes the minimum range of x and y across the PFM file that include all</span>
 <span class="s0">* points.  If there are no points with no_data_value in the grid--that is,</span>
 <span class="s0">* all points are included--then this will return (0, get_x_size(), 0,</span>
 <span class="s0">* get_y_size()).</span>
 <span class="s0">*/</span>
<span class="s0">208</span>
<span class="s0">bool PfmFile::calc_autocrop(int &amp;x_begin, int &amp;x_end, int &amp;y_begin, int &amp;y_end) const;</span>
<span class="s0">inline bool PfmFile::calc_autocrop(LVecBase4f &amp;range) const;</span>
<span class="s0">inline bool PfmFile::calc_autocrop(LVecBase4d &amp;range) const;</span>

<span class="s0">495 12 is_row_empty 0 4 701 21 PfmFile::is_row_empty 0 1 141 160</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all of the points on row y, in the range [x_begin, x_end),</span>
 <span class="s0">* are the no_data value, or false if any one of these points has a value.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool PfmFile::is_row_empty(int y, int x_begin, int x_end) const;</span>

<span class="s0">496 15 is_column_empty 0 4 701 24 PfmFile::is_column_empty 0 1 142 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all of the points on column x, from [y_begin, y_end), are</span>
 <span class="s0">* the no_data value, or false if any one of these points has a value.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">bool PfmFile::is_column_empty(int x, int y_begin, int y_end) const;</span>

<span class="s0">497 16 set_zero_special 0 4 701 25 PfmFile::set_zero_special 0 1 143 209</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the zero_special flag.  When this flag is true, values of (0, 0, 0) in</span>
 <span class="s0">* the pfm file are treated as a special case, and are not processed.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a special case of set_no_data_value().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void PfmFile::set_zero_special(bool zero_special);</span>

<span class="s0">498 17 set_no_data_chan4 0 4 701 26 PfmFile::set_no_data_chan4 0 1 144 259</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the no_data_chan4 flag.  When this flag is true, and the pfm file has</span>
 <span class="s0">* 4 channels, then a negative value in the fourth channel indicates no data.</span>
 <span class="s0">* When it is false, all points are valid.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a special case of set_no_data_value().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void PfmFile::set_no_data_chan4(bool chan4);</span>

<span class="s0">499 15 set_no_data_nan 0 4 701 24 PfmFile::set_no_data_nan 0 1 145 272</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the no_data_nan flag.  When num_channels is nonzero, then a NaN value</span>
 <span class="s0">* in any of the first num_channels channels indicates no data for that point.</span>
 <span class="s0">* If num_channels is zero, then all points are valid.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a special case of set_no_data_value().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void PfmFile::set_no_data_nan(int num_channels);</span>

<span class="s0">500 17 set_no_data_value 0 4 701 26 PfmFile::set_no_data_value 0 2 146 147 182</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the special value that means &quot;no data&quot; when it appears in the pfm</span>
 <span class="s0">* file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the special value that means &quot;no data&quot; when it appears in the pfm</span>
 <span class="s0">* file.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">void PfmFile::set_no_data_value(LPoint4f const &amp;no_data_value);</span>
<span class="s0">inline void PfmFile::set_no_data_value(LPoint4d const &amp;no_data_value);</span>

<span class="s0">501 21 set_no_data_threshold 0 4 701 30 PfmFile::set_no_data_threshold 0 2 148 149 254</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the special threshold value.  Points that are below this value in all</span>
 <span class="s0">* components are considered &quot;no value&quot;.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the special threshold value.  Points that are below this value in all</span>
 <span class="s0">* components are considered &quot;no value&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">void PfmFile::set_no_data_threshold(LPoint4f const &amp;no_data_value);</span>
<span class="s0">inline void PfmFile::set_no_data_threshold(LPoint4d const &amp;no_data_value);</span>

<span class="s0">502 19 clear_no_data_value 0 4 701 28 PfmFile::clear_no_data_value 0 1 150 136</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the special value that means &quot;no data&quot; when it appears in the pfm</span>
 <span class="s0">* file.  All points will thus be considered valid.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void PfmFile::clear_no_data_value(void);</span>

<span class="s0">503 17 has_no_data_value 0 4 701 26 PfmFile::has_no_data_value 0 1 151 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether a &quot;no data&quot; value has been established by</span>
 <span class="s0">* set_no_data_value().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool PfmFile::has_no_data_value(void) const;</span>

<span class="s0">504 21 has_no_data_threshold 0 4 701 30 PfmFile::has_no_data_threshold 0 1 152 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether a &quot;no data&quot; threshold value has been established by</span>
 <span class="s0">* set_no_data_threshold().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool PfmFile::has_no_data_threshold(void) const;</span>

<span class="s0">505 17 get_no_data_value 0 4 701 26 PfmFile::get_no_data_value 0 1 153 95</span>
<span class="s0">/**</span>
 <span class="s0">* If has_no_data_value() returns true, this returns the particular &quot;no data&quot;</span>
 <span class="s0">* value.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LPoint4f const &amp;PfmFile::get_no_data_value(void) const;</span>

<span class="s0">506 6 resize 0 4 701 15 PfmFile::resize 0 1 154 173</span>
<span class="s0">/**</span>
 <span class="s0">* Applies a simple filter to resample the pfm file in-place to the indicated</span>
 <span class="s0">* size.  Don't confuse this with applying a scale to all of the points via</span>
 <span class="s0">* xform().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void PfmFile::resize(int new_x_size, int new_y_size);</span>

<span class="s0">507 15 box_filter_from 0 4 701 24 PfmFile::box_filter_from 0 1 155 260</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a resized copy of the indicated image into this one using the</span>
 <span class="s0">* indicated filter.  The image to be copied is squashed and stretched to</span>
 <span class="s0">* match the dimensions of the current image, applying the appropriate filter</span>
 <span class="s0">* to perform the stretching.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">void PfmFile::box_filter_from(float radius, PfmFile const &amp;copy);</span>

<span class="s0">508 20 gaussian_filter_from 0 4 701 29 PfmFile::gaussian_filter_from 0 1 156 260</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a resized copy of the indicated image into this one using the</span>
 <span class="s0">* indicated filter.  The image to be copied is squashed and stretched to</span>
 <span class="s0">* match the dimensions of the current image, applying the appropriate filter</span>
 <span class="s0">* to perform the stretching.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void PfmFile::gaussian_filter_from(float radius, PfmFile const &amp;copy);</span>

<span class="s0">509 17 quick_filter_from 0 4 701 26 PfmFile::quick_filter_from 0 1 157 257</span>
<span class="s0">/**</span>
 <span class="s0">* Resizes from the given image, with a fixed radius of 0.5. This is a very</span>
 <span class="s0">* specialized and simple algorithm that doesn't handle dropping below the</span>
 <span class="s0">* Nyquist rate very well, but is quite a bit faster than the more general</span>
 <span class="s0">* box_filter(), above.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void PfmFile::quick_filter_from(PfmFile const &amp;copy);</span>

<span class="s0">510 12 reverse_rows 0 4 701 21 PfmFile::reverse_rows 0 1 158 61</span>
<span class="s0">/**</span>
 <span class="s0">* Performs an in-place reversal of the row (y) data.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void PfmFile::reverse_rows(void);</span>

<span class="s0">511 4 flip 0 4 701 13 PfmFile::flip 0 1 159 369</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses, transposes, and/or rotates the table in-place according to the</span>
 <span class="s0">* specified parameters.  If flip_x is true, the x axis is reversed; if flip_y</span>
 <span class="s0">* is true, the y axis is reversed.  Then, if transpose is true, the x and y</span>
 <span class="s0">* axes are exchanged.  These parameters can be used to select any combination</span>
 <span class="s0">* of 90-degree or 180-degree rotations and flips.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void PfmFile::flip(bool flip_x, bool flip_y, bool transpose);</span>

<span class="s0">512 5 xform 0 4 701 14 PfmFile::xform 0 2 160 161 148</span>
<span class="s0">/**</span>
 <span class="s0">* Applies the indicated transform matrix to all points in-place.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Applies the indicated transform matrix to all points in-place.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">void PfmFile::xform(LMatrix4f const &amp;transform);</span>
<span class="s0">inline void PfmFile::xform(LMatrix4d const &amp;transform);</span>

<span class="s0">513 15 forward_distort 0 4 701 24 PfmFile::forward_distort 0 1 162 659</span>
<span class="s0">/**</span>
 <span class="s0">* Applies the distortion indicated in the supplied dist map to the current</span>
 <span class="s0">* map.  The dist map is understood to be a mapping of points in the range</span>
 <span class="s0">* 0..1 in the first two dimensions.</span>
 <span class="s0">*</span>
 <span class="s0">* The operation can be expressed symbolically as:</span>
 <span class="s0">*</span>
 <span class="s0">* this(u, v) = this(dist(u, v))</span>
 <span class="s0">*</span>
 <span class="s0">* If scale_factor is not 1, it should be a value &gt; 1, and it specifies the</span>
 <span class="s0">* factor to upscale the working table while processing, to reduce artifacts</span>
 <span class="s0">* from integer truncation.</span>
 <span class="s0">*</span>
 <span class="s0">* By convention, the y axis is inverted in the distortion map relative to the</span>
 <span class="s0">* coordinates here.  A y value of 0 in the distortion map corresponds with a</span>
 <span class="s0">* v value of 1 in this file.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void PfmFile::forward_distort(PfmFile const &amp;dist, PN_float32 scale_factor = 1.0);</span>

<span class="s0">514 15 reverse_distort 0 4 701 24 PfmFile::reverse_distort 0 1 163 659</span>
<span class="s0">/**</span>
 <span class="s0">* Applies the distortion indicated in the supplied dist map to the current</span>
 <span class="s0">* map.  The dist map is understood to be a mapping of points in the range</span>
 <span class="s0">* 0..1 in the first two dimensions.</span>
 <span class="s0">*</span>
 <span class="s0">* The operation can be expressed symbolically as:</span>
 <span class="s0">*</span>
 <span class="s0">* this(u, v) = dist(this(u, v))</span>
 <span class="s0">*</span>
 <span class="s0">* If scale_factor is not 1, it should be a value &gt; 1, and it specifies the</span>
 <span class="s0">* factor to upscale the working table while processing, to reduce artifacts</span>
 <span class="s0">* from integer truncation.</span>
 <span class="s0">*</span>
 <span class="s0">* By convention, the y axis in inverted in the distortion map relative to the</span>
 <span class="s0">* coordinates here.  A y value of 0 in the distortion map corresponds with a</span>
 <span class="s0">* v value of 1 in this file.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void PfmFile::reverse_distort(PfmFile const &amp;dist, PN_float32 scale_factor = 1.0);</span>

<span class="s0">515 12 apply_1d_lut 0 4 701 21 PfmFile::apply_1d_lut 0 1 164 211</span>
<span class="s0">/**</span>
 <span class="s0">* Assumes that lut is an X by 1, 1-component PfmFile whose X axis maps points</span>
 <span class="s0">* to target points.  For each point in this pfm file, computes: p(u,</span>
 <span class="s0">* v)[channel] = lut(p(u, v)[channel] * x_scale, 0)[0]</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">void PfmFile::apply_1d_lut(int channel, PfmFile const &amp;lut, PN_float32 x_scale = 1.0);</span>

<span class="s0">516 5 merge 0 4 701 14 PfmFile::merge 0 1 165 199</span>
<span class="s0">/**</span>
 <span class="s0">* Wherever there is missing data in this PfmFile (that is, wherever</span>
 <span class="s0">* has_point() returns false), copy data from the other PfmFile, which must be</span>
 <span class="s0">* exactly the same dimensions as this one.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void PfmFile::merge(PfmFile const &amp;other);</span>

<span class="s0">517 10 apply_mask 0 4 701 19 PfmFile::apply_mask 0 1 166 274</span>
<span class="s0">/**</span>
 <span class="s0">* Wherever there is missing data in the other PfmFile, set this the</span>
 <span class="s0">* corresponding point in this PfmFile to missing as well, so that this</span>
 <span class="s0">* PfmFile has only points where both files have points.</span>
 <span class="s0">*</span>
 <span class="s0">* The point is set to &quot;missing&quot; by setting it the no_data_value.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void PfmFile::apply_mask(PfmFile const &amp;other);</span>

<span class="s0">518 12 copy_channel 0 4 701 21 PfmFile::copy_channel 0 1 167 159</span>
<span class="s0">/**</span>
 <span class="s0">* Copies just the specified channel values from the indicated PfmFile (which</span>
 <span class="s0">* could be same as this PfmFile) into the specified channel of this one.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">void PfmFile::copy_channel(int to_channel, PfmFile const &amp;other, int from_channel);</span>

<span class="s0">519 19 copy_channel_masked 0 4 701 28 PfmFile::copy_channel_masked 0 1 168 130</span>
<span class="s0">/**</span>
 <span class="s0">* Copies just the specified channel values from the indicated PfmFile, but</span>
 <span class="s0">* only where the other file has a data point.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">void PfmFile::copy_channel_masked(int to_channel, PfmFile const &amp;other, int from_channel);</span>

<span class="s0">520 10 apply_crop 0 4 701 19 PfmFile::apply_crop 0 1 169 148</span>
<span class="s0">/**</span>
 <span class="s0">* Reduces the PFM file to the cells in the rectangle bounded by (x_begin,</span>
 <span class="s0">* x_end, y_begin, y_end), where the _end cells are not included.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">void PfmFile::apply_crop(int x_begin, int x_end, int y_begin, int y_end);</span>

<span class="s0">521 18 clear_to_texcoords 0 4 701 27 PfmFile::clear_to_texcoords 0 1 170 159</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces this PfmFile with a new PfmFile of size x_size x y_size x 3,</span>
 <span class="s0">* containing the x y 0 values in the range 0 .. 1 according to the x y index.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void PfmFile::clear_to_texcoords(int x_size, int y_size);</span>

<span class="s0">522 9 pull_spot 0 4 701 18 PfmFile::pull_spot 0 1 171 262</span>
<span class="s0">/**</span>
 <span class="s0">* Applies delta * t to the point values within radius (xr, yr) distance of</span>
 <span class="s0">* (xc, yc).  The t value is scaled from 1.0 at the center to 0.0 at radius</span>
 <span class="s0">* (xr, yr), and this scale follows the specified exponent.  Returns the</span>
 <span class="s0">* number of points affected.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">int PfmFile::pull_spot(LPoint4f const &amp;delta, float xc, float yc, float xr, float yr, float exponent);</span>

<span class="s0">523 17 calc_tight_bounds 0 4 701 26 PfmFile::calc_tight_bounds 0 1 172 209</span>
<span class="s0">/**</span>
 <span class="s0">* Calculates the minimum and maximum vertices of all points within the table.</span>
 <span class="s0">* Assumes the table contains 3-D points.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if any points in the table, or false if none are.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">bool PfmFile::calc_tight_bounds(LPoint3f &amp;min_point, LPoint3f &amp;max_point) const;</span>

<span class="s0">524 21 compute_planar_bounds 0 4 701 30 PfmFile::compute_planar_bounds 0 2 173 174 1290</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the minmax bounding volume of the points in 3-D space, assuming</span>
 <span class="s0">* the points represent a mostly-planar surface.</span>
 <span class="s0">*</span>
 <span class="s0">* This algorithm works by sampling the (square) sample_radius pixels at the</span>
 <span class="s0">* four point_dist corners around the center (cx - pd, cx + pd) and so on, to</span>
 <span class="s0">* approximate the plane of the surface.  Then all of the points are projected</span>
 <span class="s0">* into that plane and the bounding volume of the entire mesh within that</span>
 <span class="s0">* plane is determined.  If points_only is true, the bounding volume of only</span>
 <span class="s0">* those four points is determined.</span>
 <span class="s0">*</span>
 <span class="s0">* center, point_dist and sample_radius are in UV space, i.e.  in the range</span>
 <span class="s0">* 0..1.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Computes the minmax bounding volume of the points in 3-D space, assuming</span>
 <span class="s0">* the points represent a mostly-planar surface.</span>
 <span class="s0">*</span>
 <span class="s0">* This algorithm works by sampling the (square) sample_radius pixels at the</span>
 <span class="s0">* four point_dist corners around the center (cx - pd, cx + pd) and so on, to</span>
 <span class="s0">* approximate the plane of the surface.  Then all of the points are projected</span>
 <span class="s0">* into that plane and the bounding volume of the entire mesh within that</span>
 <span class="s0">* plane is determined.  If points_only is true, the bounding volume of only</span>
 <span class="s0">* those four points is determined.</span>
 <span class="s0">*</span>
 <span class="s0">* center, point_dist and sample_radius are in UV space, i.e.  in the range</span>
 <span class="s0">* 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">328</span>
<span class="s0">PointerTo&lt; BoundingHexahedron &gt; PfmFile::compute_planar_bounds(LPoint2f const &amp;center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const;</span>
<span class="s0">inline PointerTo&lt; BoundingHexahedron &gt; PfmFile::compute_planar_bounds(LPoint2d const &amp;center, PN_float32 point_dist, PN_float32 sample_radius, bool points_only) const;</span>

<span class="s0">525 20 compute_sample_point 0 4 701 29 PfmFile::compute_sample_point 0 1 175 188</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the average of all the point within sample_radius (manhattan</span>
 <span class="s0">* distance) and the indicated point.</span>
 <span class="s0">*</span>
 <span class="s0">* The point coordinates are given in UV space, in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">void PfmFile::compute_sample_point(LPoint3f &amp;result, PN_float32 x, PN_float32 y, PN_float32 sample_radius) const;</span>

<span class="s0">526 14 copy_sub_image 0 4 701 23 PfmFile::copy_sub_image 0 1 176 344</span>
<span class="s0">/**</span>
 <span class="s0">* Copies a rectangular area of another image into a rectangular area of this</span>
 <span class="s0">* image.  Both images must already have been initialized.  The upper-left</span>
 <span class="s0">* corner of the region in both images is specified, and the size of the area;</span>
 <span class="s0">* if the size is omitted, it defaults to the entire other image, or the</span>
 <span class="s0">* largest piece that will fit.</span>
 <span class="s0">*/</span>
<span class="s0">132</span>
<span class="s0">void PfmFile::copy_sub_image(PfmFile const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1);</span>

<span class="s0">527 13 add_sub_image 0 4 701 22 PfmFile::add_sub_image 0 1 177 155</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are added to the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">void PfmFile::add_sub_image(PfmFile const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0);</span>

<span class="s0">528 14 mult_sub_image 0 4 701 23 PfmFile::mult_sub_image 0 1 178 160</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are multiplied to the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">void PfmFile::mult_sub_image(PfmFile const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0);</span>

<span class="s0">529 16 divide_sub_image 0 4 701 25 PfmFile::divide_sub_image 0 1 179 216</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are divided into the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">* dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).</span>
 <span class="s0">*/</span>
<span class="s0">159</span>
<span class="s0">void PfmFile::divide_sub_image(PfmFile const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0);</span>

<span class="s0">530 11 operator *= 0 4 701 20 PfmFile::operator *= 0 1 180 0</span>
<span class="s0">44</span>
<span class="s0">void PfmFile::operator *=(float multiplier);</span>

<span class="s0">531 18 indirect_1d_lookup 0 4 701 27 PfmFile::indirect_1d_lookup 0 1 181 566</span>
<span class="s0">/**</span>
 <span class="s0">* index_image is a WxH 1-channel image, while pixel_values is an Nx1</span>
 <span class="s0">* image with any number of channels.  Typically pixel_values will be</span>
 <span class="s0">* a 256x1 image.</span>
 <span class="s0">*</span>
 <span class="s0">* Fills the PfmFile with a new image the same width and height as</span>
 <span class="s0">* index_image, with the same number of channels as pixel_values.</span>
 <span class="s0">*</span>
 <span class="s0">* Each pixel of the new image is computed with the formula:</span>
 <span class="s0">*</span>
 <span class="s0">* new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)</span>
 <span class="s0">*</span>
 <span class="s0">* At present, no interpolation is performed; the nearest value in</span>
 <span class="s0">* pixel_values is discovered.  This may change in the future.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">void PfmFile::indirect_1d_lookup(PfmFile const &amp;index_image, int channel, PfmFile const &amp;pixel_values);</span>

<span class="s0">532 13 gamma_correct 0 4 701 22 PfmFile::gamma_correct 0 1 182 217</span>
<span class="s0">/**</span>
 <span class="s0">* Assuming the image was constructed with a gamma curve of from_gamma in the</span>
 <span class="s0">* RGB channels, converts it to an image with a gamma curve of to_gamma in the</span>
 <span class="s0">* RGB channels.  Does not affect the alpha channel.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void PfmFile::gamma_correct(float from_gamma, float to_gamma);</span>

<span class="s0">533 19 gamma_correct_alpha 0 4 701 28 PfmFile::gamma_correct_alpha 0 1 183 218</span>
<span class="s0">/**</span>
 <span class="s0">* Assuming the image was constructed with a gamma curve of from_gamma in the</span>
 <span class="s0">* alpha channel, converts it to an image with a gamma curve of to_gamma in</span>
 <span class="s0">* the alpha channel.  Does not affect the RGB channels.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void PfmFile::gamma_correct_alpha(float from_gamma, float to_gamma);</span>

<span class="s0">534 14 apply_exponent 0 4 701 23 PfmFile::apply_exponent 0 4 184 185 186 187 733</span>
<span class="s0">/**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.  For a</span>
 <span class="s0">* grayscale image, the blue_exponent value is used for the grayscale value,</span>
 <span class="s0">* and red_exponent and green_exponent are unused.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/</span>
<span class="s0">337</span>
<span class="s0">inline void PfmFile::apply_exponent(float gray_exponent);</span>
<span class="s0">inline void PfmFile::apply_exponent(float gray_exponent, float alpha_exponent);</span>
<span class="s0">inline void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent);</span>
<span class="s0">void PfmFile::apply_exponent(float c0_exponent, float c1_exponent, float c2_exponent, float c3_exponent);</span>

<span class="s0">535 6 output 0 4 701 15 PfmFile::output 0 1 188 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void PfmFile::output(std::ostream &amp;out) const;</span>

<span class="s0">536 10 get_points 0 4 701 19 PfmFile::get_points 0 1 189 0</span>
<span class="s0">42</span>
<span class="s0">PyObject *PfmFile::get_points(void) const;</span>

<span class="s0">537 13 __getbuffer__ 0 4 701 22 PfmFile::__getbuffer__ 0 1 190 0</span>
<span class="s0">77</span>
<span class="s0">int PfmFile::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;</span>

<span class="s0">538 8 ~PfmFile 0 516 701 17 PfmFile::~PfmFile 0 0 0</span>
<span class="s0">24</span>
<span class="s0">PfmFile::~PfmFile(void);</span>

<span class="s0">539 16 make_transparent 0 4 705 26 PNMBrush::make_transparent 0 1 191 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new brush that does not paint anything.  Can be used as either a</span>
 <span class="s0">* pen or a fill brush to make borderless or unfilled shapes, respectively.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static PointerTo&lt; PNMBrush &gt; PNMBrush::make_transparent(void);</span>

<span class="s0">540 10 make_pixel 0 4 705 20 PNMBrush::make_pixel 0 1 192 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new brush that paints a single pixel of the indicated color on a</span>
 <span class="s0">* border, or paints a solid color in an interior.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">static PointerTo&lt; PNMBrush &gt; PNMBrush::make_pixel(LColorf const &amp;color, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend);</span>

<span class="s0">541 9 make_spot 0 4 705 19 PNMBrush::make_spot 0 1 193 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new brush that paints a spot of the indicated color and radius.</span>
 <span class="s0">* If fuzzy is true, the spot is fuzzy; otherwise, it is hard-edged.</span>
 <span class="s0">*/</span>
<span class="s0">150</span>
<span class="s0">static PointerTo&lt; PNMBrush &gt; PNMBrush::make_spot(LColorf const &amp;color, float radius, bool fuzzy, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend);</span>

<span class="s0">542 10 make_image 0 4 705 20 PNMBrush::make_image 0 1 194 244</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new brush that paints with the indicated image.  xc and yc</span>
 <span class="s0">* indicate the pixel in the center of the brush.</span>
 <span class="s0">*</span>
 <span class="s0">* The brush makes a copy of the image; it is safe to deallocate or modify the</span>
 <span class="s0">* image after making this call.</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">static PointerTo&lt; PNMBrush &gt; PNMBrush::make_image(PNMImage const &amp;image, float xc, float yc, PNMBrush::BrushEffect effect = ::PNMBrush::BE_blend);</span>

<span class="s0">543 8 PNMImage 0 260 708 18 PNMImage::PNMImage 0 4 195 196 197 198 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">335</span>
<span class="s0">inline PNMImage::PNMImage(void);</span>
<span class="s0">explicit PNMImage::PNMImage(Filename const &amp;filename, PNMFileType *type = nullptr);</span>
<span class="s0">inline explicit PNMImage::PNMImage(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = nullptr, ColorSpace color_space = ::CS_linear);</span>
<span class="s0">inline PNMImage::PNMImage(PNMImage const &amp;copy);</span>

<span class="s0">544 10 operator = 0 4 708 20 PNMImage::operator = 0 1 199 0</span>
<span class="s0">55</span>
<span class="s0">inline void PNMImage::operator =(PNMImage const &amp;copy);</span>

<span class="s0">545 9 ~PNMImage 0 516 708 19 PNMImage::~PNMImage 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">inline PNMImage::~PNMImage(void);</span>

<span class="s0">546 9 clamp_val 0 4 708 19 PNMImage::clamp_val 0 1 200 65</span>
<span class="s0">/**</span>
 <span class="s0">* A handy function to clamp values to [0..get_maxval()].</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline xelval PNMImage::clamp_val(int input_value) const;</span>

<span class="s0">547 6 to_val 0 4 708 16 PNMImage::to_val 0 2 201 202 288</span>
<span class="s0">/**</span>
 <span class="s0">* A handy function to scale non-alpha values from [0..1] to</span>
 <span class="s0">* [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* A handy function to scale non-alpha values from [0..1] to</span>
 <span class="s0">* [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">inline xel PNMImage::to_val(LRGBColorf const &amp;input_value) const;</span>
<span class="s0">inline xelval PNMImage::to_val(float input_value) const;</span>

<span class="s0">548 12 to_alpha_val 0 4 708 22 PNMImage::to_alpha_val 0 1 203 83</span>
<span class="s0">/**</span>
 <span class="s0">* A handy function to scale alpha values from [0..1] to [0..get_maxval()].</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline xelval PNMImage::to_alpha_val(float input_value) const;</span>

<span class="s0">549 8 from_val 0 4 708 18 PNMImage::from_val 0 2 204 205 292</span>
<span class="s0">/**</span>
 <span class="s0">* A handy function to scale non-alpha values from [0..get_maxval()] to</span>
 <span class="s0">* [0..1].  Do not use this for alpha values, see from_alpha_val.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* A handy function to scale non-alpha values from [0..get_maxval()] to</span>
 <span class="s0">* [0..1].  Do not use this for alpha values, see from_alpha_val.</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">inline LRGBColorf PNMImage::from_val(xel const &amp;input_value) const;</span>
<span class="s0">inline float PNMImage::from_val(xelval input_value) const;</span>

<span class="s0">550 14 from_alpha_val 0 4 708 24 PNMImage::from_alpha_val 0 1 206 83</span>
<span class="s0">/**</span>
 <span class="s0">* A handy function to scale alpha values from [0..get_maxval()] to [0..1].</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline float PNMImage::from_alpha_val(xelval input_value) const;</span>

<span class="s0">551 5 clear 0 4 708 15 PNMImage::clear 0 2 207 208 226</span>
<span class="s0">/**</span>
 <span class="s0">* Frees all memory allocated for the image, and clears all its parameters</span>
 <span class="s0">* (size, color, type, etc).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of clear() reinitializes the image to an empty (black) image</span>
 <span class="s0">* with the given dimensions.</span>
 <span class="s0">*/</span>
<span class="s0">183</span>
<span class="s0">void PNMImage::clear(void);</span>
<span class="s0">void PNMImage::clear(int x_size, int y_size, int num_channels = 3, xelval maxval = 255, PNMFileType *type = nullptr, ColorSpace color_space = ::CS_linear);</span>

<span class="s0">552 9 copy_from 0 4 708 19 PNMImage::copy_from 0 1 209 61</span>
<span class="s0">/**</span>
 <span class="s0">* Makes this image become a copy of the other image.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void PNMImage::copy_from(PNMImage const &amp;copy);</span>

<span class="s0">553 12 copy_channel 0 4 708 22 PNMImage::copy_channel 0 2 210 211 227</span>
<span class="s0">/**</span>
 <span class="s0">* Copies a channel from one image into another.  Images must be the same size</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Copies just a single channel from the source image into a single channel of</span>
 <span class="s0">* this image, leaving the remaining channels alone.</span>
 <span class="s0">*/</span>
<span class="s0">242</span>
<span class="s0">void PNMImage::copy_channel(PNMImage const &amp;copy, int src_channel, int dest_channel);</span>
<span class="s0">void PNMImage::copy_channel(PNMImage const &amp;copy, int xto, int yto, int cto, int xfrom = 0, int yfrom = 0, int cfrom = 0, int x_size = -1, int y_size = -1);</span>

<span class="s0">554 17 copy_channel_bits 0 4 708 27 PNMImage::copy_channel_bits 0 1 212 247</span>
<span class="s0">/**</span>
 <span class="s0">* Copies some subset of the bits of the specified channel from one image into</span>
 <span class="s0">* some subset of the bits of the specified channel in another image.  Images</span>
 <span class="s0">* must be the same size.</span>
 <span class="s0">*</span>
 <span class="s0">* If right_shift is negative, it means a left shift.</span>
 <span class="s0">*/</span>
<span class="s0">124</span>
<span class="s0">void PNMImage::copy_channel_bits(PNMImage const &amp;copy, int src_channel, int dest_channel, xelval src_mask, int right_shift);</span>

<span class="s0">555 16 copy_header_from 0 4 708 26 PNMImage::copy_header_from 0 1 213 186</span>
<span class="s0">/**</span>
 <span class="s0">* Copies just the header information into this image.  This will blow away</span>
 <span class="s0">* any image data stored in the image.  The new image data will be allocated,</span>
 <span class="s0">* but left unitialized.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void PNMImage::copy_header_from(PNMImageHeader const &amp;header);</span>

<span class="s0">556 9 take_from 0 4 708 19 PNMImage::take_from 0 1 214 92</span>
<span class="s0">/**</span>
 <span class="s0">* Move the contents of the other image into this one, and empty the other</span>
 <span class="s0">* image.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void PNMImage::take_from(PNMImage &amp;orig);</span>

<span class="s0">557 4 fill 0 4 708 14 PNMImage::fill 0 2 215 216 173</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the entire image (except the alpha channel) to the given color.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the entire image (except the alpha channel) to the given grayscale</span>
 <span class="s0">* level.</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">inline void PNMImage::fill(float red, float green, float blue);</span>
<span class="s0">inline void PNMImage::fill(float gray = 0.0);</span>

<span class="s0">558 8 fill_val 0 4 708 18 PNMImage::fill_val 0 2 217 218 173</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the entire image (except the alpha channel) to the given grayscale</span>
 <span class="s0">* level.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the entire image (except the alpha channel) to the given color.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">void PNMImage::fill_val(xelval red, xelval green, xelval blue);</span>
<span class="s0">inline void PNMImage::fill_val(xelval gray = 0);</span>

<span class="s0">559 10 alpha_fill 0 4 708 20 PNMImage::alpha_fill 0 1 219 60</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the entire alpha channel to the given level.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void PNMImage::alpha_fill(float alpha = 0.0);</span>

<span class="s0">560 14 alpha_fill_val 0 4 708 24 PNMImage::alpha_fill_val 0 1 220 60</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the entire alpha channel to the given level.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void PNMImage::alpha_fill_val(xelval alpha = 0);</span>

<span class="s0">561 13 set_read_size 0 4 708 23 PNMImage::set_read_size 0 1 221 513</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the size to we'd like to scale the image upon reading it.  This</span>
 <span class="s0">* will affect the next call to read().  This is usually used to reduce the</span>
 <span class="s0">* image size, e.g.  for a thumbnail.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file type reader supports it (e.g.  JPEG), then this will scale the</span>
 <span class="s0">* image during the read operation, consequently reducing memory and CPU</span>
 <span class="s0">* utilization.  If the file type reader does not support it, this will load</span>
 <span class="s0">* the image normally, and them perform a linear scale after it has been</span>
 <span class="s0">* loaded.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PNMImage::set_read_size(int x_size, int y_size);</span>

<span class="s0">562 15 clear_read_size 0 4 708 25 PNMImage::clear_read_size 0 1 222 67</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of a previous call to set_read_size().</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void PNMImage::clear_read_size(void);</span>

<span class="s0">563 13 has_read_size 0 4 708 23 PNMImage::has_read_size 0 1 223 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if set_read_size() has been called.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool PNMImage::has_read_size(void) const;</span>

<span class="s0">564 15 get_read_x_size 0 4 708 25 PNMImage::get_read_x_size 0 1 224 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the requested x_size of the image if set_read_size() has been</span>
 <span class="s0">* called, or the image x_size otherwise (if it is known).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int PNMImage::get_read_x_size(void) const;</span>

<span class="s0">565 15 get_read_y_size 0 4 708 25 PNMImage::get_read_y_size 0 1 225 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the requested y_size of the image if set_read_size() has been</span>
 <span class="s0">* called, or the image y_size otherwise (if it is known).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int PNMImage::get_read_y_size(void) const;</span>

<span class="s0">566 15 get_color_space 0 4 708 25 PNMImage::get_color_space 0 1 226 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color space in which the image is encoded.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline ColorSpace PNMImage::get_color_space(void) const;</span>

<span class="s0">567 4 read 0 4 708 14 PNMImage::read 0 3 227 228 229 930</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the indicated image filename.  If type is non-NULL, it is a</span>
 <span class="s0">* suggestion for the type of file it is.  Returns true if successful, false</span>
 <span class="s0">* on error.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads the image data from the indicated stream.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is advisory only, and may be used to suggest a type if it has</span>
 <span class="s0">* a known extension.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the type of file it is (and a</span>
 <span class="s0">* non-NULL type will override any magic number test or filename extension</span>
 <span class="s0">* lookup).</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false on error.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of read() uses an already-existing PNMReader to read the image</span>
 <span class="s0">* file.  You can get a reader via the PNMImageHeader::make_reader() methods.</span>
 <span class="s0">* This is a good way to examine the header of a file (for instance, to</span>
 <span class="s0">* determine its size) before actually reading the entire image.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMReader is always deleted upon completion, whether successful or not.</span>
 <span class="s0">*/</span>
<span class="s0">291</span>
<span class="s0">bool PNMImage::read(Filename const &amp;filename, PNMFileType *type = nullptr, bool report_unknown_type = true);</span>
<span class="s0">bool PNMImage::read(std::istream &amp;data, std::string const &amp;filename = string(), PNMFileType *type = nullptr, bool report_unknown_type = true);</span>
<span class="s0">bool PNMImage::read(PNMReader *reader);</span>

<span class="s0">568 5 write 0 4 708 15 PNMImage::write 0 3 230 231 232 628</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the image to the indicated filename.  If type is non-NULL, it is a</span>
 <span class="s0">* suggestion for the type of image file to write.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes the image to the indicated ostream.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is advisory only, and may be used suggest a type if it has a</span>
 <span class="s0">* known extension.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the type of image file to</span>
 <span class="s0">* write.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of write() uses an already-existing PNMWriter to write the</span>
 <span class="s0">* image file.  You can get a writer via the PNMImageHeader::make_writer()</span>
 <span class="s0">* methods.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMWriter is always deleted upon completion, whether successful or not.</span>
 <span class="s0">*/</span>
<span class="s0">246</span>
<span class="s0">bool PNMImage::write(Filename const &amp;filename, PNMFileType *type = nullptr) const;</span>
<span class="s0">bool PNMImage::write(std::ostream &amp;data, std::string const &amp;filename = string(), PNMFileType *type = nullptr) const;</span>
<span class="s0">bool PNMImage::write(PNMWriter *writer) const;</span>

<span class="s0">569 8 is_valid 0 4 708 18 PNMImage::is_valid 0 1 233 218</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the image has been read in or correctly initialized with a</span>
 <span class="s0">* height and width.  If this returns false, virtually all member functions</span>
 <span class="s0">* except clear() and read() are invalid function calls.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool PNMImage::is_valid(void) const;</span>

<span class="s0">570 16 set_num_channels 0 4 708 26 PNMImage::set_num_channels 0 1 234 257</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the number of channels associated with the image.  The new number</span>
 <span class="s0">* of channels must be an integer in the range 1 through 4, inclusive.  This</span>
 <span class="s0">* will allocate and/or deallocate memory as necessary to accommodate; see</span>
 <span class="s0">* set_color_type().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void PNMImage::set_num_channels(int num_channels);</span>

<span class="s0">571 14 set_color_type 0 4 708 24 PNMImage::set_color_type 0 1 235 319</span>
<span class="s0">/**</span>
 <span class="s0">* Translates the image to or from grayscale, color, or four-color mode.</span>
 <span class="s0">* Grayscale images are converted to full-color images with R, G, B set to the</span>
 <span class="s0">* original gray level; color images are converted to grayscale according to</span>
 <span class="s0">* the value of Bright().  The alpha channel, if added, is initialized to</span>
 <span class="s0">* zero.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void PNMImage::set_color_type(PNMImageHeader::ColorType color_type);</span>

<span class="s0">572 15 set_color_space 0 4 708 25 PNMImage::set_color_space 0 1 236 634</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the colors in the image to the indicated color space.  This may be</span>
 <span class="s0">* a lossy operation, in particular when going from sRGB to linear.  The alpha</span>
 <span class="s0">* channel remains untouched.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that, because functions like get_xel() and set_xel() work on</span>
 <span class="s0">* linearized floating-point values, this conversion won't affect those values</span>
 <span class="s0">* (aside from some minor discrepancies due to storage precision).  It does</span>
 <span class="s0">* affect the values used by get_xel_val() and set_xel_val(), though, since</span>
 <span class="s0">* those operate on encoded colors.</span>
 <span class="s0">*</span>
 <span class="s0">* Some color spaces, particularly scRGB, may enforce the use of a particular</span>
 <span class="s0">* maxval setting.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void PNMImage::set_color_space(ColorSpace color_space);</span>

<span class="s0">573 9 add_alpha 0 4 708 19 PNMImage::add_alpha 0 1 237 126</span>
<span class="s0">/**</span>
 <span class="s0">* Adds an alpha channel to the image, if it does not already have one.  The</span>
 <span class="s0">* alpha channel is initialized to zeros.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline void PNMImage::add_alpha(void);</span>

<span class="s0">574 12 remove_alpha 0 4 708 22 PNMImage::remove_alpha 0 1 238 59</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the image's alpha channel, if it exists.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void PNMImage::remove_alpha(void);</span>

<span class="s0">575 14 make_grayscale 0 4 708 24 PNMImage::make_grayscale 0 2 239 240 337</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the image from RGB to grayscale.  Any alpha channel, if present,</span>
 <span class="s0">* is left undisturbed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Converts the image from RGB to grayscale.  Any alpha channel, if present,</span>
 <span class="s0">* is left undisturbed.  The optional rc, gc, bc values represent the relative</span>
 <span class="s0">* weights to apply to each channel to convert it to grayscale.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">inline void PNMImage::make_grayscale(void);</span>
<span class="s0">void PNMImage::make_grayscale(float rc, float gc, float bc);</span>

<span class="s0">576 8 make_rgb 0 4 708 18 PNMImage::make_rgb 0 1 241 108</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the image from grayscale to RGB.  Any alpha channel, if present,</span>
 <span class="s0">* is left undisturbed.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline void PNMImage::make_rgb(void);</span>

<span class="s0">577 17 premultiply_alpha 0 4 708 27 PNMImage::premultiply_alpha 0 1 242 234</span>
<span class="s0">/**</span>
 <span class="s0">* Converts an image in-place to its &quot;premultiplied&quot; form, where, for every</span>
 <span class="s0">* pixel in the image, the red, green, and blue components are multiplied by</span>
 <span class="s0">* that pixel's alpha value.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not modify any alpha values.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void PNMImage::premultiply_alpha(void);</span>

<span class="s0">578 19 unpremultiply_alpha 0 4 708 29 PNMImage::unpremultiply_alpha 0 1 243 273</span>
<span class="s0">/**</span>
 <span class="s0">* Converts an image in-place to its &quot;straight alpha&quot; form (presumably from a</span>
 <span class="s0">* &quot;premultiplied&quot; form), where, for every pixel in the image, the red, green,</span>
 <span class="s0">* and blue components are divided by that pixel's alpha value.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not modify any alpha values.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void PNMImage::unpremultiply_alpha(void);</span>

<span class="s0">579 12 reverse_rows 0 4 708 22 PNMImage::reverse_rows 0 1 244 61</span>
<span class="s0">/**</span>
 <span class="s0">* Performs an in-place reversal of the row (y) data.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void PNMImage::reverse_rows(void);</span>

<span class="s0">580 4 flip 0 4 708 14 PNMImage::flip 0 1 245 369</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses, transposes, and/or rotates the image in-place according to the</span>
 <span class="s0">* specified parameters.  If flip_x is true, the x axis is reversed; if flip_y</span>
 <span class="s0">* is true, the y axis is reversed.  Then, if transpose is true, the x and y</span>
 <span class="s0">* axes are exchanged.  These parameters can be used to select any combination</span>
 <span class="s0">* of 90-degree or 180-degree rotations and flips.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void PNMImage::flip(bool flip_x, bool flip_y, bool transpose);</span>

<span class="s0">581 10 set_maxval 0 4 708 20 PNMImage::set_maxval 0 1 246 54</span>
<span class="s0">/**</span>
 <span class="s0">* Rescales the image to the indicated maxval.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void PNMImage::set_maxval(xelval maxval);</span>

<span class="s0">582 11 get_xel_val 0 4 708 21 PNMImage::get_xel_val 0 2 247 248 206</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the RGB color at the indicated pixel.  Each component is in the</span>
 <span class="s0">* range 0..maxval.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the RGB color at the indicated pixel.  Each component is in the</span>
 <span class="s0">* range 0..maxval.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline xel &amp;PNMImage::get_xel_val(int x, int y);</span>
<span class="s0">inline xel PNMImage::get_xel_val(int x, int y) const;</span>

<span class="s0">583 11 set_xel_val 0 4 708 21 PNMImage::set_xel_val 0 3 249 250 251 740</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the RGB color at the indicated pixel.  Each component is in the</span>
 <span class="s0">* range 0..maxval, encoded in the configured color space.  See set_xel if you</span>
 <span class="s0">* instead have a linearized and normalized floating-point value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes the RGB color at the indicated pixel.  Each component is in the</span>
 <span class="s0">* range 0..maxval, encoded in the configured color space.  See set_xel if you</span>
 <span class="s0">* instead have a linearized and normalized floating-point value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes all three color components at the indicated pixel to the same</span>
 <span class="s0">* value.  The value is in the range component is in the range 0..maxval,</span>
 <span class="s0">* encoded in the configured color space.  See set_xel if you instead have a</span>
 <span class="s0">* linearized and normalized floating-point value.</span>
 <span class="s0">*/</span>
<span class="s0">207</span>
<span class="s0">inline void PNMImage::set_xel_val(int x, int y, xel const &amp;value);</span>
<span class="s0">inline void PNMImage::set_xel_val(int x, int y, xelval r, xelval g, xelval b);</span>
<span class="s0">inline void PNMImage::set_xel_val(int x, int y, xelval gray);</span>

<span class="s0">584 11 get_red_val 0 4 708 21 PNMImage::get_red_val 0 1 252 158</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the red component color at the indicated pixel.  The value returned</span>
 <span class="s0">* is in the range 0..maxval and encoded in the configured color space.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline xelval PNMImage::get_red_val(int x, int y) const;</span>

<span class="s0">585 13 get_green_val 0 4 708 23 PNMImage::get_green_val 0 1 253 163</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the green component color at the indicated pixel.  The value</span>
 <span class="s0">* returned is in the range 0..maxval and encoded in the configured color</span>
 <span class="s0">* space.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline xelval PNMImage::get_green_val(int x, int y) const;</span>

<span class="s0">586 12 get_blue_val 0 4 708 22 PNMImage::get_blue_val 0 1 254 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the blue component color at the indicated pixel.  The value</span>
 <span class="s0">* returned is in the range 0..maxval and encoded in the configured color</span>
 <span class="s0">* space.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline xelval PNMImage::get_blue_val(int x, int y) const;</span>

<span class="s0">587 12 get_gray_val 0 4 708 22 PNMImage::get_gray_val 0 1 255 342</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the gray component color at the indicated pixel.  This only has a</span>
 <span class="s0">* meaningful value for grayscale images; for other image types, this returns</span>
 <span class="s0">* the value of the blue channel only.  However, also see the get_bright()</span>
 <span class="s0">* function.  The value returned is in the range 0..maxval and encoded in the</span>
 <span class="s0">* configured color space.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline xelval PNMImage::get_gray_val(int x, int y) const;</span>

<span class="s0">588 13 get_alpha_val 0 4 708 23 PNMImage::get_alpha_val 0 1 256 196</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alpha component color at the indicated pixel.  It is an error</span>
 <span class="s0">* to call this unless has_alpha() is true.  The value returned is in the</span>
 <span class="s0">* range 0..maxval and always linear.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline xelval PNMImage::get_alpha_val(int x, int y) const;</span>

<span class="s0">589 11 set_red_val 0 4 708 21 PNMImage::set_red_val 0 1 257 249</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the red component color only at the indicated pixel.  The value given</span>
 <span class="s0">* should be in the range 0..maxval, encoded in the configured color space.</span>
 <span class="s0">* See set_red if you instead have a linearized and normalized floating-point</span>
 <span class="s0">* value.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void PNMImage::set_red_val(int x, int y, xelval r);</span>

<span class="s0">590 13 set_green_val 0 4 708 23 PNMImage::set_green_val 0 1 258 254</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the green component color only at the indicated pixel.  The value</span>
 <span class="s0">* given should be in the range 0..maxval, encoded in the configured color</span>
 <span class="s0">* space.  See set_green if you instead have a linearized and normalized</span>
 <span class="s0">* floating-point value.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PNMImage::set_green_val(int x, int y, xelval g);</span>

<span class="s0">591 12 set_blue_val 0 4 708 22 PNMImage::set_blue_val 0 1 259 251</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the blue component color only at the indicated pixel.  The value given</span>
 <span class="s0">* should be in the range 0..maxval, encoded in the configured color space.</span>
 <span class="s0">* See set_blue if you instead have a linearized and normalized floating-point</span>
 <span class="s0">* value.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void PNMImage::set_blue_val(int x, int y, xelval b);</span>

<span class="s0">592 12 set_gray_val 0 4 708 22 PNMImage::set_gray_val 0 1 260 530</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the gray component color at the indicated pixel.  This is only</span>
 <span class="s0">* meaningful for grayscale images; for other image types, this simply sets</span>
 <span class="s0">* the blue component color.  However, also see set_xel_val(), which can set</span>
 <span class="s0">* all the component colors to the same grayscale level, and hence works</span>
 <span class="s0">* correctly both for grayscale and color images.  The value given should be</span>
 <span class="s0">* in the range 0..maxval, encoded in the configured color space.  See</span>
 <span class="s0">* set_gray if you instead have a linearized normalized floating-point value.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void PNMImage::set_gray_val(int x, int y, xelval gray);</span>

<span class="s0">593 13 set_alpha_val 0 4 708 23 PNMImage::set_alpha_val 0 1 261 282</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the alpha component color only at the indicated pixel.  It is an error</span>
 <span class="s0">* to call this unless has_alpha() is true.  The value given should be in the</span>
 <span class="s0">* range 0..maxval.</span>
 <span class="s0">*</span>
 <span class="s0">* This value is always linearly encoded, even if the image is set to the sRGB</span>
 <span class="s0">* color space.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PNMImage::set_alpha_val(int x, int y, xelval a);</span>

<span class="s0">594 15 get_channel_val 0 4 708 25 PNMImage::get_channel_val 0 1 262 326</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth component color at the indicated pixel.  The channel index</span>
 <span class="s0">* should be in the range 0..(get_num_channels()-1).  The channels are ordered</span>
 <span class="s0">* B, G, R, A.  This is slightly less optimal than accessing the component</span>
 <span class="s0">* values directly by named methods.  The value returned is in the range</span>
 <span class="s0">* 0..maxval.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">xelval PNMImage::get_channel_val(int x, int y, int channel) const;</span>

<span class="s0">595 15 set_channel_val 0 4 708 25 PNMImage::set_channel_val 0 1 263 325</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth component color at the indicated pixel.  The channel index</span>
 <span class="s0">* should be in the range 0..(get_num_channels()-1).  The channels are ordered</span>
 <span class="s0">* B, G, R, A.  This is slightly less optimal than setting the component</span>
 <span class="s0">* values directly by named methods.  The value given should be in the range</span>
 <span class="s0">* 0..maxval.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void PNMImage::set_channel_val(int x, int y, int channel, xelval value);</span>

<span class="s0">596 11 get_channel 0 4 708 21 PNMImage::get_channel 0 1 264 329</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth component color at the indicated pixel.  The channel index</span>
 <span class="s0">* should be in the range 0..(get_num_channels()-1).  The channels are ordered</span>
 <span class="s0">* B, G, R, A.  This is slightly less optimal than accessing the component</span>
 <span class="s0">* values directly by named methods.  The value returned is a float in the</span>
 <span class="s0">* range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">float PNMImage::get_channel(int x, int y, int channel) const;</span>

<span class="s0">597 11 set_channel 0 4 708 21 PNMImage::set_channel 0 1 265 328</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth component color at the indicated pixel.  The channel index</span>
 <span class="s0">* should be in the range 0..(get_num_channels()-1).  The channels are ordered</span>
 <span class="s0">* B, G, R, A.  This is slightly less optimal than setting the component</span>
 <span class="s0">* values directly by named methods.  The value given should be a float in the</span>
 <span class="s0">* range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void PNMImage::set_channel(int x, int y, int channel, float value);</span>

<span class="s0">598 9 get_pixel 0 4 708 19 PNMImage::get_pixel 0 1 266 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the (r, g, b, a) pixel value at the indicated pixel, using a</span>
 <span class="s0">* PixelSpec object.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">PNMImageHeader::PixelSpec PNMImage::get_pixel(int x, int y) const;</span>

<span class="s0">599 9 set_pixel 0 4 708 19 PNMImage::set_pixel 0 1 267 97</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the (r, g, b, a) pixel value at the indicated pixel, using a PixelSpec</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void PNMImage::set_pixel(int x, int y, PNMImageHeader::PixelSpec const &amp;pixel);</span>

<span class="s0">600 7 get_xel 0 4 708 17 PNMImage::get_xel 0 1 268 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the RGB color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LRGBColorf PNMImage::get_xel(int x, int y) const;</span>

<span class="s0">601 7 set_xel 0 4 708 17 PNMImage::set_xel 0 3 269 270 271 378</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the RGB color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes the RGB color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes all three color components at the indicated pixel to the same</span>
 <span class="s0">* value.  The value is a linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">198</span>
<span class="s0">inline void PNMImage::set_xel(int x, int y, LRGBColorf const &amp;value);</span>
<span class="s0">inline void PNMImage::set_xel(int x, int y, float r, float g, float b);</span>
<span class="s0">inline void PNMImage::set_xel(int x, int y, float gray);</span>

<span class="s0">602 9 get_xel_a 0 4 708 19 PNMImage::get_xel_a 0 1 272 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the RGBA color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LColorf PNMImage::get_xel_a(int x, int y) const;</span>

<span class="s0">603 9 set_xel_a 0 4 708 19 PNMImage::set_xel_a 0 2 273 274 236</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the RGBA color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes the RGBA color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">151</span>
<span class="s0">inline void PNMImage::set_xel_a(int x, int y, LColorf const &amp;value);</span>
<span class="s0">inline void PNMImage::set_xel_a(int x, int y, float r, float g, float b, float a);</span>

<span class="s0">604 7 get_red 0 4 708 17 PNMImage::get_red 0 1 275 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the red component color at the indicated pixel.  The value returned</span>
 <span class="s0">* is a linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline float PNMImage::get_red(int x, int y) const;</span>

<span class="s0">605 9 get_green 0 4 708 19 PNMImage::get_green 0 1 276 132</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the green component color at the indicated pixel.  The value</span>
 <span class="s0">* returned is a linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline float PNMImage::get_green(int x, int y) const;</span>

<span class="s0">606 8 get_blue 0 4 708 18 PNMImage::get_blue 0 1 277 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the blue component color at the indicated pixel.  The value</span>
 <span class="s0">* returned is a linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline float PNMImage::get_blue(int x, int y) const;</span>

<span class="s0">607 8 get_gray 0 4 708 18 PNMImage::get_gray 0 1 278 311</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the gray component color at the indicated pixel.  This only has a</span>
 <span class="s0">* meaningful value for grayscale images; for other image types, this returns</span>
 <span class="s0">* the value of the blue channel only.  However, also see the get_bright()</span>
 <span class="s0">* function.  The value returned is a linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline float PNMImage::get_gray(int x, int y) const;</span>

<span class="s0">608 9 get_alpha 0 4 708 19 PNMImage::get_alpha 0 1 279 181</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alpha component color at the indicated pixel.  It is an error</span>
 <span class="s0">* to call this unless has_alpha() is true.  The value returned is a float in</span>
 <span class="s0">* the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline float PNMImage::get_alpha(int x, int y) const;</span>

<span class="s0">609 7 set_red 0 4 708 17 PNMImage::set_red 0 1 280 136</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the red component color only at the indicated pixel.  The value given</span>
 <span class="s0">* should be a linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void PNMImage::set_red(int x, int y, float r);</span>

<span class="s0">610 9 set_green 0 4 708 19 PNMImage::set_green 0 1 281 138</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the green component color only at the indicated pixel.  The value</span>
 <span class="s0">* given should be a linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void PNMImage::set_green(int x, int y, float g);</span>

<span class="s0">611 8 set_blue 0 4 708 18 PNMImage::set_blue 0 1 282 137</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the blue component color only at the indicated pixel.  The value given</span>
 <span class="s0">* should be a linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void PNMImage::set_blue(int x, int y, float b);</span>

<span class="s0">612 8 set_gray 0 4 708 18 PNMImage::set_gray 0 1 283 418</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the gray component color at the indicated pixel.  This is only</span>
 <span class="s0">* meaningful for grayscale images; for other image types, this simply sets</span>
 <span class="s0">* the blue component color.  However, also see set_xel(), which can set all</span>
 <span class="s0">* the component colors to the same grayscale level, and hence works correctly</span>
 <span class="s0">* both for grayscale and color images.  The value given should be a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void PNMImage::set_gray(int x, int y, float gray);</span>

<span class="s0">613 9 set_alpha 0 4 708 19 PNMImage::set_alpha 0 1 284 179</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the alpha component color only at the indicated pixel.  It is an error</span>
 <span class="s0">* to call this unless has_alpha() is true.  The value given should be in the</span>
 <span class="s0">* range 0..1.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void PNMImage::set_alpha(int x, int y, float a);</span>

<span class="s0">614 10 get_bright 0 4 708 20 PNMImage::get_bright 0 3 285 286 287 660</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the linear brightness of the given xel, as a linearized float in</span>
 <span class="s0">* the range 0..1.  This flavor of get_bright() returns the correct grayscale</span>
 <span class="s0">* brightness level for both full-color and grayscale images.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of get_bright() works correctly only for color images.  It</span>
 <span class="s0">* returns a single brightness value for the RGB color at the indicated pixel,</span>
 <span class="s0">* based on the supplied weights for each component.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of get_bright() works correctly only for four-channel images.</span>
 <span class="s0">* It returns a single brightness value for the RGBA color at the indicated</span>
 <span class="s0">* pixel, based on the supplied weights for each component.</span>
 <span class="s0">*/</span>
<span class="s0">234</span>
<span class="s0">inline float PNMImage::get_bright(int x, int y) const;</span>
<span class="s0">inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc) const;</span>
<span class="s0">inline float PNMImage::get_bright(int x, int y, float rc, float gc, float bc, float ac) const;</span>

<span class="s0">615 5 blend 0 4 708 15 PNMImage::blend 0 2 288 289 554</span>
<span class="s0">/**</span>
 <span class="s0">* Smoothly blends the indicated pixel value in with whatever was already in</span>
 <span class="s0">* the image, based on the given alpha value.  An alpha of 1.0 is fully opaque</span>
 <span class="s0">* and completely replaces whatever was there previously; alpha of 0.0 is</span>
 <span class="s0">* fully transparent and does nothing.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Smoothly blends the indicated pixel value in with whatever was already in</span>
 <span class="s0">* the image, based on the given alpha value.  An alpha of 1.0 is fully opaque</span>
 <span class="s0">* and completely replaces whatever was there previously; alpha of 0.0 is</span>
 <span class="s0">* fully transparent and does nothing.</span>
 <span class="s0">*/</span>
<span class="s0">154</span>
<span class="s0">inline void PNMImage::blend(int x, int y, LRGBColorf const &amp;val, float alpha);</span>
<span class="s0">void PNMImage::blend(int x, int y, float r, float g, float b, float alpha);</span>

<span class="s0">616 14 copy_sub_image 0 4 708 24 PNMImage::copy_sub_image 0 1 290 344</span>
<span class="s0">/**</span>
 <span class="s0">* Copies a rectangular area of another image into a rectangular area of this</span>
 <span class="s0">* image.  Both images must already have been initialized.  The upper-left</span>
 <span class="s0">* corner of the region in both images is specified, and the size of the area;</span>
 <span class="s0">* if the size is omitted, it defaults to the entire other image, or the</span>
 <span class="s0">* largest piece that will fit.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">void PNMImage::copy_sub_image(PNMImage const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1);</span>

<span class="s0">617 15 blend_sub_image 0 4 708 25 PNMImage::blend_sub_image 0 1 291 438</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the alpha channel of the copy is used</span>
 <span class="s0">* to blend the copy into the destination image, instead of overwriting pixels</span>
 <span class="s0">* unconditionally.</span>
 <span class="s0">*</span>
 <span class="s0">* If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*</span>
 <span class="s0">* value of the source image before applying it to the target image.</span>
 <span class="s0">*</span>
 <span class="s0">* If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates</span>
 <span class="s0">* into copy_sub_image().</span>
 <span class="s0">*/</span>
<span class="s0">160</span>
<span class="s0">void PNMImage::blend_sub_image(PNMImage const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0);</span>

<span class="s0">618 13 add_sub_image 0 4 708 23 PNMImage::add_sub_image 0 1 292 228</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are added to the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">* Unlike blend_sub_image(), the alpha channel is not treated specially.</span>
 <span class="s0">*/</span>
<span class="s0">158</span>
<span class="s0">void PNMImage::add_sub_image(PNMImage const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0);</span>

<span class="s0">619 14 mult_sub_image 0 4 708 24 PNMImage::mult_sub_image 0 1 293 233</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are multiplied to the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">* Unlike blend_sub_image(), the alpha channel is not treated specially.</span>
 <span class="s0">*/</span>
<span class="s0">159</span>
<span class="s0">void PNMImage::mult_sub_image(PNMImage const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0);</span>

<span class="s0">620 16 darken_sub_image 0 4 708 26 PNMImage::darken_sub_image 0 1 294 437</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like copy_sub_image(), but the resulting color will be the darker</span>
 <span class="s0">* of the source and destination colors at each pixel (and at each R, G, B, A</span>
 <span class="s0">* component value).</span>
 <span class="s0">*</span>
 <span class="s0">* If pixel_scale is not 1.0, it specifies an amount to scale each pixel value</span>
 <span class="s0">* of the source image before applying it to the target image.  The scale is</span>
 <span class="s0">* applied with the center at 1.0: scaling the pixel value smaller brings it</span>
 <span class="s0">* closer to 1.0.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">void PNMImage::darken_sub_image(PNMImage const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0);</span>

<span class="s0">621 17 lighten_sub_image 0 4 708 27 PNMImage::lighten_sub_image 0 1 295 329</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like copy_sub_image(), but the resulting color will be the lighter</span>
 <span class="s0">* of the source and destination colors at each pixel (and at each R, G, B, A</span>
 <span class="s0">* component value).</span>
 <span class="s0">*</span>
 <span class="s0">* If pixel_scale is not 1.0, it specifies an amount to scale each pixel value</span>
 <span class="s0">* of the source image before applying it to the target image.</span>
 <span class="s0">*/</span>
<span class="s0">162</span>
<span class="s0">void PNMImage::lighten_sub_image(PNMImage const &amp;copy, int xto, int yto, int xfrom = 0, int yfrom = 0, int x_size = -1, int y_size = -1, float pixel_scale = 1.0);</span>

<span class="s0">622 9 threshold 0 4 708 19 PNMImage::threshold 0 1 296 620</span>
<span class="s0">/**</span>
 <span class="s0">* Selectively copies each pixel from either one source or another source,</span>
 <span class="s0">* depending on the pixel value of the indicated channel of select_image.</span>
 <span class="s0">*</span>
 <span class="s0">* For each pixel (x, y):</span>
 <span class="s0">*</span>
 <span class="s0">* s = select_image.get_channel(x, y, channel). Set this image's (x, y) to:</span>
 <span class="s0">*</span>
 <span class="s0">* lt.get_xel(x, y) if s &lt; threshold, or</span>
 <span class="s0">*</span>
 <span class="s0">* ge.get_xel(x, y) if s &gt;= threshold</span>
 <span class="s0">*</span>
 <span class="s0">* Any of select_image, lt, or ge may be the same PNMImge object as this</span>
 <span class="s0">* image, or the same as each other; or they may all be different.  All images</span>
 <span class="s0">* must be the same size.  As a special case, lt and ge may both be 1x1 images</span>
 <span class="s0">* instead of the source image size.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">void PNMImage::threshold(PNMImage const &amp;select_image, int channel, float threshold, PNMImage const &amp;lt, PNMImage const &amp;ge);</span>

<span class="s0">623 20 fill_distance_inside 0 4 708 30 PNMImage::fill_distance_inside 0 1 297 790</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces this image with a grayscale image whose gray channel represents</span>
 <span class="s0">* the linear Manhattan distance from the nearest dark pixel in the given mask</span>
 <span class="s0">* image, up to the specified radius value (which also becomes the new</span>
 <span class="s0">* maxval).  radius may range from 0 to maxmaxval; smaller values will compute</span>
 <span class="s0">* faster.  A dark pixel is defined as one whose pixel value is &lt; threshold.</span>
 <span class="s0">*</span>
 <span class="s0">* If shrink_from_border is true, then the mask image is considered to be</span>
 <span class="s0">* surrounded by a border of dark pixels; otherwise, the border isn't</span>
 <span class="s0">* considered.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used, in conjunction with threshold, to shrink a mask image</span>
 <span class="s0">* inwards by a certain number of pixels.</span>
 <span class="s0">*</span>
 <span class="s0">* The mask image may be the same image as this one, in which case it is</span>
 <span class="s0">* destructively modified by this process.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">void PNMImage::fill_distance_inside(PNMImage const &amp;mask, float threshold, int radius, bool shrink_from_border);</span>

<span class="s0">624 21 fill_distance_outside 0 4 708 31 PNMImage::fill_distance_outside 0 1 298 630</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces this image with a grayscale image whose gray channel represents</span>
 <span class="s0">* the linear Manhattan distance from the nearest white pixel in the given</span>
 <span class="s0">* mask image, up to the specified radius value (which also becomes the new</span>
 <span class="s0">* maxval).  radius may range from 0 to maxmaxval; smaller values will compute</span>
 <span class="s0">* faster.  A white pixel is defined as one whose pixel value is &gt;= threshold.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used, in conjunction with threshold, to grow a mask image</span>
 <span class="s0">* outwards by a certain number of pixels.</span>
 <span class="s0">*</span>
 <span class="s0">* The mask image may be the same image as this one, in which case it is</span>
 <span class="s0">* destructively modified by this process.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">void PNMImage::fill_distance_outside(PNMImage const &amp;mask, float threshold, int radius);</span>

<span class="s0">625 18 indirect_1d_lookup 0 4 708 28 PNMImage::indirect_1d_lookup 0 1 299 557</span>
<span class="s0">/**</span>
 <span class="s0">* index_image is a WxH grayscale image, while pixel_values is an Nx1 color</span>
 <span class="s0">* (or grayscale) image.  Typically pixel_values will be a 256x1 image.</span>
 <span class="s0">*</span>
 <span class="s0">* Fills the PNMImage with a new image the same width and height as</span>
 <span class="s0">* index_image, with the same number of channels as pixel_values.</span>
 <span class="s0">*</span>
 <span class="s0">* Each pixel of the new image is computed with the formula:</span>
 <span class="s0">*</span>
 <span class="s0">* new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)</span>
 <span class="s0">*</span>
 <span class="s0">* At present, no interpolation is performed; the nearest value in</span>
 <span class="s0">* pixel_values is discovered.  This may change in the future.</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">void PNMImage::indirect_1d_lookup(PNMImage const &amp;index_image, int channel, PNMImage const &amp;pixel_values);</span>

<span class="s0">626 7 rescale 0 4 708 17 PNMImage::rescale 0 1 300 272</span>
<span class="s0">/**</span>
 <span class="s0">* Rescales the RGB channel values so that any values in the original image</span>
 <span class="s0">* between min_val and max_val are expanded to the range 0 .. 1.  Values below</span>
 <span class="s0">* min_val are set to 0, and values above max_val are set to 1. Does not</span>
 <span class="s0">* affect the alpha channel, if any.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void PNMImage::rescale(float min_val, float max_val);</span>

<span class="s0">627 11 render_spot 0 4 708 21 PNMImage::render_spot 0 1 301 450</span>
<span class="s0">/**</span>
 <span class="s0">* Renders a solid-color circle, with a fuzzy edge, into the center of the</span>
 <span class="s0">* PNMImage.  If the PNMImage is non-square, this actually renders an ellipse.</span>
 <span class="s0">*</span>
 <span class="s0">* The min_radius and max_radius are in the scale 0..1, where 1.0 means the</span>
 <span class="s0">* full width of the image.  If min_radius == max_radius, the edge is sharp</span>
 <span class="s0">* (but still antialiased); otherwise, the pixels between min_radius and</span>
 <span class="s0">* max_radius are smoothly blended between fg and bg colors.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">void PNMImage::render_spot(LColorf const &amp;fg, LColorf const &amp;bg, float min_radius, float max_radius);</span>

<span class="s0">628 13 expand_border 0 4 708 23 PNMImage::expand_border 0 1 302 198</span>
<span class="s0">/**</span>
 <span class="s0">* Expands the image by the indicated number of pixels on each edge.  The new</span>
 <span class="s0">* pixels are set to the indicated color.</span>
 <span class="s0">*</span>
 <span class="s0">* If any of the values is negative, this actually crops the image.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">void PNMImage::expand_border(int left, int right, int bottom, int top, LColorf const &amp;color);</span>

<span class="s0">629 10 box_filter 0 4 708 20 PNMImage::box_filter 0 1 303 154</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of box_filter() will apply the filter over the entire image</span>
 <span class="s0">* without resizing or copying; the effect is that of a blur operation.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void PNMImage::box_filter(float radius = 1.0);</span>

<span class="s0">630 15 gaussian_filter 0 4 708 25 PNMImage::gaussian_filter 0 1 304 159</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of gaussian_filter() will apply the filter over the entire</span>
 <span class="s0">* image without resizing or copying; the effect is that of a blur operation.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void PNMImage::gaussian_filter(float radius = 1.0);</span>

<span class="s0">631 23 unfiltered_stretch_from 0 4 708 33 PNMImage::unfiltered_stretch_from 0 1 305 99</span>
<span class="s0">/**</span>
 <span class="s0">* Resizes from the indicated image into this one by performing a nearest-</span>
 <span class="s0">* point sample.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void PNMImage::unfiltered_stretch_from(PNMImage const &amp;copy);</span>

<span class="s0">632 15 box_filter_from 0 4 708 25 PNMImage::box_filter_from 0 1 306 260</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a resized copy of the indicated image into this one using the</span>
 <span class="s0">* indicated filter.  The image to be copied is squashed and stretched to</span>
 <span class="s0">* match the dimensions of the current image, applying the appropriate filter</span>
 <span class="s0">* to perform the stretching.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void PNMImage::box_filter_from(float radius, PNMImage const &amp;copy);</span>

<span class="s0">633 20 gaussian_filter_from 0 4 708 30 PNMImage::gaussian_filter_from 0 1 307 260</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a resized copy of the indicated image into this one using the</span>
 <span class="s0">* indicated filter.  The image to be copied is squashed and stretched to</span>
 <span class="s0">* match the dimensions of the current image, applying the appropriate filter</span>
 <span class="s0">* to perform the stretching.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void PNMImage::gaussian_filter_from(float radius, PNMImage const &amp;copy);</span>

<span class="s0">634 17 quick_filter_from 0 4 708 27 PNMImage::quick_filter_from 0 1 308 415</span>
<span class="s0">/**</span>
 <span class="s0">* Resizes from the given image, with a fixed radius of 0.5. This is a very</span>
 <span class="s0">* specialized and simple algorithm that doesn't handle dropping below the</span>
 <span class="s0">* Nyquist rate very well, but is quite a bit faster than the more general</span>
 <span class="s0">* box_filter(), above.  If borders are specified, they will further restrict</span>
 <span class="s0">* the size of the resulting image.  There's no point in using</span>
 <span class="s0">* quick_box_filter() on a single image.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void PNMImage::quick_filter_from(PNMImage const &amp;copy, int xborder = 0, int yborder = 0);</span>

<span class="s0">635 14 make_histogram 0 4 708 24 PNMImage::make_histogram 0 1 309 64</span>
<span class="s0">/**</span>
 <span class="s0">* Computes a histogram of the colors used in the image.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void PNMImage::make_histogram(PNMImageHeader::Histogram &amp;hist);</span>

<span class="s0">636 8 quantize 0 4 708 18 PNMImage::quantize 0 1 310 284</span>
<span class="s0">/**</span>
 <span class="s0">* Reduces the number of unique colors in the image to (at most) the given</span>
 <span class="s0">* count.  Fewer colors than requested may be left in the image after this</span>
 <span class="s0">* operation, but never more.</span>
 <span class="s0">*</span>
 <span class="s0">* At present, this is only supported on images without an alpha channel.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.5</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void PNMImage::quantize(std::size_t max_colors);</span>

<span class="s0">637 17 perlin_noise_fill 0 4 708 27 PNMImage::perlin_noise_fill 0 2 311 312 361</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the image with a grayscale perlin noise pattern based on the</span>
 <span class="s0">* indicated parameters.  Uses set_xel to set the grayscale values.  The sx</span>
 <span class="s0">* and sy parameters are in multiples of the size of this image.  See also the</span>
 <span class="s0">* PerlinNoise2 class in mathutil.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Variant of perlin_noise_fill that uses an existing StackedPerlinNoise2</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>
<span class="s0">166</span>
<span class="s0">void PNMImage::perlin_noise_fill(float sx, float sy, int table_size = 256, unsigned long int seed = 0);</span>
<span class="s0">void PNMImage::perlin_noise_fill(StackedPerlinNoise2 &amp;perlin);</span>

<span class="s0">638 14 remix_channels 0 4 708 24 PNMImage::remix_channels 0 1 313 126</span>
<span class="s0">/**</span>
 <span class="s0">* Transforms every pixel using the operation (Ro,Go,Bo) =</span>
 <span class="s0">* conv.xform_point(Ri,Gi,Bi); Input must be a color image.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void PNMImage::remix_channels(LMatrix4 const &amp;conv);</span>

<span class="s0">639 13 gamma_correct 0 4 708 23 PNMImage::gamma_correct 0 1 314 217</span>
<span class="s0">/**</span>
 <span class="s0">* Assuming the image was constructed with a gamma curve of from_gamma in the</span>
 <span class="s0">* RGB channels, converts it to an image with a gamma curve of to_gamma in the</span>
 <span class="s0">* RGB channels.  Does not affect the alpha channel.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void PNMImage::gamma_correct(float from_gamma, float to_gamma);</span>

<span class="s0">640 19 gamma_correct_alpha 0 4 708 29 PNMImage::gamma_correct_alpha 0 1 315 218</span>
<span class="s0">/**</span>
 <span class="s0">* Assuming the image was constructed with a gamma curve of from_gamma in the</span>
 <span class="s0">* alpha channel, converts it to an image with a gamma curve of to_gamma in</span>
 <span class="s0">* the alpha channel.  Does not affect the RGB channels.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void PNMImage::gamma_correct_alpha(float from_gamma, float to_gamma);</span>

<span class="s0">641 14 apply_exponent 0 4 708 24 PNMImage::apply_exponent 0 4 316 317 318 319 868</span>
<span class="s0">/**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.  For a</span>
 <span class="s0">* grayscale image, the blue_exponent value is used for the grayscale value,</span>
 <span class="s0">* and red_exponent and green_exponent are unused.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.  For a</span>
 <span class="s0">* grayscale image, the blue_exponent value is used for the grayscale value,</span>
 <span class="s0">* and red_exponent and green_exponent are unused.</span>
 <span class="s0">*/</span>
<span class="s0">356</span>
<span class="s0">inline void PNMImage::apply_exponent(float gray_exponent);</span>
<span class="s0">inline void PNMImage::apply_exponent(float gray_exponent, float alpha_exponent);</span>
<span class="s0">inline void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent);</span>
<span class="s0">void PNMImage::apply_exponent(float red_exponent, float green_exponent, float blue_exponent, float alpha_exponent);</span>

<span class="s0">642 15 get_average_xel 0 4 708 25 PNMImage::get_average_xel 0 1 320 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the average color of all of the pixels in the image.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">LRGBColorf PNMImage::get_average_xel(void) const;</span>

<span class="s0">643 17 get_average_xel_a 0 4 708 27 PNMImage::get_average_xel_a 0 1 321 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the average color of all of the pixels in the image, including the</span>
 <span class="s0">* alpha channel.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">LColorf PNMImage::get_average_xel_a(void) const;</span>

<span class="s0">644 16 get_average_gray 0 4 708 26 PNMImage::get_average_gray 0 1 322 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the average grayscale component of all of the pixels in the image.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">float PNMImage::get_average_gray(void) const;</span>

<span class="s0">645 16 do_fill_distance 0 4 708 26 PNMImage::do_fill_distance 0 1 323 116</span>
<span class="s0">/**</span>
 <span class="s0">* Recursively fills in the minimum distance measured from a certain set of</span>
 <span class="s0">* points into the gray channel.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void PNMImage::do_fill_distance(int xi, int yi, int d);</span>

<span class="s0">646 4 size 0 4 709 19 PNMImage::Row::size 0 1 342 47</span>
<span class="s0">/**</span>
 <span class="s0">* Get the number of pixels in the row.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline std::size_t PNMImage::Row::size(void) const;</span>

<span class="s0">647 11 operator [] 0 4 709 26 PNMImage::Row::operator [] 0 1 343 0</span>
<span class="s0">55</span>
<span class="s0">inline LColorf PNMImage::Row::operator [](int x) const;</span>

<span class="s0">648 11 __setitem__ 0 4 709 26 PNMImage::Row::__setitem__ 0 1 344 127</span>
<span class="s0">/**</span>
 <span class="s0">* Set the pixel at the given column in the row.  If the image has no alpha</span>
 <span class="s0">* channel, the alpha component is ignored.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void PNMImage::Row::__setitem__(int x, LColorf const &amp;v);</span>

<span class="s0">649 11 get_xel_val 0 4 709 26 PNMImage::Row::get_xel_val 0 1 345 58</span>
<span class="s0">/**</span>
 <span class="s0">* Fetch the pixel at the given column in the row.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline xel &amp;PNMImage::Row::get_xel_val(int x);</span>

<span class="s0">650 11 set_xel_val 0 4 709 26 PNMImage::Row::set_xel_val 0 1 346 56</span>
<span class="s0">/**</span>
 <span class="s0">* Set the pixel at the given column in the row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PNMImage::Row::set_xel_val(int x, xel const &amp;v);</span>

<span class="s0">651 13 get_alpha_val 0 4 709 28 PNMImage::Row::get_alpha_val 0 1 347 64</span>
<span class="s0">/**</span>
 <span class="s0">* Fetch the alpha value at the given column in the row.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline xelval PNMImage::Row::get_alpha_val(int x) const;</span>

<span class="s0">652 13 set_alpha_val 0 4 709 28 PNMImage::Row::set_alpha_val 0 1 348 62</span>
<span class="s0">/**</span>
 <span class="s0">* Set the alpha value at the given column in the row.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void PNMImage::Row::set_alpha_val(int x, xelval v);</span>

<span class="s0">653 3 Row 0 260 709 18 PNMImage::Row::Row 0 1 341 8</span>
<span class="s0">/**</span>

 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PNMImage::Row::Row(PNMImage::Row const &amp;) = default;</span>

<span class="s0">654 4 size 0 4 710 20 PNMImage::CRow::size 0 1 350 47</span>
<span class="s0">/**</span>
 <span class="s0">* Get the number of pixels in the row.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::size_t PNMImage::CRow::size(void) const;</span>

<span class="s0">655 11 operator [] 0 4 710 27 PNMImage::CRow::operator [] 0 1 351 0</span>
<span class="s0">56</span>
<span class="s0">inline LColorf PNMImage::CRow::operator [](int x) const;</span>

<span class="s0">656 11 get_xel_val 0 4 710 27 PNMImage::CRow::get_xel_val 0 1 352 58</span>
<span class="s0">/**</span>
 <span class="s0">* Fetch the pixel at the given column in the row.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline xel PNMImage::CRow::get_xel_val(int x) const;</span>

<span class="s0">657 13 get_alpha_val 0 4 710 29 PNMImage::CRow::get_alpha_val 0 1 353 64</span>
<span class="s0">/**</span>
 <span class="s0">* Fetch the alpha value at the given column in the row.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline xelval PNMImage::CRow::get_alpha_val(int x) const;</span>

<span class="s0">658 4 CRow 0 260 710 20 PNMImage::CRow::CRow 0 1 349 8</span>
<span class="s0">/**</span>

 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline PNMImage::CRow::CRow(PNMImage::CRow const &amp;) = default;</span>

<span class="s0">659 11 operator [] 0 4 708 21 PNMImage::operator [] 0 2 324 325 0</span>
<span class="s0">108</span>
<span class="s0">inline PNMImage::Row PNMImage::operator [](int y);</span>
<span class="s0">inline PNMImage::CRow PNMImage::operator [](int y) const;</span>

<span class="s0">660 10 operator ~ 0 68 708 20 PNMImage::operator ~ 0 1 326 0</span>
<span class="s0">42</span>
<span class="s0">PNMImage PNMImage::operator ~(void) const;</span>

<span class="s0">661 10 operator + 0 4 708 20 PNMImage::operator + 0 2 327 328 0</span>
<span class="s0">132</span>
<span class="s0">inline PNMImage PNMImage::operator +(PNMImage const &amp;other) const;</span>
<span class="s0">inline PNMImage PNMImage::operator +(LColorf const &amp;other) const;</span>

<span class="s0">662 10 operator - 0 4 708 20 PNMImage::operator - 0 2 329 330 0</span>
<span class="s0">132</span>
<span class="s0">inline PNMImage PNMImage::operator -(PNMImage const &amp;other) const;</span>
<span class="s0">inline PNMImage PNMImage::operator -(LColorf const &amp;other) const;</span>

<span class="s0">663 10 operator * 0 4 708 20 PNMImage::operator * 0 3 331 332 333 0</span>
<span class="s0">194</span>
<span class="s0">inline PNMImage PNMImage::operator *(PNMImage const &amp;other) const;</span>
<span class="s0">inline PNMImage PNMImage::operator *(float multiplier) const;</span>
<span class="s0">inline PNMImage PNMImage::operator *(LColorf const &amp;other) const;</span>

<span class="s0">664 11 operator += 0 4 708 21 PNMImage::operator += 0 2 334 335 0</span>
<span class="s0">100</span>
<span class="s0">void PNMImage::operator +=(PNMImage const &amp;other);</span>
<span class="s0">void PNMImage::operator +=(LColorf const &amp;other);</span>

<span class="s0">665 11 operator -= 0 4 708 21 PNMImage::operator -= 0 2 336 337 0</span>
<span class="s0">100</span>
<span class="s0">void PNMImage::operator -=(PNMImage const &amp;other);</span>
<span class="s0">void PNMImage::operator -=(LColorf const &amp;other);</span>

<span class="s0">666 11 operator *= 0 4 708 21 PNMImage::operator *= 0 3 338 339 340 0</span>
<span class="s0">146</span>
<span class="s0">void PNMImage::operator *=(PNMImage const &amp;other);</span>
<span class="s0">void PNMImage::operator *=(float multiplier);</span>
<span class="s0">void PNMImage::operator *=(LColorf const &amp;other);</span>

<span class="s0">667 10 PNMPainter 0 260 711 22 PNMPainter::PNMPainter 0 2 354 355 532</span>
<span class="s0">/**</span>
 <span class="s0">* The constructor stores a pointer to the PNMImage you pass it, but it does</span>
 <span class="s0">* not take ownership of the object; you are responsible for ensuring that the</span>
 <span class="s0">* PNMImage does not destruct during the lifetime of the PNMPainter object.</span>
 <span class="s0">*</span>
 <span class="s0">* The xo, yo coordinates specify an optional offset for fill coordinates.  If</span>
 <span class="s0">* you are painting with a pattern fill, these specify the virtual coordinates</span>
 <span class="s0">* of the upper-left corner of the image, which can allow you to adjust the</span>
 <span class="s0">* pattern to line up with nested images, if necessary.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">explicit PNMPainter::PNMPainter(PNMImage &amp;image, int xo = 0, int yo = 0);</span>
<span class="s0">inline PNMPainter::PNMPainter(PNMPainter const &amp;) = default;</span>

<span class="s0">668 11 ~PNMPainter 0 516 711 23 PNMPainter::~PNMPainter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline PNMPainter::~PNMPainter(void);</span>

<span class="s0">669 7 set_pen 0 4 711 19 PNMPainter::set_pen 0 1 356 330</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a PNMBrush that will be used for drawing lines and edges.  If the</span>
 <span class="s0">* brush is a bitmap brush, its image will be smeared pixelwise along the</span>
 <span class="s0">* line.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the PNMImage passed to the constructor, the PNMPainter will take</span>
 <span class="s0">* ownership of the pen.  It is not necessary to keep a separate pointer to</span>
 <span class="s0">* it.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void PNMPainter::set_pen(PNMBrush *pen);</span>

<span class="s0">670 7 get_pen 0 4 711 19 PNMPainter::get_pen 0 1 357 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current pen.  See set_pen().</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline PNMBrush *PNMPainter::get_pen(void) const;</span>

<span class="s0">671 8 set_fill 0 4 711 20 PNMPainter::set_fill 0 1 358 343</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a PNMBrush that will be used for filling in the interiors of</span>
 <span class="s0">* objects.  If the brush is a bitmap brush, its image will be tiled</span>
 <span class="s0">* throughout the space.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the PNMImage passed to the constructor, the PNMPainter will take</span>
 <span class="s0">* ownership of the fill brush.  It is not necessary to keep a separate</span>
 <span class="s0">* pointer to it.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void PNMPainter::set_fill(PNMBrush *fill);</span>

<span class="s0">672 8 get_fill 0 4 711 20 PNMPainter::get_fill 0 1 359 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current fill brush.  See set_fill().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline PNMBrush *PNMPainter::get_fill(void) const;</span>

<span class="s0">673 10 draw_point 0 4 711 22 PNMPainter::draw_point 0 1 360 77</span>
<span class="s0">/**</span>
 <span class="s0">* Draws an antialiased point on the PNMImage, using the current pen.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void PNMPainter::draw_point(float x, float y);</span>

<span class="s0">674 9 draw_line 0 4 711 21 PNMPainter::draw_line 0 1 361 76</span>
<span class="s0">/**</span>
 <span class="s0">* Draws an antialiased line on the PNMImage, using the current pen.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void PNMPainter::draw_line(float xa, float ya, float xb, float yb);</span>

<span class="s0">675 14 draw_rectangle 0 4 711 26 PNMPainter::draw_rectangle 0 1 362 211</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a filled rectangule on the PNMImage, using the current pen for the</span>
 <span class="s0">* outline, and the current fill brush for the interior.</span>
 <span class="s0">*</span>
 <span class="s0">* The two coordinates specify any two diagonally opposite corners.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void PNMPainter::draw_rectangle(float xa, float ya, float xb, float yb);</span>

<span class="s0">370</span>
<span class="s0">1 0 0 7 2 713 390 0 0 0 </span>
<span class="s0">2 0 0 23 2 713 390 0 0 1 4 fill 1 677  </span>
<span class="s0">3 0 0 23 2 713 390 0 0 3 1 r 1 677  1 g 1 677  1 b 1 677  </span>
<span class="s0">4 0 0 15 2 713 390 0 0 1 6 param0 0 714  </span>
<span class="s0">5 0 0 4 3 716 0 0 0 3 4 this 3 713  1 i 1 688  10 assign_val 1 677  </span>
<span class="s0">6 0 0 6 3 677 0 0 0 2 4 this 3 714  1 i 1 688  </span>
<span class="s0">7 0 0 7 4 713 390 0 0 2 4 this 3 714  5 other 1 714  </span>
<span class="s0">8 0 0 7 5 713 390 0 0 2 4 this 3 714  5 other 1 714  </span>
<span class="s0">9 0 0 7 6 713 390 0 0 2 4 this 3 714  4 mult 1 717  </span>
<span class="s0">10 0 0 6 7 713 0 0 0 2 4 this 3 713  5 other 1 714  </span>
<span class="s0">11 0 0 6 8 713 0 0 0 2 4 this 3 713  5 other 1 714  </span>
<span class="s0">12 0 0 6 9 713 0 0 0 2 4 this 3 713  4 mult 1 717  </span>
<span class="s0">13 0 0 6 10 702 0 0 0 2 4 this 3 713  5 other 1 714  </span>
<span class="s0">14 0 0 6 11 702 0 0 0 2 4 this 3 713  5 other 1 714  </span>
<span class="s0">15 0 0 6 12 702 0 0 0 2 4 this 3 714  5 other 1 714  </span>
<span class="s0">16 0 0 6 13 688 0 0 0 0 </span>
<span class="s0">17 0 0 4 14 716 0 0 0 2 4 this 3 713  3 out 1 719  </span>
<span class="s0">18 0 0 6 34 723 0 0 0 1 4 this 3 721  </span>
<span class="s0">19 0 0 6 35 688 0 0 117 /**</span>
 <span class="s0">* Returns the number of different possible filename extensions associated</span>
 <span class="s0">* with this particular file type.</span>
 <span class="s0">*/ 1 4 this 3 721  </span>
<span class="s0">20 0 0 6 36 723 0 0 123 /**</span>
 <span class="s0">* Returns the nth possible filename extension associated with this particular</span>
 <span class="s0">* file type, without a leading dot.</span>
 <span class="s0">*/ 2 4 this 3 721  1 n 1 688  </span>
<span class="s0">21 0 0 6 38 723 0 0 159 /**</span>
 <span class="s0">* Returns a suitable filename extension (without a leading dot) to suggest</span>
 <span class="s0">* for files of this type, or empty string if no suggestions are available.</span>
 <span class="s0">*/ 1 4 this 3 721  </span>
<span class="s0">22 0 0 7 44 725 0 0 0 0 </span>
<span class="s0">23 0 0 15 57 728 400 0 0 1 6 param0 0 726  </span>
<span class="s0">24 0 0 6 47 688 0 0 56 /**</span>
 <span class="s0">* Returns the total number of types registered.</span>
 <span class="s0">*/ 1 4 this 3 726  </span>
<span class="s0">25 0 0 6 48 685 0 0 43 /**</span>
 <span class="s0">* Returns the nth type registered.</span>
 <span class="s0">*/ 2 4 this 3 726  1 n 1 688  </span>
<span class="s0">26 0 0 6 52 685 0 0 203 /**</span>
 <span class="s0">* Tries to determine what the PNMFileType is likely to be for a particular</span>
 <span class="s0">* image file based on its extension.  Returns a suitable PNMFileType pointer,</span>
 <span class="s0">* or NULL if no type can be determined.</span>
 <span class="s0">*/ 2 4 this 3 726  8 filename 1 723  </span>
<span class="s0">27 0 0 6 53 685 0 0 249 /**</span>
 <span class="s0">* Tries to determine what the PNMFileType is likely to be for a particular</span>
 <span class="s0">* image file based on its magic number, the first two bytes read from the</span>
 <span class="s0">* file.  Returns a suitable PNMFileType pointer, or NULL if no type can be</span>
 <span class="s0">* determined.</span>
 <span class="s0">*/ 2 4 this 3 726  12 magic_number 1 723  </span>
<span class="s0">28 0 0 6 54 685 0 0 172 /**</span>
 <span class="s0">* Returns the PNMFileType instance stored in the registry for the given</span>
 <span class="s0">* TypeHandle, e.g.  as retrieved by a previous call to get_type() on the type</span>
 <span class="s0">* instance.</span>
 <span class="s0">*/ 2 4 this 3 726  6 handle 1 725  </span>
<span class="s0">29 0 0 4 55 716 0 0 103 /**</span>
 <span class="s0">* Writes a list of supported image file types to the indicated output stream,</span>
 <span class="s0">* one per line.</span>
 <span class="s0">*/ 3 4 this 3 726  3 out 1 719  12 indent_level 5 688  </span>
<span class="s0">30 0 0 6 56 728 0 0 70 /**</span>
 <span class="s0">* Returns a pointer to the global PNMFileTypeRegistry object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">31 0 0 7 59 729 411 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">32 0 0 15 59 729 411 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 730  </span>
<span class="s0">33 0 0 6 60 729 0 0 0 2 4 this 3 729  4 copy 1 730  </span>
<span class="s0">34 0 0 6 63 687 0 0 147 /**</span>
 <span class="s0">* Returns the image type of the image, as an enumerated value.  This is</span>
 <span class="s0">* really just the number of channels cast to the enumerated type.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">35 0 0 6 64 688 0 0 55 /**</span>
 <span class="s0">* Returns the number of channels in the image.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">36 0 0 6 67 702 0 0 275 /**</span>
 <span class="s0">* Returns false if the image is a full-color image, and has red, green, and</span>
 <span class="s0">* blue components; true if it is a grayscale image and has only a gray</span>
 <span class="s0">* component.  (The gray color is actually stored in the blue channel, and the</span>
 <span class="s0">* red and green channels are ignored.)</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">37 0 0 6 67 702 0 0 139 /**</span>
 <span class="s0">* This static variant of is_grayscale() returns true if the indicated image</span>
 <span class="s0">* type represents a grayscale image, false otherwise.</span>
 <span class="s0">*/ 1 10 color_type 1 687  </span>
<span class="s0">38 0 0 6 68 702 0 0 204 /**</span>
 <span class="s0">* Returns true if the image includes an alpha channel, false otherwise.</span>
 <span class="s0">* Unlike is_grayscale(), if this returns false it is an error to call any of</span>
 <span class="s0">* the functions accessing the alpha channel.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">39 0 0 6 68 702 0 0 133 /**</span>
 <span class="s0">* This static variant of has_alpha() returns true if the indicated image type</span>
 <span class="s0">* includes an alpha channel, false otherwise.</span>
 <span class="s0">*/ 1 10 color_type 1 687  </span>
<span class="s0">40 0 0 6 69 689 0 0 183 /**</span>
 <span class="s0">* Returns the maximum channel value allowable for any pixel in this image;</span>
 <span class="s0">* for instance, 255 for a typical 8-bit-per-channel image.  A pixel with this</span>
 <span class="s0">* value is full on.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">41 0 0 6 70 690 0 0 97 /**</span>
 <span class="s0">* Returns the color space that the image is encoded in, or CS_unspecified if</span>
 <span class="s0">* unknown.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">42 0 0 6 75 688 0 0 121 /**</span>
 <span class="s0">* Returns the number of pixels in the X direction.  This is one more than the</span>
 <span class="s0">* largest allowable X coordinate.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">43 0 0 6 76 688 0 0 121 /**</span>
 <span class="s0">* Returns the number of pixels in the Y direction.  This is one more than the</span>
 <span class="s0">* largest allowable Y coordinate.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">44 0 0 7 77 732 0 0 119 /**</span>
 <span class="s0">* Returns the number of pixels in each direction.  This is one more than the</span>
 <span class="s0">* largest allowable coordinates.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">45 0 0 6 80 723 0 0 47 /**</span>
 <span class="s0">* Gets the user comment from the file.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">46 0 0 4 81 716 0 0 62 /**</span>
 <span class="s0">* Writes a user comment string to the image (header).</span>
 <span class="s0">*/ 2 4 this 3 729  7 comment 1 723  </span>
<span class="s0">47 0 0 6 83 702 0 0 85 /**</span>
 <span class="s0">* Returns true if the PNMImageHeader knows what type it is, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">48 0 0 6 84 685 0 0 130 /**</span>
 <span class="s0">* If the file type is known (e.g.  has_type() returns true), returns its</span>
 <span class="s0">* PNMFileType pointer; otherwise, returns NULL.</span>
 <span class="s0">*/ 1 4 this 3 730  </span>
<span class="s0">49 0 0 4 85 716 0 0 294 /**</span>
 <span class="s0">* Sets the file type of this PNMImage.  This will be the default type used</span>
 <span class="s0">* when an image is read, if the type cannot be determined by magic number or</span>
 <span class="s0">* inferred by extension, or the type used when the image is written, if the</span>
 <span class="s0">* type cannot be inferred from the filename extension.</span>
 <span class="s0">*/ 2 4 this 3 729  4 type 1 685  </span>
<span class="s0">50 0 0 6 87 702 0 0 220 /**</span>
 <span class="s0">* Opens up the image file and tries to read its header information to</span>
 <span class="s0">* determine its size, number of channels, etc.  If successful, updates the</span>
 <span class="s0">* header information and returns true; otherwise, returns false.</span>
 <span class="s0">*/ 4 4 this 3 729  8 filename 1 733  4 type 5 685  19 report_unknown_type 5 702  </span>
<span class="s0">51 0 0 6 87 702 0 0 397 /**</span>
 <span class="s0">* Reads the image header information only from the indicated stream.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is advisory only, and may be used to suggest a type if it has</span>
 <span class="s0">* a known extension.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the type of file it is (and a</span>
 <span class="s0">* non-NULL type will override any magic number test or filename extension</span>
 <span class="s0">* lookup).</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false on error.</span>
 <span class="s0">*/ 5 4 this 3 729  4 data 1 736  8 filename 5 723  4 type 5 685  19 report_unknown_type 5 702  </span>
<span class="s0">52 0 0 6 88 738 0 0 366 /**</span>
 <span class="s0">* Returns a newly-allocated PNMReader of the suitable type for reading from</span>
 <span class="s0">* the indicated image filename, or NULL if the filename cannot be read for</span>
 <span class="s0">* some reason.  The filename &quot;-&quot; always stands for standard input.  If type</span>
 <span class="s0">* is specified, it is a suggestion for the file type to use.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMReader should be deleted when it is no longer needed.</span>
 <span class="s0">*/ 4 4 this 3 730  8 filename 1 733  4 type 5 685  19 report_unknown_type 5 702  </span>
<span class="s0">53 0 0 6 88 738 0 0 917 /**</span>
 <span class="s0">* Returns a newly-allocated PNMReader of the suitable type for reading from</span>
 <span class="s0">* the already-opened image file, or NULL if the file cannot be read for some</span>
 <span class="s0">* reason.</span>
 <span class="s0">*</span>
 <span class="s0">* owns_file should be set true if the PNMReader is to be considered the owner</span>
 <span class="s0">* of the stream pointer (in which case the stream will be deleted on</span>
 <span class="s0">* completion, whether successful or not), or false if it should not delete</span>
 <span class="s0">* it.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename parameter is optional here, since the file has already been</span>
 <span class="s0">* opened; it is only used to examine the extension and attempt to guess the</span>
 <span class="s0">* file type.</span>
 <span class="s0">*</span>
 <span class="s0">* If magic_number is nonempty, it is assumed to represent the first few bytes</span>
 <span class="s0">* that have already been read from the file.  Some file types may have</span>
 <span class="s0">* difficulty if this is more than two bytes.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the file type to use.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMReader should be deleted when it is no longer needed.</span>
 <span class="s0">*/ 7 4 this 3 730  4 file 1 736  9 owns_file 5 702  8 filename 5 733  12 magic_number 5 723  4 type 5 685  19 report_unknown_type 5 702  </span>
<span class="s0">54 0 0 6 89 740 0 0 371 /**</span>
 <span class="s0">* Returns a newly-allocated PNMWriter of the suitable type for writing an</span>
 <span class="s0">* image to the indicated filename, or NULL if the filename cannot be written</span>
 <span class="s0">* for some reason.  The filename &quot;-&quot; always stands for standard output.  If</span>
 <span class="s0">* type is specified, it is a suggestion for the file type to use.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMWriter should be deleted when it is no longer needed.</span>
 <span class="s0">*/ 3 4 this 3 730  8 filename 1 733  4 type 5 685  </span>
<span class="s0">55 0 0 6 89 740 0 0 727 /**</span>
 <span class="s0">* Returns a newly-allocated PNMWriter of the suitable type for writing to the</span>
 <span class="s0">* already-opened image file, or NULL if the file cannot be written for some</span>
 <span class="s0">* reason.</span>
 <span class="s0">*</span>
 <span class="s0">* owns_file should be set true if the PNMWriter is to be considered the owner</span>
 <span class="s0">* of the stream pointer (in which case the stream will be deleted on</span>
 <span class="s0">* completion, whether successful or not), or false if it should not delete</span>
 <span class="s0">* it.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename parameter is optional here, since the file has already been</span>
 <span class="s0">* opened; it is only used to examine the extension and attempt to guess the</span>
 <span class="s0">* intended file type.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the file type to use.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMWriter should be deleted when it is no longer needed.</span>
 <span class="s0">*/ 5 4 this 3 730  4 file 1 719  9 owns_file 5 702  8 filename 5 733  4 type 5 685  </span>
<span class="s0">56 0 0 4 91 716 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 730  3 out 1 719  </span>
<span class="s0">57 0 0 15 93 744 447 0 0 1 6 param0 0 742  </span>
<span class="s0">58 0 0 23 93 744 447 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 3 rgb 1 745  </span>
<span class="s0">59 0 0 23 93 744 447 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 3 rgb 1 745  5 alpha 1 689  </span>
<span class="s0">60 0 0 23 93 744 447 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 gray_value 1 689  </span>
<span class="s0">61 0 0 23 93 744 447 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 10 gray_value 1 689  5 alpha 1 689  </span>
<span class="s0">62 0 0 23 93 744 447 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 3 red 1 689  5 green 1 689  4 blue 1 689  </span>
<span class="s0">63 0 0 23 93 744 447 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 3 red 1 689  5 green 1 689  4 blue 1 689  5 alpha 1 689  </span>
<span class="s0">64 0 0 6 94 702 0 0 0 2 4 this 3 742  5 other 1 742  </span>
<span class="s0">65 0 0 6 95 702 0 0 0 2 4 this 3 742  5 other 1 742  </span>
<span class="s0">66 0 0 6 96 702 0 0 0 2 4 this 3 742  5 other 1 742  </span>
<span class="s0">67 0 0 6 97 688 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 742  5 other 1 742  </span>
<span class="s0">68 0 0 6 98 689 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 742  </span>
<span class="s0">69 0 0 6 99 689 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 742  </span>
<span class="s0">70 0 0 6 100 689 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 742  </span>
<span class="s0">71 0 0 6 101 689 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 742  </span>
<span class="s0">72 0 0 4 102 716 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 744  3 red 1 689  </span>
<span class="s0">73 0 0 4 103 716 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 744  5 green 1 689  </span>
<span class="s0">74 0 0 4 104 716 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 744  4 blue 1 689  </span>
<span class="s0">75 0 0 4 105 716 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 744  5 alpha 1 689  </span>
<span class="s0">76 0 0 6 106 689 0 0 0 2 4 this 3 742  1 n 1 688  </span>
<span class="s0">77 0 0 6 107 688 0 0 135 /**</span>
 <span class="s0">* Specifies the number of components in the PixelSpec; this is always 4,</span>
 <span class="s0">* regardless of the type of image it was taken from.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">78 0 0 4 108 716 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 742  3 out 1 719  </span>
<span class="s0">79 0 0 15 111 749 449 0 0 1 6 param0 0 747  </span>
<span class="s0">80 0 0 7 120 750 455 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">81 0 0 15 120 750 455 0 0 1 6 param0 0 751  </span>
<span class="s0">82 0 0 6 121 688 0 0 70 /**</span>
 <span class="s0">* Returns the number of unique pixel colors in the histogram.</span>
 <span class="s0">*/ 1 4 this 3 751  </span>
<span class="s0">83 0 0 6 122 742 0 0 130 /**</span>
 <span class="s0">* Returns the nth unique pixel color in the histogram.  These are ordered by</span>
 <span class="s0">* default from most common to least common.</span>
 <span class="s0">*/ 2 4 this 3 751  1 n 1 688  </span>
<span class="s0">84 0 0 6 123 688 0 0 90 /**</span>
 <span class="s0">* Returns the number of occurrences in the image of the indicated pixel</span>
 <span class="s0">* color.</span>
 <span class="s0">*/ 2 4 this 3 751  5 pixel 1 742  </span>
<span class="s0">85 0 0 6 123 688 0 0 108 /**</span>
 <span class="s0">* Returns the number of occurrences in the image of the nth unique pixel</span>
 <span class="s0">* color in the histogram.</span>
 <span class="s0">*/ 2 4 this 3 751  1 n 1 688  </span>
<span class="s0">86 0 0 4 125 716 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 751  3 out 1 719  </span>
<span class="s0">87 0 0 7 128 753 538 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">88 0 0 15 128 753 538 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 754  </span>
<span class="s0">89 0 0 6 129 753 0 0 0 2 4 this 3 753  4 copy 1 754  </span>
<span class="s0">90 0 0 4 130 716 0 0 43 /**</span>
 <span class="s0">* Eliminates all data in the file.</span>
 <span class="s0">*/ 1 4 this 3 753  </span>
<span class="s0">91 0 0 4 130 716 0 0 207 /**</span>
 <span class="s0">* Resets to an empty table with a specific size.  The case of num_channels ==</span>
 <span class="s0">* 0 is allowed only in the case that x_size and y_size are also == 0; and</span>
 <span class="s0">* this makes an empty (and invalid) PfmFile.</span>
 <span class="s0">*/ 4 4 this 3 753  6 x_size 1 688  6 y_size 1 688  12 num_channels 1 688  </span>
<span class="s0">92 0 0 6 131 702 0 0 240 /**</span>
 <span class="s0">* Reads the PFM data from the indicated file, returning true on success,</span>
 <span class="s0">* false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This can also handle reading a standard image file supported by PNMImage;</span>
 <span class="s0">* it will be quietly converted to a floating-point type.</span>
 <span class="s0">*/ 2 4 this 3 753  8 fullpath 1 733  </span>
<span class="s0">93 0 0 6 131 702 0 0 142 /**</span>
 <span class="s0">* Reads the PFM data using the indicated PNMReader.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMReader is always deleted upon completion, whether successful or not.</span>
 <span class="s0">*/ 2 4 this 3 753  6 reader 1 738  </span>
<span class="s0">94 0 0 6 131 702 0 0 242 /**</span>
 <span class="s0">* Reads the PFM data from the indicated stream, returning true on success,</span>
 <span class="s0">* false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This can also handle reading a standard image file supported by PNMImage;</span>
 <span class="s0">* it will be quietly converted to a floating-point type.</span>
 <span class="s0">*/ 3 4 this 3 753  2 in 1 736  8 fullpath 5 733  </span>
<span class="s0">95 0 0 6 132 702 0 0 313 /**</span>
 <span class="s0">* Writes the PFM data to the indicated file, returning true on success, false</span>
 <span class="s0">* on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* If the type implied by the filename extension supports floating-point, the</span>
 <span class="s0">* data will be written directly; otherwise, the floating-point data will be</span>
 <span class="s0">* quietly converted to the appropriate integer type.</span>
 <span class="s0">*/ 2 4 this 3 753  8 fullpath 1 733  </span>
<span class="s0">96 0 0 6 132 702 0 0 143 /**</span>
 <span class="s0">* Writes the PFM data using the indicated PNMWriter.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMWriter is always deleted upon completion, whether successful or not.</span>
 <span class="s0">*/ 2 4 this 3 753  6 writer 1 740  </span>
<span class="s0">97 0 0 6 132 702 0 0 103 /**</span>
 <span class="s0">* Writes the PFM data to the indicated stream, returning true on success,</span>
 <span class="s0">* false on failure.</span>
 <span class="s0">*/ 3 4 this 3 753  3 out 1 719  8 fullpath 5 733  </span>
<span class="s0">98 0 0 6 133 702 0 0 110 /**</span>
 <span class="s0">* Fills the PfmFile with the data from the indicated PNMImage, converted to</span>
 <span class="s0">* floating-point values.</span>
 <span class="s0">*/ 2 4 this 3 753  8 pnmimage 1 756  </span>
<span class="s0">99 0 0 6 134 702 0 0 79 /**</span>
 <span class="s0">* Copies the data to the indicated PNMImage, converting to RGB values.</span>
 <span class="s0">*/ 2 4 this 3 754  8 pnmimage 1 758  </span>
<span class="s0">100 0 0 6 135 702 0 0 180 /**</span>
 <span class="s0">* Stores 1 or 0 values into the indicated PNMImage, according to has_point()</span>
 <span class="s0">* for each pixel.  Each valid point gets a 1 value; each nonexistent point</span>
 <span class="s0">* gets a 0 value.</span>
 <span class="s0">*/ 2 4 this 3 754  8 pnmimage 1 758  </span>
<span class="s0">101 0 0 6 135 702 0 0 424 /**</span>
 <span class="s0">* Stores 1 or 0 values into the indicated PNMImage, according to has_point()</span>
 <span class="s0">* for each pixel.  Each valid point gets a 1 value; each nonexistent point</span>
 <span class="s0">* gets a 0 value.</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of store_mask also checks whether the valid points are within</span>
 <span class="s0">* the specified min/max range.  Any valid points without the condition</span>
 <span class="s0">* min_point[c] &lt;= value[c] &lt;= max_point[c], for any c, are stored with a 0 in</span>
 <span class="s0">* the mask.</span>
 <span class="s0">*/ 4 4 this 3 754  8 pnmimage 1 758  9 min_point 1 759  9 max_point 1 759  </span>
<span class="s0">102 0 0 6 136 702 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 754  </span>
<span class="s0">103 0 0 6 139 703 0 0 81 /**</span>
 <span class="s0">* The &quot;scale&quot; is reported in the pfm header and is probably meaningless.</span>
 <span class="s0">*/ 1 4 this 3 754  </span>
<span class="s0">104 0 0 4 140 716 0 0 81 /**</span>
 <span class="s0">* The &quot;scale&quot; is reported in the pfm header and is probably meaningless.</span>
 <span class="s0">*/ 2 4 this 3 753  5 scale 1 703  </span>
<span class="s0">105 0 0 6 144 702 0 0 205 /**</span>
 <span class="s0">* Returns true if there is a valid point at x, y.  This always returns true</span>
 <span class="s0">* unless a &quot;no data&quot; value has been set, in which case it returns false if</span>
 <span class="s0">* the point at x, y is the &quot;no data&quot; value.</span>
 <span class="s0">*/ 3 4 this 3 754  1 x 1 688  1 y 1 688  </span>
<span class="s0">106 0 0 6 145 703 0 0 77 /**</span>
 <span class="s0">* Returns the cth channel of the point value at the indicated point.</span>
 <span class="s0">*/ 4 4 this 3 754  1 x 1 688  1 y 1 688  1 c 1 688  </span>
<span class="s0">107 0 0 4 146 716 0 0 78 /**</span>
 <span class="s0">* Replaces the cth channel of the point value at the indicated point.</span>
 <span class="s0">*/ 5 4 this 3 753  1 x 1 688  1 y 1 688  1 c 1 688  5 value 1 703  </span>
<span class="s0">108 0 0 6 147 703 0 0 70 /**</span>
 <span class="s0">* Returns the 1-component point value at the indicated point.</span>
 <span class="s0">*/ 3 4 this 3 754  1 x 1 688  1 y 1 688  </span>
<span class="s0">109 0 0 4 148 716 0 0 71 /**</span>
 <span class="s0">* Replaces the 1-component point value at the indicated point.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 703  </span>
<span class="s0">110 0 0 6 149 762 0 0 137 /**</span>
 <span class="s0">* Returns the 2-component point value at the indicated point.  In a 1-channel</span>
 <span class="s0">* image, the channel value is in the x component.</span>
 <span class="s0">*/ 3 4 this 3 754  1 x 1 688  1 y 1 688  </span>
<span class="s0">111 0 0 4 150 716 0 0 138 /**</span>
 <span class="s0">* Replaces the 2-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 765  </span>
<span class="s0">112 0 0 4 150 716 0 0 138 /**</span>
 <span class="s0">* Replaces the 2-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 768  </span>
<span class="s0">113 0 0 6 151 771 0 0 79 /**</span>
 <span class="s0">* Returns a modifiable 2-component point value at the indicated point.</span>
 <span class="s0">*/ 3 4 this 3 753  1 x 1 688  1 y 1 688  </span>
<span class="s0">114 0 0 6 152 772 0 0 137 /**</span>
 <span class="s0">* Returns the 3-component point value at the indicated point.  In a 1-channel</span>
 <span class="s0">* image, the channel value is in the x component.</span>
 <span class="s0">*/ 3 4 this 3 754  1 x 1 688  1 y 1 688  </span>
<span class="s0">115 0 0 4 153 716 0 0 138 /**</span>
 <span class="s0">* Replaces the 3-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 775  </span>
<span class="s0">116 0 0 4 153 716 0 0 138 /**</span>
 <span class="s0">* Replaces the 3-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 778  </span>
<span class="s0">117 0 0 6 154 781 0 0 79 /**</span>
 <span class="s0">* Returns a modifiable 3-component point value at the indicated point.</span>
 <span class="s0">*/ 3 4 this 3 753  1 x 1 688  1 y 1 688  </span>
<span class="s0">118 0 0 6 155 772 0 0 137 /**</span>
 <span class="s0">* Returns the 3-component point value at the indicated point.  In a 1-channel</span>
 <span class="s0">* image, the channel value is in the x component.</span>
 <span class="s0">*/ 3 4 this 3 754  1 x 1 688  1 y 1 688  </span>
<span class="s0">119 0 0 4 156 716 0 0 138 /**</span>
 <span class="s0">* Replaces the 3-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 775  </span>
<span class="s0">120 0 0 4 156 716 0 0 138 /**</span>
 <span class="s0">* Replaces the 3-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 778  </span>
<span class="s0">121 0 0 6 157 781 0 0 79 /**</span>
 <span class="s0">* Returns a modifiable 3-component point value at the indicated point.</span>
 <span class="s0">*/ 3 4 this 3 753  1 x 1 688  1 y 1 688  </span>
<span class="s0">122 0 0 6 158 782 0 0 137 /**</span>
 <span class="s0">* Returns the 4-component point value at the indicated point.  In a 1-channel</span>
 <span class="s0">* image, the channel value is in the x component.</span>
 <span class="s0">*/ 3 4 this 3 754  1 x 1 688  1 y 1 688  </span>
<span class="s0">123 0 0 4 159 716 0 0 138 /**</span>
 <span class="s0">* Replaces the 4-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 785  </span>
<span class="s0">124 0 0 4 159 716 0 0 138 /**</span>
 <span class="s0">* Replaces the 4-component point value at the indicated point.  In a</span>
 <span class="s0">* 1-channel image, the channel value is in the x component.</span>
 <span class="s0">*/ 4 4 this 3 753  1 x 1 688  1 y 1 688  5 point 1 759  </span>
<span class="s0">125 0 0 6 160 788 0 0 79 /**</span>
 <span class="s0">* Returns a modifiable 4-component point value at the indicated point.</span>
 <span class="s0">*/ 3 4 this 3 753  1 x 1 688  1 y 1 688  </span>
<span class="s0">126 0 0 4 161 716 0 0 54 /**</span>
 <span class="s0">* Fills the table with all of the same value.</span>
 <span class="s0">*/ 2 4 this 3 753  5 value 1 762  </span>
<span class="s0">127 0 0 4 161 716 0 0 54 /**</span>
 <span class="s0">* Fills the table with all of the same value.</span>
 <span class="s0">*/ 2 4 this 3 753  5 value 1 772  </span>
<span class="s0">128 0 0 4 161 716 0 0 54 /**</span>
 <span class="s0">* Fills the table with all of the same value.</span>
 <span class="s0">*/ 2 4 this 3 753  5 value 1 782  </span>
<span class="s0">129 0 0 4 161 716 0 0 54 /**</span>
 <span class="s0">* Fills the table with all of the same value.</span>
 <span class="s0">*/ 2 4 this 3 753  5 value 1 703  </span>
<span class="s0">130 0 0 4 162 716 0 0 40 /**</span>
 <span class="s0">* Fills the table with all NaN.</span>
 <span class="s0">*/ 1 4 this 3 753  </span>
<span class="s0">131 0 0 4 163 716 0 0 86 /**</span>
 <span class="s0">* Fills the table with the current no_data value, so that the table is empty.</span>
 <span class="s0">*/ 1 4 this 3 753  </span>
<span class="s0">132 0 0 4 164 716 0 0 107 /**</span>
 <span class="s0">* Fills the indicated channel with all of the same value, leaving the other</span>
 <span class="s0">* channels unchanged.</span>
 <span class="s0">*/ 3 4 this 3 753  7 channel 1 688  5 value 1 703  </span>
<span class="s0">133 0 0 4 165 716 0 0 86 /**</span>
 <span class="s0">* Fills the indicated channel with NaN, leaving the other channels unchanged.</span>
 <span class="s0">*/ 2 4 this 3 753  7 channel 1 688  </span>
<span class="s0">134 0 0 4 166 716 0 0 152 /**</span>
 <span class="s0">* Fills the indicated channel with all of the same value, but only where the</span>
 <span class="s0">* table already has a data point.  Leaves empty points unchanged.</span>
 <span class="s0">*/ 3 4 this 3 753  7 channel 1 688  5 value 1 703  </span>
<span class="s0">135 0 0 4 167 716 0 0 134 /**</span>
 <span class="s0">* Fills the indicated channel with NaN, but only where the table already has</span>
 <span class="s0">* a data point.  Leaves empty points unchanged.</span>
 <span class="s0">*/ 2 4 this 3 753  7 channel 1 688  </span>
<span class="s0">136 0 0 6 168 702 0 0 296 /**</span>
 <span class="s0">* Computes the unweighted average point of all points within the box centered</span>
 <span class="s0">* at (x, y) with the indicated Manhattan-distance radius.  Missing points are</span>
 <span class="s0">* assigned the value of their nearest neighbor.  Returns true if successful,</span>
 <span class="s0">* or false if the point value cannot be determined.</span>
 <span class="s0">*/ 5 4 this 3 754  6 result 1 781  1 x 1 703  1 y 1 703  6 radius 1 703  </span>
<span class="s0">137 0 0 6 169 702 0 0 190 /**</span>
 <span class="s0">* Computes the weighted average of the four nearest points to the floating-</span>
 <span class="s0">* point index (x, y).  Returns true if the point has any contributors, false</span>
 <span class="s0">* if the point is unknown.</span>
 <span class="s0">*/ 4 4 this 3 754  6 result 1 781  1 x 1 703  1 y 1 703  </span>
<span class="s0">138 0 0 6 170 702 0 0 246 /**</span>
 <span class="s0">* Calculates the minimum and maximum x, y, and z depth component values,</span>
 <span class="s0">* representing the bounding box of depth values, and places them in the</span>
 <span class="s0">* indicated vectors.  Returns true if successful, false if the mesh contains</span>
 <span class="s0">* no points.</span>
 <span class="s0">*/ 3 4 this 3 754  10 min_points 1 789  10 max_points 1 789  </span>
<span class="s0">139 0 0 6 171 702 0 0 250 /**</span>
 <span class="s0">* Computes the minimum range of x and y across the PFM file that include all</span>
 <span class="s0">* points.  If there are no points with no_data_value in the grid--that is,</span>
 <span class="s0">* all points are included--then this will return (0, get_x_size(), 0,</span>
 <span class="s0">* get_y_size()).</span>
 <span class="s0">*/ 2 4 this 3 754  5 range 1 790  </span>
<span class="s0">140 0 0 6 171 702 0 0 250 /**</span>
 <span class="s0">* Computes the minimum range of x and y across the PFM file that include all</span>
 <span class="s0">* points.  If there are no points with no_data_value in the grid--that is,</span>
 <span class="s0">* all points are included--then this will return (0, get_x_size(), 0,</span>
 <span class="s0">* get_y_size()).</span>
 <span class="s0">*/ 2 4 this 3 754  5 range 1 791  </span>
<span class="s0">141 0 0 6 172 702 0 0 160 /**</span>
 <span class="s0">* Returns true if all of the points on row y, in the range [x_begin, x_end),</span>
 <span class="s0">* are the no_data value, or false if any one of these points has a value.</span>
 <span class="s0">*/ 4 4 this 3 754  1 y 1 688  7 x_begin 1 688  5 x_end 1 688  </span>
<span class="s0">142 0 0 6 173 702 0 0 155 /**</span>
 <span class="s0">* Returns true if all of the points on column x, from [y_begin, y_end), are</span>
 <span class="s0">* the no_data value, or false if any one of these points has a value.</span>
 <span class="s0">*/ 4 4 this 3 754  1 x 1 688  7 y_begin 1 688  5 y_end 1 688  </span>
<span class="s0">143 0 0 4 174 716 0 0 209 /**</span>
 <span class="s0">* Sets the zero_special flag.  When this flag is true, values of (0, 0, 0) in</span>
 <span class="s0">* the pfm file are treated as a special case, and are not processed.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a special case of set_no_data_value().</span>
 <span class="s0">*/ 2 4 this 3 753  12 zero_special 1 702  </span>
<span class="s0">144 0 0 4 175 716 0 0 259 /**</span>
 <span class="s0">* Sets the no_data_chan4 flag.  When this flag is true, and the pfm file has</span>
 <span class="s0">* 4 channels, then a negative value in the fourth channel indicates no data.</span>
 <span class="s0">* When it is false, all points are valid.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a special case of set_no_data_value().</span>
 <span class="s0">*/ 2 4 this 3 753  5 chan4 1 702  </span>
<span class="s0">145 0 0 4 176 716 0 0 272 /**</span>
 <span class="s0">* Sets the no_data_nan flag.  When num_channels is nonzero, then a NaN value</span>
 <span class="s0">* in any of the first num_channels channels indicates no data for that point.</span>
 <span class="s0">* If num_channels is zero, then all points are valid.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a special case of set_no_data_value().</span>
 <span class="s0">*/ 2 4 this 3 753  12 num_channels 1 688  </span>
<span class="s0">146 0 0 4 177 716 0 0 90 /**</span>
 <span class="s0">* Sets the special value that means &quot;no data&quot; when it appears in the pfm</span>
 <span class="s0">* file.</span>
 <span class="s0">*/ 2 4 this 3 753  13 no_data_value 1 792  </span>
<span class="s0">147 0 0 4 177 716 0 0 90 /**</span>
 <span class="s0">* Sets the special value that means &quot;no data&quot; when it appears in the pfm</span>
 <span class="s0">* file.</span>
 <span class="s0">*/ 2 4 this 3 753  13 no_data_value 1 782  </span>
<span class="s0">148 0 0 4 178 716 0 0 126 /**</span>
 <span class="s0">* Sets the special threshold value.  Points that are below this value in all</span>
 <span class="s0">* components are considered &quot;no value&quot;.</span>
 <span class="s0">*/ 2 4 this 3 753  13 no_data_value 1 792  </span>
<span class="s0">149 0 0 4 178 716 0 0 126 /**</span>
 <span class="s0">* Sets the special threshold value.  Points that are below this value in all</span>
 <span class="s0">* components are considered &quot;no value&quot;.</span>
 <span class="s0">*/ 2 4 this 3 753  13 no_data_value 1 782  </span>
<span class="s0">150 0 0 4 179 716 0 0 136 /**</span>
 <span class="s0">* Removes the special value that means &quot;no data&quot; when it appears in the pfm</span>
 <span class="s0">* file.  All points will thus be considered valid.</span>
 <span class="s0">*/ 1 4 this 3 753  </span>
<span class="s0">151 0 0 6 180 702 0 0 92 /**</span>
 <span class="s0">* Returns whether a &quot;no data&quot; value has been established by</span>
 <span class="s0">* set_no_data_value().</span>
 <span class="s0">*/ 1 4 this 3 754  </span>
<span class="s0">152 0 0 6 181 702 0 0 106 /**</span>
 <span class="s0">* Returns whether a &quot;no data&quot; threshold value has been established by</span>
 <span class="s0">* set_no_data_threshold().</span>
 <span class="s0">*/ 1 4 this 3 754  </span>
<span class="s0">153 0 0 6 182 782 0 0 95 /**</span>
 <span class="s0">* If has_no_data_value() returns true, this returns the particular &quot;no data&quot;</span>
 <span class="s0">* value.</span>
 <span class="s0">*/ 1 4 this 3 754  </span>
<span class="s0">154 0 0 4 183 716 0 0 173 /**</span>
 <span class="s0">* Applies a simple filter to resample the pfm file in-place to the indicated</span>
 <span class="s0">* size.  Don't confuse this with applying a scale to all of the points via</span>
 <span class="s0">* xform().</span>
 <span class="s0">*/ 3 4 this 3 753  10 new_x_size 1 688  10 new_y_size 1 688  </span>
<span class="s0">155 0 0 4 184 716 0 0 260 /**</span>
 <span class="s0">* Makes a resized copy of the indicated image into this one using the</span>
 <span class="s0">* indicated filter.  The image to be copied is squashed and stretched to</span>
 <span class="s0">* match the dimensions of the current image, applying the appropriate filter</span>
 <span class="s0">* to perform the stretching.</span>
 <span class="s0">*/ 3 4 this 3 753  6 radius 1 704  4 copy 1 754  </span>
<span class="s0">156 0 0 4 185 716 0 0 260 /**</span>
 <span class="s0">* Makes a resized copy of the indicated image into this one using the</span>
 <span class="s0">* indicated filter.  The image to be copied is squashed and stretched to</span>
 <span class="s0">* match the dimensions of the current image, applying the appropriate filter</span>
 <span class="s0">* to perform the stretching.</span>
 <span class="s0">*/ 3 4 this 3 753  6 radius 1 704  4 copy 1 754  </span>
<span class="s0">157 0 0 4 186 716 0 0 257 /**</span>
 <span class="s0">* Resizes from the given image, with a fixed radius of 0.5. This is a very</span>
 <span class="s0">* specialized and simple algorithm that doesn't handle dropping below the</span>
 <span class="s0">* Nyquist rate very well, but is quite a bit faster than the more general</span>
 <span class="s0">* box_filter(), above.</span>
 <span class="s0">*/ 2 4 this 3 753  4 copy 1 754  </span>
<span class="s0">158 0 0 4 187 716 0 0 61 /**</span>
 <span class="s0">* Performs an in-place reversal of the row (y) data.</span>
 <span class="s0">*/ 1 4 this 3 753  </span>
<span class="s0">159 0 0 4 188 716 0 0 369 /**</span>
 <span class="s0">* Reverses, transposes, and/or rotates the table in-place according to the</span>
 <span class="s0">* specified parameters.  If flip_x is true, the x axis is reversed; if flip_y</span>
 <span class="s0">* is true, the y axis is reversed.  Then, if transpose is true, the x and y</span>
 <span class="s0">* axes are exchanged.  These parameters can be used to select any combination</span>
 <span class="s0">* of 90-degree or 180-degree rotations and flips.</span>
 <span class="s0">*/ 4 4 this 3 753  6 flip_x 1 702  6 flip_y 1 702  9 transpose 1 702  </span>
<span class="s0">160 0 0 4 189 716 0 0 73 /**</span>
 <span class="s0">* Applies the indicated transform matrix to all points in-place.</span>
 <span class="s0">*/ 2 4 this 3 753  9 transform 1 795  </span>
<span class="s0">161 0 0 4 189 716 0 0 73 /**</span>
 <span class="s0">* Applies the indicated transform matrix to all points in-place.</span>
 <span class="s0">*/ 2 4 this 3 753  9 transform 1 798  </span>
<span class="s0">162 0 0 4 190 716 0 0 659 /**</span>
 <span class="s0">* Applies the distortion indicated in the supplied dist map to the current</span>
 <span class="s0">* map.  The dist map is understood to be a mapping of points in the range</span>
 <span class="s0">* 0..1 in the first two dimensions.</span>
 <span class="s0">*</span>
 <span class="s0">* The operation can be expressed symbolically as:</span>
 <span class="s0">*</span>
 <span class="s0">* this(u, v) = this(dist(u, v))</span>
 <span class="s0">*</span>
 <span class="s0">* If scale_factor is not 1, it should be a value &gt; 1, and it specifies the</span>
 <span class="s0">* factor to upscale the working table while processing, to reduce artifacts</span>
 <span class="s0">* from integer truncation.</span>
 <span class="s0">*</span>
 <span class="s0">* By convention, the y axis is inverted in the distortion map relative to the</span>
 <span class="s0">* coordinates here.  A y value of 0 in the distortion map corresponds with a</span>
 <span class="s0">* v value of 1 in this file.</span>
 <span class="s0">*/ 3 4 this 3 753  4 dist 1 754  12 scale_factor 5 703  </span>
<span class="s0">163 0 0 4 191 716 0 0 659 /**</span>
 <span class="s0">* Applies the distortion indicated in the supplied dist map to the current</span>
 <span class="s0">* map.  The dist map is understood to be a mapping of points in the range</span>
 <span class="s0">* 0..1 in the first two dimensions.</span>
 <span class="s0">*</span>
 <span class="s0">* The operation can be expressed symbolically as:</span>
 <span class="s0">*</span>
 <span class="s0">* this(u, v) = dist(this(u, v))</span>
 <span class="s0">*</span>
 <span class="s0">* If scale_factor is not 1, it should be a value &gt; 1, and it specifies the</span>
 <span class="s0">* factor to upscale the working table while processing, to reduce artifacts</span>
 <span class="s0">* from integer truncation.</span>
 <span class="s0">*</span>
 <span class="s0">* By convention, the y axis in inverted in the distortion map relative to the</span>
 <span class="s0">* coordinates here.  A y value of 0 in the distortion map corresponds with a</span>
 <span class="s0">* v value of 1 in this file.</span>
 <span class="s0">*/ 3 4 this 3 753  4 dist 1 754  12 scale_factor 5 703  </span>
<span class="s0">164 0 0 4 192 716 0 0 211 /**</span>
 <span class="s0">* Assumes that lut is an X by 1, 1-component PfmFile whose X axis maps points</span>
 <span class="s0">* to target points.  For each point in this pfm file, computes: p(u,</span>
 <span class="s0">* v)[channel] = lut(p(u, v)[channel] * x_scale, 0)[0]</span>
 <span class="s0">*/ 4 4 this 3 753  7 channel 1 688  3 lut 1 754  7 x_scale 5 703  </span>
<span class="s0">165 0 0 4 193 716 0 0 199 /**</span>
 <span class="s0">* Wherever there is missing data in this PfmFile (that is, wherever</span>
 <span class="s0">* has_point() returns false), copy data from the other PfmFile, which must be</span>
 <span class="s0">* exactly the same dimensions as this one.</span>
 <span class="s0">*/ 2 4 this 3 753  5 other 1 754  </span>
<span class="s0">166 0 0 4 194 716 0 0 274 /**</span>
 <span class="s0">* Wherever there is missing data in the other PfmFile, set this the</span>
 <span class="s0">* corresponding point in this PfmFile to missing as well, so that this</span>
 <span class="s0">* PfmFile has only points where both files have points.</span>
 <span class="s0">*</span>
 <span class="s0">* The point is set to &quot;missing&quot; by setting it the no_data_value.</span>
 <span class="s0">*/ 2 4 this 3 753  5 other 1 754  </span>
<span class="s0">167 0 0 4 195 716 0 0 159 /**</span>
 <span class="s0">* Copies just the specified channel values from the indicated PfmFile (which</span>
 <span class="s0">* could be same as this PfmFile) into the specified channel of this one.</span>
 <span class="s0">*/ 4 4 this 3 753  10 to_channel 1 688  5 other 1 754  12 from_channel 1 688  </span>
<span class="s0">168 0 0 4 196 716 0 0 130 /**</span>
 <span class="s0">* Copies just the specified channel values from the indicated PfmFile, but</span>
 <span class="s0">* only where the other file has a data point.</span>
 <span class="s0">*/ 4 4 this 3 753  10 to_channel 1 688  5 other 1 754  12 from_channel 1 688  </span>
<span class="s0">169 0 0 4 197 716 0 0 148 /**</span>
 <span class="s0">* Reduces the PFM file to the cells in the rectangle bounded by (x_begin,</span>
 <span class="s0">* x_end, y_begin, y_end), where the _end cells are not included.</span>
 <span class="s0">*/ 5 4 this 3 753  7 x_begin 1 688  5 x_end 1 688  7 y_begin 1 688  5 y_end 1 688  </span>
<span class="s0">170 0 0 4 198 716 0 0 159 /**</span>
 <span class="s0">* Replaces this PfmFile with a new PfmFile of size x_size x y_size x 3,</span>
 <span class="s0">* containing the x y 0 values in the range 0 .. 1 according to the x y index.</span>
 <span class="s0">*/ 3 4 this 3 753  6 x_size 1 688  6 y_size 1 688  </span>
<span class="s0">171 0 0 6 199 688 0 0 262 /**</span>
 <span class="s0">* Applies delta * t to the point values within radius (xr, yr) distance of</span>
 <span class="s0">* (xc, yc).  The t value is scaled from 1.0 at the center to 0.0 at radius</span>
 <span class="s0">* (xr, yr), and this scale follows the specified exponent.  Returns the</span>
 <span class="s0">* number of points affected.</span>
 <span class="s0">*/ 7 4 this 3 753  5 delta 1 782  2 xc 1 704  2 yc 1 704  2 xr 1 704  2 yr 1 704  8 exponent 1 704  </span>
<span class="s0">172 0 0 6 200 702 0 0 209 /**</span>
 <span class="s0">* Calculates the minimum and maximum vertices of all points within the table.</span>
 <span class="s0">* Assumes the table contains 3-D points.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if any points in the table, or false if none are.</span>
 <span class="s0">*/ 3 4 this 3 754  9 min_point 1 781  9 max_point 1 781  </span>
<span class="s0">173 0 0 7 201 805 0 0 644 /**</span>
 <span class="s0">* Computes the minmax bounding volume of the points in 3-D space, assuming</span>
 <span class="s0">* the points represent a mostly-planar surface.</span>
 <span class="s0">*</span>
 <span class="s0">* This algorithm works by sampling the (square) sample_radius pixels at the</span>
 <span class="s0">* four point_dist corners around the center (cx - pd, cx + pd) and so on, to</span>
 <span class="s0">* approximate the plane of the surface.  Then all of the points are projected</span>
 <span class="s0">* into that plane and the bounding volume of the entire mesh within that</span>
 <span class="s0">* plane is determined.  If points_only is true, the bounding volume of only</span>
 <span class="s0">* those four points is determined.</span>
 <span class="s0">*</span>
 <span class="s0">* center, point_dist and sample_radius are in UV space, i.e.  in the range</span>
 <span class="s0">* 0..1.</span>
 <span class="s0">*/ 5 4 this 3 754  6 center 1 802  10 point_dist 1 703  13 sample_radius 1 703  11 points_only 1 702  </span>
<span class="s0">174 0 0 7 201 805 0 0 644 /**</span>
 <span class="s0">* Computes the minmax bounding volume of the points in 3-D space, assuming</span>
 <span class="s0">* the points represent a mostly-planar surface.</span>
 <span class="s0">*</span>
 <span class="s0">* This algorithm works by sampling the (square) sample_radius pixels at the</span>
 <span class="s0">* four point_dist corners around the center (cx - pd, cx + pd) and so on, to</span>
 <span class="s0">* approximate the plane of the surface.  Then all of the points are projected</span>
 <span class="s0">* into that plane and the bounding volume of the entire mesh within that</span>
 <span class="s0">* plane is determined.  If points_only is true, the bounding volume of only</span>
 <span class="s0">* those four points is determined.</span>
 <span class="s0">*</span>
 <span class="s0">* center, point_dist and sample_radius are in UV space, i.e.  in the range</span>
 <span class="s0">* 0..1.</span>
 <span class="s0">*/ 5 4 this 3 754  6 center 1 762  10 point_dist 1 703  13 sample_radius 1 703  11 points_only 1 702  </span>
<span class="s0">175 0 0 4 202 716 0 0 188 /**</span>
 <span class="s0">* Computes the average of all the point within sample_radius (manhattan</span>
 <span class="s0">* distance) and the indicated point.</span>
 <span class="s0">*</span>
 <span class="s0">* The point coordinates are given in UV space, in the range 0..1.</span>
 <span class="s0">*/ 5 4 this 3 754  6 result 1 781  1 x 1 703  1 y 1 703  13 sample_radius 1 703  </span>
<span class="s0">176 0 0 4 203 716 0 0 344 /**</span>
 <span class="s0">* Copies a rectangular area of another image into a rectangular area of this</span>
 <span class="s0">* image.  Both images must already have been initialized.  The upper-left</span>
 <span class="s0">* corner of the region in both images is specified, and the size of the area;</span>
 <span class="s0">* if the size is omitted, it defaults to the entire other image, or the</span>
 <span class="s0">* largest piece that will fit.</span>
 <span class="s0">*/ 8 4 this 3 753  4 copy 1 754  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  </span>
<span class="s0">177 0 0 4 204 716 0 0 155 /**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are added to the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">*/ 9 4 this 3 753  4 copy 1 754  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  11 pixel_scale 5 704  </span>
<span class="s0">178 0 0 4 205 716 0 0 160 /**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are multiplied to the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">*/ 9 4 this 3 753  4 copy 1 754  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  11 pixel_scale 5 704  </span>
<span class="s0">179 0 0 4 206 716 0 0 216 /**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are divided into the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">* dest(x, y) = dest(x, y) / (copy(x, y) * pixel_scale).</span>
 <span class="s0">*/ 9 4 this 3 753  4 copy 1 754  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  11 pixel_scale 5 704  </span>
<span class="s0">180 0 0 6 207 753 0 0 0 2 4 this 3 753  10 multiplier 1 704  </span>
<span class="s0">181 0 0 4 208 716 0 0 566 /**</span>
 <span class="s0">* index_image is a WxH 1-channel image, while pixel_values is an Nx1</span>
 <span class="s0">* image with any number of channels.  Typically pixel_values will be</span>
 <span class="s0">* a 256x1 image.</span>
 <span class="s0">*</span>
 <span class="s0">* Fills the PfmFile with a new image the same width and height as</span>
 <span class="s0">* index_image, with the same number of channels as pixel_values.</span>
 <span class="s0">*</span>
 <span class="s0">* Each pixel of the new image is computed with the formula:</span>
 <span class="s0">*</span>
 <span class="s0">* new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)</span>
 <span class="s0">*</span>
 <span class="s0">* At present, no interpolation is performed; the nearest value in</span>
 <span class="s0">* pixel_values is discovered.  This may change in the future.</span>
 <span class="s0">*/ 4 4 this 3 753  11 index_image 1 754  7 channel 1 688  12 pixel_values 1 754  </span>
<span class="s0">182 0 0 4 209 716 0 0 217 /**</span>
 <span class="s0">* Assuming the image was constructed with a gamma curve of from_gamma in the</span>
 <span class="s0">* RGB channels, converts it to an image with a gamma curve of to_gamma in the</span>
 <span class="s0">* RGB channels.  Does not affect the alpha channel.</span>
 <span class="s0">*/ 3 4 this 3 753  10 from_gamma 1 704  8 to_gamma 1 704  </span>
<span class="s0">183 0 0 4 210 716 0 0 218 /**</span>
 <span class="s0">* Assuming the image was constructed with a gamma curve of from_gamma in the</span>
 <span class="s0">* alpha channel, converts it to an image with a gamma curve of to_gamma in</span>
 <span class="s0">* the alpha channel.  Does not affect the RGB channels.</span>
 <span class="s0">*/ 3 4 this 3 753  10 from_gamma 1 704  8 to_gamma 1 704  </span>
<span class="s0">184 0 0 4 211 716 0 0 148 /**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/ 2 4 this 3 753  13 gray_exponent 1 704  </span>
<span class="s0">185 0 0 4 211 716 0 0 148 /**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/ 3 4 this 3 753  13 gray_exponent 1 704  14 alpha_exponent 1 704  </span>
<span class="s0">186 0 0 4 211 716 0 0 283 /**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.  For a</span>
 <span class="s0">* grayscale image, the blue_exponent value is used for the grayscale value,</span>
 <span class="s0">* and red_exponent and green_exponent are unused.</span>
 <span class="s0">*/ 4 4 this 3 753  11 c0_exponent 1 704  11 c1_exponent 1 704  11 c2_exponent 1 704  </span>
<span class="s0">187 0 0 4 211 716 0 0 148 /**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/ 5 4 this 3 753  11 c0_exponent 1 704  11 c1_exponent 1 704  11 c2_exponent 1 704  11 c3_exponent 1 704  </span>
<span class="s0">188 0 0 4 212 716 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 754  3 out 1 719  </span>
<span class="s0">189 0 0 38 213 806 0 0 0 1 4 this 3 754  </span>
<span class="s0">190 0 0 38 214 688 0 0 0 3 4 this 3 754  4 view 1 809  5 flags 1 688  </span>
<span class="s0">191 0 0 7 219 712 0 0 161 /**</span>
 <span class="s0">* Returns a new brush that does not paint anything.  Can be used as either a</span>
 <span class="s0">* pen or a fill brush to make borderless or unfilled shapes, respectively.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">192 0 0 7 220 712 0 0 136 /**</span>
 <span class="s0">* Returns a new brush that paints a single pixel of the indicated color on a</span>
 <span class="s0">* border, or paints a solid color in an interior.</span>
 <span class="s0">*/ 2 5 color 1 812  6 effect 5 707  </span>
<span class="s0">193 0 0 7 221 712 0 0 153 /**</span>
 <span class="s0">* Returns a new brush that paints a spot of the indicated color and radius.</span>
 <span class="s0">* If fuzzy is true, the spot is fuzzy; otherwise, it is hard-edged.</span>
 <span class="s0">*/ 4 5 color 1 812  6 radius 1 704  5 fuzzy 1 702  6 effect 5 707  </span>
<span class="s0">194 0 0 7 222 712 0 0 244 /**</span>
 <span class="s0">* Returns a new brush that paints with the indicated image.  xc and yc</span>
 <span class="s0">* indicate the pixel in the center of the brush.</span>
 <span class="s0">*</span>
 <span class="s0">* The brush makes a copy of the image; it is safe to deallocate or modify the</span>
 <span class="s0">* image after making this call.</span>
 <span class="s0">*/ 4 5 image 1 756  2 xc 1 704  2 yc 1 704  6 effect 5 707  </span>
<span class="s0">195 0 0 7 224 758 545 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">196 0 0 7 224 758 545 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 8 filename 1 733  4 type 5 685  </span>
<span class="s0">197 0 0 15 224 758 545 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 756  </span>
<span class="s0">198 0 0 7 224 758 545 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 6 6 x_size 1 688  6 y_size 1 688  12 num_channels 5 688  6 maxval 5 689  4 type 5 685  11 color_space 5 690  </span>
<span class="s0">199 0 0 6 225 758 0 0 0 2 4 this 3 758  4 copy 1 756  </span>
<span class="s0">200 0 0 6 227 689 0 0 65 /**</span>
 <span class="s0">* A handy function to clamp values to [0..get_maxval()].</span>
 <span class="s0">*/ 2 4 this 3 756  11 input_value 1 688  </span>
<span class="s0">201 0 0 7 228 818 0 0 143 /**</span>
 <span class="s0">* A handy function to scale non-alpha values from [0..1] to</span>
 <span class="s0">* [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.</span>
 <span class="s0">*/ 2 4 this 3 756  11 input_value 1 815  </span>
<span class="s0">202 0 0 6 228 689 0 0 143 /**</span>
 <span class="s0">* A handy function to scale non-alpha values from [0..1] to</span>
 <span class="s0">* [0..get_maxval()].  Do not use this for alpha values, see to_alpha_val.</span>
 <span class="s0">*/ 2 4 this 3 756  11 input_value 1 704  </span>
<span class="s0">203 0 0 6 229 689 0 0 83 /**</span>
 <span class="s0">* A handy function to scale alpha values from [0..1] to [0..get_maxval()].</span>
 <span class="s0">*/ 2 4 this 3 756  11 input_value 1 704  </span>
<span class="s0">204 0 0 7 230 819 0 0 145 /**</span>
 <span class="s0">* A handy function to scale non-alpha values from [0..get_maxval()] to</span>
 <span class="s0">* [0..1].  Do not use this for alpha values, see from_alpha_val.</span>
 <span class="s0">*/ 2 4 this 3 756  11 input_value 1 745  </span>
<span class="s0">205 0 0 6 230 704 0 0 145 /**</span>
 <span class="s0">* A handy function to scale non-alpha values from [0..get_maxval()] to</span>
 <span class="s0">* [0..1].  Do not use this for alpha values, see from_alpha_val.</span>
 <span class="s0">*/ 2 4 this 3 756  11 input_value 1 689  </span>
<span class="s0">206 0 0 6 231 704 0 0 83 /**</span>
 <span class="s0">* A handy function to scale alpha values from [0..get_maxval()] to [0..1].</span>
 <span class="s0">*/ 2 4 this 3 756  11 input_value 1 689  </span>
<span class="s0">207 0 0 4 232 716 0 0 111 /**</span>
 <span class="s0">* Frees all memory allocated for the image, and clears all its parameters</span>
 <span class="s0">* (size, color, type, etc).</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">208 0 0 4 232 716 0 0 113 /**</span>
 <span class="s0">* This flavor of clear() reinitializes the image to an empty (black) image</span>
 <span class="s0">* with the given dimensions.</span>
 <span class="s0">*/ 7 4 this 3 758  6 x_size 1 688  6 y_size 1 688  12 num_channels 5 688  6 maxval 5 689  4 type 5 685  11 color_space 5 690  </span>
<span class="s0">209 0 0 4 233 716 0 0 61 /**</span>
 <span class="s0">* Makes this image become a copy of the other image.</span>
 <span class="s0">*/ 2 4 this 3 758  4 copy 1 756  </span>
<span class="s0">210 0 0 4 234 716 0 0 86 /**</span>
 <span class="s0">* Copies a channel from one image into another.  Images must be the same size</span>
 <span class="s0">*/ 4 4 this 3 758  4 copy 1 756  11 src_channel 1 688  12 dest_channel 1 688  </span>
<span class="s0">211 0 0 4 234 716 0 0 139 /**</span>
 <span class="s0">* Copies just a single channel from the source image into a single channel of</span>
 <span class="s0">* this image, leaving the remaining channels alone.</span>
 <span class="s0">*/ 10 4 this 3 758  4 copy 1 756  3 xto 1 688  3 yto 1 688  3 cto 1 688  5 xfrom 5 688  5 yfrom 5 688  5 cfrom 5 688  6 x_size 5 688  6 y_size 5 688  </span>
<span class="s0">212 0 0 4 235 716 0 0 247 /**</span>
 <span class="s0">* Copies some subset of the bits of the specified channel from one image into</span>
 <span class="s0">* some subset of the bits of the specified channel in another image.  Images</span>
 <span class="s0">* must be the same size.</span>
 <span class="s0">*</span>
 <span class="s0">* If right_shift is negative, it means a left shift.</span>
 <span class="s0">*/ 6 4 this 3 758  4 copy 1 756  11 src_channel 1 688  12 dest_channel 1 688  8 src_mask 1 689  11 right_shift 1 688  </span>
<span class="s0">213 0 0 4 236 716 0 0 186 /**</span>
 <span class="s0">* Copies just the header information into this image.  This will blow away</span>
 <span class="s0">* any image data stored in the image.  The new image data will be allocated,</span>
 <span class="s0">* but left unitialized.</span>
 <span class="s0">*/ 2 4 this 3 758  6 header 1 730  </span>
<span class="s0">214 0 0 4 237 716 0 0 92 /**</span>
 <span class="s0">* Move the contents of the other image into this one, and empty the other</span>
 <span class="s0">* image.</span>
 <span class="s0">*/ 2 4 this 3 758  4 orig 1 758  </span>
<span class="s0">215 0 0 4 238 716 0 0 92 /**</span>
 <span class="s0">* Sets the entire image (except the alpha channel) to the given grayscale</span>
 <span class="s0">* level.</span>
 <span class="s0">*/ 2 4 this 3 758  4 gray 5 704  </span>
<span class="s0">216 0 0 4 238 716 0 0 79 /**</span>
 <span class="s0">* Sets the entire image (except the alpha channel) to the given color.</span>
 <span class="s0">*/ 4 4 this 3 758  3 red 1 704  5 green 1 704  4 blue 1 704  </span>
<span class="s0">217 0 0 4 239 716 0 0 92 /**</span>
 <span class="s0">* Sets the entire image (except the alpha channel) to the given grayscale</span>
 <span class="s0">* level.</span>
 <span class="s0">*/ 2 4 this 3 758  4 gray 5 689  </span>
<span class="s0">218 0 0 4 239 716 0 0 79 /**</span>
 <span class="s0">* Sets the entire image (except the alpha channel) to the given color.</span>
 <span class="s0">*/ 4 4 this 3 758  3 red 1 689  5 green 1 689  4 blue 1 689  </span>
<span class="s0">219 0 0 4 240 716 0 0 60 /**</span>
 <span class="s0">* Sets the entire alpha channel to the given level.</span>
 <span class="s0">*/ 2 4 this 3 758  5 alpha 5 704  </span>
<span class="s0">220 0 0 4 241 716 0 0 60 /**</span>
 <span class="s0">* Sets the entire alpha channel to the given level.</span>
 <span class="s0">*/ 2 4 this 3 758  5 alpha 5 689  </span>
<span class="s0">221 0 0 4 242 716 0 0 513 /**</span>
 <span class="s0">* Specifies the size to we'd like to scale the image upon reading it.  This</span>
 <span class="s0">* will affect the next call to read().  This is usually used to reduce the</span>
 <span class="s0">* image size, e.g.  for a thumbnail.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file type reader supports it (e.g.  JPEG), then this will scale the</span>
 <span class="s0">* image during the read operation, consequently reducing memory and CPU</span>
 <span class="s0">* utilization.  If the file type reader does not support it, this will load</span>
 <span class="s0">* the image normally, and them perform a linear scale after it has been</span>
 <span class="s0">* loaded.</span>
 <span class="s0">*/ 3 4 this 3 758  6 x_size 1 688  6 y_size 1 688  </span>
<span class="s0">222 0 0 4 243 716 0 0 67 /**</span>
 <span class="s0">* Undoes the effect of a previous call to set_read_size().</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">223 0 0 6 244 702 0 0 59 /**</span>
 <span class="s0">* Returns true if set_read_size() has been called.</span>
 <span class="s0">*/ 1 4 this 3 756  </span>
<span class="s0">224 0 0 6 245 688 0 0 139 /**</span>
 <span class="s0">* Returns the requested x_size of the image if set_read_size() has been</span>
 <span class="s0">* called, or the image x_size otherwise (if it is known).</span>
 <span class="s0">*/ 1 4 this 3 756  </span>
<span class="s0">225 0 0 6 246 688 0 0 139 /**</span>
 <span class="s0">* Returns the requested y_size of the image if set_read_size() has been</span>
 <span class="s0">* called, or the image y_size otherwise (if it is known).</span>
 <span class="s0">*/ 1 4 this 3 756  </span>
<span class="s0">226 0 0 6 247 690 0 0 65 /**</span>
 <span class="s0">* Returns the color space in which the image is encoded.</span>
 <span class="s0">*/ 1 4 this 3 756  </span>
<span class="s0">227 0 0 6 248 702 0 0 166 /**</span>
 <span class="s0">* Reads the indicated image filename.  If type is non-NULL, it is a</span>
 <span class="s0">* suggestion for the type of file it is.  Returns true if successful, false</span>
 <span class="s0">* on error.</span>
 <span class="s0">*/ 4 4 this 3 758  8 filename 1 733  4 type 5 685  19 report_unknown_type 5 702  </span>
<span class="s0">228 0 0 6 248 702 0 0 382 /**</span>
 <span class="s0">* This flavor of read() uses an already-existing PNMReader to read the image</span>
 <span class="s0">* file.  You can get a reader via the PNMImageHeader::make_reader() methods.</span>
 <span class="s0">* This is a good way to examine the header of a file (for instance, to</span>
 <span class="s0">* determine its size) before actually reading the entire image.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMReader is always deleted upon completion, whether successful or not.</span>
 <span class="s0">*/ 2 4 this 3 758  6 reader 1 738  </span>
<span class="s0">229 0 0 6 248 702 0 0 378 /**</span>
 <span class="s0">* Reads the image data from the indicated stream.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is advisory only, and may be used to suggest a type if it has</span>
 <span class="s0">* a known extension.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the type of file it is (and a</span>
 <span class="s0">* non-NULL type will override any magic number test or filename extension</span>
 <span class="s0">* lookup).</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false on error.</span>
 <span class="s0">*/ 5 4 this 3 758  4 data 1 736  8 filename 5 723  4 type 5 685  19 report_unknown_type 5 702  </span>
<span class="s0">230 0 0 6 249 702 0 0 135 /**</span>
 <span class="s0">* Writes the image to the indicated filename.  If type is non-NULL, it is a</span>
 <span class="s0">* suggestion for the type of image file to write.</span>
 <span class="s0">*/ 3 4 this 3 756  8 filename 1 733  4 type 5 685  </span>
<span class="s0">231 0 0 6 249 702 0 0 250 /**</span>
 <span class="s0">* This flavor of write() uses an already-existing PNMWriter to write the</span>
 <span class="s0">* image file.  You can get a writer via the PNMImageHeader::make_writer()</span>
 <span class="s0">* methods.</span>
 <span class="s0">*</span>
 <span class="s0">* The PNMWriter is always deleted upon completion, whether successful or not.</span>
 <span class="s0">*/ 2 4 this 3 756  6 writer 1 740  </span>
<span class="s0">232 0 0 6 249 702 0 0 239 /**</span>
 <span class="s0">* Writes the image to the indicated ostream.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is advisory only, and may be used suggest a type if it has a</span>
 <span class="s0">* known extension.</span>
 <span class="s0">*</span>
 <span class="s0">* If type is non-NULL, it is a suggestion for the type of image file to</span>
 <span class="s0">* write.</span>
 <span class="s0">*/ 4 4 this 3 756  4 data 1 719  8 filename 5 723  4 type 5 685  </span>
<span class="s0">233 0 0 6 250 702 0 0 218 /**</span>
 <span class="s0">* Returns true if the image has been read in or correctly initialized with a</span>
 <span class="s0">* height and width.  If this returns false, virtually all member functions</span>
 <span class="s0">* except clear() and read() are invalid function calls.</span>
 <span class="s0">*/ 1 4 this 3 756  </span>
<span class="s0">234 0 0 4 251 716 0 0 257 /**</span>
 <span class="s0">* Changes the number of channels associated with the image.  The new number</span>
 <span class="s0">* of channels must be an integer in the range 1 through 4, inclusive.  This</span>
 <span class="s0">* will allocate and/or deallocate memory as necessary to accommodate; see</span>
 <span class="s0">* set_color_type().</span>
 <span class="s0">*/ 2 4 this 3 758  12 num_channels 1 688  </span>
<span class="s0">235 0 0 4 252 716 0 0 319 /**</span>
 <span class="s0">* Translates the image to or from grayscale, color, or four-color mode.</span>
 <span class="s0">* Grayscale images are converted to full-color images with R, G, B set to the</span>
 <span class="s0">* original gray level; color images are converted to grayscale according to</span>
 <span class="s0">* the value of Bright().  The alpha channel, if added, is initialized to</span>
 <span class="s0">* zero.</span>
 <span class="s0">*/ 2 4 this 3 758  10 color_type 1 687  </span>
<span class="s0">236 0 0 4 253 716 0 0 634 /**</span>
 <span class="s0">* Converts the colors in the image to the indicated color space.  This may be</span>
 <span class="s0">* a lossy operation, in particular when going from sRGB to linear.  The alpha</span>
 <span class="s0">* channel remains untouched.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that, because functions like get_xel() and set_xel() work on</span>
 <span class="s0">* linearized floating-point values, this conversion won't affect those values</span>
 <span class="s0">* (aside from some minor discrepancies due to storage precision).  It does</span>
 <span class="s0">* affect the values used by get_xel_val() and set_xel_val(), though, since</span>
 <span class="s0">* those operate on encoded colors.</span>
 <span class="s0">*</span>
 <span class="s0">* Some color spaces, particularly scRGB, may enforce the use of a particular</span>
 <span class="s0">* maxval setting.</span>
 <span class="s0">*/ 2 4 this 3 758  11 color_space 1 690  </span>
<span class="s0">237 0 0 4 254 716 0 0 126 /**</span>
 <span class="s0">* Adds an alpha channel to the image, if it does not already have one.  The</span>
 <span class="s0">* alpha channel is initialized to zeros.</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">238 0 0 4 255 716 0 0 59 /**</span>
 <span class="s0">* Removes the image's alpha channel, if it exists.</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">239 0 0 4 256 716 0 0 108 /**</span>
 <span class="s0">* Converts the image from RGB to grayscale.  Any alpha channel, if present,</span>
 <span class="s0">* is left undisturbed.</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">240 0 0 4 256 716 0 0 227 /**</span>
 <span class="s0">* Converts the image from RGB to grayscale.  Any alpha channel, if present,</span>
 <span class="s0">* is left undisturbed.  The optional rc, gc, bc values represent the relative</span>
 <span class="s0">* weights to apply to each channel to convert it to grayscale.</span>
 <span class="s0">*/ 4 4 this 3 758  2 rc 1 704  2 gc 1 704  2 bc 1 704  </span>
<span class="s0">241 0 0 4 257 716 0 0 108 /**</span>
 <span class="s0">* Converts the image from grayscale to RGB.  Any alpha channel, if present,</span>
 <span class="s0">* is left undisturbed.</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">242 0 0 4 258 716 0 0 234 /**</span>
 <span class="s0">* Converts an image in-place to its &quot;premultiplied&quot; form, where, for every</span>
 <span class="s0">* pixel in the image, the red, green, and blue components are multiplied by</span>
 <span class="s0">* that pixel's alpha value.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not modify any alpha values.</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">243 0 0 4 259 716 0 0 273 /**</span>
 <span class="s0">* Converts an image in-place to its &quot;straight alpha&quot; form (presumably from a</span>
 <span class="s0">* &quot;premultiplied&quot; form), where, for every pixel in the image, the red, green,</span>
 <span class="s0">* and blue components are divided by that pixel's alpha value.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not modify any alpha values.</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">244 0 0 4 260 716 0 0 61 /**</span>
 <span class="s0">* Performs an in-place reversal of the row (y) data.</span>
 <span class="s0">*/ 1 4 this 3 758  </span>
<span class="s0">245 0 0 4 261 716 0 0 369 /**</span>
 <span class="s0">* Reverses, transposes, and/or rotates the image in-place according to the</span>
 <span class="s0">* specified parameters.  If flip_x is true, the x axis is reversed; if flip_y</span>
 <span class="s0">* is true, the y axis is reversed.  Then, if transpose is true, the x and y</span>
 <span class="s0">* axes are exchanged.  These parameters can be used to select any combination</span>
 <span class="s0">* of 90-degree or 180-degree rotations and flips.</span>
 <span class="s0">*/ 4 4 this 3 758  6 flip_x 1 702  6 flip_y 1 702  9 transpose 1 702  </span>
<span class="s0">246 0 0 4 262 716 0 0 54 /**</span>
 <span class="s0">* Rescales the image to the indicated maxval.</span>
 <span class="s0">*/ 2 4 this 3 758  6 maxval 1 689  </span>
<span class="s0">247 0 0 6 263 818 0 0 102 /**</span>
 <span class="s0">* Returns the RGB color at the indicated pixel.  Each component is in the</span>
 <span class="s0">* range 0..maxval.</span>
 <span class="s0">*/ 3 4 this 3 758  1 x 1 688  1 y 1 688  </span>
<span class="s0">248 0 0 7 263 818 0 0 102 /**</span>
 <span class="s0">* Returns the RGB color at the indicated pixel.  Each component is in the</span>
 <span class="s0">* range 0..maxval.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">249 0 0 4 264 716 0 0 227 /**</span>
 <span class="s0">* Changes the RGB color at the indicated pixel.  Each component is in the</span>
 <span class="s0">* range 0..maxval, encoded in the configured color space.  See set_xel if you</span>
 <span class="s0">* instead have a linearized and normalized floating-point value.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  5 value 1 745  </span>
<span class="s0">250 0 0 4 264 716 0 0 282 /**</span>
 <span class="s0">* Changes all three color components at the indicated pixel to the same</span>
 <span class="s0">* value.  The value is in the range component is in the range 0..maxval,</span>
 <span class="s0">* encoded in the configured color space.  See set_xel if you instead have a</span>
 <span class="s0">* linearized and normalized floating-point value.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  4 gray 1 689  </span>
<span class="s0">251 0 0 4 264 716 0 0 227 /**</span>
 <span class="s0">* Changes the RGB color at the indicated pixel.  Each component is in the</span>
 <span class="s0">* range 0..maxval, encoded in the configured color space.  See set_xel if you</span>
 <span class="s0">* instead have a linearized and normalized floating-point value.</span>
 <span class="s0">*/ 6 4 this 3 758  1 x 1 688  1 y 1 688  1 r 1 689  1 g 1 689  1 b 1 689  </span>
<span class="s0">252 0 0 6 265 689 0 0 158 /**</span>
 <span class="s0">* Returns the red component color at the indicated pixel.  The value returned</span>
 <span class="s0">* is in the range 0..maxval and encoded in the configured color space.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">253 0 0 6 266 689 0 0 163 /**</span>
 <span class="s0">* Returns the green component color at the indicated pixel.  The value</span>
 <span class="s0">* returned is in the range 0..maxval and encoded in the configured color</span>
 <span class="s0">* space.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">254 0 0 6 267 689 0 0 162 /**</span>
 <span class="s0">* Returns the blue component color at the indicated pixel.  The value</span>
 <span class="s0">* returned is in the range 0..maxval and encoded in the configured color</span>
 <span class="s0">* space.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">255 0 0 6 268 689 0 0 342 /**</span>
 <span class="s0">* Returns the gray component color at the indicated pixel.  This only has a</span>
 <span class="s0">* meaningful value for grayscale images; for other image types, this returns</span>
 <span class="s0">* the value of the blue channel only.  However, also see the get_bright()</span>
 <span class="s0">* function.  The value returned is in the range 0..maxval and encoded in the</span>
 <span class="s0">* configured color space.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">256 0 0 6 269 689 0 0 196 /**</span>
 <span class="s0">* Returns the alpha component color at the indicated pixel.  It is an error</span>
 <span class="s0">* to call this unless has_alpha() is true.  The value returned is in the</span>
 <span class="s0">* range 0..maxval and always linear.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">257 0 0 4 270 716 0 0 249 /**</span>
 <span class="s0">* Sets the red component color only at the indicated pixel.  The value given</span>
 <span class="s0">* should be in the range 0..maxval, encoded in the configured color space.</span>
 <span class="s0">* See set_red if you instead have a linearized and normalized floating-point</span>
 <span class="s0">* value.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  1 r 1 689  </span>
<span class="s0">258 0 0 4 271 716 0 0 254 /**</span>
 <span class="s0">* Sets the green component color only at the indicated pixel.  The value</span>
 <span class="s0">* given should be in the range 0..maxval, encoded in the configured color</span>
 <span class="s0">* space.  See set_green if you instead have a linearized and normalized</span>
 <span class="s0">* floating-point value.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  1 g 1 689  </span>
<span class="s0">259 0 0 4 272 716 0 0 251 /**</span>
 <span class="s0">* Sets the blue component color only at the indicated pixel.  The value given</span>
 <span class="s0">* should be in the range 0..maxval, encoded in the configured color space.</span>
 <span class="s0">* See set_blue if you instead have a linearized and normalized floating-point</span>
 <span class="s0">* value.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  1 b 1 689  </span>
<span class="s0">260 0 0 4 273 716 0 0 530 /**</span>
 <span class="s0">* Sets the gray component color at the indicated pixel.  This is only</span>
 <span class="s0">* meaningful for grayscale images; for other image types, this simply sets</span>
 <span class="s0">* the blue component color.  However, also see set_xel_val(), which can set</span>
 <span class="s0">* all the component colors to the same grayscale level, and hence works</span>
 <span class="s0">* correctly both for grayscale and color images.  The value given should be</span>
 <span class="s0">* in the range 0..maxval, encoded in the configured color space.  See</span>
 <span class="s0">* set_gray if you instead have a linearized normalized floating-point value.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  4 gray 1 689  </span>
<span class="s0">261 0 0 4 274 716 0 0 282 /**</span>
 <span class="s0">* Sets the alpha component color only at the indicated pixel.  It is an error</span>
 <span class="s0">* to call this unless has_alpha() is true.  The value given should be in the</span>
 <span class="s0">* range 0..maxval.</span>
 <span class="s0">*</span>
 <span class="s0">* This value is always linearly encoded, even if the image is set to the sRGB</span>
 <span class="s0">* color space.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  1 a 1 689  </span>
<span class="s0">262 0 0 6 275 689 0 0 326 /**</span>
 <span class="s0">* Returns the nth component color at the indicated pixel.  The channel index</span>
 <span class="s0">* should be in the range 0..(get_num_channels()-1).  The channels are ordered</span>
 <span class="s0">* B, G, R, A.  This is slightly less optimal than accessing the component</span>
 <span class="s0">* values directly by named methods.  The value returned is in the range</span>
 <span class="s0">* 0..maxval.</span>
 <span class="s0">*/ 4 4 this 3 756  1 x 1 688  1 y 1 688  7 channel 1 688  </span>
<span class="s0">263 0 0 4 276 716 0 0 325 /**</span>
 <span class="s0">* Sets the nth component color at the indicated pixel.  The channel index</span>
 <span class="s0">* should be in the range 0..(get_num_channels()-1).  The channels are ordered</span>
 <span class="s0">* B, G, R, A.  This is slightly less optimal than setting the component</span>
 <span class="s0">* values directly by named methods.  The value given should be in the range</span>
 <span class="s0">* 0..maxval.</span>
 <span class="s0">*/ 5 4 this 3 758  1 x 1 688  1 y 1 688  7 channel 1 688  5 value 1 689  </span>
<span class="s0">264 0 0 6 277 704 0 0 329 /**</span>
 <span class="s0">* Returns the nth component color at the indicated pixel.  The channel index</span>
 <span class="s0">* should be in the range 0..(get_num_channels()-1).  The channels are ordered</span>
 <span class="s0">* B, G, R, A.  This is slightly less optimal than accessing the component</span>
 <span class="s0">* values directly by named methods.  The value returned is a float in the</span>
 <span class="s0">* range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 756  1 x 1 688  1 y 1 688  7 channel 1 688  </span>
<span class="s0">265 0 0 4 278 716 0 0 328 /**</span>
 <span class="s0">* Sets the nth component color at the indicated pixel.  The channel index</span>
 <span class="s0">* should be in the range 0..(get_num_channels()-1).  The channels are ordered</span>
 <span class="s0">* B, G, R, A.  This is slightly less optimal than setting the component</span>
 <span class="s0">* values directly by named methods.  The value given should be a float in the</span>
 <span class="s0">* range 0..1.</span>
 <span class="s0">*/ 5 4 this 3 758  1 x 1 688  1 y 1 688  7 channel 1 688  5 value 1 704  </span>
<span class="s0">266 0 0 7 279 744 447 0 100 /**</span>
 <span class="s0">* Returns the (r, g, b, a) pixel value at the indicated pixel, using a</span>
 <span class="s0">* PixelSpec object.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">267 0 0 4 280 716 0 0 97 /**</span>
 <span class="s0">* Sets the (r, g, b, a) pixel value at the indicated pixel, using a PixelSpec</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  5 pixel 1 742  </span>
<span class="s0">268 0 0 7 281 819 0 0 116 /**</span>
 <span class="s0">* Returns the RGB color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">269 0 0 4 282 716 0 0 116 /**</span>
 <span class="s0">* Changes the RGB color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  5 value 1 815  </span>
<span class="s0">270 0 0 4 282 716 0 0 142 /**</span>
 <span class="s0">* Changes all three color components at the indicated pixel to the same</span>
 <span class="s0">* value.  The value is a linearized float in the range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  4 gray 1 704  </span>
<span class="s0">271 0 0 4 282 716 0 0 116 /**</span>
 <span class="s0">* Changes the RGB color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/ 6 4 this 3 758  1 x 1 688  1 y 1 688  1 r 1 704  1 g 1 704  1 b 1 704  </span>
<span class="s0">272 0 0 7 283 820 0 0 117 /**</span>
 <span class="s0">* Returns the RGBA color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">273 0 0 4 284 716 0 0 117 /**</span>
 <span class="s0">* Changes the RGBA color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  5 value 1 812  </span>
<span class="s0">274 0 0 4 284 716 0 0 117 /**</span>
 <span class="s0">* Changes the RGBA color at the indicated pixel.  Each component is a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/ 7 4 this 3 758  1 x 1 688  1 y 1 688  1 r 1 704  1 g 1 704  1 b 1 704  1 a 1 704  </span>
<span class="s0">275 0 0 6 285 704 0 0 130 /**</span>
 <span class="s0">* Returns the red component color at the indicated pixel.  The value returned</span>
 <span class="s0">* is a linearized float in the range 0..1.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">276 0 0 6 286 704 0 0 132 /**</span>
 <span class="s0">* Returns the green component color at the indicated pixel.  The value</span>
 <span class="s0">* returned is a linearized float in the range 0..1.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">277 0 0 6 287 704 0 0 131 /**</span>
 <span class="s0">* Returns the blue component color at the indicated pixel.  The value</span>
 <span class="s0">* returned is a linearized float in the range 0..1.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">278 0 0 6 288 704 0 0 311 /**</span>
 <span class="s0">* Returns the gray component color at the indicated pixel.  This only has a</span>
 <span class="s0">* meaningful value for grayscale images; for other image types, this returns</span>
 <span class="s0">* the value of the blue channel only.  However, also see the get_bright()</span>
 <span class="s0">* function.  The value returned is a linearized float in the range 0..1.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">279 0 0 6 289 704 0 0 181 /**</span>
 <span class="s0">* Returns the alpha component color at the indicated pixel.  It is an error</span>
 <span class="s0">* to call this unless has_alpha() is true.  The value returned is a float in</span>
 <span class="s0">* the range 0..1.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">280 0 0 4 290 716 0 0 136 /**</span>
 <span class="s0">* Sets the red component color only at the indicated pixel.  The value given</span>
 <span class="s0">* should be a linearized float in the range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  1 r 1 704  </span>
<span class="s0">281 0 0 4 291 716 0 0 138 /**</span>
 <span class="s0">* Sets the green component color only at the indicated pixel.  The value</span>
 <span class="s0">* given should be a linearized float in the range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  1 g 1 704  </span>
<span class="s0">282 0 0 4 292 716 0 0 137 /**</span>
 <span class="s0">* Sets the blue component color only at the indicated pixel.  The value given</span>
 <span class="s0">* should be a linearized float in the range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  1 b 1 704  </span>
<span class="s0">283 0 0 4 293 716 0 0 418 /**</span>
 <span class="s0">* Sets the gray component color at the indicated pixel.  This is only</span>
 <span class="s0">* meaningful for grayscale images; for other image types, this simply sets</span>
 <span class="s0">* the blue component color.  However, also see set_xel(), which can set all</span>
 <span class="s0">* the component colors to the same grayscale level, and hence works correctly</span>
 <span class="s0">* both for grayscale and color images.  The value given should be a</span>
 <span class="s0">* linearized float in the range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  4 gray 1 704  </span>
<span class="s0">284 0 0 4 294 716 0 0 179 /**</span>
 <span class="s0">* Sets the alpha component color only at the indicated pixel.  It is an error</span>
 <span class="s0">* to call this unless has_alpha() is true.  The value given should be in the</span>
 <span class="s0">* range 0..1.</span>
 <span class="s0">*/ 4 4 this 3 758  1 x 1 688  1 y 1 688  1 a 1 704  </span>
<span class="s0">285 0 0 6 295 704 0 0 223 /**</span>
 <span class="s0">* Returns the linear brightness of the given xel, as a linearized float in</span>
 <span class="s0">* the range 0..1.  This flavor of get_bright() returns the correct grayscale</span>
 <span class="s0">* brightness level for both full-color and grayscale images.</span>
 <span class="s0">*/ 3 4 this 3 756  1 x 1 688  1 y 1 688  </span>
<span class="s0">286 0 0 6 295 704 0 0 213 /**</span>
 <span class="s0">* This flavor of get_bright() works correctly only for color images.  It</span>
 <span class="s0">* returns a single brightness value for the RGB color at the indicated pixel,</span>
 <span class="s0">* based on the supplied weights for each component.</span>
 <span class="s0">*/ 6 4 this 3 756  1 x 1 688  1 y 1 688  2 rc 1 704  2 gc 1 704  2 bc 1 704  </span>
<span class="s0">287 0 0 6 295 704 0 0 220 /**</span>
 <span class="s0">* This flavor of get_bright() works correctly only for four-channel images.</span>
 <span class="s0">* It returns a single brightness value for the RGBA color at the indicated</span>
 <span class="s0">* pixel, based on the supplied weights for each component.</span>
 <span class="s0">*/ 7 4 this 3 756  1 x 1 688  1 y 1 688  2 rc 1 704  2 gc 1 704  2 bc 1 704  2 ac 1 704  </span>
<span class="s0">288 0 0 4 296 716 0 0 276 /**</span>
 <span class="s0">* Smoothly blends the indicated pixel value in with whatever was already in</span>
 <span class="s0">* the image, based on the given alpha value.  An alpha of 1.0 is fully opaque</span>
 <span class="s0">* and completely replaces whatever was there previously; alpha of 0.0 is</span>
 <span class="s0">* fully transparent and does nothing.</span>
 <span class="s0">*/ 5 4 this 3 758  1 x 1 688  1 y 1 688  3 val 1 815  5 alpha 1 704  </span>
<span class="s0">289 0 0 4 296 716 0 0 276 /**</span>
 <span class="s0">* Smoothly blends the indicated pixel value in with whatever was already in</span>
 <span class="s0">* the image, based on the given alpha value.  An alpha of 1.0 is fully opaque</span>
 <span class="s0">* and completely replaces whatever was there previously; alpha of 0.0 is</span>
 <span class="s0">* fully transparent and does nothing.</span>
 <span class="s0">*/ 7 4 this 3 758  1 x 1 688  1 y 1 688  1 r 1 704  1 g 1 704  1 b 1 704  5 alpha 1 704  </span>
<span class="s0">290 0 0 4 297 716 0 0 344 /**</span>
 <span class="s0">* Copies a rectangular area of another image into a rectangular area of this</span>
 <span class="s0">* image.  Both images must already have been initialized.  The upper-left</span>
 <span class="s0">* corner of the region in both images is specified, and the size of the area;</span>
 <span class="s0">* if the size is omitted, it defaults to the entire other image, or the</span>
 <span class="s0">* largest piece that will fit.</span>
 <span class="s0">*/ 8 4 this 3 758  4 copy 1 756  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  </span>
<span class="s0">291 0 0 4 298 716 0 0 438 /**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the alpha channel of the copy is used</span>
 <span class="s0">* to blend the copy into the destination image, instead of overwriting pixels</span>
 <span class="s0">* unconditionally.</span>
 <span class="s0">*</span>
 <span class="s0">* If pixel_scale is not 1.0, it specifies an amount to scale each *alpha*</span>
 <span class="s0">* value of the source image before applying it to the target image.</span>
 <span class="s0">*</span>
 <span class="s0">* If pixel_scale is 1.0 and the copy has no alpha channel, this degenerates</span>
 <span class="s0">* into copy_sub_image().</span>
 <span class="s0">*/ 9 4 this 3 758  4 copy 1 756  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  11 pixel_scale 5 704  </span>
<span class="s0">292 0 0 4 299 716 0 0 228 /**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are added to the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">* Unlike blend_sub_image(), the alpha channel is not treated specially.</span>
 <span class="s0">*/ 9 4 this 3 758  4 copy 1 756  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  11 pixel_scale 5 704  </span>
<span class="s0">293 0 0 4 300 716 0 0 233 /**</span>
 <span class="s0">* Behaves like copy_sub_image(), except the copy pixels are multiplied to the</span>
 <span class="s0">* pixels of the destination, after scaling by the specified pixel_scale.</span>
 <span class="s0">* Unlike blend_sub_image(), the alpha channel is not treated specially.</span>
 <span class="s0">*/ 9 4 this 3 758  4 copy 1 756  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  11 pixel_scale 5 704  </span>
<span class="s0">294 0 0 4 301 716 0 0 437 /**</span>
 <span class="s0">* Behaves like copy_sub_image(), but the resulting color will be the darker</span>
 <span class="s0">* of the source and destination colors at each pixel (and at each R, G, B, A</span>
 <span class="s0">* component value).</span>
 <span class="s0">*</span>
 <span class="s0">* If pixel_scale is not 1.0, it specifies an amount to scale each pixel value</span>
 <span class="s0">* of the source image before applying it to the target image.  The scale is</span>
 <span class="s0">* applied with the center at 1.0: scaling the pixel value smaller brings it</span>
 <span class="s0">* closer to 1.0.</span>
 <span class="s0">*/ 9 4 this 3 758  4 copy 1 756  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  11 pixel_scale 5 704  </span>
<span class="s0">295 0 0 4 302 716 0 0 329 /**</span>
 <span class="s0">* Behaves like copy_sub_image(), but the resulting color will be the lighter</span>
 <span class="s0">* of the source and destination colors at each pixel (and at each R, G, B, A</span>
 <span class="s0">* component value).</span>
 <span class="s0">*</span>
 <span class="s0">* If pixel_scale is not 1.0, it specifies an amount to scale each pixel value</span>
 <span class="s0">* of the source image before applying it to the target image.</span>
 <span class="s0">*/ 9 4 this 3 758  4 copy 1 756  3 xto 1 688  3 yto 1 688  5 xfrom 5 688  5 yfrom 5 688  6 x_size 5 688  6 y_size 5 688  11 pixel_scale 5 704  </span>
<span class="s0">296 0 0 4 303 716 0 0 620 /**</span>
 <span class="s0">* Selectively copies each pixel from either one source or another source,</span>
 <span class="s0">* depending on the pixel value of the indicated channel of select_image.</span>
 <span class="s0">*</span>
 <span class="s0">* For each pixel (x, y):</span>
 <span class="s0">*</span>
 <span class="s0">* s = select_image.get_channel(x, y, channel). Set this image's (x, y) to:</span>
 <span class="s0">*</span>
 <span class="s0">* lt.get_xel(x, y) if s &lt; threshold, or</span>
 <span class="s0">*</span>
 <span class="s0">* ge.get_xel(x, y) if s &gt;= threshold</span>
 <span class="s0">*</span>
 <span class="s0">* Any of select_image, lt, or ge may be the same PNMImge object as this</span>
 <span class="s0">* image, or the same as each other; or they may all be different.  All images</span>
 <span class="s0">* must be the same size.  As a special case, lt and ge may both be 1x1 images</span>
 <span class="s0">* instead of the source image size.</span>
 <span class="s0">*/ 6 4 this 3 758  12 select_image 1 756  7 channel 1 688  9 threshold 1 704  2 lt 1 756  2 ge 1 756  </span>
<span class="s0">297 0 0 4 304 716 0 0 790 /**</span>
 <span class="s0">* Replaces this image with a grayscale image whose gray channel represents</span>
 <span class="s0">* the linear Manhattan distance from the nearest dark pixel in the given mask</span>
 <span class="s0">* image, up to the specified radius value (which also becomes the new</span>
 <span class="s0">* maxval).  radius may range from 0 to maxmaxval; smaller values will compute</span>
 <span class="s0">* faster.  A dark pixel is defined as one whose pixel value is &lt; threshold.</span>
 <span class="s0">*</span>
 <span class="s0">* If shrink_from_border is true, then the mask image is considered to be</span>
 <span class="s0">* surrounded by a border of dark pixels; otherwise, the border isn't</span>
 <span class="s0">* considered.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used, in conjunction with threshold, to shrink a mask image</span>
 <span class="s0">* inwards by a certain number of pixels.</span>
 <span class="s0">*</span>
 <span class="s0">* The mask image may be the same image as this one, in which case it is</span>
 <span class="s0">* destructively modified by this process.</span>
 <span class="s0">*/ 5 4 this 3 758  4 mask 1 756  9 threshold 1 704  6 radius 1 688  18 shrink_from_border 1 702  </span>
<span class="s0">298 0 0 4 305 716 0 0 630 /**</span>
 <span class="s0">* Replaces this image with a grayscale image whose gray channel represents</span>
 <span class="s0">* the linear Manhattan distance from the nearest white pixel in the given</span>
 <span class="s0">* mask image, up to the specified radius value (which also becomes the new</span>
 <span class="s0">* maxval).  radius may range from 0 to maxmaxval; smaller values will compute</span>
 <span class="s0">* faster.  A white pixel is defined as one whose pixel value is &gt;= threshold.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used, in conjunction with threshold, to grow a mask image</span>
 <span class="s0">* outwards by a certain number of pixels.</span>
 <span class="s0">*</span>
 <span class="s0">* The mask image may be the same image as this one, in which case it is</span>
 <span class="s0">* destructively modified by this process.</span>
 <span class="s0">*/ 4 4 this 3 758  4 mask 1 756  9 threshold 1 704  6 radius 1 688  </span>
<span class="s0">299 0 0 4 306 716 0 0 557 /**</span>
 <span class="s0">* index_image is a WxH grayscale image, while pixel_values is an Nx1 color</span>
 <span class="s0">* (or grayscale) image.  Typically pixel_values will be a 256x1 image.</span>
 <span class="s0">*</span>
 <span class="s0">* Fills the PNMImage with a new image the same width and height as</span>
 <span class="s0">* index_image, with the same number of channels as pixel_values.</span>
 <span class="s0">*</span>
 <span class="s0">* Each pixel of the new image is computed with the formula:</span>
 <span class="s0">*</span>
 <span class="s0">* new_image(x, y) = pixel_values(index_image(x, y)[channel], 0)</span>
 <span class="s0">*</span>
 <span class="s0">* At present, no interpolation is performed; the nearest value in</span>
 <span class="s0">* pixel_values is discovered.  This may change in the future.</span>
 <span class="s0">*/ 4 4 this 3 758  11 index_image 1 756  7 channel 1 688  12 pixel_values 1 756  </span>
<span class="s0">300 0 0 4 307 716 0 0 272 /**</span>
 <span class="s0">* Rescales the RGB channel values so that any values in the original image</span>
 <span class="s0">* between min_val and max_val are expanded to the range 0 .. 1.  Values below</span>
 <span class="s0">* min_val are set to 0, and values above max_val are set to 1. Does not</span>
 <span class="s0">* affect the alpha channel, if any.</span>
 <span class="s0">*/ 3 4 this 3 758  7 min_val 1 704  7 max_val 1 704  </span>
<span class="s0">301 0 0 4 308 716 0 0 450 /**</span>
 <span class="s0">* Renders a solid-color circle, with a fuzzy edge, into the center of the</span>
 <span class="s0">* PNMImage.  If the PNMImage is non-square, this actually renders an ellipse.</span>
 <span class="s0">*</span>
 <span class="s0">* The min_radius and max_radius are in the scale 0..1, where 1.0 means the</span>
 <span class="s0">* full width of the image.  If min_radius == max_radius, the edge is sharp</span>
 <span class="s0">* (but still antialiased); otherwise, the pixels between min_radius and</span>
 <span class="s0">* max_radius are smoothly blended between fg and bg colors.</span>
 <span class="s0">*/ 5 4 this 3 758  2 fg 1 812  2 bg 1 812  10 min_radius 1 704  10 max_radius 1 704  </span>
<span class="s0">302 0 0 4 309 716 0 0 198 /**</span>
 <span class="s0">* Expands the image by the indicated number of pixels on each edge.  The new</span>
 <span class="s0">* pixels are set to the indicated color.</span>
 <span class="s0">*</span>
 <span class="s0">* If any of the values is negative, this actually crops the image.</span>
 <span class="s0">*/ 6 4 this 3 758  4 left 1 688  5 right 1 688  6 bottom 1 688  3 top 1 688  5 color 1 812  </span>
<span class="s0">303 0 0 4 310 716 0 0 154 /**</span>
 <span class="s0">* This flavor of box_filter() will apply the filter over the entire image</span>
 <span class="s0">* without resizing or copying; the effect is that of a blur operation.</span>
 <span class="s0">*/ 2 4 this 3 758  6 radius 5 704  </span>
<span class="s0">304 0 0 4 311 716 0 0 159 /**</span>
 <span class="s0">* This flavor of gaussian_filter() will apply the filter over the entire</span>
 <span class="s0">* image without resizing or copying; the effect is that of a blur operation.</span>
 <span class="s0">*/ 2 4 this 3 758  6 radius 5 704  </span>
<span class="s0">305 0 0 4 312 716 0 0 99 /**</span>
 <span class="s0">* Resizes from the indicated image into this one by performing a nearest-</span>
 <span class="s0">* point sample.</span>
 <span class="s0">*/ 2 4 this 3 758  4 copy 1 756  </span>
<span class="s0">306 0 0 4 313 716 0 0 260 /**</span>
 <span class="s0">* Makes a resized copy of the indicated image into this one using the</span>
 <span class="s0">* indicated filter.  The image to be copied is squashed and stretched to</span>
 <span class="s0">* match the dimensions of the current image, applying the appropriate filter</span>
 <span class="s0">* to perform the stretching.</span>
 <span class="s0">*/ 3 4 this 3 758  6 radius 1 704  4 copy 1 756  </span>
<span class="s0">307 0 0 4 314 716 0 0 260 /**</span>
 <span class="s0">* Makes a resized copy of the indicated image into this one using the</span>
 <span class="s0">* indicated filter.  The image to be copied is squashed and stretched to</span>
 <span class="s0">* match the dimensions of the current image, applying the appropriate filter</span>
 <span class="s0">* to perform the stretching.</span>
 <span class="s0">*/ 3 4 this 3 758  6 radius 1 704  4 copy 1 756  </span>
<span class="s0">308 0 0 4 315 716 0 0 415 /**</span>
 <span class="s0">* Resizes from the given image, with a fixed radius of 0.5. This is a very</span>
 <span class="s0">* specialized and simple algorithm that doesn't handle dropping below the</span>
 <span class="s0">* Nyquist rate very well, but is quite a bit faster than the more general</span>
 <span class="s0">* box_filter(), above.  If borders are specified, they will further restrict</span>
 <span class="s0">* the size of the resulting image.  There's no point in using</span>
 <span class="s0">* quick_box_filter() on a single image.</span>
 <span class="s0">*/ 4 4 this 3 758  4 copy 1 756  7 xborder 5 688  7 yborder 5 688  </span>
<span class="s0">309 0 0 4 316 716 0 0 64 /**</span>
 <span class="s0">* Computes a histogram of the colors used in the image.</span>
 <span class="s0">*/ 2 4 this 3 758  4 hist 1 750  </span>
<span class="s0">310 0 0 4 317 716 0 0 284 /**</span>
 <span class="s0">* Reduces the number of unique colors in the image to (at most) the given</span>
 <span class="s0">* count.  Fewer colors than requested may be left in the image after this</span>
 <span class="s0">* operation, but never more.</span>
 <span class="s0">*</span>
 <span class="s0">* At present, this is only supported on images without an alpha channel.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.5</span>
 <span class="s0">*/ 2 4 this 3 758  10 max_colors 1 821  </span>
<span class="s0">311 0 0 4 318 716 0 0 92 /**</span>
 <span class="s0">* Variant of perlin_noise_fill that uses an existing StackedPerlinNoise2</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 2 4 this 3 758  6 perlin 1 823  </span>
<span class="s0">312 0 0 4 318 716 0 0 267 /**</span>
 <span class="s0">* Fills the image with a grayscale perlin noise pattern based on the</span>
 <span class="s0">* indicated parameters.  Uses set_xel to set the grayscale values.  The sx</span>
 <span class="s0">* and sy parameters are in multiples of the size of this image.  See also the</span>
 <span class="s0">* PerlinNoise2 class in mathutil.</span>
 <span class="s0">*/ 5 4 this 3 758  2 sx 1 704  2 sy 1 704  10 table_size 5 688  4 seed 5 825  </span>
<span class="s0">313 0 0 4 319 716 0 0 126 /**</span>
 <span class="s0">* Transforms every pixel using the operation (Ro,Go,Bo) =</span>
 <span class="s0">* conv.xform_point(Ri,Gi,Bi); Input must be a color image.</span>
 <span class="s0">*/ 2 4 this 3 758  4 conv 1 826  </span>
<span class="s0">314 0 0 4 320 716 0 0 217 /**</span>
 <span class="s0">* Assuming the image was constructed with a gamma curve of from_gamma in the</span>
 <span class="s0">* RGB channels, converts it to an image with a gamma curve of to_gamma in the</span>
 <span class="s0">* RGB channels.  Does not affect the alpha channel.</span>
 <span class="s0">*/ 3 4 this 3 758  10 from_gamma 1 704  8 to_gamma 1 704  </span>
<span class="s0">315 0 0 4 321 716 0 0 218 /**</span>
 <span class="s0">* Assuming the image was constructed with a gamma curve of from_gamma in the</span>
 <span class="s0">* alpha channel, converts it to an image with a gamma curve of to_gamma in</span>
 <span class="s0">* the alpha channel.  Does not affect the RGB channels.</span>
 <span class="s0">*/ 3 4 this 3 758  10 from_gamma 1 704  8 to_gamma 1 704  </span>
<span class="s0">316 0 0 4 322 716 0 0 148 /**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/ 2 4 this 3 758  13 gray_exponent 1 704  </span>
<span class="s0">317 0 0 4 322 716 0 0 148 /**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.</span>
 <span class="s0">*/ 3 4 this 3 758  13 gray_exponent 1 704  14 alpha_exponent 1 704  </span>
<span class="s0">318 0 0 4 322 716 0 0 283 /**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.  For a</span>
 <span class="s0">* grayscale image, the blue_exponent value is used for the grayscale value,</span>
 <span class="s0">* and red_exponent and green_exponent are unused.</span>
 <span class="s0">*/ 4 4 this 3 758  12 red_exponent 1 704  14 green_exponent 1 704  13 blue_exponent 1 704  </span>
<span class="s0">319 0 0 4 322 716 0 0 283 /**</span>
 <span class="s0">* Adjusts each channel of the image by raising the corresponding component</span>
 <span class="s0">* value to the indicated exponent, such that L' = L ^ exponent.  For a</span>
 <span class="s0">* grayscale image, the blue_exponent value is used for the grayscale value,</span>
 <span class="s0">* and red_exponent and green_exponent are unused.</span>
 <span class="s0">*/ 5 4 this 3 758  12 red_exponent 1 704  14 green_exponent 1 704  13 blue_exponent 1 704  14 alpha_exponent 1 704  </span>
<span class="s0">320 0 0 7 323 819 0 0 71 /**</span>
 <span class="s0">* Returns the average color of all of the pixels in the image.</span>
 <span class="s0">*/ 1 4 this 3 756  </span>
<span class="s0">321 0 0 7 324 820 0 0 103 /**</span>
 <span class="s0">* Returns the average color of all of the pixels in the image, including the</span>
 <span class="s0">* alpha channel.</span>
 <span class="s0">*/ 1 4 this 3 756  </span>
<span class="s0">322 0 0 6 325 704 0 0 85 /**</span>
 <span class="s0">* Returns the average grayscale component of all of the pixels in the image.</span>
 <span class="s0">*/ 1 4 this 3 756  </span>
<span class="s0">323 0 0 4 326 716 0 0 116 /**</span>
 <span class="s0">* Recursively fills in the minimum distance measured from a certain set of</span>
 <span class="s0">* points into the gray channel.</span>
 <span class="s0">*/ 4 4 this 3 758  2 xi 1 688  2 yi 1 688  1 d 1 688  </span>
<span class="s0">324 0 0 7 342 829 0 0 0 2 4 this 3 758  1 y 1 688  </span>
<span class="s0">325 0 0 7 342 830 0 0 0 2 4 this 3 756  1 y 1 688  </span>
<span class="s0">326 0 0 7 343 758 545 0 0 1 4 this 3 756  </span>
<span class="s0">327 0 0 7 344 758 545 0 0 2 4 this 3 756  5 other 1 812  </span>
<span class="s0">328 0 0 7 344 758 545 0 0 2 4 this 3 756  5 other 1 756  </span>
<span class="s0">329 0 0 7 345 758 545 0 0 2 4 this 3 756  5 other 1 812  </span>
<span class="s0">330 0 0 7 345 758 545 0 0 2 4 this 3 756  5 other 1 756  </span>
<span class="s0">331 0 0 7 346 758 545 0 0 2 4 this 3 756  5 other 1 812  </span>
<span class="s0">332 0 0 7 346 758 545 0 0 2 4 this 3 756  5 other 1 756  </span>
<span class="s0">333 0 0 7 346 758 545 0 0 2 4 this 3 756  10 multiplier 1 704  </span>
<span class="s0">334 0 0 6 347 758 0 0 0 2 4 this 3 758  5 other 1 812  </span>
<span class="s0">335 0 0 6 347 758 0 0 0 2 4 this 3 758  5 other 1 756  </span>
<span class="s0">336 0 0 6 348 758 0 0 0 2 4 this 3 758  5 other 1 812  </span>
<span class="s0">337 0 0 6 348 758 0 0 0 2 4 this 3 758  5 other 1 756  </span>
<span class="s0">338 0 0 6 349 758 0 0 0 2 4 this 3 758  5 other 1 812  </span>
<span class="s0">339 0 0 6 349 758 0 0 0 2 4 this 3 758  5 other 1 756  </span>
<span class="s0">340 0 0 6 349 758 0 0 0 2 4 this 3 758  10 multiplier 1 704  </span>
<span class="s0">341 0 0 15 335 829 0 0 0 1 6 param0 0 831  </span>
<span class="s0">342 0 0 6 328 821 0 0 47 /**</span>
 <span class="s0">* Get the number of pixels in the row.</span>
 <span class="s0">*/ 1 4 this 3 831  </span>
<span class="s0">343 0 0 7 329 820 0 0 0 2 4 this 3 831  1 x 1 688  </span>
<span class="s0">344 0 0 4 330 716 0 0 127 /**</span>
 <span class="s0">* Set the pixel at the given column in the row.  If the image has no alpha</span>
 <span class="s0">* channel, the alpha component is ignored.</span>
 <span class="s0">*/ 3 4 this 3 829  1 x 1 688  1 v 1 812  </span>
<span class="s0">345 0 0 6 331 818 0 0 58 /**</span>
 <span class="s0">* Fetch the pixel at the given column in the row.</span>
 <span class="s0">*/ 2 4 this 3 829  1 x 1 688  </span>
<span class="s0">346 0 0 4 332 716 0 0 56 /**</span>
 <span class="s0">* Set the pixel at the given column in the row.</span>
 <span class="s0">*/ 3 4 this 3 829  1 x 1 688  1 v 1 745  </span>
<span class="s0">347 0 0 6 333 689 0 0 64 /**</span>
 <span class="s0">* Fetch the alpha value at the given column in the row.</span>
 <span class="s0">*/ 2 4 this 3 831  1 x 1 688  </span>
<span class="s0">348 0 0 4 334 716 0 0 62 /**</span>
 <span class="s0">* Set the alpha value at the given column in the row.</span>
 <span class="s0">*/ 3 4 this 3 829  1 x 1 688  1 v 1 689  </span>
<span class="s0">349 0 0 15 341 830 0 0 0 1 6 param0 0 833  </span>
<span class="s0">350 0 0 6 337 821 0 0 47 /**</span>
 <span class="s0">* Get the number of pixels in the row.</span>
 <span class="s0">*/ 1 4 this 3 833  </span>
<span class="s0">351 0 0 7 338 820 0 0 0 2 4 this 3 833  1 x 1 688  </span>
<span class="s0">352 0 0 7 339 818 0 0 58 /**</span>
 <span class="s0">* Fetch the pixel at the given column in the row.</span>
 <span class="s0">*/ 2 4 this 3 833  1 x 1 688  </span>
<span class="s0">353 0 0 6 340 689 0 0 64 /**</span>
 <span class="s0">* Fetch the alpha value at the given column in the row.</span>
 <span class="s0">*/ 2 4 this 3 833  1 x 1 688  </span>
<span class="s0">354 0 0 7 351 835 668 0 532 /**</span>
 <span class="s0">* The constructor stores a pointer to the PNMImage you pass it, but it does</span>
 <span class="s0">* not take ownership of the object; you are responsible for ensuring that the</span>
 <span class="s0">* PNMImage does not destruct during the lifetime of the PNMPainter object.</span>
 <span class="s0">*</span>
 <span class="s0">* The xo, yo coordinates specify an optional offset for fill coordinates.  If</span>
 <span class="s0">* you are painting with a pattern fill, these specify the virtual coordinates</span>
 <span class="s0">* of the upper-left corner of the image, which can allow you to adjust the</span>
 <span class="s0">* pattern to line up with nested images, if necessary.</span>
 <span class="s0">*/ 3 5 image 1 758  2 xo 5 688  2 yo 5 688  </span>
<span class="s0">355 0 0 15 351 835 668 0 0 1 6 param0 0 836  </span>
<span class="s0">356 0 0 4 353 716 0 0 330 /**</span>
 <span class="s0">* Specifies a PNMBrush that will be used for drawing lines and edges.  If the</span>
 <span class="s0">* brush is a bitmap brush, its image will be smeared pixelwise along the</span>
 <span class="s0">* line.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the PNMImage passed to the constructor, the PNMPainter will take</span>
 <span class="s0">* ownership of the pen.  It is not necessary to keep a separate pointer to</span>
 <span class="s0">* it.</span>
 <span class="s0">*/ 2 4 this 3 835  3 pen 1 712  </span>
<span class="s0">357 0 0 7 354 712 0 0 51 /**</span>
 <span class="s0">* Returns the current pen.  See set_pen().</span>
 <span class="s0">*/ 1 4 this 3 836  </span>
<span class="s0">358 0 0 4 355 716 0 0 343 /**</span>
 <span class="s0">* Specifies a PNMBrush that will be used for filling in the interiors of</span>
 <span class="s0">* objects.  If the brush is a bitmap brush, its image will be tiled</span>
 <span class="s0">* throughout the space.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike the PNMImage passed to the constructor, the PNMPainter will take</span>
 <span class="s0">* ownership of the fill brush.  It is not necessary to keep a separate</span>
 <span class="s0">* pointer to it.</span>
 <span class="s0">*/ 2 4 this 3 835  4 fill 1 712  </span>
<span class="s0">359 0 0 7 356 712 0 0 59 /**</span>
 <span class="s0">* Returns the current fill brush.  See set_fill().</span>
 <span class="s0">*/ 1 4 this 3 836  </span>
<span class="s0">360 0 0 4 360 716 0 0 77 /**</span>
 <span class="s0">* Draws an antialiased point on the PNMImage, using the current pen.</span>
 <span class="s0">*/ 3 4 this 3 835  1 x 1 704  1 y 1 704  </span>
<span class="s0">361 0 0 4 361 716 0 0 76 /**</span>
 <span class="s0">* Draws an antialiased line on the PNMImage, using the current pen.</span>
 <span class="s0">*/ 5 4 this 3 835  2 xa 1 704  2 ya 1 704  2 xb 1 704  2 yb 1 704  </span>
<span class="s0">362 0 0 4 362 716 0 0 211 /**</span>
 <span class="s0">* Draws a filled rectangule on the PNMImage, using the current pen for the</span>
 <span class="s0">* outline, and the current fill brush for the interior.</span>
 <span class="s0">*</span>
 <span class="s0">* The two coordinates specify any two diagonally opposite corners.</span>
 <span class="s0">*/ 5 4 this 3 835  2 xa 1 704  2 ya 1 704  2 xb 1 704  2 yb 1 704  </span>
<span class="s0">363 0 0 6 28 704 0 0 0 1 3 val 1 704  </span>
<span class="s0">364 0 0 6 28 704 0 0 0 1 3 val 1 838  </span>
<span class="s0">365 0 0 6 29 838 0 0 0 1 3 val 1 704  </span>
<span class="s0">366 0 0 6 29 838 0 0 0 1 3 val 1 838  </span>
<span class="s0">367 0 0 6 30 704 0 0 0 1 3 val 1 704  </span>
<span class="s0">368 0 0 6 30 704 0 0 0 1 3 val 1 838  </span>
<span class="s0">369 0 0 6 31 838 0 0 0 1 3 val 1 704  </span>
<span class="s0">370 0 0 6 31 838 0 0 0 1 3 val 1 838  </span>
<span class="s0">163</span>
<span class="s0">676 5 pixel 0 140289 5 pixel 5 pixel 0 0 0 1 371 390 3 839 840 841 12 372 373 374 375 376 377 378 379 380 381 382 383 0 0 0 0 0 0</span>

<span class="s0">677 4 gray 0 2105344 4 gray 4 gray 0 0 678 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">678 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">679 3 xel 0 2105345 3 xel 3 xel 0 0 676 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">680 11 PNMFileType 0 75777 11 PNMFileType 11 PNMFileType 0 0 0 0 0 3 842 843 844 5 395 396 397 398 399 1 856 0 1 0 681 0 0 0 0 126</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class of a family of classes that represent particular</span>
 <span class="s0">* image file types that PNMImage supports.</span>
 <span class="s0">*/</span>

<span class="s0">681 13 TypedWritable 0 2048 13 TypedWritable 13 TypedWritable 0 0 0 0 0 0 0 0 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* Base class for objects that can be written to and read from Bam files.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">682 6 string 0 2105344 11 std::string 11 std::string 0 0 683 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">683 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">684 19 PNMFileTypeRegistry 0 26625 19 PNMFileTypeRegistry 19 PNMFileTypeRegistry 0 0 0 1 408 400 1 845 7 401 402 403 404 405 406 407 1 857 0 0 0 0 82</span>
<span class="s0">/**</span>
 <span class="s0">* This class maintains the set of all known PNMFileTypes in the universe.</span>
 <span class="s0">*/</span>

<span class="s0">685 13 PNMFileType * 0 8576 13 PNMFileType * 13 PNMFileType * 0 0 680 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">686 14 PNMImageHeader 0 26625 14 PNMImageHeader 14 PNMImageHeader 0 0 0 1 409 411 6 846 847 848 849 850 851 20 410 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 0 0 0 0 7 687 692 693 694 696 698 700 350</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class of PNMImage, PNMReader, and PNMWriter.  It</span>
 <span class="s0">* encapsulates all the information associated with an image that describes</span>
 <span class="s0">* its size, number of channels, etc; that is, all the information about the</span>
 <span class="s0">* image except the image data itself.  It's the sort of information you</span>
 <span class="s0">* typically read from the image file's header.</span>
 <span class="s0">*/</span>

<span class="s0">687 9 ColorType 0 794624 25 PNMImageHeader::ColorType 25 PNMImageHeader::ColorType 686 0 0 0 0 0 0 0 0 0 5 10 CT_invalid 26 PNMImageHeader::CT_invalid 0</span>
<span class="s0">0 12 CT_grayscale 28 PNMImageHeader::CT_grayscale 0</span>
<span class="s0">1 14 CT_two_channel 30 PNMImageHeader::CT_two_channel 0</span>
<span class="s0">2 8 CT_color 24 PNMImageHeader::CT_color 0</span>
<span class="s0">3 15 CT_four_channel 31 PNMImageHeader::CT_four_channel 0</span>
<span class="s0">4 0 198</span>
<span class="s0">// This enumerated type indicates the number of channels in the image, and</span>
<span class="s0">// also implies an image type.  You can treat it either as an integer number</span>
<span class="s0">// of channels or as an enumerated image type.</span>

<span class="s0">688 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">689 6 xelval 0 2105344 6 xelval 6 xelval 0 0 677 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">690 10 ColorSpace 0 532480 10 ColorSpace 10 ColorSpace 0 0 0 0 0 0 0 0 0 0 4 14 CS_unspecified 14 CS_unspecified 105</span>
<span class="s0">// This value is not a color space, but is used to indicate that a color</span>
<span class="s0">// space has not been specified.</span>
<span class="s0">0 9 CS_linear 9 CS_linear 389</span>
<span class="s0">// CS_linear is not a color space per se, but represents the working color</span>
<span class="s0">// space of graphics APIs, which is linearized.  Since the conversion from</span>
<span class="s0">// sRGB to linear is defined, one could posit that it has the ITU-R BT.709</span>
<span class="s0">// primaries, but this isn't meaningful as modern graphics APIs do not</span>
<span class="s0">// perform color management.  All colors in Panda3D are linear unless</span>
<span class="s0">// otherwise specified.</span>
<span class="s0">1 7 CS_sRGB 7 CS_sRGB 107</span>
<span class="s0">// This is the standard, gamma-2.2-corrected sRGB color space, as used by</span>
<span class="s0">// the majority of image formats.</span>
<span class="s0">2 8 CS_scRGB 8 CS_scRGB 110</span>
<span class="s0">// This is a 16-bit encoded linear color space capable of encoding color</span>
<span class="s0">// values in the -0.5...7.4999 range.</span>
<span class="s0">3 0 0</span>

<span class="s0">691 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">692 9 PixelSpec 0 403457 25 PNMImageHeader::PixelSpec 25 PNMImageHeader::PixelSpec 686 0 0 1 431 447 0 15 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 0 0 0 0 0 179</span>
<span class="s0">// Contains a single pixel specification used in compute_histogram() and</span>
<span class="s0">// make_histogram().  Note that pixels are stored by integer value, not by</span>
<span class="s0">// floating-point scaled value.</span>

<span class="s0">693 14 PixelSpecCount 0 403457 30 PNMImageHeader::PixelSpecCount 30 PNMImageHeader::PixelSpecCount 686 0 0 1 448 449 0 0 0 0 0 0 0 93</span>
<span class="s0">// Associates a pixel specification with an appearance count, for use in</span>
<span class="s0">// Histogram, below.</span>

<span class="s0">694 7 HistMap 0 2367488 23 PNMImageHeader::HistMap 23 PNMImageHeader::HistMap 686 0 695 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">695 21 map&lt; PixelSpec, int &gt; 0 2048 37 map&lt; PNMImageHeader::PixelSpec, int &gt; 37 map&lt; PNMImageHeader::PixelSpec, int &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">696 10 PixelCount 0 2367488 26 PNMImageHeader::PixelCount 26 PNMImageHeader::PixelCount 686 0 697 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">697 25 pvector&lt; PixelSpecCount &gt; 0 2048 41 pvector&lt; PNMImageHeader::PixelSpecCount &gt; 41 pvector&lt; PNMImageHeader::PixelSpecCount &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">698 7 Palette 0 2367488 23 PNMImageHeader::Palette 23 PNMImageHeader::Palette 686 0 699 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">699 20 pvector&lt; PixelSpec &gt; 0 2048 36 pvector&lt; PNMImageHeader::PixelSpec &gt; 36 pvector&lt; PNMImageHeader::PixelSpec &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">700 9 Histogram 0 403457 25 PNMImageHeader::Histogram 25 PNMImageHeader::Histogram 686 0 0 1 450 455 0 4 451 452 453 454 1 858 0 0 0 0 65</span>
<span class="s0">// Used to return a pixel histogram in PNMImage::get_histogram().</span>

<span class="s0">701 7 PfmFile 0 141313 7 PfmFile 7 PfmFile 0 0 0 1 456 538 2 852 853 81 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 0 0 1 0 686 0 0 0 0 155</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a pfm file, a 2-d table of floating-point numbers, either</span>
 <span class="s0">* 3-component or 1-component, or with a special extension, 2- or 4-component.</span>
 <span class="s0">*/</span>

<span class="s0">702 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">703 10 PN_float32 0 2105344 10 PN_float32 10 PN_float32 0 0 704 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">704 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">705 8 PNMBrush 0 75777 8 PNMBrush 8 PNMBrush 0 0 0 0 0 0 4 539 540 541 542 0 0 1 0 706 0 0 0 1 707 517</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used to control the shape and color of the drawing operations</span>
 <span class="s0">* performed by a PNMPainter object.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, you don't create a PNMBrush directly; instead, use one of the</span>
 <span class="s0">* static PNMBrush::make_*() methods provided here.</span>
 <span class="s0">*</span>
 <span class="s0">* A PNMBrush is used to draw the border of a polygon or rectangle, as well as</span>
 <span class="s0">* for filling its interior.  When it is used to draw a border, the brush is</span>
 <span class="s0">* &quot;smeared&quot; over the border; when it is used to fill the interior, it is</span>
 <span class="s0">* tiled through the interior.</span>
 <span class="s0">*/</span>

<span class="s0">706 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">707 11 BrushEffect 0 794624 21 PNMBrush::BrushEffect 21 PNMBrush::BrushEffect 705 0 0 0 0 0 0 0 0 0 4 6 BE_set 16 PNMBrush::BE_set 0</span>
<span class="s0">0 8 BE_blend 18 PNMBrush::BE_blend 0</span>
<span class="s0">1 9 BE_darken 19 PNMBrush::BE_darken 0</span>
<span class="s0">2 10 BE_lighten 20 PNMBrush::BE_lighten 0</span>
<span class="s0">3 0 0</span>

<span class="s0">708 8 PNMImage 0 26625 8 PNMImage 8 PNMImage 0 0 0 1 543 545 0 109 544 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 659 660 661 662 663 664 665 666 0 0 1 0 686 0 0 0 2 709 710 1516</span>
<span class="s0">/**</span>
 <span class="s0">* The name of this class derives from the fact that we originally implemented</span>
 <span class="s0">* it as a layer on top of the &quot;pnm library&quot;, based on netpbm, which was built</span>
 <span class="s0">* to implement pbm, pgm, and pbm files, and is the underlying support of a</span>
 <span class="s0">* number of public-domain image file converters.  Nowadays we are no longer</span>
 <span class="s0">* derived directly from the pnm library, mainly to allow support of C++</span>
 <span class="s0">* iostreams instead of the C stdio FILE interface.</span>
 <span class="s0">*</span>
 <span class="s0">* Conceptually, a PNMImage is a two-dimensional array of xels, which are the</span>
 <span class="s0">* PNM-defined generic pixel type.  Each xel may have a red, green, and blue</span>
 <span class="s0">* component, or (if the image is grayscale) a gray component.  The image may</span>
 <span class="s0">* be read in, the individual xels manipulated, and written out again, or a</span>
 <span class="s0">* black image may be constructed from scratch.</span>
 <span class="s0">*</span>
 <span class="s0">* A PNMImage has a color space and a maxval, the combination of which defines</span>
 <span class="s0">* how a floating-point linear color value is encoded as an integer value in</span>
 <span class="s0">* memory.  The functions ending in _val operate on encoded colors, whereas</span>
 <span class="s0">* the regular ones work with linear floating-point values.  All operations</span>
 <span class="s0">* are color space correct unless otherwise specified.</span>
 <span class="s0">*</span>
 <span class="s0">* The image is of size XSize() by YSize() xels, numbered from top to bottom,</span>
 <span class="s0">* left to right, beginning at zero.</span>
 <span class="s0">*</span>
 <span class="s0">* Files can be specified by filename, or by an iostream pointer.  The</span>
 <span class="s0">* filename &quot;-&quot; refers to stdin or stdout.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is not inherently thread-safe; use it from a single thread or</span>
 <span class="s0">* protect access using a mutex.</span>
 <span class="s0">*/</span>

<span class="s0">709 3 Row 0 272385 13 PNMImage::Row 13 PNMImage::Row 708 0 0 1 653 0 0 7 646 647 648 649 650 651 652 0 0 0 0 0 96</span>
<span class="s0">// Provides an accessor for reading or writing the contents of one row of</span>
<span class="s0">// the image in-place.</span>

<span class="s0">710 4 CRow 0 272385 14 PNMImage::CRow 14 PNMImage::CRow 708 0 0 1 658 0 0 4 654 655 656 657 0 0 0 0 0 86</span>
<span class="s0">// Provides an accessor for reading the contents of one row of the image in-</span>
<span class="s0">// place.</span>

<span class="s0">711 10 PNMPainter 0 26625 10 PNMPainter 10 PNMPainter 0 0 0 1 667 668 2 854 855 7 669 670 671 672 673 674 675 0 0 0 0 0 334</span>
<span class="s0">/**</span>
 <span class="s0">* This class provides a number of convenient methods for painting drawings</span>
 <span class="s0">* directly into a PNMImage.</span>
 <span class="s0">*</span>
 <span class="s0">* It stores a pointer to the PNMImage you pass it, but it does not take</span>
 <span class="s0">* ownership of the object; you are responsible for ensuring that the PNMImage</span>
 <span class="s0">* does not destruct during the lifetime of the PNMPainter object.</span>
 <span class="s0">*/</span>

<span class="s0">712 10 PNMBrush * 0 8576 10 PNMBrush * 10 PNMBrush * 0 0 705 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">713 7 pixel * 0 8576 7 pixel * 7 pixel * 0 0 676 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">714 13 pixel const * 0 8576 13 pixel const * 13 pixel const * 0 0 715 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">715 11 pixel const 0 8832 11 pixel const 11 pixel const 0 0 676 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">716 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">717 12 double const 0 8832 12 double const 12 double const 0 0 718 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">718 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">719 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 720 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">720 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">721 19 PNMFileType const * 0 8576 19 PNMFileType const * 19 PNMFileType const * 0 0 722 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">722 17 PNMFileType const 0 8832 17 PNMFileType const 17 PNMFileType const 0 0 680 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">723 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">724 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">725 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 724 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">726 27 PNMFileTypeRegistry const * 0 8576 27 PNMFileTypeRegistry const * 27 PNMFileTypeRegistry const * 0 0 727 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">727 25 PNMFileTypeRegistry const 0 8832 25 PNMFileTypeRegistry const 25 PNMFileTypeRegistry const 0 0 684 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">728 21 PNMFileTypeRegistry * 0 8576 21 PNMFileTypeRegistry * 21 PNMFileTypeRegistry * 0 0 684 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">729 16 PNMImageHeader * 0 8576 16 PNMImageHeader * 16 PNMImageHeader * 0 0 686 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">730 22 PNMImageHeader const * 0 8576 22 PNMImageHeader const * 22 PNMImageHeader const * 0 0 731 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">731 20 PNMImageHeader const 0 8832 20 PNMImageHeader const 20 PNMImageHeader const 0 0 686 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">732 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 691 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">733 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 734 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">734 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 735 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">735 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">736 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 737 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">737 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">738 11 PNMReader * 0 8576 11 PNMReader * 11 PNMReader * 0 0 739 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">739 9 PNMReader 0 1050624 9 PNMReader 9 PNMReader 0 0 0 0 0 0 0 0 0 0 0 0 226</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class that defines the interface for reading image</span>
 <span class="s0">* files of various types.  Any particular image file type that can be read</span>
 <span class="s0">* must define a class that inherits from PNMReader to read it.</span>
 <span class="s0">*/</span>

<span class="s0">740 11 PNMWriter * 0 8576 11 PNMWriter * 11 PNMWriter * 0 0 741 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">741 9 PNMWriter 0 1050624 9 PNMWriter 9 PNMWriter 0 0 0 0 0 0 0 0 0 0 0 0 230</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class that defines the interface for writing image</span>
 <span class="s0">* files of various types.  Any particular image file type that can be written</span>
 <span class="s0">* must define a class that inherits from PNMWriter to write it.</span>
 <span class="s0">*/</span>

<span class="s0">742 17 PixelSpec const * 0 8576 33 PNMImageHeader::PixelSpec const * 33 PNMImageHeader::PixelSpec const * 0 0 743 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">743 15 PixelSpec const 0 8832 31 PNMImageHeader::PixelSpec const 31 PNMImageHeader::PixelSpec const 0 0 692 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">744 11 PixelSpec * 0 8576 27 PNMImageHeader::PixelSpec * 27 PNMImageHeader::PixelSpec * 0 0 692 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">745 11 xel const * 0 8576 11 xel const * 11 xel const * 0 0 746 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">746 9 xel const 0 8832 9 xel const 9 xel const 0 0 679 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">747 22 PixelSpecCount const * 0 8576 38 PNMImageHeader::PixelSpecCount const * 38 PNMImageHeader::PixelSpecCount const * 0 0 748 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">748 20 PixelSpecCount const 0 8832 36 PNMImageHeader::PixelSpecCount const 36 PNMImageHeader::PixelSpecCount const 0 0 693 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">749 16 PixelSpecCount * 0 8576 32 PNMImageHeader::PixelSpecCount * 32 PNMImageHeader::PixelSpecCount * 0 0 693 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">750 11 Histogram * 0 8576 27 PNMImageHeader::Histogram * 27 PNMImageHeader::Histogram * 0 0 700 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">751 17 Histogram const * 0 8576 33 PNMImageHeader::Histogram const * 33 PNMImageHeader::Histogram const * 0 0 752 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">752 15 Histogram const 0 8832 31 PNMImageHeader::Histogram const 31 PNMImageHeader::Histogram const 0 0 700 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">753 9 PfmFile * 0 8576 9 PfmFile * 9 PfmFile * 0 0 701 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">754 15 PfmFile const * 0 8576 15 PfmFile const * 15 PfmFile const * 0 0 755 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">755 13 PfmFile const 0 8832 13 PfmFile const 13 PfmFile const 0 0 701 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">756 16 PNMImage const * 0 8576 16 PNMImage const * 16 PNMImage const * 0 0 757 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">757 14 PNMImage const 0 8832 14 PNMImage const 14 PNMImage const 0 0 708 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">758 10 PNMImage * 0 8576 10 PNMImage * 10 PNMImage * 0 0 708 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">759 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 760 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">760 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 761 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">761 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">762 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 763 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">763 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 764 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">764 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">765 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 766 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">766 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 767 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">767 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">768 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 769 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">769 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 770 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">770 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">771 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 764 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">772 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 773 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">773 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 774 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">774 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">775 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 776 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">776 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 777 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">777 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">778 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 779 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">779 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 780 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">780 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">781 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 774 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">782 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 783 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">783 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 784 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">784 8 LPoint4f 0 2048 8 LPoint4f 8 LPoint4f 0 0 0 0 0 0 0 0 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">785 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 786 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">786 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 787 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">787 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">788 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 784 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">789 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 780 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">790 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 787 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">791 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 761 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">792 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 793 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">793 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 794 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">794 8 LPoint4d 0 2048 8 LPoint4d 8 LPoint4d 0 0 0 0 0 0 0 0 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">795 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 796 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">796 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 797 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">797 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">798 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 799 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">799 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 800 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">800 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">801 18 BoundingHexahedron 0 2048 18 BoundingHexahedron 18 BoundingHexahedron 0 0 0 0 0 0 0 0 0 0 0 0 300</span>
<span class="s0">/**</span>
 <span class="s0">* This defines a bounding convex hexahedron.  It is typically used to</span>
 <span class="s0">* represent a frustum, but may represent any enclosing convex hexahedron,</span>
 <span class="s0">* including simple boxes.  However, if all you want is an axis-aligned</span>
 <span class="s0">* bounding box, you may be better off with the simpler BoundingBox class.</span>
 <span class="s0">*/</span>

<span class="s0">802 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 803 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">803 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 804 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">804 8 LPoint2d 0 2048 8 LPoint2d 8 LPoint2d 0 0 0 0 0 0 0 0 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">805 20 BoundingHexahedron * 0 8576 20 BoundingHexahedron * 20 BoundingHexahedron * 0 0 801 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">806 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 807 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">807 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 808 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">808 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">809 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 810 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">810 9 Py_buffer 0 2105344 9 Py_buffer 9 Py_buffer 0 0 811 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">811 10 bufferinfo 0 1024 10 bufferinfo 10 bufferinfo 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">812 15 LColorf const * 0 8576 15 LColorf const * 15 LColorf const * 0 0 813 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">813 13 LColorf const 0 8832 13 LColorf const 13 LColorf const 0 0 814 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">814 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 761 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">815 18 LRGBColorf const * 0 8576 18 LRGBColorf const * 18 LRGBColorf const * 0 0 816 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">816 16 LRGBColorf const 0 8832 16 LRGBColorf const 16 LRGBColorf const 0 0 817 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">817 10 LRGBColorf 0 2105344 10 LRGBColorf 10 LRGBColorf 0 0 780 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">818 5 xel * 0 8576 5 xel * 5 xel * 0 0 679 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">819 12 LRGBColorf * 0 8576 12 LRGBColorf * 12 LRGBColorf * 0 0 817 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">820 9 LColorf * 0 8576 9 LColorf * 9 LColorf * 0 0 814 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">821 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 822 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">822 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">823 21 StackedPerlinNoise2 * 0 8576 21 StackedPerlinNoise2 * 21 StackedPerlinNoise2 * 0 0 824 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">824 19 StackedPerlinNoise2 0 2048 19 StackedPerlinNoise2 19 StackedPerlinNoise2 0 0 0 0 0 0 0 0 0 0 0 0 147</span>
<span class="s0">/**</span>
 <span class="s0">* Implements a multi-layer PerlinNoise, with one or more high-frequency noise</span>
 <span class="s0">* functions added to a lower-frequency base noise function.</span>
 <span class="s0">*/</span>

<span class="s0">825 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">826 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 827 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">827 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 828 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">828 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 800 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">829 5 Row * 0 8576 15 PNMImage::Row * 15 PNMImage::Row * 0 0 709 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">830 6 CRow * 0 8576 16 PNMImage::CRow * 16 PNMImage::CRow * 0 0 710 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">831 11 Row const * 0 8576 21 PNMImage::Row const * 21 PNMImage::Row const * 0 0 832 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">832 9 Row const 0 8832 19 PNMImage::Row const 19 PNMImage::Row const 0 0 709 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">833 12 CRow const * 0 8576 22 PNMImage::CRow const * 22 PNMImage::CRow const * 0 0 834 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">834 10 CRow const 0 8832 20 PNMImage::CRow const 20 PNMImage::CRow const 0 0 710 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">835 12 PNMPainter * 0 8576 12 PNMPainter * 12 PNMPainter * 0 0 711 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">836 18 PNMPainter const * 0 8576 18 PNMPainter const * 18 PNMPainter const * 0 0 837 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">837 16 PNMPainter const 0 8832 16 PNMPainter const 16 PNMPainter const 0 0 711 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">838 13 unsigned char 0 8198 13 unsigned char 13 unsigned char 0 5 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">17</span>
<span class="s0">839 1 b 0 6 677 384 385 0 0 0 0 0 0 8 pixel::b 0</span>

<span class="s0">840 1 g 0 6 677 386 387 0 0 0 0 0 0 8 pixel::g 0</span>

<span class="s0">841 1 r 0 6 677 388 389 0 0 0 0 0 0 8 pixel::r 0</span>

<span class="s0">842 4 name 0 2 682 395 0 0 0 0 0 0 0 17 PNMFileType::name 0</span>

<span class="s0">843 10 extensions 0 66 682 397 0 0 0 0 396 0 0 23 PNMFileType::extensions 0</span>

<span class="s0">844 19 suggested_extension 0 2 682 398 0 0 0 0 0 0 0 32 PNMFileType::suggested_extension 0</span>

<span class="s0">845 5 types 0 66 685 402 0 0 0 0 401 0 0 26 PNMFileTypeRegistry::types 0</span>

<span class="s0">846 12 num_channels 0 2 688 413 0 0 0 0 0 0 0 28 PNMImageHeader::num_channels 0</span>

<span class="s0">847 6 maxval 0 2 689 416 0 0 0 0 0 0 0 22 PNMImageHeader::maxval 0</span>

<span class="s0">848 11 color_space 0 2 690 417 0 0 0 0 0 0 0 27 PNMImageHeader::color_space 0</span>

<span class="s0">849 4 size 0 2 691 420 0 0 0 0 0 0 0 20 PNMImageHeader::size 0</span>

<span class="s0">850 7 comment 0 6 682 421 422 0 0 0 0 0 0 23 PNMImageHeader::comment 0</span>

<span class="s0">851 4 type 0 10 685 424 0 423 0 0 0 0 0 20 PNMImageHeader::type 0</span>

<span class="s0">852 5 valid 0 2 702 464 0 0 0 0 0 0 0 14 PfmFile::valid 0</span>

<span class="s0">853 5 scale 0 6 703 465 466 0 0 0 0 0 0 14 PfmFile::scale 0</span>

<span class="s0">854 3 pen 0 6 712 670 669 0 0 0 0 0 0 15 PNMPainter::pen 0</span>

<span class="s0">855 4 fill 0 6 712 672 671 0 0 0 0 0 0 16 PNMPainter::fill 0</span>

<span class="s0">3</span>
<span class="s0">856 14 get_extensions 0 396 397 27 PNMFileType::get_extensions 0</span>

<span class="s0">857 9 get_types 0 401 402 30 PNMFileTypeRegistry::get_types 0</span>

<span class="s0">858 10 get_pixels 0 451 452 37 PNMImageHeader::Histogram::get_pixels 0</span>

</pre>
</body>
</html>