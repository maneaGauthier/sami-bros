<html>
<head>
<title>RelatedObjectMgr.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RelatedObjectMgr.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;RelatedObjectMgr module: contains the RelatedObjectMgr class&quot;&quot;&quot;</span>

<span class="s2"># from direct.showbase.ShowBaseGlobal import *</span>
<span class="s3">from </span><span class="s1">direct</span><span class="s4">.</span><span class="s1">showbase </span><span class="s3">import </span><span class="s1">DirectObject</span>
<span class="s3">from </span><span class="s1">direct</span><span class="s4">.</span><span class="s1">directnotify </span><span class="s3">import </span><span class="s1">DirectNotifyGlobal</span>

<span class="s3">class </span><span class="s1">RelatedObjectMgr</span><span class="s4">(</span><span class="s1">DirectObject</span><span class="s4">.</span><span class="s1">DirectObject</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    This class manages a relationship between DistributedObjects that 
    know about each other, and are expected to be generated together. 
    Ideally, we should be able to guarantee the ordering of the 
    generate calls, but there are certain cases in which the objects 
    may not be generated in the correct order as defined by the 
    toon.dc file. 
 
    To handle cases like these robustly, it is necessary for each 
    object to deal with the possibility that its companion object has 
    not yet been generated.  This may mean deferring some operations 
    until the expected companion object has been generated. 
 
    This class helps manage that process.  To use it, an object should 
    register its desire to be associated with the other object's doId. 
    When the other object is generated (or immediately, if the object 
    already exists), the associated callback will be called.  There is 
    also a timeout callback in case the object never appears. 
    &quot;&quot;&quot;</span>
    <span class="s1">notify </span><span class="s4">= </span><span class="s1">DirectNotifyGlobal</span><span class="s4">.</span><span class="s1">directNotify</span><span class="s4">.</span><span class="s1">newCategory</span><span class="s4">(</span><span class="s5">'RelatedObjectMgr'</span><span class="s4">)</span>

    <span class="s1">doLaterSequence </span><span class="s4">= </span><span class="s6">1</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">cr</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">cr </span><span class="s4">= </span><span class="s1">cr</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects </span><span class="s4">= {}</span>

    <span class="s3">def </span><span class="s1">destroy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">abortAllRequests</span><span class="s4">()</span>
        <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">cr</span>
        <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects</span>

    <span class="s3">def </span><span class="s1">requestObjects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">allCallback </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, </span><span class="s1">eachCallback </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                       <span class="s1">timeout </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, </span><span class="s1">timeoutCallback </span><span class="s4">= </span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Requests a callback to be called when the objects in the 
        doIdList are generated.  The allCallback will be called only 
        when all the objects have been generated (and it receives a 
        list of objects, in the order given in doIdList).  The 
        eachCallback is called as each object is generated, and 
        receives only the object itself. 
 
        If the objects already exist, the appropriate callback is 
        called immediately. 
 
        If all of the objects are not generated within the indicated 
        timeout time, the timeoutCallback is called instead, with the 
        original doIdList as the parameter.  If the timeoutCallback is 
        None, then allCallback is called on timeout, with the list of 
        objects that have been generated so far, and None for objects 
        that have not been generated. 
 
        If any element of doIdList is None or 0, it is ignored, and 
        None is passed in its place in the object list passed to the 
        callback. 
 
        The return value may be saved and passed to a future call to 
        abortRequest(), in order to abort a pending request before the 
        timeout expires. 
 
        Actually, you should be careful to call abortRequest() if you 
        have made a call to requestObjects() that has not been resolved. 
        To find examples, do a search for abortRequest() to find out 
        how other code is using it.  A common idiom is to store the 
        result from requestObjects() and call abortRequest() if delete() 
        or destroy() is called on the requesting object. 
 
        See Also: abortRequest() 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;requestObjects(%s, timeout=%s)&quot; </span><span class="s4">% (</span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">timeout</span><span class="s4">))</span>

        <span class="s2"># First, see if we have all of the objects already.</span>
        <span class="s1">objects</span><span class="s4">, </span><span class="s1">doIdsPending </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__generateObjectList</span><span class="s4">(</span><span class="s1">doIdList</span><span class="s4">)</span>

        <span class="s2"># Call the eachCallback immediately on any objects we already</span>
        <span class="s2"># have.</span>
        <span class="s3">if </span><span class="s1">eachCallback</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">object </span><span class="s3">in </span><span class="s1">objects</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">object</span><span class="s4">:</span>
                    <span class="s1">eachCallback</span><span class="s4">(</span><span class="s1">object</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">doIdsPending</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s2"># All the objects exist, so just call the callback</span>
            <span class="s2"># immediately.</span>
            <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;All objects already exist.&quot;</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">allCallback</span><span class="s4">:</span>
                <span class="s1">allCallback</span><span class="s4">(</span><span class="s1">objects</span><span class="s4">)</span>
            <span class="s3">return</span>

        <span class="s2"># Some objects don't exist yet, so start listening for them, and</span>
        <span class="s2"># also set a timeout in case they don't come.</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;Some objects pending: %s&quot; </span><span class="s4">% (</span><span class="s1">doIdsPending</span><span class="s4">))</span>

        <span class="s2"># Make a copy of the original doIdList, so we can save it over</span>
        <span class="s2"># a period of time without worrying about the caller modifying</span>
        <span class="s2"># it.</span>
        <span class="s1">doIdList </span><span class="s4">= </span><span class="s1">doIdList</span><span class="s4">[:]</span>

        <span class="s1">doLaterName </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">timeout </span><span class="s4">!= </span><span class="s3">None</span><span class="s4">:</span>
            <span class="s1">doLaterName </span><span class="s4">= </span><span class="s5">&quot;RelatedObject-%s&quot; </span><span class="s4">% (</span><span class="s1">RelatedObjectMgr</span><span class="s4">.</span><span class="s1">doLaterSequence</span><span class="s4">)</span>
            <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;doLaterName = %s&quot; </span><span class="s4">% (</span><span class="s1">doLaterName</span><span class="s4">))</span>

            <span class="s1">RelatedObjectMgr</span><span class="s4">.</span><span class="s1">doLaterSequence </span><span class="s4">+= </span><span class="s6">1</span>

        <span class="s1">tuple </span><span class="s4">= (</span><span class="s1">allCallback</span><span class="s4">, </span><span class="s1">eachCallback</span><span class="s4">, </span><span class="s1">timeoutCallback</span><span class="s4">,</span>
                 <span class="s1">doIdsPending</span><span class="s4">, </span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">doLaterName</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">doId </span><span class="s3">in </span><span class="s1">doIdsPending</span><span class="s4">:</span>
            <span class="s1">pendingList </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">doId</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">pendingList </span><span class="s4">== </span><span class="s3">None</span><span class="s4">:</span>
                <span class="s1">pendingList </span><span class="s4">= []</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects</span><span class="s4">[</span><span class="s1">doId</span><span class="s4">] = </span><span class="s1">pendingList</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__listenFor</span><span class="s4">(</span><span class="s1">doId</span><span class="s4">)</span>

            <span class="s1">pendingList</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">tuple</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">doLaterName</span><span class="s4">:</span>
            <span class="s2"># Now spawn a do-later to catch the timeout.</span>
            <span class="s1">taskMgr</span><span class="s4">.</span><span class="s1">doMethodLater</span><span class="s4">(</span><span class="s1">timeout</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__timeoutExpired</span><span class="s4">, </span><span class="s1">doLaterName</span><span class="s4">,</span>
                                  <span class="s1">extraArgs </span><span class="s4">= [</span><span class="s1">tuple</span><span class="s4">])</span>

        <span class="s3">return </span><span class="s1">tuple</span>

    <span class="s3">def </span><span class="s1">abortRequest</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Aborts a previous request.  The parameter is the return value 
        from a previous call to requestObjects().  The pending request 
        is removed from the queue and no further callbacks will be called. 
 
        See Also: requestObjects() 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">tuple</span><span class="s4">:</span>
            <span class="s1">allCallback</span><span class="s4">, </span><span class="s1">eachCallback</span><span class="s4">, </span><span class="s1">timeoutCallback</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">, </span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">doLaterName </span><span class="s4">= </span><span class="s1">tuple</span>
            <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;aborting request for %s (remaining: %s)&quot; </span><span class="s4">% (</span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">))</span>

            <span class="s3">if </span><span class="s1">doLaterName</span><span class="s4">:</span>
                <span class="s1">taskMgr</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s1">doLaterName</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__removePending</span><span class="s4">(</span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">abortAllRequests</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Call this method to abruptly abort all pending requests, but 
        leave the RelatedObjectMgr in a state for accepting more 
        requests. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Stop listening for all events.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ignoreAll</span><span class="s4">()</span>

        <span class="s2"># Iterate through all the pendingObjects and stop any pending</span>
        <span class="s2"># tasks.</span>
        <span class="s3">for </span><span class="s1">pendingList </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects</span><span class="s4">.</span><span class="s1">values</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">tuple </span><span class="s3">in </span><span class="s1">pendingList</span><span class="s4">:</span>
                <span class="s1">allCallback</span><span class="s4">, </span><span class="s1">eachCallback</span><span class="s4">, </span><span class="s1">timeoutCallback</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">, </span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">doLaterName </span><span class="s4">= </span><span class="s1">tuple</span>
                <span class="s3">if </span><span class="s1">doLaterName</span><span class="s4">:</span>
                    <span class="s1">taskMgr</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s1">doLaterName</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects </span><span class="s4">= {}</span>


    <span class="s3">def </span><span class="s1">__timeoutExpired</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">):</span>
        <span class="s1">allCallback</span><span class="s4">, </span><span class="s1">eachCallback</span><span class="s4">, </span><span class="s1">timeoutCallback</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">, </span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">doLaterName </span><span class="s4">= </span><span class="s1">tuple</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;timeout expired for %s (remaining: %s)&quot; </span><span class="s4">% (</span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">))</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">__removePending</span><span class="s4">(</span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">timeoutCallback</span><span class="s4">:</span>
            <span class="s1">timeoutCallback</span><span class="s4">(</span><span class="s1">doIdList</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">objects</span><span class="s4">, </span><span class="s1">doIdsPending </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__generateObjectList</span><span class="s4">(</span><span class="s1">doIdList</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">allCallback</span><span class="s4">:</span>
                <span class="s1">allCallback</span><span class="s4">(</span><span class="s1">objects</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__removePending</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">):</span>
        <span class="s2"># Removes all the pending events for the doIdsPending list.</span>
        <span class="s3">while </span><span class="s1">len</span><span class="s4">(</span><span class="s1">doIdsPending</span><span class="s4">) &gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s2"># We pop doId's off the list instead of simply iterating</span>
            <span class="s2"># through the list, so that we will shorten the list (and</span>
            <span class="s2"># all other outstanding instances of the list) as we go.</span>
            <span class="s1">doId </span><span class="s4">= </span><span class="s1">doIdsPending</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
            <span class="s1">pendingList </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects</span><span class="s4">[</span><span class="s1">doId</span><span class="s4">]</span>
            <span class="s1">pendingList</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s1">tuple</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">pendingList</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects</span><span class="s4">[</span><span class="s1">doId</span><span class="s4">]</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__noListenFor</span><span class="s4">(</span><span class="s1">doId</span><span class="s4">)</span>


    <span class="s3">def </span><span class="s1">__listenFor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">doId</span><span class="s4">):</span>
        <span class="s2"># Start listening for the indicated object to be generated.</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;Now listening for generate from %s&quot; </span><span class="s4">% (</span><span class="s1">doId</span><span class="s4">))</span>
        <span class="s1">announceGenerateName </span><span class="s4">= </span><span class="s5">&quot;generate-%s&quot; </span><span class="s4">% (</span><span class="s1">doId</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">acceptOnce</span><span class="s4">(</span><span class="s1">announceGenerateName</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__generated</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__noListenFor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">doId</span><span class="s4">):</span>
        <span class="s2"># Stop listening for the indicated object to be generated.</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;No longer listening for generate from %s&quot; </span><span class="s4">% (</span><span class="s1">doId</span><span class="s4">))</span>
        <span class="s1">announceGenerateName </span><span class="s4">= </span><span class="s5">&quot;generate-%s&quot; </span><span class="s4">% (</span><span class="s1">doId</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ignore</span><span class="s4">(</span><span class="s1">announceGenerateName</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__generated</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">object</span><span class="s4">):</span>
        <span class="s2"># The indicated object has been generated.</span>
        <span class="s1">doId </span><span class="s4">= </span><span class="s1">object</span><span class="s4">.</span><span class="s1">doId</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;Got generate from %s&quot; </span><span class="s4">% (</span><span class="s1">doId</span><span class="s4">))</span>
        <span class="s1">pendingList </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects</span><span class="s4">[</span><span class="s1">doId</span><span class="s4">]</span>
        <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pendingObjects</span><span class="s4">[</span><span class="s1">doId</span><span class="s4">]</span>

        <span class="s3">for </span><span class="s1">tuple </span><span class="s3">in </span><span class="s1">pendingList</span><span class="s4">:</span>
            <span class="s1">allCallback</span><span class="s4">, </span><span class="s1">eachCallback</span><span class="s4">, </span><span class="s1">timeoutCallback</span><span class="s4">, </span><span class="s1">doIdsPending</span><span class="s4">, </span><span class="s1">doIdList</span><span class="s4">, </span><span class="s1">doLaterName </span><span class="s4">= </span><span class="s1">tuple</span>

            <span class="s2"># Here we are depending on Python to unify this one list</span>
            <span class="s2"># across all objects that share it.  When we remove our</span>
            <span class="s2"># doId from our reference to the list, it is also removed</span>
            <span class="s2"># from all the other references.</span>
            <span class="s1">doIdsPending</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s1">doId</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">eachCallback</span><span class="s4">:</span>
                <span class="s1">eachCallback</span><span class="s4">(</span><span class="s1">object</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">doIdsPending</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s2"># That was the last doId on the list.  Call the</span>
                <span class="s2"># allCallback!</span>
                <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;All objects generated on list: %s&quot; </span><span class="s4">% (</span><span class="s1">doIdList</span><span class="s4">,))</span>
                <span class="s3">if </span><span class="s1">doLaterName</span><span class="s4">:</span>
                    <span class="s1">taskMgr</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s1">doLaterName</span><span class="s4">)</span>

                <span class="s1">objects</span><span class="s4">, </span><span class="s1">doIdsPending </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__generateObjectList</span><span class="s4">(</span><span class="s1">doIdList</span><span class="s4">)</span>
                <span class="s3">if None in </span><span class="s1">objects</span><span class="s4">:</span>
                    <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">warning</span><span class="s4">(</span><span class="s5">'calling %s with None.</span><span class="s3">\n </span><span class="s5">objects=%s</span><span class="s3">\n </span><span class="s5">doIdsPending=%s</span><span class="s3">\n </span><span class="s5">doIdList=%s</span><span class="s3">\n</span><span class="s5">' </span><span class="s4">% (</span><span class="s1">allCallback</span><span class="s4">,</span><span class="s1">objects</span><span class="s4">,</span><span class="s1">doIdsPending</span><span class="s4">,</span><span class="s1">doIdList</span><span class="s4">))</span>
                <span class="s3">if </span><span class="s1">allCallback</span><span class="s4">:</span>
                    <span class="s1">allCallback</span><span class="s4">(</span><span class="s1">objects</span><span class="s4">)</span>

            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">notify</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">&quot;Objects still pending: %s&quot; </span><span class="s4">% (</span><span class="s1">doIdsPending</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">__generateObjectList</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">doIdList</span><span class="s4">):</span>
        <span class="s1">objects </span><span class="s4">= []</span>
        <span class="s1">doIdsPending </span><span class="s4">= []</span>

        <span class="s3">for </span><span class="s1">doId </span><span class="s3">in </span><span class="s1">doIdList</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">doId</span><span class="s4">:</span>
                <span class="s1">object </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">cr</span><span class="s4">.</span><span class="s1">doId2do</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">doId</span><span class="s4">)</span>
                <span class="s1">objects</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">object</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">object </span><span class="s4">== </span><span class="s3">None</span><span class="s4">:</span>
                    <span class="s1">doIdsPending</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">doId</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">objects</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s3">None</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">objects</span><span class="s4">, </span><span class="s1">doIdsPending</span>

</pre>
</body>
</html>