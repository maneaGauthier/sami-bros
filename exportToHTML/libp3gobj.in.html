<html>
<head>
<title>libp3gobj.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3gobj.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">9 libp3gobj 4 qQJq 12 panda3d.core </span>
<span class="s0">1562</span>
<span class="s0">1601 11 AdaptiveLru 0 260 3163 24 AdaptiveLru::AdaptiveLru 0 1 1 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">explicit AdaptiveLru::AdaptiveLru(std::string const &amp;name, std::size_t max_size);</span>

<span class="s0">1602 12 ~AdaptiveLru 0 516 3163 25 AdaptiveLru::~AdaptiveLru 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">AdaptiveLru::~AdaptiveLru(void);</span>

<span class="s0">1603 14 get_total_size 0 4 3163 27 AdaptiveLru::get_total_size 0 1 2 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total size of all objects currently active on the LRU.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::size_t AdaptiveLru::get_total_size(void) const;</span>

<span class="s0">1604 12 get_max_size 0 4 3163 25 AdaptiveLru::get_max_size 0 1 3 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the max size of all objects that are allowed to be active on the</span>
 <span class="s0">* LRU.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline std::size_t AdaptiveLru::get_max_size(void) const;</span>

<span class="s0">1605 12 set_max_size 0 4 3163 25 AdaptiveLru::set_max_size 0 1 4 143</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the max size of all objects that are allowed to be active on the</span>
 <span class="s0">* LRU.</span>
 <span class="s0">*</span>
 <span class="s0">* If the size is (size_t)-1, there is no limit.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void AdaptiveLru::set_max_size(std::size_t max_size);</span>

<span class="s0">1606 17 count_active_size 0 4 3163 30 AdaptiveLru::count_active_size 0 1 5 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total size of the pages that were enqueued since the last call</span>
 <span class="s0">* to begin_epoch().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">std::size_t AdaptiveLru::count_active_size(void) const;</span>

<span class="s0">1607 14 consider_evict 0 4 3163 27 AdaptiveLru::consider_evict 0 1 6 61</span>
<span class="s0">/**</span>
 <span class="s0">* Evicts a sequence of objects if the queue is full.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void AdaptiveLru::consider_evict(void);</span>

<span class="s0">1608 8 evict_to 0 4 3163 21 AdaptiveLru::evict_to 0 1 7 132</span>
<span class="s0">/**</span>
 <span class="s0">* Evicts a sequence of objects until the queue fits within the indicated</span>
 <span class="s0">* target size, regardless of its normal max size.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void AdaptiveLru::evict_to(std::size_t target_size);</span>

<span class="s0">1609 11 begin_epoch 0 4 3163 24 AdaptiveLru::begin_epoch 0 1 8 184</span>
<span class="s0">/**</span>
 <span class="s0">* Marks the end of the previous epoch and the beginning of the next one.</span>
 <span class="s0">* This will evict any objects that are pending eviction, and also update any</span>
 <span class="s0">* internal bookkeeping.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void AdaptiveLru::begin_epoch(void);</span>

<span class="s0">1610 8 validate 0 4 3163 21 AdaptiveLru::validate 0 1 9 125</span>
<span class="s0">/**</span>
 <span class="s0">* Checks that the LRU is internally self-consistent.  Returns true if</span>
 <span class="s0">* successful, false if there is some problem.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline bool AdaptiveLru::validate(void);</span>

<span class="s0">1611 6 output 0 4 3163 19 AdaptiveLru::output 0 1 10 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void AdaptiveLru::output(std::ostream &amp;out) const;</span>

<span class="s0">1612 5 write 0 4 3163 18 AdaptiveLru::write 0 1 11 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void AdaptiveLru::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">1613 10 set_weight 0 4 3163 23 AdaptiveLru::set_weight 0 1 12 283</span>
<span class="s0">// The following methods are specific to AdaptiveLru, and do not exist in</span>
<span class="s0">// the SimpleLru implementation.  In most cases, the defaults will be</span>
<span class="s0">// sufficient, so you do not need to mess with them.</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies the weight value used to compute the exponential moving average.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void AdaptiveLru::set_weight(PN_stdfloat weight);</span>

<span class="s0">1614 10 get_weight 0 4 3163 23 AdaptiveLru::get_weight 0 1 13 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the weight value used to compute the exponential moving average.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PN_stdfloat AdaptiveLru::get_weight(void) const;</span>

<span class="s0">1615 25 set_max_updates_per_frame 0 4 3163 38 AdaptiveLru::set_max_updates_per_frame 0 1 14 214</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the maximum number of pages the AdaptiveLru will update each</span>
 <span class="s0">* frame.  This is a performance optimization: keeping this number low limits</span>
 <span class="s0">* the impact of the AdaptiveLru's adaptive algorithm.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline void AdaptiveLru::set_max_updates_per_frame(int max_updates_per_frame);</span>

<span class="s0">1616 25 get_max_updates_per_frame 0 4 3163 38 AdaptiveLru::get_max_updates_per_frame 0 1 15 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum number of pages the AdaptiveLru will update each frame.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int AdaptiveLru::get_max_updates_per_frame(void) const;</span>

<span class="s0">1617 36 upcast_to_AdaptiveLruPageDynamicList 0 12 3165 53 AdaptiveLruPage::upcast_to_AdaptiveLruPageDynamicList 0 0 57</span>
<span class="s0">upcast from AdaptiveLruPage to AdaptiveLruPageDynamicList</span>
<span class="s0">88</span>
<span class="s0">AdaptiveLruPageDynamicList *AdaptiveLruPage::upcast_to_AdaptiveLruPageDynamicList(void);</span>

<span class="s0">1618 27 downcast_to_AdaptiveLruPage 0 12 3166 55 AdaptiveLruPageDynamicList::downcast_to_AdaptiveLruPage 0 0 59</span>
<span class="s0">downcast from AdaptiveLruPageDynamicList to AdaptiveLruPage</span>
<span class="s0">79</span>
<span class="s0">AdaptiveLruPage *AdaptiveLruPageDynamicList::downcast_to_AdaptiveLruPage(void);</span>

<span class="s0">1619 35 upcast_to_AdaptiveLruPageStaticList 0 12 3165 52 AdaptiveLruPage::upcast_to_AdaptiveLruPageStaticList 0 0 56</span>
<span class="s0">upcast from AdaptiveLruPage to AdaptiveLruPageStaticList</span>
<span class="s0">86</span>
<span class="s0">AdaptiveLruPageStaticList *AdaptiveLruPage::upcast_to_AdaptiveLruPageStaticList(void);</span>

<span class="s0">1620 27 downcast_to_AdaptiveLruPage 0 12 3167 54 AdaptiveLruPageStaticList::downcast_to_AdaptiveLruPage 0 0 58</span>
<span class="s0">downcast from AdaptiveLruPageStaticList to AdaptiveLruPage</span>
<span class="s0">78</span>
<span class="s0">AdaptiveLruPage *AdaptiveLruPageStaticList::downcast_to_AdaptiveLruPage(void);</span>

<span class="s0">1621 15 AdaptiveLruPage 0 260 3165 32 AdaptiveLruPage::AdaptiveLruPage 0 2 16 17 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">127</span>
<span class="s0">explicit AdaptiveLruPage::AdaptiveLruPage(std::size_t lru_size);</span>
<span class="s0">AdaptiveLruPage::AdaptiveLruPage(AdaptiveLruPage const &amp;copy);</span>

<span class="s0">1622 10 operator = 0 4 3165 27 AdaptiveLruPage::operator = 0 1 18 0</span>
<span class="s0">62</span>
<span class="s0">void AdaptiveLruPage::operator =(AdaptiveLruPage const &amp;copy);</span>

<span class="s0">1623 16 ~AdaptiveLruPage 0 518 3165 33 AdaptiveLruPage::~AdaptiveLruPage 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">virtual AdaptiveLruPage::~AdaptiveLruPage(void);</span>

<span class="s0">1624 7 get_lru 0 4 3165 24 AdaptiveLruPage::get_lru 0 1 19 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the LRU that manages this page, or NULL if it is not currently</span>
 <span class="s0">* managed by any LRU.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline AdaptiveLru *AdaptiveLruPage::get_lru(void) const;</span>

<span class="s0">1625 11 enqueue_lru 0 4 3165 28 AdaptiveLruPage::enqueue_lru 0 1 20 183</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the page to the LRU for the first time, or marks it recently-accessed</span>
 <span class="s0">* if it has already been added.</span>
 <span class="s0">*</span>
 <span class="s0">* If lru is NULL, it means to remove this page from its LRU.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void AdaptiveLruPage::enqueue_lru(AdaptiveLru *lru);</span>

<span class="s0">1626 11 dequeue_lru 0 4 3165 28 AdaptiveLruPage::dequeue_lru 0 1 21 49</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the page from its AdaptiveLru.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void AdaptiveLruPage::dequeue_lru(void);</span>

<span class="s0">1627 13 mark_used_lru 0 4 3165 30 AdaptiveLruPage::mark_used_lru 0 2 22 23 341</span>
<span class="s0">/**</span>
 <span class="s0">* To be called when the page is used; this will move it to the tail of the</span>
 <span class="s0">* AdaptiveLru queue it is already on.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is const because it's not technically modifying the contents of</span>
 <span class="s0">* the page itself.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* To be called when the page is used; this will move it to the tail of the</span>
 <span class="s0">* specified AdaptiveLru queue.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">inline void AdaptiveLruPage::mark_used_lru(void) const;</span>
<span class="s0">inline void AdaptiveLruPage::mark_used_lru(AdaptiveLru *lru);</span>

<span class="s0">1628 12 get_lru_size 0 4 3165 29 AdaptiveLruPage::get_lru_size 0 1 24 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of this page as reported to the LRU, presumably in bytes.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::size_t AdaptiveLruPage::get_lru_size(void) const;</span>

<span class="s0">1629 12 set_lru_size 0 4 3165 29 AdaptiveLruPage::set_lru_size 0 1 25 98</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the size of this page, presumably in bytes, although any unit is</span>
 <span class="s0">* possible.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void AdaptiveLruPage::set_lru_size(std::size_t lru_size);</span>

<span class="s0">1630 9 evict_lru 0 6 3165 26 AdaptiveLruPage::evict_lru 0 1 26 455</span>
<span class="s0">/**</span>
 <span class="s0">* Evicts the page from the LRU.  Called internally when the LRU determines</span>
 <span class="s0">* that it is full.  May also be called externally when necessary to</span>
 <span class="s0">* explicitly evict the page.</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal for this method to either evict the page as requested, do</span>
 <span class="s0">* nothing (in which case the eviction will be requested again at the next</span>
 <span class="s0">* epoch), or requeue itself on the tail of the queue (in which case the</span>
 <span class="s0">* eviction will be requested again much later).</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">virtual void AdaptiveLruPage::evict_lru(void);</span>

<span class="s0">1631 6 output 0 6 3165 23 AdaptiveLruPage::output 0 1 27 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">virtual void AdaptiveLruPage::output(std::ostream &amp;out) const;</span>

<span class="s0">1632 5 write 0 6 3165 22 AdaptiveLruPage::write 0 1 28 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">virtual void AdaptiveLruPage::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">1633 14 get_num_frames 0 4 3165 31 AdaptiveLruPage::get_num_frames 0 1 29 157</span>
<span class="s0">// Not defined in SimpleLruPage.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the number of frames since the page was first added to its LRU.</span>
 <span class="s0">* Returns 0 if it does not have an LRU.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">unsigned int AdaptiveLruPage::get_num_frames(void) const;</span>

<span class="s0">1634 23 get_num_inactive_frames 0 4 3165 40 AdaptiveLruPage::get_num_inactive_frames 0 1 30 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of frames since the page was last accessed on its LRU.</span>
 <span class="s0">* Returns 0 if it does not have an LRU.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">unsigned int AdaptiveLruPage::get_num_inactive_frames(void) const;</span>

<span class="s0">1635 9 GeomEnums 0 260 3168 20 GeomEnums::GeomEnums 0 2 31 32 0</span>
<span class="s0">102</span>
<span class="s0">inline GeomEnums::GeomEnums(void) = default;</span>
<span class="s0">inline GeomEnums::GeomEnums(GeomEnums const &amp;) = default;</span>

<span class="s0">1636 10 ~GeomEnums 0 516 3168 21 GeomEnums::~GeomEnums 0 0 0</span>
<span class="s0">28</span>
<span class="s0">GeomEnums::~GeomEnums(void);</span>

<span class="s0">1637 23 GeomVertexAnimationSpec 0 260 3176 48 GeomVertexAnimationSpec::GeomVertexAnimationSpec 0 2 33 34 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">inline GeomVertexAnimationSpec::GeomVertexAnimationSpec(void);</span>
<span class="s0">inline GeomVertexAnimationSpec::GeomVertexAnimationSpec(GeomVertexAnimationSpec const &amp;other);</span>

<span class="s0">1638 10 operator = 0 4 3176 35 GeomVertexAnimationSpec::operator = 0 1 35 0</span>
<span class="s0">86</span>
<span class="s0">inline void GeomVertexAnimationSpec::operator =(GeomVertexAnimationSpec const &amp;other);</span>

<span class="s0">1639 18 get_animation_type 0 4 3176 43 GeomVertexAnimationSpec::get_animation_type 0 1 36 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of animation represented by this spec.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">inline GeomEnums::AnimationType GeomVertexAnimationSpec::get_animation_type(void) const;</span>

<span class="s0">1640 18 get_num_transforms 0 4 3176 43 GeomVertexAnimationSpec::get_num_transforms 0 1 37 202</span>
<span class="s0">/**</span>
 <span class="s0">* This is only meaningful for animation_type AT_hardware.  It specifies the</span>
 <span class="s0">* maximum number of transforms that might be simultaneously applied to any</span>
 <span class="s0">* one vertex by the data in this format.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline int GeomVertexAnimationSpec::get_num_transforms(void) const;</span>

<span class="s0">1641 22 get_indexed_transforms 0 4 3176 47 GeomVertexAnimationSpec::get_indexed_transforms 0 1 38 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is only meaningful for animation_type AT_hardware.  If true, it</span>
 <span class="s0">* indicates that the format uses indexed animation tables.  It is false if</span>
 <span class="s0">* each vertex will reference the first _num_transforms table entries only.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline bool GeomVertexAnimationSpec::get_indexed_transforms(void) const;</span>

<span class="s0">1642 8 set_none 0 4 3176 33 GeomVertexAnimationSpec::set_none 0 1 39 74</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies that no vertex animation is represented by this spec.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void GeomVertexAnimationSpec::set_none(void);</span>

<span class="s0">1643 9 set_panda 0 4 3176 34 GeomVertexAnimationSpec::set_panda 0 1 40 168</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies that vertex animation is to be performed by Panda.  This is the</span>
 <span class="s0">* most general setting and can handle any kind of vertex animation</span>
 <span class="s0">* represented.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void GeomVertexAnimationSpec::set_panda(void);</span>

<span class="s0">1644 12 set_hardware 0 4 3176 37 GeomVertexAnimationSpec::set_hardware 0 1 41 391</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies that vertex animation is to be performed by the graphics hardware</span>
 <span class="s0">* (or at least by the graphics backend API, which is actually still free to</span>
 <span class="s0">* animate the vertices on the CPU).</span>
 <span class="s0">*</span>
 <span class="s0">* This is only legal if the graphics hardware can support the specified</span>
 <span class="s0">* limits on number of transforms and/or indexed transforms.  Also, no current</span>
 <span class="s0">* graphics API's support morphing.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline void GeomVertexAnimationSpec::set_hardware(int num_transforms, bool indexed_transforms);</span>

<span class="s0">1645 6 output 0 4 3176 31 GeomVertexAnimationSpec::output 0 1 42 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void GeomVertexAnimationSpec::output(std::ostream &amp;out) const;</span>

<span class="s0">1646 24 ~GeomVertexAnimationSpec 0 516 3176 49 GeomVertexAnimationSpec::~GeomVertexAnimationSpec 0 0 0</span>
<span class="s0">56</span>
<span class="s0">GeomVertexAnimationSpec::~GeomVertexAnimationSpec(void);</span>

<span class="s0">1647 4 make 0 4 3179 18 InternalName::make 0 2 43 44 650</span>
<span class="s0">// These versions are exposed to Python, which have additional logic to map</span>
<span class="s0">// from Python interned strings.</span>

<span class="s0">/**</span>
 <span class="s0">* The public interface for constructing an InternalName pointer.  This will</span>
 <span class="s0">* return a new InternalName representing the indicated name, if this is the</span>
 <span class="s0">* first time the particular name has been requested; if the name is already</span>
 <span class="s0">* in use, it will return the existing pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* If the string contains the '.' character, the string will be divided at the</span>
 <span class="s0">* dots and the so-defined hierarchy of names will be registered.  This is</span>
 <span class="s0">* handled transparently.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Make using a string and an integer.  Concatenates the two.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">static PointerTo&lt; InternalName &gt; InternalName::make(std::string const &amp;name, int index);</span>
<span class="s0">static PointerTo&lt; InternalName &gt; InternalName::make(PyObject *str);</span>

<span class="s0">1648 6 append 0 4 3179 20 InternalName::append 0 1 45 221</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new InternalName based on this name, with the indicated string</span>
 <span class="s0">* following it.  This is a cheaper way to construct a hierarchical name than</span>
 <span class="s0">* InternalName::make(parent-&gt;get_name() + &quot;.basename&quot;).</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">PointerTo&lt; InternalName &gt; InternalName::append(std::string const &amp;basename);</span>

<span class="s0">1649 10 get_parent 0 4 3179 24 InternalName::get_parent 0 1 46 101</span>
<span class="s0">/**</span>
 <span class="s0">* Return the parent of this InternalName.  All names have a parent, except</span>
 <span class="s0">* the root name.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline InternalName *InternalName::get_parent(void) const;</span>

<span class="s0">1650 8 get_name 0 4 3179 22 InternalName::get_name 0 1 47 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete name represented by the InternalName and all of its</span>
 <span class="s0">* parents.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">std::string InternalName::get_name(void) const;</span>

<span class="s0">1651 4 join 0 4 3179 18 InternalName::join 0 1 48 69</span>
<span class="s0">/**</span>
 <span class="s0">* Like get_name, but uses a custom separator instead of &quot;.&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">std::string InternalName::join(std::string const &amp;sep) const;</span>

<span class="s0">1652 12 get_basename 0 4 3179 26 InternalName::get_basename 0 1 49 159</span>
<span class="s0">/**</span>
 <span class="s0">* Return the name represented by just this particular InternalName object,</span>
 <span class="s0">* ignoring its parents names.  This is everything after the rightmost dot.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline std::string const &amp;InternalName::get_basename(void) const;</span>

<span class="s0">1653 13 find_ancestor 0 4 3179 27 InternalName::find_ancestor 0 1 50 293</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the ancestor with the indicated basename, or -1 if no</span>
 <span class="s0">* ancestor has that basename.  Returns 0 if this name has the basename.</span>
 <span class="s0">*</span>
 <span class="s0">* This index value may be passed to get_ancestor() or get_net_basename() to</span>
 <span class="s0">* retrieve more information about the indicated name.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">int InternalName::find_ancestor(std::string const &amp;basename) const;</span>

<span class="s0">1654 12 get_ancestor 0 4 3179 26 InternalName::get_ancestor 0 1 51 222</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ancestor with the indicated index number.  0 is this name</span>
 <span class="s0">* itself, 1 is the name's parent, 2 is the parent's parent, and so on.  If</span>
 <span class="s0">* there are not enough ancestors, returns the root InternalName.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">InternalName const *InternalName::get_ancestor(int n) const;</span>

<span class="s0">1655 7 get_top 0 4 3179 21 InternalName::get_top 0 1 52 206</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the oldest ancestor in the InternalName's chain, not counting the</span>
 <span class="s0">* root.  This will be the first name in the string, e.g.  &quot;texcoord.foo.bar&quot;</span>
 <span class="s0">* will return the InternalName &quot;texcoord&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">InternalName const *InternalName::get_top(void) const;</span>

<span class="s0">1656 16 get_net_basename 0 4 3179 30 InternalName::get_net_basename 0 1 53 192</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the basename of this name prefixed by the indicated number of</span>
 <span class="s0">* ancestors.  0 is this name's basename, 1 is parent.basename, 2 is</span>
 <span class="s0">* grandparent.parent.basename, and so on.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">std::string InternalName::get_net_basename(int n) const;</span>

<span class="s0">1657 6 output 0 4 3179 20 InternalName::output 0 1 54 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void InternalName::output(std::ostream &amp;out) const;</span>

<span class="s0">1658 8 get_root 0 4 3179 22 InternalName::get_root 0 1 55 210</span>
<span class="s0">// Some predefined built-in names.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the standard root InternalName.  This is the root of all other</span>
 <span class="s0">* InternalNames.  It has no name itself, and it is the only InternalName with</span>
 <span class="s0">* no parent.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_root(void);</span>

<span class="s0">1659 9 get_error 0 4 3179 23 InternalName::get_error 0 1 56 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;error&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_error(void);</span>

<span class="s0">1660 10 get_vertex 0 4 3179 24 InternalName::get_vertex 0 1 57 148</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;vertex&quot;.  This is the column header for</span>
 <span class="s0">* the 3-d or 4-d vertex position information for each vertex.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_vertex(void);</span>

<span class="s0">1661 10 get_normal 0 4 3179 24 InternalName::get_normal 0 1 58 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;normal&quot;.  This is the column header for</span>
 <span class="s0">* the 3-d lighting normal for each vertex.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_normal(void);</span>

<span class="s0">1662 11 get_tangent 0 4 3179 25 InternalName::get_tangent 0 1 59 295</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;tangent&quot;.  This is the column header for</span>
 <span class="s0">* the tangent vector associated with each vertex, which is a unit vector</span>
 <span class="s0">* usually perpendicular to the normal and in the direction of the U texture</span>
 <span class="s0">* coordinate change.  It is used for deriving bump maps.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_tangent(void);</span>

<span class="s0">1663 16 get_tangent_name 0 4 3179 30 InternalName::get_tangent_name 0 1 60 184</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the InternalName &quot;tangent.name&quot;, where name is the supplied string.</span>
 <span class="s0">* This is the column header for the tangent associated with the named texture</span>
 <span class="s0">* coordinate set.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_tangent_name(std::string const &amp;name);</span>

<span class="s0">1664 12 get_binormal 0 4 3179 26 InternalName::get_binormal 0 1 61 321</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;binormal&quot;.  This is the column header</span>
 <span class="s0">* for the tangent vector associated with each vertex, which is a unit vector</span>
 <span class="s0">* usually perpendicular to both the normal and the tangent, and in the</span>
 <span class="s0">* direction of the V texture coordinate change.  It is used for deriving bump</span>
 <span class="s0">* maps.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_binormal(void);</span>

<span class="s0">1665 17 get_binormal_name 0 4 3179 31 InternalName::get_binormal_name 0 1 62 187</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the InternalName &quot;binormal.name&quot;, where name is the supplied</span>
 <span class="s0">* string.  This is the column header for the binormal associated with the</span>
 <span class="s0">* named texture coordinate set.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_binormal_name(std::string const &amp;name);</span>

<span class="s0">1666 12 get_texcoord 0 4 3179 26 InternalName::get_texcoord 0 1 63 232</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;texcoord&quot;.  This is the column header</span>
 <span class="s0">* for the default texture coordinate set for each vertex.  It is also used</span>
 <span class="s0">* for identifying the default texture coordinate set in a TextureStage.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_texcoord(void);</span>

<span class="s0">1667 17 get_texcoord_name 0 4 3179 31 InternalName::get_texcoord_name 0 1 64 262</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the InternalName &quot;texcoord.name&quot;, where name is the supplied</span>
 <span class="s0">* string.  This is the column header for the named texture coordinate set for</span>
 <span class="s0">* each vertex.  It is also used for identifying the named texture coordinate</span>
 <span class="s0">* set in a TextureStage.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_texcoord_name(std::string const &amp;name);</span>

<span class="s0">1668 9 get_color 0 4 3179 23 InternalName::get_color 0 1 65 132</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;color&quot;.  This is the column header for</span>
 <span class="s0">* the 4-component color value for each vertex.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_color(void);</span>

<span class="s0">1669 10 get_rotate 0 4 3179 24 InternalName::get_rotate 0 1 66 217</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;rotate&quot;.  This is the column header for</span>
 <span class="s0">* the floating-point rotate value, which represents a number of degrees</span>
 <span class="s0">* counter-clockwise to rotate each point or point sprite.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_rotate(void);</span>

<span class="s0">1670 8 get_size 0 4 3179 22 InternalName::get_size 0 1 67 225</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;size&quot;.  This is the column header for</span>
 <span class="s0">* the floating-point size value, which overrides the thickness parameter of</span>
 <span class="s0">* the RenderModeAttrib on a per-vertex (e.g.  per-point) basis.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_size(void);</span>

<span class="s0">1671 16 get_aspect_ratio 0 4 3179 30 InternalName::get_aspect_ratio 0 1 68 250</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;aspect_ratio&quot;. This is the column header</span>
 <span class="s0">* for the floating-point aspect ratio value, which is used to define non-</span>
 <span class="s0">* square points.  This number is the ratio x / y, where y is the point size</span>
 <span class="s0">* (above).</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_aspect_ratio(void);</span>

<span class="s0">1672 19 get_transform_blend 0 4 3179 33 InternalName::get_transform_blend 0 1 69 264</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;transform_blend&quot;. This is the column</span>
 <span class="s0">* header for the integer transform_blend index, which is used to define</span>
 <span class="s0">* vertex animation on the CPU by indexing to a particular vertex weighting</span>
 <span class="s0">* from the TransformBlendTable.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_transform_blend(void);</span>

<span class="s0">1673 20 get_transform_weight 0 4 3179 34 InternalName::get_transform_weight 0 1 70 474</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;transform_weight&quot;. This is the column</span>
 <span class="s0">* header for the n-component transform_weight value, which is used in</span>
 <span class="s0">* conjuntion with &quot;transform_index&quot; to define vertex animation on the</span>
 <span class="s0">* graphics card.  The transform_weight value specifies the weight of the nth</span>
 <span class="s0">* transform.  By convention, there are 1 fewer weight values than transforms,</span>
 <span class="s0">* since the weights are assumed to sum to 1 (and the last value is therefore</span>
 <span class="s0">* implicit).</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_transform_weight(void);</span>

<span class="s0">1674 19 get_transform_index 0 4 3179 33 InternalName::get_transform_index 0 1 71 444</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;transform_index&quot;. This is the column</span>
 <span class="s0">* header for the n-component transform_index value, which is used in</span>
 <span class="s0">* conjuntion with &quot;transform_weight&quot; to define vertex animation on the</span>
 <span class="s0">* graphics card.  The transform_index value specifies the nth transform, by</span>
 <span class="s0">* lookup in the TransformTable.  The transform_index column may be omitted,</span>
 <span class="s0">* in which case the nth transform is the nth entry in the table.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_transform_index(void);</span>

<span class="s0">1675 9 get_morph 0 4 3179 23 InternalName::get_morph 0 1 72 348</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an InternalName derived from the given base column name and the</span>
 <span class="s0">* given slider name, which is the column header for the offset vector that</span>
 <span class="s0">* should be applied to the base column name when the named morph slider is</span>
 <span class="s0">* engaged.</span>
 <span class="s0">*</span>
 <span class="s0">* Each morph slider requires a set of n morph columns, one for each base</span>
 <span class="s0">* column it applies to.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_morph(InternalName *column, std::string const &amp;slider);</span>

<span class="s0">1676 9 get_index 0 4 3179 23 InternalName::get_index 0 1 73 233</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;index&quot;.  This is the column header for</span>
 <span class="s0">* the integer vertex index.  It is not used in the vertex data itself, but is</span>
 <span class="s0">* used in the GeomPrimitive structure to index into the vertex data.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_index(void);</span>

<span class="s0">1677 9 get_world 0 4 3179 23 InternalName::get_world 0 1 74 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;world&quot;.  This is used as a keyword in</span>
 <span class="s0">* the shader subsystem.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_world(void);</span>

<span class="s0">1678 10 get_camera 0 4 3179 24 InternalName::get_camera 0 1 75 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;camera&quot;.  This is used as a keyword in</span>
 <span class="s0">* the shader subsystem.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_camera(void);</span>

<span class="s0">1679 9 get_model 0 4 3179 23 InternalName::get_model 0 1 76 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;model&quot;.  This is used as a keyword in</span>
 <span class="s0">* the shader subsystem.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_model(void);</span>

<span class="s0">1680 8 get_view 0 4 3179 22 InternalName::get_view 0 1 77 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the standard InternalName &quot;view&quot;.  This is used as a keyword in the</span>
 <span class="s0">* shader subsystem.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static inline PointerTo&lt; InternalName &gt; InternalName::get_view(void);</span>

<span class="s0">1681 14 get_class_type 0 4 3179 28 InternalName::get_class_type 0 1 78 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle InternalName::get_class_type(void);</span>

<span class="s0">1682 16 GeomVertexColumn 0 260 3185 34 GeomVertexColumn::GeomVertexColumn 0 2 79 80 107</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an invalid column.  Used only when constructing from a bam file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">317</span>
<span class="s0">inline explicit GeomVertexColumn::GeomVertexColumn(CPT_InternalName name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents, int start, int column_alignment = 0, int num_elements = 0, int element_stride = 0);</span>
<span class="s0">inline GeomVertexColumn::GeomVertexColumn(GeomVertexColumn const &amp;copy);</span>

<span class="s0">1683 10 operator = 0 4 3185 28 GeomVertexColumn::operator = 0 1 81 0</span>
<span class="s0">64</span>
<span class="s0">void GeomVertexColumn::operator =(GeomVertexColumn const &amp;copy);</span>

<span class="s0">1684 17 ~GeomVertexColumn 0 516 3185 35 GeomVertexColumn::~GeomVertexColumn 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline GeomVertexColumn::~GeomVertexColumn(void);</span>

<span class="s0">1685 8 get_name 0 4 3185 26 GeomVertexColumn::get_name 0 1 82 267</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this particular data field, e.g.  &quot;vertex&quot; or &quot;normal&quot;.</span>
 <span class="s0">* The name may be a user-defined string, or it may be one of the standard</span>
 <span class="s0">* system-defined field types.  Only the system-defined field types are used</span>
 <span class="s0">* for the actual rendering.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline InternalName const *GeomVertexColumn::get_name(void) const;</span>

<span class="s0">1686 18 get_num_components 0 4 3185 36 GeomVertexColumn::get_num_components 0 1 83 194</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of components of the column: the number of instances of</span>
 <span class="s0">* the NumericType in each element.  This is usually, but not always, the same</span>
 <span class="s0">* thing as get_num_values().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int GeomVertexColumn::get_num_components(void) const;</span>

<span class="s0">1687 14 get_num_values 0 4 3185 32 GeomVertexColumn::get_num_values 0 1 84 337</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of numeric values of the column: the number of distinct</span>
 <span class="s0">* numeric values that go into each element.  This is usually, but not always,</span>
 <span class="s0">* the same thing as get_num_components(); the difference is in the case of a</span>
 <span class="s0">* composite numeric type like NT_packed_dcba, which has four numeric values</span>
 <span class="s0">* per component.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int GeomVertexColumn::get_num_values(void) const;</span>

<span class="s0">1688 16 get_num_elements 0 4 3185 34 GeomVertexColumn::get_num_elements 0 1 85 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of times this column is repeated.  This is usually 1,</span>
 <span class="s0">* except for matrices.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int GeomVertexColumn::get_num_elements(void) const;</span>

<span class="s0">1689 16 get_numeric_type 0 4 3185 34 GeomVertexColumn::get_numeric_type 0 1 86 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the token representing the numeric type of the data storage.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline GeomEnums::NumericType GeomVertexColumn::get_numeric_type(void) const;</span>

<span class="s0">1690 12 get_contents 0 4 3185 30 GeomVertexColumn::get_contents 0 1 87 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the token representing the semantic meaning of the stored value.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline GeomEnums::Contents GeomVertexColumn::get_contents(void) const;</span>

<span class="s0">1691 9 get_start 0 4 3185 27 GeomVertexColumn::get_start 0 1 88 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the byte within the array record at which this column starts.  This</span>
 <span class="s0">* can be set to non-zero to implement interleaved arrays.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int GeomVertexColumn::get_start(void) const;</span>

<span class="s0">1692 20 get_column_alignment 0 4 3185 38 GeomVertexColumn::get_column_alignment 0 1 89 299</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alignment requirements for this column.  If this is greater</span>
 <span class="s0">* than 1, it restricts the column to appear only on memory addresses that are</span>
 <span class="s0">* integer multiples of this value; this has implications for this column's</span>
 <span class="s0">* start value, as well as the stride of the resulting array.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int GeomVertexColumn::get_column_alignment(void) const;</span>

<span class="s0">1693 18 get_element_stride 0 4 3185 36 GeomVertexColumn::get_element_stride 0 1 90 133</span>
<span class="s0">/**</span>
 <span class="s0">* This value is only relevant for matrix types.  Returns the number of bytes</span>
 <span class="s0">* to add to access the next row of the matrix.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int GeomVertexColumn::get_element_stride(void) const;</span>

<span class="s0">1694 19 get_component_bytes 0 4 3185 37 GeomVertexColumn::get_component_bytes 0 1 91 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes used by each component (that is, by one element</span>
 <span class="s0">* of the numeric type).</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int GeomVertexColumn::get_component_bytes(void) const;</span>

<span class="s0">1695 15 get_total_bytes 0 4 3185 33 GeomVertexColumn::get_total_bytes 0 1 92 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes used by each element of the column:</span>
 <span class="s0">* component_bytes * num_components.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int GeomVertexColumn::get_total_bytes(void) const;</span>

<span class="s0">1696 21 has_homogeneous_coord 0 4 3185 39 GeomVertexColumn::has_homogeneous_coord 0 1 93 392</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this Contents type is one that includes a homogeneous</span>
 <span class="s0">* coordinate in the fourth component, or false otherwise.  If this is true,</span>
 <span class="s0">* correct operation on the vertex data may require scaling by the homogeneous</span>
 <span class="s0">* coordinate from time to time (but in general this is handled automatically</span>
 <span class="s0">* if you use the 3-component or smaller forms of get_data() and set_data()).</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool GeomVertexColumn::has_homogeneous_coord(void) const;</span>

<span class="s0">1697 13 overlaps_with 0 4 3185 31 GeomVertexColumn::overlaps_with 0 1 94 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this column overlaps with any of the bytes in the indicated</span>
 <span class="s0">* range, false if it does not.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline bool GeomVertexColumn::overlaps_with(int start_byte, int num_bytes) const;</span>

<span class="s0">1698 22 is_bytewise_equivalent 0 4 3185 40 GeomVertexColumn::is_bytewise_equivalent 0 1 95 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data store of this column is exactly the same as that</span>
 <span class="s0">* of the other, irrespective of name or start position within the record.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">inline bool GeomVertexColumn::is_bytewise_equivalent(GeomVertexColumn const &amp;other) const;</span>

<span class="s0">1699 8 set_name 0 4 3185 26 GeomVertexColumn::set_name 0 1 96 148</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the name of an existing column.  This is only legal on an</span>
 <span class="s0">* unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void GeomVertexColumn::set_name(InternalName *name);</span>

<span class="s0">1700 18 set_num_components 0 4 3185 36 GeomVertexColumn::set_num_components 0 1 97 163</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the number of components of an existing column.  This is only legal</span>
 <span class="s0">* on an unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void GeomVertexColumn::set_num_components(int num_components);</span>

<span class="s0">1701 16 set_numeric_type 0 4 3185 34 GeomVertexColumn::set_numeric_type 0 1 98 152</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the numeric type an existing column.  This is only legal on an</span>
 <span class="s0">* unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">void GeomVertexColumn::set_numeric_type(GeomEnums::NumericType numeric_type);</span>

<span class="s0">1702 12 set_contents 0 4 3185 30 GeomVertexColumn::set_contents 0 1 99 159</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the semantic meaning of an existing column.  This is only legal on</span>
 <span class="s0">* an unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void GeomVertexColumn::set_contents(GeomEnums::Contents contents);</span>

<span class="s0">1703 9 set_start 0 4 3185 27 GeomVertexColumn::set_start 0 1 100 153</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the start byte of an existing column.  This is only legal on an</span>
 <span class="s0">* unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void GeomVertexColumn::set_start(int start);</span>

<span class="s0">1704 20 set_column_alignment 0 4 3185 38 GeomVertexColumn::set_column_alignment 0 1 101 159</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the column alignment of an existing column.  This is only legal on</span>
 <span class="s0">* an unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void GeomVertexColumn::set_column_alignment(int column_alignment);</span>

<span class="s0">1705 6 output 0 4 3185 24 GeomVertexColumn::output 0 1 102 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void GeomVertexColumn::output(std::ostream &amp;out) const;</span>

<span class="s0">1706 37 upcast_to_TypedWritableReferenceCount 0 12 3186 60 GeomVertexArrayFormat::upcast_to_TypedWritableReferenceCount 0 1 138 64</span>
<span class="s0">upcast from GeomVertexArrayFormat to TypedWritableReferenceCount</span>
<span class="s0">96</span>
<span class="s0">TypedWritableReferenceCount *GeomVertexArrayFormat::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">1707 33 downcast_to_GeomVertexArrayFormat 0 12 3180 62 TypedWritableReferenceCount::downcast_to_GeomVertexArrayFormat 0 0 66</span>
<span class="s0">downcast from TypedWritableReferenceCount to GeomVertexArrayFormat</span>
<span class="s0">92</span>
<span class="s0">GeomVertexArrayFormat *TypedWritableReferenceCount::downcast_to_GeomVertexArrayFormat(void);</span>

<span class="s0">1708 19 upcast_to_GeomEnums 0 12 3186 42 GeomVertexArrayFormat::upcast_to_GeomEnums 0 1 139 46</span>
<span class="s0">upcast from GeomVertexArrayFormat to GeomEnums</span>
<span class="s0">60</span>
<span class="s0">GeomEnums *GeomVertexArrayFormat::upcast_to_GeomEnums(void);</span>

<span class="s0">1709 33 downcast_to_GeomVertexArrayFormat 0 12 3168 44 GeomEnums::downcast_to_GeomVertexArrayFormat 0 0 48</span>
<span class="s0">downcast from GeomEnums to GeomVertexArrayFormat</span>
<span class="s0">74</span>
<span class="s0">GeomVertexArrayFormat *GeomEnums::downcast_to_GeomVertexArrayFormat(void);</span>

<span class="s0">1710 21 GeomVertexArrayFormat 0 260 3186 44 GeomVertexArrayFormat::GeomVertexArrayFormat 0 6 103 104 105 106 107 108 70</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">1456</span>
<span class="s0">GeomVertexArrayFormat::GeomVertexArrayFormat(void);</span>
<span class="s0">GeomVertexArrayFormat::GeomVertexArrayFormat(GeomVertexArrayFormat const &amp;copy);</span>
<span class="s0">GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0);</span>
<span class="s0">GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1);</span>
<span class="s0">GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2);</span>
<span class="s0">GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2, CPT_InternalName name3, int num_components3, GeomEnums::NumericType numeric_type3, GeomEnums::Contents contents3);</span>

<span class="s0">1711 10 operator = 0 4 3186 33 GeomVertexArrayFormat::operator = 0 1 109 0</span>
<span class="s0">74</span>
<span class="s0">void GeomVertexArrayFormat::operator =(GeomVertexArrayFormat const &amp;copy);</span>

<span class="s0">1712 22 ~GeomVertexArrayFormat 0 518 3186 45 GeomVertexArrayFormat::~GeomVertexArrayFormat 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual GeomVertexArrayFormat::~GeomVertexArrayFormat(void);</span>

<span class="s0">1713 5 unref 0 6 3186 28 GeomVertexArrayFormat::unref 0 1 110 123</span>
<span class="s0">/**</span>
 <span class="s0">* This method overrides ReferenceCount::unref() to unregister the object when</span>
 <span class="s0">* its reference count goes to zero.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">virtual bool GeomVertexArrayFormat::unref(void) const;</span>

<span class="s0">1714 13 is_registered 0 4 3186 36 GeomVertexArrayFormat::is_registered 0 1 111 198</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this format has been registered, false if it has not.  It</span>
 <span class="s0">* may not be used for a Geom until it has been registered, but once</span>
 <span class="s0">* registered, it may no longer be modified.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool GeomVertexArrayFormat::is_registered(void) const;</span>

<span class="s0">1715 15 register_format 0 4 3186 38 GeomVertexArrayFormat::register_format 0 1 112 421</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated format to the registry, if there is not an equivalent</span>
 <span class="s0">* format already there; in either case, returns the pointer to the equivalent</span>
 <span class="s0">* format now in the registry.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to GeomVertexFormat::register_format(), except that you</span>
 <span class="s0">* generally need not call it explicitly.  Calling</span>
 <span class="s0">* GeomVertexFormat::register_format() automatically registers all of the</span>
 <span class="s0">* nested array formats.</span>
 <span class="s0">*/</span>
<span class="s0">130</span>
<span class="s0">static inline ConstPointerTo&lt; GeomVertexArrayFormat &gt; GeomVertexArrayFormat::register_format(GeomVertexArrayFormat const *format);</span>

<span class="s0">1716 10 get_stride 0 4 3186 33 GeomVertexArrayFormat::get_stride 0 1 113 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes reserved in the array for each vertex.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int GeomVertexArrayFormat::get_stride(void) const;</span>

<span class="s0">1717 10 set_stride 0 4 3186 33 GeomVertexArrayFormat::set_stride 0 1 114 175</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the total number of bytes reserved in the array for each vertex.</span>
 <span class="s0">* You may not reduce this below get_total_bytes(), but you may increase it</span>
 <span class="s0">* arbitrarily.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void GeomVertexArrayFormat::set_stride(int stride);</span>

<span class="s0">1718 10 get_pad_to 0 4 3186 33 GeomVertexArrayFormat::get_pad_to 0 1 115 347</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the byte divisor to which the data record must be padded to meet</span>
 <span class="s0">* hardware limitations.  For instance, if this is 4, the stride will be</span>
 <span class="s0">* automatically rounded up to the next multiple of 4 bytes.  This value is</span>
 <span class="s0">* automatically increased as needed to ensure the individual numeric</span>
 <span class="s0">* components in the array are word-aligned.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int GeomVertexArrayFormat::get_pad_to(void) const;</span>

<span class="s0">1719 10 set_pad_to 0 4 3186 33 GeomVertexArrayFormat::set_pad_to 0 1 116 355</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly sets the byte divisor to which the data record must be padded to</span>
 <span class="s0">* meet hardware limitations.  See get_pad_to().  Normally it is not necessary</span>
 <span class="s0">* to call this unless you have some specific requirements for row-to-row data</span>
 <span class="s0">* alignment.  Note that this value may be automatically increased at each</span>
 <span class="s0">* subsequent call to add_column().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void GeomVertexArrayFormat::set_pad_to(int pad_to);</span>

<span class="s0">1720 11 get_divisor 0 4 3186 34 GeomVertexArrayFormat::get_divisor 0 1 117 214</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the divisor attribute for the data in this array.  If 0, it</span>
 <span class="s0">* contains per-vertex data.  If 1, it contains per-instance data.  If higher</span>
 <span class="s0">* than 1, the read row is advanced for each n instances.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int GeomVertexArrayFormat::get_divisor(void) const;</span>

<span class="s0">1721 11 set_divisor 0 4 3186 34 GeomVertexArrayFormat::set_divisor 0 1 118 206</span>
<span class="s0">/**</span>
 <span class="s0">* Set this to 0 to indicate that this array contains per-vertex data, or to 1</span>
 <span class="s0">* to indicate that it contains per-instance data.  If higher than 1, the read</span>
 <span class="s0">* row is advanced for each n instances.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void GeomVertexArrayFormat::set_divisor(int divisor);</span>

<span class="s0">1722 15 get_total_bytes 0 4 3186 38 GeomVertexArrayFormat::get_total_bytes 0 1 119 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes used by the data types within the format,</span>
 <span class="s0">* including gaps between elements.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int GeomVertexArrayFormat::get_total_bytes(void) const;</span>

<span class="s0">1723 10 add_column 0 4 3186 33 GeomVertexArrayFormat::add_column 0 2 120 121 792</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new column to the specification.  This is a table of per-vertex</span>
 <span class="s0">* floating-point numbers such as &quot;vertex&quot; or &quot;normal&quot;; you must specify where</span>
 <span class="s0">* in each record the table starts, and how many components (dimensions) exist</span>
 <span class="s0">* per vertex.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index number of the new data type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new column to the specification.  This is a table of per-vertex</span>
 <span class="s0">* floating-point numbers such as &quot;vertex&quot; or &quot;normal&quot;; you must specify where</span>
 <span class="s0">* in each record the table starts, and how many components (dimensions) exist</span>
 <span class="s0">* per vertex.</span>
 <span class="s0">*</span>
 <span class="s0">* Adding a column with the same name as a previous type, or that overlaps</span>
 <span class="s0">* with one or more previous types, quietly removes the previous type(s).</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index number of the new data type.</span>
 <span class="s0">*/</span>
<span class="s0">261</span>
<span class="s0">int GeomVertexArrayFormat::add_column(CPT_InternalName name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents, int start = -1, int column_alignment = 0);</span>
<span class="s0">int GeomVertexArrayFormat::add_column(GeomVertexColumn const &amp;column);</span>

<span class="s0">1724 13 remove_column 0 4 3186 36 GeomVertexArrayFormat::remove_column 0 1 122 107</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the column with the indicated name, if any.  This leaves a gap in</span>
 <span class="s0">* the byte structure.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void GeomVertexArrayFormat::remove_column(InternalName const *name);</span>

<span class="s0">1725 13 clear_columns 0 4 3186 36 GeomVertexArrayFormat::clear_columns 0 1 123 104</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all columns previously added, sets the stride to zero, and prepares</span>
 <span class="s0">* to start over.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void GeomVertexArrayFormat::clear_columns(void);</span>

<span class="s0">1726 12 pack_columns 0 4 3186 35 GeomVertexArrayFormat::pack_columns 0 1 124 48</span>
<span class="s0">/**</span>
 <span class="s0">* Removes wasted space between columns.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void GeomVertexArrayFormat::pack_columns(void);</span>

<span class="s0">1727 27 align_columns_for_animation 0 4 3186 50 GeomVertexArrayFormat::align_columns_for_animation 0 1 125 319</span>
<span class="s0">/**</span>
 <span class="s0">* Reprocesses the columns in the format to align the C_point and C_vector</span>
 <span class="s0">* columns to 16-byte boundaries to allow for the more efficient SSE2</span>
 <span class="s0">* operations (assuming SSE2 is enabled in the build).</span>
 <span class="s0">*</span>
 <span class="s0">* The caller is responsible for testing vertex_animation_align_16 to decide</span>
 <span class="s0">* whether to call this method.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void GeomVertexArrayFormat::align_columns_for_animation(void);</span>

<span class="s0">1728 15 get_num_columns 0 4 3186 38 GeomVertexArrayFormat::get_num_columns 0 1 126 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of different columns in the array.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int GeomVertexArrayFormat::get_num_columns(void) const;</span>

<span class="s0">1729 10 get_column 0 4 3186 33 GeomVertexArrayFormat::get_column 0 3 127 128 129 273</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ith column of the array.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the specification with the indicated name, or NULL if the name is</span>
 <span class="s0">* not used.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the first specification that overlaps with any of the indicated</span>
 <span class="s0">* bytes in the range, or NULL if none do.</span>
 <span class="s0">*/</span>
<span class="s0">265</span>
<span class="s0">inline GeomVertexColumn const *GeomVertexArrayFormat::get_column(int i) const;</span>
<span class="s0">GeomVertexColumn const *GeomVertexArrayFormat::get_column(InternalName const *name) const;</span>
<span class="s0">GeomVertexColumn const *GeomVertexArrayFormat::get_column(int start_byte, int num_bytes) const;</span>

<span class="s0">1730 10 has_column 0 4 3186 33 GeomVertexArrayFormat::has_column 0 1 130 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the array has the named column, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline bool GeomVertexArrayFormat::has_column(InternalName const *name) const;</span>

<span class="s0">1731 17 is_data_subset_of 0 4 3186 40 GeomVertexArrayFormat::is_data_subset_of 0 1 131 309</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all of the fields in this array format are also present and</span>
 <span class="s0">* equivalent in the other array format, and in the same byte positions, and</span>
 <span class="s0">* the stride is the same.  That is, true if this format can share the same</span>
 <span class="s0">* data pointer as the other format (with possibly some unused gaps).</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">bool GeomVertexArrayFormat::is_data_subset_of(GeomVertexArrayFormat const &amp;other) const;</span>

<span class="s0">1732 18 count_unused_space 0 4 3186 41 GeomVertexArrayFormat::count_unused_space 0 1 132 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes per row that are not assigned to any column.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">int GeomVertexArrayFormat::count_unused_space(void) const;</span>

<span class="s0">1733 6 output 0 4 3186 29 GeomVertexArrayFormat::output 0 1 133 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void GeomVertexArrayFormat::output(std::ostream &amp;out) const;</span>

<span class="s0">1734 5 write 0 4 3186 28 GeomVertexArrayFormat::write 0 1 134 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">void GeomVertexArrayFormat::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1735 15 write_with_data 0 4 3186 38 GeomVertexArrayFormat::write_with_data 0 1 135 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">void GeomVertexArrayFormat::write_with_data(std::ostream &amp;out, int indent_level, GeomVertexArrayData const *array_data) const;</span>

<span class="s0">1736 17 get_format_string 0 4 3186 40 GeomVertexArrayFormat::get_format_string 0 1 136 242</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string with format codes representing the exact memory layout of</span>
 <span class="s0">* the columns in memory, as understood by Python's struct module.  If pad is</span>
 <span class="s0">* true, extra padding bytes are added to the end as 'x' characters as needed.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">std::string GeomVertexArrayFormat::get_format_string(bool pad = true) const;</span>

<span class="s0">1737 14 get_class_type 0 4 3186 37 GeomVertexArrayFormat::get_class_type 0 1 137 0</span>
<span class="s0">62</span>
<span class="s0">static TypeHandle GeomVertexArrayFormat::get_class_type(void);</span>

<span class="s0">1738 37 upcast_to_TypedWritableReferenceCount 0 12 3189 55 GeomVertexFormat::upcast_to_TypedWritableReferenceCount 0 1 199 59</span>
<span class="s0">upcast from GeomVertexFormat to TypedWritableReferenceCount</span>
<span class="s0">91</span>
<span class="s0">TypedWritableReferenceCount *GeomVertexFormat::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">1739 28 downcast_to_GeomVertexFormat 0 12 3180 57 TypedWritableReferenceCount::downcast_to_GeomVertexFormat 0 0 61</span>
<span class="s0">downcast from TypedWritableReferenceCount to GeomVertexFormat</span>
<span class="s0">82</span>
<span class="s0">GeomVertexFormat *TypedWritableReferenceCount::downcast_to_GeomVertexFormat(void);</span>

<span class="s0">1740 19 upcast_to_GeomEnums 0 12 3189 37 GeomVertexFormat::upcast_to_GeomEnums 0 1 200 41</span>
<span class="s0">upcast from GeomVertexFormat to GeomEnums</span>
<span class="s0">55</span>
<span class="s0">GeomEnums *GeomVertexFormat::upcast_to_GeomEnums(void);</span>

<span class="s0">1741 28 downcast_to_GeomVertexFormat 0 12 3168 39 GeomEnums::downcast_to_GeomVertexFormat 0 0 43</span>
<span class="s0">downcast from GeomEnums to GeomVertexFormat</span>
<span class="s0">64</span>
<span class="s0">GeomVertexFormat *GeomEnums::downcast_to_GeomVertexFormat(void);</span>

<span class="s0">1742 16 GeomVertexFormat 0 260 3189 34 GeomVertexFormat::GeomVertexFormat 0 3 140 141 142 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">186</span>
<span class="s0">GeomVertexFormat::GeomVertexFormat(void);</span>
<span class="s0">GeomVertexFormat::GeomVertexFormat(GeomVertexArrayFormat const *array_format);</span>
<span class="s0">GeomVertexFormat::GeomVertexFormat(GeomVertexFormat const &amp;copy);</span>

<span class="s0">1743 10 operator = 0 4 3189 28 GeomVertexFormat::operator = 0 1 143 0</span>
<span class="s0">64</span>
<span class="s0">void GeomVertexFormat::operator =(GeomVertexFormat const &amp;copy);</span>

<span class="s0">1744 17 ~GeomVertexFormat 0 518 3189 35 GeomVertexFormat::~GeomVertexFormat 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">virtual GeomVertexFormat::~GeomVertexFormat(void);</span>

<span class="s0">1745 5 unref 0 6 3189 23 GeomVertexFormat::unref 0 1 144 123</span>
<span class="s0">/**</span>
 <span class="s0">* This method overrides ReferenceCount::unref() to unregister the object when</span>
 <span class="s0">* its reference count goes to zero.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">virtual bool GeomVertexFormat::unref(void) const;</span>

<span class="s0">1746 13 is_registered 0 4 3189 31 GeomVertexFormat::is_registered 0 1 145 198</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this format has been registered, false if it has not.  It</span>
 <span class="s0">* may not be used for a Geom until it has been registered, but once</span>
 <span class="s0">* registered, it may no longer be modified.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool GeomVertexFormat::is_registered(void) const;</span>

<span class="s0">1747 15 register_format 0 4 3189 33 GeomVertexFormat::register_format 0 2 146 147 604</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated format to the registry, if there is not an equivalent</span>
 <span class="s0">* format already there; in either case, returns the pointer to the equivalent</span>
 <span class="s0">* format now in the registry.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called before a format may be used in a Geom.  After this</span>
 <span class="s0">* call, you should discard the original pointer you passed in (which may or</span>
 <span class="s0">* may not now be invalid) and let its reference count decrement normally; you</span>
 <span class="s0">* should use only the returned value from this point on.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of register_format() implicitly creates a one-array vertex</span>
 <span class="s0">* format from the array definition.</span>
 <span class="s0">*/</span>
<span class="s0">236</span>
<span class="s0">static inline ConstPointerTo&lt; GeomVertexFormat &gt; GeomVertexFormat::register_format(GeomVertexFormat const *format);</span>
<span class="s0">static inline ConstPointerTo&lt; GeomVertexFormat &gt; GeomVertexFormat::register_format(GeomVertexArrayFormat const *format);</span>

<span class="s0">1748 13 get_animation 0 4 3189 31 GeomVertexFormat::get_animation 0 1 148 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the GeomVertexAnimationSpec that indicates how this format's</span>
 <span class="s0">* vertices are set up for animation.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline GeomVertexAnimationSpec const &amp;GeomVertexFormat::get_animation(void) const;</span>

<span class="s0">1749 13 set_animation 0 4 3189 31 GeomVertexFormat::set_animation 0 1 149 260</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the GeomVertexAnimationSpec that indicates how this format's</span>
 <span class="s0">* vertices are set up for animation.  You should also, of course, change the</span>
 <span class="s0">* columns in the tables accordingly.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void GeomVertexFormat::set_animation(GeomVertexAnimationSpec const &amp;animation);</span>

<span class="s0">1750 24 get_post_animated_format 0 4 3189 42 GeomVertexFormat::get_post_animated_format 0 1 150 325</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable vertex format for sending the animated vertices to the</span>
 <span class="s0">* graphics backend.  This is the same format as the source format, with the</span>
 <span class="s0">* CPU-animation data elements removed.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.  The return</span>
 <span class="s0">* value will have been already registered.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">ConstPointerTo&lt; GeomVertexFormat &gt; GeomVertexFormat::get_post_animated_format(void) const;</span>

<span class="s0">1751 16 get_union_format 0 4 3189 34 GeomVertexFormat::get_union_format 0 1 151 447</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomVertexFormat that includes all of the columns defined in</span>
 <span class="s0">* either this GeomVertexFormat or the other one.  If any column is defined in</span>
 <span class="s0">* both formats with different sizes (for instance, texcoord2 vs.  texcoord3),</span>
 <span class="s0">* the new format will include the larger of the two definitions.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after both source formats have been registered.</span>
 <span class="s0">* The return value will also have been already registered.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">ConstPointerTo&lt; GeomVertexFormat &gt; GeomVertexFormat::get_union_format(GeomVertexFormat const *other) const;</span>

<span class="s0">1752 14 get_num_arrays 0 4 3189 32 GeomVertexFormat::get_num_arrays 0 1 152 223</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of individual arrays required by the format.  If the</span>
 <span class="s0">* array data is completely interleaved, this will be 1; if it is completely</span>
 <span class="s0">* parallel, this will be the same as the number of data types.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t GeomVertexFormat::get_num_arrays(void) const;</span>

<span class="s0">1753 9 get_array 0 4 3189 27 GeomVertexFormat::get_array 0 1 153 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the description of the nth array used by the format.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline GeomVertexArrayFormat const *GeomVertexFormat::get_array(std::size_t array) const;</span>

<span class="s0">1754 12 modify_array 0 4 3189 30 GeomVertexFormat::modify_array 0 1 154 190</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the indicated array.  This means</span>
 <span class="s0">* duplicating it if it is shared or registered.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">GeomVertexArrayFormat *GeomVertexFormat::modify_array(std::size_t array);</span>

<span class="s0">1755 9 set_array 0 4 3189 27 GeomVertexFormat::set_array 0 1 155 124</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the definition of the indicated array.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void GeomVertexFormat::set_array(std::size_t array, GeomVertexArrayFormat const *format);</span>

<span class="s0">1756 12 remove_array 0 4 3189 30 GeomVertexFormat::remove_array 0 1 156 115</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the nth array from the format.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void GeomVertexFormat::remove_array(std::size_t array);</span>

<span class="s0">1757 9 add_array 0 4 3189 27 GeomVertexFormat::add_array 0 1 157 243</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated array definition to the list of arrays included within</span>
 <span class="s0">* this vertex format definition.  The return value is the index number of the</span>
 <span class="s0">* new array.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">std::size_t GeomVertexFormat::add_array(GeomVertexArrayFormat const *array_format);</span>

<span class="s0">1758 12 insert_array 0 4 3189 30 GeomVertexFormat::insert_array 0 1 158 275</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated array definition to the list of arrays at the indicated</span>
 <span class="s0">* position.  This works just like add_array(), except that you can specify</span>
 <span class="s0">* which array index the new array should have.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">void GeomVertexFormat::insert_array(std::size_t array, GeomVertexArrayFormat const *array_format);</span>

<span class="s0">1759 12 clear_arrays 0 4 3189 30 GeomVertexFormat::clear_arrays 0 1 159 146</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the array definitions from the format and starts over.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void GeomVertexFormat::clear_arrays(void);</span>

<span class="s0">1760 19 remove_empty_arrays 0 4 3189 37 GeomVertexFormat::remove_empty_arrays 0 1 160 119</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the arrays that define no columns.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void GeomVertexFormat::remove_empty_arrays(void);</span>

<span class="s0">1761 15 get_num_columns 0 4 3189 33 GeomVertexFormat::get_num_columns 0 1 161 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of different columns in the specification, across</span>
 <span class="s0">* all arrays.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">std::size_t GeomVertexFormat::get_num_columns(void) const;</span>

<span class="s0">1762 14 get_array_with 0 4 3189 32 GeomVertexFormat::get_array_with 0 2 162 163 699</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number of the array with the ith column.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value can be passed to get_array_format() to get the format of</span>
 <span class="s0">* the array.  It may also be passed to GeomVertexData::get_array_data() or</span>
 <span class="s0">* get_data() or set_data() to manipulate the actual array data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the index number of the array with the indicated column, or -1 if</span>
 <span class="s0">* no arrays contained that name.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value can be passed to get_array_format() to get the format of</span>
 <span class="s0">* the array.  It may also be passed to GeomVertexData::get_array_data() or</span>
 <span class="s0">* get_data() or set_data() to manipulate the actual array data.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">int GeomVertexFormat::get_array_with(std::size_t i) const;</span>
<span class="s0">int GeomVertexFormat::get_array_with(InternalName const *name) const;</span>

<span class="s0">1763 10 get_column 0 4 3189 28 GeomVertexFormat::get_column 0 2 164 165 255</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ith column of the specification, across all arrays.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the specification with the indicated name, or NULL if the name is</span>
 <span class="s0">* not used.  Use get_array_with() to determine which array this column is</span>
 <span class="s0">* associated with.</span>
 <span class="s0">*/</span>
<span class="s0">160</span>
<span class="s0">GeomVertexColumn const *GeomVertexFormat::get_column(std::size_t i) const;</span>
<span class="s0">GeomVertexColumn const *GeomVertexFormat::get_column(InternalName const *name) const;</span>

<span class="s0">1764 10 has_column 0 4 3189 28 GeomVertexFormat::has_column 0 1 166 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the format has the named column, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline bool GeomVertexFormat::has_column(InternalName const *name) const;</span>

<span class="s0">1765 15 get_column_name 0 4 3189 33 GeomVertexFormat::get_column_name 0 1 167 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the ith column, across all arrays.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">InternalName const *GeomVertexFormat::get_column_name(std::size_t i) const;</span>

<span class="s0">1766 13 remove_column 0 4 3189 31 GeomVertexFormat::remove_column 0 1 168 370</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the named column from the format, from whichever array it exists</span>
 <span class="s0">* in.  If there are other columns remaining in the array, the array is left</span>
 <span class="s0">* with a gap where the column used to be; if this was the only column in the</span>
 <span class="s0">* array, the array is removed (unless keep_empty_array is true).</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">void GeomVertexFormat::remove_column(InternalName const *name, bool keep_empty_array = false);</span>

<span class="s0">1767 12 pack_columns 0 4 3189 30 GeomVertexFormat::pack_columns 0 1 169 48</span>
<span class="s0">/**</span>
 <span class="s0">* Removes wasted space between columns.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void GeomVertexFormat::pack_columns(void);</span>

<span class="s0">1768 27 align_columns_for_animation 0 4 3189 45 GeomVertexFormat::align_columns_for_animation 0 1 170 259</span>
<span class="s0">/**</span>
 <span class="s0">* Reprocesses the columns in the format to align the C_point and C_vector</span>
 <span class="s0">* columns to 16-byte boundaries to allow for the more efficient SSE2</span>
 <span class="s0">* operations (assuming SSE2 is enabled in the build).</span>
 <span class="s0">*</span>
 <span class="s0">* Also see maybe_align_columns_for_animation().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void GeomVertexFormat::align_columns_for_animation(void);</span>

<span class="s0">1769 33 maybe_align_columns_for_animation 0 4 3189 51 GeomVertexFormat::maybe_align_columns_for_animation 0 1 171 172</span>
<span class="s0">/**</span>
 <span class="s0">* Calls align_columns_for_animation() if this format's AnimationSpec</span>
 <span class="s0">* indicates that it contains animated vertices, and if vertex-animation-</span>
 <span class="s0">* align-16 is true.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void GeomVertexFormat::maybe_align_columns_for_animation(void);</span>

<span class="s0">1770 14 get_num_points 0 4 3189 32 GeomVertexFormat::get_num_points 0 1 172 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of columns within the format that represent points in</span>
 <span class="s0">* space.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t GeomVertexFormat::get_num_points(void) const;</span>

<span class="s0">1771 9 get_point 0 4 3189 27 GeomVertexFormat::get_point 0 1 173 219</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the nth point column.  This represents a point in</span>
 <span class="s0">* space, which should be transformed by any spatial transform matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline InternalName const *GeomVertexFormat::get_point(std::size_t n) const;</span>

<span class="s0">1772 15 get_num_vectors 0 4 3189 33 GeomVertexFormat::get_num_vectors 0 1 174 165</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of columns within the format that represent directional</span>
 <span class="s0">* vectors.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline std::size_t GeomVertexFormat::get_num_vectors(void) const;</span>

<span class="s0">1773 10 get_vector 0 4 3189 28 GeomVertexFormat::get_vector 0 1 175 239</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the nth vector column.  This represents a directional</span>
 <span class="s0">* vector, which should be transformed by any spatial transform matrix as a</span>
 <span class="s0">* vector.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline InternalName const *GeomVertexFormat::get_vector(std::size_t n) const;</span>

<span class="s0">1774 17 get_num_texcoords 0 4 3189 35 GeomVertexFormat::get_num_texcoords 0 1 176 165</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of columns within the format that represent texture</span>
 <span class="s0">* coordinates.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline std::size_t GeomVertexFormat::get_num_texcoords(void) const;</span>

<span class="s0">1775 12 get_texcoord 0 4 3189 30 GeomVertexFormat::get_texcoord 0 1 177 165</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the nth texcoord column.  This represents a texture</span>
 <span class="s0">* coordinate.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline InternalName const *GeomVertexFormat::get_texcoord(std::size_t n) const;</span>

<span class="s0">1776 14 get_num_morphs 0 4 3189 32 GeomVertexFormat::get_num_morphs 0 1 178 158</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of columns within the format that represent morph</span>
 <span class="s0">* deltas.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::size_t GeomVertexFormat::get_num_morphs(void) const;</span>

<span class="s0">1777 16 get_morph_slider 0 4 3189 34 GeomVertexFormat::get_morph_slider 0 1 179 288</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the slider name associated with the nth morph column.  This is the</span>
 <span class="s0">* name of the slider that will control the morph, and should be defined</span>
 <span class="s0">* within the SliderTable associated with the GeomVertexData.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline InternalName const *GeomVertexFormat::get_morph_slider(std::size_t n) const;</span>

<span class="s0">1778 14 get_morph_base 0 4 3189 32 GeomVertexFormat::get_morph_base 0 1 180 265</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the base column that the nth morph modifies.  This</span>
 <span class="s0">* column will also be defined within the format, and can be retrieved via</span>
 <span class="s0">* get_array_with() and/or get_column().</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline InternalName const *GeomVertexFormat::get_morph_base(std::size_t n) const;</span>

<span class="s0">1779 15 get_morph_delta 0 4 3189 33 GeomVertexFormat::get_morph_delta 0 1 181 356</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the column that defines the nth morph.  This contains</span>
 <span class="s0">* the delta offsets that are to be applied to the column defined by</span>
 <span class="s0">* get_morph_base().  This column will be defined within the format, and can</span>
 <span class="s0">* be retrieved via get_array_with() and/or get_column().</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline InternalName const *GeomVertexFormat::get_morph_delta(std::size_t n) const;</span>

<span class="s0">1780 6 output 0 4 3189 24 GeomVertexFormat::output 0 1 182 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void GeomVertexFormat::output(std::ostream &amp;out) const;</span>

<span class="s0">1781 5 write 0 4 3189 23 GeomVertexFormat::write 0 1 183 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void GeomVertexFormat::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1782 15 write_with_data 0 4 3189 33 GeomVertexFormat::write_with_data 0 1 184 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">void GeomVertexFormat::write_with_data(std::ostream &amp;out, int indent_level, GeomVertexData const *data) const;</span>

<span class="s0">1783 9 get_empty 0 4 3189 27 GeomVertexFormat::get_empty 0 1 185 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format containing no arrays at all, useful for</span>
 <span class="s0">* pull-style vertex rendering.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_empty(void);</span>

<span class="s0">1784 6 get_v3 0 4 3189 24 GeomVertexFormat::get_v3 0 1 186 288</span>
<span class="s0">// Some standard vertex formats.  No particular requirement to use one of</span>
<span class="s0">// these, but the DirectX renderers can use these formats directly, whereas</span>
<span class="s0">// any other format will have to be converted first.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with just a 3-component vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3(void);</span>

<span class="s0">1785 8 get_v3n3 0 4 3189 26 GeomVertexFormat::get_v3n3 0 1 187 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 3-component normal and a</span>
 <span class="s0">* 3-component vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3(void);</span>

<span class="s0">1786 8 get_v3t2 0 4 3189 26 GeomVertexFormat::get_v3t2 0 1 188 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate pair</span>
 <span class="s0">* and a 3-component vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3t2(void);</span>

<span class="s0">1787 10 get_v3n3t2 0 4 3189 28 GeomVertexFormat::get_v3n3t2 0 1 189 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a 3-component normal, and a 3-component vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3t2(void);</span>

<span class="s0">1788 8 get_v3cp 0 4 3189 26 GeomVertexFormat::get_v3cp 0 1 190 372</span>
<span class="s0">// These formats, with the DirectX-style packed color, may not be supported</span>
<span class="s0">// directly by OpenGL.  If you use them and the driver does not support</span>
<span class="s0">// them, the GLGraphicsStateGuardian will automatically convert to native</span>
<span class="s0">// OpenGL form (with a small runtime overhead).</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a packed color and a 3-component</span>
 <span class="s0">* vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3cp(void);</span>

<span class="s0">1789 10 get_v3cpt2 0 4 3189 28 GeomVertexFormat::get_v3cpt2 0 1 191 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a packed color, and a 3-component vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3cpt2(void);</span>

<span class="s0">1790 10 get_v3n3cp 0 4 3189 28 GeomVertexFormat::get_v3n3cp 0 1 192 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a packed color, a 3-component normal,</span>
 <span class="s0">* and a 3-component vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3cp(void);</span>

<span class="s0">1791 12 get_v3n3cpt2 0 4 3189 30 GeomVertexFormat::get_v3n3cpt2 0 1 193 166</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a packed color, a 3-component normal, and a 3-component vertex</span>
 <span class="s0">* position.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3cpt2(void);</span>

<span class="s0">1792 8 get_v3c4 0 4 3189 26 GeomVertexFormat::get_v3c4 0 1 194 426</span>
<span class="s0">// These formats, with an OpenGL-style four-byte color, are not supported</span>
<span class="s0">// directly by DirectX.  If you use them, the DXGraphicsStateGuardian will</span>
<span class="s0">// automatically convert to DirectX form (with a larger runtime overhead,</span>
<span class="s0">// since DirectX8, and old DirectX9 drivers, require everything to be</span>
<span class="s0">// interleaved together).</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 4-component color and a 3-component</span>
 <span class="s0">* vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3c4(void);</span>

<span class="s0">1793 10 get_v3c4t2 0 4 3189 28 GeomVertexFormat::get_v3c4t2 0 1 195 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a 4-component color, and a 3-component vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3c4t2(void);</span>

<span class="s0">1794 10 get_v3n3c4 0 4 3189 28 GeomVertexFormat::get_v3n3c4 0 1 196 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 4-component color, a 3-component</span>
 <span class="s0">* normal, and a 3-component vertex position.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3c4(void);</span>

<span class="s0">1795 12 get_v3n3c4t2 0 4 3189 30 GeomVertexFormat::get_v3n3c4t2 0 1 197 171</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a 4-component color, a 3-component normal, and a 3-component vertex</span>
 <span class="s0">* position.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3c4t2(void);</span>

<span class="s0">1796 14 get_class_type 0 4 3189 32 GeomVertexFormat::get_class_type 0 1 198 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle GeomVertexFormat::get_class_type(void);</span>

<span class="s0">1797 24 upcast_to_LinkedListNode 0 12 3195 35 SimpleLru::upcast_to_LinkedListNode 0 1 212 39</span>
<span class="s0">upcast from SimpleLru to LinkedListNode</span>
<span class="s0">58</span>
<span class="s0">LinkedListNode *SimpleLru::upcast_to_LinkedListNode(void);</span>

<span class="s0">1798 21 downcast_to_SimpleLru 0 12 3196 37 LinkedListNode::downcast_to_SimpleLru 0 0 41</span>
<span class="s0">downcast from LinkedListNode to SimpleLru</span>
<span class="s0">55</span>
<span class="s0">SimpleLru *LinkedListNode::downcast_to_SimpleLru(void);</span>

<span class="s0">1799 17 upcast_to_Namable 0 12 3195 28 SimpleLru::upcast_to_Namable 0 1 213 32</span>
<span class="s0">upcast from SimpleLru to Namable</span>
<span class="s0">44</span>
<span class="s0">Namable *SimpleLru::upcast_to_Namable(void);</span>

<span class="s0">1800 21 downcast_to_SimpleLru 0 12 3164 30 Namable::downcast_to_SimpleLru 0 0 34</span>
<span class="s0">downcast from Namable to SimpleLru</span>
<span class="s0">48</span>
<span class="s0">SimpleLru *Namable::downcast_to_SimpleLru(void);</span>

<span class="s0">1801 9 SimpleLru 0 260 3195 20 SimpleLru::SimpleLru 0 1 201 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">explicit SimpleLru::SimpleLru(std::string const &amp;name, std::size_t max_size);</span>

<span class="s0">1802 10 ~SimpleLru 0 516 3195 21 SimpleLru::~SimpleLru 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">SimpleLru::~SimpleLru(void);</span>

<span class="s0">1803 14 get_total_size 0 4 3195 25 SimpleLru::get_total_size 0 1 202 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total size of all objects currently active on the LRU.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline std::size_t SimpleLru::get_total_size(void) const;</span>

<span class="s0">1804 12 get_max_size 0 4 3195 23 SimpleLru::get_max_size 0 1 203 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the max size of all objects that are allowed to be active on the</span>
 <span class="s0">* LRU.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline std::size_t SimpleLru::get_max_size(void) const;</span>

<span class="s0">1805 12 set_max_size 0 4 3195 23 SimpleLru::set_max_size 0 1 204 143</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the max size of all objects that are allowed to be active on the</span>
 <span class="s0">* LRU.</span>
 <span class="s0">*</span>
 <span class="s0">* If the size is (size_t)-1, there is no limit.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void SimpleLru::set_max_size(std::size_t max_size);</span>

<span class="s0">1806 17 count_active_size 0 4 3195 28 SimpleLru::count_active_size 0 1 205 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total size of the pages that were enqueued since the last call</span>
 <span class="s0">* to begin_epoch().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">std::size_t SimpleLru::count_active_size(void) const;</span>

<span class="s0">1807 14 consider_evict 0 4 3195 25 SimpleLru::consider_evict 0 1 206 61</span>
<span class="s0">/**</span>
 <span class="s0">* Evicts a sequence of objects if the queue is full.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void SimpleLru::consider_evict(void);</span>

<span class="s0">1808 8 evict_to 0 4 3195 19 SimpleLru::evict_to 0 1 207 132</span>
<span class="s0">/**</span>
 <span class="s0">* Evicts a sequence of objects until the queue fits within the indicated</span>
 <span class="s0">* target size, regardless of its normal max size.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void SimpleLru::evict_to(std::size_t target_size);</span>

<span class="s0">1809 11 begin_epoch 0 4 3195 22 SimpleLru::begin_epoch 0 1 208 184</span>
<span class="s0">/**</span>
 <span class="s0">* Marks the end of the previous epoch and the beginning of the next one.</span>
 <span class="s0">* This will evict any objects that are pending eviction, and also update any</span>
 <span class="s0">* internal bookkeeping.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void SimpleLru::begin_epoch(void);</span>

<span class="s0">1810 8 validate 0 4 3195 19 SimpleLru::validate 0 1 209 125</span>
<span class="s0">/**</span>
 <span class="s0">* Checks that the LRU is internally self-consistent.  Returns true if</span>
 <span class="s0">* successful, false if there is some problem.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline bool SimpleLru::validate(void);</span>

<span class="s0">1811 6 output 0 4 3195 17 SimpleLru::output 0 1 210 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void SimpleLru::output(std::ostream &amp;out) const;</span>

<span class="s0">1812 5 write 0 4 3195 16 SimpleLru::write 0 1 211 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">void SimpleLru::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">1813 24 upcast_to_LinkedListNode 0 12 3197 39 SimpleLruPage::upcast_to_LinkedListNode 0 1 227 43</span>
<span class="s0">upcast from SimpleLruPage to LinkedListNode</span>
<span class="s0">62</span>
<span class="s0">LinkedListNode *SimpleLruPage::upcast_to_LinkedListNode(void);</span>

<span class="s0">1814 25 downcast_to_SimpleLruPage 0 12 3196 41 LinkedListNode::downcast_to_SimpleLruPage 0 0 45</span>
<span class="s0">downcast from LinkedListNode to SimpleLruPage</span>
<span class="s0">63</span>
<span class="s0">SimpleLruPage *LinkedListNode::downcast_to_SimpleLruPage(void);</span>

<span class="s0">1815 13 SimpleLruPage 0 260 3197 28 SimpleLruPage::SimpleLruPage 0 2 214 215 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">inline explicit SimpleLruPage::SimpleLruPage(std::size_t lru_size);</span>
<span class="s0">inline SimpleLruPage::SimpleLruPage(SimpleLruPage const &amp;copy);</span>

<span class="s0">1816 10 operator = 0 4 3197 25 SimpleLruPage::operator = 0 1 216 0</span>
<span class="s0">65</span>
<span class="s0">inline void SimpleLruPage::operator =(SimpleLruPage const &amp;copy);</span>

<span class="s0">1817 14 ~SimpleLruPage 0 518 3197 29 SimpleLruPage::~SimpleLruPage 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual SimpleLruPage::~SimpleLruPage(void);</span>

<span class="s0">1818 7 get_lru 0 4 3197 22 SimpleLruPage::get_lru 0 1 217 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the LRU that manages this page, or NULL if it is not currently</span>
 <span class="s0">* managed by any LRU.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline SimpleLru *SimpleLruPage::get_lru(void) const;</span>

<span class="s0">1819 11 enqueue_lru 0 4 3197 26 SimpleLruPage::enqueue_lru 0 1 218 183</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the page to the LRU for the first time, or marks it recently-accessed</span>
 <span class="s0">* if it has already been added.</span>
 <span class="s0">*</span>
 <span class="s0">* If lru is NULL, it means to remove this page from its LRU.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void SimpleLruPage::enqueue_lru(SimpleLru *lru);</span>

<span class="s0">1820 11 dequeue_lru 0 4 3197 26 SimpleLruPage::dequeue_lru 0 1 219 47</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the page from its SimpleLru.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void SimpleLruPage::dequeue_lru(void);</span>

<span class="s0">1821 13 mark_used_lru 0 4 3197 28 SimpleLruPage::mark_used_lru 0 2 220 221 337</span>
<span class="s0">/**</span>
 <span class="s0">* To be called when the page is used; this will move it to the tail of the</span>
 <span class="s0">* SimpleLru queue it is already on.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is const because it's not technically modifying the contents of</span>
 <span class="s0">* the page itself.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* To be called when the page is used; this will move it to the tail of the</span>
 <span class="s0">* specified SimpleLru queue.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">inline void SimpleLruPage::mark_used_lru(void) const;</span>
<span class="s0">inline void SimpleLruPage::mark_used_lru(SimpleLru *lru);</span>

<span class="s0">1822 12 get_lru_size 0 4 3197 27 SimpleLruPage::get_lru_size 0 1 222 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of this page as reported to the LRU, presumably in bytes.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::size_t SimpleLruPage::get_lru_size(void) const;</span>

<span class="s0">1823 12 set_lru_size 0 4 3197 27 SimpleLruPage::set_lru_size 0 1 223 98</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the size of this page, presumably in bytes, although any unit is</span>
 <span class="s0">* possible.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void SimpleLruPage::set_lru_size(std::size_t lru_size);</span>

<span class="s0">1824 9 evict_lru 0 6 3197 24 SimpleLruPage::evict_lru 0 1 224 455</span>
<span class="s0">/**</span>
 <span class="s0">* Evicts the page from the LRU.  Called internally when the LRU determines</span>
 <span class="s0">* that it is full.  May also be called externally when necessary to</span>
 <span class="s0">* explicitly evict the page.</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal for this method to either evict the page as requested, do</span>
 <span class="s0">* nothing (in which case the eviction will be requested again at the next</span>
 <span class="s0">* epoch), or requeue itself on the tail of the queue (in which case the</span>
 <span class="s0">* eviction will be requested again much later).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual void SimpleLruPage::evict_lru(void);</span>

<span class="s0">1825 6 output 0 6 3197 21 SimpleLruPage::output 0 1 225 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual void SimpleLruPage::output(std::ostream &amp;out) const;</span>

<span class="s0">1826 5 write 0 6 3197 20 SimpleLruPage::write 0 1 226 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">virtual void SimpleLruPage::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">1827 24 upcast_to_LinkedListNode 0 12 3198 41 SimpleAllocator::upcast_to_LinkedListNode 0 1 238 45</span>
<span class="s0">upcast from SimpleAllocator to LinkedListNode</span>
<span class="s0">64</span>
<span class="s0">LinkedListNode *SimpleAllocator::upcast_to_LinkedListNode(void);</span>

<span class="s0">1828 27 downcast_to_SimpleAllocator 0 12 3196 43 LinkedListNode::downcast_to_SimpleAllocator 0 0 47</span>
<span class="s0">downcast from LinkedListNode to SimpleAllocator</span>
<span class="s0">67</span>
<span class="s0">SimpleAllocator *LinkedListNode::downcast_to_SimpleAllocator(void);</span>

<span class="s0">1829 15 SimpleAllocator 0 260 3198 32 SimpleAllocator::SimpleAllocator 0 1 228 40</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Move constructor.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline explicit SimpleAllocator::SimpleAllocator(std::size_t max_size, Mutex &amp;lock);</span>

<span class="s0">1830 16 ~SimpleAllocator 0 518 3198 33 SimpleAllocator::~SimpleAllocator 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">virtual SimpleAllocator::~SimpleAllocator(void);</span>

<span class="s0">1831 5 alloc 0 4 3198 22 SimpleAllocator::alloc 0 1 229 198</span>
<span class="s0">/**</span>
 <span class="s0">* Allocates a new block.  Returns NULL if a block of the requested size</span>
 <span class="s0">* cannot be allocated.</span>
 <span class="s0">*</span>
 <span class="s0">* To free the allocated block, call block-&gt;free(), or simply delete the block</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">inline SimpleAllocatorBlock *SimpleAllocator::alloc(std::size_t size, std::size_t alignment = 1);</span>

<span class="s0">1832 8 is_empty 0 4 3198 25 SimpleAllocator::is_empty 0 1 230 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there are no blocks allocated on this page, or false if</span>
 <span class="s0">* there is at least one.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool SimpleAllocator::is_empty(void) const;</span>

<span class="s0">1833 14 get_total_size 0 4 3198 31 SimpleAllocator::get_total_size 0 1 231 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total size of allocated objects.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::size_t SimpleAllocator::get_total_size(void) const;</span>

<span class="s0">1834 12 get_max_size 0 4 3198 29 SimpleAllocator::get_max_size 0 1 232 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the available space for allocated objects.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::size_t SimpleAllocator::get_max_size(void) const;</span>

<span class="s0">1835 12 set_max_size 0 4 3198 29 SimpleAllocator::set_max_size 0 1 233 172</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the available space for allocated objects.  This will not affect</span>
 <span class="s0">* any already-allocated objects, but will have an effect on future calls to</span>
 <span class="s0">* alloc().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void SimpleAllocator::set_max_size(std::size_t max_size);</span>

<span class="s0">1836 14 get_contiguous 0 4 3198 31 SimpleAllocator::get_contiguous 0 1 234 299</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an upper-bound estimate of the size of the largest contiguous block</span>
 <span class="s0">* that may be allocated.  It is guaranteed that an attempt to allocate a</span>
 <span class="s0">* block larger than this will fail, though it is not guaranteed that an</span>
 <span class="s0">* attempt to allocate a block this size or smaller will succeed.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::size_t SimpleAllocator::get_contiguous(void) const;</span>

<span class="s0">1837 15 get_first_block 0 4 3198 32 SimpleAllocator::get_first_block 0 1 235 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the first allocated block, or NULL if there are no</span>
 <span class="s0">* allocated blocks.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline SimpleAllocatorBlock *SimpleAllocator::get_first_block(void) const;</span>

<span class="s0">1838 6 output 0 4 3198 23 SimpleAllocator::output 0 1 236 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void SimpleAllocator::output(std::ostream &amp;out) const;</span>

<span class="s0">1839 5 write 0 4 3198 22 SimpleAllocator::write 0 1 237 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void SimpleAllocator::write(std::ostream &amp;out) const;</span>

<span class="s0">1840 21 ~SimpleAllocatorBlock 0 516 3199 43 SimpleAllocatorBlock::~SimpleAllocatorBlock 0 0 66</span>
<span class="s0">/**</span>
 <span class="s0">* The block automatically frees itself when it destructs.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline SimpleAllocatorBlock::~SimpleAllocatorBlock(void);</span>

<span class="s0">1841 4 free 0 4 3199 26 SimpleAllocatorBlock::free 0 1 239 40</span>
<span class="s0">/**</span>
 <span class="s0">* Releases the allocated space.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void SimpleAllocatorBlock::free(void);</span>

<span class="s0">1842 13 get_allocator 0 4 3199 35 SimpleAllocatorBlock::get_allocator 0 1 240 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the SimpleAllocator object that owns this block.  Returns NULL if</span>
 <span class="s0">* the block has been freed.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline SimpleAllocator *SimpleAllocatorBlock::get_allocator(void) const;</span>

<span class="s0">1843 9 get_start 0 4 3199 31 SimpleAllocatorBlock::get_start 0 1 241 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the starting point of this block.  It is an error to call this if</span>
 <span class="s0">* the block has been freed.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::size_t SimpleAllocatorBlock::get_start(void) const;</span>

<span class="s0">1844 8 get_size 0 4 3199 30 SimpleAllocatorBlock::get_size 0 1 242 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of this block.  It is an error to call this if the block</span>
 <span class="s0">* has been freed.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t SimpleAllocatorBlock::get_size(void) const;</span>

<span class="s0">1845 7 is_free 0 4 3199 29 SimpleAllocatorBlock::is_free 0 1 243 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the block has been freed, false if it is still valid.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool SimpleAllocatorBlock::is_free(void) const;</span>

<span class="s0">1846 12 get_max_size 0 4 3199 34 SimpleAllocatorBlock::get_max_size 0 1 244 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum size this block can be reallocated to, as limited by</span>
 <span class="s0">* the following block.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::size_t SimpleAllocatorBlock::get_max_size(void) const;</span>

<span class="s0">1847 7 realloc 0 4 3199 29 SimpleAllocatorBlock::realloc 0 1 245 144</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the size of this block to the specified size.  Returns true if the</span>
 <span class="s0">* change is accepted, false if there was not enough room.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool SimpleAllocatorBlock::realloc(std::size_t size);</span>

<span class="s0">1848 14 get_next_block 0 4 3199 36 SimpleAllocatorBlock::get_next_block 0 1 246 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the next allocated block in the chain, or NULL if</span>
 <span class="s0">* there are no more allocated blocks.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline SimpleAllocatorBlock *SimpleAllocatorBlock::get_next_block(void) const;</span>

<span class="s0">1849 6 output 0 4 3199 28 SimpleAllocatorBlock::output 0 1 247 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void SimpleAllocatorBlock::output(std::ostream &amp;out) const;</span>

<span class="s0">1850 8 is_valid 0 4 3200 28 VertexDataSaveFile::is_valid 0 1 248 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the save file was successfully created and is ready for</span>
 <span class="s0">* use, false if there was an error.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool VertexDataSaveFile::is_valid(void) const;</span>

<span class="s0">1851 19 get_total_file_size 0 4 3200 39 VertexDataSaveFile::get_total_file_size 0 1 249 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of space consumed by the save file, including unused</span>
 <span class="s0">* portions.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline std::size_t VertexDataSaveFile::get_total_file_size(void) const;</span>

<span class="s0">1852 18 get_used_file_size 0 4 3200 38 VertexDataSaveFile::get_used_file_size 0 1 250 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of space within the save file that is currently in use.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline std::size_t VertexDataSaveFile::get_used_file_size(void) const;</span>

<span class="s0">1853 25 upcast_to_SimpleAllocator 0 12 3201 41 VertexDataPage::upcast_to_SimpleAllocator 0 1 269 45</span>
<span class="s0">upcast from VertexDataPage to SimpleAllocator</span>
<span class="s0">65</span>
<span class="s0">SimpleAllocator *VertexDataPage::upcast_to_SimpleAllocator(void);</span>

<span class="s0">1854 26 downcast_to_VertexDataPage 0 12 3198 43 SimpleAllocator::downcast_to_VertexDataPage 0 0 47</span>
<span class="s0">downcast from SimpleAllocator to VertexDataPage</span>
<span class="s0">66</span>
<span class="s0">VertexDataPage *SimpleAllocator::downcast_to_VertexDataPage(void);</span>

<span class="s0">1855 23 upcast_to_SimpleLruPage 0 12 3201 39 VertexDataPage::upcast_to_SimpleLruPage 0 1 270 43</span>
<span class="s0">upcast from VertexDataPage to SimpleLruPage</span>
<span class="s0">61</span>
<span class="s0">SimpleLruPage *VertexDataPage::upcast_to_SimpleLruPage(void);</span>

<span class="s0">1856 26 downcast_to_VertexDataPage 0 12 3197 41 SimpleLruPage::downcast_to_VertexDataPage 0 0 45</span>
<span class="s0">downcast from SimpleLruPage to VertexDataPage</span>
<span class="s0">64</span>
<span class="s0">VertexDataPage *SimpleLruPage::downcast_to_VertexDataPage(void);</span>

<span class="s0">1857 13 get_ram_class 0 4 3201 29 VertexDataPage::get_ram_class 0 1 251 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current ram class of the array.  If this is other than</span>
 <span class="s0">* RC_resident, the array data is not resident in memory.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline VertexDataPage::RamClass VertexDataPage::get_ram_class(void) const;</span>

<span class="s0">1858 21 get_pending_ram_class 0 4 3201 37 VertexDataPage::get_pending_ram_class 0 1 252 212</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pending ram class of the array.  If this is different from</span>
 <span class="s0">* get_ram_class(), this page has been queued to be processed by the thread.</span>
 <span class="s0">* Eventually the page will be set to this ram class.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline VertexDataPage::RamClass VertexDataPage::get_pending_ram_class(void) const;</span>

<span class="s0">1859 16 request_resident 0 4 3201 32 VertexDataPage::request_resident 0 1 253 128</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that the page will become resident soon.  Future calls to</span>
 <span class="s0">* get_page_data() will eventually return non-NULL.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void VertexDataPage::request_resident(void);</span>

<span class="s0">1860 5 alloc 0 4 3201 21 VertexDataPage::alloc 0 1 254 198</span>
<span class="s0">/**</span>
 <span class="s0">* Allocates a new block.  Returns NULL if a block of the requested size</span>
 <span class="s0">* cannot be allocated.</span>
 <span class="s0">*</span>
 <span class="s0">* To free the allocated block, call block-&gt;free(), or simply delete the block</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline VertexDataBlock *VertexDataPage::alloc(std::size_t size);</span>

<span class="s0">1861 15 get_first_block 0 4 3201 31 VertexDataPage::get_first_block 0 1 255 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the first allocated block, or NULL if there are no</span>
 <span class="s0">* allocated blocks.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline VertexDataBlock *VertexDataPage::get_first_block(void) const;</span>

<span class="s0">1862 8 get_book 0 4 3201 24 VertexDataPage::get_book 0 1 256 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the book that owns this page.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline VertexDataBook *VertexDataPage::get_book(void) const;</span>

<span class="s0">1863 14 get_global_lru 0 4 3201 30 VertexDataPage::get_global_lru 0 1 257 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global LRU object that manages the</span>
 <span class="s0">* VertexDataPage's with the indicated RamClass.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">static inline SimpleLru *VertexDataPage::get_global_lru(VertexDataPage::RamClass rclass);</span>

<span class="s0">1864 15 get_pending_lru 0 4 3201 31 VertexDataPage::get_pending_lru 0 1 258 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global LRU object that manages the</span>
 <span class="s0">* VertexDataPage's that are pending processing by the thread.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static inline SimpleLru *VertexDataPage::get_pending_lru(void);</span>

<span class="s0">1865 13 get_save_file 0 4 3201 29 VertexDataPage::get_save_file 0 1 259 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the global VertexDataSaveFile that will be used to save vertex data</span>
 <span class="s0">* buffers to disk when necessary.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline VertexDataSaveFile *VertexDataPage::get_save_file(void);</span>

<span class="s0">1866 12 save_to_disk 0 4 3201 28 VertexDataPage::save_to_disk 0 1 260 205</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the page to disk, but does not evict it from memory or affect its</span>
 <span class="s0">* LRU status.  If it gets evicted later without having been modified, it will</span>
 <span class="s0">* not need to write itself to disk again.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool VertexDataPage::save_to_disk(void);</span>

<span class="s0">1867 15 get_num_threads 0 4 3201 31 VertexDataPage::get_num_threads 0 1 261 285</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of threads that have been spawned to service vertex</span>
 <span class="s0">* paging requests, or 0 if no threads have been spawned (which may mean</span>
 <span class="s0">* either that all paging requests will be handled by the main thread, or</span>
 <span class="s0">* simply that no paging requests have yet been issued).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static inline int VertexDataPage::get_num_threads(void);</span>

<span class="s0">1868 21 get_num_pending_reads 0 4 3201 37 VertexDataPage::get_num_pending_reads 0 1 262 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of read requests that are waiting to be serviced by a</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline int VertexDataPage::get_num_pending_reads(void);</span>

<span class="s0">1869 22 get_num_pending_writes 0 4 3201 38 VertexDataPage::get_num_pending_writes 0 1 263 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of write requests that are waiting to be serviced by a</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static inline int VertexDataPage::get_num_pending_writes(void);</span>

<span class="s0">1870 12 stop_threads 0 4 3201 28 VertexDataPage::stop_threads 0 1 264 141</span>
<span class="s0">/**</span>
 <span class="s0">* Call this to stop the paging threads, if they were started.  This may block</span>
 <span class="s0">* until all of the pending tasks have been completed.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static void VertexDataPage::stop_threads(void);</span>

<span class="s0">1871 13 flush_threads 0 4 3201 29 VertexDataPage::flush_threads 0 1 265 80</span>
<span class="s0">/**</span>
 <span class="s0">* Waits for all of the pending thread tasks to finish before returning.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">static void VertexDataPage::flush_threads(void);</span>

<span class="s0">1872 6 output 0 6 3201 22 VertexDataPage::output 0 1 266 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual void VertexDataPage::output(std::ostream &amp;out) const;</span>

<span class="s0">1873 5 write 0 6 3201 21 VertexDataPage::write 0 1 267 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">virtual void VertexDataPage::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">1874 14 get_class_type 0 4 3201 30 VertexDataPage::get_class_type 0 1 268 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle VertexDataPage::get_class_type(void);</span>

<span class="s0">1875 14 VertexDataBook 0 260 3204 30 VertexDataBook::VertexDataBook 0 1 271 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">explicit VertexDataBook::VertexDataBook(std::size_t block_size);</span>

<span class="s0">1876 15 ~VertexDataBook 0 516 3204 31 VertexDataBook::~VertexDataBook 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">VertexDataBook::~VertexDataBook(void);</span>

<span class="s0">1877 5 alloc 0 4 3204 21 VertexDataBook::alloc 0 1 272 78</span>
<span class="s0">/**</span>
 <span class="s0">* Allocates and returns a new VertexDataBuffer of the requested size.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline VertexDataBlock *VertexDataBook::alloc(std::size_t size);</span>

<span class="s0">1878 13 get_num_pages 0 4 3204 29 VertexDataBook::get_num_pages 0 1 273 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of pages created for the book.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::size_t VertexDataBook::get_num_pages(void) const;</span>

<span class="s0">1879 21 count_total_page_size 0 4 3204 37 VertexDataBook::count_total_page_size 0 2 274 275 209</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total size of all bytes owned by all pages owned by this book.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the total size of all bytes owned by all pages owned by this book</span>
 <span class="s0">* that have the indicated ram class.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">std::size_t VertexDataBook::count_total_page_size(void) const;</span>
<span class="s0">std::size_t VertexDataBook::count_total_page_size(VertexDataPage::RamClass ram_class) const;</span>

<span class="s0">1880 20 count_allocated_size 0 4 3204 36 VertexDataBook::count_allocated_size 0 2 276 277 220</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total size of all bytes allocated within pages owned by this</span>
 <span class="s0">* book.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the total size of all bytes allocated within pages owned by this</span>
 <span class="s0">* book that have the indicated ram class.</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">std::size_t VertexDataBook::count_allocated_size(void) const;</span>
<span class="s0">std::size_t VertexDataBook::count_allocated_size(VertexDataPage::RamClass ram_class) const;</span>

<span class="s0">1881 12 save_to_disk 0 4 3204 28 VertexDataBook::save_to_disk 0 1 278 223</span>
<span class="s0">/**</span>
 <span class="s0">* Writes all pages to disk immediately, just in case they get evicted later.</span>
 <span class="s0">* It makes sense to make this call just before taking down a loading screen,</span>
 <span class="s0">* to minimize chugs from saving pages inadvertently later.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void VertexDataBook::save_to_disk(void);</span>

<span class="s0">1882 30 upcast_to_SimpleAllocatorBlock 0 12 3205 47 VertexDataBlock::upcast_to_SimpleAllocatorBlock 0 1 281 51</span>
<span class="s0">upcast from VertexDataBlock to SimpleAllocatorBlock</span>
<span class="s0">76</span>
<span class="s0">SimpleAllocatorBlock *VertexDataBlock::upcast_to_SimpleAllocatorBlock(void);</span>

<span class="s0">1883 27 downcast_to_VertexDataBlock 0 12 3199 49 SimpleAllocatorBlock::downcast_to_VertexDataBlock 0 0 53</span>
<span class="s0">downcast from SimpleAllocatorBlock to VertexDataBlock</span>
<span class="s0">73</span>
<span class="s0">VertexDataBlock *SimpleAllocatorBlock::downcast_to_VertexDataBlock(void);</span>

<span class="s0">1884 24 upcast_to_ReferenceCount 0 12 3205 41 VertexDataBlock::upcast_to_ReferenceCount 0 1 282 45</span>
<span class="s0">upcast from VertexDataBlock to ReferenceCount</span>
<span class="s0">64</span>
<span class="s0">ReferenceCount *VertexDataBlock::upcast_to_ReferenceCount(void);</span>

<span class="s0">1885 27 downcast_to_VertexDataBlock 0 12 3206 43 ReferenceCount::downcast_to_VertexDataBlock 0 0 47</span>
<span class="s0">downcast from ReferenceCount to VertexDataBlock</span>
<span class="s0">67</span>
<span class="s0">VertexDataBlock *ReferenceCount::downcast_to_VertexDataBlock(void);</span>

<span class="s0">1886 8 get_page 0 4 3205 25 VertexDataBlock::get_page 0 1 279 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the page from which this buffer was allocated.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline VertexDataPage *VertexDataBlock::get_page(void) const;</span>

<span class="s0">1887 14 get_next_block 0 4 3205 31 VertexDataBlock::get_next_block 0 1 280 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the next allocated block in the chain, or NULL if</span>
 <span class="s0">* there are no more allocated blocks.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline VertexDataBlock *VertexDataBlock::get_next_block(void) const;</span>

<span class="s0">1888 16 ~VertexDataBlock 0 516 3205 33 VertexDataBlock::~VertexDataBlock 0 0 0</span>
<span class="s0">40</span>
<span class="s0">VertexDataBlock::~VertexDataBlock(void);</span>

<span class="s0">1889 27 upcast_to_CopyOnWriteObject 0 12 3207 48 GeomVertexArrayData::upcast_to_CopyOnWriteObject 0 1 317 52</span>
<span class="s0">upcast from GeomVertexArrayData to CopyOnWriteObject</span>
<span class="s0">74</span>
<span class="s0">CopyOnWriteObject *GeomVertexArrayData::upcast_to_CopyOnWriteObject(void);</span>

<span class="s0">1890 31 downcast_to_GeomVertexArrayData 0 12 3208 50 CopyOnWriteObject::downcast_to_GeomVertexArrayData 0 0 54</span>
<span class="s0">downcast from CopyOnWriteObject to GeomVertexArrayData</span>
<span class="s0">78</span>
<span class="s0">GeomVertexArrayData *CopyOnWriteObject::downcast_to_GeomVertexArrayData(void);</span>

<span class="s0">1891 23 upcast_to_SimpleLruPage 0 12 3207 44 GeomVertexArrayData::upcast_to_SimpleLruPage 0 1 318 48</span>
<span class="s0">upcast from GeomVertexArrayData to SimpleLruPage</span>
<span class="s0">66</span>
<span class="s0">SimpleLruPage *GeomVertexArrayData::upcast_to_SimpleLruPage(void);</span>

<span class="s0">1892 31 downcast_to_GeomVertexArrayData 0 12 3197 46 SimpleLruPage::downcast_to_GeomVertexArrayData 0 0 50</span>
<span class="s0">downcast from SimpleLruPage to GeomVertexArrayData</span>
<span class="s0">74</span>
<span class="s0">GeomVertexArrayData *SimpleLruPage::downcast_to_GeomVertexArrayData(void);</span>

<span class="s0">1893 19 upcast_to_GeomEnums 0 12 3207 40 GeomVertexArrayData::upcast_to_GeomEnums 0 1 319 44</span>
<span class="s0">upcast from GeomVertexArrayData to GeomEnums</span>
<span class="s0">58</span>
<span class="s0">GeomEnums *GeomVertexArrayData::upcast_to_GeomEnums(void);</span>

<span class="s0">1894 31 downcast_to_GeomVertexArrayData 0 12 3168 42 GeomEnums::downcast_to_GeomVertexArrayData 0 0 46</span>
<span class="s0">downcast from GeomEnums to GeomVertexArrayData</span>
<span class="s0">70</span>
<span class="s0">GeomVertexArrayData *GeomEnums::downcast_to_GeomVertexArrayData(void);</span>

<span class="s0">1895 19 GeomVertexArrayData 0 260 3207 40 GeomVertexArrayData::GeomVertexArrayData 0 2 283 284 118</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an invalid object.  This is only used when reading from the bam</span>
 <span class="s0">* file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">201</span>
<span class="s0">explicit GeomVertexArrayData::GeomVertexArrayData(GeomVertexArrayFormat const *array_format, GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomVertexArrayData::GeomVertexArrayData(GeomVertexArrayData const &amp;copy);</span>

<span class="s0">1896 10 operator = 0 4 3207 31 GeomVertexArrayData::operator = 0 1 285 0</span>
<span class="s0">70</span>
<span class="s0">void GeomVertexArrayData::operator =(GeomVertexArrayData const &amp;copy);</span>

<span class="s0">1897 20 ~GeomVertexArrayData 0 518 3207 41 GeomVertexArrayData::~GeomVertexArrayData 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual GeomVertexArrayData::~GeomVertexArrayData(void);</span>

<span class="s0">1898 12 operator new 0 4 3207 33 GeomVertexArrayData::operator new 0 1 286 0</span>
<span class="s0">142</span>
<span class="s0">inline void *GeomVertexArrayData::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomVertexArrayData::operator new(std::size_t size, void *ptr);</span>

<span class="s0">1899 15 operator delete 0 4 3207 36 GeomVertexArrayData::operator delete 0 0 0</span>
<span class="s0">126</span>
<span class="s0">inline void GeomVertexArrayData::operator delete(void *ptr);</span>
<span class="s0">inline void GeomVertexArrayData::operator delete(void *, void *);</span>

<span class="s0">1900 12 validate_ptr 0 4 3207 33 GeomVertexArrayData::validate_ptr 0 0 0</span>
<span class="s0">70</span>
<span class="s0">static inline bool GeomVertexArrayData::validate_ptr(void const *ptr);</span>

<span class="s0">1901 10 compare_to 0 4 3207 31 GeomVertexArrayData::compare_to 0 1 287 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 0 if the two arrays are equivalent, even if they are not the same</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">int GeomVertexArrayData::compare_to(GeomVertexArrayData const &amp;other) const;</span>

<span class="s0">1902 16 get_array_format 0 4 3207 37 GeomVertexArrayData::get_array_format 0 1 288 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the format object that describes this array.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline GeomVertexArrayFormat const *GeomVertexArrayData::get_array_format(void) const;</span>

<span class="s0">1903 14 get_usage_hint 0 4 3207 35 GeomVertexArrayData::get_usage_hint 0 1 289 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the usage hint that describes to the rendering backend how often</span>
 <span class="s0">* the vertex data will be modified and/or rendered.  See geomEnums.h.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline GeomEnums::UsageHint GeomVertexArrayData::get_usage_hint(void) const;</span>

<span class="s0">1904 14 set_usage_hint 0 4 3207 35 GeomVertexArrayData::set_usage_hint 0 1 290 228</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the UsageHint hint for this array.  See get_usage_hint().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void GeomVertexArrayData::set_usage_hint(GeomEnums::UsageHint usage_hint);</span>

<span class="s0">1905 10 has_column 0 4 3207 31 GeomVertexArrayData::has_column 0 1 291 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the array has the named column, false otherwise.  This is</span>
 <span class="s0">* really just a shortcut for asking the same thing from the format.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline bool GeomVertexArrayData::has_column(InternalName const *name) const;</span>

<span class="s0">1906 12 get_num_rows 0 4 3207 33 GeomVertexArrayData::get_num_rows 0 1 292 187</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of rows stored in the array, based on the number of</span>
 <span class="s0">* bytes and the stride.  This should be the same for all arrays within a</span>
 <span class="s0">* given GeomVertexData object.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int GeomVertexArrayData::get_num_rows(void) const;</span>

<span class="s0">1907 12 set_num_rows 0 4 3207 33 GeomVertexArrayData::set_num_rows 0 1 293 659</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the length of the array to n rows.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, you would not call this directly, since all of the arrays in a</span>
 <span class="s0">* particular GeomVertexData must have the same number of rows; instead, call</span>
 <span class="s0">* GeomVertexData::set_num_rows().</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the number of rows was changed, false if the</span>
 <span class="s0">* object already contained n rows (or if there was some error).</span>
 <span class="s0">*</span>
 <span class="s0">* The new vertex data is initialized to 0, including the &quot;color&quot; column (but</span>
 <span class="s0">* see GeomVertexData::set_num_rows()).</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool GeomVertexArrayData::set_num_rows(int n);</span>

<span class="s0">1908 20 unclean_set_num_rows 0 4 3207 41 GeomVertexArrayData::unclean_set_num_rows 0 1 294 423</span>
<span class="s0">/**</span>
 <span class="s0">* This method behaves like set_num_rows(), except the new data is not</span>
 <span class="s0">* initialized.  Furthermore, after this call, *any* of the data in the</span>
 <span class="s0">* GeomVertexArrayData may be uninitialized, including the earlier rows.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, you would not call this directly, since all of the arrays in a</span>
 <span class="s0">* particular GeomVertexData must have the same number of rows; instead, call</span>
 <span class="s0">* GeomVertexData::unclean_set_num_rows().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool GeomVertexArrayData::unclean_set_num_rows(int n);</span>

<span class="s0">1909 16 reserve_num_rows 0 4 3207 37 GeomVertexArrayData::reserve_num_rows 0 1 295 313</span>
<span class="s0">/**</span>
 <span class="s0">* This ensures that enough memory space for n rows is allocated, so that you</span>
 <span class="s0">* may increase the number of rows to n without causing a new memory</span>
 <span class="s0">* allocation.  This is a performance optimization only; it is especially</span>
 <span class="s0">* useful when you know ahead of time that you will be adding n rows to the</span>
 <span class="s0">* data.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool GeomVertexArrayData::reserve_num_rows(int n);</span>

<span class="s0">1910 10 clear_rows 0 4 3207 31 GeomVertexArrayData::clear_rows 0 1 296 96</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the rows in the array.  Functionally equivalent to</span>
 <span class="s0">* set_num_rows(0).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void GeomVertexArrayData::clear_rows(void);</span>

<span class="s0">1911 19 get_data_size_bytes 0 4 3207 40 GeomVertexArrayData::get_data_size_bytes 0 1 297 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes stored in the array.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline std::size_t GeomVertexArrayData::get_data_size_bytes(void) const;</span>

<span class="s0">1912 12 get_modified 0 4 3207 33 GeomVertexArrayData::get_modified 0 1 298 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the array vertex data is modified.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline UpdateSeq GeomVertexArrayData::get_modified(void) const;</span>

<span class="s0">1913 6 output 0 6 3207 27 GeomVertexArrayData::output 0 1 299 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">virtual void GeomVertexArrayData::output(std::ostream &amp;out) const;</span>

<span class="s0">1914 5 write 0 6 3207 26 GeomVertexArrayData::write 0 1 300 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">virtual void GeomVertexArrayData::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">1915 16 request_resident 0 4 3207 37 GeomVertexArrayData::request_resident 0 1 301 281</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the vertex data is currently resident in memory.  If this</span>
 <span class="s0">* returns true, the next call to get_handle()-&gt;get_read_pointer() will</span>
 <span class="s0">* probably not block.  If this returns false, the vertex data will be brought</span>
 <span class="s0">* back into memory shortly; try again later.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">inline bool GeomVertexArrayData::request_resident(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1916 10 get_handle 0 4 3207 31 GeomVertexArrayData::get_handle 0 1 302 250</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an object that can be used to read the actual data bytes stored in</span>
 <span class="s0">* the array.  Calling this method locks the data, and will block any other</span>
 <span class="s0">* threads attempting to read or write the data, until the returned object</span>
 <span class="s0">* destructs.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">inline ConstPointerTo&lt; GeomVertexArrayDataHandle &gt; GeomVertexArrayData::get_handle(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1917 13 modify_handle 0 4 3207 34 GeomVertexArrayData::modify_handle 0 1 303 259</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an object that can be used to read or write the actual data bytes</span>
 <span class="s0">* stored in the array.  Calling this method locks the data, and will block</span>
 <span class="s0">* any other threads attempting to read or write the data, until the returned</span>
 <span class="s0">* object destructs.</span>
 <span class="s0">*/</span>
<span class="s0">136</span>
<span class="s0">inline PointerTo&lt; GeomVertexArrayDataHandle &gt; GeomVertexArrayData::modify_handle(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">1918 7 prepare 0 4 3207 28 GeomVertexArrayData::prepare 0 1 304 344</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the data should be enqueued to be prepared in the indicated</span>
 <span class="s0">* prepared_objects at the beginning of the next frame.  This will ensure the</span>
 <span class="s0">* data is already loaded into the GSG if it is expected to be rendered soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload datas from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">void GeomVertexArrayData::prepare(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">1919 11 is_prepared 0 4 3207 32 GeomVertexArrayData::is_prepared 0 1 305 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">bool GeomVertexArrayData::is_prepared(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">1920 11 prepare_now 0 4 3207 32 GeomVertexArrayData::prepare_now 0 1 306 527</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a context for the data on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) VertexBufferContext.  This assumes</span>
 <span class="s0">* that the GraphicsStateGuardian is the currently active rendering context</span>
 <span class="s0">* and that it is ready to accept new datas.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a data does not need to be explicitly prepared by the user before it may be</span>
 <span class="s0">* rendered.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">VertexBufferContext *GeomVertexArrayData::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">1921 7 release 0 4 3207 28 GeomVertexArrayData::release 0 1 307 154</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the data context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">bool GeomVertexArrayData::release(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">1922 11 release_all 0 4 3207 32 GeomVertexArrayData::release_all 0 1 308 149</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the context allocated on all objects for which the data has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">int GeomVertexArrayData::release_all(void);</span>

<span class="s0">1923 19 get_independent_lru 0 4 3207 40 GeomVertexArrayData::get_independent_lru 0 1 309 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global LRU object that manages the</span>
 <span class="s0">* GeomVertexArrayData's that have not (yet) been paged out.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline SimpleLru *GeomVertexArrayData::get_independent_lru(void);</span>

<span class="s0">1924 13 get_small_lru 0 4 3207 34 GeomVertexArrayData::get_small_lru 0 1 310 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global LRU object that manages the</span>
 <span class="s0">* GeomVertexArrayData's that are deemed too small to be paged out.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline SimpleLru *GeomVertexArrayData::get_small_lru(void);</span>

<span class="s0">1925 9 lru_epoch 0 4 3207 30 GeomVertexArrayData::lru_epoch 0 1 311 124</span>
<span class="s0">/**</span>
 <span class="s0">* Marks that an epoch has passed in each LRU.  Asks the LRU's to consider</span>
 <span class="s0">* whether they should perform evictions.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static void GeomVertexArrayData::lru_epoch(void);</span>

<span class="s0">1926 8 get_book 0 4 3207 29 GeomVertexArrayData::get_book 0 1 312 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the global VertexDataBook that will be used to allocate vertex data</span>
 <span class="s0">* buffers.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline VertexDataBook &amp;GeomVertexArrayData::get_book(void);</span>

<span class="s0">1927 13 __getbuffer__ 0 4 3207 34 GeomVertexArrayData::__getbuffer__ 0 2 313 314 0</span>
<span class="s0">173</span>
<span class="s0">int GeomVertexArrayData::__getbuffer__(PyObject *self, Py_buffer *view, int flags);</span>
<span class="s0">int GeomVertexArrayData::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;</span>

<span class="s0">1928 17 __releasebuffer__ 0 4 3207 38 GeomVertexArrayData::__releasebuffer__ 0 1 315 0</span>
<span class="s0">83</span>
<span class="s0">void GeomVertexArrayData::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">1929 14 get_class_type 0 4 3207 35 GeomVertexArrayData::get_class_type 0 1 316 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle GeomVertexArrayData::get_class_type(void);</span>

<span class="s0">1930 24 upcast_to_ReferenceCount 0 12 3212 51 GeomVertexArrayDataHandle::upcast_to_ReferenceCount 0 1 344 55</span>
<span class="s0">upcast from GeomVertexArrayDataHandle to ReferenceCount</span>
<span class="s0">74</span>
<span class="s0">ReferenceCount *GeomVertexArrayDataHandle::upcast_to_ReferenceCount(void);</span>

<span class="s0">1931 37 downcast_to_GeomVertexArrayDataHandle 0 12 3206 53 ReferenceCount::downcast_to_GeomVertexArrayDataHandle 0 0 57</span>
<span class="s0">downcast from ReferenceCount to GeomVertexArrayDataHandle</span>
<span class="s0">87</span>
<span class="s0">GeomVertexArrayDataHandle *ReferenceCount::downcast_to_GeomVertexArrayDataHandle(void);</span>

<span class="s0">1932 19 upcast_to_GeomEnums 0 12 3212 46 GeomVertexArrayDataHandle::upcast_to_GeomEnums 0 1 345 50</span>
<span class="s0">upcast from GeomVertexArrayDataHandle to GeomEnums</span>
<span class="s0">64</span>
<span class="s0">GeomEnums *GeomVertexArrayDataHandle::upcast_to_GeomEnums(void);</span>

<span class="s0">1933 37 downcast_to_GeomVertexArrayDataHandle 0 12 3168 48 GeomEnums::downcast_to_GeomVertexArrayDataHandle 0 0 52</span>
<span class="s0">downcast from GeomEnums to GeomVertexArrayDataHandle</span>
<span class="s0">82</span>
<span class="s0">GeomVertexArrayDataHandle *GeomEnums::downcast_to_GeomVertexArrayDataHandle(void);</span>

<span class="s0">1934 26 ~GeomVertexArrayDataHandle 0 518 3212 53 GeomVertexArrayDataHandle::~GeomVertexArrayDataHandle 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">virtual inline GeomVertexArrayDataHandle::~GeomVertexArrayDataHandle(void);</span>

<span class="s0">1935 10 get_object 0 4 3212 37 GeomVertexArrayDataHandle::get_object 0 2 320 321 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">inline GeomVertexArrayData const *GeomVertexArrayDataHandle::get_object(void) const;</span>
<span class="s0">inline GeomVertexArrayData *GeomVertexArrayDataHandle::get_object(void);</span>

<span class="s0">1936 16 get_array_format 0 4 3212 43 GeomVertexArrayDataHandle::get_array_format 0 1 322 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline GeomVertexArrayFormat const *GeomVertexArrayDataHandle::get_array_format(void) const;</span>

<span class="s0">1937 14 get_usage_hint 0 4 3212 41 GeomVertexArrayDataHandle::get_usage_hint 0 1 323 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline GeomEnums::UsageHint GeomVertexArrayDataHandle::get_usage_hint(void) const;</span>

<span class="s0">1938 12 get_num_rows 0 4 3212 39 GeomVertexArrayDataHandle::get_num_rows 0 1 324 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int GeomVertexArrayDataHandle::get_num_rows(void) const;</span>

<span class="s0">1939 12 set_num_rows 0 4 3212 39 GeomVertexArrayDataHandle::set_num_rows 0 1 325 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">bool GeomVertexArrayDataHandle::set_num_rows(int n);</span>

<span class="s0">1940 20 unclean_set_num_rows 0 4 3212 47 GeomVertexArrayDataHandle::unclean_set_num_rows 0 1 326 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool GeomVertexArrayDataHandle::unclean_set_num_rows(int n);</span>

<span class="s0">1941 16 reserve_num_rows 0 4 3212 43 GeomVertexArrayDataHandle::reserve_num_rows 0 1 327 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">bool GeomVertexArrayDataHandle::reserve_num_rows(int n);</span>

<span class="s0">1942 10 clear_rows 0 4 3212 37 GeomVertexArrayDataHandle::clear_rows 0 1 328 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void GeomVertexArrayDataHandle::clear_rows(void);</span>

<span class="s0">1943 19 get_data_size_bytes 0 4 3212 46 GeomVertexArrayDataHandle::get_data_size_bytes 0 1 329 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline std::size_t GeomVertexArrayDataHandle::get_data_size_bytes(void) const;</span>

<span class="s0">1944 12 get_modified 0 4 3212 39 GeomVertexArrayDataHandle::get_modified 0 1 330 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline UpdateSeq GeomVertexArrayDataHandle::get_modified(void) const;</span>

<span class="s0">1945 16 request_resident 0 4 3212 43 GeomVertexArrayDataHandle::request_resident 0 1 331 281</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the vertex data is currently resident in memory.  If this</span>
 <span class="s0">* returns true, the next call to get_handle()-&gt;get_read_pointer() will</span>
 <span class="s0">* probably not block.  If this returns false, the vertex data will be brought</span>
 <span class="s0">* back into memory shortly; try again later.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool GeomVertexArrayDataHandle::request_resident(void) const;</span>

<span class="s0">1946 11 prepare_now 0 4 3212 38 GeomVertexArrayDataHandle::prepare_now 0 1 332 527</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a context for the data on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) VertexBufferContext.  This assumes</span>
 <span class="s0">* that the GraphicsStateGuardian is the currently active rendering context</span>
 <span class="s0">* and that it is ready to accept new datas.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a data does not need to be explicitly prepared by the user before it may be</span>
 <span class="s0">* rendered.</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline VertexBufferContext *GeomVertexArrayDataHandle::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg) const;</span>

<span class="s0">1947 14 copy_data_from 0 4 3212 41 GeomVertexArrayDataHandle::copy_data_from 0 2 333 334 120</span>
<span class="s0">/**</span>
 <span class="s0">* Copies the entire data array from the other object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Copies the entire data array from the buffer.</span>
 <span class="s0">*/</span>
<span class="s0">248</span>
<span class="s0">void GeomVertexArrayDataHandle::copy_data_from(GeomVertexArrayDataHandle const *other);</span>
<span class="s0">void GeomVertexArrayDataHandle::copy_data_from(unsigned char const *source, std::size_t size);</span>
<span class="s0">void GeomVertexArrayDataHandle::copy_data_from(PyObject *buffer);</span>

<span class="s0">1948 17 copy_subdata_from 0 4 3212 44 GeomVertexArrayDataHandle::copy_subdata_from 0 3 335 336 337 398</span>
<span class="s0">/**</span>
 <span class="s0">* Copies a portion of the data array from the other object into a portion of</span>
 <span class="s0">* the data array of this object.  If to_size != from_size, the size of this</span>
 <span class="s0">* data array is adjusted accordingly.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Copies a portion of the data array from the buffer into a portion of the</span>
 <span class="s0">* data array of this object.  If to_size != from_size, the size of this data</span>
 <span class="s0">* array is adjusted accordingly.</span>
 <span class="s0">*/</span>
<span class="s0">621</span>
<span class="s0">void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, GeomVertexArrayDataHandle const *other, std::size_t from_start, std::size_t from_size);</span>
<span class="s0">void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, unsigned char const *source, std::size_t from_start, std::size_t from_size);</span>
<span class="s0">void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, PyObject *buffer);</span>
<span class="s0">void GeomVertexArrayDataHandle::copy_subdata_from(std::size_t to_start, std::size_t to_size, PyObject *buffer, std::size_t from_start, std::size_t from_size);</span>

<span class="s0">1949 8 get_data 0 4 3212 35 GeomVertexArrayDataHandle::get_data 0 1 338 177</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the entire raw data of the GeomVertexArrayData object, formatted as</span>
 <span class="s0">* a string.  This is primarily for the benefit of high-level languages such</span>
 <span class="s0">* as Python.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline vector_uchar GeomVertexArrayDataHandle::get_data(void) const;</span>

<span class="s0">1950 8 set_data 0 4 3212 35 GeomVertexArrayDataHandle::set_data 0 1 339 166</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the entire raw data array with the contents of the indicated</span>
 <span class="s0">* string.  This is primarily for the benefit of high-level languages like</span>
 <span class="s0">* Python.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void GeomVertexArrayDataHandle::set_data(vector_uchar const &amp;data);</span>

<span class="s0">1951 11 get_subdata 0 4 3212 38 GeomVertexArrayDataHandle::get_subdata 0 1 340 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a subset of the raw data of the GeomVertexArrayData object,</span>
 <span class="s0">* formatted as a string.  This is primarily for the benefit of high-level</span>
 <span class="s0">* languages such as Python.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline vector_uchar GeomVertexArrayDataHandle::get_subdata(std::size_t start, std::size_t size) const;</span>

<span class="s0">1952 11 set_subdata 0 4 3212 38 GeomVertexArrayDataHandle::set_subdata 0 1 341 232</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces a portion of the data array from the indicated string.  If size !=</span>
 <span class="s0">* data.size(), the size of this data array is adjusted accordingly.</span>
 <span class="s0">*</span>
 <span class="s0">* This is primarily for the benefit of high-level languages like Python.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">void GeomVertexArrayDataHandle::set_subdata(std::size_t start, std::size_t size, vector_uchar const &amp;data);</span>

<span class="s0">1953 9 mark_used 0 4 3212 36 GeomVertexArrayDataHandle::mark_used 0 1 342 46</span>
<span class="s0">/**</span>
 <span class="s0">* Marks the array data recently-used.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void GeomVertexArrayDataHandle::mark_used(void) const;</span>

<span class="s0">1954 14 get_class_type 0 4 3212 41 GeomVertexArrayDataHandle::get_class_type 0 1 343 0</span>
<span class="s0">66</span>
<span class="s0">static TypeHandle GeomVertexArrayDataHandle::get_class_type(void);</span>

<span class="s0">1955 12 set_max_size 0 4 3214 30 GeomCacheManager::set_max_size 0 1 346 482</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the maximum number of entries in the cache for storing pre-</span>
 <span class="s0">* processed data for rendering vertices.  This limit is flexible, and may be</span>
 <span class="s0">* temporarily exceeded if many different Geoms are pre-processed during the</span>
 <span class="s0">* space of a single frame.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not a limit on the actual vertex data, which is what it is; it is</span>
 <span class="s0">* also not a limit on the amount of memory used by the video driver or the</span>
 <span class="s0">* system graphics interface, which Panda has no control over.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void GeomCacheManager::set_max_size(int max_size) const;</span>

<span class="s0">1956 12 get_max_size 0 4 3214 30 GeomCacheManager::get_max_size 0 1 347 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum number of entries in the cache for storing pre-</span>
 <span class="s0">* processed data for rendering vertices.  See set_max_size().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int GeomCacheManager::get_max_size(void) const;</span>

<span class="s0">1957 14 get_total_size 0 4 3214 32 GeomCacheManager::get_total_size 0 1 348 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of entries currently in the cache.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int GeomCacheManager::get_total_size(void) const;</span>

<span class="s0">1958 5 flush 0 4 3214 23 GeomCacheManager::flush 0 1 349 57</span>
<span class="s0">/**</span>
 <span class="s0">* Immediately empties all elements in the cache.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">void GeomCacheManager::flush(void);</span>

<span class="s0">1959 14 get_global_ptr 0 4 3214 32 GeomCacheManager::get_global_ptr 0 1 350 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the global cache manager pointer.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">static GeomCacheManager *GeomCacheManager::get_global_ptr(void);</span>

<span class="s0">1960 10 get_matrix 0 6 3215 27 VertexTransform::get_matrix 0 1 351 0</span>
<span class="s0">69</span>
<span class="s0">virtual void VertexTransform::get_matrix(LMatrix4 &amp;matrix) const = 0;</span>

<span class="s0">1961 11 mult_matrix 0 6 3215 28 VertexTransform::mult_matrix 0 1 352 277</span>
<span class="s0">/**</span>
 <span class="s0">* Premultiplies this transform's matrix with the indicated previous matrix,</span>
 <span class="s0">* so that the result is the net composition of the given transform with this</span>
 <span class="s0">* transform.  The result is stored in the parameter &quot;result&quot;, which should</span>
 <span class="s0">* not be the same matrix as previous.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">virtual void VertexTransform::mult_matrix(LMatrix4 &amp;result, LMatrix4 const &amp;previous) const;</span>

<span class="s0">1962 17 accumulate_matrix 0 6 3215 34 VertexTransform::accumulate_matrix 0 1 353 200</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the value of this transform's matrix, modified by the indicated</span>
 <span class="s0">* weight, into the indicated accumulation matrix.  This is used to compute</span>
 <span class="s0">* the result of several blended transforms.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">virtual void VertexTransform::accumulate_matrix(LMatrix4 &amp;accum, PN_stdfloat weight) const;</span>

<span class="s0">1963 12 get_modified 0 4 3215 29 VertexTransform::get_modified 0 1 354 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number that's guaranteed to change at least every time</span>
 <span class="s0">* the value reported by get_matrix() changes.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">inline UpdateSeq VertexTransform::get_modified(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1964 6 output 0 6 3215 23 VertexTransform::output 0 1 355 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">virtual void VertexTransform::output(std::ostream &amp;out) const;</span>

<span class="s0">1965 5 write 0 6 3215 22 VertexTransform::write 0 1 356 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">virtual void VertexTransform::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">1966 17 get_next_modified 0 4 3215 34 VertexTransform::get_next_modified 0 1 357 417</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a monotonically increasing sequence.  Each time this is called, a</span>
 <span class="s0">* new sequence number is returned, higher than the previous value.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used to ensure that all VertexTransform::get_modified() calls</span>
 <span class="s0">* return an increasing number in the same space, so that</span>
 <span class="s0">* TransformBlend::get_modified() is easy to determine.  It is similar to</span>
 <span class="s0">* Geom::get_modified(), but it is in a different space.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static UpdateSeq VertexTransform::get_next_modified(Thread *current_thread);</span>

<span class="s0">1967 19 get_global_modified 0 4 3215 36 VertexTransform::get_global_modified 0 1 358 197</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the currently highest VertexTransform::get_modified() value in the</span>
 <span class="s0">* world.  This can be used as a quick way to determine if any</span>
 <span class="s0">* VertexTransforms have changed value recently.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">static inline UpdateSeq VertexTransform::get_global_modified(Thread *current_thread);</span>

<span class="s0">1968 14 get_class_type 0 4 3215 31 VertexTransform::get_class_type 0 1 359 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle VertexTransform::get_class_type(void);</span>

<span class="s0">1969 14 TransformTable 0 260 3216 30 TransformTable::TransformTable 0 2 360 361 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">TransformTable::TransformTable(void);</span>
<span class="s0">TransformTable::TransformTable(TransformTable const &amp;copy);</span>

<span class="s0">1970 10 operator = 0 4 3216 26 TransformTable::operator = 0 1 362 0</span>
<span class="s0">60</span>
<span class="s0">void TransformTable::operator =(TransformTable const &amp;copy);</span>

<span class="s0">1971 13 is_registered 0 4 3216 29 TransformTable::is_registered 0 1 363 228</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this table has been registered.  Once it has been</span>
 <span class="s0">* registered, the set of transforms in a TransformTable may not be further</span>
 <span class="s0">* modified; but it must be registered before it can be assigned to a Geom.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool TransformTable::is_registered(void) const;</span>

<span class="s0">1972 14 register_table 0 4 3216 30 TransformTable::register_table 0 1 364 551</span>
<span class="s0">/**</span>
 <span class="s0">* Registers a TransformTable for use.  This is similar to</span>
 <span class="s0">* GeomVertexFormat::register_format().  Once registered, a TransformTable may</span>
 <span class="s0">* no longer be modified (although the individual VertexTransform objects may</span>
 <span class="s0">* modify their reported transforms).</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called before a table may be used in a Geom.  After this call,</span>
 <span class="s0">* you should discard the original pointer you passed in (which may or may not</span>
 <span class="s0">* now be invalid) and let its reference count decrement normally; you should</span>
 <span class="s0">* use only the returned value from this point on.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">static inline ConstPointerTo&lt; TransformTable &gt; TransformTable::register_table(TransformTable const *table);</span>

<span class="s0">1973 18 get_num_transforms 0 4 3216 34 TransformTable::get_num_transforms 0 1 365 57</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of transforms in the table.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::size_t TransformTable::get_num_transforms(void) const;</span>

<span class="s0">1974 13 get_transform 0 4 3216 29 TransformTable::get_transform 0 1 366 50</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth transform in the table.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline VertexTransform const *TransformTable::get_transform(std::size_t n) const;</span>

<span class="s0">1975 12 get_modified 0 4 3216 28 TransformTable::get_modified 0 1 367 276</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number that's guaranteed to change at least when any</span>
 <span class="s0">* VertexTransforms in the table change.  (However, this is only true for a</span>
 <span class="s0">* registered table.  An unregistered table may or may not reflect an update</span>
 <span class="s0">* here when a VertexTransform changes.)</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline UpdateSeq TransformTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">1976 13 set_transform 0 4 3216 29 TransformTable::set_transform 0 1 368 75</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the nth transform.  Only valid for unregistered tables.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">void TransformTable::set_transform(std::size_t n, VertexTransform const *transform);</span>

<span class="s0">1977 16 insert_transform 0 4 3216 32 TransformTable::insert_transform 0 1 369 321</span>
<span class="s0">/**</span>
 <span class="s0">* Inserts a new transform to the table at the given index position.  If the</span>
 <span class="s0">* index is beyond the end of the table, appends it to the end.  Only valid</span>
 <span class="s0">* for unregistered tables.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not automatically uniquify the pointer; if the transform is</span>
 <span class="s0">* already present in the table, it will be added twice.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">void TransformTable::insert_transform(std::size_t n, VertexTransform const *transform);</span>

<span class="s0">1978 16 remove_transform 0 4 3216 32 TransformTable::remove_transform 0 1 370 74</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the nth transform.  Only valid for unregistered tables.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void TransformTable::remove_transform(std::size_t n);</span>

<span class="s0">1979 13 add_transform 0 4 3216 29 TransformTable::add_transform 0 1 371 268</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new transform to the table and returns the index number of the new</span>
 <span class="s0">* transform.  Only valid for unregistered tables.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not automatically uniquify the pointer; if the transform is</span>
 <span class="s0">* already present in the table, it will be added twice.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">std::size_t TransformTable::add_transform(VertexTransform const *transform);</span>

<span class="s0">1980 5 write 0 4 3216 21 TransformTable::write 0 1 372 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void TransformTable::write(std::ostream &amp;out) const;</span>

<span class="s0">1981 14 get_class_type 0 4 3216 30 TransformTable::get_class_type 0 1 373 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle TransformTable::get_class_type(void);</span>

<span class="s0">1982 14 TransformBlend 0 260 3219 30 TransformBlend::TransformBlend 0 6 374 375 376 377 378 379 70</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">827</span>
<span class="s0">inline TransformBlend::TransformBlend(void);</span>
<span class="s0">inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0);</span>
<span class="s0">inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1);</span>
<span class="s0">inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2);</span>
<span class="s0">inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2, VertexTransform const *transform3, PN_stdfloat weight3);</span>
<span class="s0">inline TransformBlend::TransformBlend(TransformBlend const &amp;copy);</span>

<span class="s0">1983 10 operator = 0 4 3219 26 TransformBlend::operator = 0 1 380 0</span>
<span class="s0">67</span>
<span class="s0">inline void TransformBlend::operator =(TransformBlend const &amp;copy);</span>

<span class="s0">1984 15 ~TransformBlend 0 516 3219 31 TransformBlend::~TransformBlend 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline TransformBlend::~TransformBlend(void);</span>

<span class="s0">1985 10 compare_to 0 4 3219 26 TransformBlend::compare_to 0 1 381 68</span>
<span class="s0">/**</span>
 <span class="s0">* Defines an arbitrary ordering for TransformBlend objects.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">int TransformBlend::compare_to(TransformBlend const &amp;other) const;</span>

<span class="s0">1986 10 operator &lt; 0 4 3219 26 TransformBlend::operator &lt; 0 1 382 0</span>
<span class="s0">74</span>
<span class="s0">inline bool TransformBlend::operator &lt;(TransformBlend const &amp;other) const;</span>

<span class="s0">1987 11 operator == 0 4 3219 27 TransformBlend::operator == 0 1 383 0</span>
<span class="s0">75</span>
<span class="s0">inline bool TransformBlend::operator ==(TransformBlend const &amp;other) const;</span>

<span class="s0">1988 11 operator != 0 4 3219 27 TransformBlend::operator != 0 1 384 0</span>
<span class="s0">75</span>
<span class="s0">inline bool TransformBlend::operator !=(TransformBlend const &amp;other) const;</span>

<span class="s0">1989 13 add_transform 0 4 3219 29 TransformBlend::add_transform 0 1 385 112</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new transform to the blend.  If the transform already existed,</span>
 <span class="s0">* increases its weight factor.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">void TransformBlend::add_transform(VertexTransform const *transform, PN_stdfloat weight);</span>

<span class="s0">1990 16 remove_transform 0 4 3219 32 TransformBlend::remove_transform 0 2 386 387 124</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the nth transform stored in the blend object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the indicated transform from the blend.</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">void TransformBlend::remove_transform(VertexTransform const *transform);</span>
<span class="s0">inline void TransformBlend::remove_transform(std::size_t n);</span>

<span class="s0">1991 16 limit_transforms 0 4 3219 32 TransformBlend::limit_transforms 0 1 388 192</span>
<span class="s0">/**</span>
 <span class="s0">* If the total number of transforms in the blend exceeds max_transforms,</span>
 <span class="s0">* removes the n least-important transforms as needed to reduce the number of</span>
 <span class="s0">* transforms to max_transforms.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void TransformBlend::limit_transforms(int max_transforms);</span>

<span class="s0">1992 17 normalize_weights 0 4 3219 33 TransformBlend::normalize_weights 0 1 389 189</span>
<span class="s0">/**</span>
 <span class="s0">* Rescales all of the weights on the various transforms so that they sum to</span>
 <span class="s0">* 1.0.  It is generally a good idea to call this after adding or removing</span>
 <span class="s0">* transforms from the blend.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void TransformBlend::normalize_weights(void);</span>

<span class="s0">1993 13 has_transform 0 4 3219 29 TransformBlend::has_transform 0 1 390 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the blend has the indicated transform, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">bool TransformBlend::has_transform(VertexTransform const *transform) const;</span>

<span class="s0">1994 10 get_weight 0 4 3219 26 TransformBlend::get_weight 0 2 391 392 214</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the weight associated with the nth transform stored in the blend</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the weight associated with the indicated transform, or 0 if there</span>
 <span class="s0">* is no entry for the transform.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">PN_stdfloat TransformBlend::get_weight(VertexTransform const *transform) const;</span>
<span class="s0">inline PN_stdfloat TransformBlend::get_weight(std::size_t n) const;</span>

<span class="s0">1995 18 get_num_transforms 0 4 3219 34 TransformBlend::get_num_transforms 0 1 393 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of transforms stored in the blend object.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::size_t TransformBlend::get_num_transforms(void) const;</span>

<span class="s0">1996 13 get_transform 0 4 3219 29 TransformBlend::get_transform 0 1 394 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth transform stored in the blend object.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline VertexTransform const *TransformBlend::get_transform(std::size_t n) const;</span>

<span class="s0">1997 13 set_transform 0 4 3219 29 TransformBlend::set_transform 0 1 395 65</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the nth transform stored in the blend object.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline void TransformBlend::set_transform(std::size_t n, VertexTransform const *transform);</span>

<span class="s0">1998 10 set_weight 0 4 3219 26 TransformBlend::set_weight 0 1 396 95</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the weight associated with the nth transform stored in the blend</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void TransformBlend::set_weight(std::size_t n, PN_stdfloat weight);</span>

<span class="s0">1999 12 update_blend 0 4 3219 28 TransformBlend::update_blend 0 1 397 156</span>
<span class="s0">/**</span>
 <span class="s0">* Recomputes the internal representation of the blend value, if necessary.</span>
 <span class="s0">* You should call this before calling get_blend() or transform_point().</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void TransformBlend::update_blend(Thread *current_thread) const;</span>

<span class="s0">2000 9 get_blend 0 4 3219 25 TransformBlend::get_blend 0 1 398 249</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current value of the blend, based on the current value of all</span>
 <span class="s0">* of the nested transform objects and their associated weights.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void TransformBlend::get_blend(LMatrix4 &amp;result, Thread *current_thread) const;</span>

<span class="s0">2001 15 transform_point 0 4 3219 31 TransformBlend::transform_point 0 4 399 400 401 402 654</span>
<span class="s0">/**</span>
 <span class="s0">* Transforms the indicated point by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Transforms the indicated point by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Transforms the indicated point by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Transforms the indicated point by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/</span>
<span class="s0">367</span>
<span class="s0">inline void TransformBlend::transform_point(LPoint4f &amp;point, Thread *current_thread) const;</span>
<span class="s0">inline void TransformBlend::transform_point(LPoint3f &amp;point, Thread *current_thread) const;</span>
<span class="s0">inline void TransformBlend::transform_point(LPoint4d &amp;point, Thread *current_thread) const;</span>
<span class="s0">inline void TransformBlend::transform_point(LPoint3d &amp;point, Thread *current_thread) const;</span>

<span class="s0">2002 16 transform_vector 0 4 3219 32 TransformBlend::transform_vector 0 2 403 404 328</span>
<span class="s0">/**</span>
 <span class="s0">* Transforms the indicated vector by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Transforms the indicated vector by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/</span>
<span class="s0">187</span>
<span class="s0">inline void TransformBlend::transform_vector(LVector3f &amp;point, Thread *current_thread) const;</span>
<span class="s0">inline void TransformBlend::transform_vector(LVector3d &amp;point, Thread *current_thread) const;</span>

<span class="s0">2003 12 get_modified 0 4 3219 28 TransformBlend::get_modified 0 1 405 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a counter which is guaranteed to increment at least as often as the</span>
 <span class="s0">* result of get_blend() changes.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline UpdateSeq TransformBlend::get_modified(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2004 6 output 0 4 3219 22 TransformBlend::output 0 1 406 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void TransformBlend::output(std::ostream &amp;out) const;</span>

<span class="s0">2005 5 write 0 4 3219 21 TransformBlend::write 0 1 407 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void TransformBlend::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2006 14 get_class_type 0 4 3219 30 TransformBlend::get_class_type 0 1 408 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle TransformBlend::get_class_type(void);</span>

<span class="s0">2007 19 TransformBlendTable 0 260 3222 40 TransformBlendTable::TransformBlendTable 0 2 409 410 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">TransformBlendTable::TransformBlendTable(void);</span>
<span class="s0">TransformBlendTable::TransformBlendTable(TransformBlendTable const &amp;copy);</span>

<span class="s0">2008 10 operator = 0 4 3222 31 TransformBlendTable::operator = 0 1 411 0</span>
<span class="s0">70</span>
<span class="s0">void TransformBlendTable::operator =(TransformBlendTable const &amp;copy);</span>

<span class="s0">2009 14 get_num_blends 0 4 3222 35 TransformBlendTable::get_num_blends 0 1 412 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of different blend combinations in the table.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline std::size_t TransformBlendTable::get_num_blends(void) const;</span>

<span class="s0">2010 9 get_blend 0 4 3222 30 TransformBlendTable::get_blend 0 1 413 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth blend in the table.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline TransformBlend const &amp;TransformBlendTable::get_blend(std::size_t n) const;</span>

<span class="s0">2011 12 get_modified 0 4 3222 33 TransformBlendTable::get_modified 0 1 414 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a counter which is guaranteed to increment at least when any</span>
 <span class="s0">* TransformBlends within the table have changed.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">inline UpdateSeq TransformBlendTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2012 9 set_blend 0 4 3222 30 TransformBlendTable::set_blend 0 1 415 75</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the blend at the nth position with the indicated value.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">void TransformBlendTable::set_blend(std::size_t n, TransformBlend const &amp;blend);</span>

<span class="s0">2013 12 remove_blend 0 4 3222 33 TransformBlendTable::remove_blend 0 1 416 49</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the blend at the nth position.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void TransformBlendTable::remove_blend(std::size_t n);</span>

<span class="s0">2014 9 add_blend 0 4 3222 30 TransformBlendTable::add_blend 0 1 417 167</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new blend to the table, and returns its index number.  If there is</span>
 <span class="s0">* already an identical blend in the table, simply returns that number</span>
 <span class="s0">* instead.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">std::size_t TransformBlendTable::add_blend(TransformBlend const &amp;blend);</span>

<span class="s0">2015 18 get_num_transforms 0 4 3222 39 TransformBlendTable::get_num_transforms 0 1 418 299</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of unique VertexTransform objects represented in the</span>
 <span class="s0">* table.  This will correspond to the size of the TransformTable object that</span>
 <span class="s0">* would represent the same table.  This is also the same limit reflected by</span>
 <span class="s0">* GraphicsStateGuardian::get_max_vertex_transform_indices().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int TransformBlendTable::get_num_transforms(void) const;</span>

<span class="s0">2016 31 get_max_simultaneous_transforms 0 4 3222 52 TransformBlendTable::get_max_simultaneous_transforms 0 1 419 217</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum number of unique VertexTransform objects that are</span>
 <span class="s0">* applied to any one vertex simultaneously.  This is the same limit reflected</span>
 <span class="s0">* by GraphicsStateGuardian::get_max_vertex_transforms().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline int TransformBlendTable::get_max_simultaneous_transforms(void) const;</span>

<span class="s0">2017 8 set_rows 0 4 3222 29 TransformBlendTable::set_rows 0 1 420 134</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the subset of rows (vertices) in the associated GeomVertexData</span>
 <span class="s0">* that this TransformBlendTable actually affects.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void TransformBlendTable::set_rows(SparseArray const &amp;rows);</span>

<span class="s0">2018 8 get_rows 0 4 3222 29 TransformBlendTable::get_rows 0 1 421 132</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the subset of rows (vertices) in the associated GeomVertexData that</span>
 <span class="s0">* this TransformBlendTable actually affects.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline SparseArray const &amp;TransformBlendTable::get_rows(void) const;</span>

<span class="s0">2019 11 modify_rows 0 4 3222 32 TransformBlendTable::modify_rows 0 1 422 192</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable reference to the SparseArray that specifies the subset</span>
 <span class="s0">* of rows (vertices) in the associated GeomVertexData that this</span>
 <span class="s0">* TransformBlendTable actually affects.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline SparseArray &amp;TransformBlendTable::modify_rows(void);</span>

<span class="s0">2020 5 write 0 4 3222 26 TransformBlendTable::write 0 1 423 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void TransformBlendTable::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2021 14 get_class_type 0 4 3222 35 TransformBlendTable::get_class_type 0 1 424 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle TransformBlendTable::get_class_type(void);</span>

<span class="s0">2022 8 get_name 0 4 3226 22 VertexSlider::get_name 0 1 425 201</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this particular slider.  Every unique blend shape</span>
 <span class="s0">* within a particular Geom must be identified with a different name, which is</span>
 <span class="s0">* shared by the slider that controls it.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline InternalName const *VertexSlider::get_name(void) const;</span>

<span class="s0">2023 10 get_slider 0 6 3226 24 VertexSlider::get_slider 0 1 426 0</span>
<span class="s0">61</span>
<span class="s0">virtual PN_stdfloat VertexSlider::get_slider(void) const = 0;</span>

<span class="s0">2024 12 get_modified 0 4 3226 26 VertexSlider::get_modified 0 1 427 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number that's guaranteed to change at least every time</span>
 <span class="s0">* the value reported by get_slider() changes.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">inline UpdateSeq VertexSlider::get_modified(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2025 6 output 0 6 3226 20 VertexSlider::output 0 1 428 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual void VertexSlider::output(std::ostream &amp;out) const;</span>

<span class="s0">2026 5 write 0 6 3226 19 VertexSlider::write 0 1 429 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">virtual void VertexSlider::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2027 14 get_class_type 0 4 3226 28 VertexSlider::get_class_type 0 1 430 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle VertexSlider::get_class_type(void);</span>

<span class="s0">2028 11 SliderTable 0 260 3227 24 SliderTable::SliderTable 0 2 431 432 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">SliderTable::SliderTable(void);</span>
<span class="s0">SliderTable::SliderTable(SliderTable const &amp;copy);</span>

<span class="s0">2029 10 operator = 0 4 3227 23 SliderTable::operator = 0 1 433 0</span>
<span class="s0">54</span>
<span class="s0">void SliderTable::operator =(SliderTable const &amp;copy);</span>

<span class="s0">2030 13 is_registered 0 4 3227 26 SliderTable::is_registered 0 1 434 222</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this table has been registered.  Once it has been</span>
 <span class="s0">* registered, the set of sliders in a SliderTable may not be further</span>
 <span class="s0">* modified; but it must be registered before it can be assigned to a Geom.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool SliderTable::is_registered(void) const;</span>

<span class="s0">2031 14 register_table 0 4 3227 27 SliderTable::register_table 0 1 435 539</span>
<span class="s0">/**</span>
 <span class="s0">* Registers a SliderTable for use.  This is similar to</span>
 <span class="s0">* GeomVertexFormat::register_format().  Once registered, a SliderTable may no</span>
 <span class="s0">* longer be modified (although the individual VertexSlider objects may modify</span>
 <span class="s0">* their reported sliders).</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called before a table may be used in a Geom.  After this call,</span>
 <span class="s0">* you should discard the original pointer you passed in (which may or may not</span>
 <span class="s0">* now be invalid) and let its reference count decrement normally; you should</span>
 <span class="s0">* use only the returned value from this point on.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">static inline ConstPointerTo&lt; SliderTable &gt; SliderTable::register_table(SliderTable const *table);</span>

<span class="s0">2032 15 get_num_sliders 0 4 3227 28 SliderTable::get_num_sliders 0 1 436 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of sliders in the table.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline std::size_t SliderTable::get_num_sliders(void) const;</span>

<span class="s0">2033 10 get_slider 0 4 3227 23 SliderTable::get_slider 0 1 437 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth slider in the table.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline VertexSlider const *SliderTable::get_slider(std::size_t n) const;</span>

<span class="s0">2034 15 get_slider_rows 0 4 3227 28 SliderTable::get_slider_rows 0 1 438 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of rows (vertices) governed by the nth slider in the table.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline SparseArray const &amp;SliderTable::get_slider_rows(std::size_t n) const;</span>

<span class="s0">2035 12 find_sliders 0 4 3227 25 SliderTable::find_sliders 0 1 439 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a list of slider indices that represent the list of sliders with</span>
 <span class="s0">* the indicated name, or an empty SparseArray if no slider in the table has</span>
 <span class="s0">* that name.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline SparseArray const &amp;SliderTable::find_sliders(InternalName const *name) const;</span>

<span class="s0">2036 10 has_slider 0 4 3227 23 SliderTable::has_slider 0 1 440 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the table has at least one slider by the indicated name,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool SliderTable::has_slider(InternalName const *name) const;</span>

<span class="s0">2037 8 is_empty 0 4 3227 21 SliderTable::is_empty 0 1 441 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the table has no sliders, false if it has at least one.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool SliderTable::is_empty(void) const;</span>

<span class="s0">2038 12 get_modified 0 4 3227 25 SliderTable::get_modified 0 1 442 270</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number that's guaranteed to change at least when any</span>
 <span class="s0">* VertexSliders in the table change.  (However, this is only true for a</span>
 <span class="s0">* registered table.  An unregistered table may or may not reflect an update</span>
 <span class="s0">* here when a VertexSlider changes.)</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">inline UpdateSeq SliderTable::get_modified(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2039 10 set_slider 0 4 3227 23 SliderTable::set_slider 0 1 443 72</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the nth slider.  Only valid for unregistered tables.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void SliderTable::set_slider(std::size_t n, VertexSlider const *slider);</span>

<span class="s0">2040 15 set_slider_rows 0 4 3227 28 SliderTable::set_slider_rows 0 1 444 96</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the rows affected by the nth slider.  Only valid for unregistered</span>
 <span class="s0">* tables.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void SliderTable::set_slider_rows(std::size_t n, SparseArray const &amp;rows);</span>

<span class="s0">2041 13 remove_slider 0 4 3227 26 SliderTable::remove_slider 0 1 445 71</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the nth slider.  Only valid for unregistered tables.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void SliderTable::remove_slider(std::size_t n);</span>

<span class="s0">2042 10 add_slider 0 4 3227 23 SliderTable::add_slider 0 1 446 130</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new slider to the table, and returns the index number of the new</span>
 <span class="s0">* slider.  Only valid for unregistered tables.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">std::size_t SliderTable::add_slider(VertexSlider const *slider, SparseArray const &amp;rows);</span>

<span class="s0">2043 5 write 0 4 3227 18 SliderTable::write 0 1 447 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void SliderTable::write(std::ostream &amp;out) const;</span>

<span class="s0">2044 14 get_class_type 0 4 3227 27 SliderTable::get_class_type 0 1 448 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle SliderTable::get_class_type(void);</span>

<span class="s0">2045 27 upcast_to_CopyOnWriteObject 0 12 3228 43 GeomVertexData::upcast_to_CopyOnWriteObject 0 1 507 47</span>
<span class="s0">upcast from GeomVertexData to CopyOnWriteObject</span>
<span class="s0">69</span>
<span class="s0">CopyOnWriteObject *GeomVertexData::upcast_to_CopyOnWriteObject(void);</span>

<span class="s0">2046 26 downcast_to_GeomVertexData 0 12 3208 45 CopyOnWriteObject::downcast_to_GeomVertexData 0 0 49</span>
<span class="s0">downcast from CopyOnWriteObject to GeomVertexData</span>
<span class="s0">68</span>
<span class="s0">GeomVertexData *CopyOnWriteObject::downcast_to_GeomVertexData(void);</span>

<span class="s0">2047 19 upcast_to_GeomEnums 0 12 3228 35 GeomVertexData::upcast_to_GeomEnums 0 1 508 39</span>
<span class="s0">upcast from GeomVertexData to GeomEnums</span>
<span class="s0">53</span>
<span class="s0">GeomEnums *GeomVertexData::upcast_to_GeomEnums(void);</span>

<span class="s0">2048 26 downcast_to_GeomVertexData 0 12 3168 37 GeomEnums::downcast_to_GeomVertexData 0 0 41</span>
<span class="s0">downcast from GeomEnums to GeomVertexData</span>
<span class="s0">60</span>
<span class="s0">GeomVertexData *GeomEnums::downcast_to_GeomVertexData(void);</span>

<span class="s0">2049 14 GeomVertexData 0 260 3228 30 GeomVertexData::GeomVertexData 0 3 449 450 451 336</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an invalid object.  This is only used when reading from the bam</span>
 <span class="s0">* file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This constructor copies all of the basic properties of the source</span>
 <span class="s0">* VertexData, like usage_hint and animation tables, but does not copy the</span>
 <span class="s0">* actual data, and it allows you to specify a different format.</span>
 <span class="s0">*/</span>
<span class="s0">291</span>
<span class="s0">explicit GeomVertexData::GeomVertexData(std::string const &amp;name, GeomVertexFormat const *format, GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomVertexData::GeomVertexData(GeomVertexData const &amp;copy);</span>
<span class="s0">explicit GeomVertexData::GeomVertexData(GeomVertexData const &amp;copy, GeomVertexFormat const *format);</span>

<span class="s0">2050 10 operator = 0 4 3228 26 GeomVertexData::operator = 0 1 452 0</span>
<span class="s0">60</span>
<span class="s0">void GeomVertexData::operator =(GeomVertexData const &amp;copy);</span>

<span class="s0">2051 15 ~GeomVertexData 0 518 3228 31 GeomVertexData::~GeomVertexData 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">virtual GeomVertexData::~GeomVertexData(void);</span>

<span class="s0">2052 12 operator new 0 4 3228 28 GeomVertexData::operator new 0 1 453 0</span>
<span class="s0">132</span>
<span class="s0">inline void *GeomVertexData::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomVertexData::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2053 15 operator delete 0 4 3228 31 GeomVertexData::operator delete 0 0 0</span>
<span class="s0">116</span>
<span class="s0">inline void GeomVertexData::operator delete(void *ptr);</span>
<span class="s0">inline void GeomVertexData::operator delete(void *, void *);</span>

<span class="s0">2054 12 validate_ptr 0 4 3228 28 GeomVertexData::validate_ptr 0 0 0</span>
<span class="s0">65</span>
<span class="s0">static inline bool GeomVertexData::validate_ptr(void const *ptr);</span>

<span class="s0">2055 10 compare_to 0 4 3228 26 GeomVertexData::compare_to 0 1 454 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns 0 if the two objects are equivalent, even if they are not the same</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">int GeomVertexData::compare_to(GeomVertexData const &amp;other) const;</span>

<span class="s0">2056 8 get_name 0 4 3228 24 GeomVertexData::get_name 0 1 455 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name passed to the constructor, if any.  This name is reported</span>
 <span class="s0">* on the PStats graph for vertex computations.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::string const &amp;GeomVertexData::get_name(void) const;</span>

<span class="s0">2057 8 set_name 0 4 3228 24 GeomVertexData::set_name 0 1 456 118</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the name of the vertex data.  This name is reported on the PStats</span>
 <span class="s0">* graph for vertex computations.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void GeomVertexData::set_name(std::string const &amp;name);</span>

<span class="s0">2058 14 get_usage_hint 0 4 3228 30 GeomVertexData::get_usage_hint 0 1 457 438</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the usage hint that was passed to the constructor, and which will</span>
 <span class="s0">* be passed to each array data object created initially, and arrays created</span>
 <span class="s0">* as the result of a convert_to() operation.  See geomEnums.h.</span>
 <span class="s0">*</span>
 <span class="s0">* However, each individual array may be replaced with a different array</span>
 <span class="s0">* object with an independent usage hint specified, so there is no guarantee</span>
 <span class="s0">* that the individual arrays all have the same usage_hint.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline GeomEnums::UsageHint GeomVertexData::get_usage_hint(void) const;</span>

<span class="s0">2059 14 set_usage_hint 0 4 3228 30 GeomVertexData::set_usage_hint 0 1 458 285</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the UsageHint hint for this vertex data, and for all of the arrays</span>
 <span class="s0">* that share this data.  See get_usage_hint().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void GeomVertexData::set_usage_hint(GeomEnums::UsageHint usage_hint);</span>

<span class="s0">2060 10 get_format 0 4 3228 26 GeomVertexData::get_format 0 1 459 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the GeomVertexFormat structure that defines this data.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline GeomVertexFormat const *GeomVertexData::get_format(void) const;</span>

<span class="s0">2061 10 set_format 0 4 3228 26 GeomVertexData::set_format 0 1 460 294</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the format of the vertex data.  If the data is not empty, this will</span>
 <span class="s0">* implicitly change every row to match the new format.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void GeomVertexData::set_format(GeomVertexFormat const *format);</span>

<span class="s0">2062 18 unclean_set_format 0 4 3228 34 GeomVertexData::unclean_set_format 0 1 461 440</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the format of the vertex data, without reformatting the data to</span>
 <span class="s0">* match.  The data is exactly the same after this operation, but will be</span>
 <span class="s0">* reinterpreted according to the new format.  This assumes that the new</span>
 <span class="s0">* format is fundamentally compatible with the old format; in particular, it</span>
 <span class="s0">* must have the same number of arrays with the same stride in each one.  No</span>
 <span class="s0">* checking is performed that the data remains sensible.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void GeomVertexData::unclean_set_format(GeomVertexFormat const *format);</span>

<span class="s0">2063 10 has_column 0 4 3228 26 GeomVertexData::has_column 0 1 462 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has the named column, false otherwise.  This is</span>
 <span class="s0">* really just a shortcut for asking the same thing from the format.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline bool GeomVertexData::has_column(InternalName const *name) const;</span>

<span class="s0">2064 12 get_num_rows 0 4 3228 28 GeomVertexData::get_num_rows 0 1 463 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of rows stored within all the arrays.  All arrays store</span>
 <span class="s0">* data for the same n rows.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int GeomVertexData::get_num_rows(void) const;</span>

<span class="s0">2065 12 set_num_rows 0 4 3228 28 GeomVertexData::set_num_rows 0 1 464 736</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the length of the array to n rows in all of the various arrays</span>
 <span class="s0">* (presumably by adding rows).</span>
 <span class="s0">*</span>
 <span class="s0">* The new vertex data is initialized to 0, except for the &quot;color&quot; column,</span>
 <span class="s0">* which is initialized to (1, 1, 1, 1).</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the number of rows was changed, false if the</span>
 <span class="s0">* object already contained n rows (or if there was some error).</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used when you know exactly how many rows you will be needing.</span>
 <span class="s0">* It is faster than reserve_num_rows().  Also see unclean_set_num_rows() if</span>
 <span class="s0">* you are planning to fill in all the data yourself.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool GeomVertexData::set_num_rows(int n);</span>

<span class="s0">2066 20 unclean_set_num_rows 0 4 3228 36 GeomVertexData::unclean_set_num_rows 0 1 465 518</span>
<span class="s0">/**</span>
 <span class="s0">* This method behaves like set_num_rows(), except the new data is not</span>
 <span class="s0">* initialized.  Furthermore, after this call, *any* of the data in the</span>
 <span class="s0">* GeomVertexData may be uninitialized, including the earlier rows.</span>
 <span class="s0">*</span>
 <span class="s0">* This is intended for applications that are about to completely fill the</span>
 <span class="s0">* GeomVertexData with new data anyway; it provides a tiny performance boost</span>
 <span class="s0">* over set_num_rows().</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used when you know exactly how many rows you will be needing.</span>
 <span class="s0">* It is faster than reserve_num_rows().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool GeomVertexData::unclean_set_num_rows(int n);</span>

<span class="s0">2067 16 reserve_num_rows 0 4 3228 32 GeomVertexData::reserve_num_rows 0 1 466 461</span>
<span class="s0">/**</span>
 <span class="s0">* This ensures that enough memory space for n rows is allocated, so that you</span>
 <span class="s0">* may increase the number of rows to n without causing a new memory</span>
 <span class="s0">* allocation.  This is a performance optimization only; it is especially</span>
 <span class="s0">* useful when you know ahead of time that you will be adding n rows to the</span>
 <span class="s0">* data.</span>
 <span class="s0">*</span>
 <span class="s0">* If you know exactly how many rows you will be needing, it is significantly</span>
 <span class="s0">* faster to use set_num_rows() or unclean_set_num_rows() instead.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool GeomVertexData::reserve_num_rows(int n);</span>

<span class="s0">2068 10 clear_rows 0 4 3228 26 GeomVertexData::clear_rows 0 1 467 263</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the rows from the arrays; functionally equivalent to</span>
 <span class="s0">* set_num_rows(0) (but faster).</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void GeomVertexData::clear_rows(void);</span>

<span class="s0">2069 14 get_num_arrays 0 4 3228 30 GeomVertexData::get_num_arrays 0 1 468 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of individual arrays stored within the data.  This must</span>
 <span class="s0">* match get_format()-&gt;get_num_arrays().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t GeomVertexData::get_num_arrays(void) const;</span>

<span class="s0">2070 9 get_array 0 4 3228 25 GeomVertexData::get_array 0 1 469 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the vertex data for the indicated array, for</span>
 <span class="s0">* application code to directly examine (but not modify) the underlying vertex</span>
 <span class="s0">* data.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline ConstPointerTo&lt; GeomVertexArrayData &gt; GeomVertexData::get_array(std::size_t i) const;</span>

<span class="s0">2071 16 get_array_handle 0 4 3228 32 GeomVertexData::get_array_handle 0 1 470 51</span>
<span class="s0">/**</span>
 <span class="s0">* Equivalent to get_array(i).get_handle().</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">inline ConstPointerTo&lt; GeomVertexArrayDataHandle &gt; GeomVertexData::get_array_handle(std::size_t i) const;</span>

<span class="s0">2072 12 modify_array 0 4 3228 28 GeomVertexData::modify_array 0 1 471 419</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the indicated vertex array, so that</span>
 <span class="s0">* application code may directly manipulate the data.  You should avoid</span>
 <span class="s0">* changing the length of this array, since all of the arrays should be kept</span>
 <span class="s0">* in sync--use set_num_rows() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline PointerTo&lt; GeomVertexArrayData &gt; GeomVertexData::modify_array(std::size_t i);</span>

<span class="s0">2073 19 modify_array_handle 0 4 3228 35 GeomVertexData::modify_array_handle 0 1 472 57</span>
<span class="s0">/**</span>
 <span class="s0">* Equivalent to modify_array(i).modify_handle().</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">inline PointerTo&lt; GeomVertexArrayDataHandle &gt; GeomVertexData::modify_array_handle(std::size_t i);</span>

<span class="s0">2074 9 set_array 0 4 3228 25 GeomVertexData::set_array 0 1 473 363</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the indicated vertex data array with a completely new array.  You</span>
 <span class="s0">* should be careful that the new array has the same length and format as the</span>
 <span class="s0">* old one, unless you know what you are doing.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void GeomVertexData::set_array(std::size_t i, GeomVertexArrayData const *array);</span>

<span class="s0">2075 19 get_transform_table 0 4 3228 35 GeomVertexData::get_transform_table 0 1 474 494</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the TransformTable assigned to this data.</span>
 <span class="s0">* Vertices within the table will index into this table to indicate their</span>
 <span class="s0">* dynamic skinning information; this table is used when the vertex animation</span>
 <span class="s0">* is to be performed by the graphics hardware (but also see</span>
 <span class="s0">* get_transform_blend_table()).</span>
 <span class="s0">*</span>
 <span class="s0">* This will return NULL if the vertex data does not have a TransformTable</span>
 <span class="s0">* assigned (which implies the vertices will not be animated by the graphics</span>
 <span class="s0">* hardware).</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline TransformTable const *GeomVertexData::get_transform_table(void) const;</span>

<span class="s0">2076 19 set_transform_table 0 4 3228 35 GeomVertexData::set_transform_table 0 1 475 376</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the TransformTable on this vertex data with the indicated table.</span>
 <span class="s0">* The length of this table should be consistent with the maximum table index</span>
 <span class="s0">* assigned to the vertices under the &quot;transform_index&quot; name.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void GeomVertexData::set_transform_table(TransformTable const *table);</span>

<span class="s0">2077 21 clear_transform_table 0 4 3228 37 GeomVertexData::clear_transform_table 0 1 476 144</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the TransformTable pointer to NULL, removing the table from the vertex</span>
 <span class="s0">* data.  This disables hardware-driven vertex animation.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void GeomVertexData::clear_transform_table(void);</span>

<span class="s0">2078 25 get_transform_blend_table 0 4 3228 41 GeomVertexData::get_transform_blend_table 0 1 477 467</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the TransformBlendTable assigned to this data.</span>
 <span class="s0">* Vertices within the table will index into this table to indicate their</span>
 <span class="s0">* dynamic skinning information; this table is used when the vertex animation</span>
 <span class="s0">* is to be performed by the CPU (but also see get_transform_table()).</span>
 <span class="s0">*</span>
 <span class="s0">* This will return NULL if the vertex data does not have a</span>
 <span class="s0">* TransformBlendTable assigned (which implies the vertices will not be</span>
 <span class="s0">* animated by the CPU).</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">inline ConstPointerTo&lt; TransformBlendTable &gt; GeomVertexData::get_transform_blend_table(void) const;</span>

<span class="s0">2079 28 modify_transform_blend_table 0 4 3228 44 GeomVertexData::modify_transform_blend_table 0 1 478 342</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the current TransformBlendTable on this</span>
 <span class="s0">* vertex data, if any, or NULL if there is not a TransformBlendTable.  See</span>
 <span class="s0">* get_transform_blend_table().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">PointerTo&lt; TransformBlendTable &gt; GeomVertexData::modify_transform_blend_table(void);</span>

<span class="s0">2080 25 set_transform_blend_table 0 4 3228 41 GeomVertexData::set_transform_blend_table 0 1 479 382</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the TransformBlendTable on this vertex data with the indicated</span>
 <span class="s0">* table.  The length of this table should be consistent with the maximum</span>
 <span class="s0">* table index assigned to the vertices under the &quot;transform_blend&quot; name.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">void GeomVertexData::set_transform_blend_table(TransformBlendTable const *table);</span>

<span class="s0">2081 27 clear_transform_blend_table 0 4 3228 43 GeomVertexData::clear_transform_blend_table 0 1 480 144</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the TransformBlendTable pointer to NULL, removing the table from the</span>
 <span class="s0">* vertex data.  This disables CPU-driven vertex animation.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void GeomVertexData::clear_transform_blend_table(void);</span>

<span class="s0">2082 16 get_slider_table 0 4 3228 32 GeomVertexData::get_slider_table 0 1 481 264</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the SliderTable assigned to this data.  Vertices</span>
 <span class="s0">* within the vertex data will look up their morph offsets, if any, within</span>
 <span class="s0">* this table.</span>
 <span class="s0">*</span>
 <span class="s0">* This will return NULL if the vertex data does not have a SliderTable</span>
 <span class="s0">* assigned.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline SliderTable const *GeomVertexData::get_slider_table(void) const;</span>

<span class="s0">2083 16 set_slider_table 0 4 3228 32 GeomVertexData::set_slider_table 0 1 482 437</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the SliderTable on this vertex data with the indicated table.</span>
 <span class="s0">* There should be an entry in this table for each kind of morph offset</span>
 <span class="s0">* defined in the vertex data.</span>
 <span class="s0">*</span>
 <span class="s0">* The SliderTable object must have been registered prior to setting it on the</span>
 <span class="s0">* GeomVertexData.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void GeomVertexData::set_slider_table(SliderTable const *table);</span>

<span class="s0">2084 18 clear_slider_table 0 4 3228 34 GeomVertexData::clear_slider_table 0 1 483 138</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the SliderTable pointer to NULL, removing the table from the vertex</span>
 <span class="s0">* data.  This disables morph (blend shape) animation.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void GeomVertexData::clear_slider_table(void);</span>

<span class="s0">2085 13 get_num_bytes 0 4 3228 29 GeomVertexData::get_num_bytes 0 1 484 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes consumed by the different arrays of the</span>
 <span class="s0">* vertex data.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int GeomVertexData::get_num_bytes(void) const;</span>

<span class="s0">2086 12 get_modified 0 4 3228 28 GeomVertexData::get_modified 0 1 485 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the vertex data is modified.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline UpdateSeq GeomVertexData::get_modified(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2087 16 request_resident 0 4 3228 32 GeomVertexData::request_resident 0 1 486 180</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the vertex data is currently resident in memory.  If this</span>
 <span class="s0">* returns false, the vertex data will be brought back into memory shortly;</span>
 <span class="s0">* try again later.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">bool GeomVertexData::request_resident(void) const;</span>

<span class="s0">2088 9 copy_from 0 4 3228 25 GeomVertexData::copy_from 0 1 487 691</span>
<span class="s0">/**</span>
 <span class="s0">* Copies all the data from the other array into the corresponding data types</span>
 <span class="s0">* in this array, by matching data types name-by-name.</span>
 <span class="s0">*</span>
 <span class="s0">* keep_data_objects specifies what to do when one or more of the arrays can</span>
 <span class="s0">* be copied without the need to apply any conversion operation.  If it is</span>
 <span class="s0">* true, the original GeomVertexArrayData objects in this object are retained,</span>
 <span class="s0">* and their data arrays are copied byte-by-byte from the source; if it is</span>
 <span class="s0">* false, then the GeomVertexArrayData objects are copied pointerwise from the</span>
 <span class="s0">* source.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">void GeomVertexData::copy_from(GeomVertexData const *source, bool keep_data_objects, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2089 13 copy_row_from 0 4 3228 29 GeomVertexData::copy_row_from 0 1 488 335</span>
<span class="s0">/**</span>
 <span class="s0">* Copies a single row of the data from the other array into the indicated row</span>
 <span class="s0">* of this array.  In this case, the source format must exactly match the</span>
 <span class="s0">* destination format.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">void GeomVertexData::copy_row_from(int dest_row, GeomVertexData const *source, int source_row, Thread *current_thread);</span>

<span class="s0">2090 10 convert_to 0 4 3228 26 GeomVertexData::convert_to 0 1 489 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomVertexData that represents the same contents as this one,</span>
 <span class="s0">* with all data types matched up name-by-name to the indicated new format.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">ConstPointerTo&lt; GeomVertexData &gt; GeomVertexData::convert_to(GeomVertexFormat const *new_format) const;</span>

<span class="s0">2091 11 scale_color 0 4 3228 27 GeomVertexData::scale_color 0 2 490 491 517</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomVertexData object with the color table modified in-place</span>
 <span class="s0">* to apply the indicated scale.</span>
 <span class="s0">*</span>
 <span class="s0">* If the vertex data does not include a color column, a new one will not be</span>
 <span class="s0">* added.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomVertexData object with the color table replaced with a</span>
 <span class="s0">* new color table that has been scaled by the indicated value.  The new color</span>
 <span class="s0">* table will be added as a new array; if the old color table was interleaved</span>
 <span class="s0">* with a previous array, the previous array will not be repacked.</span>
 <span class="s0">*/</span>
<span class="s0">282</span>
<span class="s0">ConstPointerTo&lt; GeomVertexData &gt; GeomVertexData::scale_color(LVecBase4 const &amp;color_scale) const;</span>
<span class="s0">ConstPointerTo&lt; GeomVertexData &gt; GeomVertexData::scale_color(LVecBase4 const &amp;color_scale, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const;</span>

<span class="s0">2092 9 set_color 0 4 3228 25 GeomVertexData::set_color 0 2 492 493 508</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomVertexData object with the color data modified in-place</span>
 <span class="s0">* with the new value.</span>
 <span class="s0">*</span>
 <span class="s0">* If the vertex data does not include a color column, a new one will not be</span>
 <span class="s0">* added.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomVertexData object with the color table replaced with a</span>
 <span class="s0">* new color table for which each vertex has the indicated value.  The new</span>
 <span class="s0">* color table will be added as a new array; if the old color table was</span>
 <span class="s0">* interleaved with a previous array, the previous array will not be repacked.</span>
 <span class="s0">*/</span>
<span class="s0">260</span>
<span class="s0">ConstPointerTo&lt; GeomVertexData &gt; GeomVertexData::set_color(LColor const &amp;color) const;</span>
<span class="s0">ConstPointerTo&lt; GeomVertexData &gt; GeomVertexData::set_color(LColor const &amp;color, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const;</span>

<span class="s0">2093 15 reverse_normals 0 4 3228 31 GeomVertexData::reverse_normals 0 1 494 281</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomVertexData object with the normal data modified in-place,</span>
 <span class="s0">* so that each lighting normal is now facing in the opposite direction.</span>
 <span class="s0">*</span>
 <span class="s0">* If the vertex data does not include a normal column, this returns the</span>
 <span class="s0">* original GeomVertexData object, unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">ConstPointerTo&lt; GeomVertexData &gt; GeomVertexData::reverse_normals(void) const;</span>

<span class="s0">2094 16 animate_vertices 0 4 3228 32 GeomVertexData::animate_vertices 0 1 495 861</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a GeomVertexData that represents the results of computing the</span>
 <span class="s0">* vertex animation on the CPU for this GeomVertexData.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is no CPU-defined vertex animation on this object, this just</span>
 <span class="s0">* returns the original object.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is vertex animation, but the VertexTransform values have not</span>
 <span class="s0">* changed since last time, this may return the same pointer it returned</span>
 <span class="s0">* previously.  Even if the VertexTransform values have changed, it may still</span>
 <span class="s0">* return the same pointer, but with its contents modified (this is preferred,</span>
 <span class="s0">* since it allows the graphics backend to update vertex buffers optimally).</span>
 <span class="s0">*</span>
 <span class="s0">* If force is false, this method may return immediately with stale data, if</span>
 <span class="s0">* the vertex data is not completely resident.  If force is true, this method</span>
 <span class="s0">* will never return stale data, but may block until the data is available.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">ConstPointerTo&lt; GeomVertexData &gt; GeomVertexData::animate_vertices(bool force, Thread *current_thread) const;</span>

<span class="s0">2095 23 clear_animated_vertices 0 4 3228 39 GeomVertexData::clear_animated_vertices 0 1 496 268</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the cache of animated vertices computed by a previous call to</span>
 <span class="s0">* animate_vertices() within the same frame.  This will force the next call to</span>
 <span class="s0">* animate_vertices() to recompute these values from scratch.  Normally it is</span>
 <span class="s0">* not necessary to call this.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void GeomVertexData::clear_animated_vertices(void);</span>

<span class="s0">2096 18 transform_vertices 0 4 3228 34 GeomVertexData::transform_vertices 0 3 497 498 499 616</span>
<span class="s0">/**</span>
 <span class="s0">* Applies the indicated transform matrix to all of the vertices in the</span>
 <span class="s0">* GeomVertexData.  The transform is applied to all &quot;point&quot; and &quot;vector&quot; type</span>
 <span class="s0">* columns described in the format.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Applies the indicated transform matrix to all of the vertices from</span>
 <span class="s0">* begin_row up to but not including end_row.  The transform is applied to all</span>
 <span class="s0">* &quot;point&quot; and &quot;vector&quot; type columns described in the format.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Applies the indicated transform matrix to all of the vertices mentioned in</span>
 <span class="s0">* the sparse array.  The transform is applied to all &quot;point&quot; and &quot;vector&quot;</span>
 <span class="s0">* type columns described in the format.</span>
 <span class="s0">*/</span>
<span class="s0">238</span>
<span class="s0">void GeomVertexData::transform_vertices(LMatrix4 const &amp;mat);</span>
<span class="s0">void GeomVertexData::transform_vertices(LMatrix4 const &amp;mat, int begin_row, int end_row);</span>
<span class="s0">void GeomVertexData::transform_vertices(LMatrix4 const &amp;mat, SparseArray const &amp;rows);</span>

<span class="s0">2097 14 replace_column 0 4 3228 30 GeomVertexData::replace_column 0 1 500 435</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomVertexData object, suitable for modification, with the</span>
 <span class="s0">* indicated data type replaced with a new table filled with undefined values.</span>
 <span class="s0">* The new table will be added as a new array; if the old table was</span>
 <span class="s0">* interleaved with a previous array, the previous array will not be repacked.</span>
 <span class="s0">*</span>
 <span class="s0">* If num_components is 0, the indicated name is simply removed from the type,</span>
 <span class="s0">* without replacing it with anything else.</span>
 <span class="s0">*/</span>
<span class="s0">172</span>
<span class="s0">PointerTo&lt; GeomVertexData &gt; GeomVertexData::replace_column(InternalName *name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const;</span>

<span class="s0">2098 6 output 0 4 3228 22 GeomVertexData::output 0 1 501 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void GeomVertexData::output(std::ostream &amp;out) const;</span>

<span class="s0">2099 5 write 0 4 3228 21 GeomVertexData::write 0 1 502 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void GeomVertexData::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2100 15 describe_vertex 0 4 3228 31 GeomVertexData::describe_vertex 0 1 503 90</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a verbose, human-friendly description of the indicated vertex</span>
 <span class="s0">* number.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">void GeomVertexData::describe_vertex(std::ostream &amp;out, int row) const;</span>

<span class="s0">2101 11 clear_cache 0 4 3228 27 GeomVertexData::clear_cache 0 1 504 263</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the previously-cached results of convert_to().</span>
 <span class="s0">*</span>
 <span class="s0">* This blows away the entire cache, upstream and downstream the pipeline.</span>
 <span class="s0">* Use clear_cache_stage() instead if you only want to blow away the cache at</span>
 <span class="s0">* the current stage and upstream.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void GeomVertexData::clear_cache(void);</span>

<span class="s0">2102 17 clear_cache_stage 0 4 3228 33 GeomVertexData::clear_cache_stage 0 1 505 310</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the previously-cached results of convert_to(), at the</span>
 <span class="s0">* current pipeline stage and upstream.  Does not affect the downstream cache.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void GeomVertexData::clear_cache_stage(void);</span>

<span class="s0">2103 14 get_class_type 0 4 3228 30 GeomVertexData::get_class_type 0 1 506 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle GeomVertexData::get_class_type(void);</span>

<span class="s0">2104 22 AnimateVerticesRequest 0 260 3236 46 AnimateVerticesRequest::AnimateVerticesRequest 0 2 509 510 47</span>
<span class="s0">/**</span>
 <span class="s0">* Create a new AnimateVerticesRequest.</span>
 <span class="s0">*/</span>
<span class="s0">194</span>
<span class="s0">inline explicit AnimateVerticesRequest::AnimateVerticesRequest(GeomVertexData *geom_vertex_data);</span>
<span class="s0">inline AnimateVerticesRequest::AnimateVerticesRequest(AnimateVerticesRequest const &amp;) = default;</span>

<span class="s0">2105 8 is_ready 0 4 3236 32 AnimateVerticesRequest::is_ready 0 1 511 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending.</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool AnimateVerticesRequest::is_ready(void) const;</span>

<span class="s0">2106 14 get_class_type 0 4 3236 38 AnimateVerticesRequest::get_class_type 0 1 512 0</span>
<span class="s0">63</span>
<span class="s0">static TypeHandle AnimateVerticesRequest::get_class_type(void);</span>

<span class="s0">2107 23 ~AnimateVerticesRequest 0 516 3236 47 AnimateVerticesRequest::~AnimateVerticesRequest 0 0 0</span>
<span class="s0">54</span>
<span class="s0">AnimateVerticesRequest::~AnimateVerticesRequest(void);</span>

<span class="s0">2108 14 get_class_type 0 4 3238 28 SavedContext::get_class_type 0 1 513 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle SavedContext::get_class_type(void);</span>

<span class="s0">2109 13 ~SavedContext 0 516 3238 27 SavedContext::~SavedContext 0 0 0</span>
<span class="s0">34</span>
<span class="s0">SavedContext::~SavedContext(void);</span>

<span class="s0">2110 22 upcast_to_SavedContext 0 12 3240 37 BufferContext::upcast_to_SavedContext 0 1 519 41</span>
<span class="s0">upcast from BufferContext to SavedContext</span>
<span class="s0">58</span>
<span class="s0">SavedContext *BufferContext::upcast_to_SavedContext(void);</span>

<span class="s0">2111 25 downcast_to_BufferContext 0 12 3238 39 SavedContext::downcast_to_BufferContext 0 0 43</span>
<span class="s0">downcast from SavedContext to BufferContext</span>
<span class="s0">61</span>
<span class="s0">BufferContext *SavedContext::downcast_to_BufferContext(void);</span>

<span class="s0">2112 14 ~BufferContext 0 518 3240 29 BufferContext::~BufferContext 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual BufferContext::~BufferContext(void);</span>

<span class="s0">2113 19 get_data_size_bytes 0 4 3240 34 BufferContext::get_data_size_bytes 0 1 514 271</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes previously reported for the data object.  This</span>
 <span class="s0">* is used to track changes in the data object's allocated size; if it changes</span>
 <span class="s0">* from this, we need to create a new buffer.  This is also used to track</span>
 <span class="s0">* memory utilization in PStats.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::size_t BufferContext::get_data_size_bytes(void) const;</span>

<span class="s0">2114 12 get_modified 0 4 3240 27 BufferContext::get_modified 0 1 515 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the UpdateSeq that was recorded the last time mark_loaded() was</span>
 <span class="s0">* called.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline UpdateSeq BufferContext::get_modified(void) const;</span>

<span class="s0">2115 10 get_active 0 4 3240 25 BufferContext::get_active 0 1 516 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the active flag associated with this object.  An object is</span>
 <span class="s0">* considered &quot;active&quot; if it was rendered in the current frame.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool BufferContext::get_active(void) const;</span>

<span class="s0">2116 12 get_resident 0 4 3240 27 BufferContext::get_resident 0 1 517 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the resident flag associated with this object.  An object is</span>
 <span class="s0">* considered &quot;resident&quot; if it appears to be resident in texture memory.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool BufferContext::get_resident(void) const;</span>

<span class="s0">2117 10 get_object 0 4 3240 25 BufferContext::get_object 0 0 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the associated object.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline TypedWritableReferenceCount *BufferContext::get_object(void) const;</span>

<span class="s0">2118 14 get_class_type 0 4 3240 29 BufferContext::get_class_type 0 1 518 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle BufferContext::get_class_type(void);</span>

<span class="s0">2119 27 upcast_to_CopyOnWriteObject 0 12 3242 42 GeomPrimitive::upcast_to_CopyOnWriteObject 0 1 597 46</span>
<span class="s0">upcast from GeomPrimitive to CopyOnWriteObject</span>
<span class="s0">68</span>
<span class="s0">CopyOnWriteObject *GeomPrimitive::upcast_to_CopyOnWriteObject(void);</span>

<span class="s0">2120 25 downcast_to_GeomPrimitive 0 12 3208 44 CopyOnWriteObject::downcast_to_GeomPrimitive 0 0 48</span>
<span class="s0">downcast from CopyOnWriteObject to GeomPrimitive</span>
<span class="s0">66</span>
<span class="s0">GeomPrimitive *CopyOnWriteObject::downcast_to_GeomPrimitive(void);</span>

<span class="s0">2121 19 upcast_to_GeomEnums 0 12 3242 34 GeomPrimitive::upcast_to_GeomEnums 0 1 598 38</span>
<span class="s0">upcast from GeomPrimitive to GeomEnums</span>
<span class="s0">52</span>
<span class="s0">GeomEnums *GeomPrimitive::upcast_to_GeomEnums(void);</span>

<span class="s0">2122 25 downcast_to_GeomPrimitive 0 12 3168 36 GeomEnums::downcast_to_GeomPrimitive 0 0 40</span>
<span class="s0">downcast from GeomEnums to GeomPrimitive</span>
<span class="s0">58</span>
<span class="s0">GeomPrimitive *GeomEnums::downcast_to_GeomPrimitive(void);</span>

<span class="s0">2123 10 operator = 0 4 3242 25 GeomPrimitive::operator = 0 1 520 0</span>
<span class="s0">58</span>
<span class="s0">void GeomPrimitive::operator =(GeomPrimitive const &amp;copy);</span>

<span class="s0">2124 14 ~GeomPrimitive 0 518 3242 29 GeomPrimitive::~GeomPrimitive 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual GeomPrimitive::~GeomPrimitive(void);</span>

<span class="s0">2125 12 operator new 0 4 3242 27 GeomPrimitive::operator new 0 1 521 0</span>
<span class="s0">130</span>
<span class="s0">inline void *GeomPrimitive::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomPrimitive::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2126 15 operator delete 0 4 3242 30 GeomPrimitive::operator delete 0 0 0</span>
<span class="s0">114</span>
<span class="s0">inline void GeomPrimitive::operator delete(void *ptr);</span>
<span class="s0">inline void GeomPrimitive::operator delete(void *, void *);</span>

<span class="s0">2127 12 validate_ptr 0 4 3242 27 GeomPrimitive::validate_ptr 0 0 0</span>
<span class="s0">64</span>
<span class="s0">static inline bool GeomPrimitive::validate_ptr(void const *ptr);</span>

<span class="s0">2128 9 make_copy 0 6 3242 24 GeomPrimitive::make_copy 0 1 522 0</span>
<span class="s0">76</span>
<span class="s0">virtual PointerTo&lt; GeomPrimitive &gt; GeomPrimitive::make_copy(void) const = 0;</span>

<span class="s0">2129 18 get_primitive_type 0 6 3242 33 GeomPrimitive::get_primitive_type 0 1 523 0</span>
<span class="s0">83</span>
<span class="s0">virtual GeomEnums::PrimitiveType GeomPrimitive::get_primitive_type(void) const = 0;</span>

<span class="s0">2130 18 get_geom_rendering 0 6 3242 33 GeomPrimitive::get_geom_rendering 0 1 524 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of GeomRendering bits that represent the rendering</span>
 <span class="s0">* properties required to properly render this primitive.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual int GeomPrimitive::get_geom_rendering(void) const;</span>

<span class="s0">2131 15 get_shade_model 0 4 3242 30 GeomPrimitive::get_shade_model 0 1 525 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ShadeModel hint for this primitive.  This is intended as a hint</span>
 <span class="s0">* to the renderer to tell it how the per-vertex colors and normals are</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline GeomEnums::ShadeModel GeomPrimitive::get_shade_model(void) const;</span>

<span class="s0">2132 15 set_shade_model 0 4 3242 30 GeomPrimitive::set_shade_model 0 1 526 512</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the ShadeModel hint for this primitive.  This is different from the</span>
 <span class="s0">* ShadeModelAttrib that might also be applied from the scene graph.  This</span>
 <span class="s0">* does not affect the shade model that is in effect when rendering, but</span>
 <span class="s0">* rather serves as a hint to the renderer to tell it how the per-vertex</span>
 <span class="s0">* colors and normals on this primitive are applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline void GeomPrimitive::set_shade_model(GeomEnums::ShadeModel shade_model);</span>

<span class="s0">2133 14 get_usage_hint 0 4 3242 29 GeomPrimitive::get_usage_hint 0 1 527 554</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the usage hint for this primitive.  See geomEnums.h.  This has</span>
 <span class="s0">* nothing to do with the usage hint associated with the primitive's vertices;</span>
 <span class="s0">* this only specifies how often the vertex indices that define the primitive</span>
 <span class="s0">* will be modified.</span>
 <span class="s0">*</span>
 <span class="s0">* It is perfectly legal (and, in fact, common) for a GeomPrimitive to have</span>
 <span class="s0">* UH_static on itself, while referencing vertex data with UH_dynamic.  This</span>
 <span class="s0">* means that the vertices themselves will be animated, but the primitive will</span>
 <span class="s0">* always reference the same set of vertices from the pool.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline GeomEnums::UsageHint GeomPrimitive::get_usage_hint(void) const;</span>

<span class="s0">2134 14 set_usage_hint 0 4 3242 29 GeomPrimitive::set_usage_hint 0 1 528 232</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the UsageHint hint for this primitive.  See get_usage_hint().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void GeomPrimitive::set_usage_hint(GeomEnums::UsageHint usage_hint);</span>

<span class="s0">2135 14 get_index_type 0 4 3242 29 GeomPrimitive::get_index_type 0 1 529 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the numeric type of the index column.  Normally, this will be</span>
 <span class="s0">* either NT_uint16 or NT_uint32.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline GeomEnums::NumericType GeomPrimitive::get_index_type(void) const;</span>

<span class="s0">2136 14 set_index_type 0 4 3242 29 GeomPrimitive::set_index_type 0 1 530 556</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the numeric type of the index column.  Normally, this should be</span>
 <span class="s0">* either NT_uint16 or NT_uint32.</span>
 <span class="s0">*</span>
 <span class="s0">* The index type must be large enough to include all of the index values in</span>
 <span class="s0">* the primitive.  It may be automatically elevated, if necessary, to a larger</span>
 <span class="s0">* index type, by a subsequent call to add_index() that names an index value</span>
 <span class="s0">* that does not fit in the index type you specify.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void GeomPrimitive::set_index_type(GeomEnums::NumericType index_type);</span>

<span class="s0">2137 12 is_composite 0 4 3242 27 GeomPrimitive::is_composite 0 1 531 178</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the primitive is a composite primitive such as a tristrip</span>
 <span class="s0">* or trifan, or false if it is a fundamental primitive such as a collection</span>
 <span class="s0">* of triangles.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool GeomPrimitive::is_composite(void) const;</span>

<span class="s0">2138 10 is_indexed 0 4 3242 25 GeomPrimitive::is_indexed 0 1 532 379</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the primitive is indexed, false otherwise.  An indexed</span>
 <span class="s0">* primitive stores a table of index numbers into its GeomVertexData, so that</span>
 <span class="s0">* it can reference the vertices in any order.  A nonindexed primitive, on the</span>
 <span class="s0">* other hand, stores only the first vertex number and number of vertices</span>
 <span class="s0">* used, so that it can only reference the vertices consecutively.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool GeomPrimitive::is_indexed(void) const;</span>

<span class="s0">2139 16 get_first_vertex 0 4 3242 31 GeomPrimitive::get_first_vertex 0 1 533 257</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first vertex number referenced by the primitive.  This is</span>
 <span class="s0">* particularly important in the case of a nonindexed primitive, in which case</span>
 <span class="s0">* get_first_vertex() and get_num_vertices() completely define the extent of</span>
 <span class="s0">* the vertex range.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int GeomPrimitive::get_first_vertex(void) const;</span>

<span class="s0">2140 16 get_num_vertices 0 4 3242 31 GeomPrimitive::get_num_vertices 0 1 534 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of indices used by all the primitives in this object.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int GeomPrimitive::get_num_vertices(void) const;</span>

<span class="s0">2141 10 get_vertex 0 4 3242 25 GeomPrimitive::get_vertex 0 1 535 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ith vertex index in the table.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int GeomPrimitive::get_vertex(int i) const;</span>

<span class="s0">2142 10 add_vertex 0 4 3242 25 GeomPrimitive::add_vertex 0 1 536 445</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated vertex to the list of vertex indices used by the</span>
 <span class="s0">* graphics primitive type.  To define a primitive, you must call add_vertex()</span>
 <span class="s0">* for each vertex of the new primitive, and then call close_primitive() after</span>
 <span class="s0">* you have specified the last vertex of each primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void GeomPrimitive::add_vertex(int vertex);</span>

<span class="s0">2143 12 add_vertices 0 4 3242 27 GeomPrimitive::add_vertices 0 3 537 538 539 130</span>
<span class="s0">/**</span>
 <span class="s0">* Adds several vertices in a row.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds several vertices in a row.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds several vertices in a row.</span>
 <span class="s0">*/</span>
<span class="s0">194</span>
<span class="s0">inline void GeomPrimitive::add_vertices(int v1, int v2);</span>
<span class="s0">inline void GeomPrimitive::add_vertices(int v1, int v2, int v3);</span>
<span class="s0">inline void GeomPrimitive::add_vertices(int v1, int v2, int v3, int v4);</span>

<span class="s0">2144 24 add_consecutive_vertices 0 4 3242 39 GeomPrimitive::add_consecutive_vertices 0 1 540 244</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a consecutive sequence of vertices, beginning at start, to the</span>
 <span class="s0">* primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void GeomPrimitive::add_consecutive_vertices(int start, int num_vertices);</span>

<span class="s0">2145 17 add_next_vertices 0 4 3242 32 GeomPrimitive::add_next_vertices 0 1 541 327</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the next n vertices in sequence, beginning from the last vertex added</span>
 <span class="s0">* to the primitive + 1.</span>
 <span class="s0">*</span>
 <span class="s0">* This is most useful when you are building up a primitive and a</span>
 <span class="s0">* GeomVertexData at the same time, and you just want the primitive to</span>
 <span class="s0">* reference the first n vertices from the data, then the next n, and so on.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void GeomPrimitive::add_next_vertices(int num_vertices);</span>

<span class="s0">2146 20 reserve_num_vertices 0 4 3242 35 GeomPrimitive::reserve_num_vertices 0 1 542 813</span>
<span class="s0">/**</span>
 <span class="s0">* This ensures that enough memory space for n vertices is allocated, so that</span>
 <span class="s0">* you may increase the number of vertices to n without causing a new memory</span>
 <span class="s0">* allocation.  This is a performance optimization only; it is especially</span>
 <span class="s0">* useful when you know ahead of time that you will be adding n vertices to</span>
 <span class="s0">* the primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the total you specify here should also include implicit vertices</span>
 <span class="s0">* which may be added at each close_primitive() call, according to</span>
 <span class="s0">* get_num_unused_vertices_per_primitive().</span>
 <span class="s0">*</span>
 <span class="s0">* Note also that making this call will implicitly make the primitive indexed</span>
 <span class="s0">* if it is not already, which could result in a performance *penalty*.  If</span>
 <span class="s0">* you would prefer not to lose the nonindexed nature of your existing</span>
 <span class="s0">* GeomPrimitives, check is_indexed() before making this call.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void GeomPrimitive::reserve_num_vertices(int num_vertices);</span>

<span class="s0">2147 15 close_primitive 0 4 3242 30 GeomPrimitive::close_primitive 0 1 543 345</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the previous n calls to add_vertex(), since the last call to</span>
 <span class="s0">* close_primitive(), have fully defined a new primitive.  Returns true if</span>
 <span class="s0">* successful, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">bool GeomPrimitive::close_primitive(void);</span>

<span class="s0">2148 14 clear_vertices 0 4 3242 29 GeomPrimitive::clear_vertices 0 1 544 250</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the vertices and primitives from the object, so they can be</span>
 <span class="s0">* re-added.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void GeomPrimitive::clear_vertices(void);</span>

<span class="s0">2149 15 offset_vertices 0 4 3242 30 GeomPrimitive::offset_vertices 0 2 545 546 737</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated offset to all vertices used by the primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the indicated offset to the indicated segment of vertices used by the</span>
 <span class="s0">* primitive.  Unlike the other version of offset_vertices, this makes the</span>
 <span class="s0">* geometry indexed if it isn't already.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that end_row indicates one past the last row that should be offset.</span>
 <span class="s0">* In other words, the number of vertices touched is (end_row - begin_row).</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">void GeomPrimitive::offset_vertices(int offset);</span>
<span class="s0">void GeomPrimitive::offset_vertices(int offset, int begin_row, int end_row);</span>

<span class="s0">2150 15 make_nonindexed 0 4 3242 30 GeomPrimitive::make_nonindexed 0 1 547 202</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the primitive from indexed to nonindexed by duplicating vertices</span>
 <span class="s0">* as necessary into the indicated dest GeomVertexData.  Note: does not</span>
 <span class="s0">* support primitives with strip cut indices.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">void GeomPrimitive::make_nonindexed(GeomVertexData *dest, GeomVertexData const *source);</span>

<span class="s0">2151 13 pack_vertices 0 4 3242 28 GeomPrimitive::pack_vertices 0 1 548 135</span>
<span class="s0">/**</span>
 <span class="s0">* Packs the vertices used by the primitive from the indicated source array</span>
 <span class="s0">* onto the end of the indicated destination array.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">void GeomPrimitive::pack_vertices(GeomVertexData *dest, GeomVertexData const *source);</span>

<span class="s0">2152 12 make_indexed 0 4 3242 27 GeomPrimitive::make_indexed 0 1 549 466</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the primitive from nonindexed form to indexed form.  This will</span>
 <span class="s0">* simply create an index table that is numbered consecutively from</span>
 <span class="s0">* get_first_vertex(); it does not automatically collapse together identical</span>
 <span class="s0">* vertices that may have been split apart by a previous call to</span>
 <span class="s0">* make_nonindexed().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void GeomPrimitive::make_indexed(void);</span>

<span class="s0">2153 18 get_num_primitives 0 4 3242 33 GeomPrimitive::get_num_primitives 0 1 550 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of individual primitives stored within this object.  All</span>
 <span class="s0">* primitives are the same type.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int GeomPrimitive::get_num_primitives(void) const;</span>

<span class="s0">2154 19 get_primitive_start 0 4 3242 34 GeomPrimitive::get_primitive_start 0 1 551 457</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the element within the _vertices list at which the nth primitive</span>
 <span class="s0">* starts.</span>
 <span class="s0">*</span>
 <span class="s0">* If i is one more than the highest valid primitive vertex, the return value</span>
 <span class="s0">* will be one more than the last valid vertex.  Thus, it is generally true</span>
 <span class="s0">* that the vertices used by a particular primitive i are the set</span>
 <span class="s0">* get_primitive_start(n) &lt;= vi &lt; get_primitive_start(n + 1) (although this</span>
 <span class="s0">* range also includes the unused vertices between primitives).</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">int GeomPrimitive::get_primitive_start(int n) const;</span>

<span class="s0">2155 17 get_primitive_end 0 4 3242 32 GeomPrimitive::get_primitive_end 0 1 552 156</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the element within the _vertices list at which the nth primitive</span>
 <span class="s0">* ends.  This is one past the last valid element for the nth primitive.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int GeomPrimitive::get_primitive_end(int n) const;</span>

<span class="s0">2156 26 get_primitive_num_vertices 0 4 3242 41 GeomPrimitive::get_primitive_num_vertices 0 1 553 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertices used by the nth primitive.  This is the same</span>
 <span class="s0">* thing as get_primitive_end(n) - get_primitive_start(n).</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">int GeomPrimitive::get_primitive_num_vertices(int n) const;</span>

<span class="s0">2157 21 get_num_used_vertices 0 4 3242 36 GeomPrimitive::get_num_used_vertices 0 1 554 278</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertices used by all of the primitives.  This is the</span>
 <span class="s0">* same as summing get_primitive_num_vertices(n) for n in</span>
 <span class="s0">* get_num_primitives().  It is like get_num_vertices except that it excludes</span>
 <span class="s0">* all of the degenerate vertices and strip-cut indices.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">int GeomPrimitive::get_num_used_vertices(void) const;</span>

<span class="s0">2158 13 get_num_faces 0 4 3242 28 GeomPrimitive::get_num_faces 0 1 555 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of triangles or other fundamental type (such as line</span>
 <span class="s0">* segments) represented by all the primitives in this object.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int GeomPrimitive::get_num_faces(void) const;</span>

<span class="s0">2159 23 get_primitive_num_faces 0 4 3242 38 GeomPrimitive::get_primitive_num_faces 0 1 556 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of triangles or other fundamental type (such as line</span>
 <span class="s0">* segments) represented by the nth primitive in this object.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int GeomPrimitive::get_primitive_num_faces(int n) const;</span>

<span class="s0">2160 14 get_min_vertex 0 4 3242 29 GeomPrimitive::get_min_vertex 0 1 557 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minimum vertex index number used by all the primitives in this</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int GeomPrimitive::get_min_vertex(void) const;</span>

<span class="s0">2161 24 get_primitive_min_vertex 0 4 3242 39 GeomPrimitive::get_primitive_min_vertex 0 1 558 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minimum vertex index number used by the nth primitive in this</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">int GeomPrimitive::get_primitive_min_vertex(int n) const;</span>

<span class="s0">2162 14 get_max_vertex 0 4 3242 29 GeomPrimitive::get_max_vertex 0 1 559 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum vertex index number used by all the primitives in this</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int GeomPrimitive::get_max_vertex(void) const;</span>

<span class="s0">2163 24 get_primitive_max_vertex 0 4 3242 39 GeomPrimitive::get_primitive_max_vertex 0 1 560 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum vertex index number used by the nth primitive in this</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">int GeomPrimitive::get_primitive_max_vertex(int n) const;</span>

<span class="s0">2164 9 decompose 0 4 3242 24 GeomPrimitive::decompose 0 1 561 464</span>
<span class="s0">/**</span>
 <span class="s0">* Decomposes a complex primitive type into a simpler primitive type, for</span>
 <span class="s0">* instance triangle strips to triangles, and returns a pointer to the new</span>
 <span class="s0">* primitive definition.  If the decomposition cannot be performed, this might</span>
 <span class="s0">* return the original object.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is useful for application code that wants to iterate through</span>
 <span class="s0">* the set of triangles on the primitive without having to write handlers for</span>
 <span class="s0">* each possible kind of primitive type.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::decompose(void) const;</span>

<span class="s0">2165 6 rotate 0 4 3242 21 GeomPrimitive::rotate 0 1 562 408</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new primitive with the shade_model reversed (if it is flat</span>
 <span class="s0">* shaded), if possible.  If the primitive type cannot be rotated, returns the</span>
 <span class="s0">* original primitive, unrotated.</span>
 <span class="s0">*</span>
 <span class="s0">* If the current shade_model indicates flat_vertex_last, this should bring</span>
 <span class="s0">* the last vertex to the first position; if it indicates flat_vertex_first,</span>
 <span class="s0">* this should bring the first vertex to the last position.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::rotate(void) const;</span>

<span class="s0">2166 10 doubleside 0 4 3242 25 GeomPrimitive::doubleside 0 1 563 493</span>
<span class="s0">/**</span>
 <span class="s0">* Duplicates triangles in the primitive so that each triangle is back-to-back</span>
 <span class="s0">* with another triangle facing in the opposite direction.  Note that this</span>
 <span class="s0">* doesn't affect vertex normals, so this operation alone won't work in the</span>
 <span class="s0">* presence of lighting (but see SceneGraphReducer::doubleside()).</span>
 <span class="s0">*</span>
 <span class="s0">* Also see CullFaceAttrib, which can enable rendering of both sides of a</span>
 <span class="s0">* triangle without having to duplicate it (but which doesn't necessarily work</span>
 <span class="s0">* in the presence of lighting).</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::doubleside(void) const;</span>

<span class="s0">2167 7 reverse 0 4 3242 22 GeomPrimitive::reverse 0 1 564 477</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses the winding order in the primitive so that each triangle is facing</span>
 <span class="s0">* in the opposite direction it was originally.  Note that this doesn't affect</span>
 <span class="s0">* vertex normals, so this operation alone won't work in the presence of</span>
 <span class="s0">* lighting (but see SceneGraphReducer::reverse()).</span>
 <span class="s0">*</span>
 <span class="s0">* Also see CullFaceAttrib, which can change the visible direction of a</span>
 <span class="s0">* triangle without having to duplicate it (but which doesn't necessarily work</span>
 <span class="s0">* in the presence of lighting).</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::reverse(void) const;</span>

<span class="s0">2168 17 match_shade_model 0 4 3242 32 GeomPrimitive::match_shade_model 0 1 565 346</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new primitive that is compatible with the indicated shade model,</span>
 <span class="s0">* if possible, or NULL if this is not possible.</span>
 <span class="s0">*</span>
 <span class="s0">* In most cases, this will return either NULL or the original primitive.  In</span>
 <span class="s0">* the case of a SM_flat_first_vertex vs.  a SM_flat_last_vertex (or vice-</span>
 <span class="s0">* versa), however, it will return a rotated primitive.</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::match_shade_model(GeomEnums::ShadeModel shade_model) const;</span>

<span class="s0">2169 11 make_points 0 4 3242 26 GeomPrimitive::make_points 0 1 566 245</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomPoints primitive that represents each of the vertices in</span>
 <span class="s0">* the original primitive, rendered exactly once.  If the original primitive</span>
 <span class="s0">* is already a GeomPoints primitive, returns the original primitive</span>
 <span class="s0">* unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::make_points(void) const;</span>

<span class="s0">2170 10 make_lines 0 4 3242 25 GeomPrimitive::make_lines 0 1 567 233</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new GeomLines primitive that represents each of the edges in the</span>
 <span class="s0">* original primitive rendered as a line.  If the original primitive is</span>
 <span class="s0">* already a GeomLines primitive, returns the original primitive unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::make_lines(void) const;</span>

<span class="s0">2171 12 make_patches 0 4 3242 27 GeomPrimitive::make_patches 0 1 568 418</span>
<span class="s0">/**</span>
 <span class="s0">* Decomposes a complex primitive type into a simpler primitive type, for</span>
 <span class="s0">* instance triangle strips to triangles, puts these in a new GeomPatches</span>
 <span class="s0">* object and returns a pointer to the new primitive definition.  If the</span>
 <span class="s0">* decomposition cannot be performed, this might return the original object.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is useful for application code that wants to use tesselation</span>
 <span class="s0">* shaders on arbitrary geometry.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::make_patches(void) const;</span>

<span class="s0">2172 14 make_adjacency 0 6 3242 29 GeomPrimitive::make_adjacency 0 1 569 161</span>
<span class="s0">/**</span>
 <span class="s0">* Adds adjacency information to this primitive.  May return null if this type</span>
 <span class="s0">* of geometry does not support adjacency information.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">virtual ConstPointerTo&lt; GeomPrimitive &gt; GeomPrimitive::make_adjacency(void) const;</span>

<span class="s0">2173 13 get_num_bytes 0 4 3242 28 GeomPrimitive::get_num_bytes 0 1 570 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes consumed by the primitive and its index</span>
 <span class="s0">* table(s).</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int GeomPrimitive::get_num_bytes(void) const;</span>

<span class="s0">2174 19 get_data_size_bytes 0 4 3242 34 GeomPrimitive::get_data_size_bytes 0 1 571 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes stored in the vertices array.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int GeomPrimitive::get_data_size_bytes(void) const;</span>

<span class="s0">2175 12 get_modified 0 4 3242 27 GeomPrimitive::get_modified 0 1 572 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the vertex index array is modified.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline UpdateSeq GeomPrimitive::get_modified(void) const;</span>

<span class="s0">2176 16 request_resident 0 4 3242 31 GeomPrimitive::request_resident 0 1 573 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the primitive data is currently resident in memory.  If</span>
 <span class="s0">* this returns false, the primitive data will be brought back into memory</span>
 <span class="s0">* shortly; try again later.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">bool GeomPrimitive::request_resident(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2177 11 check_valid 0 4 3242 26 GeomPrimitive::check_valid 0 2 574 575 207</span>
<span class="s0">/**</span>
 <span class="s0">* Verifies that the primitive only references vertices that actually exist</span>
 <span class="s0">* within the indicated GeomVertexData.  Returns true if the primitive appears</span>
 <span class="s0">* to be valid, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">175</span>
<span class="s0">inline bool GeomPrimitive::check_valid(GeomVertexData const *vertex_data) const;</span>
<span class="s0">inline bool GeomPrimitive::check_valid(GeomVertexDataPipelineReader const *data_reader) const;</span>

<span class="s0">2178 6 output 0 6 3242 21 GeomPrimitive::output 0 1 576 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual void GeomPrimitive::output(std::ostream &amp;out) const;</span>

<span class="s0">2179 5 write 0 6 3242 20 GeomPrimitive::write 0 1 577 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">virtual void GeomPrimitive::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2180 12 get_vertices 0 4 3242 27 GeomPrimitive::get_vertices 0 1 578 479</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the vertex index array so application code can</span>
 <span class="s0">* read it directly.  This might return NULL if the primitive is nonindexed.</span>
 <span class="s0">* Do not attempt to modify the returned array; use modify_vertices() or</span>
 <span class="s0">* set_vertices() for this.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline ConstPointerTo&lt; GeomVertexArrayData &gt; GeomPrimitive::get_vertices(void) const;</span>

<span class="s0">2181 19 get_vertices_handle 0 4 3242 34 GeomPrimitive::get_vertices_handle 0 1 579 53</span>
<span class="s0">/**</span>
 <span class="s0">* Equivalent to get_vertices().get_handle().</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline ConstPointerTo&lt; GeomVertexArrayDataHandle &gt; GeomPrimitive::get_vertices_handle(Thread *current_thread) const;</span>

<span class="s0">2182 15 modify_vertices 0 4 3242 30 GeomPrimitive::modify_vertices 0 1 580 869</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the vertex index list, so application code</span>
 <span class="s0">* can directly fiddle with this data.  Use with caution, since there are no</span>
 <span class="s0">* checks that the data will be left in a stable state.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is called on a nonindexed primitive, it will implicitly be</span>
 <span class="s0">* converted to an indexed primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* If num_vertices is not -1, it specifies an artificial limit to the number</span>
 <span class="s0">* of vertices in the array.  Otherwise, all of the vertices in the array will</span>
 <span class="s0">* be used.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">PointerTo&lt; GeomVertexArrayData &gt; GeomPrimitive::modify_vertices(int num_vertices = -1);</span>

<span class="s0">2183 22 modify_vertices_handle 0 4 3242 37 GeomPrimitive::modify_vertices_handle 0 1 581 56</span>
<span class="s0">/**</span>
 <span class="s0">* Equivalent to modify_vertices().get_handle().</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">inline PointerTo&lt; GeomVertexArrayDataHandle &gt; GeomPrimitive::modify_vertices_handle(Thread *current_thread);</span>

<span class="s0">2184 12 set_vertices 0 4 3242 27 GeomPrimitive::set_vertices 0 1 582 711</span>
<span class="s0">/**</span>
 <span class="s0">* Completely replaces the vertex index list with a new table.  Chances are</span>
 <span class="s0">* good that you should also replace the ends list with set_ends() at the same</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* If num_vertices is not -1, it specifies an artificial limit to the number</span>
 <span class="s0">* of vertices in the array.  Otherwise, all of the vertices in the array will</span>
 <span class="s0">* be used.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">void GeomPrimitive::set_vertices(GeomVertexArrayData const *vertices, int num_vertices = -1);</span>

<span class="s0">2185 23 set_nonindexed_vertices 0 4 3242 38 GeomPrimitive::set_nonindexed_vertices 0 1 583 465</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the primitive up as a nonindexed primitive, using the indicated vertex</span>
 <span class="s0">* range.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">void GeomPrimitive::set_nonindexed_vertices(int first_vertex, int num_vertices);</span>

<span class="s0">2186 16 get_index_stride 0 4 3242 31 GeomPrimitive::get_index_stride 0 1 584 334</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to return the gap between successive index numbers,</span>
 <span class="s0">* in bytes, of the index data.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int GeomPrimitive::get_index_stride(void) const;</span>

<span class="s0">2187 19 get_strip_cut_index 0 4 3242 34 GeomPrimitive::get_strip_cut_index 0 1 585 454</span>
<span class="s0">/**</span>
 <span class="s0">* If relevant, returns the index value that may be used in some cases to</span>
 <span class="s0">* signify the end of a primitive.  This is typically the highest value that</span>
 <span class="s0">* the numeric type can store.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the index of the indicated type that is reserved for use as a strip</span>
 <span class="s0">* cut index, if enabled for the primitive.  When the renderer encounters this</span>
 <span class="s0">* index, it will restart the primitive.  This is guaranteed not to point to</span>
 <span class="s0">* an actual vertex.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int GeomPrimitive::get_strip_cut_index(void) const;</span>

<span class="s0">2188 8 get_ends 0 4 3242 23 GeomPrimitive::get_ends 0 1 586 580</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the primitive ends array so application code can</span>
 <span class="s0">* read it directly.  Do not attempt to modify the returned array; use</span>
 <span class="s0">* modify_ends() or set_ends() for this.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a ends array:</span>
 <span class="s0">* since all the primitives have the same number of vertices, it is not</span>
 <span class="s0">* needed.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline CPTA_int GeomPrimitive::get_ends(void) const;</span>

<span class="s0">2189 11 modify_ends 0 4 3242 26 GeomPrimitive::modify_ends 0 1 587 755</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the primitive ends array, so application</span>
 <span class="s0">* code can directly fiddle with this data.  Use with caution, since there are</span>
 <span class="s0">* no checks that the data will be left in a stable state.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a ends array:</span>
 <span class="s0">* since all the primitives have the same number of vertices, it is not</span>
 <span class="s0">* needed.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">PTA_int GeomPrimitive::modify_ends(void);</span>

<span class="s0">2190 8 set_ends 0 4 3242 23 GeomPrimitive::set_ends 0 1 588 716</span>
<span class="s0">/**</span>
 <span class="s0">* Completely replaces the primitive ends array with a new table.  Chances are</span>
 <span class="s0">* good that you should also replace the vertices list with set_vertices() at</span>
 <span class="s0">* the same time.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a ends array:</span>
 <span class="s0">* since all the primitives have the same number of vertices, it is not</span>
 <span class="s0">* needed.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void GeomPrimitive::set_ends(PTA_int ends);</span>

<span class="s0">2191 8 get_mins 0 4 3242 23 GeomPrimitive::get_mins 0 1 589 482</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the primitive mins array so application code can</span>
 <span class="s0">* read it directly.  Do not attempt to modify the returned array; use</span>
 <span class="s0">* set_minmax() for this.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a mins array.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline ConstPointerTo&lt; GeomVertexArrayData &gt; GeomPrimitive::get_mins(void) const;</span>

<span class="s0">2192 8 get_maxs 0 4 3242 23 GeomPrimitive::get_maxs 0 1 590 473</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the primitive maxs array so application code can</span>
 <span class="s0">* read it directly.  Do not attempt to modify the returned array; use</span>
 <span class="s0">* set_minmax().</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a maxs array.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline ConstPointerTo&lt; GeomVertexArrayData &gt; GeomPrimitive::get_maxs(void) const;</span>

<span class="s0">2193 10 set_minmax 0 4 3242 25 GeomPrimitive::set_minmax 0 1 591 687</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly specifies the minimum and maximum vertices, as well as the lists</span>
 <span class="s0">* of per-component min and max.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this method with extreme caution.  It's generally better to let the</span>
 <span class="s0">* GeomPrimitive compute these explicitly, unless for some reason you can do</span>
 <span class="s0">* it faster and you absolutely need the speed improvement.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that any modification to the vertex array will normally cause this to</span>
 <span class="s0">* be recomputed, unless you set it immediately again.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">void GeomPrimitive::set_minmax(int min_vertex, int max_vertex, GeomVertexArrayData *mins, GeomVertexArrayData *maxs);</span>

<span class="s0">2194 12 clear_minmax 0 4 3242 27 GeomPrimitive::clear_minmax 0 1 592 339</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes a previous call to set_minmax(), and allows the minimum and maximum</span>
 <span class="s0">* values to be recomputed normally.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void GeomPrimitive::clear_minmax(void);</span>

<span class="s0">2195 30 get_num_vertices_per_primitive 0 6 3242 45 GeomPrimitive::get_num_vertices_per_primitive 0 1 593 558</span>
<span class="s0">/**</span>
 <span class="s0">* If the primitive type is a simple type in which all primitives have the</span>
 <span class="s0">* same number of vertices, like triangles, returns the number of vertices per</span>
 <span class="s0">* primitive.  If the primitive type is a more complex type in which different</span>
 <span class="s0">* primitives might have different numbers of vertices, for instance a</span>
 <span class="s0">* triangle strip, returns 0.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">virtual int GeomPrimitive::get_num_vertices_per_primitive(void) const;</span>

<span class="s0">2196 34 get_min_num_vertices_per_primitive 0 6 3242 49 GeomPrimitive::get_min_num_vertices_per_primitive 0 1 594 336</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minimum number of vertices that must be added before</span>
 <span class="s0">* close_primitive() may legally be called.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">virtual int GeomPrimitive::get_min_num_vertices_per_primitive(void) const;</span>

<span class="s0">2197 37 get_num_unused_vertices_per_primitive 0 6 3242 52 GeomPrimitive::get_num_unused_vertices_per_primitive 0 1 595 479</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertices that are added between primitives that</span>
 <span class="s0">* aren't, strictly speaking, part of the primitives themselves.  This is</span>
 <span class="s0">* used, for instance, to define degenerate triangles to connect otherwise</span>
 <span class="s0">* disconnected triangle strips.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">virtual int GeomPrimitive::get_num_unused_vertices_per_primitive(void) const;</span>

<span class="s0">2198 14 get_class_type 0 4 3242 29 GeomPrimitive::get_class_type 0 1 596 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle GeomPrimitive::get_class_type(void);</span>

<span class="s0">2199 12 TextureStage 0 260 3243 26 TextureStage::TextureStage 0 2 599 600 107</span>
<span class="s0">/**</span>
 <span class="s0">* Initialize the texture stage from other</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Initialize the texture stage at construction</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">explicit TextureStage::TextureStage(std::string const &amp;name);</span>
<span class="s0">inline TextureStage::TextureStage(TextureStage const &amp;copy);</span>

<span class="s0">2200 10 operator = 0 4 3243 24 TextureStage::operator = 0 1 601 0</span>
<span class="s0">56</span>
<span class="s0">void TextureStage::operator =(TextureStage const &amp;copy);</span>

<span class="s0">2201 8 set_name 0 4 3243 22 TextureStage::set_name 0 1 602 49</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the name of this texture stage</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void TextureStage::set_name(std::string const &amp;name);</span>

<span class="s0">2202 8 get_name 0 4 3243 22 TextureStage::get_name 0 1 603 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of this texture stage</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::string const &amp;TextureStage::get_name(void) const;</span>

<span class="s0">2203 8 set_sort 0 4 3243 22 TextureStage::set_sort 0 1 604 439</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the order in which the texture associated with this stage is</span>
 <span class="s0">* rendered relative to the other texture stages.  When geometry is rendered</span>
 <span class="s0">* with multiple textures, the textures are rendered in order from the lowest</span>
 <span class="s0">* sort number to the highest sort number.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_priority(), which is used to select the most important</span>
 <span class="s0">* textures for rendering when some must be omitted because of hardware</span>
 <span class="s0">* limitations.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void TextureStage::set_sort(int sort);</span>

<span class="s0">2204 8 get_sort 0 4 3243 22 TextureStage::get_sort 0 1 605 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sort order of this texture stage.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline int TextureStage::get_sort(void) const;</span>

<span class="s0">2205 12 set_priority 0 4 3243 26 TextureStage::set_priority 0 1 606 555</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the relative importance of the texture associated with this stage</span>
 <span class="s0">* relative to the other texture stages that are applied simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* This is unrelated to set_sort(), which controls the order in which multiple</span>
 <span class="s0">* textures are applied.  The priority number is used to decide which of the</span>
 <span class="s0">* requested textures are to be selected for rendering when more textures are</span>
 <span class="s0">* requested than the hardware will support.  The highest-priority n textures</span>
 <span class="s0">* are selected for rendering, and then rendered in order by their sort</span>
 <span class="s0">* factor.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void TextureStage::set_priority(int priority);</span>

<span class="s0">2206 12 get_priority 0 4 3243 26 TextureStage::get_priority 0 1 607 163</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the priority associated with this stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This is specially helpful for cards that do not support more than n stages</span>
 <span class="s0">* of multi-texturing.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int TextureStage::get_priority(void) const;</span>

<span class="s0">2207 17 set_texcoord_name 0 4 3243 31 TextureStage::set_texcoord_name 0 2 608 609 324</span>
<span class="s0">/**</span>
 <span class="s0">* Indicate which set of UV's this texture stage will use.  Geometry may have</span>
 <span class="s0">* any number of associated UV sets, each of which must have a unique name.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Indicate which set of UV's this texture stage will use.  Geometry may have</span>
 <span class="s0">* any number of associated UV sets, each of which must have a unique name.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void TextureStage::set_texcoord_name(InternalName *name);</span>
<span class="s0">inline void TextureStage::set_texcoord_name(std::string const &amp;texcoord_name);</span>

<span class="s0">2208 17 get_texcoord_name 0 4 3243 31 TextureStage::get_texcoord_name 0 1 610 79</span>
<span class="s0">/**</span>
 <span class="s0">* See set_texcoord_name.  The default is InternalName::get_texcoord().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline InternalName *TextureStage::get_texcoord_name(void) const;</span>

<span class="s0">2209 16 get_tangent_name 0 4 3243 30 TextureStage::get_tangent_name 0 1 611 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of tangents this texture stage will use.  This is the same</span>
 <span class="s0">* as get_texcoord_name(), except that the first part is &quot;tangent&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline InternalName *TextureStage::get_tangent_name(void) const;</span>

<span class="s0">2210 17 get_binormal_name 0 4 3243 31 TextureStage::get_binormal_name 0 1 612 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of binormals this texture stage will use.  This is the same</span>
 <span class="s0">* as get_binormal_name(), except that the first part is &quot;binormal&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline InternalName *TextureStage::get_binormal_name(void) const;</span>

<span class="s0">2211 8 set_mode 0 4 3243 22 TextureStage::set_mode 0 1 613 45</span>
<span class="s0">/**</span>
 <span class="s0">* Set the mode of this texture stage</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void TextureStage::set_mode(TextureStage::Mode mode);</span>

<span class="s0">2212 8 get_mode 0 4 3243 22 TextureStage::get_mode 0 1 614 40</span>
<span class="s0">/**</span>
 <span class="s0">* Return the mode of this stage</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline TextureStage::Mode TextureStage::get_mode(void) const;</span>

<span class="s0">2213 17 is_fixed_function 0 4 3243 31 TextureStage::is_fixed_function 0 1 615 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the TextureStage is relevant to the classic fixed function</span>
 <span class="s0">* pipeline.  This excludes texture stages such as normal mapping and the</span>
 <span class="s0">* like.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool TextureStage::is_fixed_function(void) const;</span>

<span class="s0">2214 9 set_color 0 4 3243 23 TextureStage::set_color 0 1 616 39</span>
<span class="s0">/**</span>
 <span class="s0">* Set the color for this stage</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void TextureStage::set_color(LColor const &amp;color);</span>

<span class="s0">2215 9 get_color 0 4 3243 23 TextureStage::get_color 0 1 617 42</span>
<span class="s0">/**</span>
 <span class="s0">* return the color for this stage</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline LColor TextureStage::get_color(void) const;</span>

<span class="s0">2216 13 set_rgb_scale 0 4 3243 27 TextureStage::set_rgb_scale 0 1 618 215</span>
<span class="s0">/**</span>
 <span class="s0">* Sets an additional factor that will scale all three r, g, b components</span>
 <span class="s0">* after the texture has been applied.  This is used only when the mode is</span>
 <span class="s0">* CM_combine.</span>
 <span class="s0">*</span>
 <span class="s0">* The only legal values are 1, 2, or 4.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void TextureStage::set_rgb_scale(int rgb_scale);</span>

<span class="s0">2217 13 get_rgb_scale 0 4 3243 27 TextureStage::get_rgb_scale 0 1 619 31</span>
<span class="s0">/**</span>
 <span class="s0">* See set_rgb_scale().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int TextureStage::get_rgb_scale(void) const;</span>

<span class="s0">2218 15 set_alpha_scale 0 4 3243 29 TextureStage::set_alpha_scale 0 1 620 203</span>
<span class="s0">/**</span>
 <span class="s0">* Sets an additional factor that will scale the alpha component after the</span>
 <span class="s0">* texture has been applied.  This is used only when the mode is CM_combine.</span>
 <span class="s0">*</span>
 <span class="s0">* The only legal values are 1, 2, or 4.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void TextureStage::set_alpha_scale(int alpha_scale);</span>

<span class="s0">2219 15 get_alpha_scale 0 4 3243 29 TextureStage::get_alpha_scale 0 1 621 33</span>
<span class="s0">/**</span>
 <span class="s0">* See set_alpha_scale().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int TextureStage::get_alpha_scale(void) const;</span>

<span class="s0">2220 16 set_saved_result 0 4 3243 30 TextureStage::set_saved_result 0 1 622 471</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the saved_result flag.  When this is true, the output of this stage</span>
 <span class="s0">* will be supplied as the &quot;last_saved_result&quot; source for any future stages,</span>
 <span class="s0">* until the next TextureStage with a saved_result set true is encountered.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to reuse the results of this texture stage as input to</span>
 <span class="s0">* more than one stage later in the pipeline.</span>
 <span class="s0">*</span>
 <span class="s0">* The last texture in the pipeline (the one with the highest sort value)</span>
 <span class="s0">* should not have this flag set.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void TextureStage::set_saved_result(bool saved_result);</span>

<span class="s0">2221 16 get_saved_result 0 4 3243 30 TextureStage::get_saved_result 0 1 623 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the saved_result flag.  See</span>
 <span class="s0">* set_saved_result().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool TextureStage::get_saved_result(void) const;</span>

<span class="s0">2222 19 set_tex_view_offset 0 4 3243 33 TextureStage::set_tex_view_offset 0 1 624 342</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the tex_view_offset value.  This is used only when a special multiview</span>
 <span class="s0">* texture is bound to the TextureStage, and it selects the particular view of</span>
 <span class="s0">* the texture that is to be used.</span>
 <span class="s0">*</span>
 <span class="s0">* This value is added to the similar parameter on DisplayRegion to derive the</span>
 <span class="s0">* final texture view index that is selected for rendering.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void TextureStage::set_tex_view_offset(int tex_view_offset);</span>

<span class="s0">2223 19 get_tex_view_offset 0 4 3243 33 TextureStage::get_tex_view_offset 0 1 625 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the tex_view_offset.  See</span>
 <span class="s0">* set_tex_view_offset().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int TextureStage::get_tex_view_offset(void) const;</span>

<span class="s0">2224 15 set_combine_rgb 0 4 3243 29 TextureStage::set_combine_rgb 0 3 626 627 628 452</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a one-parameter</span>
 <span class="s0">* operation.  Specifically, this is CM_replace only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a two-parameter</span>
 <span class="s0">* operation.  Specifically, this is everything except for CM_replace and</span>
 <span class="s0">* CM_interpolate.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a one-parameter</span>
 <span class="s0">* operation.  Specifically, this is CM_interpolate only.</span>
 <span class="s0">*/</span>
<span class="s0">680</span>
<span class="s0">inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0);</span>
<span class="s0">inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1);</span>
<span class="s0">inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1, TextureStage::CombineSource source2, TextureStage::CombineOperand operand2);</span>

<span class="s0">2225 20 get_combine_rgb_mode 0 4 3243 34 TextureStage::get_combine_rgb_mode 0 1 629 35</span>
<span class="s0">/**</span>
 <span class="s0">* Get the combine_rgb_mode</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline TextureStage::CombineMode TextureStage::get_combine_rgb_mode(void) const;</span>

<span class="s0">2226 28 get_num_combine_rgb_operands 0 4 3243 42 TextureStage::get_num_combine_rgb_operands 0 1 630 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of meaningful operands that may be retrieved via</span>
 <span class="s0">* get_combine_rgb_sourceN() and get_combine_rgb_operandN().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline int TextureStage::get_num_combine_rgb_operands(void) const;</span>

<span class="s0">2227 23 get_combine_rgb_source0 0 4 3243 37 TextureStage::get_combine_rgb_source0 0 1 631 42</span>
<span class="s0">/**</span>
 <span class="s0">* Get source0 of combine_rgb_mode</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline TextureStage::CombineSource TextureStage::get_combine_rgb_source0(void) const;</span>

<span class="s0">2228 24 get_combine_rgb_operand0 0 4 3243 38 TextureStage::get_combine_rgb_operand0 0 1 632 43</span>
<span class="s0">/**</span>
 <span class="s0">* Get operand0 of combine_rgb_mode</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand0(void) const;</span>

<span class="s0">2229 23 get_combine_rgb_source1 0 4 3243 37 TextureStage::get_combine_rgb_source1 0 1 633 42</span>
<span class="s0">/**</span>
 <span class="s0">* Get source1 of combine_rgb_mode</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline TextureStage::CombineSource TextureStage::get_combine_rgb_source1(void) const;</span>

<span class="s0">2230 24 get_combine_rgb_operand1 0 4 3243 38 TextureStage::get_combine_rgb_operand1 0 1 634 43</span>
<span class="s0">/**</span>
 <span class="s0">* Get operand1 of combine_rgb_mode</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand1(void) const;</span>

<span class="s0">2231 23 get_combine_rgb_source2 0 4 3243 37 TextureStage::get_combine_rgb_source2 0 1 635 42</span>
<span class="s0">/**</span>
 <span class="s0">* Get source2 of combine_rgb_mode</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline TextureStage::CombineSource TextureStage::get_combine_rgb_source2(void) const;</span>

<span class="s0">2232 24 get_combine_rgb_operand2 0 4 3243 38 TextureStage::get_combine_rgb_operand2 0 1 636 43</span>
<span class="s0">/**</span>
 <span class="s0">* Get operand2 of combine_rgb_mode</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand2(void) const;</span>

<span class="s0">2233 17 set_combine_alpha 0 4 3243 31 TextureStage::set_combine_alpha 0 3 637 638 639 452</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a one-parameter</span>
 <span class="s0">* operation.  Specifically, this is CM_replace only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a two-parameter</span>
 <span class="s0">* operation.  Specifically, this is everything except for CM_replace and</span>
 <span class="s0">* CM_interpolate.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a one-parameter</span>
 <span class="s0">* operation.  Specifically, this is CM_interpolate only.</span>
 <span class="s0">*/</span>
<span class="s0">686</span>
<span class="s0">inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0);</span>
<span class="s0">inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1);</span>
<span class="s0">inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1, TextureStage::CombineSource source2, TextureStage::CombineOperand operand2);</span>

<span class="s0">2234 22 get_combine_alpha_mode 0 4 3243 36 TextureStage::get_combine_alpha_mode 0 1 640 33</span>
<span class="s0">/**</span>
 <span class="s0">* Get combine_alpha_mode</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline TextureStage::CombineMode TextureStage::get_combine_alpha_mode(void) const;</span>

<span class="s0">2235 30 get_num_combine_alpha_operands 0 4 3243 44 TextureStage::get_num_combine_alpha_operands 0 1 641 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of meaningful operands that may be retrieved via</span>
 <span class="s0">* get_combine_alpha_sourceN() and get_combine_alpha_operandN().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline int TextureStage::get_num_combine_alpha_operands(void) const;</span>

<span class="s0">2236 25 get_combine_alpha_source0 0 4 3243 39 TextureStage::get_combine_alpha_source0 0 1 642 44</span>
<span class="s0">/**</span>
 <span class="s0">* Get source0 of combine_alpha_mode</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline TextureStage::CombineSource TextureStage::get_combine_alpha_source0(void) const;</span>

<span class="s0">2237 26 get_combine_alpha_operand0 0 4 3243 40 TextureStage::get_combine_alpha_operand0 0 1 643 45</span>
<span class="s0">/**</span>
 <span class="s0">* Get operand0 of combine_alpha_mode</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand0(void) const;</span>

<span class="s0">2238 25 get_combine_alpha_source1 0 4 3243 39 TextureStage::get_combine_alpha_source1 0 1 644 44</span>
<span class="s0">/**</span>
 <span class="s0">* Get source1 of combine_alpha_mode</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline TextureStage::CombineSource TextureStage::get_combine_alpha_source1(void) const;</span>

<span class="s0">2239 26 get_combine_alpha_operand1 0 4 3243 40 TextureStage::get_combine_alpha_operand1 0 1 645 45</span>
<span class="s0">/**</span>
 <span class="s0">* Get operand1 of combine_alpha_mode</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand1(void) const;</span>

<span class="s0">2240 25 get_combine_alpha_source2 0 4 3243 39 TextureStage::get_combine_alpha_source2 0 1 646 44</span>
<span class="s0">/**</span>
 <span class="s0">* Get source2 of combine_alpha_mode</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline TextureStage::CombineSource TextureStage::get_combine_alpha_source2(void) const;</span>

<span class="s0">2241 26 get_combine_alpha_operand2 0 4 3243 40 TextureStage::get_combine_alpha_operand2 0 1 647 45</span>
<span class="s0">/**</span>
 <span class="s0">* Get operand2 of combine_alpha_mode</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand2(void) const;</span>

<span class="s0">2242 20 involves_color_scale 0 4 3243 34 TextureStage::involves_color_scale 0 1 648 123</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the TextureStage is affected by the setting of the current</span>
 <span class="s0">* ColorScaleAttrib, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool TextureStage::involves_color_scale(void) const;</span>

<span class="s0">2243 10 uses_color 0 4 3243 24 TextureStage::uses_color 0 1 649 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the TextureStage makes use of whatever color is specified</span>
 <span class="s0">* in set_color(), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool TextureStage::uses_color(void) const;</span>

<span class="s0">2244 18 uses_primary_color 0 4 3243 32 TextureStage::uses_primary_color 0 1 650 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the TextureStage makes use of the CS_primary_color combine</span>
 <span class="s0">* source.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool TextureStage::uses_primary_color(void) const;</span>

<span class="s0">2245 22 uses_last_saved_result 0 4 3243 36 TextureStage::uses_last_saved_result 0 1 651 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the TextureStage makes use of the CS_primary_color combine</span>
 <span class="s0">* source.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool TextureStage::uses_last_saved_result(void) const;</span>

<span class="s0">2246 11 operator == 0 4 3243 25 TextureStage::operator == 0 1 652 0</span>
<span class="s0">71</span>
<span class="s0">inline bool TextureStage::operator ==(TextureStage const &amp;other) const;</span>

<span class="s0">2247 11 operator != 0 4 3243 25 TextureStage::operator != 0 1 653 0</span>
<span class="s0">71</span>
<span class="s0">inline bool TextureStage::operator !=(TextureStage const &amp;other) const;</span>

<span class="s0">2248 10 operator &lt; 0 4 3243 24 TextureStage::operator &lt; 0 1 654 0</span>
<span class="s0">70</span>
<span class="s0">inline bool TextureStage::operator &lt;(TextureStage const &amp;other) const;</span>

<span class="s0">2249 10 compare_to 0 4 3243 24 TextureStage::compare_to 0 1 655 267</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this TextureStage sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">* The sorting order is arbitrary and largely meaningless, except to</span>
 <span class="s0">* differentiate different stages.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">int TextureStage::compare_to(TextureStage const &amp;other) const;</span>

<span class="s0">2250 5 write 0 4 3243 19 TextureStage::write 0 2 656 657 88</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the details of this stage</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes the details of this stage</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">void TextureStage::write(std::ostream &amp;out) const;</span>
<span class="s0">void TextureStage::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2251 6 output 0 4 3243 20 TextureStage::output 0 1 658 36</span>
<span class="s0">/**</span>
 <span class="s0">* Just a single line output</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void TextureStage::output(std::ostream &amp;out) const;</span>

<span class="s0">2252 11 get_default 0 4 3243 25 TextureStage::get_default 0 1 659 180</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default TextureStage that will be used for all texturing that</span>
 <span class="s0">* does not name a particular stage.  This generally handles the normal</span>
 <span class="s0">* single-texture case.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">static inline TextureStage *TextureStage::get_default(void);</span>

<span class="s0">2253 14 get_class_type 0 4 3243 28 TextureStage::get_class_type 0 1 660 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle TextureStage::get_class_type(void);</span>

<span class="s0">2254 27 upcast_to_CopyOnWriteObject 0 12 3252 33 Geom::upcast_to_CopyOnWriteObject 0 1 727 37</span>
<span class="s0">upcast from Geom to CopyOnWriteObject</span>
<span class="s0">59</span>
<span class="s0">CopyOnWriteObject *Geom::upcast_to_CopyOnWriteObject(void);</span>

<span class="s0">2255 16 downcast_to_Geom 0 12 3208 35 CopyOnWriteObject::downcast_to_Geom 0 0 39</span>
<span class="s0">downcast from CopyOnWriteObject to Geom</span>
<span class="s0">48</span>
<span class="s0">Geom *CopyOnWriteObject::downcast_to_Geom(void);</span>

<span class="s0">2256 19 upcast_to_GeomEnums 0 12 3252 25 Geom::upcast_to_GeomEnums 0 1 728 29</span>
<span class="s0">upcast from Geom to GeomEnums</span>
<span class="s0">43</span>
<span class="s0">GeomEnums *Geom::upcast_to_GeomEnums(void);</span>

<span class="s0">2257 16 downcast_to_Geom 0 12 3168 27 GeomEnums::downcast_to_Geom 0 0 31</span>
<span class="s0">downcast from GeomEnums to Geom</span>
<span class="s0">40</span>
<span class="s0">Geom *GeomEnums::downcast_to_Geom(void);</span>

<span class="s0">2258 4 Geom 0 260 3252 10 Geom::Geom 0 1 661 59</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Use make_copy() to duplicate a Geom.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">explicit Geom::Geom(GeomVertexData const *data);</span>

<span class="s0">2259 10 operator = 0 4 3252 16 Geom::operator = 0 1 662 0</span>
<span class="s0">40</span>
<span class="s0">void Geom::operator =(Geom const &amp;copy);</span>

<span class="s0">2260 5 ~Geom 0 518 3252 11 Geom::~Geom 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">26</span>
<span class="s0">virtual Geom::~Geom(void);</span>

<span class="s0">2261 12 operator new 0 4 3252 18 Geom::operator new 0 1 663 0</span>
<span class="s0">112</span>
<span class="s0">inline void *Geom::operator new(std::size_t size);</span>
<span class="s0">inline void *Geom::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2262 15 operator delete 0 4 3252 21 Geom::operator delete 0 0 0</span>
<span class="s0">96</span>
<span class="s0">inline void Geom::operator delete(void *ptr);</span>
<span class="s0">inline void Geom::operator delete(void *, void *);</span>

<span class="s0">2263 12 validate_ptr 0 4 3252 18 Geom::validate_ptr 0 0 0</span>
<span class="s0">55</span>
<span class="s0">static inline bool Geom::validate_ptr(void const *ptr);</span>

<span class="s0">2264 9 make_copy 0 6 3252 15 Geom::make_copy 0 1 664 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated Geom that is a shallow copy of this one.  It will</span>
 <span class="s0">* be a different Geom pointer, but its internal data may or may not be shared</span>
 <span class="s0">* with that of the original Geom.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">virtual Geom *Geom::make_copy(void) const;</span>

<span class="s0">2265 18 get_primitive_type 0 4 3252 24 Geom::get_primitive_type 0 1 665 361</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the fundamental primitive type that is common to all GeomPrimitives</span>
 <span class="s0">* added within the Geom.  All nested primitives within a particular Geom must</span>
 <span class="s0">* be the same type (that is, you can mix triangles and tristrips, because</span>
 <span class="s0">* they are both the same fundamental type PT_polygons, but you cannot mix</span>
 <span class="s0">* triangles and points withn the same Geom).</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline GeomEnums::PrimitiveType Geom::get_primitive_type(void) const;</span>

<span class="s0">2266 15 get_shade_model 0 4 3252 21 Geom::get_shade_model 0 1 666 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the shade model common to all of the individual GeomPrimitives that</span>
 <span class="s0">* have been added to the geom.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline GeomEnums::ShadeModel Geom::get_shade_model(void) const;</span>

<span class="s0">2267 18 get_geom_rendering 0 4 3252 24 Geom::get_geom_rendering 0 1 667 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of GeomRendering bits that represent the rendering</span>
 <span class="s0">* properties required to properly render this Geom.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int Geom::get_geom_rendering(void) const;</span>

<span class="s0">2268 14 get_usage_hint 0 4 3252 20 Geom::get_usage_hint 0 1 668 189</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minimum (i.e.  most dynamic) usage_hint among all of the</span>
 <span class="s0">* individual GeomPrimitives that have been added to the geom.</span>
 <span class="s0">* @deprecated  This is no longer very useful.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">GeomEnums::UsageHint Geom::get_usage_hint(void) const;</span>

<span class="s0">2269 14 set_usage_hint 0 4 3252 20 Geom::set_usage_hint 0 1 669 273</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the UsageHint hint for all of the primitives on this Geom to the</span>
 <span class="s0">* same value.  See get_usage_hint().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void Geom::set_usage_hint(GeomEnums::UsageHint usage_hint);</span>

<span class="s0">2270 15 get_vertex_data 0 4 3252 21 Geom::get_vertex_data 0 1 670 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the GeomVertexData, for application code to</span>
 <span class="s0">* directly examine (but not modify) the geom's underlying data.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline ConstPointerTo&lt; GeomVertexData &gt; Geom::get_vertex_data(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2271 18 modify_vertex_data 0 4 3252 24 Geom::modify_vertex_data 0 1 671 294</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the GeomVertexData, so that application</span>
 <span class="s0">* code may directly maniuplate the geom's underlying data.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">PointerTo&lt; GeomVertexData &gt; Geom::modify_vertex_data(void);</span>

<span class="s0">2272 15 set_vertex_data 0 4 3252 21 Geom::set_vertex_data 0 1 672 243</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the Geom's underlying vertex data table with a completely new</span>
 <span class="s0">* table.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void Geom::set_vertex_data(GeomVertexData const *data);</span>

<span class="s0">2273 15 offset_vertices 0 4 3252 21 Geom::offset_vertices 0 1 673 501</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces a Geom's vertex table with a new table, and simultaneously adds</span>
 <span class="s0">* the indicated offset to all vertex references within the Geom's primitives.</span>
 <span class="s0">* This is intended to be used to combine multiple GeomVertexDatas from</span>
 <span class="s0">* different Geoms into a single big buffer, with each Geom referencing a</span>
 <span class="s0">* subset of the vertices in the buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void Geom::offset_vertices(GeomVertexData const *data, int offset);</span>

<span class="s0">2274 15 make_nonindexed 0 4 3252 21 Geom::make_nonindexed 0 1 674 414</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the geom from indexed to nonindexed by duplicating vertices as</span>
 <span class="s0">* necessary.  If composite_only is true, then only composite primitives such</span>
 <span class="s0">* as trifans and tristrips are converted.  Returns the number of</span>
 <span class="s0">* GeomPrimitive objects converted.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">int Geom::make_nonindexed(bool composite_only);</span>

<span class="s0">2275 24 get_animated_vertex_data 0 4 3252 30 Geom::get_animated_vertex_data 0 1 675 865</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a GeomVertexData that represents the results of computing the</span>
 <span class="s0">* vertex animation on the CPU for this Geom's vertex data.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is no CPU-defined vertex animation on this object, this just</span>
 <span class="s0">* returns the original object.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is vertex animation, but the VertexTransform values have not</span>
 <span class="s0">* changed since last time, this may return the same pointer it returned</span>
 <span class="s0">* previously.  Even if the VertexTransform values have changed, it may still</span>
 <span class="s0">* return the same pointer, but with its contents modified (this is preferred,</span>
 <span class="s0">* since it allows the graphics backend to update vertex buffers optimally).</span>
 <span class="s0">*</span>
 <span class="s0">* If force is false, this method may return immediately with stale data, if</span>
 <span class="s0">* the vertex data is not completely resident.  If force is true, this method</span>
 <span class="s0">* will never return stale data, but may block until the data is available.</span>
 <span class="s0">*/</span>
<span class="s0">137</span>
<span class="s0">ConstPointerTo&lt; GeomVertexData &gt; Geom::get_animated_vertex_data(bool force, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2276 8 is_empty 0 4 3252 14 Geom::is_empty 0 1 676 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there appear to be no vertices to be rendered by this Geom,</span>
 <span class="s0">* false if has some actual data.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline bool Geom::is_empty(void) const;</span>

<span class="s0">2277 18 get_num_primitives 0 4 3252 24 Geom::get_num_primitives 0 1 677 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of GeomPrimitive objects stored within the Geom, each of</span>
 <span class="s0">* which represents a number of primitives of a particular type.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline std::size_t Geom::get_num_primitives(void) const;</span>

<span class="s0">2278 13 get_primitive 0 4 3252 19 Geom::get_primitive 0 1 678 211</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the ith GeomPrimitive object stored within the</span>
 <span class="s0">* Geom.  Use this call only to inspect the ith object; use modify_primitive()</span>
 <span class="s0">* or set_primitive() if you want to modify it.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline ConstPointerTo&lt; GeomPrimitive &gt; Geom::get_primitive(std::size_t i) const;</span>

<span class="s0">2279 16 modify_primitive 0 4 3252 22 Geom::modify_primitive 0 1 679 331</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the ith GeomPrimitive object stored within</span>
 <span class="s0">* the Geom, so application code can directly manipulate the properties of</span>
 <span class="s0">* this primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline PointerTo&lt; GeomPrimitive &gt; Geom::modify_primitive(std::size_t i);</span>

<span class="s0">2280 13 set_primitive 0 4 3252 19 Geom::set_primitive 0 1 680 247</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the ith GeomPrimitive object stored within the Geom with the new</span>
 <span class="s0">* object.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void Geom::set_primitive(std::size_t i, GeomPrimitive const *primitive);</span>

<span class="s0">2281 16 insert_primitive 0 4 3252 22 Geom::insert_primitive 0 1 681 342</span>
<span class="s0">/**</span>
 <span class="s0">* Inserts a new GeomPrimitive structure to the Geom object.  This specifies a</span>
 <span class="s0">* particular subset of vertices that are used to define geometric primitives</span>
 <span class="s0">* of the indicated type.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void Geom::insert_primitive(std::size_t i, GeomPrimitive const *primitive);</span>

<span class="s0">2282 13 add_primitive 0 4 3252 19 Geom::add_primitive 0 1 682 342</span>
<span class="s0">/**</span>
 <span class="s0">* Inserts a new GeomPrimitive structure to the Geom object.  This specifies a</span>
 <span class="s0">* particular subset of vertices that are used to define geometric primitives</span>
 <span class="s0">* of the indicated type.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void Geom::add_primitive(GeomPrimitive const *primitive);</span>

<span class="s0">2283 16 remove_primitive 0 4 3252 22 Geom::remove_primitive 0 1 683 203</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the ith primitive from the list.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void Geom::remove_primitive(std::size_t i);</span>

<span class="s0">2284 16 clear_primitives 0 4 3252 22 Geom::clear_primitives 0 1 684 332</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the primitives from the Geom object (but keeps the same table</span>
 <span class="s0">* of vertices).  You may then re-add primitives one at a time via calls to</span>
 <span class="s0">* add_primitive().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void Geom::clear_primitives(void);</span>

<span class="s0">2285 9 decompose 0 4 3252 15 Geom::decompose 0 1 685 118</span>
<span class="s0">/**</span>
 <span class="s0">* Decomposes all of the primitives within this Geom, returning the result.</span>
 <span class="s0">* See GeomPrimitive::decompose().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::decompose(void) const;</span>

<span class="s0">2286 10 doubleside 0 4 3252 16 Geom::doubleside 0 1 686 120</span>
<span class="s0">/**</span>
 <span class="s0">* Doublesides all of the primitives within this Geom, returning the result.</span>
 <span class="s0">* See GeomPrimitive::doubleside().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::doubleside(void) const;</span>

<span class="s0">2287 7 reverse 0 4 3252 13 Geom::reverse 0 1 687 115</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses all of the primitives within this Geom, returning the result.  See</span>
 <span class="s0">* GeomPrimitive::reverse().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::reverse(void) const;</span>

<span class="s0">2288 6 rotate 0 4 3252 12 Geom::rotate 0 1 688 113</span>
<span class="s0">/**</span>
 <span class="s0">* Rotates all of the primitives within this Geom, returning the result.  See</span>
 <span class="s0">* GeomPrimitive::rotate().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::rotate(void) const;</span>

<span class="s0">2289 5 unify 0 4 3252 11 Geom::unify 0 1 689 541</span>
<span class="s0">/**</span>
 <span class="s0">* Unifies all of the primitives contained within this Geom into a single (or</span>
 <span class="s0">* as few as possible, within the constraints of max_indices) primitive</span>
 <span class="s0">* objects.  This may require decomposing the primitives if, for instance, the</span>
 <span class="s0">* Geom contains both triangle strips and triangle fans.</span>
 <span class="s0">*</span>
 <span class="s0">* max_indices represents the maximum number of indices that will be put in</span>
 <span class="s0">* any one GeomPrimitive.  If preserve_order is true, then the primitives will</span>
 <span class="s0">* not be reordered during the operation, even if this results in a suboptimal</span>
 <span class="s0">* result.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::unify(int max_indices, bool preserve_order) const;</span>

<span class="s0">2290 11 make_points 0 4 3252 17 Geom::make_points 0 1 690 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new Geom with points at all the vertices.  See</span>
 <span class="s0">* GeomPrimitive::make_points().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::make_points(void) const;</span>

<span class="s0">2291 10 make_lines 0 4 3252 16 Geom::make_lines 0 1 691 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new Geom with lines at all the edges.  See</span>
 <span class="s0">* GeomPrimitive::make_lines().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::make_lines(void) const;</span>

<span class="s0">2292 12 make_patches 0 4 3252 18 Geom::make_patches 0 1 692 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new Geom with each primitive converted into a patch.  Calls</span>
 <span class="s0">* decompose() first.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::make_patches(void) const;</span>

<span class="s0">2293 14 make_adjacency 0 4 3252 20 Geom::make_adjacency 0 1 693 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new Geom with each primitive converted into a corresponding</span>
 <span class="s0">* version with adjacency information.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline PointerTo&lt; Geom &gt; Geom::make_adjacency(void) const;</span>

<span class="s0">2294 18 decompose_in_place 0 4 3252 24 Geom::decompose_in_place 0 1 694 279</span>
<span class="s0">/**</span>
 <span class="s0">* Decomposes all of the primitives within this Geom, leaving the results in</span>
 <span class="s0">* place.  See GeomPrimitive::decompose().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void Geom::decompose_in_place(void);</span>

<span class="s0">2295 19 doubleside_in_place 0 4 3252 25 Geom::doubleside_in_place 0 1 695 281</span>
<span class="s0">/**</span>
 <span class="s0">* Doublesides all of the primitives within this Geom, leaving the results in</span>
 <span class="s0">* place.  See GeomPrimitive::doubleside().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void Geom::doubleside_in_place(void);</span>

<span class="s0">2296 16 reverse_in_place 0 4 3252 22 Geom::reverse_in_place 0 1 696 275</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses all of the primitives within this Geom, leaving the results in</span>
 <span class="s0">* place.  See GeomPrimitive::reverse().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void Geom::reverse_in_place(void);</span>

<span class="s0">2297 15 rotate_in_place 0 4 3252 21 Geom::rotate_in_place 0 1 697 273</span>
<span class="s0">/**</span>
 <span class="s0">* Rotates all of the primitives within this Geom, leaving the results in</span>
 <span class="s0">* place.  See GeomPrimitive::rotate().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void Geom::rotate_in_place(void);</span>

<span class="s0">2298 14 unify_in_place 0 4 3252 20 Geom::unify_in_place 0 1 698 693</span>
<span class="s0">/**</span>
 <span class="s0">* Unifies all of the primitives contained within this Geom into a single (or</span>
 <span class="s0">* as few as possible, within the constraints of max_indices) primitive</span>
 <span class="s0">* objects.  This may require decomposing the primitives if, for instance, the</span>
 <span class="s0">* Geom contains both triangle strips and triangle fans.</span>
 <span class="s0">*</span>
 <span class="s0">* max_indices represents the maximum number of indices that will be put in</span>
 <span class="s0">* any one GeomPrimitive.  If preserve_order is true, then the primitives will</span>
 <span class="s0">* not be reordered during the operation, even if this results in a suboptimal</span>
 <span class="s0">* result.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void Geom::unify_in_place(int max_indices, bool preserve_order);</span>

<span class="s0">2299 20 make_points_in_place 0 4 3252 26 Geom::make_points_in_place 0 1 699 275</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the GeomPrimitives within this Geom with corresponding GeomPoints.</span>
 <span class="s0">* See GeomPrimitive::make_points().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void Geom::make_points_in_place(void);</span>

<span class="s0">2300 19 make_lines_in_place 0 4 3252 25 Geom::make_lines_in_place 0 1 700 321</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the GeomPrimitives within this Geom with corresponding GeomLines,</span>
 <span class="s0">* representing a wireframe of the primitives.  See</span>
 <span class="s0">* GeomPrimitive::make_lines().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void Geom::make_lines_in_place(void);</span>

<span class="s0">2301 21 make_patches_in_place 0 4 3252 27 Geom::make_patches_in_place 0 1 701 278</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the GeomPrimitives within this Geom with corresponding</span>
 <span class="s0">* GeomPatches.  See GeomPrimitive::make_patches().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void Geom::make_patches_in_place(void);</span>

<span class="s0">2302 23 make_adjacency_in_place 0 4 3252 29 Geom::make_adjacency_in_place 0 1 702 324</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the GeomPrimitives within this Geom with corresponding versions</span>
 <span class="s0">* with adjacency information.  See GeomPrimitive::make_adjacency().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void Geom::make_adjacency_in_place(void);</span>

<span class="s0">2303 20 copy_primitives_from 0 6 3252 26 Geom::copy_primitives_from 0 1 703 451</span>
<span class="s0">/**</span>
 <span class="s0">* Copies the primitives from the indicated Geom into this one.  This does</span>
 <span class="s0">* require that both Geoms contain the same fundamental type primitives, both</span>
 <span class="s0">* have a compatible shade model, and both use the same GeomVertexData.  Both</span>
 <span class="s0">* Geoms must also be the same specific class type (i.e.  if one is a</span>
 <span class="s0">* GeomTextGlyph, they both must be.)</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the copy is successful, or false otherwise (because the</span>
 <span class="s0">* Geoms were mismatched).</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual bool Geom::copy_primitives_from(Geom const *other);</span>

<span class="s0">2304 13 get_num_bytes 0 4 3252 19 Geom::get_num_bytes 0 1 704 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes consumed by the geom and its primitives (but</span>
 <span class="s0">* not including its vertex table).</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">int Geom::get_num_bytes(void) const;</span>

<span class="s0">2305 12 get_modified 0 4 3252 18 Geom::get_modified 0 1 705 281</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* any of the primitives in the Geom is modified, or the set of primitives is</span>
 <span class="s0">* modified.  However, this does not include modifications to the vertex data,</span>
 <span class="s0">* which should be tested separately.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">inline UpdateSeq Geom::get_modified(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2306 16 request_resident 0 4 3252 22 Geom::request_resident 0 1 706 286</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all the primitive arrays are currently resident in memory.</span>
 <span class="s0">* If this returns false, the data will be brought back into memory shortly;</span>
 <span class="s0">* try again later.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not also test the Geom's associated GeomVertexData.  That must be</span>
 <span class="s0">* tested separately.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">bool Geom::request_resident(void) const;</span>

<span class="s0">2307 18 transform_vertices 0 4 3252 24 Geom::transform_vertices 0 1 707 477</span>
<span class="s0">/**</span>
 <span class="s0">* Applies the indicated transform to all of the vertices in the Geom.  If the</span>
 <span class="s0">* Geom happens to share a vertex table with another Geom, this operation will</span>
 <span class="s0">* duplicate the vertex table instead of breaking the other Geom; however, if</span>
 <span class="s0">* multiple Geoms with shared tables are transformed by the same matrix, they</span>
 <span class="s0">* will no longer share tables after the operation.  Consider using the</span>
 <span class="s0">* GeomTransformer if you will be applying the same transform to multiple</span>
 <span class="s0">* Geoms.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void Geom::transform_vertices(LMatrix4 const &amp;mat);</span>

<span class="s0">2308 11 check_valid 0 4 3252 17 Geom::check_valid 0 2 708 709 423</span>
<span class="s0">/**</span>
 <span class="s0">* Verifies that the all of the primitives within the geom reference vertices</span>
 <span class="s0">* that actually exist within the geom's GeomVertexData.  Returns true if the</span>
 <span class="s0">* geom appears to be valid, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Verifies that the all of the primitives within the geom reference vertices</span>
 <span class="s0">* that actually exist within the indicated GeomVertexData.  Returns true if</span>
 <span class="s0">* the geom appears to be valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">bool Geom::check_valid(void) const;</span>
<span class="s0">bool Geom::check_valid(GeomVertexData const *vertex_data) const;</span>

<span class="s0">2309 10 get_bounds 0 4 3252 16 Geom::get_bounds 0 1 710 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bounding volume for the Geom.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">ConstPointerTo&lt; BoundingVolume &gt; Geom::get_bounds(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2310 19 get_nested_vertices 0 4 3252 25 Geom::get_nested_vertices 0 1 711 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertices rendered by all primitives within the Geom.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">int Geom::get_nested_vertices(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2311 17 mark_bounds_stale 0 4 3252 23 Geom::mark_bounds_stale 0 1 712 147</span>
<span class="s0">/**</span>
 <span class="s0">* Marks the bounding volume of the Geom as stale so that it should be</span>
 <span class="s0">* recomputed.  Usually it is not necessary to call this explicitly.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void Geom::mark_bounds_stale(void) const;</span>

<span class="s0">2312 15 set_bounds_type 0 4 3252 21 Geom::set_bounds_type 0 1 713 594</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the desired type of bounding volume that will be created for this</span>
 <span class="s0">* Geom.  This is normally BoundingVolume::BT_default, which means to set the</span>
 <span class="s0">* type according to the config variable &quot;bounds-type&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is BT_sphere or BT_box, a BoundingSphere or BoundingBox is</span>
 <span class="s0">* explicitly created.  If it is BT_best, a BoundingBox is created.</span>
 <span class="s0">*</span>
 <span class="s0">* This affects the implicit bounding volume only.  If an explicit bounding</span>
 <span class="s0">* volume is set on the Geom with set_bounds(), that bounding volume type is</span>
 <span class="s0">* used.  (This is different behavior from the similar method on PandaNode.)</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void Geom::set_bounds_type(BoundingVolume::BoundsType bounds_type);</span>

<span class="s0">2313 15 get_bounds_type 0 4 3252 21 Geom::get_bounds_type 0 1 714 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bounding volume type set with set_bounds_type().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline BoundingVolume::BoundsType Geom::get_bounds_type(void) const;</span>

<span class="s0">2314 10 set_bounds 0 4 3252 16 Geom::set_bounds 0 1 715 417</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the bounding volume so that it is the indicated volume.  When it is</span>
 <span class="s0">* explicitly set, the bounding volume will no longer be automatically</span>
 <span class="s0">* computed; call clear_bounds() if you would like to return the bounding</span>
 <span class="s0">* volume to its default behavior.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void Geom::set_bounds(BoundingVolume const *volume);</span>

<span class="s0">2315 12 clear_bounds 0 4 3252 18 Geom::clear_bounds 0 1 716 317</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses the effect of a previous call to set_bounds(), and allows the</span>
 <span class="s0">* bounding volume to be automatically computed once more based on the</span>
 <span class="s0">* vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline void Geom::clear_bounds(void);</span>

<span class="s0">2316 6 output 0 6 3252 12 Geom::output 0 1 717 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">virtual void Geom::output(std::ostream &amp;out) const;</span>

<span class="s0">2317 5 write 0 6 3252 11 Geom::write 0 1 718 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">virtual void Geom::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2318 11 clear_cache 0 4 3252 17 Geom::clear_cache 0 1 719 263</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the previously-cached results of munge_geom().</span>
 <span class="s0">*</span>
 <span class="s0">* This blows away the entire cache, upstream and downstream the pipeline.</span>
 <span class="s0">* Use clear_cache_stage() instead if you only want to blow away the cache at</span>
 <span class="s0">* the current stage and upstream.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">void Geom::clear_cache(void);</span>

<span class="s0">2319 17 clear_cache_stage 0 4 3252 23 Geom::clear_cache_stage 0 1 720 310</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the previously-cached results of munge_geom(), at the</span>
 <span class="s0">* current pipeline stage and upstream.  Does not affect the downstream cache.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void Geom::clear_cache_stage(Thread *current_thread);</span>

<span class="s0">2320 7 prepare 0 4 3252 13 Geom::prepare 0 1 721 351</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the geom should be enqueued to be prepared in the indicated</span>
 <span class="s0">* prepared_objects at the beginning of the next frame.  This will ensure the</span>
 <span class="s0">* geom is already loaded into geom memory if it is expected to be rendered</span>
 <span class="s0">* soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload geoms from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void Geom::prepare(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">2321 11 is_prepared 0 4 3252 17 Geom::is_prepared 0 1 722 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the geom has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">bool Geom::is_prepared(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2322 7 release 0 4 3252 13 Geom::release 0 1 723 154</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the geom context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool Geom::release(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">2323 11 release_all 0 4 3252 17 Geom::release_all 0 1 724 149</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the context allocated on all objects for which the geom has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">int Geom::release_all(void);</span>

<span class="s0">2324 11 prepare_now 0 4 3252 17 Geom::prepare_now 0 1 725 519</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a context for the geom on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) GeomContext.  This assumes that</span>
 <span class="s0">* the GraphicsStateGuardian is the currently active rendering context and</span>
 <span class="s0">* that it is ready to accept new geoms.  If this is not necessarily the case,</span>
 <span class="s0">* you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a geom does not need to be explicitly prepared by the user before it may be</span>
 <span class="s0">* rendered.</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">GeomContext *Geom::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2325 14 get_class_type 0 4 3252 20 Geom::get_class_type 0 1 726 0</span>
<span class="s0">45</span>
<span class="s0">static TypeHandle Geom::get_class_type(void);</span>

<span class="s0">2326 8 get_geom 0 4 3256 21 GeomContext::get_geom 0 1 729 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline Geom *GeomContext::get_geom(void) const;</span>

<span class="s0">2327 14 get_class_type 0 4 3256 27 GeomContext::get_class_type 0 1 730 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle GeomContext::get_class_type(void);</span>

<span class="s0">2328 12 ~GeomContext 0 516 3256 25 GeomContext::~GeomContext 0 0 0</span>
<span class="s0">32</span>
<span class="s0">GeomContext::~GeomContext(void);</span>

<span class="s0">2329 9 GeomLines 0 260 3258 20 GeomLines::GeomLines 0 2 731 732 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">explicit GeomLines::GeomLines(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomLines::GeomLines(GeomLines const &amp;copy);</span>

<span class="s0">2330 12 operator new 0 4 3258 23 GeomLines::operator new 0 1 733 0</span>
<span class="s0">122</span>
<span class="s0">inline void *GeomLines::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomLines::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2331 15 operator delete 0 4 3258 26 GeomLines::operator delete 0 0 0</span>
<span class="s0">106</span>
<span class="s0">inline void GeomLines::operator delete(void *ptr);</span>
<span class="s0">inline void GeomLines::operator delete(void *, void *);</span>

<span class="s0">2332 12 validate_ptr 0 4 3258 23 GeomLines::validate_ptr 0 0 0</span>
<span class="s0">60</span>
<span class="s0">static inline bool GeomLines::validate_ptr(void const *ptr);</span>

<span class="s0">2333 14 get_class_type 0 4 3258 25 GeomLines::get_class_type 0 1 734 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle GeomLines::get_class_type(void);</span>

<span class="s0">2334 18 GeomLinesAdjacency 0 260 3259 38 GeomLinesAdjacency::GeomLinesAdjacency 0 2 735 736 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">explicit GeomLinesAdjacency::GeomLinesAdjacency(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomLinesAdjacency::GeomLinesAdjacency(GeomLinesAdjacency const &amp;copy);</span>

<span class="s0">2335 12 operator new 0 4 3259 32 GeomLinesAdjacency::operator new 0 1 737 0</span>
<span class="s0">140</span>
<span class="s0">inline void *GeomLinesAdjacency::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomLinesAdjacency::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2336 15 operator delete 0 4 3259 35 GeomLinesAdjacency::operator delete 0 0 0</span>
<span class="s0">124</span>
<span class="s0">inline void GeomLinesAdjacency::operator delete(void *ptr);</span>
<span class="s0">inline void GeomLinesAdjacency::operator delete(void *, void *);</span>

<span class="s0">2337 12 validate_ptr 0 4 3259 32 GeomLinesAdjacency::validate_ptr 0 0 0</span>
<span class="s0">69</span>
<span class="s0">static inline bool GeomLinesAdjacency::validate_ptr(void const *ptr);</span>

<span class="s0">2338 14 get_class_type 0 4 3259 34 GeomLinesAdjacency::get_class_type 0 1 738 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle GeomLinesAdjacency::get_class_type(void);</span>

<span class="s0">2339 14 GeomLinestrips 0 260 3260 30 GeomLinestrips::GeomLinestrips 0 2 739 740 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">explicit GeomLinestrips::GeomLinestrips(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomLinestrips::GeomLinestrips(GeomLinestrips const &amp;copy);</span>

<span class="s0">2340 12 operator new 0 4 3260 28 GeomLinestrips::operator new 0 1 741 0</span>
<span class="s0">132</span>
<span class="s0">inline void *GeomLinestrips::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomLinestrips::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2341 15 operator delete 0 4 3260 31 GeomLinestrips::operator delete 0 0 0</span>
<span class="s0">116</span>
<span class="s0">inline void GeomLinestrips::operator delete(void *ptr);</span>
<span class="s0">inline void GeomLinestrips::operator delete(void *, void *);</span>

<span class="s0">2342 12 validate_ptr 0 4 3260 28 GeomLinestrips::validate_ptr 0 0 0</span>
<span class="s0">65</span>
<span class="s0">static inline bool GeomLinestrips::validate_ptr(void const *ptr);</span>

<span class="s0">2343 14 get_class_type 0 4 3260 30 GeomLinestrips::get_class_type 0 1 742 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle GeomLinestrips::get_class_type(void);</span>

<span class="s0">2344 23 GeomLinestripsAdjacency 0 260 3261 48 GeomLinestripsAdjacency::GeomLinestripsAdjacency 0 2 743 744 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">178</span>
<span class="s0">explicit GeomLinestripsAdjacency::GeomLinestripsAdjacency(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomLinestripsAdjacency::GeomLinestripsAdjacency(GeomLinestripsAdjacency const &amp;copy);</span>

<span class="s0">2345 12 operator new 0 4 3261 37 GeomLinestripsAdjacency::operator new 0 1 745 0</span>
<span class="s0">150</span>
<span class="s0">inline void *GeomLinestripsAdjacency::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomLinestripsAdjacency::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2346 15 operator delete 0 4 3261 40 GeomLinestripsAdjacency::operator delete 0 0 0</span>
<span class="s0">134</span>
<span class="s0">inline void GeomLinestripsAdjacency::operator delete(void *ptr);</span>
<span class="s0">inline void GeomLinestripsAdjacency::operator delete(void *, void *);</span>

<span class="s0">2347 12 validate_ptr 0 4 3261 37 GeomLinestripsAdjacency::validate_ptr 0 0 0</span>
<span class="s0">74</span>
<span class="s0">static inline bool GeomLinestripsAdjacency::validate_ptr(void const *ptr);</span>

<span class="s0">2348 14 get_class_type 0 4 3261 39 GeomLinestripsAdjacency::get_class_type 0 1 746 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle GeomLinestripsAdjacency::get_class_type(void);</span>

<span class="s0">2349 11 GeomPatches 0 260 3262 24 GeomPatches::GeomPatches 0 2 747 748 252</span>
<span class="s0">/**</span>
 <span class="s0">* The number of vertices per patch must be specified to the GeomPatches</span>
 <span class="s0">* constructor, and it may not be changed during the lifetime of the</span>
 <span class="s0">* GeomPatches object.  Create a new GeomPatches if you need to have a</span>
 <span class="s0">* different value.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">explicit GeomPatches::GeomPatches(int num_vertices_per_patch, GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomPatches::GeomPatches(GeomPatches const &amp;copy);</span>

<span class="s0">2350 12 operator new 0 4 3262 25 GeomPatches::operator new 0 1 749 0</span>
<span class="s0">126</span>
<span class="s0">inline void *GeomPatches::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomPatches::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2351 15 operator delete 0 4 3262 28 GeomPatches::operator delete 0 0 0</span>
<span class="s0">110</span>
<span class="s0">inline void GeomPatches::operator delete(void *ptr);</span>
<span class="s0">inline void GeomPatches::operator delete(void *, void *);</span>

<span class="s0">2352 12 validate_ptr 0 4 3262 25 GeomPatches::validate_ptr 0 0 0</span>
<span class="s0">62</span>
<span class="s0">static inline bool GeomPatches::validate_ptr(void const *ptr);</span>

<span class="s0">2353 14 get_class_type 0 4 3262 27 GeomPatches::get_class_type 0 1 750 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle GeomPatches::get_class_type(void);</span>

<span class="s0">2354 10 GeomPoints 0 260 3263 22 GeomPoints::GeomPoints 0 2 751 752 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">explicit GeomPoints::GeomPoints(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomPoints::GeomPoints(GeomPoints const &amp;copy);</span>

<span class="s0">2355 12 operator new 0 4 3263 24 GeomPoints::operator new 0 1 753 0</span>
<span class="s0">124</span>
<span class="s0">inline void *GeomPoints::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomPoints::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2356 15 operator delete 0 4 3263 27 GeomPoints::operator delete 0 0 0</span>
<span class="s0">108</span>
<span class="s0">inline void GeomPoints::operator delete(void *ptr);</span>
<span class="s0">inline void GeomPoints::operator delete(void *, void *);</span>

<span class="s0">2357 12 validate_ptr 0 4 3263 24 GeomPoints::validate_ptr 0 0 0</span>
<span class="s0">61</span>
<span class="s0">static inline bool GeomPoints::validate_ptr(void const *ptr);</span>

<span class="s0">2358 14 get_class_type 0 4 3263 26 GeomPoints::get_class_type 0 1 754 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle GeomPoints::get_class_type(void);</span>

<span class="s0">2359 13 GeomTriangles 0 260 3264 28 GeomTriangles::GeomTriangles 0 2 755 756 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">explicit GeomTriangles::GeomTriangles(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomTriangles::GeomTriangles(GeomTriangles const &amp;copy);</span>

<span class="s0">2360 12 operator new 0 4 3264 27 GeomTriangles::operator new 0 1 757 0</span>
<span class="s0">130</span>
<span class="s0">inline void *GeomTriangles::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomTriangles::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2361 15 operator delete 0 4 3264 30 GeomTriangles::operator delete 0 0 0</span>
<span class="s0">114</span>
<span class="s0">inline void GeomTriangles::operator delete(void *ptr);</span>
<span class="s0">inline void GeomTriangles::operator delete(void *, void *);</span>

<span class="s0">2362 12 validate_ptr 0 4 3264 27 GeomTriangles::validate_ptr 0 0 0</span>
<span class="s0">64</span>
<span class="s0">static inline bool GeomTriangles::validate_ptr(void const *ptr);</span>

<span class="s0">2363 14 get_class_type 0 4 3264 29 GeomTriangles::get_class_type 0 1 758 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle GeomTriangles::get_class_type(void);</span>

<span class="s0">2364 22 GeomTrianglesAdjacency 0 260 3265 46 GeomTrianglesAdjacency::GeomTrianglesAdjacency 0 2 759 760 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">173</span>
<span class="s0">explicit GeomTrianglesAdjacency::GeomTrianglesAdjacency(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomTrianglesAdjacency::GeomTrianglesAdjacency(GeomTrianglesAdjacency const &amp;copy);</span>

<span class="s0">2365 12 operator new 0 4 3265 36 GeomTrianglesAdjacency::operator new 0 1 761 0</span>
<span class="s0">148</span>
<span class="s0">inline void *GeomTrianglesAdjacency::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomTrianglesAdjacency::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2366 15 operator delete 0 4 3265 39 GeomTrianglesAdjacency::operator delete 0 0 0</span>
<span class="s0">132</span>
<span class="s0">inline void GeomTrianglesAdjacency::operator delete(void *ptr);</span>
<span class="s0">inline void GeomTrianglesAdjacency::operator delete(void *, void *);</span>

<span class="s0">2367 12 validate_ptr 0 4 3265 36 GeomTrianglesAdjacency::validate_ptr 0 0 0</span>
<span class="s0">73</span>
<span class="s0">static inline bool GeomTrianglesAdjacency::validate_ptr(void const *ptr);</span>

<span class="s0">2368 14 get_class_type 0 4 3265 38 GeomTrianglesAdjacency::get_class_type 0 1 762 0</span>
<span class="s0">63</span>
<span class="s0">static TypeHandle GeomTrianglesAdjacency::get_class_type(void);</span>

<span class="s0">2369 11 GeomTrifans 0 260 3266 24 GeomTrifans::GeomTrifans 0 2 763 764 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">explicit GeomTrifans::GeomTrifans(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomTrifans::GeomTrifans(GeomTrifans const &amp;copy);</span>

<span class="s0">2370 12 operator new 0 4 3266 25 GeomTrifans::operator new 0 1 765 0</span>
<span class="s0">126</span>
<span class="s0">inline void *GeomTrifans::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomTrifans::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2371 15 operator delete 0 4 3266 28 GeomTrifans::operator delete 0 0 0</span>
<span class="s0">110</span>
<span class="s0">inline void GeomTrifans::operator delete(void *ptr);</span>
<span class="s0">inline void GeomTrifans::operator delete(void *, void *);</span>

<span class="s0">2372 12 validate_ptr 0 4 3266 25 GeomTrifans::validate_ptr 0 0 0</span>
<span class="s0">62</span>
<span class="s0">static inline bool GeomTrifans::validate_ptr(void const *ptr);</span>

<span class="s0">2373 14 get_class_type 0 4 3266 27 GeomTrifans::get_class_type 0 1 766 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle GeomTrifans::get_class_type(void);</span>

<span class="s0">2374 13 GeomTristrips 0 260 3267 28 GeomTristrips::GeomTristrips 0 2 767 768 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">explicit GeomTristrips::GeomTristrips(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomTristrips::GeomTristrips(GeomTristrips const &amp;copy);</span>

<span class="s0">2375 12 operator new 0 4 3267 27 GeomTristrips::operator new 0 1 769 0</span>
<span class="s0">130</span>
<span class="s0">inline void *GeomTristrips::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomTristrips::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2376 15 operator delete 0 4 3267 30 GeomTristrips::operator delete 0 0 0</span>
<span class="s0">114</span>
<span class="s0">inline void GeomTristrips::operator delete(void *ptr);</span>
<span class="s0">inline void GeomTristrips::operator delete(void *, void *);</span>

<span class="s0">2377 12 validate_ptr 0 4 3267 27 GeomTristrips::validate_ptr 0 0 0</span>
<span class="s0">64</span>
<span class="s0">static inline bool GeomTristrips::validate_ptr(void const *ptr);</span>

<span class="s0">2378 14 get_class_type 0 4 3267 29 GeomTristrips::get_class_type 0 1 770 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle GeomTristrips::get_class_type(void);</span>

<span class="s0">2379 22 GeomTristripsAdjacency 0 260 3268 46 GeomTristripsAdjacency::GeomTristripsAdjacency 0 2 771 772 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">173</span>
<span class="s0">explicit GeomTristripsAdjacency::GeomTristripsAdjacency(GeomEnums::UsageHint usage_hint);</span>
<span class="s0">GeomTristripsAdjacency::GeomTristripsAdjacency(GeomTristripsAdjacency const &amp;copy);</span>

<span class="s0">2380 12 operator new 0 4 3268 36 GeomTristripsAdjacency::operator new 0 1 773 0</span>
<span class="s0">148</span>
<span class="s0">inline void *GeomTristripsAdjacency::operator new(std::size_t size);</span>
<span class="s0">inline void *GeomTristripsAdjacency::operator new(std::size_t size, void *ptr);</span>

<span class="s0">2381 15 operator delete 0 4 3268 39 GeomTristripsAdjacency::operator delete 0 0 0</span>
<span class="s0">132</span>
<span class="s0">inline void GeomTristripsAdjacency::operator delete(void *ptr);</span>
<span class="s0">inline void GeomTristripsAdjacency::operator delete(void *, void *);</span>

<span class="s0">2382 12 validate_ptr 0 4 3268 36 GeomTristripsAdjacency::validate_ptr 0 0 0</span>
<span class="s0">73</span>
<span class="s0">static inline bool GeomTristripsAdjacency::validate_ptr(void const *ptr);</span>

<span class="s0">2383 14 get_class_type 0 4 3268 38 GeomTristripsAdjacency::get_class_type 0 1 774 0</span>
<span class="s0">63</span>
<span class="s0">static TypeHandle GeomTristripsAdjacency::get_class_type(void);</span>

<span class="s0">2384 16 GeomVertexReader 0 260 3269 34 GeomVertexReader::GeomVertexReader 0 6 775 776 777 778 779 780 802</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an invalid GeomVertexReader.  You must use the assignment</span>
 <span class="s0">* operator to assign a valid GeomVertexReader to this object before you can</span>
 <span class="s0">* use it.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated data</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated data</span>
 <span class="s0">* object.  This flavor creates the reader specifically to process the named</span>
 <span class="s0">* data type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated data</span>
 <span class="s0">* object.  This flavor creates the reader specifically to process the named</span>
 <span class="s0">* data type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">745</span>
<span class="s0">inline GeomVertexReader::GeomVertexReader(Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, int column, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexReader::GeomVertexReader(GeomVertexReader const &amp;copy);</span>

<span class="s0">2385 10 operator = 0 4 3269 28 GeomVertexReader::operator = 0 1 781 0</span>
<span class="s0">71</span>
<span class="s0">inline void GeomVertexReader::operator =(GeomVertexReader const &amp;copy);</span>

<span class="s0">2386 17 ~GeomVertexReader 0 516 3269 35 GeomVertexReader::~GeomVertexReader 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline GeomVertexReader::~GeomVertexReader(void);</span>

<span class="s0">2387 15 get_vertex_data 0 4 3269 33 GeomVertexReader::get_vertex_data 0 1 782 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the vertex data object that the reader is processing.  This may</span>
 <span class="s0">* return NULL if the reader was constructed with just an array pointer.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline GeomVertexData const *GeomVertexReader::get_vertex_data(void) const;</span>

<span class="s0">2388 14 get_array_data 0 4 3269 32 GeomVertexReader::get_array_data 0 1 783 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the particular array object that the reader is currently</span>
 <span class="s0">* processing.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline GeomVertexArrayData const *GeomVertexReader::get_array_data(void) const;</span>

<span class="s0">2389 16 get_array_handle 0 4 3269 34 GeomVertexReader::get_array_handle 0 1 784 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the read handle to the array object that the read is currently</span>
 <span class="s0">* processing.  This low-level call should be used with caution.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline GeomVertexArrayDataHandle const *GeomVertexReader::get_array_handle(void) const;</span>

<span class="s0">2390 10 get_stride 0 4 3269 28 GeomVertexReader::get_stride 0 1 785 197</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the per-row stride (bytes between consecutive rows) of the</span>
 <span class="s0">* underlying vertex array.  This low-level information is normally not needed</span>
 <span class="s0">* to use the GeomVertexReader directly.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline std::size_t GeomVertexReader::get_stride(void) const;</span>

<span class="s0">2391 18 get_current_thread 0 4 3269 36 GeomVertexReader::get_current_thread 0 1 786 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Thread pointer of the currently-executing thread, as passed to</span>
 <span class="s0">* the constructor of this object.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline Thread *GeomVertexReader::get_current_thread(void) const;</span>

<span class="s0">2392 9 set_force 0 4 3269 27 GeomVertexReader::set_force 0 1 787 563</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the value of the force flag.  When this is true (the default), vertex</span>
 <span class="s0">* data will be paged in from disk if necessary.  When this is false, the</span>
 <span class="s0">* GeomVertexData will simply return a failure code when attempting to read</span>
 <span class="s0">* vertex data that is not resident (but will put it on the queue to become</span>
 <span class="s0">* resident later).</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, vertex data is always resident, so this will not be an issue.  It</span>
 <span class="s0">* is only possible for vertex data to be nonresident if you have enabled</span>
 <span class="s0">* vertex paging via the GeomVertexArrayData and VertexDataPage interfaces.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void GeomVertexReader::set_force(bool force);</span>

<span class="s0">2393 9 get_force 0 4 3269 27 GeomVertexReader::get_force 0 1 788 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value of the force flag.  See set_force().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool GeomVertexReader::get_force(void) const;</span>

<span class="s0">2394 10 set_column 0 4 3269 28 GeomVertexReader::set_column 0 3 789 790 791 981</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the reader to use the nth data type of the GeomVertexFormat,</span>
 <span class="s0">* numbering from 0.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the read row number to the start row (the same value</span>
 <span class="s0">* passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up the reader to use the data type with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the read row number to the start row (the same value</span>
 <span class="s0">* passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up the reader to use the indicated column description on the given</span>
 <span class="s0">* array.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the current read row number to the start row (the same</span>
 <span class="s0">* value passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">196</span>
<span class="s0">inline bool GeomVertexReader::set_column(int column);</span>
<span class="s0">inline bool GeomVertexReader::set_column(CPT_InternalName name);</span>
<span class="s0">bool GeomVertexReader::set_column(int array, GeomVertexColumn const *column);</span>

<span class="s0">2395 5 clear 0 4 3269 23 GeomVertexReader::clear 0 1 792 60</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the GeomVertexReader to the initial state.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void GeomVertexReader::clear(void);</span>

<span class="s0">2396 10 has_column 0 4 3269 28 GeomVertexReader::has_column 0 1 793 183</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a valid data type has been successfully set, or false if</span>
 <span class="s0">* the data type does not exist (or if get_force() is false and the vertex</span>
 <span class="s0">* data is nonresident).</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool GeomVertexReader::has_column(void) const;</span>

<span class="s0">2397 9 get_array 0 4 3269 27 GeomVertexReader::get_array 0 1 794 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the array index containing the data type that the reader is working</span>
 <span class="s0">* on.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int GeomVertexReader::get_array(void) const;</span>

<span class="s0">2398 10 get_column 0 4 3269 28 GeomVertexReader::get_column 0 1 795 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the description of the data type that the reader is working on.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline GeomVertexColumn const *GeomVertexReader::get_column(void) const;</span>

<span class="s0">2399 14 set_row_unsafe 0 4 3269 32 GeomVertexReader::set_row_unsafe 0 1 796 344</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the start row to the indicated value, without internal checks.  This</span>
 <span class="s0">* is the same as set_row(), but it does not check for the possibility that</span>
 <span class="s0">* the array has been reallocated internally for some reason; use only when</span>
 <span class="s0">* you are confident that the array is unchanged and you really need every bit</span>
 <span class="s0">* of available performance.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void GeomVertexReader::set_row_unsafe(int row);</span>

<span class="s0">2400 7 set_row 0 4 3269 25 GeomVertexReader::set_row 0 1 797 260</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the start row to the indicated value.  The reader will begin reading</span>
 <span class="s0">* from the indicated row; each subsequent get_data*() call will return the</span>
 <span class="s0">* data from the subsequent row.  If set_column() is called, the reader will</span>
 <span class="s0">* return to this row.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void GeomVertexReader::set_row(int row);</span>

<span class="s0">2401 13 get_start_row 0 4 3269 31 GeomVertexReader::get_start_row 0 1 798 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the row index at which the reader started.  It will return to this</span>
 <span class="s0">* row if you reset the current column.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int GeomVertexReader::get_start_row(void) const;</span>

<span class="s0">2402 12 get_read_row 0 4 3269 30 GeomVertexReader::get_read_row 0 1 799 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the row index from which the data will be retrieved by the next</span>
 <span class="s0">* call to get_data*().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int GeomVertexReader::get_read_row(void) const;</span>

<span class="s0">2403 9 is_at_end 0 4 3269 27 GeomVertexReader::is_at_end 0 1 800 179</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the reader is currently at the end of the list of vertices,</span>
 <span class="s0">* false otherwise.  If this is true, another call to get_data*() will result</span>
 <span class="s0">* in a crash.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool GeomVertexReader::is_at_end(void) const;</span>

<span class="s0">2404 10 get_data1f 0 4 3269 28 GeomVertexReader::get_data1f 0 1 801 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 1-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline float GeomVertexReader::get_data1f(void);</span>

<span class="s0">2405 10 get_data2f 0 4 3269 28 GeomVertexReader::get_data2f 0 1 802 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 2-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase2f const &amp;GeomVertexReader::get_data2f(void);</span>

<span class="s0">2406 10 get_data3f 0 4 3269 28 GeomVertexReader::get_data3f 0 1 803 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 3-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase3f const &amp;GeomVertexReader::get_data3f(void);</span>

<span class="s0">2407 10 get_data4f 0 4 3269 28 GeomVertexReader::get_data4f 0 1 804 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 4-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase4f const &amp;GeomVertexReader::get_data4f(void);</span>

<span class="s0">2408 12 get_matrix3f 0 4 3269 30 GeomVertexReader::get_matrix3f 0 1 805 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 3-by-3 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LMatrix3f GeomVertexReader::get_matrix3f(void);</span>

<span class="s0">2409 12 get_matrix4f 0 4 3269 30 GeomVertexReader::get_matrix4f 0 1 806 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 4-by-4 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LMatrix4f GeomVertexReader::get_matrix4f(void);</span>

<span class="s0">2410 10 get_data1d 0 4 3269 28 GeomVertexReader::get_data1d 0 1 807 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 1-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline double GeomVertexReader::get_data1d(void);</span>

<span class="s0">2411 10 get_data2d 0 4 3269 28 GeomVertexReader::get_data2d 0 1 808 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 2-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase2d const &amp;GeomVertexReader::get_data2d(void);</span>

<span class="s0">2412 10 get_data3d 0 4 3269 28 GeomVertexReader::get_data3d 0 1 809 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 3-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase3d const &amp;GeomVertexReader::get_data3d(void);</span>

<span class="s0">2413 10 get_data4d 0 4 3269 28 GeomVertexReader::get_data4d 0 1 810 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 4-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase4d const &amp;GeomVertexReader::get_data4d(void);</span>

<span class="s0">2414 12 get_matrix3d 0 4 3269 30 GeomVertexReader::get_matrix3d 0 1 811 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 3-by-3 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LMatrix3d GeomVertexReader::get_matrix3d(void);</span>

<span class="s0">2415 12 get_matrix4d 0 4 3269 30 GeomVertexReader::get_matrix4d 0 1 812 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 4-by-4 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LMatrix4d GeomVertexReader::get_matrix4d(void);</span>

<span class="s0">2416 9 get_data1 0 4 3269 27 GeomVertexReader::get_data1 0 1 813 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 1-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat GeomVertexReader::get_data1(void);</span>

<span class="s0">2417 9 get_data2 0 4 3269 27 GeomVertexReader::get_data2 0 1 814 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 2-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LVecBase2 const &amp;GeomVertexReader::get_data2(void);</span>

<span class="s0">2418 9 get_data3 0 4 3269 27 GeomVertexReader::get_data3 0 1 815 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 3-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LVecBase3 const &amp;GeomVertexReader::get_data3(void);</span>

<span class="s0">2419 9 get_data4 0 4 3269 27 GeomVertexReader::get_data4 0 1 816 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 4-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LVecBase4 const &amp;GeomVertexReader::get_data4(void);</span>

<span class="s0">2420 11 get_matrix3 0 4 3269 29 GeomVertexReader::get_matrix3 0 1 817 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 3-by-3 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LMatrix3 GeomVertexReader::get_matrix3(void);</span>

<span class="s0">2421 11 get_matrix4 0 4 3269 29 GeomVertexReader::get_matrix4 0 1 818 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 4-by-4 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LMatrix4 GeomVertexReader::get_matrix4(void);</span>

<span class="s0">2422 10 get_data1i 0 4 3269 28 GeomVertexReader::get_data1i 0 1 819 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 1-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline int GeomVertexReader::get_data1i(void);</span>

<span class="s0">2423 10 get_data2i 0 4 3269 28 GeomVertexReader::get_data2i 0 1 820 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 2-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase2i const &amp;GeomVertexReader::get_data2i(void);</span>

<span class="s0">2424 10 get_data3i 0 4 3269 28 GeomVertexReader::get_data3i 0 1 821 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 3-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase3i const &amp;GeomVertexReader::get_data3i(void);</span>

<span class="s0">2425 10 get_data4i 0 4 3269 28 GeomVertexReader::get_data4i 0 1 822 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 4-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase4i const &amp;GeomVertexReader::get_data4i(void);</span>

<span class="s0">2426 6 output 0 4 3269 24 GeomVertexReader::output 0 1 823 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void GeomVertexReader::output(std::ostream &amp;out) const;</span>

<span class="s0">2427 16 GeomVertexWriter 0 260 3270 34 GeomVertexWriter::GeomVertexWriter 0 6 824 825 826 827 828 829 802</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an invalid GeomVertexWriter.  You must use the assignment</span>
 <span class="s0">* operator to assign a valid GeomVertexWriter to this object before you can</span>
 <span class="s0">* use it.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated data</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated data</span>
 <span class="s0">* object.  This flavor creates the writer specifically to process the named</span>
 <span class="s0">* data type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated data</span>
 <span class="s0">* object.  This flavor creates the writer specifically to process the named</span>
 <span class="s0">* data type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">721</span>
<span class="s0">inline GeomVertexWriter::GeomVertexWriter(Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexWriter::GeomVertexWriter(GeomVertexWriter const &amp;copy);</span>

<span class="s0">2428 10 operator = 0 4 3270 28 GeomVertexWriter::operator = 0 1 830 0</span>
<span class="s0">71</span>
<span class="s0">inline void GeomVertexWriter::operator =(GeomVertexWriter const &amp;copy);</span>

<span class="s0">2429 17 ~GeomVertexWriter 0 516 3270 35 GeomVertexWriter::~GeomVertexWriter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline GeomVertexWriter::~GeomVertexWriter(void);</span>

<span class="s0">2430 15 get_vertex_data 0 4 3270 33 GeomVertexWriter::get_vertex_data 0 1 831 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the vertex data object that the writer is processing.  This may</span>
 <span class="s0">* return NULL if the writer was constructed with just an array pointer.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline GeomVertexData *GeomVertexWriter::get_vertex_data(void) const;</span>

<span class="s0">2431 14 get_array_data 0 4 3270 32 GeomVertexWriter::get_array_data 0 1 832 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the particular array object that the writer is currently</span>
 <span class="s0">* processing.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline GeomVertexArrayData *GeomVertexWriter::get_array_data(void) const;</span>

<span class="s0">2432 16 get_array_handle 0 4 3270 34 GeomVertexWriter::get_array_handle 0 1 833 238</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the write handle to the array object that the writer is currently</span>
 <span class="s0">* processing.  This low-level call should be used with caution; be careful</span>
 <span class="s0">* with modifying the data in the handle out from under the GeomVertexWriter.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline GeomVertexArrayDataHandle *GeomVertexWriter::get_array_handle(void) const;</span>

<span class="s0">2433 10 get_stride 0 4 3270 28 GeomVertexWriter::get_stride 0 1 834 197</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the per-row stride (bytes between consecutive rows) of the</span>
 <span class="s0">* underlying vertex array.  This low-level information is normally not needed</span>
 <span class="s0">* to use the GeomVertexWriter directly.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline std::size_t GeomVertexWriter::get_stride(void) const;</span>

<span class="s0">2434 18 get_current_thread 0 4 3270 36 GeomVertexWriter::get_current_thread 0 1 835 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Thread pointer of the currently-executing thread, as passed to</span>
 <span class="s0">* the constructor of this object.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline Thread *GeomVertexWriter::get_current_thread(void) const;</span>

<span class="s0">2435 10 set_column 0 4 3270 28 GeomVertexWriter::set_column 0 3 836 837 838 977</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the writer to use the nth data type of the GeomVertexFormat,</span>
 <span class="s0">* numbering from 0.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the write row number to the start row (the same value</span>
 <span class="s0">* passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up the writer to use the data type with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the write number to the start row (the same value passed</span>
 <span class="s0">* to a previous call to set_row(), or 0 if set_row() was never called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up the writer to use the indicated column description on the given</span>
 <span class="s0">* array.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the current write row number to the start row (the same</span>
 <span class="s0">* value passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">196</span>
<span class="s0">inline bool GeomVertexWriter::set_column(int column);</span>
<span class="s0">inline bool GeomVertexWriter::set_column(CPT_InternalName name);</span>
<span class="s0">bool GeomVertexWriter::set_column(int array, GeomVertexColumn const *column);</span>

<span class="s0">2436 5 clear 0 4 3270 23 GeomVertexWriter::clear 0 1 839 60</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the GeomVertexWriter to the initial state.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void GeomVertexWriter::clear(void);</span>

<span class="s0">2437 16 reserve_num_rows 0 4 3270 34 GeomVertexWriter::reserve_num_rows 0 1 840 297</span>
<span class="s0">/**</span>
 <span class="s0">* This ensures that enough memory space for num_rows is allocated, so that</span>
 <span class="s0">* you may add up to num_rows rows without causing a new memory allocation.</span>
 <span class="s0">* This is a performance optimization only; it is especially useful when you</span>
 <span class="s0">* know the number of rows you will be adding ahead of time.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">bool GeomVertexWriter::reserve_num_rows(int num_rows);</span>

<span class="s0">2438 10 has_column 0 4 3270 28 GeomVertexWriter::has_column 0 1 841 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a valid data type has been successfully set, or false if</span>
 <span class="s0">* the data type does not exist.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool GeomVertexWriter::has_column(void) const;</span>

<span class="s0">2439 9 get_array 0 4 3270 27 GeomVertexWriter::get_array 0 1 842 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the array index containing the data type that the writer is working</span>
 <span class="s0">* on.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int GeomVertexWriter::get_array(void) const;</span>

<span class="s0">2440 10 get_column 0 4 3270 28 GeomVertexWriter::get_column 0 1 843 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the description of the data type that the writer is working on.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline GeomVertexColumn const *GeomVertexWriter::get_column(void) const;</span>

<span class="s0">2441 14 set_row_unsafe 0 4 3270 32 GeomVertexWriter::set_row_unsafe 0 1 844 344</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the start row to the indicated value, without internal checks.  This</span>
 <span class="s0">* is the same as set_row(), but it does not check for the possibility that</span>
 <span class="s0">* the array has been reallocated internally for some reason; use only when</span>
 <span class="s0">* you are confident that the array is unchanged and you really need every bit</span>
 <span class="s0">* of available performance.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void GeomVertexWriter::set_row_unsafe(int row);</span>

<span class="s0">2442 7 set_row 0 4 3270 25 GeomVertexWriter::set_row 0 1 845 257</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the start row to the indicated value.  The writer will begin writing</span>
 <span class="s0">* to the indicated row; each subsequent set_data*() call will store the data</span>
 <span class="s0">* into the subsequent row.  If set_column() is called, the writer will return</span>
 <span class="s0">* to this row.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void GeomVertexWriter::set_row(int row);</span>

<span class="s0">2443 13 get_start_row 0 4 3270 31 GeomVertexWriter::get_start_row 0 1 846 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the row index at which the writer started.  It will return to this</span>
 <span class="s0">* row if you reset the current column.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int GeomVertexWriter::get_start_row(void) const;</span>

<span class="s0">2444 13 get_write_row 0 4 3270 31 GeomVertexWriter::get_write_row 0 1 847 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the row index to which the data will be written at the next call to</span>
 <span class="s0">* set_data*() or add_data*().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int GeomVertexWriter::get_write_row(void) const;</span>

<span class="s0">2445 9 is_at_end 0 4 3270 27 GeomVertexWriter::is_at_end 0 1 848 231</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the writer is currently at the end of the list of vertices,</span>
 <span class="s0">* false otherwise.  If this is true, another call to set_data*() will result</span>
 <span class="s0">* in a crash, but another call to add_data*() will add a new row.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool GeomVertexWriter::is_at_end(void) const;</span>

<span class="s0">2446 10 set_data1f 0 4 3270 28 GeomVertexWriter::set_data1f 0 1 849 167</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void GeomVertexWriter::set_data1f(float data);</span>

<span class="s0">2447 10 set_data2f 0 4 3270 28 GeomVertexWriter::set_data2f 0 2 850 851 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">inline void GeomVertexWriter::set_data2f(float x, float y);</span>
<span class="s0">inline void GeomVertexWriter::set_data2f(LVecBase2f const &amp;data);</span>

<span class="s0">2448 10 set_data3f 0 4 3270 28 GeomVertexWriter::set_data3f 0 2 852 853 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">inline void GeomVertexWriter::set_data3f(float x, float y, float z);</span>
<span class="s0">inline void GeomVertexWriter::set_data3f(LVecBase3f const &amp;data);</span>

<span class="s0">2449 10 set_data4f 0 4 3270 28 GeomVertexWriter::set_data4f 0 2 854 855 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void GeomVertexWriter::set_data4f(float x, float y, float z, float w);</span>
<span class="s0">inline void GeomVertexWriter::set_data4f(LVecBase4f const &amp;data);</span>

<span class="s0">2450 12 set_matrix3f 0 4 3270 30 GeomVertexWriter::set_matrix3f 0 1 856 219</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void GeomVertexWriter::set_matrix3f(LMatrix3f const &amp;mat);</span>

<span class="s0">2451 12 set_matrix4f 0 4 3270 30 GeomVertexWriter::set_matrix4f 0 1 857 219</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void GeomVertexWriter::set_matrix4f(LMatrix4f const &amp;mat);</span>

<span class="s0">2452 10 set_data1d 0 4 3270 28 GeomVertexWriter::set_data1d 0 1 858 167</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void GeomVertexWriter::set_data1d(double data);</span>

<span class="s0">2453 10 set_data2d 0 4 3270 28 GeomVertexWriter::set_data2d 0 2 859 860 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">127</span>
<span class="s0">inline void GeomVertexWriter::set_data2d(double x, double y);</span>
<span class="s0">inline void GeomVertexWriter::set_data2d(LVecBase2d const &amp;data);</span>

<span class="s0">2454 10 set_data3d 0 4 3270 28 GeomVertexWriter::set_data3d 0 2 861 862 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">137</span>
<span class="s0">inline void GeomVertexWriter::set_data3d(double x, double y, double z);</span>
<span class="s0">inline void GeomVertexWriter::set_data3d(LVecBase3d const &amp;data);</span>

<span class="s0">2455 10 set_data4d 0 4 3270 28 GeomVertexWriter::set_data4d 0 2 863 864 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">inline void GeomVertexWriter::set_data4d(double x, double y, double z, double w);</span>
<span class="s0">inline void GeomVertexWriter::set_data4d(LVecBase4d const &amp;data);</span>

<span class="s0">2456 12 set_matrix3d 0 4 3270 30 GeomVertexWriter::set_matrix3d 0 1 865 219</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void GeomVertexWriter::set_matrix3d(LMatrix3d const &amp;mat);</span>

<span class="s0">2457 12 set_matrix4d 0 4 3270 30 GeomVertexWriter::set_matrix4d 0 1 866 219</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void GeomVertexWriter::set_matrix4d(LMatrix4d const &amp;mat);</span>

<span class="s0">2458 9 set_data1 0 4 3270 27 GeomVertexWriter::set_data1 0 1 867 167</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void GeomVertexWriter::set_data1(PN_stdfloat data);</span>

<span class="s0">2459 9 set_data2 0 4 3270 27 GeomVertexWriter::set_data2 0 2 868 869 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">inline void GeomVertexWriter::set_data2(PN_stdfloat x, PN_stdfloat y);</span>
<span class="s0">inline void GeomVertexWriter::set_data2(LVecBase2 const &amp;data);</span>

<span class="s0">2460 9 set_data3 0 4 3270 27 GeomVertexWriter::set_data3 0 2 870 871 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">inline void GeomVertexWriter::set_data3(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline void GeomVertexWriter::set_data3(LVecBase3 const &amp;data);</span>

<span class="s0">2461 9 set_data4 0 4 3270 27 GeomVertexWriter::set_data4 0 2 872 873 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">164</span>
<span class="s0">inline void GeomVertexWriter::set_data4(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat w);</span>
<span class="s0">inline void GeomVertexWriter::set_data4(LVecBase4 const &amp;data);</span>

<span class="s0">2462 11 set_matrix3 0 4 3270 29 GeomVertexWriter::set_matrix3 0 1 874 219</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void GeomVertexWriter::set_matrix3(LMatrix3 const &amp;mat);</span>

<span class="s0">2463 11 set_matrix4 0 4 3270 29 GeomVertexWriter::set_matrix4 0 1 875 219</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void GeomVertexWriter::set_matrix4(LMatrix4 const &amp;mat);</span>

<span class="s0">2464 10 set_data1i 0 4 3270 28 GeomVertexWriter::set_data1i 0 1 876 167</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void GeomVertexWriter::set_data1i(int data);</span>

<span class="s0">2465 10 set_data2i 0 4 3270 28 GeomVertexWriter::set_data2i 0 2 877 878 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">inline void GeomVertexWriter::set_data2i(int a, int b);</span>
<span class="s0">inline void GeomVertexWriter::set_data2i(LVecBase2i const &amp;data);</span>

<span class="s0">2466 10 set_data3i 0 4 3270 28 GeomVertexWriter::set_data3i 0 2 879 880 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">inline void GeomVertexWriter::set_data3i(int a, int b, int c);</span>
<span class="s0">inline void GeomVertexWriter::set_data3i(LVecBase3i const &amp;data);</span>

<span class="s0">2467 10 set_data4i 0 4 3270 28 GeomVertexWriter::set_data4i 0 2 881 882 336</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">inline void GeomVertexWriter::set_data4i(int a, int b, int c, int d);</span>
<span class="s0">inline void GeomVertexWriter::set_data4i(LVecBase4i const &amp;data);</span>

<span class="s0">2468 10 add_data1f 0 4 3270 28 GeomVertexWriter::add_data1f 0 1 883 191</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void GeomVertexWriter::add_data1f(float data);</span>

<span class="s0">2469 10 add_data2f 0 4 3270 28 GeomVertexWriter::add_data2f 0 2 884 885 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">inline void GeomVertexWriter::add_data2f(float x, float y);</span>
<span class="s0">inline void GeomVertexWriter::add_data2f(LVecBase2f const &amp;data);</span>

<span class="s0">2470 10 add_data3f 0 4 3270 28 GeomVertexWriter::add_data3f 0 2 886 887 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">inline void GeomVertexWriter::add_data3f(float x, float y, float z);</span>
<span class="s0">inline void GeomVertexWriter::add_data3f(LVecBase3f const &amp;data);</span>

<span class="s0">2471 10 add_data4f 0 4 3270 28 GeomVertexWriter::add_data4f 0 2 888 889 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void GeomVertexWriter::add_data4f(float x, float y, float z, float w);</span>
<span class="s0">inline void GeomVertexWriter::add_data4f(LVecBase4f const &amp;data);</span>

<span class="s0">2472 12 add_matrix3f 0 4 3270 30 GeomVertexWriter::add_matrix3f 0 1 890 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void GeomVertexWriter::add_matrix3f(LMatrix3f const &amp;mat);</span>

<span class="s0">2473 12 add_matrix4f 0 4 3270 30 GeomVertexWriter::add_matrix4f 0 1 891 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void GeomVertexWriter::add_matrix4f(LMatrix4f const &amp;mat);</span>

<span class="s0">2474 10 add_data1d 0 4 3270 28 GeomVertexWriter::add_data1d 0 1 892 191</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void GeomVertexWriter::add_data1d(double data);</span>

<span class="s0">2475 10 add_data2d 0 4 3270 28 GeomVertexWriter::add_data2d 0 2 893 894 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">127</span>
<span class="s0">inline void GeomVertexWriter::add_data2d(double x, double y);</span>
<span class="s0">inline void GeomVertexWriter::add_data2d(LVecBase2d const &amp;data);</span>

<span class="s0">2476 10 add_data3d 0 4 3270 28 GeomVertexWriter::add_data3d 0 2 895 896 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">137</span>
<span class="s0">inline void GeomVertexWriter::add_data3d(double x, double y, double z);</span>
<span class="s0">inline void GeomVertexWriter::add_data3d(LVecBase3d const &amp;data);</span>

<span class="s0">2477 10 add_data4d 0 4 3270 28 GeomVertexWriter::add_data4d 0 2 897 898 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">inline void GeomVertexWriter::add_data4d(double x, double y, double z, double w);</span>
<span class="s0">inline void GeomVertexWriter::add_data4d(LVecBase4d const &amp;data);</span>

<span class="s0">2478 12 add_matrix3d 0 4 3270 30 GeomVertexWriter::add_matrix3d 0 1 899 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void GeomVertexWriter::add_matrix3d(LMatrix3d const &amp;mat);</span>

<span class="s0">2479 12 add_matrix4d 0 4 3270 30 GeomVertexWriter::add_matrix4d 0 1 900 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void GeomVertexWriter::add_matrix4d(LMatrix4d const &amp;mat);</span>

<span class="s0">2480 9 add_data1 0 4 3270 27 GeomVertexWriter::add_data1 0 1 901 191</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void GeomVertexWriter::add_data1(PN_stdfloat data);</span>

<span class="s0">2481 9 add_data2 0 4 3270 27 GeomVertexWriter::add_data2 0 2 902 903 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">inline void GeomVertexWriter::add_data2(PN_stdfloat x, PN_stdfloat y);</span>
<span class="s0">inline void GeomVertexWriter::add_data2(LVecBase2 const &amp;data);</span>

<span class="s0">2482 9 add_data3 0 4 3270 27 GeomVertexWriter::add_data3 0 2 904 905 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">inline void GeomVertexWriter::add_data3(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline void GeomVertexWriter::add_data3(LVecBase3 const &amp;data);</span>

<span class="s0">2483 9 add_data4 0 4 3270 27 GeomVertexWriter::add_data4 0 2 906 907 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">164</span>
<span class="s0">inline void GeomVertexWriter::add_data4(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat w);</span>
<span class="s0">inline void GeomVertexWriter::add_data4(LVecBase4 const &amp;data);</span>

<span class="s0">2484 11 add_matrix3 0 4 3270 29 GeomVertexWriter::add_matrix3 0 1 908 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void GeomVertexWriter::add_matrix3(LMatrix3 const &amp;mat);</span>

<span class="s0">2485 11 add_matrix4 0 4 3270 29 GeomVertexWriter::add_matrix4 0 1 909 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void GeomVertexWriter::add_matrix4(LMatrix4 const &amp;mat);</span>

<span class="s0">2486 10 add_data1i 0 4 3270 28 GeomVertexWriter::add_data1i 0 1 910 191</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void GeomVertexWriter::add_data1i(int data);</span>

<span class="s0">2487 10 add_data2i 0 4 3270 28 GeomVertexWriter::add_data2i 0 2 911 912 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">inline void GeomVertexWriter::add_data2i(int a, int b);</span>
<span class="s0">inline void GeomVertexWriter::add_data2i(LVecBase2i const &amp;data);</span>

<span class="s0">2488 10 add_data3i 0 4 3270 28 GeomVertexWriter::add_data3i 0 2 913 914 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">inline void GeomVertexWriter::add_data3i(int a, int b, int c);</span>
<span class="s0">inline void GeomVertexWriter::add_data3i(LVecBase3i const &amp;data);</span>

<span class="s0">2489 10 add_data4i 0 4 3270 28 GeomVertexWriter::add_data4i 0 2 915 916 384</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">inline void GeomVertexWriter::add_data4i(int a, int b, int c, int d);</span>
<span class="s0">inline void GeomVertexWriter::add_data4i(LVecBase4i const &amp;data);</span>

<span class="s0">2490 6 output 0 4 3270 24 GeomVertexWriter::output 0 1 917 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void GeomVertexWriter::output(std::ostream &amp;out) const;</span>

<span class="s0">2491 26 upcast_to_GeomVertexWriter 0 12 3271 46 GeomVertexRewriter::upcast_to_GeomVertexWriter 0 1 942 50</span>
<span class="s0">upcast from GeomVertexRewriter to GeomVertexWriter</span>
<span class="s0">71</span>
<span class="s0">GeomVertexWriter *GeomVertexRewriter::upcast_to_GeomVertexWriter(void);</span>

<span class="s0">2492 30 downcast_to_GeomVertexRewriter 0 12 3270 48 GeomVertexWriter::downcast_to_GeomVertexRewriter 0 0 52</span>
<span class="s0">downcast from GeomVertexWriter to GeomVertexRewriter</span>
<span class="s0">75</span>
<span class="s0">GeomVertexRewriter *GeomVertexWriter::downcast_to_GeomVertexRewriter(void);</span>

<span class="s0">2493 26 upcast_to_GeomVertexReader 0 12 3271 46 GeomVertexRewriter::upcast_to_GeomVertexReader 0 1 943 50</span>
<span class="s0">upcast from GeomVertexRewriter to GeomVertexReader</span>
<span class="s0">71</span>
<span class="s0">GeomVertexReader *GeomVertexRewriter::upcast_to_GeomVertexReader(void);</span>

<span class="s0">2494 30 downcast_to_GeomVertexRewriter 0 12 3269 48 GeomVertexReader::downcast_to_GeomVertexRewriter 0 0 52</span>
<span class="s0">downcast from GeomVertexReader to GeomVertexRewriter</span>
<span class="s0">75</span>
<span class="s0">GeomVertexRewriter *GeomVertexReader::downcast_to_GeomVertexRewriter(void);</span>

<span class="s0">2495 18 GeomVertexRewriter 0 260 3271 38 GeomVertexRewriter::GeomVertexRewriter 0 6 918 919 920 921 922 923 643</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an invalid GeomVertexRewriter.  You must use the assignment</span>
 <span class="s0">* operator to assign a valid GeomVertexRewriter to this object before you can</span>
 <span class="s0">* use it.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new rewriter to process the vertices of the indicated data</span>
 <span class="s0">* object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new rewriter to process the vertices of the indicated data</span>
 <span class="s0">* object.  This flavor creates the rewriter specifically to process the named</span>
 <span class="s0">* data type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new rewriter to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new rewriter to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">747</span>
<span class="s0">inline GeomVertexRewriter::GeomVertexRewriter(Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexRewriter const &amp;copy);</span>

<span class="s0">2496 10 operator = 0 4 3271 30 GeomVertexRewriter::operator = 0 1 924 0</span>
<span class="s0">75</span>
<span class="s0">inline void GeomVertexRewriter::operator =(GeomVertexRewriter const &amp;copy);</span>

<span class="s0">2497 19 ~GeomVertexRewriter 0 516 3271 39 GeomVertexRewriter::~GeomVertexRewriter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline GeomVertexRewriter::~GeomVertexRewriter(void);</span>

<span class="s0">2498 15 get_vertex_data 0 4 3271 35 GeomVertexRewriter::get_vertex_data 0 1 925 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the vertex data object that the rewriter is processing.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline GeomVertexData *GeomVertexRewriter::get_vertex_data(void) const;</span>

<span class="s0">2499 14 get_array_data 0 4 3271 34 GeomVertexRewriter::get_array_data 0 1 926 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the particular array object that the rewriter is currently</span>
 <span class="s0">* processing.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline GeomVertexArrayData *GeomVertexRewriter::get_array_data(void) const;</span>

<span class="s0">2500 16 get_array_handle 0 4 3271 36 GeomVertexRewriter::get_array_handle 0 1 927 245</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the write handle to the array object that the rewriter is currently</span>
 <span class="s0">* processing.  This low-level call should be used with caution; be careful</span>
 <span class="s0">* with modifying the data in the handle out from under the</span>
 <span class="s0">* GeomVertexRewriter.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline GeomVertexArrayDataHandle *GeomVertexRewriter::get_array_handle(void) const;</span>

<span class="s0">2501 10 get_stride 0 4 3271 30 GeomVertexRewriter::get_stride 0 1 928 199</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the per-row stride (bytes between consecutive rows) of the</span>
 <span class="s0">* underlying vertex array.  This low-level information is normally not needed</span>
 <span class="s0">* to use the GeomVertexRewriter directly.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t GeomVertexRewriter::get_stride(void) const;</span>

<span class="s0">2502 18 get_current_thread 0 4 3271 38 GeomVertexRewriter::get_current_thread 0 1 929 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Thread pointer of the currently-executing thread, as passed to</span>
 <span class="s0">* the constructor of this object.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline Thread *GeomVertexRewriter::get_current_thread(void) const;</span>

<span class="s0">2503 10 set_column 0 4 3271 30 GeomVertexRewriter::set_column 0 3 930 931 932 1027</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the rewriter to use the nth data type of the GeomVertexFormat,</span>
 <span class="s0">* numbering from 0.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets both the read and write row numbers to the start row (the</span>
 <span class="s0">* same value passed to a previous call to set_row(), or 0 if set_row() was</span>
 <span class="s0">* never called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up the rewriter to use the data type with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets both the read and write row numbers to the start row (the</span>
 <span class="s0">* same value passed to a previous call to set_row(), or 0 if set_row() was</span>
 <span class="s0">* never called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up the rewriter to use the indicated column description on the given</span>
 <span class="s0">* array.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets both the read and write row numbers to the start row (the</span>
 <span class="s0">* same value passed to a previous call to set_row(), or 0 if set_row() was</span>
 <span class="s0">* never called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">209</span>
<span class="s0">inline bool GeomVertexRewriter::set_column(int column);</span>
<span class="s0">inline bool GeomVertexRewriter::set_column(CPT_InternalName name);</span>
<span class="s0">inline bool GeomVertexRewriter::set_column(int array, GeomVertexColumn const *column);</span>

<span class="s0">2504 5 clear 0 4 3271 25 GeomVertexRewriter::clear 0 1 933 62</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the GeomVertexRewriter to the initial state.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void GeomVertexRewriter::clear(void);</span>

<span class="s0">2505 10 has_column 0 4 3271 30 GeomVertexRewriter::has_column 0 1 934 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a valid data type has been successfully set, or false if</span>
 <span class="s0">* the data type does not exist.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool GeomVertexRewriter::has_column(void) const;</span>

<span class="s0">2506 9 get_array 0 4 3271 29 GeomVertexRewriter::get_array 0 1 935 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the array index containing the data type that the rewriter is</span>
 <span class="s0">* working on.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int GeomVertexRewriter::get_array(void) const;</span>

<span class="s0">2507 10 get_column 0 4 3271 30 GeomVertexRewriter::get_column 0 1 936 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the description of the data type that the rewriter is working on.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline GeomVertexColumn const *GeomVertexRewriter::get_column(void) const;</span>

<span class="s0">2508 14 set_row_unsafe 0 4 3271 34 GeomVertexRewriter::set_row_unsafe 0 1 937 344</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the start row to the indicated value, without internal checks.  This</span>
 <span class="s0">* is the same as set_row(), but it does not check for the possibility that</span>
 <span class="s0">* the array has been reallocated internally for some reason; use only when</span>
 <span class="s0">* you are confident that the array is unchanged and you really need every bit</span>
 <span class="s0">* of available performance.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void GeomVertexRewriter::set_row_unsafe(int row);</span>

<span class="s0">2509 7 set_row 0 4 3271 27 GeomVertexRewriter::set_row 0 1 938 132</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the start, write, and write index to the indicated value.  The</span>
 <span class="s0">* rewriter will begin traversing from the given row.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void GeomVertexRewriter::set_row(int row);</span>

<span class="s0">2510 13 get_start_row 0 4 3271 33 GeomVertexRewriter::get_start_row 0 1 939 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the row index at which the rewriter started.  It will return to</span>
 <span class="s0">* this row if you reset the current column.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int GeomVertexRewriter::get_start_row(void) const;</span>

<span class="s0">2511 9 is_at_end 0 4 3271 29 GeomVertexRewriter::is_at_end 0 1 940 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the reader or writer is currently at the end of the list of</span>
 <span class="s0">* vertices, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool GeomVertexRewriter::is_at_end(void) const;</span>

<span class="s0">2512 6 output 0 4 3271 26 GeomVertexRewriter::output 0 1 941 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void GeomVertexRewriter::output(std::ostream &amp;out) const;</span>

<span class="s0">2513 12 SamplerState 0 260 3272 26 SamplerState::SamplerState 0 2 944 945 72</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new SamplerState initialized to the default values.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline SamplerState::SamplerState(void);</span>
<span class="s0">inline SamplerState::SamplerState(SamplerState const &amp;) = default;</span>

<span class="s0">2514 11 get_default 0 4 3272 25 SamplerState::get_default 0 1 946 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a reference to the global default immutable SamplerState object.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline SamplerState const &amp;SamplerState::get_default(void);</span>

<span class="s0">2515 10 set_wrap_u 0 4 3272 24 SamplerState::set_wrap_u 0 1 947 221</span>
<span class="s0">/**</span>
 <span class="s0">* This setting determines what happens when the SamplerState is sampled with</span>
 <span class="s0">* a U value outside the range 0.0-1.0.  The default is WM_repeat, which</span>
 <span class="s0">* indicates that the SamplerState should repeat indefinitely.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void SamplerState::set_wrap_u(SamplerState::WrapMode wrap);</span>

<span class="s0">2516 10 set_wrap_v 0 4 3272 24 SamplerState::set_wrap_v 0 1 948 221</span>
<span class="s0">/**</span>
 <span class="s0">* This setting determines what happens when the SamplerState is sampled with</span>
 <span class="s0">* a V value outside the range 0.0-1.0.  The default is WM_repeat, which</span>
 <span class="s0">* indicates that the SamplerState should repeat indefinitely.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void SamplerState::set_wrap_v(SamplerState::WrapMode wrap);</span>

<span class="s0">2517 10 set_wrap_w 0 4 3272 24 SamplerState::set_wrap_w 0 1 949 67</span>
<span class="s0">/**</span>
 <span class="s0">* The W wrap direction is only used for 3-d SamplerStates.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void SamplerState::set_wrap_w(SamplerState::WrapMode wrap);</span>

<span class="s0">2518 13 set_minfilter 0 4 3272 27 SamplerState::set_minfilter 0 1 950 106</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the filtering method that should be used when viewing the SamplerState</span>
 <span class="s0">* from a distance.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void SamplerState::set_minfilter(SamplerState::FilterType filter);</span>

<span class="s0">2519 13 set_magfilter 0 4 3272 27 SamplerState::set_magfilter 0 1 951 99</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the filtering method that should be used when viewing the SamplerState</span>
 <span class="s0">* up close.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void SamplerState::set_magfilter(SamplerState::FilterType filter);</span>

<span class="s0">2520 22 set_anisotropic_degree 0 4 3272 36 SamplerState::set_anisotropic_degree 0 1 952 418</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the level of anisotropic filtering to apply to the SamplerState.</span>
 <span class="s0">* Set this 0 to indicate the default value, which is specified in the</span>
 <span class="s0">* SamplerState-anisotropic-degree config variable.</span>
 <span class="s0">*</span>
 <span class="s0">* To explicitly disable anisotropic filtering, set this value to 1.  To</span>
 <span class="s0">* explicitly enable anisotropic filtering, set it to a value higher than 1;</span>
 <span class="s0">* larger numbers indicate greater degrees of filtering.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void SamplerState::set_anisotropic_degree(int anisotropic_degree);</span>

<span class="s0">2521 16 set_border_color 0 4 3272 30 SamplerState::set_border_color 0 1 953 198</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the solid color of the SamplerState's border.  Some OpenGL</span>
 <span class="s0">* implementations use a border for tiling SamplerStates; in Panda, it is only</span>
 <span class="s0">* used for specifying the clamp color.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void SamplerState::set_border_color(LColor const &amp;color);</span>

<span class="s0">2522 11 set_min_lod 0 4 3272 25 SamplerState::set_min_lod 0 1 954 123</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the minimum level of detail that will be used when sampling this</span>
 <span class="s0">* texture.  This may be a negative value.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void SamplerState::set_min_lod(PN_stdfloat min_lod);</span>

<span class="s0">2523 11 set_max_lod 0 4 3272 25 SamplerState::set_max_lod 0 1 955 159</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the maximum level of detail that will be used when sampling this</span>
 <span class="s0">* texture.  This may exceed the number of mipmap levels that the texture has.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void SamplerState::set_max_lod(PN_stdfloat max_lod);</span>

<span class="s0">2524 12 set_lod_bias 0 4 3272 26 SamplerState::set_lod_bias 0 1 956 211</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the value that will be added to the level of detail when sampling the</span>
 <span class="s0">* texture.  This may be a negative value, although some graphics hardware may</span>
 <span class="s0">* not support the use of negative LOD values.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void SamplerState::set_lod_bias(PN_stdfloat lod_bias);</span>

<span class="s0">2525 10 get_wrap_u 0 4 3272 24 SamplerState::get_wrap_u 0 1 957 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the wrap mode of the texture in the U direction.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline SamplerState::WrapMode SamplerState::get_wrap_u(void) const;</span>

<span class="s0">2526 10 get_wrap_v 0 4 3272 24 SamplerState::get_wrap_v 0 1 958 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the wrap mode of the texture in the V direction.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline SamplerState::WrapMode SamplerState::get_wrap_v(void) const;</span>

<span class="s0">2527 10 get_wrap_w 0 4 3272 24 SamplerState::get_wrap_w 0 1 959 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the wrap mode of the texture in the W direction.  This is the depth</span>
 <span class="s0">* direction of 3-d textures.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline SamplerState::WrapMode SamplerState::get_wrap_w(void) const;</span>

<span class="s0">2528 13 get_minfilter 0 4 3272 27 SamplerState::get_minfilter 0 1 960 214</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filter mode of the texture for minification.  If this is one of</span>
 <span class="s0">* the mipmap constants, then the texture requires mipmaps.  This may return</span>
 <span class="s0">* FT_default; see also get_effective_minfilter().</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline SamplerState::FilterType SamplerState::get_minfilter(void) const;</span>

<span class="s0">2529 13 get_magfilter 0 4 3272 27 SamplerState::get_magfilter 0 1 961 179</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filter mode of the texture for magnification.  The mipmap</span>
 <span class="s0">* constants are invalid here.  This may return FT_default; see also</span>
 <span class="s0">* get_effective_minfilter().</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline SamplerState::FilterType SamplerState::get_magfilter(void) const;</span>

<span class="s0">2530 23 get_effective_minfilter 0 4 3272 37 SamplerState::get_effective_minfilter 0 1 962 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filter mode of the texture for minification, with special</span>
 <span class="s0">* treatment for FT_default.  This will normally not return FT_default, unless</span>
 <span class="s0">* there is an error in the config file.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">SamplerState::FilterType SamplerState::get_effective_minfilter(void) const;</span>

<span class="s0">2531 23 get_effective_magfilter 0 4 3272 37 SamplerState::get_effective_magfilter 0 1 963 201</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filter mode of the texture for magnification, with special</span>
 <span class="s0">* treatment for FT_default.  This will normally not return FT_default, unless</span>
 <span class="s0">* there is an error in the config file.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">SamplerState::FilterType SamplerState::get_effective_magfilter(void) const;</span>

<span class="s0">2532 22 get_anisotropic_degree 0 4 3272 36 SamplerState::get_anisotropic_degree 0 1 964 198</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the degree of anisotropic filtering that should be applied to the</span>
 <span class="s0">* texture.  This value may return 0, indicating the default value; see also</span>
 <span class="s0">* get_effective_anisotropic_degree.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int SamplerState::get_anisotropic_degree(void) const;</span>

<span class="s0">2533 32 get_effective_anisotropic_degree 0 4 3272 46 SamplerState::get_effective_anisotropic_degree 0 1 965 184</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the degree of anisotropic filtering that should be applied to the</span>
 <span class="s0">* texture.  This value will normally not return 0, unless there is an error</span>
 <span class="s0">* in the config file.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline int SamplerState::get_effective_anisotropic_degree(void) const;</span>

<span class="s0">2534 16 get_border_color 0 4 3272 30 SamplerState::get_border_color 0 1 966 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the solid color of the texture's border.  Some OpenGL</span>
 <span class="s0">* implementations use a border for tiling textures; in Panda, it is only used</span>
 <span class="s0">* for specifying the clamp color.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LColor const &amp;SamplerState::get_border_color(void) const;</span>

<span class="s0">2535 11 get_min_lod 0 4 3272 25 SamplerState::get_min_lod 0 1 967 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minimum level of detail that will be observed when sampling</span>
 <span class="s0">* this texture.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat SamplerState::get_min_lod(void) const;</span>

<span class="s0">2536 11 get_max_lod 0 4 3272 25 SamplerState::get_max_lod 0 1 968 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum level of detail that will be observed when sampling</span>
 <span class="s0">* this texture.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat SamplerState::get_max_lod(void) const;</span>

<span class="s0">2537 12 get_lod_bias 0 4 3272 26 SamplerState::get_lod_bias 0 1 969 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bias that will be added to the texture level of detail when</span>
 <span class="s0">* sampling this texture.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline PN_stdfloat SamplerState::get_lod_bias(void) const;</span>

<span class="s0">2538 12 uses_mipmaps 0 4 3272 26 SamplerState::uses_mipmaps 0 1 970 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the minfilter settings on this sampler indicate the use of</span>
 <span class="s0">* mipmapping, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool SamplerState::uses_mipmaps(void) const;</span>

<span class="s0">2539 9 is_mipmap 0 4 3272 23 SamplerState::is_mipmap 0 1 971 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated filter type requires the use of mipmaps, or</span>
 <span class="s0">* false if it does not.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline bool SamplerState::is_mipmap(SamplerState::FilterType type);</span>

<span class="s0">2540 18 format_filter_type 0 4 3272 32 SamplerState::format_filter_type 0 1 972 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated FilterType converted to a string word.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">static std::string SamplerState::format_filter_type(SamplerState::FilterType ft);</span>

<span class="s0">2541 18 string_filter_type 0 4 3272 32 SamplerState::string_filter_type 0 1 973 165</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the FilterType value associated with the given string</span>
 <span class="s0">* representation, or FT_invalid if the string does not match any known</span>
 <span class="s0">* FilterType value.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">static SamplerState::FilterType SamplerState::string_filter_type(std::string const &amp;str);</span>

<span class="s0">2542 16 format_wrap_mode 0 4 3272 30 SamplerState::format_wrap_mode 0 1 974 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated WrapMode converted to a string word.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">static std::string SamplerState::format_wrap_mode(SamplerState::WrapMode wm);</span>

<span class="s0">2543 16 string_wrap_mode 0 4 3272 30 SamplerState::string_wrap_mode 0 1 975 158</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the WrapMode value associated with the given string representation,</span>
 <span class="s0">* or WM_invalid if the string does not match any known WrapMode value.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">static SamplerState::WrapMode SamplerState::string_wrap_mode(std::string const &amp;str);</span>

<span class="s0">2544 11 operator == 0 4 3272 25 SamplerState::operator == 0 1 976 0</span>
<span class="s0">71</span>
<span class="s0">inline bool SamplerState::operator ==(SamplerState const &amp;other) const;</span>

<span class="s0">2545 11 operator != 0 4 3272 25 SamplerState::operator != 0 1 977 0</span>
<span class="s0">71</span>
<span class="s0">inline bool SamplerState::operator !=(SamplerState const &amp;other) const;</span>

<span class="s0">2546 10 operator &lt; 0 4 3272 24 SamplerState::operator &lt; 0 1 978 0</span>
<span class="s0">70</span>
<span class="s0">inline bool SamplerState::operator &lt;(SamplerState const &amp;other) const;</span>

<span class="s0">2547 7 prepare 0 4 3272 21 SamplerState::prepare 0 1 979 250</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the sampler should be enqueued to be prepared in the</span>
 <span class="s0">* indicated prepared_objects at the beginning of the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload samplers from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void SamplerState::prepare(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2548 11 is_prepared 0 4 3272 25 SamplerState::is_prepared 0 1 980 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the sampler has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">bool SamplerState::is_prepared(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2549 7 release 0 4 3272 21 SamplerState::release 0 1 981 157</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the texture context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void SamplerState::release(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2550 11 prepare_now 0 4 3272 25 SamplerState::prepare_now 0 1 982 531</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a context for the sampler on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) SamplerContext.  This assumes that</span>
 <span class="s0">* the GraphicsStateGuardian is the currently active rendering context and</span>
 <span class="s0">* that it is ready to accept new textures.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a sampler does not need to be explicitly prepared by the user before it may</span>
 <span class="s0">* be rendered.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">SamplerContext *SamplerState::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg) const;</span>

<span class="s0">2551 14 get_class_type 0 4 3272 28 SamplerState::get_class_type 0 1 983 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle SamplerState::get_class_type(void);</span>

<span class="s0">2552 13 ~SamplerState 0 516 3272 27 SamplerState::~SamplerState 0 0 0</span>
<span class="s0">34</span>
<span class="s0">SamplerState::~SamplerState(void);</span>

<span class="s0">2553 37 upcast_to_TypedWritableReferenceCount 0 12 3276 46 Texture::upcast_to_TypedWritableReferenceCount 0 1 1207 50</span>
<span class="s0">upcast from Texture to TypedWritableReferenceCount</span>
<span class="s0">82</span>
<span class="s0">TypedWritableReferenceCount *Texture::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">2554 19 downcast_to_Texture 0 12 3180 48 TypedWritableReferenceCount::downcast_to_Texture 0 0 52</span>
<span class="s0">downcast from TypedWritableReferenceCount to Texture</span>
<span class="s0">64</span>
<span class="s0">Texture *TypedWritableReferenceCount::downcast_to_Texture(void);</span>

<span class="s0">2555 17 upcast_to_Namable 0 12 3276 26 Texture::upcast_to_Namable 0 1 1208 30</span>
<span class="s0">upcast from Texture to Namable</span>
<span class="s0">42</span>
<span class="s0">Namable *Texture::upcast_to_Namable(void);</span>

<span class="s0">2556 19 downcast_to_Texture 0 12 3164 28 Namable::downcast_to_Texture 0 0 32</span>
<span class="s0">downcast from Namable to Texture</span>
<span class="s0">44</span>
<span class="s0">Texture *Namable::downcast_to_Texture(void);</span>

<span class="s0">2557 7 Texture 0 260 3276 16 Texture::Texture 0 1 984 278</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an empty texture.  The default is to set up the texture as an</span>
 <span class="s0">* empty 2-d texture; follow up with one of the variants of setup_texture() if</span>
 <span class="s0">* this is not what you want.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Use Texture::make_copy() to make a duplicate copy of an existing Texture.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">explicit Texture::Texture(std::string const &amp;name = string());</span>

<span class="s0">2558 8 ~Texture 0 518 3276 17 Texture::~Texture 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">virtual Texture::~Texture(void);</span>

<span class="s0">2559 9 make_copy 0 4 3276 18 Texture::make_copy 0 1 985 369</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new copy of the same Texture.  This copy, if applied to geometry,</span>
 <span class="s0">* will be copied into texture as a separate texture from the original, so it</span>
 <span class="s0">* will be duplicated in texture memory (and may be independently modified if</span>
 <span class="s0">* desired).</span>
 <span class="s0">*</span>
 <span class="s0">* If the Texture is a VideoTexture, the resulting duplicate may be animated</span>
 <span class="s0">* independently of the original.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PointerTo&lt; Texture &gt; Texture::make_copy(void) const;</span>

<span class="s0">2560 5 clear 0 4 3276 14 Texture::clear 0 1 986 90</span>
<span class="s0">/**</span>
 <span class="s0">* Reinitializes the texture to its default, empty state (except for the</span>
 <span class="s0">* name).</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">inline void Texture::clear(void);</span>

<span class="s0">2561 13 setup_texture 0 4 3276 22 Texture::setup_texture 0 1 987 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture to the indicated type and dimensions, presumably in</span>
 <span class="s0">* preparation for calling read() or load(), or set_ram_image() or</span>
 <span class="s0">* modify_ram_image(), or use set_clear_color to let the texture be cleared to</span>
 <span class="s0">* a solid color.</span>
 <span class="s0">*/</span>
<span class="s0">169</span>
<span class="s0">inline void Texture::setup_texture(Texture::TextureType texture_type, int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format);</span>

<span class="s0">2562 16 setup_1d_texture 0 4 3276 25 Texture::setup_1d_texture 0 2 988 989 485</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty 1-d texture with no dimensions.  Follow up</span>
 <span class="s0">* with read() or load() to fill the texture properties and image data, or use</span>
 <span class="s0">* set_clear_color to let the texture be cleared to a solid color.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty 1-d texture with the specified dimensions and</span>
 <span class="s0">* properties.  Follow up with set_ram_image() or modify_ram_image() to fill</span>
 <span class="s0">* the image data, or use set_clear_color to let the texture be cleared to a</span>
 <span class="s0">* solid color.</span>
 <span class="s0">*/</span>
<span class="s0">158</span>
<span class="s0">inline void Texture::setup_1d_texture(void);</span>
<span class="s0">inline void Texture::setup_1d_texture(int x_size, Texture::ComponentType component_type, Texture::Format format);</span>

<span class="s0">2563 16 setup_2d_texture 0 4 3276 25 Texture::setup_2d_texture 0 2 990 991 485</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty 2-d texture with no dimensions.  Follow up</span>
 <span class="s0">* with read() or load() to fill the texture properties and image data, or use</span>
 <span class="s0">* set_clear_color to let the texture be cleared to a solid color.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty 2-d texture with the specified dimensions and</span>
 <span class="s0">* properties.  Follow up with set_ram_image() or modify_ram_image() to fill</span>
 <span class="s0">* the image data, or use set_clear_color to let the texture be cleared to a</span>
 <span class="s0">* solid color.</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">inline void Texture::setup_2d_texture(void);</span>
<span class="s0">inline void Texture::setup_2d_texture(int x_size, int y_size, Texture::ComponentType component_type, Texture::Format format);</span>

<span class="s0">2564 16 setup_3d_texture 0 4 3276 25 Texture::setup_3d_texture 0 2 992 993 496</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty 3-d texture with no dimensions (though if you</span>
 <span class="s0">* know the depth ahead of time, it saves a bit of reallocation later). Follow</span>
 <span class="s0">* up with read() or load() to fill the texture properties and image data, or</span>
 <span class="s0">* use set_clear_color to let the texture be cleared to a solid color.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty 3-d texture with the specified dimensions and</span>
 <span class="s0">* properties.  Follow up with set_ram_image() or modify_ram_image() to fill</span>
 <span class="s0">* the image data.</span>
 <span class="s0">*/</span>
<span class="s0">192</span>
<span class="s0">inline void Texture::setup_3d_texture(int z_size = 1);</span>
<span class="s0">inline void Texture::setup_3d_texture(int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format);</span>

<span class="s0">2565 14 setup_cube_map 0 4 3276 23 Texture::setup_cube_map 0 2 994 995 632</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty cube map texture with no dimensions.  Follow</span>
 <span class="s0">* up with read() or load() to fill the texture properties and image data, or</span>
 <span class="s0">* use set_clear_color to let the texture be cleared to a solid color.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty cube map texture with the specified dimensions</span>
 <span class="s0">* and properties.  Follow up with set_ram_image() or modify_ram_image() to</span>
 <span class="s0">* fill the image data, or use set_clear_color to let the texture be cleared</span>
 <span class="s0">* to a solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that a cube map should always consist of six square images, so x_size</span>
 <span class="s0">* and y_size will be the same, and z_size is always 6.</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">inline void Texture::setup_cube_map(void);</span>
<span class="s0">inline void Texture::setup_cube_map(int size, Texture::ComponentType component_type, Texture::Format format);</span>

<span class="s0">2566 22 setup_2d_texture_array 0 4 3276 31 Texture::setup_2d_texture_array 0 2 996 997 585</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty 2-d texture array with no dimensions (though</span>
 <span class="s0">* if you know the depth ahead of time, it saves a bit of reallocation later).</span>
 <span class="s0">* Follow up with read() or load() to fill the texture properties and image</span>
 <span class="s0">* data, or use set_clear_color to let the texture be cleared to a solid</span>
 <span class="s0">* color.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty 2-d texture array with the specified</span>
 <span class="s0">* dimensions and properties.  Follow up with set_ram_image() or</span>
 <span class="s0">* modify_ram_image() to fill the image data, or use set_clear_color to let</span>
 <span class="s0">* the texture be cleared to a solid color.</span>
 <span class="s0">*/</span>
<span class="s0">204</span>
<span class="s0">inline void Texture::setup_2d_texture_array(int z_size = 1);</span>
<span class="s0">inline void Texture::setup_2d_texture_array(int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format);</span>

<span class="s0">2567 20 setup_cube_map_array 0 4 3276 29 Texture::setup_cube_map_array 0 2 998 999 675</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture as cube map array with N cube maps.  Note that this number</span>
 <span class="s0">* is not the same as the z_size.  Follow up with read() or load() to fill the</span>
 <span class="s0">* texture properties and image data, or use set_clear_color to let the</span>
 <span class="s0">* texture be cleared to a solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the texture as cube map array with N cube maps with the specified</span>
 <span class="s0">* dimensions and format.  Follow up with set_ram_image() or</span>
 <span class="s0">* modify_ram_image() to fill the image data, or use set_clear_color to let</span>
 <span class="s0">* the texture be cleared to a solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* The num_cube_maps given here is multiplied by six to become the z_size of</span>
 <span class="s0">* the image.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">196</span>
<span class="s0">inline void Texture::setup_cube_map_array(int num_cube_maps);</span>
<span class="s0">inline void Texture::setup_cube_map_array(int size, int num_cube_maps, Texture::ComponentType component_type, Texture::Format format);</span>

<span class="s0">2568 20 setup_buffer_texture 0 4 3276 29 Texture::setup_buffer_texture 0 1 1000 329</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture as an empty buffer texture with the specified size and</span>
 <span class="s0">* properties.  Follow up with set_ram_image() or modify_ram_image() to fill</span>
 <span class="s0">* the image data, or use set_clear_color to let the texture be cleared to a</span>
 <span class="s0">* solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that a buffer texture's format needs to match the component type.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void Texture::setup_buffer_texture(int size, Texture::ComponentType component_type, Texture::Format format, GeomEnums::UsageHint usage);</span>

<span class="s0">2569 31 generate_normalization_cube_map 0 4 3276 40 Texture::generate_normalization_cube_map 0 1 1001 296</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a special cube map image in the texture that can be used to apply</span>
 <span class="s0">* bump mapping effects: for each texel in the cube map that is indexed by the</span>
 <span class="s0">* 3-d texture coordinates (x, y, z), the resulting value is the normalized</span>
 <span class="s0">* vector (x, y, z) (compressed from -1..1 into 0..1).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void Texture::generate_normalization_cube_map(int size);</span>

<span class="s0">2570 24 generate_alpha_scale_map 0 4 3276 33 Texture::generate_alpha_scale_map 0 1 1002 253</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a special 256x1 1-d texture that can be used to apply an</span>
 <span class="s0">* arbitrary alpha scale to objects by judicious use of texture matrix.  The</span>
 <span class="s0">* texture is a gradient, with an alpha of 0 on the left (U = 0), and 255 on</span>
 <span class="s0">* the right (U = 1).</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void Texture::generate_alpha_scale_map(void);</span>

<span class="s0">2571 11 clear_image 0 4 3276 20 Texture::clear_image 0 1 1003 445</span>
<span class="s0">/**</span>
 <span class="s0">* Clears the texture data without changing its format or resolution.  The</span>
 <span class="s0">* texture is cleared on both the graphics hardware and from RAM, unlike</span>
 <span class="s0">* clear_ram_image, which only removes the data from RAM.</span>
 <span class="s0">*</span>
 <span class="s0">* If a clear color has been specified using set_clear_color, the texture will</span>
 <span class="s0">* be cleared using a solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* The texture data will be cleared the first time in which the texture is</span>
 <span class="s0">* used after this method is called.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline void Texture::clear_image(void);</span>

<span class="s0">2572 15 has_clear_color 0 4 3276 24 Texture::has_clear_color 0 1 1004 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a color was previously set using set_clear_color.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool Texture::has_clear_color(void) const;</span>

<span class="s0">2573 15 get_clear_color 0 4 3276 24 Texture::get_clear_color 0 1 1005 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color that was previously set using set_clear_color.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LColor Texture::get_clear_color(void) const;</span>

<span class="s0">2574 15 set_clear_color 0 4 3276 24 Texture::set_clear_color 0 1 1006 359</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color that will be used to fill the texture image in absence of</span>
 <span class="s0">* any image data.  It is used when any of the setup_texture functions or</span>
 <span class="s0">* clear_image is called and image data is not provided using read() or</span>
 <span class="s0">* modify_ram_image().</span>
 <span class="s0">*</span>
 <span class="s0">* This does not affect a texture that has already been cleared; call</span>
 <span class="s0">* clear_image to clear it again.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void Texture::set_clear_color(LColor const &amp;color);</span>

<span class="s0">2575 17 clear_clear_color 0 4 3276 26 Texture::clear_clear_color 0 1 1007 161</span>
<span class="s0">/**</span>
 <span class="s0">* The opposite of set_clear_color.  If the image is cleared after setting</span>
 <span class="s0">* this, its contents may be undefined (or may in fact not be cleared at all).</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void Texture::clear_clear_color(void);</span>

<span class="s0">2576 14 get_clear_data 0 4 3276 23 Texture::get_clear_data 0 1 1008 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the raw image data for a single pixel if it were set to the clear</span>
 <span class="s0">* color.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline vector_uchar Texture::get_clear_data(void) const;</span>

<span class="s0">2577 4 read 0 4 3276 13 Texture::read 0 4 1009 1010 1011 1012 3436</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the named filename into the texture.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Combine a 3-component image with a grayscale image to get a 4-component</span>
 <span class="s0">* image.</span>
 <span class="s0">*</span>
 <span class="s0">* See the description of the full-parameter read() method for the meaning of</span>
 <span class="s0">* the primary_file_num_channels and alpha_file_channel parameters.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads a single file into a single page or mipmap level, or automatically</span>
 <span class="s0">* reads a series of files into a series of pages and/or mipmap levels.</span>
 <span class="s0">*</span>
 <span class="s0">* See the description of the full-parameter read() method for the meaning of</span>
 <span class="s0">* the various parameters.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads the texture from the indicated filename.  If</span>
 <span class="s0">* primary_file_num_channels is not 0, it specifies the number of components</span>
 <span class="s0">* to downgrade the image to if it is greater than this number.</span>
 <span class="s0">*</span>
 <span class="s0">* If the filename has the extension .txo, this implicitly reads a texture</span>
 <span class="s0">* object instead of a filename (which replaces all of the texture</span>
 <span class="s0">* properties).  In this case, all the rest of the parameters are ignored, and</span>
 <span class="s0">* the filename should not contain any hash marks; just the one named file</span>
 <span class="s0">* will be read, since a single .txo file can contain all pages and mipmaps</span>
 <span class="s0">* necessary to define a texture.</span>
 <span class="s0">*</span>
 <span class="s0">* If alpha_fullpath is not empty, it specifies the name of a file from which</span>
 <span class="s0">* to retrieve the alpha.  In this case, alpha_file_channel represents the</span>
 <span class="s0">* numeric channel of this image file to use as the resulting texture's alpha</span>
 <span class="s0">* channel; usually, this is 0 to indicate the grayscale combination of r, g,</span>
 <span class="s0">* b; or it may be a one-based channel number, e.g.  1 for the red channel, 2</span>
 <span class="s0">* for the green channel, and so on.</span>
 <span class="s0">*</span>
 <span class="s0">* If read pages is false, then z indicates the page number into which this</span>
 <span class="s0">* image will be assigned.  Normally this is 0 for the first (or only) page of</span>
 <span class="s0">* the texture.  3-D textures have one page for each level of depth, and cube</span>
 <span class="s0">* map textures always have six pages.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_pages is true, multiple images will be read at once, one for each</span>
 <span class="s0">* page of a cube map or a 3-D texture.  In this case, the filename should</span>
 <span class="s0">* contain a sequence of one or more hash marks (&quot;#&quot;) which will be filled in</span>
 <span class="s0">* with the z value of each page, zero-based.  In this case, the z parameter</span>
 <span class="s0">* indicates the maximum z value that will be loaded, or 0 to load all</span>
 <span class="s0">* filenames that exist.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is false, then n indicates the mipmap level to which this</span>
 <span class="s0">* image will be assigned.  Normally this is 0 for the base texture image, but</span>
 <span class="s0">* it is possible to load custom mipmap levels into the later images.  After</span>
 <span class="s0">* the base texture image is loaded (thus defining the size of the texture),</span>
 <span class="s0">* you can call get_expected_num_mipmap_levels() to determine the maximum</span>
 <span class="s0">* sensible value for n.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, multiple images will be read as above, but this</span>
 <span class="s0">* time the images represent the different mipmap levels of the texture image.</span>
 <span class="s0">* In this case, the n parameter indicates the maximum n value that will be</span>
 <span class="s0">* loaded, or 0 to load all filenames that exist (up to the expected number of</span>
 <span class="s0">* mipmap levels).</span>
 <span class="s0">*</span>
 <span class="s0">* If both read_pages and read_mipmaps is true, then both sequences will be</span>
 <span class="s0">* read; the filename should contain two sequences of hash marks, separated by</span>
 <span class="s0">* some character such as a hyphen, underscore, or dot.  The first hash mark</span>
 <span class="s0">* sequence will be filled in with the mipmap level, while the second hash</span>
 <span class="s0">* mark sequence will be the page index.</span>
 <span class="s0">*</span>
 <span class="s0">* This method implicitly sets keep_ram_image to false.</span>
 <span class="s0">*/</span>
<span class="s0">683</span>
<span class="s0">bool Texture::read(Filename const &amp;fullpath, LoaderOptions const &amp;options = LoaderOptions());</span>
<span class="s0">bool Texture::read(Filename const &amp;fullpath, Filename const &amp;alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, LoaderOptions const &amp;options = LoaderOptions());</span>
<span class="s0">bool Texture::read(Filename const &amp;fullpath, int z, int n, bool read_pages, bool read_mipmaps, LoaderOptions const &amp;options = LoaderOptions());</span>
<span class="s0">bool Texture::read(Filename const &amp;fullpath, Filename const &amp;alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, int z, int n, bool read_pages, bool read_mipmaps, BamCacheRecord *record = nullptr, LoaderOptions const &amp;options = LoaderOptions());</span>

<span class="s0">2578 5 write 0 4 3276 14 Texture::write 0 3 1013 1014 1015 2416</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the texture to the named filename.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes a single page or mipmap level to a single file, or automatically</span>
 <span class="s0">* writes a series of pages and/or mipmap levels to a numbered series of</span>
 <span class="s0">* files.</span>
 <span class="s0">*</span>
 <span class="s0">* If the filename ends in the extension .txo, this implicitly writes a Panda</span>
 <span class="s0">* texture object (.txo) instead of an image file.  In this case, the</span>
 <span class="s0">* remaining parameters are ignored, and only one file is written, which will</span>
 <span class="s0">* contain all of the pages and resident mipmap levels in the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* If write_pages is false, then z indicates the page number to write.  3-D</span>
 <span class="s0">* textures have one page number for each level of depth; cube maps have six</span>
 <span class="s0">* pages number 0 through 5.  Other kinds of textures have only one page,</span>
 <span class="s0">* numbered 0.  If there are multiple views, the range of z is increased; the</span>
 <span class="s0">* total range is [0, get_num_pages()).</span>
 <span class="s0">*</span>
 <span class="s0">* If write_pages is true, then all pages of the texture will be written.  In</span>
 <span class="s0">* this case z is ignored, and the filename should contain a sequence of hash</span>
 <span class="s0">* marks (&quot;#&quot;) which will be filled in with the page index number.</span>
 <span class="s0">*</span>
 <span class="s0">* If write_mipmaps is false, then n indicates the mipmap level number to</span>
 <span class="s0">* write.  Normally, this is 0, for the base texture image.  Normally, the</span>
 <span class="s0">* mipmap levels of a texture are not available in RAM (they are generated</span>
 <span class="s0">* automatically by the graphics card). However, if you have the mipmap levels</span>
 <span class="s0">* available, for instance because you called generate_ram_mipmap_images() to</span>
 <span class="s0">* generate them internally, or you called</span>
 <span class="s0">* GraphicsEngine::extract_texture_data() to retrieve them from the graphics</span>
 <span class="s0">* card, then you may write out each mipmap level with this parameter.</span>
 <span class="s0">*</span>
 <span class="s0">* If write_mipmaps is true, then all mipmap levels of the texture will be</span>
 <span class="s0">* written.  In this case n is ignored, and the filename should contain a</span>
 <span class="s0">* sequence of hash marks (&quot;#&quot;) which will be filled in with the mipmap level</span>
 <span class="s0">* number.</span>
 <span class="s0">*</span>
 <span class="s0">* If both write_pages and write_mipmaps is true, then all pages and all</span>
 <span class="s0">* mipmap levels will be written.  In this case, the filename should contain</span>
 <span class="s0">* two different sequences of hash marks, separated by a character such as a</span>
 <span class="s0">* hyphen, underscore, or dot.  The first hash mark sequence will be filled in</span>
 <span class="s0">* with the mipmap level, while the second hash mark sequence will be the page</span>
 <span class="s0">* index.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Not to be confused with write(Filename), this method simply describes the</span>
 <span class="s0">* texture properties.</span>
 <span class="s0">*/</span>
<span class="s0">223</span>
<span class="s0">inline bool Texture::write(Filename const &amp;fullpath);</span>
<span class="s0">inline bool Texture::write(Filename const &amp;fullpath, int z, int n, bool write_pages, bool write_mipmaps);</span>
<span class="s0">void Texture::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2579 8 read_txo 0 4 3276 17 Texture::read_txo 0 1 1016 380</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the texture from a Panda texture object.  This defines the complete</span>
 <span class="s0">* Texture specification, including the image data as well as all texture</span>
 <span class="s0">* properties.  This only works if the txo file contains a static Texture</span>
 <span class="s0">* image, as opposed to a subclass of Texture such as a movie texture.</span>
 <span class="s0">*</span>
 <span class="s0">* Pass a real filename if it is available, or empty string if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">bool Texture::read_txo(std::istream &amp;in, std::string const &amp;filename = &quot;&quot;);</span>

<span class="s0">2580 13 make_from_txo 0 4 3276 22 Texture::make_from_txo 0 1 1017 310</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new Texture object from the txo file.  This is similar to</span>
 <span class="s0">* Texture::read_txo(), but it constructs and returns a new object, which</span>
 <span class="s0">* allows it to return a subclass of Texture (for instance, a movie texture).</span>
 <span class="s0">*</span>
 <span class="s0">* Pass a real filename if it is available, or empty string if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">static PointerTo&lt; Texture &gt; Texture::make_from_txo(std::istream &amp;in, std::string const &amp;filename = &quot;&quot;);</span>

<span class="s0">2581 9 write_txo 0 4 3276 18 Texture::write_txo 0 1 1018 214</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the texture to a Panda texture object.  This defines the complete</span>
 <span class="s0">* Texture specification, including the image data as well as all texture</span>
 <span class="s0">* properties.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is just for reference.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">bool Texture::write_txo(std::ostream &amp;out, std::string const &amp;filename = &quot;&quot;) const;</span>

<span class="s0">2582 8 read_dds 0 4 3276 17 Texture::read_dds 0 1 1019 381</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the texture from a DDS file object.  This is a Microsoft-defined file</span>
 <span class="s0">* format; it is similar in principle to a txo object, in that it is designed</span>
 <span class="s0">* to contain the texture image in a form as similar as possible to its</span>
 <span class="s0">* runtime image, and it can contain mipmaps, pre-compressed textures, and so</span>
 <span class="s0">* on.</span>
 <span class="s0">*</span>
 <span class="s0">* As with read_txo, the filename is just for reference.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">bool Texture::read_dds(std::istream &amp;in, std::string const &amp;filename = &quot;&quot;, bool header_only = false);</span>

<span class="s0">2583 8 read_ktx 0 4 3276 17 Texture::read_ktx 0 1 1020 379</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the texture from a KTX file object.  This is a Khronos-defined file</span>
 <span class="s0">* format; it is similar in principle to a dds object, in that it is designed</span>
 <span class="s0">* to contain the texture image in a form as similar as possible to its</span>
 <span class="s0">* runtime image, and it can contain mipmaps, pre-compressed textures, and so</span>
 <span class="s0">* on.</span>
 <span class="s0">*</span>
 <span class="s0">* As with read_dds, the filename is just for reference.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">bool Texture::read_ktx(std::istream &amp;in, std::string const &amp;filename = &quot;&quot;, bool header_only = false);</span>

<span class="s0">2584 4 load 0 4 3276 13 Texture::load 0 4 1021 1022 1023 1024 292</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the texture with the indicated image.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores the indicated image in the given page and mipmap level.  See read().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the texture with the indicated image.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stores the indicated image in the given page and mipmap level.  See read().</span>
 <span class="s0">*/</span>
<span class="s0">419</span>
<span class="s0">inline bool Texture::load(PNMImage const &amp;pnmimage, LoaderOptions const &amp;options = LoaderOptions());</span>
<span class="s0">inline bool Texture::load(PNMImage const &amp;pnmimage, int z, int n, LoaderOptions const &amp;options = LoaderOptions());</span>
<span class="s0">inline bool Texture::load(PfmFile const &amp;pfm, LoaderOptions const &amp;options = LoaderOptions());</span>
<span class="s0">inline bool Texture::load(PfmFile const &amp;pfm, int z, int n, LoaderOptions const &amp;options = LoaderOptions());</span>

<span class="s0">2585 14 load_sub_image 0 4 3276 23 Texture::load_sub_image 0 1 1025 328</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the indicated image in a region of the texture.  The texture</span>
 <span class="s0">* properties remain unchanged.  This can be more efficient than updating an</span>
 <span class="s0">* entire texture, but has a few restrictions: for one, you must ensure that</span>
 <span class="s0">* the texture is still in RAM (eg.  using set_keep_ram_image) and it may not</span>
 <span class="s0">* be compressed.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline bool Texture::load_sub_image(PNMImage const &amp;pnmimage, int x, int y, int z = 0, int n = 0);</span>

<span class="s0">2586 5 store 0 4 3276 14 Texture::store 0 4 1026 1027 1028 1029 344</span>
<span class="s0">/**</span>
 <span class="s0">* Saves the texture to the indicated PNMImage, but does not write it to disk.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Saves the indicated page and mipmap level of the texture to the PNMImage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Saves the texture to the indicated PfmFile, but does not write it to disk.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Saves the indicated page and mipmap level of the texture to the PfmFile.</span>
 <span class="s0">*/</span>
<span class="s0">231</span>
<span class="s0">inline bool Texture::store(PNMImage &amp;pnmimage) const;</span>
<span class="s0">inline bool Texture::store(PNMImage &amp;pnmimage, int z, int n) const;</span>
<span class="s0">inline bool Texture::store(PfmFile &amp;pfm) const;</span>
<span class="s0">inline bool Texture::store(PfmFile &amp;pfm, int z, int n) const;</span>

<span class="s0">2587 6 reload 0 4 3276 15 Texture::reload 0 1 1030 269</span>
<span class="s0">/**</span>
 <span class="s0">* Re-reads the Texture from its disk file.  Useful when you know the image on</span>
 <span class="s0">* disk has recently changed, and you want to update the Texture image.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure (in which case, the Texture may</span>
 <span class="s0">* or may not still be valid).</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">inline bool Texture::reload(void);</span>

<span class="s0">2588 12 load_related 0 4 3276 21 Texture::load_related 0 1 1031 189</span>
<span class="s0">/**</span>
 <span class="s0">* Loads a texture whose filename is derived by concatenating a suffix to the</span>
 <span class="s0">* filename of this texture.  May return NULL, for example, if this texture</span>
 <span class="s0">* doesn't have a filename.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">Texture *Texture::load_related(InternalName const *suffix) const;</span>

<span class="s0">2589 12 has_filename 0 4 3276 21 Texture::has_filename 0 1 1032 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the filename has been set and is available.  See</span>
 <span class="s0">* set_filename().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool Texture::has_filename(void) const;</span>

<span class="s0">2590 12 get_filename 0 4 3276 21 Texture::get_filename 0 1 1033 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename that has been set.  This is the name of the file as it</span>
 <span class="s0">* was requested.  Also see get_fullpath().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline Filename const &amp;Texture::get_filename(void) const;</span>

<span class="s0">2591 12 set_filename 0 4 3276 21 Texture::set_filename 0 1 1034 376</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the name of the file that contains the image's contents.  Normally,</span>
 <span class="s0">* this is set automatically when the image is loaded, for instance via</span>
 <span class="s0">* Texture::read().</span>
 <span class="s0">*</span>
 <span class="s0">* The Texture's get_name() function used to return the filename, but now</span>
 <span class="s0">* returns just the basename (without the extension), which is a more useful</span>
 <span class="s0">* name for identifying an image in show code.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void Texture::set_filename(Filename const &amp;filename);</span>

<span class="s0">2592 14 clear_filename 0 4 3276 23 Texture::clear_filename 0 1 1035 85</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the alpha filename, if it was previously set.  See set_filename().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void Texture::clear_filename(void);</span>

<span class="s0">2593 18 has_alpha_filename 0 4 3276 27 Texture::has_alpha_filename 0 1 1036 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the alpha_filename has been set and is available.  See</span>
 <span class="s0">* set_alpha_filename().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool Texture::has_alpha_filename(void) const;</span>

<span class="s0">2594 18 get_alpha_filename 0 4 3276 27 Texture::get_alpha_filename 0 1 1037 214</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alpha_filename that has been set.  If this is set, it</span>
 <span class="s0">* represents the name of the alpha component, which is stored in a separate</span>
 <span class="s0">* file.  See also get_filename(), and get_alpha_fullpath().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline Filename const &amp;Texture::get_alpha_filename(void) const;</span>

<span class="s0">2595 18 set_alpha_filename 0 4 3276 27 Texture::set_alpha_filename 0 1 1038 549</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the name of the file that contains the image's alpha channel contents.</span>
 <span class="s0">* Normally, this is set automatically when the image is loaded, for instance</span>
 <span class="s0">* via Texture::read().</span>
 <span class="s0">*</span>
 <span class="s0">* The Texture's get_filename() function returns the name of the image file</span>
 <span class="s0">* that was loaded into the buffer.  In the case where a texture specified two</span>
 <span class="s0">* separate files to load, a 1- or 3-channel color image and a 1-channel alpha</span>
 <span class="s0">* image, this Filename is update to contain the name of the image file that</span>
 <span class="s0">* was loaded into the buffer's alpha channel.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void Texture::set_alpha_filename(Filename const &amp;alpha_filename);</span>

<span class="s0">2596 20 clear_alpha_filename 0 4 3276 29 Texture::clear_alpha_filename 0 1 1039 94</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the alpha filename, if it was previously set.  See</span>
 <span class="s0">* set_alpha_filename().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void Texture::clear_alpha_filename(void);</span>

<span class="s0">2597 12 has_fullpath 0 4 3276 21 Texture::has_fullpath 0 1 1040 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the fullpath has been set and is available.  See</span>
 <span class="s0">* set_fullpath().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool Texture::has_fullpath(void) const;</span>

<span class="s0">2598 12 get_fullpath 0 4 3276 21 Texture::get_fullpath 0 1 1041 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the fullpath that has been set.  This is the full path to the file</span>
 <span class="s0">* as it was found along the texture search path.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline Filename const &amp;Texture::get_fullpath(void) const;</span>

<span class="s0">2599 12 set_fullpath 0 4 3276 21 Texture::set_fullpath 0 1 1042 216</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the full pathname to the file that contains the image's contents, as</span>
 <span class="s0">* found along the search path.  Normally, this is set automatically when the</span>
 <span class="s0">* image is loaded, for instance via Texture::read().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void Texture::set_fullpath(Filename const &amp;fullpath);</span>

<span class="s0">2600 14 clear_fullpath 0 4 3276 23 Texture::clear_fullpath 0 1 1043 85</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the alpha fullpath, if it was previously set.  See set_fullpath().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void Texture::clear_fullpath(void);</span>

<span class="s0">2601 18 has_alpha_fullpath 0 4 3276 27 Texture::has_alpha_fullpath 0 1 1044 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the alpha_fullpath has been set and is available.  See</span>
 <span class="s0">* set_alpha_fullpath().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool Texture::has_alpha_fullpath(void) const;</span>

<span class="s0">2602 18 get_alpha_fullpath 0 4 3276 27 Texture::get_alpha_fullpath 0 1 1045 168</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the alpha_fullpath that has been set.  This is the full path to the</span>
 <span class="s0">* alpha part of the image file as it was found along the texture search path.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline Filename const &amp;Texture::get_alpha_fullpath(void) const;</span>

<span class="s0">2603 18 set_alpha_fullpath 0 4 3276 27 Texture::set_alpha_fullpath 0 1 1046 230</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the full pathname to the file that contains the image's alpha channel</span>
 <span class="s0">* contents, as found along the search path.  Normally, this is set</span>
 <span class="s0">* automatically when the image is loaded, for instance via Texture::read().</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void Texture::set_alpha_fullpath(Filename const &amp;alpha_fullpath);</span>

<span class="s0">2604 20 clear_alpha_fullpath 0 4 3276 29 Texture::clear_alpha_fullpath 0 1 1047 94</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the alpha fullpath, if it was previously set.  See</span>
 <span class="s0">* set_alpha_fullpath().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void Texture::clear_alpha_fullpath(void);</span>

<span class="s0">2605 10 get_x_size 0 4 3276 19 Texture::get_x_size 0 1 1048 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the width of the texture image in texels.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int Texture::get_x_size(void) const;</span>

<span class="s0">2606 10 set_x_size 0 4 3276 19 Texture::set_x_size 0 1 1049 132</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the x size indicated for the texture.  This also implicitly unloads</span>
 <span class="s0">* the texture if it has already been loaded.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void Texture::set_x_size(int x_size);</span>

<span class="s0">2607 10 get_y_size 0 4 3276 19 Texture::get_y_size 0 1 1050 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the height of the texture image in texels.  For a 1-d texture, this</span>
 <span class="s0">* will be 1.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int Texture::get_y_size(void) const;</span>

<span class="s0">2608 10 set_y_size 0 4 3276 19 Texture::set_y_size 0 1 1051 132</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the y size indicated for the texture.  This also implicitly unloads</span>
 <span class="s0">* the texture if it has already been loaded.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void Texture::set_y_size(int y_size);</span>

<span class="s0">2609 10 get_z_size 0 4 3276 19 Texture::get_z_size 0 1 1052 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the depth of the texture image in texels.  For a 1-d texture or 2-d</span>
 <span class="s0">* texture, this will be 1. For a cube map texture, this will be 6.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int Texture::get_z_size(void) const;</span>

<span class="s0">2610 10 set_z_size 0 4 3276 19 Texture::set_z_size 0 1 1053 132</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the z size indicated for the texture.  This also implicitly unloads</span>
 <span class="s0">* the texture if it has already been loaded.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void Texture::set_z_size(int z_size);</span>

<span class="s0">2611 13 get_num_views 0 4 3276 22 Texture::get_num_views 0 1 1054 426</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of &quot;views&quot; in the texture.  A view is a completely</span>
 <span class="s0">* separate image stored within the Texture object.  Most textures have only</span>
 <span class="s0">* one view, but a stereo texture, for instance, may have two views, a left</span>
 <span class="s0">* and a right image.  Other uses for multiple views are not yet defined.</span>
 <span class="s0">*</span>
 <span class="s0">* If this value is greater than one, the additional views are accessed as</span>
 <span class="s0">* additional pages beyond get_z_size().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline int Texture::get_num_views(void) const;</span>

<span class="s0">2612 13 set_num_views 0 4 3276 22 Texture::set_num_views 0 1 1055 503</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the number of &quot;views&quot; within a texture.  A view is a completely</span>
 <span class="s0">* separate image stored within the Texture object.  Most textures have only</span>
 <span class="s0">* one view, but a stereo texture, for instance, may have two views, a left</span>
 <span class="s0">* and a right image.  Other uses for multiple views are not yet defined.</span>
 <span class="s0">*</span>
 <span class="s0">* If this value is greater than one, the additional views are accessed as</span>
 <span class="s0">* additional pages beyond get_z_size().</span>
 <span class="s0">*</span>
 <span class="s0">* This also implicitly unloads the texture if it has already been loaded.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void Texture::set_num_views(int num_views);</span>

<span class="s0">2613 13 get_num_pages 0 4 3276 22 Texture::get_num_pages 0 1 1056 318</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of pages in the texture.  Each &quot;page&quot; is a 2-d</span>
 <span class="s0">* texture image within the larger image--a face of a cube map, or a level of</span>
 <span class="s0">* a 3-d texture.  Normally, get_num_pages() is the same as get_z_size().</span>
 <span class="s0">* However, in a multiview texture, this returns get_z_size() *</span>
 <span class="s0">* get_num_views().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline int Texture::get_num_pages(void) const;</span>

<span class="s0">2614 18 get_num_components 0 4 3276 27 Texture::get_num_components 0 1 1057 194</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of color components for each texel of the texture image.</span>
 <span class="s0">* This is 3 for an rgb texture or 4 for an rgba texture; it may also be 1 or</span>
 <span class="s0">* 2 for a grayscale texture.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int Texture::get_num_components(void) const;</span>

<span class="s0">2615 19 get_component_width 0 4 3276 28 Texture::get_component_width 0 1 1058 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes stored for each color component of a texel.</span>
 <span class="s0">* Typically this is 1, but it may be 2 for 16-bit texels.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int Texture::get_component_width(void) const;</span>

<span class="s0">2616 16 get_texture_type 0 4 3276 25 Texture::get_texture_type 0 1 1059 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the overall interpretation of the texture.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline Texture::TextureType Texture::get_texture_type(void) const;</span>

<span class="s0">2617 14 get_usage_hint 0 4 3276 23 Texture::get_usage_hint 0 1 1060 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the usage hint specified for buffer textures, or UH_unspecified for</span>
 <span class="s0">* all other texture types.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline GeomEnums::UsageHint Texture::get_usage_hint(void) const;</span>

<span class="s0">2618 10 get_format 0 4 3276 19 Texture::get_format 0 1 1061 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the format of the texture, which represents both the semantic</span>
 <span class="s0">* meaning of the texels and, to some extent, their storage information.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline Texture::Format Texture::get_format(void) const;</span>

<span class="s0">2619 10 set_format 0 4 3276 19 Texture::set_format 0 1 1062 112</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the format value for the texture components.  This implicitly sets</span>
 <span class="s0">* num_components as well.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void Texture::set_format(Texture::Format format);</span>

<span class="s0">2620 18 get_component_type 0 4 3276 27 Texture::get_component_type 0 1 1063 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the numeric interpretation of each component of the texture.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline Texture::ComponentType Texture::get_component_type(void) const;</span>

<span class="s0">2621 18 set_component_type 0 4 3276 27 Texture::set_component_type 0 1 1064 111</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the data value for the texture components.  This implicitly sets</span>
 <span class="s0">* component_width as well.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline void Texture::set_component_type(Texture::ComponentType component_type);</span>

<span class="s0">2622 10 get_wrap_u 0 4 3276 19 Texture::get_wrap_u 0 1 1065 208</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the wrap mode of the texture in the U direction.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline SamplerState::WrapMode Texture::get_wrap_u(void) const;</span>

<span class="s0">2623 10 set_wrap_u 0 4 3276 19 Texture::set_wrap_u 0 1 1066 349</span>
<span class="s0">/**</span>
 <span class="s0">* This setting determines what happens when the texture is sampled with a U</span>
 <span class="s0">* value outside the range 0.0-1.0.  The default is WM_repeat, which indicates</span>
 <span class="s0">* that the texture should repeat indefinitely.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void Texture::set_wrap_u(Texture::WrapMode wrap);</span>

<span class="s0">2624 10 get_wrap_v 0 4 3276 19 Texture::get_wrap_v 0 1 1067 208</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the wrap mode of the texture in the V direction.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline SamplerState::WrapMode Texture::get_wrap_v(void) const;</span>

<span class="s0">2625 10 set_wrap_v 0 4 3276 19 Texture::set_wrap_v 0 1 1068 349</span>
<span class="s0">/**</span>
 <span class="s0">* This setting determines what happens when the texture is sampled with a V</span>
 <span class="s0">* value outside the range 0.0-1.0.  The default is WM_repeat, which indicates</span>
 <span class="s0">* that the texture should repeat indefinitely.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void Texture::set_wrap_v(Texture::WrapMode wrap);</span>

<span class="s0">2626 10 get_wrap_w 0 4 3276 19 Texture::get_wrap_w 0 1 1069 257</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the wrap mode of the texture in the W direction.  This is the depth</span>
 <span class="s0">* direction of 3-d textures.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline SamplerState::WrapMode Texture::get_wrap_w(void) const;</span>

<span class="s0">2627 10 set_wrap_w 0 4 3276 19 Texture::set_wrap_w 0 1 1070 200</span>
<span class="s0">/**</span>
 <span class="s0">* The W wrap direction is only used for 3-d textures.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void Texture::set_wrap_w(Texture::WrapMode wrap);</span>

<span class="s0">2628 13 get_minfilter 0 4 3276 22 Texture::get_minfilter 0 1 1071 355</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filter mode of the texture for minification.  If this is one of</span>
 <span class="s0">* the mipmap constants, then the texture requires mipmaps.  This may return</span>
 <span class="s0">* FT_default; see also get_effective_minfilter().</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline SamplerState::FilterType Texture::get_minfilter(void) const;</span>

<span class="s0">2629 23 get_effective_minfilter 0 4 3276 32 Texture::get_effective_minfilter 0 1 1072 341</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filter mode of the texture for minification, with special</span>
 <span class="s0">* treatment for FT_default.  This will normally not return FT_default, unless</span>
 <span class="s0">* there is an error in the config file.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline SamplerState::FilterType Texture::get_effective_minfilter(void) const;</span>

<span class="s0">2630 13 set_minfilter 0 4 3276 22 Texture::set_minfilter 0 1 1073 239</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the filtering method that should be used when viewing the texture from</span>
 <span class="s0">* a distance.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void Texture::set_minfilter(Texture::FilterType filter);</span>

<span class="s0">2631 13 get_magfilter 0 4 3276 22 Texture::get_magfilter 0 1 1074 320</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filter mode of the texture for magnification.  The mipmap</span>
 <span class="s0">* constants are invalid here.  This may return FT_default; see also</span>
 <span class="s0">* get_effective_minfilter().</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline SamplerState::FilterType Texture::get_magfilter(void) const;</span>

<span class="s0">2632 23 get_effective_magfilter 0 4 3276 32 Texture::get_effective_magfilter 0 1 1075 342</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filter mode of the texture for magnification, with special</span>
 <span class="s0">* treatment for FT_default.  This will normally not return FT_default, unless</span>
 <span class="s0">* there is an error in the config file.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline SamplerState::FilterType Texture::get_effective_magfilter(void) const;</span>

<span class="s0">2633 13 set_magfilter 0 4 3276 22 Texture::set_magfilter 0 1 1076 232</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the filtering method that should be used when viewing the texture up</span>
 <span class="s0">* close.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void Texture::set_magfilter(Texture::FilterType filter);</span>

<span class="s0">2634 22 get_anisotropic_degree 0 4 3276 31 Texture::get_anisotropic_degree 0 1 1077 339</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the degree of anisotropic filtering that should be applied to the</span>
 <span class="s0">* texture.  This value may return 0, indicating the default value; see also</span>
 <span class="s0">* get_effective_anisotropic_degree.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int Texture::get_anisotropic_degree(void) const;</span>

<span class="s0">2635 32 get_effective_anisotropic_degree 0 4 3276 41 Texture::get_effective_anisotropic_degree 0 1 1078 325</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the degree of anisotropic filtering that should be applied to the</span>
 <span class="s0">* texture.  This value will normally not return 0, unless there is an error</span>
 <span class="s0">* in the config file.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int Texture::get_effective_anisotropic_degree(void) const;</span>

<span class="s0">2636 22 set_anisotropic_degree 0 4 3276 31 Texture::set_anisotropic_degree 0 1 1079 548</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the level of anisotropic filtering to apply to the texture.  Set</span>
 <span class="s0">* this 0 to indicate the default value, which is specified in the texture-</span>
 <span class="s0">* anisotropic-degree config variable.</span>
 <span class="s0">*</span>
 <span class="s0">* To explicitly disable anisotropic filtering, set this value to 1.  To</span>
 <span class="s0">* explicitly enable anisotropic filtering, set it to a value higher than 1;</span>
 <span class="s0">* larger numbers indicate greater degrees of filtering.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void Texture::set_anisotropic_degree(int anisotropic_degree);</span>

<span class="s0">2637 16 get_border_color 0 4 3276 25 Texture::get_border_color 0 1 1080 327</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the solid color of the texture's border.  Some OpenGL</span>
 <span class="s0">* implementations use a border for tiling textures; in Panda, it is only used</span>
 <span class="s0">* for specifying the clamp color.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LColor Texture::get_border_color(void) const;</span>

<span class="s0">2638 16 set_border_color 0 4 3276 25 Texture::set_border_color 0 1 1081 326</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the solid color of the texture's border.  Some OpenGL</span>
 <span class="s0">* implementations use a border for tiling textures; in Panda, it is only used</span>
 <span class="s0">* for specifying the clamp color.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void Texture::set_border_color(LColor const &amp;color);</span>

<span class="s0">2639 15 has_compression 0 4 3276 24 Texture::has_compression 0 1 1082 430</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture indicates it wants to be compressed, either</span>
 <span class="s0">* with CM_on or higher, or CM_default and compressed-textures is true.</span>
 <span class="s0">*</span>
 <span class="s0">* If true returned, this is not a guarantee that the texture is actually</span>
 <span class="s0">* successfully compressed on the GSG.  It may be that the GSG does not</span>
 <span class="s0">* support the requested compression mode, in which case the texture may</span>
 <span class="s0">* actually be stored uncompressed in texture memory.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool Texture::has_compression(void) const;</span>

<span class="s0">2640 15 get_compression 0 4 3276 24 Texture::get_compression 0 1 1083 431</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the compression mode requested for this particular texture, or</span>
 <span class="s0">* CM_off if the texture is not to be compressed.</span>
 <span class="s0">*</span>
 <span class="s0">* If a value other than CM_off is returned, this is not a guarantee that the</span>
 <span class="s0">* texture is actually successfully compressed on the GSG.  It may be that the</span>
 <span class="s0">* GSG does not support the requested compression mode, in which case the</span>
 <span class="s0">* texture may actually be stored uncompressed in texture memory.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline Texture::CompressionMode Texture::get_compression(void) const;</span>

<span class="s0">2641 15 set_compression 0 4 3276 24 Texture::set_compression 0 1 1084 645</span>
<span class="s0">/**</span>
 <span class="s0">* Requests that this particular Texture be compressed when it is loaded into</span>
 <span class="s0">* texture memory.</span>
 <span class="s0">*</span>
 <span class="s0">* This refers to the internal compression of the texture image within texture</span>
 <span class="s0">* memory; it is not related to jpeg or png compression, which are disk file</span>
 <span class="s0">* compression formats.  The actual disk file that generated this texture may</span>
 <span class="s0">* be stored in a compressed or uncompressed format supported by Panda; it</span>
 <span class="s0">* will be decompressed on load, and then recompressed by the graphics API if</span>
 <span class="s0">* this parameter is not CM_off.</span>
 <span class="s0">*</span>
 <span class="s0">* If the GSG does not support this texture compression mode, the texture will</span>
 <span class="s0">* silently be loaded uncompressed.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void Texture::set_compression(Texture::CompressionMode compression);</span>

<span class="s0">2642 21 get_render_to_texture 0 4 3276 30 Texture::get_render_to_texture 0 1 1085 378</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a flag on the texture that indicates whether the texture is</span>
 <span class="s0">* intended to be used as a direct-render target, by binding a framebuffer to</span>
 <span class="s0">* a texture and rendering directly into the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, a user should not need to set this flag directly; it is set</span>
 <span class="s0">* automatically by the low-level display code when a texture is bound to a</span>
 <span class="s0">* framebuffer.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool Texture::get_render_to_texture(void) const;</span>

<span class="s0">2643 21 set_render_to_texture 0 4 3276 30 Texture::set_render_to_texture 0 1 1086 539</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a flag on the texture that indicates whether the texture is intended</span>
 <span class="s0">* to be used as a direct-render target, by binding a framebuffer to a texture</span>
 <span class="s0">* and rendering directly into the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* This controls some low-level choices made about the texture object itself.</span>
 <span class="s0">* For instance, compressed textures are disallowed when this flag is set</span>
 <span class="s0">* true.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, a user should not need to set this flag directly; it is set</span>
 <span class="s0">* automatically by the low-level display code when a texture is bound to a</span>
 <span class="s0">* framebuffer.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void Texture::set_render_to_texture(bool render_to_texture);</span>

<span class="s0">2644 19 get_default_sampler 0 4 3276 28 Texture::get_default_sampler 0 1 1087 222</span>
<span class="s0">/**</span>
 <span class="s0">* This returns the default sampler state for this texture, containing the</span>
 <span class="s0">* wrap and filter properties specified on the texture level; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline SamplerState const &amp;Texture::get_default_sampler(void) const;</span>

<span class="s0">2645 19 set_default_sampler 0 4 3276 28 Texture::set_default_sampler 0 1 1088 502</span>
<span class="s0">/**</span>
 <span class="s0">* This sets the default sampler state for this texture, containing the wrap</span>
 <span class="s0">* and filter properties specified on the texture level; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.  This</span>
 <span class="s0">* encompasses the settings for get_wrap_u, get_minfilter,</span>
 <span class="s0">* get_anisotropic_degree, etc.</span>
 <span class="s0">*</span>
 <span class="s0">* This makes a copy of the SamplerState object, so future modifications of</span>
 <span class="s0">* the same SamplerState will have no effect on this texture unless you call</span>
 <span class="s0">* set_default_sampler again.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void Texture::set_default_sampler(SamplerState const &amp;sampler);</span>

<span class="s0">2646 12 uses_mipmaps 0 4 3276 21 Texture::uses_mipmaps 0 1 1089 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the minfilter settings on this texture indicate the use of</span>
 <span class="s0">* mipmapping, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool Texture::uses_mipmaps(void) const;</span>

<span class="s0">2647 17 get_quality_level 0 4 3276 26 Texture::get_quality_level 0 1 1090 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current quality_level hint.  See set_quality_level().  This</span>
 <span class="s0">* value may return QL_default; see get_effective_quality_level().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline Texture::QualityLevel Texture::get_quality_level(void) const;</span>

<span class="s0">2648 27 get_effective_quality_level 0 4 3276 36 Texture::get_effective_quality_level 0 1 1091 235</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current quality_level hint, or the global default quality_level</span>
 <span class="s0">* if this texture doesn't specify a quality level.  This value will not</span>
 <span class="s0">* normally return QL_default (unless there is an error in the config file)</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline Texture::QualityLevel Texture::get_effective_quality_level(void) const;</span>

<span class="s0">2649 17 set_quality_level 0 4 3276 26 Texture::set_quality_level 0 1 1092 264</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a hint to the renderer about the desired performance / quality</span>
 <span class="s0">* tradeoff for this particular texture.  This is most useful for the</span>
 <span class="s0">* tinydisplay software renderer; for normal, hardware-accelerated renderers,</span>
 <span class="s0">* this may have little or no effect.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void Texture::set_quality_level(Texture::QualityLevel quality_level);</span>

<span class="s0">2650 30 get_expected_num_mipmap_levels 0 4 3276 39 Texture::get_expected_num_mipmap_levels 0 1 1093 249</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of mipmap levels that should be defined for this</span>
 <span class="s0">* texture, given the texture's size.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this returns a number appropriate for mipmapping, even if the</span>
 <span class="s0">* texture does not currently have mipmapping enabled.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int Texture::get_expected_num_mipmap_levels(void) const;</span>

<span class="s0">2651 26 get_expected_mipmap_x_size 0 4 3276 35 Texture::get_expected_mipmap_x_size 0 1 1094 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x_size that the nth mipmap level should have, based on the</span>
 <span class="s0">* texture's size.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int Texture::get_expected_mipmap_x_size(int n) const;</span>

<span class="s0">2652 26 get_expected_mipmap_y_size 0 4 3276 35 Texture::get_expected_mipmap_y_size 0 1 1095 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the y_size that the nth mipmap level should have, based on the</span>
 <span class="s0">* texture's size.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int Texture::get_expected_mipmap_y_size(int n) const;</span>

<span class="s0">2653 26 get_expected_mipmap_z_size 0 4 3276 35 Texture::get_expected_mipmap_z_size 0 1 1096 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the z_size that the nth mipmap level should have, based on the</span>
 <span class="s0">* texture's size.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int Texture::get_expected_mipmap_z_size(int n) const;</span>

<span class="s0">2654 29 get_expected_mipmap_num_pages 0 4 3276 38 Texture::get_expected_mipmap_num_pages 0 1 1097 280</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of pages that the nth mipmap level should have,</span>
 <span class="s0">* based on the texture's size.  This is usually the same as</span>
 <span class="s0">* get_expected_mipmap_z_size(), except for a multiview texture, in which case</span>
 <span class="s0">* it is get_expected_mipmap_z_size() * get_num_views().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int Texture::get_expected_mipmap_num_pages(int n) const;</span>

<span class="s0">2655 13 has_ram_image 0 4 3276 22 Texture::has_ram_image 0 1 1098 1090</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Texture has its image contents available in main RAM,</span>
 <span class="s0">* false if it exists only in texture memory or in the prepared GSG context.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this has nothing to do with whether get_ram_image() will fail or</span>
 <span class="s0">* not.  Even if has_ram_image() returns false, get_ram_image() may still</span>
 <span class="s0">* return a valid RAM image, because get_ram_image() will automatically load</span>
 <span class="s0">* the texture from disk if necessary.  The only thing has_ram_image() tells</span>
 <span class="s0">* you is whether the texture is available right now without hitting the disk</span>
 <span class="s0">* first.</span>
 <span class="s0">*</span>
 <span class="s0">* Note also that if an application uses only one GSG, it may appear that</span>
 <span class="s0">* has_ram_image() returns true if the texture has not yet been loaded by the</span>
 <span class="s0">* GSG, but this correlation is not true in general and should not be depended</span>
 <span class="s0">* on.  Specifically, if an application ever uses multiple GSG's in its</span>
 <span class="s0">* lifetime (for instance, by opening more than one window, or by closing its</span>
 <span class="s0">* window and opening another one later), then has_ram_image() may well return</span>
 <span class="s0">* false on textures that have never been loaded on the current GSG.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool Texture::has_ram_image(void) const;</span>

<span class="s0">2656 26 has_uncompressed_ram_image 0 4 3276 35 Texture::has_uncompressed_ram_image 0 1 1099 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Texture has its image contents available in main RAM</span>
 <span class="s0">* and is uncompressed, false otherwise.  See has_ram_image().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool Texture::has_uncompressed_ram_image(void) const;</span>

<span class="s0">2657 20 might_have_ram_image 0 4 3276 29 Texture::might_have_ram_image 0 1 1100 284</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture's image contents are currently available in</span>
 <span class="s0">* main RAM, or there is reason to believe it can be loaded on demand.  That</span>
 <span class="s0">* is, this function returns a &quot;best guess&quot; as to whether get_ram_image() will</span>
 <span class="s0">* succeed without actually calling it first.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool Texture::might_have_ram_image(void) const;</span>

<span class="s0">2658 18 get_ram_image_size 0 4 3276 27 Texture::get_ram_image_size 0 1 1101 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes used by the in-memory image, across all</span>
 <span class="s0">* pages and views, or 0 if there is no in-memory image.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::size_t Texture::get_ram_image_size(void) const;</span>

<span class="s0">2659 17 get_ram_view_size 0 4 3276 26 Texture::get_ram_view_size 0 1 1102 208</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image per view, or 0 if</span>
 <span class="s0">* there is no in-memory image.  Since each view is a stack of z_size pages,</span>
 <span class="s0">* this is get_z_size() * get_ram_page_size().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline std::size_t Texture::get_ram_view_size(void) const;</span>

<span class="s0">2660 17 get_ram_page_size 0 4 3276 26 Texture::get_ram_page_size 0 1 1103 345</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image per page, or 0 if</span>
 <span class="s0">* there is no in-memory image.</span>
 <span class="s0">*</span>
 <span class="s0">* For a non-compressed texture, this is the same as</span>
 <span class="s0">* get_expected_ram_page_size().  For a compressed texture, this may be a</span>
 <span class="s0">* smaller value.  (We do assume that all pages will be the same size on a</span>
 <span class="s0">* compressed texture).</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline std::size_t Texture::get_ram_page_size(void) const;</span>

<span class="s0">2661 27 get_expected_ram_image_size 0 4 3276 36 Texture::get_expected_ram_image_size 0 1 1104 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes that *ought* to be used by the in-memory image,</span>
 <span class="s0">* based on the texture parameters.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline std::size_t Texture::get_expected_ram_image_size(void) const;</span>

<span class="s0">2662 26 get_expected_ram_page_size 0 4 3276 35 Texture::get_expected_ram_page_size 0 1 1105 178</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes that should be used per each Z page of the 3-d</span>
 <span class="s0">* texture.  For a 2-d or 1-d texture, this is the same as</span>
 <span class="s0">* get_expected_ram_image_size().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline std::size_t Texture::get_expected_ram_page_size(void) const;</span>

<span class="s0">2663 13 get_ram_image 0 4 3276 22 Texture::get_ram_image 0 1 1106 1159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the system-RAM image data associated with the texture.  If the</span>
 <span class="s0">* texture does not currently have an associated RAM image, and the texture</span>
 <span class="s0">* was generated by loading an image from a disk file (the most common case),</span>
 <span class="s0">* this forces the reload of the same texture.  This can happen if</span>
 <span class="s0">* keep_texture_ram is configured to false, and we have previously prepared</span>
 <span class="s0">* this texture with a GSG.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that it is not correct to call has_ram_image() first to test whether</span>
 <span class="s0">* this function will fail.  A false return value from has_ram_image()</span>
 <span class="s0">* indicates only that get_ram_image() may need to reload the texture from</span>
 <span class="s0">* disk, which it will do automatically.  However, you can call</span>
 <span class="s0">* might_have_ram_image(), which will return true if the ram image exists, or</span>
 <span class="s0">* there is a reasonable reason to believe it can be loaded.</span>
 <span class="s0">*</span>
 <span class="s0">* On the other hand, it is possible that the texture cannot be found on disk</span>
 <span class="s0">* or is otherwise unavailable.  If that happens, this function will return</span>
 <span class="s0">* NULL. There is no way to predict with 100% accuracy whether get_ram_image()</span>
 <span class="s0">* will return NULL without calling it first; might_have_ram_image() is the</span>
 <span class="s0">* closest.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline CPTA_uchar Texture::get_ram_image(void);</span>

<span class="s0">2664 25 get_ram_image_compression 0 4 3276 34 Texture::get_ram_image_compression 0 1 1107 338</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the compression mode in which the ram image is already stored pre-</span>
 <span class="s0">* compressed.  If this is other than CM_off, you cannot rely on the contents</span>
 <span class="s0">* of the ram image to be anything predicatable (it will not be an array of x</span>
 <span class="s0">* by y pixels, and it probably won't have the same length as</span>
 <span class="s0">* get_expected_ram_image_size()).</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline Texture::CompressionMode Texture::get_ram_image_compression(void) const;</span>

<span class="s0">2665 26 get_uncompressed_ram_image 0 4 3276 35 Texture::get_uncompressed_ram_image 0 1 1108 586</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the system-RAM image associated with the texture, in an</span>
 <span class="s0">* uncompressed form if at all possible.</span>
 <span class="s0">*</span>
 <span class="s0">* If get_ram_image_compression() is CM_off, then the system-RAM image is</span>
 <span class="s0">* already uncompressed, and this returns the same thing as get_ram_image().</span>
 <span class="s0">*</span>
 <span class="s0">* If get_ram_image_compression() is anything else, then the system-RAM image</span>
 <span class="s0">* is compressed.  In this case, the image will be reloaded from the</span>
 <span class="s0">* *original* file (not from the cache), in the hopes that an uncompressed</span>
 <span class="s0">* image will be found there.</span>
 <span class="s0">*</span>
 <span class="s0">* If an uncompressed image cannot be found, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline CPTA_uchar Texture::get_uncompressed_ram_image(void);</span>

<span class="s0">2666 16 get_ram_image_as 0 4 3276 25 Texture::get_ram_image_as 0 1 1109 1220</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the uncompressed system-RAM image data associated with the texture.</span>
 <span class="s0">* Rather than just returning a pointer to the data, like</span>
 <span class="s0">* get_uncompressed_ram_image, this function first processes the data and</span>
 <span class="s0">* reorders the components using the specified format string, and places these</span>
 <span class="s0">* into a new char array.</span>
 <span class="s0">*</span>
 <span class="s0">* The 'format' argument should specify in which order the components of the</span>
 <span class="s0">* texture must be.  For example, valid format strings are &quot;RGBA&quot;, &quot;GA&quot;,</span>
 <span class="s0">* &quot;ABRG&quot; or &quot;AAA&quot;.  A component can also be written as &quot;0&quot; or &quot;1&quot;, which</span>
 <span class="s0">* means an empty/black or a full/white channel, respectively.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is particularly useful to copy an image in-memory to a</span>
 <span class="s0">* different library (for example, PIL or wxWidgets) that require a different</span>
 <span class="s0">* component order than Panda's internal format, BGRA. Note, however, that</span>
 <span class="s0">* this conversion can still be too slow if you want to do it every frame, and</span>
 <span class="s0">* should thus be avoided for that purpose.</span>
 <span class="s0">*</span>
 <span class="s0">* The only requirement for the reordering is that an uncompressed image must</span>
 <span class="s0">* be available.  If the RAM image is compressed, it will attempt to re-load</span>
 <span class="s0">* the texture from disk, if it doesn't find an uncompressed image there, it</span>
 <span class="s0">* will return NULL.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">CPTA_uchar Texture::get_ram_image_as(std::string const &amp;requested_format);</span>

<span class="s0">2667 16 modify_ram_image 0 4 3276 25 Texture::modify_ram_image 0 1 1110 246</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the system-RAM image.  This assumes the RAM</span>
 <span class="s0">* image should be uncompressed.  If the RAM image has been dumped, or is</span>
 <span class="s0">* stored compressed, creates a new one.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline PTA_uchar Texture::modify_ram_image(void);</span>

<span class="s0">2668 14 make_ram_image 0 4 3276 23 Texture::make_ram_image 0 1 1111 198</span>
<span class="s0">/**</span>
 <span class="s0">* Discards the current system-RAM image for the texture, if any, and</span>
 <span class="s0">* allocates a new buffer of the appropriate size.  Returns the new buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline PTA_uchar Texture::make_ram_image(void);</span>

<span class="s0">2669 13 set_ram_image 0 4 3276 22 Texture::set_ram_image 0 1 1112 231</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the current system-RAM image with the new data.  If compression is</span>
 <span class="s0">* not CM_off, it indicates that the new data is already pre-compressed in the</span>
 <span class="s0">* indicated format.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/</span>
<span class="s0">130</span>
<span class="s0">void Texture::set_ram_image(PyObject *image, Texture::CompressionMode compression = ::Texture::CM_off, std::size_t page_size = 0);</span>

<span class="s0">2670 16 set_ram_image_as 0 4 3276 25 Texture::set_ram_image_as 0 1 1113 307</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the current system-RAM image with the new data, converting it</span>
 <span class="s0">* first if necessary from the indicated component-order format.  See</span>
 <span class="s0">* get_ram_image_as() for specifications about the format.  This method cannot</span>
 <span class="s0">* support compressed image data or sub-pages; use set_ram_image() for that.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">void Texture::set_ram_image_as(PyObject *image, std::string const &amp;provided_format);</span>

<span class="s0">2671 15 clear_ram_image 0 4 3276 24 Texture::clear_ram_image 0 1 1114 49</span>
<span class="s0">/**</span>
 <span class="s0">* Discards the current system-RAM image.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void Texture::clear_ram_image(void);</span>

<span class="s0">2672 18 set_keep_ram_image 0 4 3276 27 Texture::set_keep_ram_image 0 1 1115 476</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates whether this Texture is eligible to have its</span>
 <span class="s0">* main RAM copy of the texture memory dumped when the texture is prepared for</span>
 <span class="s0">* rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* This will be false for most textures, which can reload their images if</span>
 <span class="s0">* needed by rereading the input file.  However, textures that were generated</span>
 <span class="s0">* dynamically and cannot be easily reloaded will want to set this flag to</span>
 <span class="s0">* true, so that the texture will always keep its image copy around.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void Texture::set_keep_ram_image(bool keep_ram_image);</span>

<span class="s0">2673 18 get_keep_ram_image 0 6 3276 27 Texture::get_keep_ram_image 0 1 1116 207</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that indicates whether this Texture is eligible to have</span>
 <span class="s0">* its main RAM copy of the texture memory dumped when the texture is prepared</span>
 <span class="s0">* for rendering.  See set_keep_ram_image().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">virtual bool Texture::get_keep_ram_image(void) const;</span>

<span class="s0">2674 12 is_cacheable 0 6 3276 21 Texture::is_cacheable 0 1 1117 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is enough information in this Texture object to write</span>
 <span class="s0">* it to the bam cache successfully, false otherwise.  For most textures, this</span>
 <span class="s0">* is the same as has_ram_image().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">virtual bool Texture::is_cacheable(void) const;</span>

<span class="s0">2675 12 __deepcopy__ 0 4 3276 21 Texture::__deepcopy__ 0 1 1118 0</span>
<span class="s0">65</span>
<span class="s0">PointerTo&lt; Texture &gt; Texture::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">2676 18 compress_ram_image 0 4 3276 27 Texture::compress_ram_image 0 1 1119 802</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to compress the texture's RAM image internally, to a format</span>
 <span class="s0">* supported by the indicated GSG.  In order for this to work, the squish</span>
 <span class="s0">* library must have been compiled into Panda.</span>
 <span class="s0">*</span>
 <span class="s0">* If compression is CM_on, then an appropriate compression method that is</span>
 <span class="s0">* supported by the indicated GSG is automatically chosen.  If the GSG pointer</span>
 <span class="s0">* is NULL, any of the standard DXT1/3/5 compression methods will be used,</span>
 <span class="s0">* regardless of whether it is supported.</span>
 <span class="s0">*</span>
 <span class="s0">* If compression is any specific compression method, that method is used</span>
 <span class="s0">* regardless of whether the GSG supports it.</span>
 <span class="s0">*</span>
 <span class="s0">* quality_level determines the speed/quality tradeoff of the compression.  If</span>
 <span class="s0">* it is QL_default, the texture's own quality_level parameter is used.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">200</span>
<span class="s0">inline bool Texture::compress_ram_image(Texture::CompressionMode compression = ::Texture::CM_on, Texture::QualityLevel quality_level = ::Texture::QL_default, GraphicsStateGuardianBase *gsg = nullptr);</span>

<span class="s0">2677 20 uncompress_ram_image 0 4 3276 29 Texture::uncompress_ram_image 0 1 1120 279</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to uncompress the texture's RAM image internally.  In order for</span>
 <span class="s0">* this to work, the squish library must have been compiled into Panda, and</span>
 <span class="s0">* the ram image must be compressed in a format supported by squish.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool Texture::uncompress_ram_image(void);</span>

<span class="s0">2678 25 get_num_ram_mipmap_images 0 4 3276 34 Texture::get_num_ram_mipmap_images 0 1 1121 285</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum number of mipmap level images available in system</span>
 <span class="s0">* memory.  The actual number may be less than this (that is, there might be</span>
 <span class="s0">* gaps in the sequence); use has_ram_mipmap_image() to verify each level.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see get_num_loadable_ram_mipmap_images().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int Texture::get_num_ram_mipmap_images(void) const;</span>

<span class="s0">2679 20 has_ram_mipmap_image 0 4 3276 29 Texture::has_ram_mipmap_image 0 1 1122 317</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Texture has the nth mipmap level available in system</span>
 <span class="s0">* memory, false otherwise.  If the texture's minfilter mode requires</span>
 <span class="s0">* mipmapping (see uses_mipmaps()), and all the texture's mipmap levels are</span>
 <span class="s0">* not available when the texture is rendered, they will be generated</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool Texture::has_ram_mipmap_image(int n) const;</span>

<span class="s0">2680 34 get_num_loadable_ram_mipmap_images 0 4 3276 43 Texture::get_num_loadable_ram_mipmap_images 0 1 1123 558</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of contiguous mipmap levels that exist in RAM, up until</span>
 <span class="s0">* the first gap in the sequence.  It is guaranteed that at least mipmap</span>
 <span class="s0">* levels [0, get_num_ram_mipmap_images()) exist.</span>
 <span class="s0">*</span>
 <span class="s0">* The number returned will never exceed the number of required mipmap images</span>
 <span class="s0">* based on the size of the texture and its filter mode.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is different from get_num_ram_mipmap_images() in that it</span>
 <span class="s0">* returns only the number of mipmap levels that can actually be usefully</span>
 <span class="s0">* loaded, regardless of the actual number that may be stored.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">int Texture::get_num_loadable_ram_mipmap_images(void) const;</span>

<span class="s0">2681 25 has_all_ram_mipmap_images 0 4 3276 34 Texture::has_all_ram_mipmap_images 0 1 1124 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all expected mipmap levels have been defined and exist in</span>
 <span class="s0">* the system RAM, or false if even one mipmap level is missing.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool Texture::has_all_ram_mipmap_images(void) const;</span>

<span class="s0">2682 25 get_ram_mipmap_image_size 0 4 3276 34 Texture::get_ram_mipmap_image_size 0 1 1125 148</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image for mipmap level n,</span>
 <span class="s0">* or 0 if there is no in-memory image for this mipmap level.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline std::size_t Texture::get_ram_mipmap_image_size(int n) const;</span>

<span class="s0">2683 24 get_ram_mipmap_view_size 0 4 3276 33 Texture::get_ram_mipmap_view_size 0 1 1126 542</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image per view for mipmap</span>
 <span class="s0">* level n, or 0 if there is no in-memory image for this mipmap level.</span>
 <span class="s0">*</span>
 <span class="s0">* A &quot;view&quot; is a collection of z_size pages for each mipmap level.  Most</span>
 <span class="s0">* textures have only one view, except for multiview or stereo textures.</span>
 <span class="s0">*</span>
 <span class="s0">* For a non-compressed texture, this is the same as</span>
 <span class="s0">* get_expected_ram_mipmap_view_size().  For a compressed texture, this may be</span>
 <span class="s0">* a smaller value.  (We do assume that all pages will be the same size on a</span>
 <span class="s0">* compressed texture).</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::size_t Texture::get_ram_mipmap_view_size(int n) const;</span>

<span class="s0">2684 24 get_ram_mipmap_page_size 0 4 3276 33 Texture::get_ram_mipmap_page_size 0 1 1127 393</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image per page for mipmap</span>
 <span class="s0">* level n, or 0 if there is no in-memory image for this mipmap level.</span>
 <span class="s0">*</span>
 <span class="s0">* For a non-compressed texture, this is the same as</span>
 <span class="s0">* get_expected_ram_mipmap_page_size().  For a compressed texture, this may be</span>
 <span class="s0">* a smaller value.  (We do assume that all pages will be the same size on a</span>
 <span class="s0">* compressed texture).</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::size_t Texture::get_ram_mipmap_page_size(int n) const;</span>

<span class="s0">2685 34 get_expected_ram_mipmap_image_size 0 4 3276 43 Texture::get_expected_ram_mipmap_image_size 0 1 1128 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes that *ought* to be used by the in-memory image</span>
 <span class="s0">* for mipmap level n, based on the texture parameters.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline std::size_t Texture::get_expected_ram_mipmap_image_size(int n) const;</span>

<span class="s0">2686 33 get_expected_ram_mipmap_view_size 0 4 3276 42 Texture::get_expected_ram_mipmap_view_size 0 1 1129 258</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes that *ought* to be used by each view of the in-</span>
 <span class="s0">* memory image for mipmap level n, based on the texture parameters.  For a</span>
 <span class="s0">* normal, non-multiview texture, this is the same as</span>
 <span class="s0">* get_expected_ram_mipmap_image_size(n).</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline std::size_t Texture::get_expected_ram_mipmap_view_size(int n) const;</span>

<span class="s0">2687 33 get_expected_ram_mipmap_page_size 0 4 3276 42 Texture::get_expected_ram_mipmap_page_size 0 1 1130 205</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes that should be used per each Z page of the 3-d</span>
 <span class="s0">* texture, for mipmap level n.  For a 2-d or 1-d texture, this is the same as</span>
 <span class="s0">* get_expected_ram_mipmap_view_size(n).</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline std::size_t Texture::get_expected_ram_mipmap_page_size(int n) const;</span>

<span class="s0">2688 20 get_ram_mipmap_image 0 4 3276 29 Texture::get_ram_mipmap_image 0 1 1131 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the system-RAM image data associated with the nth mipmap level, if</span>
 <span class="s0">* present.  Returns NULL if the nth mipmap level is not present.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">CPTA_uchar Texture::get_ram_mipmap_image(int n) const;</span>

<span class="s0">2689 22 get_ram_mipmap_pointer 0 4 3276 31 Texture::get_ram_mipmap_pointer 0 1 1132 182</span>
<span class="s0">/**</span>
 <span class="s0">* Similiar to get_ram_mipmap_image(), however, in this case the void pointer</span>
 <span class="s0">* for the given ram image is returned.  This will be NULL unless it has been</span>
 <span class="s0">* explicitly set.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void *Texture::get_ram_mipmap_pointer(int n) const;</span>

<span class="s0">2690 23 modify_ram_mipmap_image 0 4 3276 32 Texture::modify_ram_mipmap_image 0 1 1133 231</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the system-RAM image for the nth mipmap</span>
 <span class="s0">* level.  This assumes the RAM image is uncompressed; if this is not the</span>
 <span class="s0">* case, raises an assertion.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PTA_uchar Texture::modify_ram_mipmap_image(int n);</span>

<span class="s0">2691 21 make_ram_mipmap_image 0 4 3276 30 Texture::make_ram_mipmap_image 0 1 1134 207</span>
<span class="s0">/**</span>
 <span class="s0">* Discards the current system-RAM image for the nth mipmap level, if any, and</span>
 <span class="s0">* allocates a new buffer of the appropriate size.  Returns the new buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PTA_uchar Texture::make_ram_mipmap_image(int n);</span>

<span class="s0">2692 22 set_ram_mipmap_pointer 0 4 3276 31 Texture::set_ram_mipmap_pointer 0 0 489</span>
<span class="s0">/**</span>
 <span class="s0">* Sets an explicit void pointer as the texture's mipmap image for the</span>
 <span class="s0">* indicated level.  This is a special call to direct a texture to reference</span>
 <span class="s0">* some external image location, for instance from a webcam input.</span>
 <span class="s0">*</span>
 <span class="s0">* The texture will henceforth reference this pointer directly, instead of its</span>
 <span class="s0">* own internal storage; the user is responsible for ensuring the data at this</span>
 <span class="s0">* address remains allocated and valid, and in the correct format, during the</span>
 <span class="s0">* lifetime of the texture.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">void Texture::set_ram_mipmap_pointer(int n, void *image, std::size_t page_size = 0);</span>

<span class="s0">2693 31 set_ram_mipmap_pointer_from_int 0 4 3276 40 Texture::set_ram_mipmap_pointer_from_int 0 1 1135 287</span>
<span class="s0">/**</span>
 <span class="s0">* Accepts a raw pointer cast as an int, which is then passed to</span>
 <span class="s0">* set_ram_mipmap_pointer(); see the documentation for that method.</span>
 <span class="s0">*</span>
 <span class="s0">* This variant is particularly useful to set an external pointer from a</span>
 <span class="s0">* language like Python, which doesn't support void pointers directly.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">void Texture::set_ram_mipmap_pointer_from_int(long long int pointer, int n, int page_size);</span>

<span class="s0">2694 20 set_ram_mipmap_image 0 4 3276 29 Texture::set_ram_mipmap_image 0 1 1136 262</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the current system-RAM image for the indicated mipmap level with</span>
 <span class="s0">* the new data.  If compression is not CM_off, it indicates that the new data</span>
 <span class="s0">* is already pre-compressed in the indicated format.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline void Texture::set_ram_mipmap_image(int n, CPTA_uchar image, std::size_t page_size = 0);</span>

<span class="s0">2695 22 clear_ram_mipmap_image 0 4 3276 31 Texture::clear_ram_mipmap_image 0 1 1137 74</span>
<span class="s0">/**</span>
 <span class="s0">* Discards the current system-RAM image for the nth mipmap level.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void Texture::clear_ram_mipmap_image(int n);</span>

<span class="s0">2696 23 clear_ram_mipmap_images 0 4 3276 32 Texture::clear_ram_mipmap_images 0 1 1138 107</span>
<span class="s0">/**</span>
 <span class="s0">* Discards the current system-RAM image for all mipmap levels, except level 0</span>
 <span class="s0">* (the base image).</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void Texture::clear_ram_mipmap_images(void);</span>

<span class="s0">2697 26 generate_ram_mipmap_images 0 4 3276 35 Texture::generate_ram_mipmap_images 0 1 1139 453</span>
<span class="s0">/**</span>
 <span class="s0">* Automatically fills in the n mipmap levels of the Texture, based on the</span>
 <span class="s0">* texture's source image.  This requires the texture's uncompressed ram image</span>
 <span class="s0">* to be available in system memory.  If it is not already, it will be fetched</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is not normally necessary, since the mipmap levels will be</span>
 <span class="s0">* generated automatically if needed.  But there may be certain cases in which</span>
 <span class="s0">* you would like to call this explicitly.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void Texture::generate_ram_mipmap_images(void);</span>

<span class="s0">2698 17 get_simple_x_size 0 4 3276 26 Texture::get_simple_x_size 0 1 1140 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the width of the &quot;simple&quot; image in texels.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int Texture::get_simple_x_size(void) const;</span>

<span class="s0">2699 17 get_simple_y_size 0 4 3276 26 Texture::get_simple_y_size 0 1 1141 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the height of the &quot;simple&quot; image in texels.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int Texture::get_simple_y_size(void) const;</span>

<span class="s0">2700 20 has_simple_ram_image 0 4 3276 29 Texture::has_simple_ram_image 0 1 1142 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Texture has a &quot;simple&quot; image available in main RAM.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool Texture::has_simple_ram_image(void) const;</span>

<span class="s0">2701 25 get_simple_ram_image_size 0 4 3276 34 Texture::get_simple_ram_image_size 0 1 1143 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes used by the &quot;simple&quot; image, or 0 if there is no</span>
 <span class="s0">* simple image.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::size_t Texture::get_simple_ram_image_size(void) const;</span>

<span class="s0">2702 20 get_simple_ram_image 0 4 3276 29 Texture::get_simple_ram_image 0 1 1144 511</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the image data associated with the &quot;simple&quot; texture image.  This is</span>
 <span class="s0">* provided for some textures as an option to display while the main texture</span>
 <span class="s0">* image is being loaded from disk.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike get_ram_image(), this function will always return immediately.</span>
 <span class="s0">* Either the simple image is available, or it is not.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;simple&quot; image is always 4 components, 1 byte each, regardless of the</span>
 <span class="s0">* parameters of the full texture.  The simple image is only supported for</span>
 <span class="s0">* ordinary 2-d textures.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline CPTA_uchar Texture::get_simple_ram_image(void) const;</span>

<span class="s0">2703 20 set_simple_ram_image 0 4 3276 29 Texture::set_simple_ram_image 0 1 1145 638</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the internal &quot;simple&quot; texture image.  This can be used as an</span>
 <span class="s0">* option to display while the main texture image is being loaded from disk.</span>
 <span class="s0">* It is normally a very small image, 16x16 or smaller (and maybe even 1x1),</span>
 <span class="s0">* that is designed to give just enough sense of color to serve as a</span>
 <span class="s0">* placeholder until the full texture is available.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;simple&quot; image is always 4 components, 1 byte each, regardless of the</span>
 <span class="s0">* parameters of the full texture.  The simple image is only supported for</span>
 <span class="s0">* ordinary 2-d textures.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see generate_simple_ram_image(), modify_simple_ram_image(), and</span>
 <span class="s0">* new_simple_ram_image().</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline void Texture::set_simple_ram_image(CPTA_uchar image, int x_size, int y_size);</span>

<span class="s0">2704 23 modify_simple_ram_image 0 4 3276 32 Texture::modify_simple_ram_image 0 1 1146 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the internal &quot;simple&quot; texture image.  See</span>
 <span class="s0">* set_simple_ram_image().</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">PTA_uchar Texture::modify_simple_ram_image(void);</span>

<span class="s0">2705 20 new_simple_ram_image 0 4 3276 29 Texture::new_simple_ram_image 0 1 1147 164</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an empty array for the simple ram image of the indicated size, and</span>
 <span class="s0">* returns a modifiable pointer to the new array.  See set_simple_ram_image().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">PTA_uchar Texture::new_simple_ram_image(int x_size, int y_size);</span>

<span class="s0">2706 25 generate_simple_ram_image 0 4 3276 34 Texture::generate_simple_ram_image 0 1 1148 185</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the &quot;simple&quot; ram image by loading the main RAM image, if it is not</span>
 <span class="s0">* already available, and reducing it to 16x16 or smaller.  This may be an</span>
 <span class="s0">* expensive operation.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void Texture::generate_simple_ram_image(void);</span>

<span class="s0">2707 22 clear_simple_ram_image 0 4 3276 31 Texture::clear_simple_ram_image 0 1 1149 47</span>
<span class="s0">/**</span>
 <span class="s0">* Discards the current &quot;simple&quot; image.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void Texture::clear_simple_ram_image(void);</span>

<span class="s0">2708 4 peek 0 4 3276 13 Texture::peek 0 1 1150 492</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a TexturePeeker object that can be used to examine the individual</span>
 <span class="s0">* texels stored within this Texture by (u, v) coordinate.</span>
 <span class="s0">*</span>
 <span class="s0">* If the texture has a ram image resident, that image is used.  If it does</span>
 <span class="s0">* not have a full ram image but does have a simple_ram_image resident, that</span>
 <span class="s0">* image is used instead.  If neither image is resident the full image is</span>
 <span class="s0">* reloaded.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns NULL if the texture cannot find an image to load, or the texture</span>
 <span class="s0">* format is incompatible.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">PointerTo&lt; TexturePeeker &gt; Texture::peek(void);</span>

<span class="s0">2709 23 get_properties_modified 0 4 3276 32 Texture::get_properties_modified 0 1 1151 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture properties (unrelated to the image) are modified.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline UpdateSeq Texture::get_properties_modified(void) const;</span>

<span class="s0">2710 18 get_image_modified 0 4 3276 27 Texture::get_image_modified 0 1 1152 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture image data (including mipmap levels) are modified.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline UpdateSeq Texture::get_image_modified(void) const;</span>

<span class="s0">2711 25 get_simple_image_modified 0 4 3276 34 Texture::get_simple_image_modified 0 1 1153 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture's &quot;simple&quot; image data is modified.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline UpdateSeq Texture::get_simple_image_modified(void) const;</span>

<span class="s0">2712 22 has_auto_texture_scale 0 4 3276 31 Texture::has_auto_texture_scale 0 1 1154 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if set_auto_texture_scale() has been set to something other</span>
 <span class="s0">* than ATS_unspecified for this particular texture.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool Texture::has_auto_texture_scale(void) const;</span>

<span class="s0">2713 22 get_auto_texture_scale 0 4 3276 31 Texture::get_auto_texture_scale 0 1 1155 171</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the power-of-2 texture-scaling mode that will be applied to this</span>
 <span class="s0">* particular texture when it is next loaded from disk.  See</span>
 <span class="s0">* set_textures_power_2().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline AutoTextureScale Texture::get_auto_texture_scale(void) const;</span>

<span class="s0">2714 22 set_auto_texture_scale 0 4 3276 31 Texture::set_auto_texture_scale 0 1 1156 173</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the power-of-2 texture-scaling mode that will be applied to this</span>
 <span class="s0">* particular texture when it is next loaded from disk.  See</span>
 <span class="s0">* set_textures_power_2().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void Texture::set_auto_texture_scale(AutoTextureScale scale);</span>

<span class="s0">2715 7 prepare 0 4 3276 16 Texture::prepare 0 1 1157 363</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the texture should be enqueued to be prepared in the</span>
 <span class="s0">* indicated prepared_objects at the beginning of the next frame.  This will</span>
 <span class="s0">* ensure the texture is already loaded into texture memory if it is expected</span>
 <span class="s0">* to be rendered soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload textures from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">PointerTo&lt; AsyncFuture &gt; Texture::prepare(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">2716 11 is_prepared 0 4 3276 20 Texture::is_prepared 0 1 1158 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">bool Texture::is_prepared(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2717 18 was_image_modified 0 4 3276 27 Texture::was_image_modified 0 1 1159 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture needs to be re-loaded onto the indicated GSG,</span>
 <span class="s0">* either because its image data is out-of-date, or because it's not fully</span>
 <span class="s0">* prepared now.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">bool Texture::was_image_modified(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2718 19 get_data_size_bytes 0 4 3276 28 Texture::get_data_size_bytes 0 1 1160 335</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes which the texture is reported to consume within</span>
 <span class="s0">* graphics memory, for the indicated GSG.  This may return a nonzero value</span>
 <span class="s0">* even if the texture is not currently resident; you should also check</span>
 <span class="s0">* get_resident() if you want to know how much space the texture is actually</span>
 <span class="s0">* consuming right now.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">std::size_t Texture::get_data_size_bytes(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2719 10 get_active 0 4 3276 19 Texture::get_active 0 1 1161 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this Texture was rendered in the most recent frame within</span>
 <span class="s0">* the indicated GSG.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">bool Texture::get_active(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2720 12 get_resident 0 4 3276 21 Texture::get_resident 0 1 1162 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this Texture is reported to be resident within graphics</span>
 <span class="s0">* memory for the indicated GSG.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">bool Texture::get_resident(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2721 7 release 0 4 3276 16 Texture::release 0 1 1163 157</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the texture context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool Texture::release(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">2722 11 release_all 0 4 3276 20 Texture::release_all 0 1 1164 152</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the context allocated on all objects for which the texture has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">int Texture::release_all(void);</span>

<span class="s0">2723 23 estimate_texture_memory 0 4 3276 32 Texture::estimate_texture_memory 0 1 1165 437</span>
<span class="s0">/**</span>
 <span class="s0">* Estimates the amount of texture memory that will be consumed by loading</span>
 <span class="s0">* this texture.  This returns a value that is not specific to any particular</span>
 <span class="s0">* graphics card or driver; it tries to make a reasonable assumption about how</span>
 <span class="s0">* a driver will load the texture.  It does not account for texture</span>
 <span class="s0">* compression or anything fancy.  This is mainly useful for debugging and</span>
 <span class="s0">* reporting purposes.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns a value in bytes.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">std::size_t Texture::estimate_texture_memory(void) const;</span>

<span class="s0">2724 12 set_aux_data 0 4 3276 21 Texture::set_aux_data 0 1 1166 237</span>
<span class="s0">/**</span>
 <span class="s0">* Records an arbitrary object in the Texture, associated with a specified</span>
 <span class="s0">* key.  The object may later be retrieved by calling get_aux_data() with the</span>
 <span class="s0">* same key.</span>
 <span class="s0">*</span>
 <span class="s0">* These data objects are not recorded to a bam or txo file.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void Texture::set_aux_data(std::string const &amp;key, TypedReferenceCount *aux_data);</span>

<span class="s0">2725 14 clear_aux_data 0 4 3276 23 Texture::clear_aux_data 0 1 1167 67</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a record previously recorded via set_aux_data().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void Texture::clear_aux_data(std::string const &amp;key);</span>

<span class="s0">2726 12 get_aux_data 0 4 3276 21 Texture::get_aux_data 0 1 1168 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a record previously recorded via set_aux_data().  Returns NULL if</span>
 <span class="s0">* there was no record associated with the indicated key.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">TypedReferenceCount *Texture::get_aux_data(std::string const &amp;key) const;</span>

<span class="s0">2727 20 set_textures_power_2 0 4 3276 29 Texture::set_textures_power_2 0 1 1169 232</span>
<span class="s0">/**</span>
 <span class="s0">* Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control the</span>
 <span class="s0">* scaling of textures in general, if a particular texture does not override</span>
 <span class="s0">* this.  See also set_auto_texture_scale() for the per-texture override.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline void Texture::set_textures_power_2(AutoTextureScale scale);</span>

<span class="s0">2728 20 get_textures_power_2 0 4 3276 29 Texture::get_textures_power_2 0 1 1170 251</span>
<span class="s0">/**</span>
 <span class="s0">* This flag returns ATS_none, ATS_up, or ATS_down and controls the scaling of</span>
 <span class="s0">* textures in general.  It is initialized from the config variable of the</span>
 <span class="s0">* same name, but it can be subsequently adjusted.  See also</span>
 <span class="s0">* get_auto_texture_scale().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">static inline AutoTextureScale Texture::get_textures_power_2(void);</span>

<span class="s0">2729 20 has_textures_power_2 0 4 3276 29 Texture::has_textures_power_2 0 1 1171 181</span>
<span class="s0">/**</span>
 <span class="s0">* If true, then get_textures_power_2 has been set using set_textures_power_2.</span>
 <span class="s0">* If false, then get_textures_power_2 simply returns the config variable of</span>
 <span class="s0">* the same name.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline bool Texture::has_textures_power_2(void);</span>

<span class="s0">2730 14 get_pad_x_size 0 4 3276 23 Texture::get_pad_x_size 0 1 1172 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns size of the pad region.  See set_pad_size.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int Texture::get_pad_x_size(void) const;</span>

<span class="s0">2731 14 get_pad_y_size 0 4 3276 23 Texture::get_pad_y_size 0 1 1173 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns size of the pad region.  See set_pad_size.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int Texture::get_pad_y_size(void) const;</span>

<span class="s0">2732 14 get_pad_z_size 0 4 3276 23 Texture::get_pad_z_size 0 1 1174 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns size of the pad region.  See set_pad_size.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int Texture::get_pad_z_size(void) const;</span>

<span class="s0">2733 13 get_tex_scale 0 4 3276 22 Texture::get_tex_scale 0 1 1175 523</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a scale pair that is suitable for applying to geometry via</span>
 <span class="s0">* NodePath::set_tex_scale(), which will convert texture coordinates on the</span>
 <span class="s0">* geometry from the range 0..1 into the appropriate range to render the video</span>
 <span class="s0">* part of the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* This is necessary only if a padding size has been set via set_pad_size()</span>
 <span class="s0">* (or implicitly via something like &quot;textures-power-2 pad&quot; in the config.prc</span>
 <span class="s0">* file).  In this case, this is a convenient way to generate UV's that</span>
 <span class="s0">* reflect the built-in padding size.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline LVecBase2 Texture::get_tex_scale(void) const;</span>

<span class="s0">2734 12 set_pad_size 0 4 3276 21 Texture::set_pad_size 0 1 1176 468</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the size of the pad region.</span>
 <span class="s0">*</span>
 <span class="s0">* Sometimes, when a video card demands power-of-two textures, it is necessary</span>
 <span class="s0">* to create a big texture and then only use a portion of it.  The pad region</span>
 <span class="s0">* indicates which portion of the texture is not really in use.  All</span>
 <span class="s0">* operations use the texture as a whole, including the pad region, unless</span>
 <span class="s0">* they explicitly state that they use only the non-pad region.</span>
 <span class="s0">*</span>
 <span class="s0">* Changing the texture's size clears the pad region.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void Texture::set_pad_size(int x = 0, int y = 0, int z = 0);</span>

<span class="s0">2735 15 set_size_padded 0 4 3276 24 Texture::set_size_padded 0 1 1177 104</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the size of the texture, padding if necessary, and setting the pad</span>
 <span class="s0">* region as well.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void Texture::set_size_padded(int x = 1, int y = 1, int z = 1);</span>

<span class="s0">2736 20 get_orig_file_x_size 0 4 3276 29 Texture::get_orig_file_x_size 0 1 1178 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the X size of the original disk image that this Texture was loaded</span>
 <span class="s0">* from (if it came from a disk file), before any automatic rescaling by</span>
 <span class="s0">* Panda.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int Texture::get_orig_file_x_size(void) const;</span>

<span class="s0">2737 20 get_orig_file_y_size 0 4 3276 29 Texture::get_orig_file_y_size 0 1 1179 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Y size of the original disk image that this Texture was loaded</span>
 <span class="s0">* from (if it came from a disk file), before any automatic rescaling by</span>
 <span class="s0">* Panda.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int Texture::get_orig_file_y_size(void) const;</span>

<span class="s0">2738 20 get_orig_file_z_size 0 4 3276 29 Texture::get_orig_file_z_size 0 1 1180 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Z size of the original disk image that this Texture was loaded</span>
 <span class="s0">* from (if it came from a disk file), before any automatic rescaling by</span>
 <span class="s0">* Panda.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int Texture::get_orig_file_z_size(void) const;</span>

<span class="s0">2739 18 set_orig_file_size 0 4 3276 27 Texture::set_orig_file_size 0 1 1181 113</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the size of the texture as it exists in its original disk file,</span>
 <span class="s0">* before any Panda scaling.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void Texture::set_orig_file_size(int x, int y, int z = 1);</span>

<span class="s0">2740 21 set_loaded_from_image 0 4 3276 30 Texture::set_loaded_from_image 0 1 1182 274</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates the texture has been loaded from a disk file</span>
 <span class="s0">* or PNMImage.  You should also ensure the filename has been set correctly.</span>
 <span class="s0">* When this flag is true, the texture may be automatically reloaded when its</span>
 <span class="s0">* ram image needs to be replaced.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void Texture::set_loaded_from_image(bool flag = true);</span>

<span class="s0">2741 21 get_loaded_from_image 0 4 3276 30 Texture::get_loaded_from_image 0 1 1183 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that indicates the texture has been loaded from a disk</span>
 <span class="s0">* file or PNMImage.  See set_loaded_from_image().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool Texture::get_loaded_from_image(void) const;</span>

<span class="s0">2742 19 set_loaded_from_txo 0 4 3276 28 Texture::set_loaded_from_txo 0 1 1184 189</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates the texture has been loaded from a txo file.</span>
 <span class="s0">* You probably shouldn't be setting this directly; it is set automatically</span>
 <span class="s0">* when a Texture is loaded.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void Texture::set_loaded_from_txo(bool flag = true);</span>

<span class="s0">2743 19 get_loaded_from_txo 0 4 3276 28 Texture::get_loaded_from_txo 0 1 1185 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that indicates the texture has been loaded from a txo</span>
 <span class="s0">* file.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool Texture::get_loaded_from_txo(void) const;</span>

<span class="s0">2744 28 get_match_framebuffer_format 0 4 3276 37 Texture::get_match_framebuffer_format 0 1 1186 289</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the special flag was set that indicates to the GSG that the</span>
 <span class="s0">* Texture's format should be chosen to exactly match the framebuffer's</span>
 <span class="s0">* format, presumably because the application intends to copy image data from</span>
 <span class="s0">* the framebuffer into the Texture (or vice-versa).</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool Texture::get_match_framebuffer_format(void) const;</span>

<span class="s0">2745 28 set_match_framebuffer_format 0 4 3276 37 Texture::set_match_framebuffer_format 0 1 1187 399</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the special flag that, if true, indicates to the GSG that the</span>
 <span class="s0">* Texture's format should be chosen to exactly match the framebuffer's</span>
 <span class="s0">* format, presumably because the application intends to copy image data from</span>
 <span class="s0">* the framebuffer into the Texture (or vice-versa).</span>
 <span class="s0">*</span>
 <span class="s0">* This sets only the graphics card's idea of the texture format; it is not</span>
 <span class="s0">* related to the system-memory format.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void Texture::set_match_framebuffer_format(bool flag);</span>

<span class="s0">2746 25 get_post_load_store_cache 0 4 3276 34 Texture::get_post_load_store_cache 0 1 1188 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the setting of the post_load_store_cache flag.  See</span>
 <span class="s0">* set_post_load_store_cache().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool Texture::get_post_load_store_cache(void) const;</span>

<span class="s0">2747 25 set_post_load_store_cache 0 4 3276 34 Texture::set_post_load_store_cache 0 1 1189 418</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the post_load_store_cache flag.  When this is set, the next time the</span>
 <span class="s0">* texture is loaded on a GSG, it will automatically extract its RAM image</span>
 <span class="s0">* from the GSG and save it to the global BamCache.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used to store compressed RAM images in the BamCache.  This flag</span>
 <span class="s0">* should not be set explicitly; it is set automatically by the TexturePool</span>
 <span class="s0">* when model-cache-compressed-textures is set true.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void Texture::set_post_load_store_cache(bool flag);</span>

<span class="s0">2748 11 prepare_now 0 4 3276 20 Texture::prepare_now 0 1 1190 531</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a context for the texture on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) TextureContext.  This assumes that</span>
 <span class="s0">* the GraphicsStateGuardian is the currently active rendering context and</span>
 <span class="s0">* that it is ready to accept new textures.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a texture does not need to be explicitly prepared by the user before it may</span>
 <span class="s0">* be rendered.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">TextureContext *Texture::prepare_now(int view, PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2749 13 up_to_power_2 0 4 3276 22 Texture::up_to_power_2 0 1 1191 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the smallest power of 2 greater than or equal to value.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static int Texture::up_to_power_2(int value);</span>

<span class="s0">2750 15 down_to_power_2 0 4 3276 24 Texture::down_to_power_2 0 1 1192 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the largest power of 2 less than or equal to value.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static int Texture::down_to_power_2(int value);</span>

<span class="s0">2751 16 consider_rescale 0 4 3276 25 Texture::consider_rescale 0 2 1193 1194 904</span>
<span class="s0">/**</span>
 <span class="s0">* Asks the PNMImage to change its scale when it reads the image, according to</span>
 <span class="s0">* the whims of the Config.prc file.</span>
 <span class="s0">*</span>
 <span class="s0">* For most efficient results, this method should be called after</span>
 <span class="s0">* pnmimage.read_header() has been called, but before pnmimage.read().  This</span>
 <span class="s0">* method may also be called after pnmimage.read(), i.e.  when the pnmimage is</span>
 <span class="s0">* already loaded; in this case it will rescale the image on the spot.  Also</span>
 <span class="s0">* see rescale_texture().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Asks the PNMImage to change its scale when it reads the image, according to</span>
 <span class="s0">* the whims of the Config.prc file.</span>
 <span class="s0">*</span>
 <span class="s0">* For most efficient results, this method should be called after</span>
 <span class="s0">* pnmimage.read_header() has been called, but before pnmimage.read().  This</span>
 <span class="s0">* method may also be called after pnmimage.read(), i.e.  when the pnmimage is</span>
 <span class="s0">* already loaded; in this case it will rescale the image on the spot.  Also</span>
 <span class="s0">* see rescale_texture().</span>
 <span class="s0">*/</span>
<span class="s0">192</span>
<span class="s0">void Texture::consider_rescale(PNMImage &amp;pnmimage);</span>
<span class="s0">static void Texture::consider_rescale(PNMImage &amp;pnmimage, std::string const &amp;name, AutoTextureScale auto_texture_scale = ::ATS_unspecified);</span>

<span class="s0">2752 15 rescale_texture 0 4 3276 24 Texture::rescale_texture 0 1 1195 391</span>
<span class="s0">/**</span>
 <span class="s0">* This method is similar to consider_rescale(), but instead of scaling a</span>
 <span class="s0">* separate PNMImage, it will ask the Texture to rescale its own internal</span>
 <span class="s0">* image to a power of 2, according to the config file requirements.  This may</span>
 <span class="s0">* be useful after loading a Texture image by hand, instead of reading it from</span>
 <span class="s0">* a disk file.  Returns true if the texture is changed, false if it was not.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool Texture::rescale_texture(void);</span>

<span class="s0">2753 19 format_texture_type 0 4 3276 28 Texture::format_texture_type 0 1 1196 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated TextureType converted to a string word.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static std::string Texture::format_texture_type(Texture::TextureType tt);</span>

<span class="s0">2754 19 string_texture_type 0 4 3276 28 Texture::string_texture_type 0 1 1197 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the TextureType corresponding to the indicated string word.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">static Texture::TextureType Texture::string_texture_type(std::string const &amp;str);</span>

<span class="s0">2755 21 format_component_type 0 4 3276 30 Texture::format_component_type 0 1 1198 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated ComponentType converted to a string word.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">static std::string Texture::format_component_type(Texture::ComponentType ct);</span>

<span class="s0">2756 21 string_component_type 0 4 3276 30 Texture::string_component_type 0 1 1199 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ComponentType corresponding to the indicated string word.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">static Texture::ComponentType Texture::string_component_type(std::string const &amp;str);</span>

<span class="s0">2757 13 format_format 0 4 3276 22 Texture::format_format 0 1 1200 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated Format converted to a string word.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">static std::string Texture::format_format(Texture::Format f);</span>

<span class="s0">2758 13 string_format 0 4 3276 22 Texture::string_format 0 1 1201 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Format corresponding to the indicated string word.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static Texture::Format Texture::string_format(std::string const &amp;str);</span>

<span class="s0">2759 23 format_compression_mode 0 4 3276 32 Texture::format_compression_mode 0 1 1202 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated CompressionMode converted to a string word.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">static std::string Texture::format_compression_mode(Texture::CompressionMode cm);</span>

<span class="s0">2760 23 string_compression_mode 0 4 3276 32 Texture::string_compression_mode 0 1 1203 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CompressionMode value associated with the given string</span>
 <span class="s0">* representation.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">static Texture::CompressionMode Texture::string_compression_mode(std::string const &amp;str);</span>

<span class="s0">2761 20 format_quality_level 0 4 3276 29 Texture::format_quality_level 0 1 1204 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated QualityLevel converted to a string word.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static std::string Texture::format_quality_level(Texture::QualityLevel tql);</span>

<span class="s0">2762 20 string_quality_level 0 4 3276 29 Texture::string_quality_level 0 1 1205 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the QualityLevel value associated with the given string</span>
 <span class="s0">* representation.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">static Texture::QualityLevel Texture::string_quality_level(std::string const &amp;str);</span>

<span class="s0">2763 14 get_class_type 0 4 3276 23 Texture::get_class_type 0 1 1206 0</span>
<span class="s0">48</span>
<span class="s0">static TypeHandle Texture::get_class_type(void);</span>

<span class="s0">2764 4 load 0 4 3292 12 Shader::load 0 2 1210 1211 238</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the shader from the given string(s). Returns a boolean indicating</span>
 <span class="s0">* success or failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Loads the shader with the given filename.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This variant of Shader::load loads all shader programs separately.</span>
 <span class="s0">*/</span>
<span class="s0">335</span>
<span class="s0">static PointerTo&lt; Shader &gt; Shader::load(Filename const &amp;file, Shader::ShaderLanguage lang = ::Shader::SL_none);</span>
<span class="s0">static PointerTo&lt; Shader &gt; Shader::load(Shader::ShaderLanguage lang, Filename const &amp;vertex, Filename const &amp;fragment, Filename const &amp;geometry = &quot;&quot;, Filename const &amp;tess_control = &quot;&quot;, Filename const &amp;tess_evaluation = &quot;&quot;);</span>

<span class="s0">2765 4 make 0 4 3292 12 Shader::make 0 2 1212 1213 127</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the shader, using the string as shader body.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Loads the shader, using the strings as shader bodies.</span>
 <span class="s0">*/</span>
<span class="s0">311</span>
<span class="s0">static PointerTo&lt; Shader &gt; Shader::make(std::string body, Shader::ShaderLanguage lang = ::Shader::SL_none);</span>
<span class="s0">static PointerTo&lt; Shader &gt; Shader::make(Shader::ShaderLanguage lang, std::string vertex, std::string fragment, std::string geometry = &quot;&quot;, std::string tess_control = &quot;&quot;, std::string tess_evaluation = &quot;&quot;);</span>

<span class="s0">2766 12 load_compute 0 4 3292 20 Shader::load_compute 0 1 1214 34</span>
<span class="s0">/**</span>
 <span class="s0">* Loads a compute shader.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">static PointerTo&lt; Shader &gt; Shader::load_compute(Shader::ShaderLanguage lang, Filename const &amp;fn);</span>

<span class="s0">2767 12 make_compute 0 4 3292 20 Shader::make_compute 0 1 1215 58</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the compute shader from the given string.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">static PointerTo&lt; Shader &gt; Shader::make_compute(Shader::ShaderLanguage lang, std::string body);</span>

<span class="s0">2768 12 get_filename 0 4 3292 20 Shader::get_filename 0 1 1216 66</span>
<span class="s0">/**</span>
 <span class="s0">* Return the Shader's filename for the given shader type.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">inline Filename Shader::get_filename(Shader::ShaderType type = ::Shader::ST_none) const;</span>

<span class="s0">2769 12 set_filename 0 4 3292 20 Shader::set_filename 0 1 1217 154</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the Shader's filename for the given shader type.  Useful for</span>
 <span class="s0">* associating a shader created with Shader.make with a name for diagnostics.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline void Shader::set_filename(Shader::ShaderType type, Filename const &amp;filename);</span>

<span class="s0">2770 8 get_text 0 4 3292 16 Shader::get_text 0 1 1218 62</span>
<span class="s0">/**</span>
 <span class="s0">* Return the Shader's text for the given shader type.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline std::string const &amp;Shader::get_text(Shader::ShaderType type = ::Shader::ST_none) const;</span>

<span class="s0">2771 14 get_error_flag 0 4 3292 22 Shader::get_error_flag 0 1 1219 160</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the shader contains a compile-time error.  This doesn't</span>
 <span class="s0">* tell you whether or not the shader is supported on the current video card.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool Shader::get_error_flag(void) const;</span>

<span class="s0">2772 12 get_language 0 4 3292 20 Shader::get_language 0 1 1220 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the shader language in which this shader was written.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline Shader::ShaderLanguage Shader::get_language(void) const;</span>

<span class="s0">2773 12 has_fullpath 0 4 3292 20 Shader::has_fullpath 0 1 1221 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the fullpath has been set and is available.  See</span>
 <span class="s0">* set_fullpath().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool Shader::has_fullpath(void) const;</span>

<span class="s0">2774 12 get_fullpath 0 4 3292 20 Shader::get_fullpath 0 1 1222 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the fullpath that has been set.  This is the full path to the file</span>
 <span class="s0">* as it was found along the model-path.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline Filename const &amp;Shader::get_fullpath(void) const;</span>

<span class="s0">2775 25 get_cache_compiled_shader 0 4 3292 33 Shader::get_cache_compiled_shader 0 1 1223 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the setting of the cache_compiled_shader flag.  See</span>
 <span class="s0">* set_cache_compiled_shader().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool Shader::get_cache_compiled_shader(void) const;</span>

<span class="s0">2776 25 set_cache_compiled_shader 0 4 3292 33 Shader::set_cache_compiled_shader 0 1 1224 414</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the cache_compiled_shader flag.  When this is set, the next time the</span>
 <span class="s0">* Shader is loaded on a GSG, it will automatically extract the compiled</span>
 <span class="s0">* shader from the GSG and save it to the global BamCache.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used to store compiled shaders in the BamCache.  This flag should</span>
 <span class="s0">* not be set explicitly; it is set automatically by the ShaderPool when</span>
 <span class="s0">* model-cache-compiled-shaders is set true.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void Shader::set_cache_compiled_shader(bool flag);</span>

<span class="s0">2777 7 prepare 0 4 3292 15 Shader::prepare 0 1 1225 362</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the shader should be enqueued to be prepared in the</span>
 <span class="s0">* indicated prepared_objects at the beginning of the next frame.  This will</span>
 <span class="s0">* ensure the texture is already loaded into texture memory if it is expected</span>
 <span class="s0">* to be rendered soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload textures from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">PointerTo&lt; AsyncFuture &gt; Shader::prepare(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">2778 11 is_prepared 0 4 3292 19 Shader::is_prepared 0 1 1226 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the shader has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">bool Shader::is_prepared(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2779 7 release 0 4 3292 15 Shader::release 0 1 1227 157</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the texture context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool Shader::release(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">2780 11 release_all 0 4 3292 19 Shader::release_all 0 1 1228 152</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the context allocated on all objects for which the texture has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">int Shader::release_all(void);</span>

<span class="s0">2781 11 prepare_now 0 4 3292 19 Shader::prepare_now 0 1 1229 528</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a context for the shader on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) ShaderContext.  This assumes that</span>
 <span class="s0">* the GraphicsStateGuardian is the currently active rendering context and</span>
 <span class="s0">* that it is ready to accept new textures.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a shader does not need to be explicitly prepared by the user before it may</span>
 <span class="s0">* be rendered.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">ShaderContext *Shader::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2782 14 get_class_type 0 4 3292 22 Shader::get_class_type 0 1 1230 0</span>
<span class="s0">47</span>
<span class="s0">static TypeHandle Shader::get_class_type(void);</span>

<span class="s0">2783 6 Shader 0 260 3292 14 Shader::Shader 0 1 1209 84</span>
<span class="s0">/**</span>
 <span class="s0">* Construct a Shader that will be filled in using fillin() or read() later.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline Shader::Shader(Shader const &amp;) = default;</span>

<span class="s0">2784 37 upcast_to_TypedWritableReferenceCount 0 12 3297 51 ShaderBuffer::upcast_to_TypedWritableReferenceCount 0 1 1240 55</span>
<span class="s0">upcast from ShaderBuffer to TypedWritableReferenceCount</span>
<span class="s0">87</span>
<span class="s0">TypedWritableReferenceCount *ShaderBuffer::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">2785 24 downcast_to_ShaderBuffer 0 12 3180 53 TypedWritableReferenceCount::downcast_to_ShaderBuffer 0 0 57</span>
<span class="s0">downcast from TypedWritableReferenceCount to ShaderBuffer</span>
<span class="s0">74</span>
<span class="s0">ShaderBuffer *TypedWritableReferenceCount::downcast_to_ShaderBuffer(void);</span>

<span class="s0">2786 17 upcast_to_Namable 0 12 3297 31 ShaderBuffer::upcast_to_Namable 0 1 1241 35</span>
<span class="s0">upcast from ShaderBuffer to Namable</span>
<span class="s0">47</span>
<span class="s0">Namable *ShaderBuffer::upcast_to_Namable(void);</span>

<span class="s0">2787 24 downcast_to_ShaderBuffer 0 12 3164 33 Namable::downcast_to_ShaderBuffer 0 0 37</span>
<span class="s0">downcast from Namable to ShaderBuffer</span>
<span class="s0">54</span>
<span class="s0">ShaderBuffer *Namable::downcast_to_ShaderBuffer(void);</span>

<span class="s0">2788 19 upcast_to_GeomEnums 0 12 3297 33 ShaderBuffer::upcast_to_GeomEnums 0 1 1242 37</span>
<span class="s0">upcast from ShaderBuffer to GeomEnums</span>
<span class="s0">51</span>
<span class="s0">GeomEnums *ShaderBuffer::upcast_to_GeomEnums(void);</span>

<span class="s0">2789 24 downcast_to_ShaderBuffer 0 12 3168 35 GeomEnums::downcast_to_ShaderBuffer 0 0 39</span>
<span class="s0">downcast from GeomEnums to ShaderBuffer</span>
<span class="s0">56</span>
<span class="s0">ShaderBuffer *GeomEnums::downcast_to_ShaderBuffer(void);</span>

<span class="s0">2790 13 ~ShaderBuffer 0 518 3297 27 ShaderBuffer::~ShaderBuffer 0 0 22</span>
<span class="s0">/**</span>
 <span class="s0">* Destructor.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">virtual ShaderBuffer::~ShaderBuffer(void);</span>

<span class="s0">2791 12 ShaderBuffer 0 260 3297 26 ShaderBuffer::ShaderBuffer 0 3 1231 1232 1233 309</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an uninitialized buffer object with the given size.  For now, these</span>
 <span class="s0">* parameters cannot be modified, but this may change in the future.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a buffer object initialized with the given data.  For now, these</span>
 <span class="s0">* parameters cannot be modified, but this may change in the future.</span>
 <span class="s0">*/</span>
<span class="s0">312</span>
<span class="s0">inline explicit ShaderBuffer::ShaderBuffer(std::string const &amp;name, uint64_t size, GeomEnums::UsageHint usage_hint);</span>
<span class="s0">inline explicit ShaderBuffer::ShaderBuffer(std::string const &amp;name, vector_uchar initial_data, GeomEnums::UsageHint usage_hint);</span>
<span class="s0">inline ShaderBuffer::ShaderBuffer(ShaderBuffer const &amp;) = default;</span>

<span class="s0">2792 19 get_data_size_bytes 0 4 3297 33 ShaderBuffer::get_data_size_bytes 0 0 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the buffer size in bytes.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline uint64_t ShaderBuffer::get_data_size_bytes(void) const;</span>

<span class="s0">2793 14 get_usage_hint 0 4 3297 28 ShaderBuffer::get_usage_hint 0 0 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the buffer usage hint.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline GeomEnums::UsageHint ShaderBuffer::get_usage_hint(void) const;</span>

<span class="s0">2794 7 prepare 0 4 3297 21 ShaderBuffer::prepare 0 1 1234 344</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the data should be enqueued to be prepared in the indicated</span>
 <span class="s0">* prepared_objects at the beginning of the next frame.  This will ensure the</span>
 <span class="s0">* data is already loaded into the GSG if it is expected to be rendered soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload datas from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void ShaderBuffer::prepare(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">2795 11 is_prepared 0 4 3297 25 ShaderBuffer::is_prepared 0 1 1235 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">bool ShaderBuffer::is_prepared(PreparedGraphicsObjects *prepared_objects) const;</span>

<span class="s0">2796 11 prepare_now 0 4 3297 25 ShaderBuffer::prepare_now 0 1 1236 521</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a context for the data on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) BufferContext.  This assumes</span>
 <span class="s0">* that the GraphicsStateGuardian is the currently active rendering context</span>
 <span class="s0">* and that it is ready to accept new datas.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a data does not need to be explicitly prepared by the user before it may be</span>
 <span class="s0">* rendered.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">BufferContext *ShaderBuffer::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2797 7 release 0 4 3297 21 ShaderBuffer::release 0 1 1237 154</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the data context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">bool ShaderBuffer::release(PreparedGraphicsObjects *prepared_objects);</span>

<span class="s0">2798 11 release_all 0 4 3297 25 ShaderBuffer::release_all 0 1 1238 149</span>
<span class="s0">/**</span>
 <span class="s0">* Frees the context allocated on all objects for which the data has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">int ShaderBuffer::release_all(void);</span>

<span class="s0">2799 14 get_class_type 0 4 3297 28 ShaderBuffer::get_class_type 0 1 1239 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle ShaderBuffer::get_class_type(void);</span>

<span class="s0">2800 8 get_name 0 4 3299 33 PreparedGraphicsObjects::get_name 0 1 1243 167</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the PreparedGraphicsObjects structure.  This is an</span>
 <span class="s0">* arbitrary name that serves mainly to uniquify the context for PStats</span>
 <span class="s0">* reporting.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline std::string const &amp;PreparedGraphicsObjects::get_name(void) const;</span>

<span class="s0">2801 25 set_graphics_memory_limit 0 4 3299 50 PreparedGraphicsObjects::set_graphics_memory_limit 0 1 1244 503</span>
<span class="s0">/**</span>
 <span class="s0">* Sets an artificial cap on graphics memory that will be imposed on this GSG.</span>
 <span class="s0">*</span>
 <span class="s0">* This limits the total amount of graphics memory, including texture memory</span>
 <span class="s0">* and vertex buffer memory, that will be consumed by the GSG, regardless of</span>
 <span class="s0">* whether the hardware claims to provide more graphics memory than this.  It</span>
 <span class="s0">* is useful to put a ceiling on graphics memory consumed, since some drivers</span>
 <span class="s0">* seem to allow the application to consume more memory than the hardware can</span>
 <span class="s0">* realistically support.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void PreparedGraphicsObjects::set_graphics_memory_limit(std::size_t limit);</span>

<span class="s0">2802 25 get_graphics_memory_limit 0 4 3299 50 PreparedGraphicsObjects::get_graphics_memory_limit 0 1 1245 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the artificial cap on graphics memory that will be imposed on this</span>
 <span class="s0">* GSG.  See set_graphics_memory_limit().</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline std::size_t PreparedGraphicsObjects::get_graphics_memory_limit(void) const;</span>

<span class="s0">2803 24 show_graphics_memory_lru 0 4 3299 49 PreparedGraphicsObjects::show_graphics_memory_lru 0 1 1246 127</span>
<span class="s0">/**</span>
 <span class="s0">* Writes to the indicated ostream a report of how the various textures and</span>
 <span class="s0">* vertex buffers are allocated in the LRU.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">void PreparedGraphicsObjects::show_graphics_memory_lru(std::ostream &amp;out) const;</span>

<span class="s0">2804 23 show_residency_trackers 0 4 3299 48 PreparedGraphicsObjects::show_residency_trackers 0 1 1247 127</span>
<span class="s0">/**</span>
 <span class="s0">* Writes to the indicated ostream a report of how the various textures and</span>
 <span class="s0">* vertex buffers are allocated in the LRU.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void PreparedGraphicsObjects::show_residency_trackers(std::ostream &amp;out) const;</span>

<span class="s0">2805 11 release_all 0 4 3299 36 PreparedGraphicsObjects::release_all 0 1 1248 62</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all prepared objects of all kinds at once.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void PreparedGraphicsObjects::release_all(void);</span>

<span class="s0">2806 14 get_num_queued 0 4 3299 39 PreparedGraphicsObjects::get_num_queued 0 1 1249 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of objects of any kind that have been enqueued to be</span>
 <span class="s0">* prepared on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int PreparedGraphicsObjects::get_num_queued(void) const;</span>

<span class="s0">2807 16 get_num_prepared 0 4 3299 41 PreparedGraphicsObjects::get_num_prepared 0 1 1250 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of objects of any kind that have already been prepared</span>
 <span class="s0">* on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int PreparedGraphicsObjects::get_num_prepared(void) const;</span>

<span class="s0">2808 15 enqueue_texture 0 4 3299 40 PreparedGraphicsObjects::enqueue_texture 0 1 1251 156</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a texture would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void PreparedGraphicsObjects::enqueue_texture(Texture *tex);</span>

<span class="s0">2809 17 is_texture_queued 0 4 3299 42 PreparedGraphicsObjects::is_texture_queued 0 1 1252 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture has been queued on this GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">bool PreparedGraphicsObjects::is_texture_queued(Texture const *tex) const;</span>

<span class="s0">2810 15 dequeue_texture 0 4 3299 40 PreparedGraphicsObjects::dequeue_texture 0 1 1253 385</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a texture from the queued list of textures to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the texture will automatically</span>
 <span class="s0">* be dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the texture is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool PreparedGraphicsObjects::dequeue_texture(Texture *tex);</span>

<span class="s0">2811 19 is_texture_prepared 0 4 3299 44 PreparedGraphicsObjects::is_texture_prepared 0 1 1254 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture has been prepared on this GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">bool PreparedGraphicsObjects::is_texture_prepared(Texture const *tex) const;</span>

<span class="s0">2812 15 release_texture 0 4 3299 40 PreparedGraphicsObjects::release_texture 0 2 1255 1256 587</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a texture context, created by a previous call to</span>
 <span class="s0">* prepare_texture(), is no longer needed.  The driver resources will not be</span>
 <span class="s0">* freed until some GSG calls update(), indicating it is at a stage where it</span>
 <span class="s0">* is ready to release textures--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing textures (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_texture is called).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Releases a texture if it has already been prepared, or removes it from the</span>
 <span class="s0">* preparation queue.</span>
 <span class="s0">*/</span>
<span class="s0">127</span>
<span class="s0">void PreparedGraphicsObjects::release_texture(TextureContext *tc);</span>
<span class="s0">void PreparedGraphicsObjects::release_texture(Texture *tex);</span>

<span class="s0">2813 20 release_all_textures 0 4 3299 45 PreparedGraphicsObjects::release_all_textures 0 1 1257 184</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all textures at once.  This will force them to be reloaded into</span>
 <span class="s0">* texture memory for all GSG's that share this object.  Returns the number of</span>
 <span class="s0">* textures released.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">int PreparedGraphicsObjects::release_all_textures(void);</span>

<span class="s0">2814 23 get_num_queued_textures 0 4 3299 48 PreparedGraphicsObjects::get_num_queued_textures 0 1 1258 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of textures that have been enqueued to be prepared on</span>
 <span class="s0">* this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">int PreparedGraphicsObjects::get_num_queued_textures(void) const;</span>

<span class="s0">2815 25 get_num_prepared_textures 0 4 3299 50 PreparedGraphicsObjects::get_num_prepared_textures 0 1 1259 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of textures that have already been prepared on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">int PreparedGraphicsObjects::get_num_prepared_textures(void) const;</span>

<span class="s0">2816 19 prepare_texture_now 0 4 3299 44 PreparedGraphicsObjects::prepare_texture_now 0 1 1260 727</span>
<span class="s0">/**</span>
 <span class="s0">* Immediately creates a new TextureContext for the indicated texture and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new textures.  If</span>
 <span class="s0">* this is not necessarily the case, you should use enqueue_texture() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call</span>
 <span class="s0">* Texture::prepare_now() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The TextureContext contains all of the pertinent information needed by the</span>
 <span class="s0">* GSG to keep track of this one particular texture, and will exist as long as</span>
 <span class="s0">* the texture is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Texture or the PreparedGraphicsObjects object destructs,</span>
 <span class="s0">* the TextureContext will be deleted.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">TextureContext *PreparedGraphicsObjects::prepare_texture_now(Texture *tex, int view, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2817 15 enqueue_sampler 0 4 3299 40 PreparedGraphicsObjects::enqueue_sampler 0 1 1261 156</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a sampler would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void PreparedGraphicsObjects::enqueue_sampler(SamplerState const &amp;sampler);</span>

<span class="s0">2818 17 is_sampler_queued 0 4 3299 42 PreparedGraphicsObjects::is_sampler_queued 0 1 1262 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the sampler has been queued on this GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">bool PreparedGraphicsObjects::is_sampler_queued(SamplerState const &amp;sampler) const;</span>

<span class="s0">2819 15 dequeue_sampler 0 4 3299 40 PreparedGraphicsObjects::dequeue_sampler 0 1 1263 385</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a sampler from the queued list of samplers to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the sampler will automatically</span>
 <span class="s0">* be dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the sampler is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">bool PreparedGraphicsObjects::dequeue_sampler(SamplerState const &amp;sampler);</span>

<span class="s0">2820 19 is_sampler_prepared 0 4 3299 44 PreparedGraphicsObjects::is_sampler_prepared 0 1 1264 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the sampler has been prepared on this GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">bool PreparedGraphicsObjects::is_sampler_prepared(SamplerState const &amp;sampler) const;</span>

<span class="s0">2821 15 release_sampler 0 4 3299 40 PreparedGraphicsObjects::release_sampler 0 2 1265 1266 370</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a sampler context, created by a previous call to</span>
 <span class="s0">* prepare_sampler(), is no longer needed.  The driver resources will not be</span>
 <span class="s0">* freed until some GSG calls update(), indicating it is at a stage where it</span>
 <span class="s0">* is ready to release samplers.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Releases a sampler if it has already been prepared, or removes it from the</span>
 <span class="s0">* preparation queue.</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">void PreparedGraphicsObjects::release_sampler(SamplerContext *sc);</span>
<span class="s0">void PreparedGraphicsObjects::release_sampler(SamplerState const &amp;sampler);</span>

<span class="s0">2822 20 release_all_samplers 0 4 3299 45 PreparedGraphicsObjects::release_all_samplers 0 1 1267 161</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all samplers at once.  This will force them to be reloaded for all</span>
 <span class="s0">* GSG's that share this object.  Returns the number of samplers released.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">int PreparedGraphicsObjects::release_all_samplers(void);</span>

<span class="s0">2823 23 get_num_queued_samplers 0 4 3299 48 PreparedGraphicsObjects::get_num_queued_samplers 0 1 1268 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of samplers that have been enqueued to be prepared on</span>
 <span class="s0">* this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">int PreparedGraphicsObjects::get_num_queued_samplers(void) const;</span>

<span class="s0">2824 25 get_num_prepared_samplers 0 4 3299 50 PreparedGraphicsObjects::get_num_prepared_samplers 0 1 1269 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of samplers that have already been prepared on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">int PreparedGraphicsObjects::get_num_prepared_samplers(void) const;</span>

<span class="s0">2825 19 prepare_sampler_now 0 4 3299 44 PreparedGraphicsObjects::prepare_sampler_now 0 1 1270 727</span>
<span class="s0">/**</span>
 <span class="s0">* Immediately creates a new SamplerContext for the indicated sampler and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new samplers.  If</span>
 <span class="s0">* this is not necessarily the case, you should use enqueue_sampler() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call</span>
 <span class="s0">* Sampler::prepare_now() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The SamplerContext contains all of the pertinent information needed by the</span>
 <span class="s0">* GSG to keep track of this one particular sampler, and will exist as long as</span>
 <span class="s0">* the sampler is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Sampler or the PreparedGraphicsObjects object destructs,</span>
 <span class="s0">* the SamplerContext will be deleted.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">SamplerContext *PreparedGraphicsObjects::prepare_sampler_now(SamplerState const &amp;sampler, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2826 12 enqueue_geom 0 4 3299 37 PreparedGraphicsObjects::enqueue_geom 0 1 1271 153</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a geom would like to be put on the list to be prepared when</span>
 <span class="s0">* the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void PreparedGraphicsObjects::enqueue_geom(Geom *geom);</span>

<span class="s0">2827 14 is_geom_queued 0 4 3299 39 PreparedGraphicsObjects::is_geom_queued 0 1 1272 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the geom has been queued on this GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool PreparedGraphicsObjects::is_geom_queued(Geom const *geom) const;</span>

<span class="s0">2828 12 dequeue_geom 0 4 3299 37 PreparedGraphicsObjects::dequeue_geom 0 1 1273 374</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a geom from the queued list of geoms to be prepared.  Normally it</span>
 <span class="s0">* is not necessary to call this, unless you change your mind about preparing</span>
 <span class="s0">* it at the last minute, since the geom will automatically be dequeued and</span>
 <span class="s0">* prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the geom is successfully dequeued, false if it</span>
 <span class="s0">* had not been queued.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool PreparedGraphicsObjects::dequeue_geom(Geom *geom);</span>

<span class="s0">2829 16 is_geom_prepared 0 4 3299 41 PreparedGraphicsObjects::is_geom_prepared 0 1 1274 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the vertex buffer has been prepared on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">bool PreparedGraphicsObjects::is_geom_prepared(Geom const *geom) const;</span>

<span class="s0">2830 12 release_geom 0 4 3299 37 PreparedGraphicsObjects::release_geom 0 1 1275 463</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a geom context, created by a previous call to</span>
 <span class="s0">* prepare_geom(), is no longer needed.  The driver resources will not be</span>
 <span class="s0">* freed until some GSG calls update(), indicating it is at a stage where it</span>
 <span class="s0">* is ready to release geoms--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing geoms (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_geom is called).</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void PreparedGraphicsObjects::release_geom(GeomContext *gc);</span>

<span class="s0">2831 17 release_all_geoms 0 4 3299 42 PreparedGraphicsObjects::release_all_geoms 0 1 1276 175</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all geoms at once.  This will force them to be reloaded into geom</span>
 <span class="s0">* memory for all GSG's that share this object.  Returns the number of geoms</span>
 <span class="s0">* released.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">int PreparedGraphicsObjects::release_all_geoms(void);</span>

<span class="s0">2832 20 get_num_queued_geoms 0 4 3299 45 PreparedGraphicsObjects::get_num_queued_geoms 0 1 1277 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of geoms that have been enqueued to be prepared on this</span>
 <span class="s0">* GSG.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">int PreparedGraphicsObjects::get_num_queued_geoms(void) const;</span>

<span class="s0">2833 22 get_num_prepared_geoms 0 4 3299 47 PreparedGraphicsObjects::get_num_prepared_geoms 0 1 1278 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of geoms that have already been prepared on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">int PreparedGraphicsObjects::get_num_prepared_geoms(void) const;</span>

<span class="s0">2834 16 prepare_geom_now 0 4 3299 41 PreparedGraphicsObjects::prepare_geom_now 0 1 1279 697</span>
<span class="s0">/**</span>
 <span class="s0">* Immediately creates a new GeomContext for the indicated geom and returns</span>
 <span class="s0">* it.  This assumes that the GraphicsStateGuardian is the currently active</span>
 <span class="s0">* rendering context and that it is ready to accept new geoms.  If this is not</span>
 <span class="s0">* necessarily the case, you should use enqueue_geom() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Geom::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The GeomContext contains all of the pertinent information needed by the GSG</span>
 <span class="s0">* to keep track of this one particular geom, and will exist as long as the</span>
 <span class="s0">* geom is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Geom or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* GeomContext will be deleted.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">GeomContext *PreparedGraphicsObjects::prepare_geom_now(Geom *geom, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2835 14 enqueue_shader 0 4 3299 39 PreparedGraphicsObjects::enqueue_shader 0 1 1280 155</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a shader would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void PreparedGraphicsObjects::enqueue_shader(Shader *shader);</span>

<span class="s0">2836 16 is_shader_queued 0 4 3299 41 PreparedGraphicsObjects::is_shader_queued 0 1 1281 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the shader has been queued on this GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">bool PreparedGraphicsObjects::is_shader_queued(Shader const *shader) const;</span>

<span class="s0">2837 14 dequeue_shader 0 4 3299 39 PreparedGraphicsObjects::dequeue_shader 0 1 1282 382</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a shader from the queued list of shaders to be prepared.  Normally</span>
 <span class="s0">* it is not necessary to call this, unless you change your mind about</span>
 <span class="s0">* preparing it at the last minute, since the shader will automatically be</span>
 <span class="s0">* dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the shader is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">bool PreparedGraphicsObjects::dequeue_shader(Shader *shader);</span>

<span class="s0">2838 18 is_shader_prepared 0 4 3299 43 PreparedGraphicsObjects::is_shader_prepared 0 1 1283 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the shader has been prepared on this GSG, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">bool PreparedGraphicsObjects::is_shader_prepared(Shader const *shader) const;</span>

<span class="s0">2839 14 release_shader 0 4 3299 39 PreparedGraphicsObjects::release_shader 0 1 1284 473</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a shader context, created by a previous call to</span>
 <span class="s0">* prepare_shader(), is no longer needed.  The driver resources will not be</span>
 <span class="s0">* freed until some GSG calls update(), indicating it is at a stage where it</span>
 <span class="s0">* is ready to release shaders--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing shaders (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_shader is called).</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void PreparedGraphicsObjects::release_shader(ShaderContext *sc);</span>

<span class="s0">2840 19 release_all_shaders 0 4 3299 44 PreparedGraphicsObjects::release_all_shaders 0 1 1285 181</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all shaders at once.  This will force them to be reloaded into</span>
 <span class="s0">* shader memory for all GSG's that share this object.  Returns the number of</span>
 <span class="s0">* shaders released.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">int PreparedGraphicsObjects::release_all_shaders(void);</span>

<span class="s0">2841 22 get_num_queued_shaders 0 4 3299 47 PreparedGraphicsObjects::get_num_queued_shaders 0 1 1286 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of shaders that have been enqueued to be prepared on</span>
 <span class="s0">* this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">int PreparedGraphicsObjects::get_num_queued_shaders(void) const;</span>

<span class="s0">2842 24 get_num_prepared_shaders 0 4 3299 49 PreparedGraphicsObjects::get_num_prepared_shaders 0 1 1287 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of shaders that have already been prepared on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">int PreparedGraphicsObjects::get_num_prepared_shaders(void) const;</span>

<span class="s0">2843 18 prepare_shader_now 0 4 3299 43 PreparedGraphicsObjects::prepare_shader_now 0 1 1288 717</span>
<span class="s0">/**</span>
 <span class="s0">* Immediately creates a new ShaderContext for the indicated shader and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new shaders.  If</span>
 <span class="s0">* this is not necessarily the case, you should use enqueue_shader() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Shader::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The ShaderContext contains all of the pertinent information needed by the</span>
 <span class="s0">* GSG to keep track of this one particular shader, and will exist as long as</span>
 <span class="s0">* the shader is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Shader or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* ShaderContext will be deleted.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">ShaderContext *PreparedGraphicsObjects::prepare_shader_now(Shader *shader, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2844 21 enqueue_vertex_buffer 0 4 3299 46 PreparedGraphicsObjects::enqueue_vertex_buffer 0 1 1289 155</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a buffer would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void PreparedGraphicsObjects::enqueue_vertex_buffer(GeomVertexArrayData *data);</span>

<span class="s0">2845 23 is_vertex_buffer_queued 0 4 3299 48 PreparedGraphicsObjects::is_vertex_buffer_queued 0 1 1290 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the vertex buffer has been queued on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">bool PreparedGraphicsObjects::is_vertex_buffer_queued(GeomVertexArrayData const *data) const;</span>

<span class="s0">2846 21 dequeue_vertex_buffer 0 4 3299 46 PreparedGraphicsObjects::dequeue_vertex_buffer 0 1 1291 383</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a buffer from the queued list of data arrays to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the data will automatically be</span>
 <span class="s0">* dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the buffer is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">bool PreparedGraphicsObjects::dequeue_vertex_buffer(GeomVertexArrayData *data);</span>

<span class="s0">2847 25 is_vertex_buffer_prepared 0 4 3299 50 PreparedGraphicsObjects::is_vertex_buffer_prepared 0 1 1292 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the vertex buffer has been prepared on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">bool PreparedGraphicsObjects::is_vertex_buffer_prepared(GeomVertexArrayData const *data) const;</span>

<span class="s0">2848 21 release_vertex_buffer 0 4 3299 46 PreparedGraphicsObjects::release_vertex_buffer 0 1 1293 481</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a data context, created by a previous call to</span>
 <span class="s0">* prepare_vertex_buffer(), is no longer needed.  The driver resources will</span>
 <span class="s0">* not be freed until some GSG calls update(), indicating it is at a stage</span>
 <span class="s0">* where it is ready to release datas--this prevents conflicts from threading</span>
 <span class="s0">* or multiple GSG's sharing datas (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_vertex_buffer is called).</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void PreparedGraphicsObjects::release_vertex_buffer(VertexBufferContext *vbc);</span>

<span class="s0">2849 26 release_all_vertex_buffers 0 4 3299 51 PreparedGraphicsObjects::release_all_vertex_buffers 0 1 1294 175</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all datas at once.  This will force them to be reloaded into data</span>
 <span class="s0">* memory for all GSG's that share this object.  Returns the number of datas</span>
 <span class="s0">* released.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">int PreparedGraphicsObjects::release_all_vertex_buffers(void);</span>

<span class="s0">2850 29 get_num_queued_vertex_buffers 0 4 3299 54 PreparedGraphicsObjects::get_num_queued_vertex_buffers 0 1 1295 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertex buffers that have been enqueued to be prepared</span>
 <span class="s0">* on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">int PreparedGraphicsObjects::get_num_queued_vertex_buffers(void) const;</span>

<span class="s0">2851 31 get_num_prepared_vertex_buffers 0 4 3299 56 PreparedGraphicsObjects::get_num_prepared_vertex_buffers 0 1 1296 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertex buffers that have already been prepared on</span>
 <span class="s0">* this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">int PreparedGraphicsObjects::get_num_prepared_vertex_buffers(void) const;</span>

<span class="s0">2852 25 prepare_vertex_buffer_now 0 4 3299 50 PreparedGraphicsObjects::prepare_vertex_buffer_now 0 1 1297 733</span>
<span class="s0">/**</span>
 <span class="s0">* Immediately creates a new VertexBufferContext for the indicated data and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new datas.  If this</span>
 <span class="s0">* is not necessarily the case, you should use enqueue_vertex_buffer()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Data::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The VertexBufferContext contains all of the pertinent information needed by</span>
 <span class="s0">* the GSG to keep track of this one particular data, and will exist as long</span>
 <span class="s0">* as the data is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Data or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* VertexBufferContext will be deleted.</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">VertexBufferContext *PreparedGraphicsObjects::prepare_vertex_buffer_now(GeomVertexArrayData *data, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2853 20 enqueue_index_buffer 0 4 3299 45 PreparedGraphicsObjects::enqueue_index_buffer 0 1 1298 155</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a buffer would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void PreparedGraphicsObjects::enqueue_index_buffer(GeomPrimitive *data);</span>

<span class="s0">2854 22 is_index_buffer_queued 0 4 3299 47 PreparedGraphicsObjects::is_index_buffer_queued 0 1 1299 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the index buffer has been queued on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">bool PreparedGraphicsObjects::is_index_buffer_queued(GeomPrimitive const *data) const;</span>

<span class="s0">2855 20 dequeue_index_buffer 0 4 3299 45 PreparedGraphicsObjects::dequeue_index_buffer 0 1 1300 383</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a buffer from the queued list of data arrays to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the data will automatically be</span>
 <span class="s0">* dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the buffer is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">bool PreparedGraphicsObjects::dequeue_index_buffer(GeomPrimitive *data);</span>

<span class="s0">2856 24 is_index_buffer_prepared 0 4 3299 49 PreparedGraphicsObjects::is_index_buffer_prepared 0 1 1301 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the index buffer has been prepared on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">bool PreparedGraphicsObjects::is_index_buffer_prepared(GeomPrimitive const *data) const;</span>

<span class="s0">2857 20 release_index_buffer 0 4 3299 45 PreparedGraphicsObjects::release_index_buffer 0 1 1302 479</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a data context, created by a previous call to</span>
 <span class="s0">* prepare_index_buffer(), is no longer needed.  The driver resources will not</span>
 <span class="s0">* be freed until some GSG calls update(), indicating it is at a stage where</span>
 <span class="s0">* it is ready to release datas--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing datas (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_index_buffer is called).</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void PreparedGraphicsObjects::release_index_buffer(IndexBufferContext *ibc);</span>

<span class="s0">2858 25 release_all_index_buffers 0 4 3299 50 PreparedGraphicsObjects::release_all_index_buffers 0 1 1303 175</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all datas at once.  This will force them to be reloaded into data</span>
 <span class="s0">* memory for all GSG's that share this object.  Returns the number of datas</span>
 <span class="s0">* released.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">int PreparedGraphicsObjects::release_all_index_buffers(void);</span>

<span class="s0">2859 28 get_num_queued_index_buffers 0 4 3299 53 PreparedGraphicsObjects::get_num_queued_index_buffers 0 1 1304 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of index buffers that have been enqueued to be prepared</span>
 <span class="s0">* on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">int PreparedGraphicsObjects::get_num_queued_index_buffers(void) const;</span>

<span class="s0">2860 30 get_num_prepared_index_buffers 0 4 3299 55 PreparedGraphicsObjects::get_num_prepared_index_buffers 0 1 1305 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of index buffers that have already been prepared on this</span>
 <span class="s0">* GSG.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">int PreparedGraphicsObjects::get_num_prepared_index_buffers(void) const;</span>

<span class="s0">2861 24 prepare_index_buffer_now 0 4 3299 49 PreparedGraphicsObjects::prepare_index_buffer_now 0 1 1306 726</span>
<span class="s0">/**</span>
 <span class="s0">* Immediately creates a new IndexBufferContext for the indicated data and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new datas.  If this</span>
 <span class="s0">* is not necessarily the case, you should use enqueue_index_buffer() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Data::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The IndexBufferContext contains all of the pertinent information needed by</span>
 <span class="s0">* the GSG to keep track of this one particular data, and will exist as long</span>
 <span class="s0">* as the data is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Data or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* IndexBufferContext will be deleted.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">IndexBufferContext *PreparedGraphicsObjects::prepare_index_buffer_now(GeomPrimitive *data, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2862 21 enqueue_shader_buffer 0 4 3299 46 PreparedGraphicsObjects::enqueue_shader_buffer 0 1 1307 155</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a buffer would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void PreparedGraphicsObjects::enqueue_shader_buffer(ShaderBuffer *data);</span>

<span class="s0">2863 23 is_shader_buffer_queued 0 4 3299 48 PreparedGraphicsObjects::is_shader_buffer_queued 0 1 1308 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the index buffer has been queued on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">bool PreparedGraphicsObjects::is_shader_buffer_queued(ShaderBuffer const *data) const;</span>

<span class="s0">2864 21 dequeue_shader_buffer 0 4 3299 46 PreparedGraphicsObjects::dequeue_shader_buffer 0 1 1309 383</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a buffer from the queued list of data arrays to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the data will automatically be</span>
 <span class="s0">* dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the buffer is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">bool PreparedGraphicsObjects::dequeue_shader_buffer(ShaderBuffer *data);</span>

<span class="s0">2865 25 is_shader_buffer_prepared 0 4 3299 50 PreparedGraphicsObjects::is_shader_buffer_prepared 0 1 1310 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the index buffer has been prepared on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">bool PreparedGraphicsObjects::is_shader_buffer_prepared(ShaderBuffer const *data) const;</span>

<span class="s0">2866 21 release_shader_buffer 0 4 3299 46 PreparedGraphicsObjects::release_shader_buffer 0 1 1311 481</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that a data context, created by a previous call to</span>
 <span class="s0">* prepare_shader_buffer(), is no longer needed.  The driver resources will not</span>
 <span class="s0">* be freed until some GSG calls update(), indicating it is at a stage where</span>
 <span class="s0">* it is ready to release datas--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing datas (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_shader_buffer is called).</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">void PreparedGraphicsObjects::release_shader_buffer(BufferContext *bc);</span>

<span class="s0">2867 26 release_all_shader_buffers 0 4 3299 51 PreparedGraphicsObjects::release_all_shader_buffers 0 1 1312 175</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all datas at once.  This will force them to be reloaded into data</span>
 <span class="s0">* memory for all GSG's that share this object.  Returns the number of datas</span>
 <span class="s0">* released.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">int PreparedGraphicsObjects::release_all_shader_buffers(void);</span>

<span class="s0">2868 29 get_num_queued_shader_buffers 0 4 3299 54 PreparedGraphicsObjects::get_num_queued_shader_buffers 0 1 1313 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of index buffers that have been enqueued to be prepared</span>
 <span class="s0">* on this GSG.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">int PreparedGraphicsObjects::get_num_queued_shader_buffers(void) const;</span>

<span class="s0">2869 31 get_num_prepared_shader_buffers 0 4 3299 56 PreparedGraphicsObjects::get_num_prepared_shader_buffers 0 1 1314 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of index buffers that have already been prepared on this</span>
 <span class="s0">* GSG.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">int PreparedGraphicsObjects::get_num_prepared_shader_buffers(void) const;</span>

<span class="s0">2870 25 prepare_shader_buffer_now 0 4 3299 50 PreparedGraphicsObjects::prepare_shader_buffer_now 0 1 1315 712</span>
<span class="s0">/**</span>
 <span class="s0">* Immediately creates a new BufferContext for the indicated data and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new datas.  If this</span>
 <span class="s0">* is not necessarily the case, you should use enqueue_shader_buffer() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Data::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The BufferContext contains all of the pertinent information needed by</span>
 <span class="s0">* the GSG to keep track of this one particular data, and will exist as long</span>
 <span class="s0">* as the data is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Data or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* BufferContext will be deleted.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">BufferContext *PreparedGraphicsObjects::prepare_shader_buffer_now(ShaderBuffer *data, GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2871 23 upcast_to_BufferContext 0 12 3300 43 IndexBufferContext::upcast_to_BufferContext 0 1 1321 47</span>
<span class="s0">upcast from IndexBufferContext to BufferContext</span>
<span class="s0">65</span>
<span class="s0">BufferContext *IndexBufferContext::upcast_to_BufferContext(void);</span>

<span class="s0">2872 30 downcast_to_IndexBufferContext 0 12 3240 45 BufferContext::downcast_to_IndexBufferContext 0 0 49</span>
<span class="s0">downcast from BufferContext to IndexBufferContext</span>
<span class="s0">72</span>
<span class="s0">IndexBufferContext *BufferContext::downcast_to_IndexBufferContext(void);</span>

<span class="s0">2873 25 upcast_to_AdaptiveLruPage 0 12 3300 45 IndexBufferContext::upcast_to_AdaptiveLruPage 0 1 1322 49</span>
<span class="s0">upcast from IndexBufferContext to AdaptiveLruPage</span>
<span class="s0">69</span>
<span class="s0">AdaptiveLruPage *IndexBufferContext::upcast_to_AdaptiveLruPage(void);</span>

<span class="s0">2874 30 downcast_to_IndexBufferContext 0 12 3165 47 AdaptiveLruPage::downcast_to_IndexBufferContext 0 0 51</span>
<span class="s0">downcast from AdaptiveLruPage to IndexBufferContext</span>
<span class="s0">74</span>
<span class="s0">IndexBufferContext *AdaptiveLruPage::downcast_to_IndexBufferContext(void);</span>

<span class="s0">2875 8 get_data 0 4 3300 28 IndexBufferContext::get_data 0 1 1316 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the client-side array data object.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline GeomPrimitive *IndexBufferContext::get_data(void) const;</span>

<span class="s0">2876 12 changed_size 0 4 3300 32 IndexBufferContext::changed_size 0 1 1317 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has changed size since the last time mark_loaded()</span>
 <span class="s0">* was called.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline bool IndexBufferContext::changed_size(GeomPrimitivePipelineReader const *reader) const;</span>

<span class="s0">2877 18 changed_usage_hint 0 4 3300 38 IndexBufferContext::changed_usage_hint 0 1 1318 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has changed its usage hint since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">inline bool IndexBufferContext::changed_usage_hint(GeomPrimitivePipelineReader const *reader) const;</span>

<span class="s0">2878 12 was_modified 0 4 3300 32 IndexBufferContext::was_modified 0 1 1319 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has been modified since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline bool IndexBufferContext::was_modified(GeomPrimitivePipelineReader const *reader) const;</span>

<span class="s0">2879 14 get_class_type 0 4 3300 34 IndexBufferContext::get_class_type 0 1 1320 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle IndexBufferContext::get_class_type(void);</span>

<span class="s0">2880 19 ~IndexBufferContext 0 516 3300 39 IndexBufferContext::~IndexBufferContext 0 0 0</span>
<span class="s0">46</span>
<span class="s0">IndexBufferContext::~IndexBufferContext(void);</span>

<span class="s0">2881 9 make_copy 0 6 3301 15 Lens::make_copy 0 1 1323 0</span>
<span class="s0">58</span>
<span class="s0">virtual PointerTo&lt; Lens &gt; Lens::make_copy(void) const = 0;</span>

<span class="s0">2882 7 extrude 0 4 3301 13 Lens::extrude 0 2 1324 1325 948</span>
<span class="s0">/**</span>
 <span class="s0">* Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is</span>
 <span class="s0">* the center of the lens and (-1,-1) is the lower-left corner, compute the</span>
 <span class="s0">* corresponding vector in space that maps to this point, if such a vector can</span>
 <span class="s0">* be determined.  The vector is returned by indicating the points on the near</span>
 <span class="s0">* plane and far plane that both map to the indicated 2-d point.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the vector is defined, or false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is</span>
 <span class="s0">* the center of the lens and (-1,-1) is the lower-left corner, compute the</span>
 <span class="s0">* corresponding vector in space that maps to this point, if such a vector can</span>
 <span class="s0">* be determined.  The vector is returned by indicating the points on the near</span>
 <span class="s0">* plane and far plane that both map to the indicated 2-d point.</span>
 <span class="s0">*</span>
 <span class="s0">* The z coordinate of the 2-d point is ignored.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the vector is defined, or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">195</span>
<span class="s0">inline bool Lens::extrude(LPoint2 const &amp;point2d, LPoint3 &amp;near_point, LPoint3 &amp;far_point) const;</span>
<span class="s0">inline bool Lens::extrude(LPoint3 const &amp;point2d, LPoint3 &amp;near_point, LPoint3 &amp;far_point) const;</span>

<span class="s0">2883 13 extrude_depth 0 4 3301 19 Lens::extrude_depth 0 1 1326 262</span>
<span class="s0">/**</span>
 <span class="s0">* Uses the depth component of the 3-d result from project() to compute the</span>
 <span class="s0">* original point in 3-d space corresponding to a particular point on the</span>
 <span class="s0">* lens.  This exactly reverses project(), assuming the point does fall</span>
 <span class="s0">* legitimately within the lens.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline bool Lens::extrude_depth(LPoint3 const &amp;point2d, LPoint3 &amp;point3d) const;</span>

<span class="s0">2884 11 extrude_vec 0 4 3301 17 Lens::extrude_vec 0 2 1327 1328 1080</span>
<span class="s0">/**</span>
 <span class="s0">* Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is</span>
 <span class="s0">* the center of the lens and (-1,-1) is the lower-left corner, compute the</span>
 <span class="s0">* vector that corresponds to the view direction.  This will be parallel to</span>
 <span class="s0">* the normal on the surface (the far plane) corresponding to the lens shape</span>
 <span class="s0">* at this point.</span>
 <span class="s0">*</span>
 <span class="s0">* See the comment block on Lens::extrude_vec_impl() for a more in-depth</span>
 <span class="s0">* comment on the meaning of this vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the vector is defined, or false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is</span>
 <span class="s0">* the center of the lens and (-1,-1) is the lower-left corner, compute the</span>
 <span class="s0">* vector that corresponds to the view direction.  This will be parallel to</span>
 <span class="s0">* the normal on the surface (the far plane) corresponding to the lens shape</span>
 <span class="s0">* at this point.</span>
 <span class="s0">*</span>
 <span class="s0">* See the comment block on Lens::extrude_vec_impl() for a more in-depth</span>
 <span class="s0">* comment on the meaning of this vector.</span>
 <span class="s0">*</span>
 <span class="s0">* The z coordinate of the 2-d point is ignored.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the vector is defined, or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">inline bool Lens::extrude_vec(LPoint2 const &amp;point2d, LVector3 &amp;vec3d) const;</span>
<span class="s0">inline bool Lens::extrude_vec(LPoint3 const &amp;point2d, LVector3 &amp;vec3d) const;</span>

<span class="s0">2885 7 project 0 4 3301 13 Lens::project 0 2 1329 1330 1069</span>
<span class="s0">/**</span>
 <span class="s0">* Given a 3-d point in space, determine the 2-d point this maps to, in the</span>
 <span class="s0">* range (-1,1) in both dimensions, where (0,0) is the center of the lens and</span>
 <span class="s0">* (-1,-1) is the lower-left corner.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the 3-d point is in front of the lens and within the</span>
 <span class="s0">* viewing frustum (in which case point2d is filled in), or false otherwise</span>
 <span class="s0">* (in which case point2d will be filled in with something, which may or may</span>
 <span class="s0">* not be meaningful).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Given a 3-d point in space, determine the 2-d point this maps to, in the</span>
 <span class="s0">* range (-1,1) in both dimensions, where (0,0) is the center of the lens and</span>
 <span class="s0">* (-1,-1) is the lower-left corner.</span>
 <span class="s0">*</span>
 <span class="s0">* The z coordinate will also be set to a value in the range (-1, 1), where 1</span>
 <span class="s0">* represents a point on the near plane, and -1 represents a point on the far</span>
 <span class="s0">* plane.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the 3-d point is in front of the lens and within the</span>
 <span class="s0">* viewing frustum (in which case point2d is filled in), or false otherwise</span>
 <span class="s0">* (in which case point2d will be filled in with something, which may or may</span>
 <span class="s0">* not be meaningful).</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">inline bool Lens::project(LPoint3 const &amp;point3d, LPoint3 &amp;point2d) const;</span>
<span class="s0">inline bool Lens::project(LPoint3 const &amp;point3d, LPoint2 &amp;point2d) const;</span>

<span class="s0">2886 16 set_change_event 0 4 3301 22 Lens::set_change_event 0 1 1331 343</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the name of the event that will be generated whenever any properties</span>
 <span class="s0">* of the Lens have changed.  If this is not set for a particular lens, no</span>
 <span class="s0">* event will be generated.</span>
 <span class="s0">*</span>
 <span class="s0">* The event is thrown with one parameter, the lens itself.  This can be used</span>
 <span class="s0">* to automatically track changes to camera fov, etc.  in the application.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void Lens::set_change_event(std::string const &amp;event);</span>

<span class="s0">2887 16 get_change_event 0 4 3301 22 Lens::get_change_event 0 1 1332 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the event that will be generated whenever any</span>
 <span class="s0">* properties of this particular Lens have changed.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::string const &amp;Lens::get_change_event(void) const;</span>

<span class="s0">2888 21 set_coordinate_system 0 4 3301 27 Lens::set_coordinate_system 0 1 1333 138</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the coordinate system that all 3-d computations are performed</span>
 <span class="s0">* within for this Lens.  Normally, this is CS_default.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void Lens::set_coordinate_system(CoordinateSystem cs);</span>

<span class="s0">2889 21 get_coordinate_system 0 4 3301 27 Lens::get_coordinate_system 0 1 1334 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the coordinate system that all 3-d computations are performed</span>
 <span class="s0">* within for this Lens.  Normally, this is CS_default.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline CoordinateSystem Lens::get_coordinate_system(void) const;</span>

<span class="s0">2890 5 clear 0 4 3301 11 Lens::clear 0 1 1335 72</span>
<span class="s0">/**</span>
 <span class="s0">* Resets all lens parameters to their initial default settings.</span>
 <span class="s0">*/</span>
<span class="s0">23</span>
<span class="s0">void Lens::clear(void);</span>

<span class="s0">2891 13 set_film_size 0 4 3301 19 Lens::set_film_size 0 3 1336 1337 1338 1744</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the horizontal size of the film without changing its shape.  The</span>
 <span class="s0">* aspect ratio remains unchanged; this computes the vertical size of the film</span>
 <span class="s0">* to automatically maintain the aspect ratio.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the size and shape of the &quot;film&quot; within the lens.  This both</span>
 <span class="s0">* establishes the units used by calls like set_focal_length(), and</span>
 <span class="s0">* establishes the aspect ratio of the frame.</span>
 <span class="s0">*</span>
 <span class="s0">* In a physical camera, the field of view of a lens is determined by the</span>
 <span class="s0">* lens' focal length and by the size of the film area exposed by the lens.</span>
 <span class="s0">* For instance, a 35mm camera exposes a rectangle on the film about 24mm x</span>
 <span class="s0">* 36mm, which means a 50mm lens gives about a 40-degree horizontal field of</span>
 <span class="s0">* view.</span>
 <span class="s0">*</span>
 <span class="s0">* In the virtual camera, you may set the film size to any units here, and</span>
 <span class="s0">* specify a focal length in the same units to simulate the same effect.  Or,</span>
 <span class="s0">* you may ignore this parameter, and specify the field of view and aspect</span>
 <span class="s0">* ratio of the lens directly.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the size and shape of the &quot;film&quot; within the lens.  This both</span>
 <span class="s0">* establishes the units used by calls like set_focal_length(), and</span>
 <span class="s0">* establishes the aspect ratio of the frame.</span>
 <span class="s0">*</span>
 <span class="s0">* In a physical camera, the field of view of a lens is determined by the</span>
 <span class="s0">* lens' focal length and by the size of the film area exposed by the lens.</span>
 <span class="s0">* For instance, a 35mm camera exposes a rectangle on the film about 24mm x</span>
 <span class="s0">* 36mm, which means a 50mm lens gives about a 40-degree horizontal field of</span>
 <span class="s0">* view.</span>
 <span class="s0">*</span>
 <span class="s0">* In the virtual camera, you may set the film size to any units here, and</span>
 <span class="s0">* specify a focal length in the same units to simulate the same effect.  Or,</span>
 <span class="s0">* you may ignore this parameter, and specify the field of view and aspect</span>
 <span class="s0">* ratio of the lens directly.</span>
 <span class="s0">*/</span>
<span class="s0">184</span>
<span class="s0">inline void Lens::set_film_size(PN_stdfloat width);</span>
<span class="s0">inline void Lens::set_film_size(PN_stdfloat width, PN_stdfloat height);</span>
<span class="s0">inline void Lens::set_film_size(LVecBase2 const &amp;film_size);</span>

<span class="s0">2892 13 get_film_size 0 4 3301 19 Lens::get_film_size 0 1 1339 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the horizontal and vertical film size of the virtual film.  See</span>
 <span class="s0">* set_film_size().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LVecBase2 const &amp;Lens::get_film_size(void) const;</span>

<span class="s0">2893 15 set_film_offset 0 4 3301 21 Lens::set_film_offset 0 2 1340 1341 388</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the horizontal and vertical offset amounts of this Lens.  These are</span>
 <span class="s0">* both in the same units specified in set_film_size().</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to establish an off-axis lens.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the horizontal and vertical offset amounts of this Lens.  These are</span>
 <span class="s0">* both in the same units specified in set_film_size().</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to establish an off-axis lens.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">inline void Lens::set_film_offset(PN_stdfloat x, PN_stdfloat y);</span>
<span class="s0">inline void Lens::set_film_offset(LVecBase2 const &amp;film_offset);</span>

<span class="s0">2894 15 get_film_offset 0 4 3301 21 Lens::get_film_offset 0 1 1342 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the horizontal and vertical offset amounts of this Lens.  See</span>
 <span class="s0">* set_film_offset().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline LVector2 const &amp;Lens::get_film_offset(void) const;</span>

<span class="s0">2895 16 set_focal_length 0 4 3301 22 Lens::set_focal_length 0 1 1343 246</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the focal length of the lens.  This may adjust the field-of-view</span>
 <span class="s0">* correspondingly, and is an alternate way to specify field of view.</span>
 <span class="s0">*</span>
 <span class="s0">* For certain kinds of lenses (e.g.  OrthographicLens), the focal length has</span>
 <span class="s0">* no meaning.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void Lens::set_focal_length(PN_stdfloat focal_length);</span>

<span class="s0">2896 16 get_focal_length 0 4 3301 22 Lens::get_focal_length 0 1 1344 257</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the focal length of the lens.  This may have been set explicitly by</span>
 <span class="s0">* a previous call to set_focal_length(), or it may be computed based on the</span>
 <span class="s0">* lens' fov and film_size.  For certain kinds of lenses, the focal length has</span>
 <span class="s0">* no meaning.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PN_stdfloat Lens::get_focal_length(void) const;</span>

<span class="s0">2897 11 set_min_fov 0 4 3301 17 Lens::set_min_fov 0 1 1345 499</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the field of view of the smallest dimension of the window.  If the</span>
 <span class="s0">* window is wider than it is tall, this specifies the vertical field of view;</span>
 <span class="s0">* if it is taller than it is wide, this specifies the horizontal field of</span>
 <span class="s0">* view.</span>
 <span class="s0">*</span>
 <span class="s0">* In many cases, this is preferable to setting either the horizontal or</span>
 <span class="s0">* vertical field of view explicitly.  Setting this parameter means that</span>
 <span class="s0">* pulling the window wider will widen the field of view, which is usually</span>
 <span class="s0">* what you expect to happen.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void Lens::set_min_fov(PN_stdfloat min_fov);</span>

<span class="s0">2898 7 set_fov 0 4 3301 13 Lens::set_fov 0 3 1346 1347 1348 837</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the horizontal field of view of the lens without changing the aspect</span>
 <span class="s0">* ratio.  The vertical field of view is adjusted to maintain the same aspect</span>
 <span class="s0">* ratio.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the field of view of the lens in both dimensions.  This establishes</span>
 <span class="s0">* both the field of view and the aspect ratio of the lens.  This is one way</span>
 <span class="s0">* to specify the field of view of a lens; set_focal_length() is another way.</span>
 <span class="s0">*</span>
 <span class="s0">* For certain kinds of lenses (like OrthoLens), the field of view has no</span>
 <span class="s0">* meaning.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the field of view of the lens in both dimensions.  This establishes</span>
 <span class="s0">* both the field of view and the aspect ratio of the lens.  This is one way</span>
 <span class="s0">* to specify the field of view of a lens; set_focal_length() is another way.</span>
 <span class="s0">*</span>
 <span class="s0">* For certain kinds of lenses (like OrthographicLens), the field of view has</span>
 <span class="s0">* no meaning.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">inline void Lens::set_fov(PN_stdfloat fov);</span>
<span class="s0">inline void Lens::set_fov(PN_stdfloat hfov, PN_stdfloat vfov);</span>
<span class="s0">inline void Lens::set_fov(LVecBase2 const &amp;fov);</span>

<span class="s0">2899 7 get_fov 0 4 3301 13 Lens::get_fov 0 1 1349 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the horizontal and vertical film size of the virtual film.  See</span>
 <span class="s0">* set_fov().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline LVecBase2 const &amp;Lens::get_fov(void) const;</span>

<span class="s0">2900 8 get_hfov 0 4 3301 14 Lens::get_hfov 0 1 1350 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the horizontal component of fov only.  See get_fov().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline PN_stdfloat Lens::get_hfov(void) const;</span>

<span class="s0">2901 8 get_vfov 0 4 3301 14 Lens::get_vfov 0 1 1351 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the vertical component of fov only.  See get_fov().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline PN_stdfloat Lens::get_vfov(void) const;</span>

<span class="s0">2902 11 get_min_fov 0 4 3301 17 Lens::get_min_fov 0 1 1352 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the field of view of the narrowest dimension of the window.  See</span>
 <span class="s0">* set_min_fov().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">PN_stdfloat Lens::get_min_fov(void) const;</span>

<span class="s0">2903 16 set_aspect_ratio 0 4 3301 22 Lens::set_aspect_ratio 0 1 1353 189</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the aspect ratio of the lens.  This is the ratio of the height to the</span>
 <span class="s0">* width of the generated image.  Setting this overrides the two-parameter fov</span>
 <span class="s0">* or film size setting.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void Lens::set_aspect_ratio(PN_stdfloat aspect_ratio);</span>

<span class="s0">2904 16 get_aspect_ratio 0 4 3301 22 Lens::get_aspect_ratio 0 1 1354 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the aspect ratio of the Lens.  This is determined based on the</span>
 <span class="s0">* indicated film size; see set_film_size().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PN_stdfloat Lens::get_aspect_ratio(void) const;</span>

<span class="s0">2905 8 set_near 0 4 3301 14 Lens::set_near 0 1 1355 142</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the position of the near plane (or cylinder, sphere, whatever).</span>
 <span class="s0">* Points closer to the lens than this may not be rendered.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void Lens::set_near(PN_stdfloat near_distance);</span>

<span class="s0">2906 8 get_near 0 4 3301 14 Lens::get_near 0 1 1356 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the near plane (or cylinder, sphere, whatever).</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline PN_stdfloat Lens::get_near(void) const;</span>

<span class="s0">2907 7 set_far 0 4 3301 13 Lens::set_far 0 1 1357 144</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the position of the far plane (or cylinder, sphere, whatever).</span>
 <span class="s0">* Points farther from the lens than this may not be rendered.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void Lens::set_far(PN_stdfloat far_distance);</span>

<span class="s0">2908 7 get_far 0 4 3301 13 Lens::get_far 0 1 1358 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the far plane (or cylinder, sphere, whatever).</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline PN_stdfloat Lens::get_far(void) const;</span>

<span class="s0">2909 12 set_near_far 0 4 3301 18 Lens::set_near_far 0 1 1359 58</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously changes the near and far planes.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline void Lens::set_near_far(PN_stdfloat near_distance, PN_stdfloat far_distance);</span>

<span class="s0">2910 16 get_default_near 0 4 3301 22 Lens::get_default_near 0 1 1360 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default near plane distance that will be assigned to each</span>
 <span class="s0">* newly-created lens.  This is read from the Config.prc file.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">static PN_stdfloat Lens::get_default_near(void);</span>

<span class="s0">2911 15 get_default_far 0 4 3301 21 Lens::get_default_far 0 1 1361 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default far plane distance that will be assigned to each newly-</span>
 <span class="s0">* created lens.  This is read from the Config.prc file.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static PN_stdfloat Lens::get_default_far(void);</span>

<span class="s0">2912 12 set_view_hpr 0 4 3301 18 Lens::set_view_hpr 0 2 1362 1363 624</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the direction in which the lens is facing.  Normally, this is down the</span>
 <span class="s0">* forward axis (usually the Y axis), but it may be rotated.  This is only one</span>
 <span class="s0">* way of specifying the rotation; you may also specify an explicit vector in</span>
 <span class="s0">* which to look, or you may give a complete transformation matrix.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the direction in which the lens is facing.  Normally, this is down the</span>
 <span class="s0">* forward axis (usually the Y axis), but it may be rotated.  This is only one</span>
 <span class="s0">* way of specifying the rotation; you may also specify an explicit vector in</span>
 <span class="s0">* which to look, or you may give a complete transformation matrix.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">inline void Lens::set_view_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>
<span class="s0">void Lens::set_view_hpr(LVecBase3 const &amp;view_hpr);</span>

<span class="s0">2913 12 get_view_hpr 0 4 3301 18 Lens::get_view_hpr 0 1 1364 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the direction in which the lens is facing.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">LVecBase3 const &amp;Lens::get_view_hpr(void) const;</span>

<span class="s0">2914 15 set_view_vector 0 4 3301 21 Lens::set_view_vector 0 2 1365 1366 372</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the direction in which the lens is facing by giving an axis to</span>
 <span class="s0">* look along, and a perpendicular (or at least non-parallel) up axis.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_view_hpr().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies the direction in which the lens is facing by giving an axis to</span>
 <span class="s0">* look along, and a perpendicular (or at least non-parallel) up axis.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_view_hpr().</span>
 <span class="s0">*/</span>
<span class="s0">208</span>
<span class="s0">inline void Lens::set_view_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat i, PN_stdfloat j, PN_stdfloat k);</span>
<span class="s0">void Lens::set_view_vector(LVector3 const &amp;view_vector, LVector3 const &amp;up_vector);</span>

<span class="s0">2915 15 get_view_vector 0 4 3301 21 Lens::get_view_vector 0 1 1367 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the axis along which the lens is facing.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">LVector3 const &amp;Lens::get_view_vector(void) const;</span>

<span class="s0">2916 13 get_up_vector 0 4 3301 19 Lens::get_up_vector 0 1 1368 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the axis perpendicular to the camera's view vector that indicates</span>
 <span class="s0">* the &quot;up&quot; direction.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">LVector3 const &amp;Lens::get_up_vector(void) const;</span>

<span class="s0">2917 15 get_nodal_point 0 4 3301 21 Lens::get_nodal_point 0 1 1369 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the center point of the lens: the point from which the lens is</span>
 <span class="s0">* viewing.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">LPoint3 Lens::get_nodal_point(void) const;</span>

<span class="s0">2918 24 set_interocular_distance 0 4 3301 30 Lens::set_interocular_distance 0 1 1370 459</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the distance between the left and right eyes of a stereo camera.  This</span>
 <span class="s0">* distance is used to apply a stereo effect when the lens is rendered on a</span>
 <span class="s0">* stereo display region.  It only has an effect on a PerspectiveLens.</span>
 <span class="s0">*</span>
 <span class="s0">* The left eye and the right eye are each offset along the X axis by half of</span>
 <span class="s0">* this distance, so that this parameter specifies the total distance between</span>
 <span class="s0">* them.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_convergence_distance(), which relates.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void Lens::set_interocular_distance(PN_stdfloat interocular_distance);</span>

<span class="s0">2919 24 get_interocular_distance 0 4 3301 30 Lens::get_interocular_distance 0 1 1371 42</span>
<span class="s0">/**</span>
 <span class="s0">* See set_interocular_distance().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline PN_stdfloat Lens::get_interocular_distance(void) const;</span>

<span class="s0">2920 24 set_convergence_distance 0 4 3301 30 Lens::set_convergence_distance 0 1 1372 1332</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the distance between between the camera plane and the point in the</span>
 <span class="s0">* distance that the left and right eyes are both looking at.  This distance</span>
 <span class="s0">* is used to apply a stereo effect when the lens is rendered on a stereo</span>
 <span class="s0">* display region.  It only has an effect on a PerspectiveLens.</span>
 <span class="s0">*</span>
 <span class="s0">* This parameter must be greater than 0, but may be as large as you like.  It</span>
 <span class="s0">* controls the distance at which the two stereo images will appear to</span>
 <span class="s0">* converge, which is a normal property of stereo vision.  Normally this</span>
 <span class="s0">* should be set to the distance from the camera to the area of interest in</span>
 <span class="s0">* your scene.  Anything beyond this distance will appear to go into the</span>
 <span class="s0">* screen, and anything closer will appear to come out of the screen.  If you</span>
 <span class="s0">* want to simulate parallel stereo, set this to infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this creates an off-axis frustum, which means that the lenses are</span>
 <span class="s0">* still pointing in the same direction, which is usually more desirable than</span>
 <span class="s0">* the more naive toe-in approach, where the two lenses are simply tilted</span>
 <span class="s0">* toward each other.</span>
 <span class="s0">*</span>
 <span class="s0">* Prior to Panda3D 1.9.0, the convergence was being calculated incorrectly.</span>
 <span class="s0">* It has since been corrected.  To restore the legacy behavior you can set</span>
 <span class="s0">* the stereo-lens-old-convergence variable to true.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_interocular_distance(), which relates.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void Lens::set_convergence_distance(PN_stdfloat convergence_distance);</span>

<span class="s0">2921 24 get_convergence_distance 0 4 3301 30 Lens::get_convergence_distance 0 1 1373 42</span>
<span class="s0">/**</span>
 <span class="s0">* See set_convergence_distance().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline PN_stdfloat Lens::get_convergence_distance(void) const;</span>

<span class="s0">2922 12 set_view_mat 0 4 3301 18 Lens::set_view_mat 0 1 1374 489</span>
<span class="s0">/**</span>
 <span class="s0">* Sets an arbitrary transformation on the lens.  This replaces the individual</span>
 <span class="s0">* transformation components like set_view_hpr().</span>
 <span class="s0">*</span>
 <span class="s0">* Setting a transformation here will have a slightly different effect than</span>
 <span class="s0">* putting one on the LensNode that contains this lens.  In particular,</span>
 <span class="s0">* lighting and other effects computations will still be performed on the lens</span>
 <span class="s0">* in its untransformed (facing forward) position, but the actual projection</span>
 <span class="s0">* matrix will be transformed by this matrix.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void Lens::set_view_mat(LMatrix4 const &amp;view_mat);</span>

<span class="s0">2923 12 get_view_mat 0 4 3301 18 Lens::get_view_mat 0 1 1375 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the direction in which the lens is facing.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LMatrix4 const &amp;Lens::get_view_mat(void) const;</span>

<span class="s0">2924 14 clear_view_mat 0 4 3301 20 Lens::clear_view_mat 0 1 1376 49</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the lens transform to identity.</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">void Lens::clear_view_mat(void);</span>

<span class="s0">2925 12 set_keystone 0 4 3301 18 Lens::set_keystone 0 1 1377 617</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the ratio of keystone correction to perform on the lens, in each</span>
 <span class="s0">* of three axes.  This will build a special non-affine scale factor into the</span>
 <span class="s0">* projection matrix that will compensate for keystoning of a projected image;</span>
 <span class="s0">* this can be used to compensate for a projector that for physical reasons</span>
 <span class="s0">* cannot be aimed directly at its screen.</span>
 <span class="s0">*</span>
 <span class="s0">* The default value is taken from the default-keystone Config variable.  0, 0</span>
 <span class="s0">* indicates no keystone correction; specify a small value (usually in the</span>
 <span class="s0">* range -1 .. 1) in either the x or y position to generate a keystone</span>
 <span class="s0">* correction in that axis.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void Lens::set_keystone(LVecBase2 const &amp;keystone);</span>

<span class="s0">2926 12 get_keystone 0 4 3301 18 Lens::get_keystone 0 1 1378 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the keystone correction specified for the lens.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LVecBase2 const &amp;Lens::get_keystone(void) const;</span>

<span class="s0">2927 14 clear_keystone 0 4 3301 20 Lens::clear_keystone 0 1 1379 49</span>
<span class="s0">/**</span>
 <span class="s0">* Disables the lens keystone correction.</span>
 <span class="s0">*/</span>
<span class="s0">32</span>
<span class="s0">void Lens::clear_keystone(void);</span>

<span class="s0">2928 19 set_custom_film_mat 0 4 3301 25 Lens::set_custom_film_mat 0 1 1380 425</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a custom matrix to transform the points on the film after they</span>
 <span class="s0">* have been converted into nominal film space (-1 .. 1 in U and V).  This can</span>
 <span class="s0">* be used to introduce arbitrary scales, rotations, or other linear</span>
 <span class="s0">* transforms to the media plane.  This is normally a 2-d matrix, but a full</span>
 <span class="s0">* 4x4 matrix may be specified.  This is applied on top of any film size, lens</span>
 <span class="s0">* shift, and/or keystone correction.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void Lens::set_custom_film_mat(LMatrix4 const &amp;custom_film_mat);</span>

<span class="s0">2929 19 get_custom_film_mat 0 4 3301 25 Lens::get_custom_film_mat 0 1 1381 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the custom_film_mat specified for the lens.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline LMatrix4 const &amp;Lens::get_custom_film_mat(void) const;</span>

<span class="s0">2930 21 clear_custom_film_mat 0 4 3301 27 Lens::clear_custom_film_mat 0 1 1382 56</span>
<span class="s0">/**</span>
 <span class="s0">* Disables the lens custom_film_mat correction.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void Lens::clear_custom_film_mat(void);</span>

<span class="s0">2931 24 set_frustum_from_corners 0 4 3301 30 Lens::set_frustum_from_corners 0 1 1383 2188</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the lens to use the frustum defined by the four indicated points.</span>
 <span class="s0">* This is most useful for a PerspectiveLens, but it may be called for other</span>
 <span class="s0">* kinds of lenses as well.</span>
 <span class="s0">*</span>
 <span class="s0">* The frustum will be rooted at the origin (or by whatever translation might</span>
 <span class="s0">* have been specified in a previous call to set_view_mat).</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal for the four points not to be arranged in a rectangle; if this</span>
 <span class="s0">* is the case, the frustum will be fitted as tightly as possible to cover all</span>
 <span class="s0">* four points.</span>
 <span class="s0">*</span>
 <span class="s0">* The flags parameter contains the union of one or more of the following bits</span>
 <span class="s0">* to control the behavior of this function:</span>
 <span class="s0">*</span>
 <span class="s0">* FC_roll - If this is included, the camera may be rotated so that its up</span>
 <span class="s0">* vector is perpendicular to the top line.  Otherwise, the standard up vector</span>
 <span class="s0">* is used.</span>
 <span class="s0">*</span>
 <span class="s0">* FC_camera_plane - This allows the camera plane to be adjusted to be as</span>
 <span class="s0">* nearly perpendicular to the center of the frustum as possible.  Without</span>
 <span class="s0">* this bit, the orientation camera plane is defined by position of the four</span>
 <span class="s0">* points (which should all be coplanar).  With this bit, the camera plane is</span>
 <span class="s0">* arbitrary, and may be chosen so that the four points do not themselves lie</span>
 <span class="s0">* in the camera plane (but the points will still be within the frustum).</span>
 <span class="s0">*</span>
 <span class="s0">* FC_off_axis - This allows the resulting frustum to be off-axis to get the</span>
 <span class="s0">* tightest possible fit.  Without this bit, the viewing axis will be centered</span>
 <span class="s0">* within the frustum, but there may be more wasted space along the edges.</span>
 <span class="s0">*</span>
 <span class="s0">* FC_aspect_ratio - This allows the frustum to be scaled non-proportionately</span>
 <span class="s0">* in the vertical and horizontal dimensions, if necessary, to get a tighter</span>
 <span class="s0">* fit.  Without this bit, the current aspect ratio will be preserved.</span>
 <span class="s0">*</span>
 <span class="s0">* FC_shear - This allows the frustum to be sheared, if necessary, to get the</span>
 <span class="s0">* tightest possible fit.  This may result in a parallelogram-based frustum,</span>
 <span class="s0">* which will give a slanted appearance to the rendered image.  Without this</span>
 <span class="s0">* bit, the frustum will be rectangle-based.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, if 0 is passed in as the value for flags, the generated frustum</span>
 <span class="s0">* will be a loose fit but sane; if -1 is passed in, it will be a tighter fit</span>
 <span class="s0">* and possibly screwy.</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">void Lens::set_frustum_from_corners(LVecBase3 const &amp;ul, LVecBase3 const &amp;ur, LVecBase3 const &amp;ll, LVecBase3 const &amp;lr, int flags);</span>

<span class="s0">2932 13 recompute_all 0 4 3301 19 Lens::recompute_all 0 1 1384 169</span>
<span class="s0">/**</span>
 <span class="s0">* Forces all internal parameters of the Lens to be recomputed.  Normally,</span>
 <span class="s0">* this should never need to be called; it is provided only to assist in</span>
 <span class="s0">* debugging.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void Lens::recompute_all(void);</span>

<span class="s0">2933 9 is_linear 0 6 3301 15 Lens::is_linear 0 1 1385 206</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the lens represents a linear projection (e.g.</span>
 <span class="s0">* PerspectiveLens, OrthographicLens), and therefore there is a valid matrix</span>
 <span class="s0">* returned by get_projection_mat(), or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">virtual bool Lens::is_linear(void) const;</span>

<span class="s0">2934 14 is_perspective 0 6 3301 20 Lens::is_perspective 0 1 1386 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the lens represents a perspective projection (i.e.  it is a</span>
 <span class="s0">* PerspectiveLens), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">virtual bool Lens::is_perspective(void) const;</span>

<span class="s0">2935 15 is_orthographic 0 6 3301 21 Lens::is_orthographic 0 1 1387 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the lens represents a orthographic projection (i.e.  it is</span>
 <span class="s0">* a OrthographicLens), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">virtual bool Lens::is_orthographic(void) const;</span>

<span class="s0">2936 13 make_geometry 0 6 3301 19 Lens::make_geometry 0 1 1388 236</span>
<span class="s0">/**</span>
 <span class="s0">* Allocates and returns a new Geom that can be rendered to show a visible</span>
 <span class="s0">* representation of the frustum used for this kind of lens, if it makes sense</span>
 <span class="s0">* to do so.  If a visible representation cannot be created, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">virtual PointerTo&lt; Geom &gt; Lens::make_geometry(void);</span>

<span class="s0">2937 11 make_bounds 0 6 3301 17 Lens::make_bounds 0 1 1389 190</span>
<span class="s0">/**</span>
 <span class="s0">* Allocates and returns a new BoundingVolume that encloses the frustum used</span>
 <span class="s0">* for this kind of lens, if possible.  If a suitable bounding volume cannot</span>
 <span class="s0">* be created, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">virtual PointerTo&lt; BoundingVolume &gt; Lens::make_bounds(void) const;</span>

<span class="s0">2938 18 get_projection_mat 0 4 3301 24 Lens::get_projection_mat 0 1 1390 183</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete transformation matrix from a 3-d point in space to a</span>
 <span class="s0">* point on the film, if such a matrix exists, or the identity matrix if the</span>
 <span class="s0">* lens is nonlinear.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">inline LMatrix4 const &amp;Lens::get_projection_mat(Lens::StereoChannel channel = ::Lens::SC_mono) const;</span>

<span class="s0">2939 22 get_projection_mat_inv 0 4 3301 28 Lens::get_projection_mat_inv 0 1 1391 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the matrix that transforms from a 2-d point on the film to a 3-d</span>
 <span class="s0">* vector in space, if such a matrix exists.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">inline LMatrix4 const &amp;Lens::get_projection_mat_inv(Lens::StereoChannel channel = ::Lens::SC_mono) const;</span>

<span class="s0">2940 12 get_film_mat 0 4 3301 18 Lens::get_film_mat 0 1 1392 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the matrix that transforms from a point behind the lens to a point</span>
 <span class="s0">* on the film.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LMatrix4 const &amp;Lens::get_film_mat(void) const;</span>

<span class="s0">2941 16 get_film_mat_inv 0 4 3301 22 Lens::get_film_mat_inv 0 1 1393 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the matrix that transforms from a point on the film to a point</span>
 <span class="s0">* behind the lens.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LMatrix4 const &amp;Lens::get_film_mat_inv(void) const;</span>

<span class="s0">2942 12 get_lens_mat 0 4 3301 18 Lens::get_lens_mat 0 1 1394 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the matrix that transforms from a point in front of the lens to a</span>
 <span class="s0">* point in space.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LMatrix4 const &amp;Lens::get_lens_mat(void) const;</span>

<span class="s0">2943 16 get_lens_mat_inv 0 4 3301 22 Lens::get_lens_mat_inv 0 1 1395 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the matrix that transforms from a point in space to a point in</span>
 <span class="s0">* front of the lens.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LMatrix4 const &amp;Lens::get_lens_mat_inv(void) const;</span>

<span class="s0">2944 6 output 0 6 3301 12 Lens::output 0 1 1396 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">virtual void Lens::output(std::ostream &amp;out) const;</span>

<span class="s0">2945 5 write 0 6 3301 11 Lens::write 0 1 1397 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">virtual void Lens::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2946 15 get_last_change 0 4 3301 21 Lens::get_last_change 0 1 1398 192</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the UpdateSeq that is incremented whenever the lens properties are</span>
 <span class="s0">* changed.  As long as this number remains the same, you may assume the lens</span>
 <span class="s0">* properties are unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline UpdateSeq Lens::get_last_change(void) const;</span>

<span class="s0">2947 14 get_class_type 0 4 3301 20 Lens::get_class_type 0 1 1399 0</span>
<span class="s0">45</span>
<span class="s0">static TypeHandle Lens::get_class_type(void);</span>

<span class="s0">2948 5 ~Lens 0 516 3301 11 Lens::~Lens 0 0 0</span>
<span class="s0">18</span>
<span class="s0">Lens::~Lens(void);</span>

<span class="s0">2949 37 upcast_to_TypedWritableReferenceCount 0 12 3319 47 Material::upcast_to_TypedWritableReferenceCount 0 1 1449 51</span>
<span class="s0">upcast from Material to TypedWritableReferenceCount</span>
<span class="s0">83</span>
<span class="s0">TypedWritableReferenceCount *Material::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">2950 20 downcast_to_Material 0 12 3180 49 TypedWritableReferenceCount::downcast_to_Material 0 0 53</span>
<span class="s0">downcast from TypedWritableReferenceCount to Material</span>
<span class="s0">66</span>
<span class="s0">Material *TypedWritableReferenceCount::downcast_to_Material(void);</span>

<span class="s0">2951 17 upcast_to_Namable 0 12 3319 27 Material::upcast_to_Namable 0 1 1450 31</span>
<span class="s0">upcast from Material to Namable</span>
<span class="s0">43</span>
<span class="s0">Namable *Material::upcast_to_Namable(void);</span>

<span class="s0">2952 20 downcast_to_Material 0 12 3164 29 Namable::downcast_to_Material 0 0 33</span>
<span class="s0">downcast from Namable to Material</span>
<span class="s0">46</span>
<span class="s0">Material *Namable::downcast_to_Material(void);</span>

<span class="s0">2953 8 Material 0 260 3319 18 Material::Material 0 2 1400 1401 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline explicit Material::Material(std::string const &amp;name = &quot;&quot;);</span>
<span class="s0">inline Material::Material(Material const &amp;copy);</span>

<span class="s0">2954 10 operator = 0 4 3319 20 Material::operator = 0 1 1402 0</span>
<span class="s0">48</span>
<span class="s0">void Material::operator =(Material const &amp;copy);</span>

<span class="s0">2955 9 ~Material 0 518 3319 19 Material::~Material 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">virtual inline Material::~Material(void);</span>

<span class="s0">2956 11 get_default 0 4 3319 21 Material::get_default 0 1 1403 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default material.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static inline Material *Material::get_default(void);</span>

<span class="s0">2957 14 has_base_color 0 4 3319 24 Material::has_base_color 0 1 1404 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the base color has been explicitly set for this material,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool Material::has_base_color(void) const;</span>

<span class="s0">2958 14 get_base_color 0 4 3319 24 Material::get_base_color 0 1 1405 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the base_color color setting, if it has been set.  If neither the</span>
 <span class="s0">* base color nor the metallic have been set, this returns the diffuse color.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LColor const &amp;Material::get_base_color(void) const;</span>

<span class="s0">2959 14 set_base_color 0 4 3319 24 Material::set_base_color 0 1 1406 444</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the base color of the material.  In conjunction with</span>
 <span class="s0">* set_metallic, this is an alternate way to specify the color of a material.</span>
 <span class="s0">* For dielectrics, this will determine the value of the diffuse color, and</span>
 <span class="s0">* for metals, this will determine the value of the specular color.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this will clear an explicit specular, diffuse or ambient color</span>
 <span class="s0">* assignment.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the object color will be used.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void Material::set_base_color(LColor const &amp;color);</span>

<span class="s0">2960 16 clear_base_color 0 4 3319 26 Material::clear_base_color 0 1 1407 67</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the explicit base_color color from the material.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void Material::clear_base_color(void);</span>

<span class="s0">2961 11 has_ambient 0 4 3319 21 Material::has_ambient 0 1 1408 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ambient color has been explicitly set for this</span>
 <span class="s0">* material, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool Material::has_ambient(void) const;</span>

<span class="s0">2962 11 get_ambient 0 4 3319 21 Material::get_ambient 0 1 1409 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ambient color setting, if it has been set.  Returns (0,0,0,0)</span>
 <span class="s0">* if the ambient color has not been set.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LColor const &amp;Material::get_ambient(void) const;</span>

<span class="s0">2963 11 set_ambient 0 4 3319 21 Material::set_ambient 0 1 1410 313</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the ambient color setting of the material.  This will be the</span>
 <span class="s0">* multiplied by any ambient lights in effect on the material to set its base</span>
 <span class="s0">* color.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the color of the object as it appears in the absence of direct</span>
 <span class="s0">* light.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the object color will be used.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void Material::set_ambient(LColor const &amp;color);</span>

<span class="s0">2964 13 clear_ambient 0 4 3319 23 Material::clear_ambient 0 1 1411 64</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the explicit ambient color from the material.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void Material::clear_ambient(void);</span>

<span class="s0">2965 11 has_diffuse 0 4 3319 21 Material::has_diffuse 0 1 1412 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the diffuse color has been explicitly set for this</span>
 <span class="s0">* material, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool Material::has_diffuse(void) const;</span>

<span class="s0">2966 11 get_diffuse 0 4 3319 21 Material::get_diffuse 0 1 1413 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the diffuse color setting, if it has been set.  Returns (1,1,1,1)</span>
 <span class="s0">* if the diffuse color has not been set.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LColor const &amp;Material::get_diffuse(void) const;</span>

<span class="s0">2967 11 set_diffuse 0 4 3319 21 Material::set_diffuse 0 1 1414 396</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the diffuse color setting of the material.  This will be</span>
 <span class="s0">* multiplied by any lights in effect on the material to get the color in the</span>
 <span class="s0">* parts of the object illuminated by the lights.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the primary color of an object; the color of the object as it</span>
 <span class="s0">* appears in direct light, in the absence of highlights.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the object color will be used.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void Material::set_diffuse(LColor const &amp;color);</span>

<span class="s0">2968 13 clear_diffuse 0 4 3319 23 Material::clear_diffuse 0 1 1415 64</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the explicit diffuse color from the material.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void Material::clear_diffuse(void);</span>

<span class="s0">2969 12 has_specular 0 4 3319 22 Material::has_specular 0 1 1416 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the specular color has been explicitly set for this</span>
 <span class="s0">* material, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool Material::has_specular(void) const;</span>

<span class="s0">2970 12 get_specular 0 4 3319 22 Material::get_specular 0 1 1417 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the specular color setting, if it has been set.  Returns (0,0,0,0)</span>
 <span class="s0">* if the specular color has not been set.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LColor const &amp;Material::get_specular(void) const;</span>

<span class="s0">2971 12 set_specular 0 4 3319 22 Material::set_specular 0 1 1418 448</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the specular color setting of the material.  This will be</span>
 <span class="s0">* multiplied by any lights in effect on the material to compute the color of</span>
 <span class="s0">* specular highlights on the object.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the highlight color of an object: the color of small highlight</span>
 <span class="s0">* reflections.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the specular color is taken from the index of</span>
 <span class="s0">* refraction, which is 1 by default (meaning no specular reflections are</span>
 <span class="s0">* generated).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void Material::set_specular(LColor const &amp;color);</span>

<span class="s0">2972 14 clear_specular 0 4 3319 24 Material::clear_specular 0 1 1419 65</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the explicit specular color from the material.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void Material::clear_specular(void);</span>

<span class="s0">2973 12 has_emission 0 4 3319 22 Material::has_emission 0 1 1420 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the emission color has been explicitly set for this</span>
 <span class="s0">* material, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool Material::has_emission(void) const;</span>

<span class="s0">2974 12 get_emission 0 4 3319 22 Material::get_emission 0 1 1421 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the emission color setting, if it has been set.  Returns (0,0,0,0)</span>
 <span class="s0">* if the emission color has not been set.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LColor const &amp;Material::get_emission(void) const;</span>

<span class="s0">2975 12 set_emission 0 4 3319 22 Material::set_emission 0 1 1422 437</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the emission color setting of the material.  This is the color of</span>
 <span class="s0">* the object as it appears in the absence of any light whatsover, including</span>
 <span class="s0">* ambient light.  It is as if the object is glowing by this color (although</span>
 <span class="s0">* of course it will not illuminate neighboring objects).</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the object will not glow by its own light and will only</span>
 <span class="s0">* appear visible in the presence of one or more lights.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void Material::set_emission(LColor const &amp;color);</span>

<span class="s0">2976 14 clear_emission 0 4 3319 24 Material::clear_emission 0 1 1423 65</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the explicit emission color from the material.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void Material::clear_emission(void);</span>

<span class="s0">2977 13 get_shininess 0 4 3319 23 Material::get_shininess 0 1 1424 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the shininess exponent of the material.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PN_stdfloat Material::get_shininess(void) const;</span>

<span class="s0">2978 13 set_shininess 0 4 3319 23 Material::set_shininess 0 1 1425 429</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the shininess exponent of the material.  This controls the size of the</span>
 <span class="s0">* specular highlight spot.  In general, larger number produce a smaller</span>
 <span class="s0">* specular highlight, which makes the object appear shinier.  Smaller numbers</span>
 <span class="s0">* produce a larger highlight, which makes the object appear less shiny.</span>
 <span class="s0">*</span>
 <span class="s0">* This is usually in the range 0..128.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting a shininess value removes any previous roughness assignment.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void Material::set_shininess(PN_stdfloat shininess);</span>

<span class="s0">2979 13 has_roughness 0 4 3319 23 Material::has_roughness 0 1 1426 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the roughness has been explicitly set for this material,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool Material::has_roughness(void) const;</span>

<span class="s0">2980 13 get_roughness 0 4 3319 23 Material::get_roughness 0 1 1427 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the roughness previously specified by set_roughness.  If none was</span>
 <span class="s0">* previously set, this value is computed from the shininess value.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">PN_stdfloat Material::get_roughness(void) const;</span>

<span class="s0">2981 13 set_roughness 0 4 3319 23 Material::set_roughness 0 1 1428 379</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the roughness exponent of the material, where 0 is completely shiny</span>
 <span class="s0">* (infinite shininess), and 1 is a completely dull object (0 shininess).</span>
 <span class="s0">* This is a different, more perceptually intuitive way of controlling the</span>
 <span class="s0">* size of the specular spot, and more commonly used in physically-based</span>
 <span class="s0">* rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting a roughness recalculates the shininess value.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void Material::set_roughness(PN_stdfloat roughness);</span>

<span class="s0">2982 12 has_metallic 0 4 3319 22 Material::has_metallic 0 1 1429 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the metallic has been explicitly set for this material,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool Material::has_metallic(void) const;</span>

<span class="s0">2983 12 get_metallic 0 4 3319 22 Material::get_metallic 0 1 1430 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the metallic setting, if it has been set.  Returns 0 if it has not</span>
 <span class="s0">* been set.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PN_stdfloat Material::get_metallic(void) const;</span>

<span class="s0">2984 12 set_metallic 0 4 3319 22 Material::set_metallic 0 1 1431 369</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the metallic setting of the material, which is is used for physically-</span>
 <span class="s0">* based rendering models.  This is usually 0 for dielectric materials and 1</span>
 <span class="s0">* for metals.  It really does not make sense to set this to a value other</span>
 <span class="s0">* than 0 or 1, but it is nonetheless a float for compatibility with tools</span>
 <span class="s0">* that allow setting this to values other than 0 or 1.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void Material::set_metallic(PN_stdfloat metallic);</span>

<span class="s0">2985 14 clear_metallic 0 4 3319 24 Material::clear_metallic 0 1 1432 67</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the explicit metallic setting from the material.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void Material::clear_metallic(void);</span>

<span class="s0">2986 20 has_refractive_index 0 4 3319 30 Material::has_refractive_index 0 1 1433 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a refractive index has explicitly been specified for this</span>
 <span class="s0">* material.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool Material::has_refractive_index(void) const;</span>

<span class="s0">2987 20 get_refractive_index 0 4 3319 30 Material::get_refractive_index 0 1 1434 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of refraction, or 1 if none has been set for this</span>
 <span class="s0">* material.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline PN_stdfloat Material::get_refractive_index(void) const;</span>

<span class="s0">2988 20 set_refractive_index 0 4 3319 30 Material::set_refractive_index 0 1 1435 356</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the index of refraction of the material, which is used to determine</span>
 <span class="s0">* the specular color in absence of an explicit specular color assignment.</span>
 <span class="s0">* This is usually 1.5 for dielectric materials.  It is not very useful for</span>
 <span class="s0">* metals, since they cannot be described as easily with a single number.</span>
 <span class="s0">*</span>
 <span class="s0">* Should be 1 or higher.  The default is 1.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void Material::set_refractive_index(PN_stdfloat refractive_index);</span>

<span class="s0">2989 9 get_local 0 4 3319 19 Material::get_local 0 1 1436 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the local viewer flag.  Set set_local().</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool Material::get_local(void) const;</span>

<span class="s0">2990 9 set_local 0 4 3319 19 Material::set_local 0 1 1437 252</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the local viewer flag.  Set this true to enable camera-relative</span>
 <span class="s0">* specular highlights, or false to use orthogonal specular highlights.  The</span>
 <span class="s0">* default value is true.  Applications that use orthogonal projection should</span>
 <span class="s0">* specify false.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void Material::set_local(bool local);</span>

<span class="s0">2991 11 get_twoside 0 4 3319 21 Material::get_twoside 0 1 1438 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the state of the two-sided lighting flag.  See set_twoside().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool Material::get_twoside(void) const;</span>

<span class="s0">2992 11 set_twoside 0 4 3319 21 Material::set_twoside 0 1 1439 241</span>
<span class="s0">/**</span>
 <span class="s0">* Set this true to enable two-sided lighting.  When two-sided lighting is on,</span>
 <span class="s0">* both sides of a polygon will be lit by this material.  The default is for</span>
 <span class="s0">* two-sided lighting to be off, in which case only the front surface is lit.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void Material::set_twoside(bool twoside);</span>

<span class="s0">2993 11 operator == 0 4 3319 21 Material::operator == 0 1 1440 0</span>
<span class="s0">63</span>
<span class="s0">inline bool Material::operator ==(Material const &amp;other) const;</span>

<span class="s0">2994 11 operator != 0 4 3319 21 Material::operator != 0 1 1441 0</span>
<span class="s0">63</span>
<span class="s0">inline bool Material::operator !=(Material const &amp;other) const;</span>

<span class="s0">2995 10 operator &lt; 0 4 3319 20 Material::operator &lt; 0 1 1442 0</span>
<span class="s0">62</span>
<span class="s0">inline bool Material::operator &lt;(Material const &amp;other) const;</span>

<span class="s0">2996 10 compare_to 0 4 3319 20 Material::compare_to 0 1 1443 266</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this material sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">* The sorting order is arbitrary and largely meaningless, except to</span>
 <span class="s0">* differentiate different materials.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int Material::compare_to(Material const &amp;other) const;</span>

<span class="s0">2997 6 output 0 4 3319 16 Material::output 0 1 1444 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void Material::output(std::ostream &amp;out) const;</span>

<span class="s0">2998 5 write 0 4 3319 15 Material::write 0 1 1445 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void Material::write(std::ostream &amp;out, int indent) const;</span>

<span class="s0">2999 16 is_attrib_locked 0 4 3319 26 Material::is_attrib_locked 0 1 1446 62</span>
<span class="s0">/**</span>
 <span class="s0">* @deprecated This no longer has any meaning in 1.10.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool Material::is_attrib_locked(void) const;</span>

<span class="s0">3000 15 set_attrib_lock 0 4 3319 25 Material::set_attrib_lock 0 1 1447 62</span>
<span class="s0">/**</span>
 <span class="s0">* @deprecated This no longer has any meaning in 1.10.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void Material::set_attrib_lock(void);</span>

<span class="s0">3001 14 get_class_type 0 4 3319 24 Material::get_class_type 0 1 1448 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle Material::get_class_type(void);</span>

<span class="s0">3002 12 get_material 0 4 3320 26 MaterialPool::get_material 0 1 1451 657</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a Material pointer that represents the same material described by</span>
 <span class="s0">* temp, except that it is a shared pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* Each call to get_material() passing an equivalent Material pointer will</span>
 <span class="s0">* return the same shared pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* If you modify the shared pointer, it will automatically disassociate it</span>
 <span class="s0">* from the pool.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, the return value may be a different pointer than that passed in, or</span>
 <span class="s0">* it may be the same pointer.  In either case, the passed in pointer has now</span>
 <span class="s0">* been sacrificed to the greater good and should not be used again (like any</span>
 <span class="s0">* other PointerTo, it will be freed when the last reference count is</span>
 <span class="s0">* removed).</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">static inline Material *MaterialPool::get_material(Material *temp);</span>

<span class="s0">3003 16 release_material 0 4 3320 30 MaterialPool::release_material 0 1 1452 56</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated material from the pool.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline void MaterialPool::release_material(Material *temp);</span>

<span class="s0">3004 21 release_all_materials 0 4 3320 35 MaterialPool::release_all_materials 0 1 1453 90</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all materials in the pool and restores the pool to the empty</span>
 <span class="s0">* state.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">static inline void MaterialPool::release_all_materials(void);</span>

<span class="s0">3005 15 garbage_collect 0 4 3320 29 MaterialPool::garbage_collect 0 1 1454 215</span>
<span class="s0">/**</span>
 <span class="s0">* Releases only those materials in the pool that have a reference count of</span>
 <span class="s0">* exactly 1; i.e.  only those materials that are not being used outside of</span>
 <span class="s0">* the pool.  Returns the number of materials released.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">static inline int MaterialPool::garbage_collect(void);</span>

<span class="s0">3006 13 list_contents 0 4 3320 27 MaterialPool::list_contents 0 1 1455 82</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the material pool to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline void MaterialPool::list_contents(std::ostream &amp;out);</span>

<span class="s0">3007 5 write 0 4 3320 19 MaterialPool::write 0 1 1456 82</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the material pool to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static void MaterialPool::write(std::ostream &amp;out);</span>

<span class="s0">3008 13 ~MaterialPool 0 516 3320 27 MaterialPool::~MaterialPool 0 0 0</span>
<span class="s0">34</span>
<span class="s0">MaterialPool::~MaterialPool(void);</span>

<span class="s0">3009 10 MatrixLens 0 260 3321 22 MatrixLens::MatrixLens 0 1 1457 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">inline MatrixLens::MatrixLens(void);</span>

<span class="s0">3010 12 set_user_mat 0 4 3321 24 MatrixLens::set_user_mat 0 1 1458 559</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly specifies the projection matrix.  This matrix should convert X</span>
 <span class="s0">* and Y to the range [-film_size/2, film_size/2], where (-fs/2,-fs/2) is the</span>
 <span class="s0">* lower left corner of the screen and (fs/2, fs/2) is the upper right.  Z</span>
 <span class="s0">* should go to the range [-1, 1], where -1 is the near plane and 1 is the far</span>
 <span class="s0">* plane.  Note that this is a left-handed Y-up coordinate system.</span>
 <span class="s0">*</span>
 <span class="s0">* The default film_size for a MatrixLens is 2, so the default range is [-1,</span>
 <span class="s0">* 1] for both X and Y.  This is consistent with the GL conventions for</span>
 <span class="s0">* projection matrices.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void MatrixLens::set_user_mat(LMatrix4 const &amp;user_mat);</span>

<span class="s0">3011 12 get_user_mat 0 4 3321 24 MatrixLens::get_user_mat 0 1 1459 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the explicit projection matrix as set by the user.  This does not</span>
 <span class="s0">* include transforms on the lens or film (e.g.  a film offset or view hpr).</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LMatrix4 const &amp;MatrixLens::get_user_mat(void) const;</span>

<span class="s0">3012 16 set_left_eye_mat 0 4 3321 28 MatrixLens::set_left_eye_mat 0 1 1460 424</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a custom projection matrix for the left eye.  This is only used if the</span>
 <span class="s0">* lens is attached to a stereo camera, in which case the left eye matrix will</span>
 <span class="s0">* be used to draw the scene in the left eye (but the center matrix--the</span>
 <span class="s0">* user_mat--will still be used to cull the scene).</span>
 <span class="s0">*</span>
 <span class="s0">* This matrix should not be too different from the center matrix (set by</span>
 <span class="s0">* set_user_mat()) or culling errors may become obvious.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void MatrixLens::set_left_eye_mat(LMatrix4 const &amp;user_mat);</span>

<span class="s0">3013 18 clear_left_eye_mat 0 4 3321 30 MatrixLens::clear_left_eye_mat 0 1 1461 130</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the custom projection matrix set for the left eye, and uses the</span>
 <span class="s0">* center matrix (set by set_user_mat) instead.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void MatrixLens::clear_left_eye_mat(void);</span>

<span class="s0">3014 16 has_left_eye_mat 0 4 3321 28 MatrixLens::has_left_eye_mat 0 1 1462 179</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the camera has a custom projection matrix set for the left</span>
 <span class="s0">* eye, or false if the center matrix (set by set_user_mat) will be used for</span>
 <span class="s0">* the left eye.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool MatrixLens::has_left_eye_mat(void) const;</span>

<span class="s0">3015 16 get_left_eye_mat 0 4 3321 28 MatrixLens::get_left_eye_mat 0 1 1463 148</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the custom projection matrix for the left eye, if any, or the</span>
 <span class="s0">* center matrix if there is no custom matrix set for the left eye.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LMatrix4 const &amp;MatrixLens::get_left_eye_mat(void) const;</span>

<span class="s0">3016 17 set_right_eye_mat 0 4 3321 29 MatrixLens::set_right_eye_mat 0 1 1464 427</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a custom projection matrix for the right eye.  This is only used if</span>
 <span class="s0">* the lens is attached to a stereo camera, in which case the right eye matrix</span>
 <span class="s0">* will be used to draw the scene in the right eye (but the center matrix--the</span>
 <span class="s0">* user_mat--will still be used to cull the scene).</span>
 <span class="s0">*</span>
 <span class="s0">* This matrix should not be too different from the center matrix (set by</span>
 <span class="s0">* set_user_mat()) or culling errors may become obvious.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void MatrixLens::set_right_eye_mat(LMatrix4 const &amp;user_mat);</span>

<span class="s0">3017 19 clear_right_eye_mat 0 4 3321 31 MatrixLens::clear_right_eye_mat 0 1 1465 131</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the custom projection matrix set for the right eye, and uses the</span>
 <span class="s0">* center matrix (set by set_user_mat) instead.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void MatrixLens::clear_right_eye_mat(void);</span>

<span class="s0">3018 17 has_right_eye_mat 0 4 3321 29 MatrixLens::has_right_eye_mat 0 1 1466 181</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the camera has a custom projection matrix set for the right</span>
 <span class="s0">* eye, or false if the center matrix (set by set_user_mat) will be used for</span>
 <span class="s0">* the right eye.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool MatrixLens::has_right_eye_mat(void) const;</span>

<span class="s0">3019 17 get_right_eye_mat 0 4 3321 29 MatrixLens::get_right_eye_mat 0 1 1467 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the custom projection matrix for the right eye, if any, or the</span>
 <span class="s0">* center matrix if there is no custom matrix set for the right eye.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline LMatrix4 const &amp;MatrixLens::get_right_eye_mat(void) const;</span>

<span class="s0">3020 14 get_class_type 0 4 3321 26 MatrixLens::get_class_type 0 1 1468 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle MatrixLens::get_class_type(void);</span>

<span class="s0">3021 11 ~MatrixLens 0 516 3321 23 MatrixLens::~MatrixLens 0 0 0</span>
<span class="s0">30</span>
<span class="s0">MatrixLens::~MatrixLens(void);</span>

<span class="s0">3022 16 OrthographicLens 0 260 3322 34 OrthographicLens::OrthographicLens 0 1 1469 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline OrthographicLens::OrthographicLens(void);</span>

<span class="s0">3023 14 get_class_type 0 4 3322 32 OrthographicLens::get_class_type 0 1 1470 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle OrthographicLens::get_class_type(void);</span>

<span class="s0">3024 17 ~OrthographicLens 0 516 3322 35 OrthographicLens::~OrthographicLens 0 0 0</span>
<span class="s0">42</span>
<span class="s0">OrthographicLens::~OrthographicLens(void);</span>

<span class="s0">3025 19 ParamTextureSampler 0 260 3323 40 ParamTextureSampler::ParamTextureSampler 0 1 1471 94</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new ParamTextureSampler storing the given texture and sampler</span>
 <span class="s0">* objects.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline ParamTextureSampler::ParamTextureSampler(Texture *tex, SamplerState const &amp;sampler);</span>

<span class="s0">3026 11 get_texture 0 4 3323 32 ParamTextureSampler::get_texture 0 1 1472 57</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the texture stored in the parameter.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline Texture *ParamTextureSampler::get_texture(void) const;</span>

<span class="s0">3027 11 get_sampler 0 4 3323 32 ParamTextureSampler::get_sampler 0 1 1473 63</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the sampler state stored in the parameter.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline SamplerState const &amp;ParamTextureSampler::get_sampler(void) const;</span>

<span class="s0">3028 14 get_class_type 0 4 3323 35 ParamTextureSampler::get_class_type 0 1 1474 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle ParamTextureSampler::get_class_type(void);</span>

<span class="s0">3029 20 ~ParamTextureSampler 0 516 3323 41 ParamTextureSampler::~ParamTextureSampler 0 0 0</span>
<span class="s0">48</span>
<span class="s0">ParamTextureSampler::~ParamTextureSampler(void);</span>

<span class="s0">3030 17 ParamTextureImage 0 260 3326 36 ParamTextureImage::ParamTextureImage 0 1 1475 101</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new ParamTextureImage storing the given texture and image binding</span>
 <span class="s0">* parameters.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">inline ParamTextureImage::ParamTextureImage(Texture *tex, bool read, bool write, int z = -1, int n = 0);</span>

<span class="s0">3031 11 get_texture 0 4 3326 30 ParamTextureImage::get_texture 0 1 1476 57</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the texture stored in the parameter.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline Texture *ParamTextureImage::get_texture(void) const;</span>

<span class="s0">3032 15 has_read_access 0 4 3326 34 ParamTextureImage::has_read_access 0 1 1477 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this image should be bound with read access enabled.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool ParamTextureImage::has_read_access(void) const;</span>

<span class="s0">3033 16 has_write_access 0 4 3326 35 ParamTextureImage::has_write_access 0 1 1478 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this image should be bound with write access enabled.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool ParamTextureImage::has_write_access(void) const;</span>

<span class="s0">3034 16 get_bind_layered 0 4 3326 35 ParamTextureImage::get_bind_layered 0 1 1479 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all layers of this image should be bound simultaneously.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool ParamTextureImage::get_bind_layered(void) const;</span>

<span class="s0">3035 14 get_bind_level 0 4 3326 33 ParamTextureImage::get_bind_level 0 1 1480 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the image level that should be bound.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int ParamTextureImage::get_bind_level(void) const;</span>

<span class="s0">3036 14 get_bind_layer 0 4 3326 33 ParamTextureImage::get_bind_layer 0 1 1481 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the image layer that should be bound.  This is undefined if</span>
 <span class="s0">* get_bind_layered() returns false.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int ParamTextureImage::get_bind_layer(void) const;</span>

<span class="s0">3037 14 get_class_type 0 4 3326 33 ParamTextureImage::get_class_type 0 1 1482 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle ParamTextureImage::get_class_type(void);</span>

<span class="s0">3038 18 ~ParamTextureImage 0 516 3326 37 ParamTextureImage::~ParamTextureImage 0 0 0</span>
<span class="s0">44</span>
<span class="s0">ParamTextureImage::~ParamTextureImage(void);</span>

<span class="s0">3039 15 PerspectiveLens 0 260 3327 32 PerspectiveLens::PerspectiveLens 0 2 1483 1484 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">132</span>
<span class="s0">inline PerspectiveLens::PerspectiveLens(void);</span>
<span class="s0">inline explicit PerspectiveLens::PerspectiveLens(PN_stdfloat hfov, PN_stdfloat vfov);</span>

<span class="s0">3040 14 get_class_type 0 4 3327 31 PerspectiveLens::get_class_type 0 1 1485 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle PerspectiveLens::get_class_type(void);</span>

<span class="s0">3041 16 ~PerspectiveLens 0 516 3327 33 PerspectiveLens::~PerspectiveLens 0 0 0</span>
<span class="s0">40</span>
<span class="s0">PerspectiveLens::~PerspectiveLens(void);</span>

<span class="s0">3042 20 TextureReloadRequest 0 260 3328 42 TextureReloadRequest::TextureReloadRequest 0 2 1486 1487 122</span>
<span class="s0">/**</span>
 <span class="s0">* Create a new TextureReloadRequest, and add it to the loader via</span>
 <span class="s0">* load_async(), to begin an asynchronous load.</span>
 <span class="s0">*/</span>
<span class="s0">246</span>
<span class="s0">inline explicit TextureReloadRequest::TextureReloadRequest(std::string const &amp;name, PreparedGraphicsObjects *pgo, Texture *texture, bool allow_compressed);</span>
<span class="s0">inline TextureReloadRequest::TextureReloadRequest(TextureReloadRequest const &amp;) = default;</span>

<span class="s0">3043 29 get_prepared_graphics_objects 0 4 3328 51 TextureReloadRequest::get_prepared_graphics_objects 0 1 1488 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the PreparedGraphicsObjects object associated with this</span>
 <span class="s0">* asynchronous TextureReloadRequest.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline PreparedGraphicsObjects *TextureReloadRequest::get_prepared_graphics_objects(void) const;</span>

<span class="s0">3044 11 get_texture 0 4 3328 33 TextureReloadRequest::get_texture 0 1 1489 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Texture object associated with this asynchronous</span>
 <span class="s0">* TextureReloadRequest.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline Texture *TextureReloadRequest::get_texture(void) const;</span>

<span class="s0">3045 20 get_allow_compressed 0 4 3328 42 TextureReloadRequest::get_allow_compressed 0 1 1490 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;allow compressed&quot; flag associated with this asynchronous</span>
 <span class="s0">* TextureReloadRequest.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline bool TextureReloadRequest::get_allow_compressed(void) const;</span>

<span class="s0">3046 8 is_ready 0 4 3328 30 TextureReloadRequest::is_ready 0 1 1491 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending.</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool TextureReloadRequest::is_ready(void) const;</span>

<span class="s0">3047 14 get_class_type 0 4 3328 36 TextureReloadRequest::get_class_type 0 1 1492 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle TextureReloadRequest::get_class_type(void);</span>

<span class="s0">3048 21 ~TextureReloadRequest 0 516 3328 43 TextureReloadRequest::~TextureReloadRequest 0 0 0</span>
<span class="s0">50</span>
<span class="s0">TextureReloadRequest::~TextureReloadRequest(void);</span>

<span class="s0">3049 23 upcast_to_BufferContext 0 12 3329 39 TextureContext::upcast_to_BufferContext 0 1 1505 43</span>
<span class="s0">upcast from TextureContext to BufferContext</span>
<span class="s0">61</span>
<span class="s0">BufferContext *TextureContext::upcast_to_BufferContext(void);</span>

<span class="s0">3050 26 downcast_to_TextureContext 0 12 3240 41 BufferContext::downcast_to_TextureContext 0 0 45</span>
<span class="s0">downcast from BufferContext to TextureContext</span>
<span class="s0">64</span>
<span class="s0">TextureContext *BufferContext::downcast_to_TextureContext(void);</span>

<span class="s0">3051 25 upcast_to_AdaptiveLruPage 0 12 3329 41 TextureContext::upcast_to_AdaptiveLruPage 0 1 1506 45</span>
<span class="s0">upcast from TextureContext to AdaptiveLruPage</span>
<span class="s0">65</span>
<span class="s0">AdaptiveLruPage *TextureContext::upcast_to_AdaptiveLruPage(void);</span>

<span class="s0">3052 26 downcast_to_TextureContext 0 12 3165 43 AdaptiveLruPage::downcast_to_TextureContext 0 0 47</span>
<span class="s0">downcast from AdaptiveLruPage to TextureContext</span>
<span class="s0">66</span>
<span class="s0">TextureContext *AdaptiveLruPage::downcast_to_TextureContext(void);</span>

<span class="s0">3053 11 get_texture 0 4 3329 27 TextureContext::get_texture 0 1 1493 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the associated Texture object.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline Texture *TextureContext::get_texture(void) const;</span>

<span class="s0">3054 8 get_view 0 4 3329 24 TextureContext::get_view 0 1 1494 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the specific view of a multiview texture this context represents.</span>
 <span class="s0">* In the usual case, with a non-multiview texture, this will be 0.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int TextureContext::get_view(void) const;</span>

<span class="s0">3055 13 get_native_id 0 6 3329 29 TextureContext::get_native_id 0 1 1495 198</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an implementation-defined handle or pointer that can be used</span>
 <span class="s0">* to interface directly with the underlying API.</span>
 <span class="s0">* Returns 0 if the underlying implementation does not support this.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual uint64_t TextureContext::get_native_id(void) const;</span>

<span class="s0">3056 20 get_native_buffer_id 0 6 3329 36 TextureContext::get_native_buffer_id 0 1 1496 253</span>
<span class="s0">/**</span>
 <span class="s0">* Similar to get_native_id, but some implementations use a separate</span>
 <span class="s0">* identifier for the buffer object associated with buffer textures.</span>
 <span class="s0">* Returns 0 if the underlying implementation does not support this, or</span>
 <span class="s0">* if this is not a buffer texture.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">virtual uint64_t TextureContext::get_native_buffer_id(void) const;</span>

<span class="s0">3057 12 was_modified 0 4 3329 28 TextureContext::was_modified 0 1 1497 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture properties or image have been modified since</span>
 <span class="s0">* the last time mark_loaded() was called.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool TextureContext::was_modified(void) const;</span>

<span class="s0">3058 23 was_properties_modified 0 4 3329 39 TextureContext::was_properties_modified 0 1 1498 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture properties (unrelated to the image) have been</span>
 <span class="s0">* modified since the last time mark_loaded() was called.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool TextureContext::was_properties_modified(void) const;</span>

<span class="s0">3059 18 was_image_modified 0 4 3329 34 TextureContext::was_image_modified 0 1 1499 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture image has been modified since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool TextureContext::was_image_modified(void) const;</span>

<span class="s0">3060 25 was_simple_image_modified 0 4 3329 41 TextureContext::was_simple_image_modified 0 1 1500 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture's &quot;simple&quot; image has been modified since the</span>
 <span class="s0">* last time mark_simple_loaded() was called.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline bool TextureContext::was_simple_image_modified(void) const;</span>

<span class="s0">3061 23 get_properties_modified 0 4 3329 39 TextureContext::get_properties_modified 0 1 1501 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture properties (unrelated to the image) are modified.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline UpdateSeq TextureContext::get_properties_modified(void) const;</span>

<span class="s0">3062 18 get_image_modified 0 4 3329 34 TextureContext::get_image_modified 0 1 1502 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture image data (including mipmap levels) are modified.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline UpdateSeq TextureContext::get_image_modified(void) const;</span>

<span class="s0">3063 25 get_simple_image_modified 0 4 3329 41 TextureContext::get_simple_image_modified 0 1 1503 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture's &quot;simple&quot; image data is modified.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline UpdateSeq TextureContext::get_simple_image_modified(void) const;</span>

<span class="s0">3064 14 get_class_type 0 4 3329 30 TextureContext::get_class_type 0 1 1504 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle TextureContext::get_class_type(void);</span>

<span class="s0">3065 15 ~TextureContext 0 516 3329 31 TextureContext::~TextureContext 0 0 0</span>
<span class="s0">38</span>
<span class="s0">TextureContext::~TextureContext(void);</span>

<span class="s0">3066 10 get_shader 0 4 3330 25 ShaderContext::get_shader 0 1 1507 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline Shader *ShaderContext::get_shader(void) const;</span>

<span class="s0">3067 14 get_class_type 0 4 3330 29 ShaderContext::get_class_type 0 1 1508 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle ShaderContext::get_class_type(void);</span>

<span class="s0">3068 14 ~ShaderContext 0 516 3330 29 ShaderContext::~ShaderContext 0 0 0</span>
<span class="s0">36</span>
<span class="s0">ShaderContext::~ShaderContext(void);</span>

<span class="s0">3069 16 UserVertexSlider 0 260 3332 34 UserVertexSlider::UserVertexSlider 0 2 1509 1510 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">explicit UserVertexSlider::UserVertexSlider(std::string const &amp;name);</span>
<span class="s0">explicit UserVertexSlider::UserVertexSlider(InternalName const *name);</span>

<span class="s0">3070 10 set_slider 0 4 3332 28 UserVertexSlider::set_slider 0 1 1511 45</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the indicated slider value.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void UserVertexSlider::set_slider(PN_stdfloat slider);</span>

<span class="s0">3071 14 get_class_type 0 4 3332 32 UserVertexSlider::get_class_type 0 1 1512 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle UserVertexSlider::get_class_type(void);</span>

<span class="s0">3072 17 ~UserVertexSlider 0 516 3332 35 UserVertexSlider::~UserVertexSlider 0 0 0</span>
<span class="s0">42</span>
<span class="s0">UserVertexSlider::~UserVertexSlider(void);</span>

<span class="s0">3073 19 UserVertexTransform 0 260 3333 40 UserVertexTransform::UserVertexTransform 0 1 1513 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">explicit UserVertexTransform::UserVertexTransform(std::string const &amp;name);</span>

<span class="s0">3074 8 get_name 0 4 3333 29 UserVertexTransform::get_name 0 1 1514 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name passed to the constructor.  Completely arbitrary.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline std::string const &amp;UserVertexTransform::get_name(void) const;</span>

<span class="s0">3075 10 set_matrix 0 4 3333 31 UserVertexTransform::set_matrix 0 1 1515 39</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the indicated matrix.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void UserVertexTransform::set_matrix(LMatrix4 const &amp;matrix);</span>

<span class="s0">3076 14 get_class_type 0 4 3333 35 UserVertexTransform::get_class_type 0 1 1516 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle UserVertexTransform::get_class_type(void);</span>

<span class="s0">3077 20 ~UserVertexTransform 0 516 3333 41 UserVertexTransform::~UserVertexTransform 0 0 0</span>
<span class="s0">48</span>
<span class="s0">UserVertexTransform::~UserVertexTransform(void);</span>

<span class="s0">3078 17 upcast_to_Texture 0 12 3334 31 VideoTexture::upcast_to_Texture 0 1 1521 35</span>
<span class="s0">upcast from VideoTexture to Texture</span>
<span class="s0">47</span>
<span class="s0">Texture *VideoTexture::upcast_to_Texture(void);</span>

<span class="s0">3079 24 downcast_to_VideoTexture 0 12 3276 33 Texture::downcast_to_VideoTexture 0 0 37</span>
<span class="s0">downcast from Texture to VideoTexture</span>
<span class="s0">54</span>
<span class="s0">VideoTexture *Texture::downcast_to_VideoTexture(void);</span>

<span class="s0">3080 23 upcast_to_AnimInterface 0 12 3334 37 VideoTexture::upcast_to_AnimInterface 0 1 1522 41</span>
<span class="s0">upcast from VideoTexture to AnimInterface</span>
<span class="s0">59</span>
<span class="s0">AnimInterface *VideoTexture::upcast_to_AnimInterface(void);</span>

<span class="s0">3081 24 downcast_to_VideoTexture 0 12 3335 39 AnimInterface::downcast_to_VideoTexture 0 0 43</span>
<span class="s0">downcast from AnimInterface to VideoTexture</span>
<span class="s0">60</span>
<span class="s0">VideoTexture *AnimInterface::downcast_to_VideoTexture(void);</span>

<span class="s0">3082 18 get_keep_ram_image 0 6 3334 32 VideoTexture::get_keep_ram_image 0 1 1517 207</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that indicates whether this Texture is eligible to have</span>
 <span class="s0">* its main RAM copy of the texture memory dumped when the texture is prepared</span>
 <span class="s0">* for rendering.  See set_keep_ram_image().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual bool VideoTexture::get_keep_ram_image(void) const;</span>

<span class="s0">3083 15 get_video_width 0 4 3334 29 VideoTexture::get_video_width 0 1 1518 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the width in texels of the source video stream.  This is not</span>
 <span class="s0">* necessarily the width of the actual texture, since the texture may have</span>
 <span class="s0">* been expanded to raise it to a power of 2.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int VideoTexture::get_video_width(void) const;</span>

<span class="s0">3084 16 get_video_height 0 4 3334 30 VideoTexture::get_video_height 0 1 1519 202</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the height in texels of the source video stream.  This is not</span>
 <span class="s0">* necessarily the height of the actual texture, since the texture may have</span>
 <span class="s0">* been expanded to raise it to a power of 2.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int VideoTexture::get_video_height(void) const;</span>

<span class="s0">3085 14 get_class_type 0 4 3334 28 VideoTexture::get_class_type 0 1 1520 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle VideoTexture::get_class_type(void);</span>

<span class="s0">3086 13 ~VideoTexture 0 516 3334 27 VideoTexture::~VideoTexture 0 0 0</span>
<span class="s0">34</span>
<span class="s0">VideoTexture::~VideoTexture(void);</span>

<span class="s0">3087 23 upcast_to_BufferContext 0 12 3336 44 VertexBufferContext::upcast_to_BufferContext 0 1 1528 48</span>
<span class="s0">upcast from VertexBufferContext to BufferContext</span>
<span class="s0">66</span>
<span class="s0">BufferContext *VertexBufferContext::upcast_to_BufferContext(void);</span>

<span class="s0">3088 31 downcast_to_VertexBufferContext 0 12 3240 46 BufferContext::downcast_to_VertexBufferContext 0 0 50</span>
<span class="s0">downcast from BufferContext to VertexBufferContext</span>
<span class="s0">74</span>
<span class="s0">VertexBufferContext *BufferContext::downcast_to_VertexBufferContext(void);</span>

<span class="s0">3089 25 upcast_to_AdaptiveLruPage 0 12 3336 46 VertexBufferContext::upcast_to_AdaptiveLruPage 0 1 1529 50</span>
<span class="s0">upcast from VertexBufferContext to AdaptiveLruPage</span>
<span class="s0">70</span>
<span class="s0">AdaptiveLruPage *VertexBufferContext::upcast_to_AdaptiveLruPage(void);</span>

<span class="s0">3090 31 downcast_to_VertexBufferContext 0 12 3165 48 AdaptiveLruPage::downcast_to_VertexBufferContext 0 0 52</span>
<span class="s0">downcast from AdaptiveLruPage to VertexBufferContext</span>
<span class="s0">76</span>
<span class="s0">VertexBufferContext *AdaptiveLruPage::downcast_to_VertexBufferContext(void);</span>

<span class="s0">3091 8 get_data 0 4 3336 29 VertexBufferContext::get_data 0 1 1523 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the client-side array data object.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline GeomVertexArrayData *VertexBufferContext::get_data(void) const;</span>

<span class="s0">3092 12 changed_size 0 4 3336 33 VertexBufferContext::changed_size 0 1 1524 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has changed size since the last time mark_loaded()</span>
 <span class="s0">* was called.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline bool VertexBufferContext::changed_size(GeomVertexArrayDataHandle const *reader) const;</span>

<span class="s0">3093 18 changed_usage_hint 0 4 3336 39 VertexBufferContext::changed_usage_hint 0 1 1525 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has changed its usage hint since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">inline bool VertexBufferContext::changed_usage_hint(GeomVertexArrayDataHandle const *reader) const;</span>

<span class="s0">3094 12 was_modified 0 4 3336 33 VertexBufferContext::was_modified 0 1 1526 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the data has been modified since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline bool VertexBufferContext::was_modified(GeomVertexArrayDataHandle const *reader) const;</span>

<span class="s0">3095 14 get_class_type 0 4 3336 35 VertexBufferContext::get_class_type 0 1 1527 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle VertexBufferContext::get_class_type(void);</span>

<span class="s0">3096 20 ~VertexBufferContext 0 516 3336 41 VertexBufferContext::~VertexBufferContext 0 0 0</span>
<span class="s0">48</span>
<span class="s0">VertexBufferContext::~VertexBufferContext(void);</span>

<span class="s0">3097 17 TextureCollection 0 260 3337 36 TextureCollection::TextureCollection 0 3 1530 1531 1532 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">186</span>
<span class="s0">TextureCollection::TextureCollection(void);</span>
<span class="s0">TextureCollection::TextureCollection(TextureCollection const &amp;copy);</span>
<span class="s0">TextureCollection::TextureCollection(PyObject *self, PyObject *sequence);</span>

<span class="s0">3098 10 operator = 0 4 3337 29 TextureCollection::operator = 0 1 1533 0</span>
<span class="s0">66</span>
<span class="s0">void TextureCollection::operator =(TextureCollection const &amp;copy);</span>

<span class="s0">3099 18 ~TextureCollection 0 516 3337 37 TextureCollection::~TextureCollection 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline TextureCollection::~TextureCollection(void);</span>

<span class="s0">3100 10 __reduce__ 0 4 3337 29 TextureCollection::__reduce__ 0 1 1534 0</span>
<span class="s0">62</span>
<span class="s0">PyObject *TextureCollection::__reduce__(PyObject *self) const;</span>

<span class="s0">3101 11 add_texture 0 4 3337 30 TextureCollection::add_texture 0 1 1535 48</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new Texture to the collection.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void TextureCollection::add_texture(Texture *texture);</span>

<span class="s0">3102 14 remove_texture 0 4 3337 33 TextureCollection::remove_texture 0 1 1536 154</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated Texture from the collection.  Returns true if the</span>
 <span class="s0">* texture was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">bool TextureCollection::remove_texture(Texture *texture);</span>

<span class="s0">3103 17 add_textures_from 0 4 3337 36 TextureCollection::add_textures_from 0 1 1537 211</span>
<span class="s0">/**</span>
 <span class="s0">* Adds all the Textures indicated in the other collection to this texture.</span>
 <span class="s0">* The other textures are simply appended to the end of the textures in this</span>
 <span class="s0">* list; duplicates are not automatically removed.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void TextureCollection::add_textures_from(TextureCollection const &amp;other);</span>

<span class="s0">3104 20 remove_textures_from 0 4 3337 39 TextureCollection::remove_textures_from 0 1 1538 94</span>
<span class="s0">/**</span>
 <span class="s0">* Removes from this collection all of the Textures listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">void TextureCollection::remove_textures_from(TextureCollection const &amp;other);</span>

<span class="s0">3105 25 remove_duplicate_textures 0 4 3337 44 TextureCollection::remove_duplicate_textures 0 1 1539 195</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any duplicate entries of the same Textures on this collection.  If</span>
 <span class="s0">* a Texture appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void TextureCollection::remove_duplicate_textures(void);</span>

<span class="s0">3106 11 has_texture 0 4 3337 30 TextureCollection::has_texture 0 1 1540 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated Texture appears in this collection, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool TextureCollection::has_texture(Texture *texture) const;</span>

<span class="s0">3107 5 clear 0 4 3337 24 TextureCollection::clear 0 1 1541 52</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all Textures from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void TextureCollection::clear(void);</span>

<span class="s0">3108 7 reserve 0 4 3337 26 TextureCollection::reserve 0 1 1542 157</span>
<span class="s0">/**</span>
 <span class="s0">* This is a hint to Panda to allocate enough memory to hold the given number</span>
 <span class="s0">* of NodePaths, if you know ahead of time how many you will be adding.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void TextureCollection::reserve(std::size_t num);</span>

<span class="s0">3109 12 find_texture 0 4 3337 31 TextureCollection::find_texture 0 1 1543 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the texture in the collection with the indicated name, if any, or</span>
 <span class="s0">* NULL if no texture has that name.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">Texture *TextureCollection::find_texture(std::string const &amp;name) const;</span>

<span class="s0">3110 16 get_num_textures 0 4 3337 35 TextureCollection::get_num_textures 0 1 1544 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of Textures in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">int TextureCollection::get_num_textures(void) const;</span>

<span class="s0">3111 11 get_texture 0 4 3337 30 TextureCollection::get_texture 0 1 1545 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth Texture in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">Texture *TextureCollection::get_texture(int index) const;</span>

<span class="s0">3112 11 operator [] 0 4 3337 30 TextureCollection::operator [] 0 1 1546 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth Texture in the collection.  This is the same as</span>
 <span class="s0">* get_texture(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">Texture *TextureCollection::operator [](int index) const;</span>

<span class="s0">3113 4 size 0 4 3337 23 TextureCollection::size 0 1 1547 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of textures in the collection.  This is the same thing</span>
 <span class="s0">* as get_num_textures().</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">int TextureCollection::size(void) const;</span>

<span class="s0">3114 11 operator += 0 4 3337 30 TextureCollection::operator += 0 1 1548 0</span>
<span class="s0">75</span>
<span class="s0">inline void TextureCollection::operator +=(TextureCollection const &amp;other);</span>

<span class="s0">3115 10 operator + 0 4 3337 29 TextureCollection::operator + 0 1 1549 0</span>
<span class="s0">93</span>
<span class="s0">inline TextureCollection TextureCollection::operator +(TextureCollection const &amp;other) const;</span>

<span class="s0">3116 6 append 0 4 3337 25 TextureCollection::append 0 1 1550 205</span>
<span class="s0">// Method names to satisfy Python's conventions.</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new Texture to the collection.  This method duplicates the</span>
 <span class="s0">* add_texture() method; it is provided to satisfy Python's naming convention.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void TextureCollection::append(Texture *texture);</span>

<span class="s0">3117 6 extend 0 4 3337 25 TextureCollection::extend 0 1 1551 157</span>
<span class="s0">/**</span>
 <span class="s0">* Appends the other list onto the end of this one.  This method duplicates</span>
 <span class="s0">* the += operator; it is provided to satisfy Python's naming convention.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void TextureCollection::extend(TextureCollection const &amp;other);</span>

<span class="s0">3118 6 output 0 4 3337 25 TextureCollection::output 0 1 1552 106</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief one-line description of the TextureCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void TextureCollection::output(std::ostream &amp;out) const;</span>

<span class="s0">3119 5 write 0 4 3337 24 TextureCollection::write 0 1 1553 111</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a complete multi-line description of the TextureCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">void TextureCollection::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">3120 11 has_texture 0 4 3338 24 TexturePool::has_texture 0 1 1554 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the texture has ever been loaded, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline bool TexturePool::has_texture(Filename const &amp;filename);</span>

<span class="s0">3121 14 verify_texture 0 4 3338 27 TexturePool::verify_texture 0 1 1555 313</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the given filename up into a texture, if it has not already been</span>
 <span class="s0">* loaded, and returns true to indicate success, or false to indicate failure.</span>
 <span class="s0">* If this returns true, it is guaranteed that a subsequent call to</span>
 <span class="s0">* load_texture() with the same texture name will return a valid Texture</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline bool TexturePool::verify_texture(Filename const &amp;filename);</span>

<span class="s0">3122 11 get_texture 0 4 3338 24 TexturePool::get_texture 0 2 1556 1557 188</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the texture that has already been previously loaded, or NULL</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the texture that has already been previously loaded, or NULL</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">333</span>
<span class="s0">static inline Texture *TexturePool::get_texture(Filename const &amp;filename, int primary_file_num_channels = 0, bool read_mipmaps = false);</span>
<span class="s0">static inline Texture *TexturePool::get_texture(Filename const &amp;filename, Filename const &amp;alpha_filename, int primary_file_num_channels = 0, int alpha_file_channel = 0, bool read_mipmaps = false);</span>

<span class="s0">3123 12 load_texture 0 4 3338 25 TexturePool::load_texture 0 2 1558 1559 978</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the given filename up into a texture, if it has not already been</span>
 <span class="s0">* loaded, and returns the new texture.  If a texture with the same filename</span>
 <span class="s0">* was previously loaded, returns that one instead.  If the texture file</span>
 <span class="s0">* cannot be found, returns NULL.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, the filename should contain a hash mark ('#'),</span>
 <span class="s0">* which will be filled in with the mipmap level number; and the texture will</span>
 <span class="s0">* be defined with a series of images, one for each mipmap level.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Loads the given filename up into a texture, if it has not already been</span>
 <span class="s0">* loaded, and returns the new texture.  If a texture with the same filename</span>
 <span class="s0">* was previously loaded, returns that one instead.  If the texture file</span>
 <span class="s0">* cannot be found, returns NULL.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, both filenames should contain a hash mark ('#'),</span>
 <span class="s0">* which will be filled in with the mipmap level number; and the texture will</span>
 <span class="s0">* be defined with a series of images, two for each mipmap level.</span>
 <span class="s0">*/</span>
<span class="s0">431</span>
<span class="s0">static inline Texture *TexturePool::load_texture(Filename const &amp;filename, int primary_file_num_channels = 0, bool read_mipmaps = false, LoaderOptions const &amp;options = LoaderOptions());</span>
<span class="s0">static inline Texture *TexturePool::load_texture(Filename const &amp;filename, Filename const &amp;alpha_filename, int primary_file_num_channels = 0, int alpha_file_channel = 0, bool read_mipmaps = false, LoaderOptions const &amp;options = LoaderOptions());</span>

<span class="s0">3124 15 load_3d_texture 0 4 3338 28 TexturePool::load_3d_texture 0 1 1560 490</span>
<span class="s0">/**</span>
 <span class="s0">* Loads a 3-D texture that is specified with a series of n pages, all</span>
 <span class="s0">* numbered in sequence, and beginning with index 0.  The filename should</span>
 <span class="s0">* include a sequence of one or more hash characters (&quot;#&quot;) which will be</span>
 <span class="s0">* filled in with the index number of each level.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, the filename should contain an additional hash</span>
 <span class="s0">* mark.  The first hash mark will be filled in with the mipmap level number,</span>
 <span class="s0">* and the second with the index number of each 3-d level.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">static inline Texture *TexturePool::load_3d_texture(Filename const &amp;filename_pattern, bool read_mipmaps = false, LoaderOptions const &amp;options = LoaderOptions());</span>

<span class="s0">3125 21 load_2d_texture_array 0 4 3338 34 TexturePool::load_2d_texture_array 0 1 1561 496</span>
<span class="s0">/**</span>
 <span class="s0">* Loads a 2-D texture array that is specified with a series of n pages, all</span>
 <span class="s0">* numbered in sequence, and beginning with index 0.  The filename should</span>
 <span class="s0">* include a sequence of one or more hash characters (&quot;#&quot;) which will be</span>
 <span class="s0">* filled in with the index number of each level.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, the filename should contain an additional hash</span>
 <span class="s0">* mark.  The first hash mark will be filled in with the mipmap level number,</span>
 <span class="s0">* and the second with the index number of each 2-d level.</span>
 <span class="s0">*/</span>
<span class="s0">167</span>
<span class="s0">static inline Texture *TexturePool::load_2d_texture_array(Filename const &amp;filename_pattern, bool read_mipmaps = false, LoaderOptions const &amp;options = LoaderOptions());</span>

<span class="s0">3126 13 load_cube_map 0 4 3338 26 TexturePool::load_cube_map 0 1 1562 457</span>
<span class="s0">/**</span>
 <span class="s0">* Loads a cube map texture that is specified with a series of 6 pages,</span>
 <span class="s0">* numbered 0 through 5.  The filename should include a sequence of one or</span>
 <span class="s0">* more hash characters (&quot;#&quot;) which will be filled in with the index number of</span>
 <span class="s0">* each pagee.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, the filename should contain an additional hash</span>
 <span class="s0">* mark.  The first hash mark will be filled in with the mipmap level number,</span>
 <span class="s0">* and the second with the face number, 0 through 5.</span>
 <span class="s0">*/</span>
<span class="s0">159</span>
<span class="s0">static inline Texture *TexturePool::load_cube_map(Filename const &amp;filename_pattern, bool read_mipmaps = false, LoaderOptions const &amp;options = LoaderOptions());</span>

<span class="s0">3127 26 get_normalization_cube_map 0 4 3338 39 TexturePool::get_normalization_cube_map 0 1 1563 290</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard Texture object that has been created with</span>
 <span class="s0">* Texture::generate_normalization_cube_map().  This Texture may be shared by</span>
 <span class="s0">* any application code requiring a normalization cube map.  It will be at</span>
 <span class="s0">* least as large as the specified size, though it may be larger.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static inline Texture *TexturePool::get_normalization_cube_map(int size);</span>

<span class="s0">3128 19 get_alpha_scale_map 0 4 3338 32 TexturePool::get_alpha_scale_map 0 1 1564 296</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a standard Texture object that has been created with</span>
 <span class="s0">* Texture::generate_alpha_scale_map().</span>
 <span class="s0">*</span>
 <span class="s0">* This Texture object is used internally by Panda to apply an alpha scale to</span>
 <span class="s0">* an object (instead of munging its vertices) when</span>
 <span class="s0">* gsg-&gt;get_alpha_scale_via_texture() returns true.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline Texture *TexturePool::get_alpha_scale_map(void);</span>

<span class="s0">3129 11 add_texture 0 4 3338 24 TexturePool::add_texture 0 1 1565 226</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated already-loaded texture to the pool.  The texture must</span>
 <span class="s0">* have a filename set for its name.  The texture will always replace any</span>
 <span class="s0">* previously-loaded texture in the pool that had the same filename.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline void TexturePool::add_texture(Texture *texture);</span>

<span class="s0">3130 15 release_texture 0 4 3338 28 TexturePool::release_texture 0 1 1566 404</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated texture from the pool, indicating it will never be</span>
 <span class="s0">* loaded again; the texture may then be freed.  If this function is never</span>
 <span class="s0">* called, a reference count will be maintained on every texture every loaded,</span>
 <span class="s0">* and textures will never be freed.</span>
 <span class="s0">*</span>
 <span class="s0">* The texture's name should not have been changed during its lifetime, or</span>
 <span class="s0">* this function may fail to locate it in the pool.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline void TexturePool::release_texture(Texture *texture);</span>

<span class="s0">3131 20 release_all_textures 0 4 3338 33 TexturePool::release_all_textures 0 1 1567 86</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all textures in the pool and restores the pool to the empty state.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">static inline void TexturePool::release_all_textures(void);</span>

<span class="s0">3132 6 rehash 0 4 3338 19 TexturePool::rehash 0 1 1568 131</span>
<span class="s0">/**</span>
 <span class="s0">* Should be called when the model-path changes, to blow away the cache of</span>
 <span class="s0">* texture pathnames found along the model-path.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static inline void TexturePool::rehash(void);</span>

<span class="s0">3133 15 garbage_collect 0 4 3338 28 TexturePool::garbage_collect 0 1 1569 212</span>
<span class="s0">/**</span>
 <span class="s0">* Releases only those textures in the pool that have a reference count of</span>
 <span class="s0">* exactly 1; i.e.  only those textures that are not being used outside of the</span>
 <span class="s0">* pool.  Returns the number of textures released.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">static inline int TexturePool::garbage_collect(void);</span>

<span class="s0">3134 13 list_contents 0 4 3338 26 TexturePool::list_contents 0 2 1570 1571 140</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the texture pool to the indicated output stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the texture pool to cout</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">static inline void TexturePool::list_contents(std::ostream &amp;out);</span>
<span class="s0">static inline void TexturePool::list_contents(void);</span>

<span class="s0">3135 12 find_texture 0 4 3338 25 TexturePool::find_texture 0 1 1572 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first texture found in the pool that matches the indicated name</span>
 <span class="s0">* (which may contain wildcards).  Returns the texture if it is found, or NULL</span>
 <span class="s0">* if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline Texture *TexturePool::find_texture(std::string const &amp;name);</span>

<span class="s0">3136 17 find_all_textures 0 4 3338 30 TexturePool::find_all_textures 0 1 1573 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of all textures found in the pool that match the indicated</span>
 <span class="s0">* name (which may contain wildcards).</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">static inline TextureCollection TexturePool::find_all_textures(std::string const &amp;name = &quot;*&quot;);</span>

<span class="s0">3137 22 set_fake_texture_image 0 4 3338 35 TexturePool::set_fake_texture_image 0 1 1574 109</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a bogus filename that will be loaded in lieu of any textures requested</span>
 <span class="s0">* from this point on.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">static inline void TexturePool::set_fake_texture_image(Filename const &amp;filename);</span>

<span class="s0">3138 24 clear_fake_texture_image 0 4 3338 37 TexturePool::clear_fake_texture_image 0 1 1575 79</span>
<span class="s0">/**</span>
 <span class="s0">* Restores normal behavior of loading the textures actually requested.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static inline void TexturePool::clear_fake_texture_image(void);</span>

<span class="s0">3139 22 has_fake_texture_image 0 4 3338 35 TexturePool::has_fake_texture_image 0 1 1576 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if fake_texture_image mode has been enabled, false if we are</span>
 <span class="s0">* in the normal mode.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">static inline bool TexturePool::has_fake_texture_image(void);</span>

<span class="s0">3140 22 get_fake_texture_image 0 4 3338 35 TexturePool::get_fake_texture_image 0 1 1577 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename that was specified with a previous call to</span>
 <span class="s0">* set_fake_texture_image().</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline Filename const &amp;TexturePool::get_fake_texture_image(void);</span>

<span class="s0">3141 12 make_texture 0 4 3338 25 TexturePool::make_texture 0 1 1578 185</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new Texture object of the appropriate type for the indicated</span>
 <span class="s0">* filename extension, according to the types that have been registered via</span>
 <span class="s0">* register_texture_type().</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">static inline PointerTo&lt; Texture &gt; TexturePool::make_texture(std::string const &amp;extension);</span>

<span class="s0">3142 5 write 0 4 3338 18 TexturePool::write 0 1 1579 100</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the texture pool to the indicated output stream.  For</span>
 <span class="s0">* debugging.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static void TexturePool::write(std::ostream &amp;out);</span>

<span class="s0">3143 12 ~TexturePool 0 516 3338 25 TexturePool::~TexturePool 0 0 0</span>
<span class="s0">32</span>
<span class="s0">TexturePool::~TexturePool(void);</span>

<span class="s0">3144 10 get_x_size 0 4 3339 25 TexturePeeker::get_x_size 0 1 1581 191</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the width of the texture image that is contributing to the</span>
 <span class="s0">* TexturePeeker's information.  This may be either the Texture's full width,</span>
 <span class="s0">* or its simple ram image's width.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int TexturePeeker::get_x_size(void) const;</span>

<span class="s0">3145 10 get_y_size 0 4 3339 25 TexturePeeker::get_y_size 0 1 1582 194</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the height of the texture image that is contributing to the</span>
 <span class="s0">* TexturePeeker's information.  This may be either the Texture's full height,</span>
 <span class="s0">* or its simple ram image's height.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int TexturePeeker::get_y_size(void) const;</span>

<span class="s0">3146 10 get_z_size 0 4 3339 25 TexturePeeker::get_z_size 0 1 1583 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the depth of the texture image that is contributing to the</span>
 <span class="s0">* TexturePeeker's information.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int TexturePeeker::get_z_size(void) const;</span>

<span class="s0">3147 9 has_pixel 0 4 3339 24 TexturePeeker::has_pixel 0 2 1584 1585 166</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether a given coordinate is inside of the texture dimensions.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns whether a given coordinate is inside of the texture dimensions.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">inline bool TexturePeeker::has_pixel(int x, int y) const;</span>
<span class="s0">inline bool TexturePeeker::has_pixel(int x, int y, int z) const;</span>

<span class="s0">3148 6 lookup 0 4 3339 21 TexturePeeker::lookup 0 2 1586 1587 623</span>
<span class="s0">/**</span>
 <span class="s0">* Fills &quot;color&quot; with the RGBA color of the texel at point (u, v).</span>
 <span class="s0">*</span>
 <span class="s0">* The texel color is determined via nearest-point sampling (no filtering of</span>
 <span class="s0">* adjacent pixels), regardless of the filter type associated with the</span>
 <span class="s0">* texture.  u, v, and w will wrap around regardless of the texture's wrap</span>
 <span class="s0">* mode.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills &quot;color&quot; with the RGBA color of the texel at point (u, v, w).</span>
 <span class="s0">*</span>
 <span class="s0">* The texel color is determined via nearest-point sampling (no filtering of</span>
 <span class="s0">* adjacent pixels), regardless of the filter type associated with the</span>
 <span class="s0">* texture.  u, v, and w will wrap around regardless of the texture's wrap</span>
 <span class="s0">* mode.</span>
 <span class="s0">*/</span>
<span class="s0">172</span>
<span class="s0">void TexturePeeker::lookup(LColor &amp;color, PN_stdfloat u, PN_stdfloat v) const;</span>
<span class="s0">void TexturePeeker::lookup(LColor &amp;color, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w) const;</span>

<span class="s0">3149 11 fetch_pixel 0 4 3339 26 TexturePeeker::fetch_pixel 0 2 1588 1589 222</span>
<span class="s0">/**</span>
 <span class="s0">* Works like TexturePeeker::lookup(), but instead of uv-coordinates, integer</span>
 <span class="s0">* coordinates are used.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Works like TexturePeeker::lookup(), but instead of uv-coordinates, integer</span>
 <span class="s0">* coordinates are used.</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">void TexturePeeker::fetch_pixel(LColor &amp;color, int x, int y) const;</span>
<span class="s0">void TexturePeeker::fetch_pixel(LColor &amp;color, int x, int y, int z) const;</span>

<span class="s0">3150 15 lookup_bilinear 0 4 3339 30 TexturePeeker::lookup_bilinear 0 1 1590 233</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a bilinear lookup to retrieve the color value stored at the uv</span>
 <span class="s0">* coordinate (u, v).</span>
 <span class="s0">*</span>
 <span class="s0">* In case the point is outside of the uv range, color is set to zero,</span>
 <span class="s0">* and false is returned.  Otherwise true is returned.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">bool TexturePeeker::lookup_bilinear(LColor &amp;color, PN_stdfloat u, PN_stdfloat v) const;</span>

<span class="s0">3151 11 filter_rect 0 4 3339 26 TexturePeeker::filter_rect 0 2 1591 1592 492</span>
<span class="s0">/**</span>
 <span class="s0">* Fills &quot;color&quot; with the average RGBA color of the texels within the</span>
 <span class="s0">* rectangle defined by the specified coordinate range.</span>
 <span class="s0">*</span>
 <span class="s0">* The texel color is linearly filtered over the entire region.  u, v, and w</span>
 <span class="s0">* must be in the range [0, 1].</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills &quot;color&quot; with the average RGBA color of the texels within the</span>
 <span class="s0">* rectangle defined by the specified coordinate range.</span>
 <span class="s0">*</span>
 <span class="s0">* The texel color is linearly filtered over the entire region.  u, v, and w</span>
 <span class="s0">* must be in the range [0, 1].</span>
 <span class="s0">*/</span>
<span class="s0">297</span>
<span class="s0">void TexturePeeker::filter_rect(LColor &amp;color, PN_stdfloat min_u, PN_stdfloat min_v, PN_stdfloat max_u, PN_stdfloat max_v) const;</span>
<span class="s0">void TexturePeeker::filter_rect(LColor &amp;color, PN_stdfloat min_u, PN_stdfloat min_v, PN_stdfloat min_w, PN_stdfloat max_u, PN_stdfloat max_v, PN_stdfloat max_w) const;</span>

<span class="s0">3152 13 TexturePeeker 0 260 3339 28 TexturePeeker::TexturePeeker 0 1 1580 169</span>
<span class="s0">/**</span>
 <span class="s0">* Use Texture::peek() to construct a TexturePeeker.</span>
 <span class="s0">*</span>
 <span class="s0">* This constructor is called only by Texture::peek(), and assumes the</span>
 <span class="s0">* texture's lock is already held.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline TexturePeeker::TexturePeeker(TexturePeeker const &amp;) = default;</span>

<span class="s0">3153 14 ~TexturePeeker 0 516 3339 29 TexturePeeker::~TexturePeeker 0 0 0</span>
<span class="s0">36</span>
<span class="s0">TexturePeeker::~TexturePeeker(void);</span>

<span class="s0">3154 9 get_stage 0 4 3340 27 TextureStagePool::get_stage 0 1 1593 666</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a TextureStage pointer that represents the same TextureStage</span>
 <span class="s0">* described by temp, except that it is a shared pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* Each call to get_stage() passing an equivalent TextureStage pointer will</span>
 <span class="s0">* return the same shared pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* If you modify the shared pointer, it will automatically disassociate it</span>
 <span class="s0">* from the pool.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, the return value may be a different pointer than that passed in, or</span>
 <span class="s0">* it may be the same pointer.  In either case, the passed in pointer has now</span>
 <span class="s0">* been sacrificed to the greater good and should not be used again (like any</span>
 <span class="s0">* other PointerTo, it will be freed when the last reference count is</span>
 <span class="s0">* removed).</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static inline TextureStage *TextureStagePool::get_stage(TextureStage *temp);</span>

<span class="s0">3155 13 release_stage 0 4 3340 31 TextureStagePool::release_stage 0 1 1594 60</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated TextureStage from the pool.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline void TextureStagePool::release_stage(TextureStage *temp);</span>

<span class="s0">3156 18 release_all_stages 0 4 3340 36 TextureStagePool::release_all_stages 0 1 1595 94</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all TextureStages in the pool and restores the pool to the empty</span>
 <span class="s0">* state.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static inline void TextureStagePool::release_all_stages(void);</span>

<span class="s0">3157 8 set_mode 0 4 3340 26 TextureStagePool::set_mode 0 1 1596 489</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the fundamental operating mode of the TextureStagePool.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is M_none, each call to get_stage() returns the same TextureStage</span>
 <span class="s0">* pointer that was passed in (the pool is effectively disabled).  If this is</span>
 <span class="s0">* M_name, each call to get_stage() returns the last TextureStage passed in</span>
 <span class="s0">* with the same name, whether it has different properties or not.  If this is</span>
 <span class="s0">* M_unique, then each call to get_stage() returns only TextureStages with</span>
 <span class="s0">* identical properties.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static inline void TextureStagePool::set_mode(TextureStagePool::Mode mode);</span>

<span class="s0">3158 8 get_mode 0 4 3340 26 TextureStagePool::get_mode 0 1 1597 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the fundamental operating mode of the TextureStagePool.  See</span>
 <span class="s0">* set_mode().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline TextureStagePool::Mode TextureStagePool::get_mode(void);</span>

<span class="s0">3159 15 garbage_collect 0 4 3340 33 TextureStagePool::garbage_collect 0 1 1598 227</span>
<span class="s0">/**</span>
 <span class="s0">* Releases only those TextureStages in the pool that have a reference count</span>
 <span class="s0">* of exactly 1; i.e.  only those TextureStages that are not being used</span>
 <span class="s0">* outside of the pool.  Returns the number of TextureStages released.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static inline int TextureStagePool::garbage_collect(void);</span>

<span class="s0">3160 13 list_contents 0 4 3340 31 TextureStagePool::list_contents 0 1 1599 86</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the TextureStage pool to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static inline void TextureStagePool::list_contents(std::ostream &amp;out);</span>

<span class="s0">3161 5 write 0 4 3340 23 TextureStagePool::write 0 1 1600 86</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the TextureStage pool to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static void TextureStagePool::write(std::ostream &amp;out);</span>

<span class="s0">3162 17 ~TextureStagePool 0 516 3340 35 TextureStagePool::~TextureStagePool 0 0 0</span>
<span class="s0">42</span>
<span class="s0">TextureStagePool::~TextureStagePool(void);</span>

<span class="s0">1600</span>
<span class="s0">1 0 0 7 3 3343 1602 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 name 1 3342  8 max_size 1 3209  </span>
<span class="s0">2 0 0 6 5 3209 0 0 77 /**</span>
 <span class="s0">* Returns the total size of all objects currently active on the LRU.</span>
 <span class="s0">*/ 1 4 this 3 3344  </span>
<span class="s0">3 0 0 6 6 3209 0 0 91 /**</span>
 <span class="s0">* Returns the max size of all objects that are allowed to be active on the</span>
 <span class="s0">* LRU.</span>
 <span class="s0">*/ 1 4 this 3 3344  </span>
<span class="s0">4 0 0 4 7 3346 0 0 143 /**</span>
 <span class="s0">* Changes the max size of all objects that are allowed to be active on the</span>
 <span class="s0">* LRU.</span>
 <span class="s0">*</span>
 <span class="s0">* If the size is (size_t)-1, there is no limit.</span>
 <span class="s0">*/ 2 4 this 3 3343  8 max_size 1 3209  </span>
<span class="s0">5 0 0 6 8 3209 0 0 106 /**</span>
 <span class="s0">* Returns the total size of the pages that were enqueued since the last call</span>
 <span class="s0">* to begin_epoch().</span>
 <span class="s0">*/ 1 4 this 3 3344  </span>
<span class="s0">6 0 0 4 9 3346 0 0 61 /**</span>
 <span class="s0">* Evicts a sequence of objects if the queue is full.</span>
 <span class="s0">*/ 1 4 this 3 3343  </span>
<span class="s0">7 0 0 4 10 3346 0 0 132 /**</span>
 <span class="s0">* Evicts a sequence of objects until the queue fits within the indicated</span>
 <span class="s0">* target size, regardless of its normal max size.</span>
 <span class="s0">*/ 2 4 this 3 3343  11 target_size 1 3209  </span>
<span class="s0">8 0 0 4 11 3346 0 0 184 /**</span>
 <span class="s0">* Marks the end of the previous epoch and the beginning of the next one.</span>
 <span class="s0">* This will evict any objects that are pending eviction, and also update any</span>
 <span class="s0">* internal bookkeeping.</span>
 <span class="s0">*/ 1 4 this 3 3343  </span>
<span class="s0">9 0 0 6 12 3178 0 0 125 /**</span>
 <span class="s0">* Checks that the LRU is internally self-consistent.  Returns true if</span>
 <span class="s0">* successful, false if there is some problem.</span>
 <span class="s0">*/ 1 4 this 3 3343  </span>
<span class="s0">10 0 0 4 13 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3344  3 out 1 3347  </span>
<span class="s0">11 0 0 4 14 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3344  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">12 0 0 4 15 3346 0 0 196 // The following methods are specific to AdaptiveLru, and do not exist in</span>
<span class="s0">// the SimpleLru implementation.  In most cases, the defaults will be</span>
<span class="s0">// sufficient, so you do not need to mess with them. 2 4 this 3 3343  6 weight 1 3220  </span>
<span class="s0">13 0 0 6 16 3220 0 0 83 /**</span>
 <span class="s0">* Returns the weight value used to compute the exponential moving average.</span>
 <span class="s0">*/ 1 4 this 3 3344  </span>
<span class="s0">14 0 0 4 17 3346 0 0 214 /**</span>
 <span class="s0">* Specifies the maximum number of pages the AdaptiveLru will update each</span>
 <span class="s0">* frame.  This is a performance optimization: keeping this number low limits</span>
 <span class="s0">* the impact of the AdaptiveLru's adaptive algorithm.</span>
 <span class="s0">*/ 2 4 this 3 3343  21 max_updates_per_frame 1 3177  </span>
<span class="s0">15 0 0 6 18 3177 0 0 86 /**</span>
 <span class="s0">* Returns the maximum number of pages the AdaptiveLru will update each frame.</span>
 <span class="s0">*/ 1 4 this 3 3344  </span>
<span class="s0">16 0 0 15 26 3351 1623 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3349  </span>
<span class="s0">17 0 0 7 26 3351 1623 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 8 lru_size 1 3209  </span>
<span class="s0">18 0 0 6 27 3351 0 0 0 2 4 this 3 3351  4 copy 1 3349  </span>
<span class="s0">19 0 0 6 29 3343 0 0 104 /**</span>
 <span class="s0">* Returns the LRU that manages this page, or NULL if it is not currently</span>
 <span class="s0">* managed by any LRU.</span>
 <span class="s0">*/ 1 4 this 3 3349  </span>
<span class="s0">20 0 0 4 30 3346 0 0 183 /**</span>
 <span class="s0">* Adds the page to the LRU for the first time, or marks it recently-accessed</span>
 <span class="s0">* if it has already been added.</span>
 <span class="s0">*</span>
 <span class="s0">* If lru is NULL, it means to remove this page from its LRU.</span>
 <span class="s0">*/ 2 4 this 3 3351  3 lru 1 3343  </span>
<span class="s0">21 0 0 4 31 3346 0 0 49 /**</span>
 <span class="s0">* Removes the page from its AdaptiveLru.</span>
 <span class="s0">*/ 1 4 this 3 3351  </span>
<span class="s0">22 0 0 4 32 3346 0 0 224 /**</span>
 <span class="s0">* To be called when the page is used; this will move it to the tail of the</span>
 <span class="s0">* AdaptiveLru queue it is already on.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is const because it's not technically modifying the contents of</span>
 <span class="s0">* the page itself.</span>
 <span class="s0">*/ 1 4 this 3 3349  </span>
<span class="s0">23 0 0 4 32 3346 0 0 115 /**</span>
 <span class="s0">* To be called when the page is used; this will move it to the tail of the</span>
 <span class="s0">* specified AdaptiveLru queue.</span>
 <span class="s0">*/ 2 4 this 3 3351  3 lru 1 3343  </span>
<span class="s0">24 0 0 6 33 3209 0 0 85 /**</span>
 <span class="s0">* Returns the size of this page as reported to the LRU, presumably in bytes.</span>
 <span class="s0">*/ 1 4 this 3 3349  </span>
<span class="s0">25 0 0 4 34 3346 0 0 98 /**</span>
 <span class="s0">* Specifies the size of this page, presumably in bytes, although any unit is</span>
 <span class="s0">* possible.</span>
 <span class="s0">*/ 2 4 this 3 3351  8 lru_size 1 3209  </span>
<span class="s0">26 0 0 4 35 3346 0 0 455 /**</span>
 <span class="s0">* Evicts the page from the LRU.  Called internally when the LRU determines</span>
 <span class="s0">* that it is full.  May also be called externally when necessary to</span>
 <span class="s0">* explicitly evict the page.</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal for this method to either evict the page as requested, do</span>
 <span class="s0">* nothing (in which case the eviction will be requested again at the next</span>
 <span class="s0">* epoch), or requeue itself on the tail of the queue (in which case the</span>
 <span class="s0">* eviction will be requested again much later).</span>
 <span class="s0">*/ 1 4 this 3 3351  </span>
<span class="s0">27 0 0 4 36 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3349  3 out 1 3347  </span>
<span class="s0">28 0 0 4 37 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3349  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">29 0 0 6 38 3352 0 0 123 /**</span>
 <span class="s0">* Returns the number of frames since the page was first added to its LRU.</span>
 <span class="s0">* Returns 0 if it does not have an LRU.</span>
 <span class="s0">*/ 1 4 this 3 3349  </span>
<span class="s0">30 0 0 6 39 3352 0 0 125 /**</span>
 <span class="s0">* Returns the number of frames since the page was last accessed on its LRU.</span>
 <span class="s0">* Returns 0 if it does not have an LRU.</span>
 <span class="s0">*/ 1 4 this 3 3349  </span>
<span class="s0">31 0 0 7 48 3353 1636 0 0 0 </span>
<span class="s0">32 0 0 15 48 3353 1636 0 0 1 6 param0 0 3354  </span>
<span class="s0">33 0 0 7 51 3356 1646 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">34 0 0 15 51 3356 1646 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 5 other 1 3357  </span>
<span class="s0">35 0 0 6 52 3356 0 0 0 2 4 this 3 3356  5 other 1 3357  </span>
<span class="s0">36 0 0 6 53 3175 0 0 66 /**</span>
 <span class="s0">* Returns the type of animation represented by this spec.</span>
 <span class="s0">*/ 1 4 this 3 3357  </span>
<span class="s0">37 0 0 6 55 3177 0 0 202 /**</span>
 <span class="s0">* This is only meaningful for animation_type AT_hardware.  It specifies the</span>
 <span class="s0">* maximum number of transforms that might be simultaneously applied to any</span>
 <span class="s0">* one vertex by the data in this format.</span>
 <span class="s0">*/ 1 4 this 3 3357  </span>
<span class="s0">38 0 0 6 56 3178 0 0 231 /**</span>
 <span class="s0">* This is only meaningful for animation_type AT_hardware.  If true, it</span>
 <span class="s0">* indicates that the format uses indexed animation tables.  It is false if</span>
 <span class="s0">* each vertex will reference the first _num_transforms table entries only.</span>
 <span class="s0">*/ 1 4 this 3 3357  </span>
<span class="s0">39 0 0 4 61 3346 0 0 74 /**</span>
 <span class="s0">* Specifies that no vertex animation is represented by this spec.</span>
 <span class="s0">*/ 1 4 this 3 3356  </span>
<span class="s0">40 0 0 4 62 3346 0 0 168 /**</span>
 <span class="s0">* Specifies that vertex animation is to be performed by Panda.  This is the</span>
 <span class="s0">* most general setting and can handle any kind of vertex animation</span>
 <span class="s0">* represented.</span>
 <span class="s0">*/ 1 4 this 3 3356  </span>
<span class="s0">41 0 0 4 63 3346 0 0 391 /**</span>
 <span class="s0">* Specifies that vertex animation is to be performed by the graphics hardware</span>
 <span class="s0">* (or at least by the graphics backend API, which is actually still free to</span>
 <span class="s0">* animate the vertices on the CPU).</span>
 <span class="s0">*</span>
 <span class="s0">* This is only legal if the graphics hardware can support the specified</span>
 <span class="s0">* limits on number of transforms and/or indexed transforms.  Also, no current</span>
 <span class="s0">* graphics API's support morphing.</span>
 <span class="s0">*/ 3 4 this 3 3356  14 num_transforms 1 3177  18 indexed_transforms 1 3178  </span>
<span class="s0">42 0 0 4 64 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3357  3 out 1 3347  </span>
<span class="s0">43 0 0 55 68 3181 0 0 108 // These versions are exposed to Python, which have additional logic to map</span>
<span class="s0">// from Python interned strings. 1 3 str 1 3358  </span>
<span class="s0">44 0 0 23 68 3181 0 0 69 /**</span>
 <span class="s0">* Make using a string and an integer.  Concatenates the two.</span>
 <span class="s0">*/ 2 4 name 1 3342  5 index 1 3177  </span>
<span class="s0">45 0 0 7 69 3181 0 0 221 /**</span>
 <span class="s0">* Constructs a new InternalName based on this name, with the indicated string</span>
 <span class="s0">* following it.  This is a cheaper way to construct a hierarchical name than</span>
 <span class="s0">* InternalName::make(parent-&gt;get_name() + &quot;.basename&quot;).</span>
 <span class="s0">*/ 2 4 this 3 3181  8 basename 1 3342  </span>
<span class="s0">46 0 0 7 70 3181 0 0 101 /**</span>
 <span class="s0">* Return the parent of this InternalName.  All names have a parent, except</span>
 <span class="s0">* the root name.</span>
 <span class="s0">*/ 1 4 this 3 3193  </span>
<span class="s0">47 0 0 6 71 3342 0 0 95 /**</span>
 <span class="s0">* Returns the complete name represented by the InternalName and all of its</span>
 <span class="s0">* parents.</span>
 <span class="s0">*/ 1 4 this 3 3193  </span>
<span class="s0">48 0 0 6 72 3342 0 0 69 /**</span>
 <span class="s0">* Like get_name, but uses a custom separator instead of &quot;.&quot;.</span>
 <span class="s0">*/ 2 4 this 3 3193  3 sep 1 3342  </span>
<span class="s0">49 0 0 6 73 3342 0 0 159 /**</span>
 <span class="s0">* Return the name represented by just this particular InternalName object,</span>
 <span class="s0">* ignoring its parents names.  This is everything after the rightmost dot.</span>
 <span class="s0">*/ 1 4 this 3 3193  </span>
<span class="s0">50 0 0 6 81 3177 0 0 293 /**</span>
 <span class="s0">* Returns the index of the ancestor with the indicated basename, or -1 if no</span>
 <span class="s0">* ancestor has that basename.  Returns 0 if this name has the basename.</span>
 <span class="s0">*</span>
 <span class="s0">* This index value may be passed to get_ancestor() or get_net_basename() to</span>
 <span class="s0">* retrieve more information about the indicated name.</span>
 <span class="s0">*/ 2 4 this 3 3193  8 basename 1 3342  </span>
<span class="s0">51 0 0 7 82 3193 0 0 222 /**</span>
 <span class="s0">* Returns the ancestor with the indicated index number.  0 is this name</span>
 <span class="s0">* itself, 1 is the name's parent, 2 is the parent's parent, and so on.  If</span>
 <span class="s0">* there are not enough ancestors, returns the root InternalName.</span>
 <span class="s0">*/ 2 4 this 3 3193  1 n 1 3177  </span>
<span class="s0">52 0 0 7 83 3193 0 0 206 /**</span>
 <span class="s0">* Returns the oldest ancestor in the InternalName's chain, not counting the</span>
 <span class="s0">* root.  This will be the first name in the string, e.g.  &quot;texcoord.foo.bar&quot;</span>
 <span class="s0">* will return the InternalName &quot;texcoord&quot;.</span>
 <span class="s0">*/ 1 4 this 3 3193  </span>
<span class="s0">53 0 0 6 84 3342 0 0 192 /**</span>
 <span class="s0">* Returns the basename of this name prefixed by the indicated number of</span>
 <span class="s0">* ancestors.  0 is this name's basename, 1 is parent.basename, 2 is</span>
 <span class="s0">* grandparent.parent.basename, and so on.</span>
 <span class="s0">*/ 2 4 this 3 3193  1 n 1 3177  </span>
<span class="s0">54 0 0 4 85 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3193  3 out 1 3347  </span>
<span class="s0">55 0 0 7 86 3181 0 0 174 /**</span>
 <span class="s0">* Returns the standard root InternalName.  This is the root of all other</span>
 <span class="s0">* InternalNames.  It has no name itself, and it is the only InternalName with</span>
 <span class="s0">* no parent.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">56 0 0 7 87 3181 0 0 53 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;error&quot;.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">57 0 0 7 88 3181 0 0 148 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;vertex&quot;.  This is the column header for</span>
 <span class="s0">* the 3-d or 4-d vertex position information for each vertex.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">58 0 0 7 89 3181 0 0 129 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;normal&quot;.  This is the column header for</span>
 <span class="s0">* the 3-d lighting normal for each vertex.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">59 0 0 7 90 3181 0 0 295 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;tangent&quot;.  This is the column header for</span>
 <span class="s0">* the tangent vector associated with each vertex, which is a unit vector</span>
 <span class="s0">* usually perpendicular to the normal and in the direction of the U texture</span>
 <span class="s0">* coordinate change.  It is used for deriving bump maps.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">60 0 0 7 91 3181 0 0 184 /**</span>
 <span class="s0">* Returns the InternalName &quot;tangent.name&quot;, where name is the supplied string.</span>
 <span class="s0">* This is the column header for the tangent associated with the named texture</span>
 <span class="s0">* coordinate set.</span>
 <span class="s0">*/ 1 4 name 1 3342  </span>
<span class="s0">61 0 0 7 92 3181 0 0 321 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;binormal&quot;.  This is the column header</span>
 <span class="s0">* for the tangent vector associated with each vertex, which is a unit vector</span>
 <span class="s0">* usually perpendicular to both the normal and the tangent, and in the</span>
 <span class="s0">* direction of the V texture coordinate change.  It is used for deriving bump</span>
 <span class="s0">* maps.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">62 0 0 7 93 3181 0 0 187 /**</span>
 <span class="s0">* Returns the InternalName &quot;binormal.name&quot;, where name is the supplied</span>
 <span class="s0">* string.  This is the column header for the binormal associated with the</span>
 <span class="s0">* named texture coordinate set.</span>
 <span class="s0">*/ 1 4 name 1 3342  </span>
<span class="s0">63 0 0 7 94 3181 0 0 232 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;texcoord&quot;.  This is the column header</span>
 <span class="s0">* for the default texture coordinate set for each vertex.  It is also used</span>
 <span class="s0">* for identifying the default texture coordinate set in a TextureStage.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">64 0 0 7 95 3181 0 0 262 /**</span>
 <span class="s0">* Returns the InternalName &quot;texcoord.name&quot;, where name is the supplied</span>
 <span class="s0">* string.  This is the column header for the named texture coordinate set for</span>
 <span class="s0">* each vertex.  It is also used for identifying the named texture coordinate</span>
 <span class="s0">* set in a TextureStage.</span>
 <span class="s0">*/ 1 4 name 1 3342  </span>
<span class="s0">65 0 0 7 96 3181 0 0 132 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;color&quot;.  This is the column header for</span>
 <span class="s0">* the 4-component color value for each vertex.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">66 0 0 7 97 3181 0 0 217 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;rotate&quot;.  This is the column header for</span>
 <span class="s0">* the floating-point rotate value, which represents a number of degrees</span>
 <span class="s0">* counter-clockwise to rotate each point or point sprite.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">67 0 0 7 98 3181 0 0 225 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;size&quot;.  This is the column header for</span>
 <span class="s0">* the floating-point size value, which overrides the thickness parameter of</span>
 <span class="s0">* the RenderModeAttrib on a per-vertex (e.g.  per-point) basis.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">68 0 0 7 99 3181 0 0 250 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;aspect_ratio&quot;. This is the column header</span>
 <span class="s0">* for the floating-point aspect ratio value, which is used to define non-</span>
 <span class="s0">* square points.  This number is the ratio x / y, where y is the point size</span>
 <span class="s0">* (above).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">69 0 0 7 100 3181 0 0 264 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;transform_blend&quot;. This is the column</span>
 <span class="s0">* header for the integer transform_blend index, which is used to define</span>
 <span class="s0">* vertex animation on the CPU by indexing to a particular vertex weighting</span>
 <span class="s0">* from the TransformBlendTable.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">70 0 0 7 101 3181 0 0 474 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;transform_weight&quot;. This is the column</span>
 <span class="s0">* header for the n-component transform_weight value, which is used in</span>
 <span class="s0">* conjuntion with &quot;transform_index&quot; to define vertex animation on the</span>
 <span class="s0">* graphics card.  The transform_weight value specifies the weight of the nth</span>
 <span class="s0">* transform.  By convention, there are 1 fewer weight values than transforms,</span>
 <span class="s0">* since the weights are assumed to sum to 1 (and the last value is therefore</span>
 <span class="s0">* implicit).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">71 0 0 7 102 3181 0 0 444 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;transform_index&quot;. This is the column</span>
 <span class="s0">* header for the n-component transform_index value, which is used in</span>
 <span class="s0">* conjuntion with &quot;transform_weight&quot; to define vertex animation on the</span>
 <span class="s0">* graphics card.  The transform_index value specifies the nth transform, by</span>
 <span class="s0">* lookup in the TransformTable.  The transform_index column may be omitted,</span>
 <span class="s0">* in which case the nth transform is the nth entry in the table.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">72 0 0 7 103 3181 0 0 348 /**</span>
 <span class="s0">* Returns an InternalName derived from the given base column name and the</span>
 <span class="s0">* given slider name, which is the column header for the offset vector that</span>
 <span class="s0">* should be applied to the base column name when the named morph slider is</span>
 <span class="s0">* engaged.</span>
 <span class="s0">*</span>
 <span class="s0">* Each morph slider requires a set of n morph columns, one for each base</span>
 <span class="s0">* column it applies to.</span>
 <span class="s0">*/ 2 6 column 1 3181  6 slider 1 3342  </span>
<span class="s0">73 0 0 7 104 3181 0 0 233 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;index&quot;.  This is the column header for</span>
 <span class="s0">* the integer vertex index.  It is not used in the vertex data itself, but is</span>
 <span class="s0">* used in the GeomPrimitive structure to index into the vertex data.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">74 0 0 7 105 3181 0 0 108 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;world&quot;.  This is used as a keyword in</span>
 <span class="s0">* the shader subsystem.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">75 0 0 7 106 3181 0 0 109 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;camera&quot;.  This is used as a keyword in</span>
 <span class="s0">* the shader subsystem.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">76 0 0 7 107 3181 0 0 108 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;model&quot;.  This is used as a keyword in</span>
 <span class="s0">* the shader subsystem.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">77 0 0 7 108 3181 0 0 107 /**</span>
 <span class="s0">* Returns the standard InternalName &quot;view&quot;.  This is used as a keyword in the</span>
 <span class="s0">* shader subsystem.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">78 0 0 7 109 3362 0 0 0 0 </span>
<span class="s0">79 0 0 7 111 3363 1684 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 8 4 name 1 3193  14 num_components 1 3177  12 numeric_type 1 3173  8 contents 1 3174  5 start 1 3177  16 column_alignment 5 3177  12 num_elements 5 3177  14 element_stride 5 3177  </span>
<span class="s0">80 0 0 15 111 3363 1684 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3187  </span>
<span class="s0">81 0 0 6 112 3363 0 0 0 2 4 this 3 3363  4 copy 1 3187  </span>
<span class="s0">82 0 0 7 114 3193 0 0 267 /**</span>
 <span class="s0">* Returns the name of this particular data field, e.g.  &quot;vertex&quot; or &quot;normal&quot;.</span>
 <span class="s0">* The name may be a user-defined string, or it may be one of the standard</span>
 <span class="s0">* system-defined field types.  Only the system-defined field types are used</span>
 <span class="s0">* for the actual rendering.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">83 0 0 6 115 3177 0 0 194 /**</span>
 <span class="s0">* Returns the number of components of the column: the number of instances of</span>
 <span class="s0">* the NumericType in each element.  This is usually, but not always, the same</span>
 <span class="s0">* thing as get_num_values().</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">84 0 0 6 116 3177 0 0 337 /**</span>
 <span class="s0">* Returns the number of numeric values of the column: the number of distinct</span>
 <span class="s0">* numeric values that go into each element.  This is usually, but not always,</span>
 <span class="s0">* the same thing as get_num_components(); the difference is in the case of a</span>
 <span class="s0">* composite numeric type like NT_packed_dcba, which has four numeric values</span>
 <span class="s0">* per component.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">85 0 0 6 117 3177 0 0 107 /**</span>
 <span class="s0">* Returns the number of times this column is repeated.  This is usually 1,</span>
 <span class="s0">* except for matrices.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">86 0 0 6 118 3173 0 0 79 /**</span>
 <span class="s0">* Returns the token representing the numeric type of the data storage.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">87 0 0 6 119 3174 0 0 83 /**</span>
 <span class="s0">* Returns the token representing the semantic meaning of the stored value.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">88 0 0 6 120 3177 0 0 145 /**</span>
 <span class="s0">* Returns the byte within the array record at which this column starts.  This</span>
 <span class="s0">* can be set to non-zero to implement interleaved arrays.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">89 0 0 6 121 3177 0 0 299 /**</span>
 <span class="s0">* Returns the alignment requirements for this column.  If this is greater</span>
 <span class="s0">* than 1, it restricts the column to appear only on memory addresses that are</span>
 <span class="s0">* integer multiples of this value; this has implications for this column's</span>
 <span class="s0">* start value, as well as the stride of the resulting array.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">90 0 0 6 122 3177 0 0 133 /**</span>
 <span class="s0">* This value is only relevant for matrix types.  Returns the number of bytes</span>
 <span class="s0">* to add to access the next row of the matrix.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">91 0 0 6 123 3177 0 0 111 /**</span>
 <span class="s0">* Returns the number of bytes used by each component (that is, by one element</span>
 <span class="s0">* of the numeric type).</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">92 0 0 6 124 3177 0 0 111 /**</span>
 <span class="s0">* Returns the number of bytes used by each element of the column:</span>
 <span class="s0">* component_bytes * num_components.</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">93 0 0 6 125 3178 0 0 392 /**</span>
 <span class="s0">* Returns true if this Contents type is one that includes a homogeneous</span>
 <span class="s0">* coordinate in the fourth component, or false otherwise.  If this is true,</span>
 <span class="s0">* correct operation on the vertex data may require scaling by the homogeneous</span>
 <span class="s0">* coordinate from time to time (but in general this is handled automatically</span>
 <span class="s0">* if you use the 3-component or smaller forms of get_data() and set_data()).</span>
 <span class="s0">*/ 1 4 this 3 3187  </span>
<span class="s0">94 0 0 6 126 3178 0 0 118 /**</span>
 <span class="s0">* Returns true if this column overlaps with any of the bytes in the indicated</span>
 <span class="s0">* range, false if it does not.</span>
 <span class="s0">*/ 3 4 this 3 3187  10 start_byte 1 3177  9 num_bytes 1 3177  </span>
<span class="s0">95 0 0 6 127 3178 0 0 159 /**</span>
 <span class="s0">* Returns true if the data store of this column is exactly the same as that</span>
 <span class="s0">* of the other, irrespective of name or start position within the record.</span>
 <span class="s0">*/ 2 4 this 3 3187  5 other 1 3187  </span>
<span class="s0">96 0 0 4 128 3346 0 0 148 /**</span>
 <span class="s0">* Replaces the name of an existing column.  This is only legal on an</span>
 <span class="s0">* unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/ 2 4 this 3 3363  4 name 1 3181  </span>
<span class="s0">97 0 0 4 129 3346 0 0 163 /**</span>
 <span class="s0">* Changes the number of components of an existing column.  This is only legal</span>
 <span class="s0">* on an unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/ 2 4 this 3 3363  14 num_components 1 3177  </span>
<span class="s0">98 0 0 4 130 3346 0 0 152 /**</span>
 <span class="s0">* Changes the numeric type an existing column.  This is only legal on an</span>
 <span class="s0">* unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/ 2 4 this 3 3363  12 numeric_type 1 3173  </span>
<span class="s0">99 0 0 4 131 3346 0 0 159 /**</span>
 <span class="s0">* Changes the semantic meaning of an existing column.  This is only legal on</span>
 <span class="s0">* an unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/ 2 4 this 3 3363  8 contents 1 3174  </span>
<span class="s0">100 0 0 4 132 3346 0 0 153 /**</span>
 <span class="s0">* Changes the start byte of an existing column.  This is only legal on an</span>
 <span class="s0">* unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/ 2 4 this 3 3363  5 start 1 3177  </span>
<span class="s0">101 0 0 4 133 3346 0 0 159 /**</span>
 <span class="s0">* Changes the column alignment of an existing column.  This is only legal on</span>
 <span class="s0">* an unregistered format (i.e.  when constructing the format initially).</span>
 <span class="s0">*/ 2 4 this 3 3363  16 column_alignment 1 3177  </span>
<span class="s0">102 0 0 4 134 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3187  3 out 1 3347  </span>
<span class="s0">103 0 0 7 140 3364 1712 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">104 0 0 23 140 3364 1712 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 5 name0 1 3193  15 num_components0 1 3177  13 numeric_type0 1 3173  9 contents0 1 3174  </span>
<span class="s0">105 0 0 23 140 3364 1712 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 8 5 name0 1 3193  15 num_components0 1 3177  13 numeric_type0 1 3173  9 contents0 1 3174  5 name1 1 3193  15 num_components1 1 3177  13 numeric_type1 1 3173  9 contents1 1 3174  </span>
<span class="s0">106 0 0 23 140 3364 1712 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 12 5 name0 1 3193  15 num_components0 1 3177  13 numeric_type0 1 3173  9 contents0 1 3174  5 name1 1 3193  15 num_components1 1 3177  13 numeric_type1 1 3173  9 contents1 1 3174  5 name2 1 3193  15 num_components2 1 3177  13 numeric_type2 1 3173  9 contents2 1 3174  </span>
<span class="s0">107 0 0 23 140 3364 1712 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 16 5 name0 1 3193  15 num_components0 1 3177  13 numeric_type0 1 3173  9 contents0 1 3174  5 name1 1 3193  15 num_components1 1 3177  13 numeric_type1 1 3173  9 contents1 1 3174  5 name2 1 3193  15 num_components2 1 3177  13 numeric_type2 1 3173  9 contents2 1 3174  5 name3 1 3193  15 num_components3 1 3177  13 numeric_type3 1 3173  9 contents3 1 3174  </span>
<span class="s0">108 0 0 15 140 3364 1712 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3191  </span>
<span class="s0">109 0 0 7 141 3364 1712 0 0 2 4 this 3 3364  4 copy 1 3191  </span>
<span class="s0">110 0 0 6 143 3178 0 0 123 /**</span>
 <span class="s0">* This method overrides ReferenceCount::unref() to unregister the object when</span>
 <span class="s0">* its reference count goes to zero.</span>
 <span class="s0">*/ 1 4 this 3 3191  </span>
<span class="s0">111 0 0 6 144 3178 0 0 198 /**</span>
 <span class="s0">* Returns true if this format has been registered, false if it has not.  It</span>
 <span class="s0">* may not be used for a Geom until it has been registered, but once</span>
 <span class="s0">* registered, it may no longer be modified.</span>
 <span class="s0">*/ 1 4 this 3 3191  </span>
<span class="s0">112 0 0 7 145 3191 0 0 421 /**</span>
 <span class="s0">* Adds the indicated format to the registry, if there is not an equivalent</span>
 <span class="s0">* format already there; in either case, returns the pointer to the equivalent</span>
 <span class="s0">* format now in the registry.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to GeomVertexFormat::register_format(), except that you</span>
 <span class="s0">* generally need not call it explicitly.  Calling</span>
 <span class="s0">* GeomVertexFormat::register_format() automatically registers all of the</span>
 <span class="s0">* nested array formats.</span>
 <span class="s0">*/ 1 6 format 1 3191  </span>
<span class="s0">113 0 0 6 147 3177 0 0 83 /**</span>
 <span class="s0">* Returns the total number of bytes reserved in the array for each vertex.</span>
 <span class="s0">*/ 1 4 this 3 3191  </span>
<span class="s0">114 0 0 4 148 3346 0 0 175 /**</span>
 <span class="s0">* Changes the total number of bytes reserved in the array for each vertex.</span>
 <span class="s0">* You may not reduce this below get_total_bytes(), but you may increase it</span>
 <span class="s0">* arbitrarily.</span>
 <span class="s0">*/ 2 4 this 3 3364  6 stride 1 3177  </span>
<span class="s0">115 0 0 6 150 3177 0 0 347 /**</span>
 <span class="s0">* Returns the byte divisor to which the data record must be padded to meet</span>
 <span class="s0">* hardware limitations.  For instance, if this is 4, the stride will be</span>
 <span class="s0">* automatically rounded up to the next multiple of 4 bytes.  This value is</span>
 <span class="s0">* automatically increased as needed to ensure the individual numeric</span>
 <span class="s0">* components in the array are word-aligned.</span>
 <span class="s0">*/ 1 4 this 3 3191  </span>
<span class="s0">116 0 0 4 151 3346 0 0 355 /**</span>
 <span class="s0">* Explicitly sets the byte divisor to which the data record must be padded to</span>
 <span class="s0">* meet hardware limitations.  See get_pad_to().  Normally it is not necessary</span>
 <span class="s0">* to call this unless you have some specific requirements for row-to-row data</span>
 <span class="s0">* alignment.  Note that this value may be automatically increased at each</span>
 <span class="s0">* subsequent call to add_column().</span>
 <span class="s0">*/ 2 4 this 3 3364  6 pad_to 1 3177  </span>
<span class="s0">117 0 0 6 153 3177 0 0 214 /**</span>
 <span class="s0">* Returns the divisor attribute for the data in this array.  If 0, it</span>
 <span class="s0">* contains per-vertex data.  If 1, it contains per-instance data.  If higher</span>
 <span class="s0">* than 1, the read row is advanced for each n instances.</span>
 <span class="s0">*/ 1 4 this 3 3191  </span>
<span class="s0">118 0 0 4 154 3346 0 0 206 /**</span>
 <span class="s0">* Set this to 0 to indicate that this array contains per-vertex data, or to 1</span>
 <span class="s0">* to indicate that it contains per-instance data.  If higher than 1, the read</span>
 <span class="s0">* row is advanced for each n instances.</span>
 <span class="s0">*/ 2 4 this 3 3364  7 divisor 1 3177  </span>
<span class="s0">119 0 0 6 156 3177 0 0 122 /**</span>
 <span class="s0">* Returns the total number of bytes used by the data types within the format,</span>
 <span class="s0">* including gaps between elements.</span>
 <span class="s0">*/ 1 4 this 3 3191  </span>
<span class="s0">120 0 0 6 158 3177 0 0 319 /**</span>
 <span class="s0">* Adds a new column to the specification.  This is a table of per-vertex</span>
 <span class="s0">* floating-point numbers such as &quot;vertex&quot; or &quot;normal&quot;; you must specify where</span>
 <span class="s0">* in each record the table starts, and how many components (dimensions) exist</span>
 <span class="s0">* per vertex.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index number of the new data type.</span>
 <span class="s0">*/ 7 4 this 3 3364  4 name 1 3193  14 num_components 1 3177  12 numeric_type 1 3173  8 contents 1 3174  5 start 5 3177  16 column_alignment 5 3177  </span>
<span class="s0">121 0 0 6 158 3177 0 0 471 /**</span>
 <span class="s0">* Adds a new column to the specification.  This is a table of per-vertex</span>
 <span class="s0">* floating-point numbers such as &quot;vertex&quot; or &quot;normal&quot;; you must specify where</span>
 <span class="s0">* in each record the table starts, and how many components (dimensions) exist</span>
 <span class="s0">* per vertex.</span>
 <span class="s0">*</span>
 <span class="s0">* Adding a column with the same name as a previous type, or that overlaps</span>
 <span class="s0">* with one or more previous types, quietly removes the previous type(s).</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the index number of the new data type.</span>
 <span class="s0">*/ 2 4 this 3 3364  6 column 1 3187  </span>
<span class="s0">122 0 0 4 159 3346 0 0 107 /**</span>
 <span class="s0">* Removes the column with the indicated name, if any.  This leaves a gap in</span>
 <span class="s0">* the byte structure.</span>
 <span class="s0">*/ 2 4 this 3 3364  4 name 1 3193  </span>
<span class="s0">123 0 0 4 160 3346 0 0 104 /**</span>
 <span class="s0">* Removes all columns previously added, sets the stride to zero, and prepares</span>
 <span class="s0">* to start over.</span>
 <span class="s0">*/ 1 4 this 3 3364  </span>
<span class="s0">124 0 0 4 161 3346 0 0 48 /**</span>
 <span class="s0">* Removes wasted space between columns.</span>
 <span class="s0">*/ 1 4 this 3 3364  </span>
<span class="s0">125 0 0 4 162 3346 0 0 319 /**</span>
 <span class="s0">* Reprocesses the columns in the format to align the C_point and C_vector</span>
 <span class="s0">* columns to 16-byte boundaries to allow for the more efficient SSE2</span>
 <span class="s0">* operations (assuming SSE2 is enabled in the build).</span>
 <span class="s0">*</span>
 <span class="s0">* The caller is responsible for testing vertex_animation_align_16 to decide</span>
 <span class="s0">* whether to call this method.</span>
 <span class="s0">*/ 1 4 this 3 3364  </span>
<span class="s0">126 0 0 6 163 3177 0 0 64 /**</span>
 <span class="s0">* Returns the number of different columns in the array.</span>
 <span class="s0">*/ 1 4 this 3 3191  </span>
<span class="s0">127 0 0 6 164 3187 0 0 97 /**</span>
 <span class="s0">* Returns the specification with the indicated name, or NULL if the name is</span>
 <span class="s0">* not used.</span>
 <span class="s0">*/ 2 4 this 3 3191  4 name 1 3193  </span>
<span class="s0">128 0 0 6 164 3187 0 0 47 /**</span>
 <span class="s0">* Returns the ith column of the array.</span>
 <span class="s0">*/ 2 4 this 3 3191  1 i 1 3177  </span>
<span class="s0">129 0 0 6 164 3187 0 0 125 /**</span>
 <span class="s0">* Returns the first specification that overlaps with any of the indicated</span>
 <span class="s0">* bytes in the range, or NULL if none do.</span>
 <span class="s0">*/ 3 4 this 3 3191  10 start_byte 1 3177  9 num_bytes 1 3177  </span>
<span class="s0">130 0 0 6 169 3178 0 0 75 /**</span>
 <span class="s0">* Returns true if the array has the named column, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3191  4 name 1 3193  </span>
<span class="s0">131 0 0 6 170 3178 0 0 309 /**</span>
 <span class="s0">* Returns true if all of the fields in this array format are also present and</span>
 <span class="s0">* equivalent in the other array format, and in the same byte positions, and</span>
 <span class="s0">* the stride is the same.  That is, true if this format can share the same</span>
 <span class="s0">* data pointer as the other format (with possibly some unused gaps).</span>
 <span class="s0">*/ 2 4 this 3 3191  5 other 1 3191  </span>
<span class="s0">132 0 0 6 171 3177 0 0 83 /**</span>
 <span class="s0">* Returns the number of bytes per row that are not assigned to any column.</span>
 <span class="s0">*/ 1 4 this 3 3191  </span>
<span class="s0">133 0 0 4 172 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3191  3 out 1 3347  </span>
<span class="s0">134 0 0 4 173 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3191  3 out 1 3347  12 indent_level 5 3177  </span>
<span class="s0">135 0 0 4 174 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 3191  3 out 1 3347  12 indent_level 1 3177  10 array_data 1 3365  </span>
<span class="s0">136 0 0 6 175 3342 0 0 242 /**</span>
 <span class="s0">* Returns a string with format codes representing the exact memory layout of</span>
 <span class="s0">* the columns in memory, as understood by Python's struct module.  If pad is</span>
 <span class="s0">* true, extra padding bytes are added to the end as 'x' characters as needed.</span>
 <span class="s0">*/ 2 4 this 3 3191  3 pad 5 3178  </span>
<span class="s0">137 0 0 7 176 3362 0 0 0 0 </span>
<span class="s0">138 0 0 7 136 3241 0 0 0 1 4 this 3 3364  </span>
<span class="s0">139 0 0 6 138 3353 0 0 0 1 4 this 3 3364  </span>
<span class="s0">140 0 0 7 182 3367 1744 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">141 0 0 23 182 3367 1744 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 12 array_format 1 3191  </span>
<span class="s0">142 0 0 15 182 3367 1744 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3229  </span>
<span class="s0">143 0 0 7 183 3367 1744 0 0 2 4 this 3 3367  4 copy 1 3229  </span>
<span class="s0">144 0 0 6 185 3178 0 0 123 /**</span>
 <span class="s0">* This method overrides ReferenceCount::unref() to unregister the object when</span>
 <span class="s0">* its reference count goes to zero.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">145 0 0 6 186 3178 0 0 198 /**</span>
 <span class="s0">* Returns true if this format has been registered, false if it has not.  It</span>
 <span class="s0">* may not be used for a Geom until it has been registered, but once</span>
 <span class="s0">* registered, it may no longer be modified.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">146 0 0 7 187 3229 0 0 118 /**</span>
 <span class="s0">* This flavor of register_format() implicitly creates a one-array vertex</span>
 <span class="s0">* format from the array definition.</span>
 <span class="s0">*/ 1 6 format 1 3191  </span>
<span class="s0">147 0 0 7 187 3229 0 0 484 /**</span>
 <span class="s0">* Adds the indicated format to the registry, if there is not an equivalent</span>
 <span class="s0">* format already there; in either case, returns the pointer to the equivalent</span>
 <span class="s0">* format now in the registry.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called before a format may be used in a Geom.  After this</span>
 <span class="s0">* call, you should discard the original pointer you passed in (which may or</span>
 <span class="s0">* may not now be invalid) and let its reference count decrement normally; you</span>
 <span class="s0">* should use only the returned value from this point on.</span>
 <span class="s0">*/ 1 6 format 1 3229  </span>
<span class="s0">148 0 0 6 189 3357 0 0 117 /**</span>
 <span class="s0">* Returns the GeomVertexAnimationSpec that indicates how this format's</span>
 <span class="s0">* vertices are set up for animation.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">149 0 0 4 190 3346 0 0 260 /**</span>
 <span class="s0">* Resets the GeomVertexAnimationSpec that indicates how this format's</span>
 <span class="s0">* vertices are set up for animation.  You should also, of course, change the</span>
 <span class="s0">* columns in the tables accordingly.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3367  9 animation 1 3357  </span>
<span class="s0">150 0 0 7 193 3229 0 0 325 /**</span>
 <span class="s0">* Returns a suitable vertex format for sending the animated vertices to the</span>
 <span class="s0">* graphics backend.  This is the same format as the source format, with the</span>
 <span class="s0">* CPU-animation data elements removed.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.  The return</span>
 <span class="s0">* value will have been already registered.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">151 0 0 7 194 3229 0 0 447 /**</span>
 <span class="s0">* Returns a new GeomVertexFormat that includes all of the columns defined in</span>
 <span class="s0">* either this GeomVertexFormat or the other one.  If any column is defined in</span>
 <span class="s0">* both formats with different sizes (for instance, texcoord2 vs.  texcoord3),</span>
 <span class="s0">* the new format will include the larger of the two definitions.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after both source formats have been registered.</span>
 <span class="s0">* The return value will also have been already registered.</span>
 <span class="s0">*/ 2 4 this 3 3229  5 other 1 3229  </span>
<span class="s0">152 0 0 6 195 3209 0 0 223 /**</span>
 <span class="s0">* Returns the number of individual arrays required by the format.  If the</span>
 <span class="s0">* array data is completely interleaved, this will be 1; if it is completely</span>
 <span class="s0">* parallel, this will be the same as the number of data types.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">153 0 0 7 196 3191 0 0 71 /**</span>
 <span class="s0">* Returns the description of the nth array used by the format.</span>
 <span class="s0">*/ 2 4 this 3 3229  5 array 1 3209  </span>
<span class="s0">154 0 0 7 198 3364 1712 0 190 /**</span>
 <span class="s0">* Returns a modifiable pointer to the indicated array.  This means</span>
 <span class="s0">* duplicating it if it is shared or registered.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3367  5 array 1 3209  </span>
<span class="s0">155 0 0 4 199 3346 0 0 124 /**</span>
 <span class="s0">* Replaces the definition of the indicated array.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 3 4 this 3 3367  5 array 1 3209  6 format 1 3191  </span>
<span class="s0">156 0 0 4 200 3346 0 0 115 /**</span>
 <span class="s0">* Removes the nth array from the format.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3367  5 array 1 3209  </span>
<span class="s0">157 0 0 6 201 3209 0 0 243 /**</span>
 <span class="s0">* Adds the indicated array definition to the list of arrays included within</span>
 <span class="s0">* this vertex format definition.  The return value is the index number of the</span>
 <span class="s0">* new array.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3367  12 array_format 1 3191  </span>
<span class="s0">158 0 0 4 202 3346 0 0 275 /**</span>
 <span class="s0">* Adds the indicated array definition to the list of arrays at the indicated</span>
 <span class="s0">* position.  This works just like add_array(), except that you can specify</span>
 <span class="s0">* which array index the new array should have.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 3 4 this 3 3367  5 array 1 3209  12 array_format 1 3191  </span>
<span class="s0">159 0 0 4 203 3346 0 0 146 /**</span>
 <span class="s0">* Removes all of the array definitions from the format and starts over.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 1 4 this 3 3367  </span>
<span class="s0">160 0 0 4 204 3346 0 0 119 /**</span>
 <span class="s0">* Removes the arrays that define no columns.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 1 4 this 3 3367  </span>
<span class="s0">161 0 0 6 205 3209 0 0 100 /**</span>
 <span class="s0">* Returns the total number of different columns in the specification, across</span>
 <span class="s0">* all arrays.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">162 0 0 6 206 3177 0 0 407 /**</span>
 <span class="s0">* Returns the index number of the array with the indicated column, or -1 if</span>
 <span class="s0">* no arrays contained that name.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value can be passed to get_array_format() to get the format of</span>
 <span class="s0">* the array.  It may also be passed to GeomVertexData::get_array_data() or</span>
 <span class="s0">* get_data() or set_data() to manipulate the actual array data.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3229  4 name 1 3193  </span>
<span class="s0">163 0 0 6 206 3177 0 0 290 /**</span>
 <span class="s0">* Returns the index number of the array with the ith column.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value can be passed to get_array_format() to get the format of</span>
 <span class="s0">* the array.  It may also be passed to GeomVertexData::get_array_data() or</span>
 <span class="s0">* get_data() or set_data() to manipulate the actual array data.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 i 1 3209  </span>
<span class="s0">164 0 0 6 207 3187 0 0 179 /**</span>
 <span class="s0">* Returns the specification with the indicated name, or NULL if the name is</span>
 <span class="s0">* not used.  Use get_array_with() to determine which array this column is</span>
 <span class="s0">* associated with.</span>
 <span class="s0">*/ 2 4 this 3 3229  4 name 1 3193  </span>
<span class="s0">165 0 0 6 207 3187 0 0 74 /**</span>
 <span class="s0">* Returns the ith column of the specification, across all arrays.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 i 1 3209  </span>
<span class="s0">166 0 0 6 208 3178 0 0 76 /**</span>
 <span class="s0">* Returns true if the format has the named column, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3229  4 name 1 3193  </span>
<span class="s0">167 0 0 7 209 3193 0 0 65 /**</span>
 <span class="s0">* Returns the name of the ith column, across all arrays.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 i 1 3209  </span>
<span class="s0">168 0 0 4 211 3346 0 0 370 /**</span>
 <span class="s0">* Removes the named column from the format, from whichever array it exists</span>
 <span class="s0">* in.  If there are other columns remaining in the array, the array is left</span>
 <span class="s0">* with a gap where the column used to be; if this was the only column in the</span>
 <span class="s0">* array, the array is removed (unless keep_empty_array is true).</span>
 <span class="s0">*</span>
 <span class="s0">* This may not be called once the format has been registered.</span>
 <span class="s0">*/ 3 4 this 3 3367  4 name 1 3193  16 keep_empty_array 5 3178  </span>
<span class="s0">169 0 0 4 212 3346 0 0 48 /**</span>
 <span class="s0">* Removes wasted space between columns.</span>
 <span class="s0">*/ 1 4 this 3 3367  </span>
<span class="s0">170 0 0 4 213 3346 0 0 259 /**</span>
 <span class="s0">* Reprocesses the columns in the format to align the C_point and C_vector</span>
 <span class="s0">* columns to 16-byte boundaries to allow for the more efficient SSE2</span>
 <span class="s0">* operations (assuming SSE2 is enabled in the build).</span>
 <span class="s0">*</span>
 <span class="s0">* Also see maybe_align_columns_for_animation().</span>
 <span class="s0">*/ 1 4 this 3 3367  </span>
<span class="s0">171 0 0 4 214 3346 0 0 172 /**</span>
 <span class="s0">* Calls align_columns_for_animation() if this format's AnimationSpec</span>
 <span class="s0">* indicates that it contains animated vertices, and if vertex-animation-</span>
 <span class="s0">* align-16 is true.</span>
 <span class="s0">*/ 1 4 this 3 3367  </span>
<span class="s0">172 0 0 6 215 3209 0 0 161 /**</span>
 <span class="s0">* Returns the number of columns within the format that represent points in</span>
 <span class="s0">* space.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">173 0 0 7 216 3193 0 0 219 /**</span>
 <span class="s0">* Returns the name of the nth point column.  This represents a point in</span>
 <span class="s0">* space, which should be transformed by any spatial transform matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 n 1 3209  </span>
<span class="s0">174 0 0 6 218 3209 0 0 165 /**</span>
 <span class="s0">* Returns the number of columns within the format that represent directional</span>
 <span class="s0">* vectors.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">175 0 0 7 219 3193 0 0 239 /**</span>
 <span class="s0">* Returns the name of the nth vector column.  This represents a directional</span>
 <span class="s0">* vector, which should be transformed by any spatial transform matrix as a</span>
 <span class="s0">* vector.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 n 1 3209  </span>
<span class="s0">176 0 0 6 221 3209 0 0 165 /**</span>
 <span class="s0">* Returns the number of columns within the format that represent texture</span>
 <span class="s0">* coordinates.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">177 0 0 7 222 3193 0 0 165 /**</span>
 <span class="s0">* Returns the name of the nth texcoord column.  This represents a texture</span>
 <span class="s0">* coordinate.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 n 1 3209  </span>
<span class="s0">178 0 0 6 224 3209 0 0 158 /**</span>
 <span class="s0">* Returns the number of columns within the format that represent morph</span>
 <span class="s0">* deltas.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 1 4 this 3 3229  </span>
<span class="s0">179 0 0 7 225 3193 0 0 288 /**</span>
 <span class="s0">* Returns the slider name associated with the nth morph column.  This is the</span>
 <span class="s0">* name of the slider that will control the morph, and should be defined</span>
 <span class="s0">* within the SliderTable associated with the GeomVertexData.</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 n 1 3209  </span>
<span class="s0">180 0 0 7 226 3193 0 0 265 /**</span>
 <span class="s0">* Returns the name of the base column that the nth morph modifies.  This</span>
 <span class="s0">* column will also be defined within the format, and can be retrieved via</span>
 <span class="s0">* get_array_with() and/or get_column().</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 n 1 3209  </span>
<span class="s0">181 0 0 7 227 3193 0 0 356 /**</span>
 <span class="s0">* Returns the name of the column that defines the nth morph.  This contains</span>
 <span class="s0">* the delta offsets that are to be applied to the column defined by</span>
 <span class="s0">* get_morph_base().  This column will be defined within the format, and can</span>
 <span class="s0">* be retrieved via get_array_with() and/or get_column().</span>
 <span class="s0">*</span>
 <span class="s0">* This may only be called after the format has been registered.</span>
 <span class="s0">*/ 2 4 this 3 3229  1 n 1 3209  </span>
<span class="s0">182 0 0 4 239 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3229  3 out 1 3347  </span>
<span class="s0">183 0 0 4 240 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3229  3 out 1 3347  12 indent_level 5 3177  </span>
<span class="s0">184 0 0 4 241 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 3229  3 out 1 3347  12 indent_level 1 3177  4 data 1 3368  </span>
<span class="s0">185 0 0 7 242 3229 0 0 115 /**</span>
 <span class="s0">* Returns a standard vertex format containing no arrays at all, useful for</span>
 <span class="s0">* pull-style vertex rendering.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">186 0 0 7 243 3229 0 0 202 // Some standard vertex formats.  No particular requirement to use one of</span>
<span class="s0">// these, but the DirectX renderers can use these formats directly, whereas</span>
<span class="s0">// any other format will have to be converted first. 0 </span>
<span class="s0">187 0 0 7 244 3229 0 0 107 /**</span>
 <span class="s0">* Returns a standard vertex format with a 3-component normal and a</span>
 <span class="s0">* 3-component vertex position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">188 0 0 7 245 3229 0 0 124 /**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate pair</span>
 <span class="s0">* and a 3-component vertex position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">189 0 0 7 246 3229 0 0 147 /**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a 3-component normal, and a 3-component vertex position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">190 0 0 7 247 3229 0 0 269 // These formats, with the DirectX-style packed color, may not be supported</span>
<span class="s0">// directly by OpenGL.  If you use them and the driver does not support</span>
<span class="s0">// them, the GLGraphicsStateGuardian will automatically convert to native</span>
<span class="s0">// OpenGL form (with a small runtime overhead). 0 </span>
<span class="s0">191 0 0 7 248 3229 0 0 141 /**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a packed color, and a 3-component vertex position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">192 0 0 7 249 3229 0 0 124 /**</span>
 <span class="s0">* Returns a standard vertex format with a packed color, a 3-component normal,</span>
 <span class="s0">* and a 3-component vertex position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">193 0 0 7 250 3229 0 0 166 /**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a packed color, a 3-component normal, and a 3-component vertex</span>
 <span class="s0">* position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">194 0 0 7 251 3229 0 0 318 // These formats, with an OpenGL-style four-byte color, are not supported</span>
<span class="s0">// directly by DirectX.  If you use them, the DXGraphicsStateGuardian will</span>
<span class="s0">// automatically convert to DirectX form (with a larger runtime overhead,</span>
<span class="s0">// since DirectX8, and old DirectX9 drivers, require everything to be</span>
<span class="s0">// interleaved together). 0 </span>
<span class="s0">195 0 0 7 252 3229 0 0 146 /**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a 4-component color, and a 3-component vertex position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">196 0 0 7 253 3229 0 0 129 /**</span>
 <span class="s0">* Returns a standard vertex format with a 4-component color, a 3-component</span>
 <span class="s0">* normal, and a 3-component vertex position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">197 0 0 7 254 3229 0 0 171 /**</span>
 <span class="s0">* Returns a standard vertex format with a 2-component texture coordinate</span>
 <span class="s0">* pair, a 4-component color, a 3-component normal, and a 3-component vertex</span>
 <span class="s0">* position.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">198 0 0 7 255 3362 0 0 0 0 </span>
<span class="s0">199 0 0 7 178 3241 0 0 0 1 4 this 3 3367  </span>
<span class="s0">200 0 0 6 180 3353 0 0 0 1 4 this 3 3367  </span>
<span class="s0">201 0 0 7 262 3370 1802 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 name 1 3342  8 max_size 1 3209  </span>
<span class="s0">202 0 0 6 264 3209 0 0 77 /**</span>
 <span class="s0">* Returns the total size of all objects currently active on the LRU.</span>
 <span class="s0">*/ 1 4 this 3 3371  </span>
<span class="s0">203 0 0 6 265 3209 0 0 91 /**</span>
 <span class="s0">* Returns the max size of all objects that are allowed to be active on the</span>
 <span class="s0">* LRU.</span>
 <span class="s0">*/ 1 4 this 3 3371  </span>
<span class="s0">204 0 0 4 266 3346 0 0 143 /**</span>
 <span class="s0">* Changes the max size of all objects that are allowed to be active on the</span>
 <span class="s0">* LRU.</span>
 <span class="s0">*</span>
 <span class="s0">* If the size is (size_t)-1, there is no limit.</span>
 <span class="s0">*/ 2 4 this 3 3370  8 max_size 1 3209  </span>
<span class="s0">205 0 0 6 267 3209 0 0 106 /**</span>
 <span class="s0">* Returns the total size of the pages that were enqueued since the last call</span>
 <span class="s0">* to begin_epoch().</span>
 <span class="s0">*/ 1 4 this 3 3371  </span>
<span class="s0">206 0 0 4 268 3346 0 0 61 /**</span>
 <span class="s0">* Evicts a sequence of objects if the queue is full.</span>
 <span class="s0">*/ 1 4 this 3 3370  </span>
<span class="s0">207 0 0 4 269 3346 0 0 132 /**</span>
 <span class="s0">* Evicts a sequence of objects until the queue fits within the indicated</span>
 <span class="s0">* target size, regardless of its normal max size.</span>
 <span class="s0">*/ 2 4 this 3 3370  11 target_size 1 3209  </span>
<span class="s0">208 0 0 4 270 3346 0 0 184 /**</span>
 <span class="s0">* Marks the end of the previous epoch and the beginning of the next one.</span>
 <span class="s0">* This will evict any objects that are pending eviction, and also update any</span>
 <span class="s0">* internal bookkeeping.</span>
 <span class="s0">*/ 1 4 this 3 3370  </span>
<span class="s0">209 0 0 6 271 3178 0 0 125 /**</span>
 <span class="s0">* Checks that the LRU is internally self-consistent.  Returns true if</span>
 <span class="s0">* successful, false if there is some problem.</span>
 <span class="s0">*/ 1 4 this 3 3370  </span>
<span class="s0">210 0 0 4 272 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3371  3 out 1 3347  </span>
<span class="s0">211 0 0 4 273 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3371  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">212 0 0 6 258 3373 0 0 0 1 4 this 3 3370  </span>
<span class="s0">213 0 0 6 260 3374 0 0 0 1 4 this 3 3370  </span>
<span class="s0">214 0 0 15 277 3377 1817 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3375  </span>
<span class="s0">215 0 0 7 277 3377 1817 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 8 lru_size 1 3209  </span>
<span class="s0">216 0 0 6 278 3377 0 0 0 2 4 this 3 3377  4 copy 1 3375  </span>
<span class="s0">217 0 0 6 280 3370 0 0 104 /**</span>
 <span class="s0">* Returns the LRU that manages this page, or NULL if it is not currently</span>
 <span class="s0">* managed by any LRU.</span>
 <span class="s0">*/ 1 4 this 3 3375  </span>
<span class="s0">218 0 0 4 281 3346 0 0 183 /**</span>
 <span class="s0">* Adds the page to the LRU for the first time, or marks it recently-accessed</span>
 <span class="s0">* if it has already been added.</span>
 <span class="s0">*</span>
 <span class="s0">* If lru is NULL, it means to remove this page from its LRU.</span>
 <span class="s0">*/ 2 4 this 3 3377  3 lru 1 3370  </span>
<span class="s0">219 0 0 4 282 3346 0 0 47 /**</span>
 <span class="s0">* Removes the page from its SimpleLru.</span>
 <span class="s0">*/ 1 4 this 3 3377  </span>
<span class="s0">220 0 0 4 283 3346 0 0 222 /**</span>
 <span class="s0">* To be called when the page is used; this will move it to the tail of the</span>
 <span class="s0">* SimpleLru queue it is already on.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is const because it's not technically modifying the contents of</span>
 <span class="s0">* the page itself.</span>
 <span class="s0">*/ 1 4 this 3 3375  </span>
<span class="s0">221 0 0 4 283 3346 0 0 113 /**</span>
 <span class="s0">* To be called when the page is used; this will move it to the tail of the</span>
 <span class="s0">* specified SimpleLru queue.</span>
 <span class="s0">*/ 2 4 this 3 3377  3 lru 1 3370  </span>
<span class="s0">222 0 0 6 284 3209 0 0 85 /**</span>
 <span class="s0">* Returns the size of this page as reported to the LRU, presumably in bytes.</span>
 <span class="s0">*/ 1 4 this 3 3375  </span>
<span class="s0">223 0 0 4 285 3346 0 0 98 /**</span>
 <span class="s0">* Specifies the size of this page, presumably in bytes, although any unit is</span>
 <span class="s0">* possible.</span>
 <span class="s0">*/ 2 4 this 3 3377  8 lru_size 1 3209  </span>
<span class="s0">224 0 0 4 286 3346 0 0 455 /**</span>
 <span class="s0">* Evicts the page from the LRU.  Called internally when the LRU determines</span>
 <span class="s0">* that it is full.  May also be called externally when necessary to</span>
 <span class="s0">* explicitly evict the page.</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal for this method to either evict the page as requested, do</span>
 <span class="s0">* nothing (in which case the eviction will be requested again at the next</span>
 <span class="s0">* epoch), or requeue itself on the tail of the queue (in which case the</span>
 <span class="s0">* eviction will be requested again much later).</span>
 <span class="s0">*/ 1 4 this 3 3377  </span>
<span class="s0">225 0 0 4 287 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3375  3 out 1 3347  </span>
<span class="s0">226 0 0 4 288 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3375  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">227 0 0 6 275 3373 0 0 0 1 4 this 3 3377  </span>
<span class="s0">228 0 0 7 292 3380 1830 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 8 max_size 1 3209  4 lock 1 3378  </span>
<span class="s0">229 0 0 6 294 3381 0 0 198 /**</span>
 <span class="s0">* Allocates a new block.  Returns NULL if a block of the requested size</span>
 <span class="s0">* cannot be allocated.</span>
 <span class="s0">*</span>
 <span class="s0">* To free the allocated block, call block-&gt;free(), or simply delete the block</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/ 3 4 this 3 3380  4 size 1 3209  9 alignment 5 3209  </span>
<span class="s0">230 0 0 6 295 3178 0 0 108 /**</span>
 <span class="s0">* Returns true if there are no blocks allocated on this page, or false if</span>
 <span class="s0">* there is at least one.</span>
 <span class="s0">*/ 1 4 this 3 3382  </span>
<span class="s0">231 0 0 6 296 3209 0 0 55 /**</span>
 <span class="s0">* Returns the total size of allocated objects.</span>
 <span class="s0">*/ 1 4 this 3 3382  </span>
<span class="s0">232 0 0 6 297 3209 0 0 61 /**</span>
 <span class="s0">* Returns the available space for allocated objects.</span>
 <span class="s0">*/ 1 4 this 3 3382  </span>
<span class="s0">233 0 0 4 298 3346 0 0 172 /**</span>
 <span class="s0">* Changes the available space for allocated objects.  This will not affect</span>
 <span class="s0">* any already-allocated objects, but will have an effect on future calls to</span>
 <span class="s0">* alloc().</span>
 <span class="s0">*/ 2 4 this 3 3380  8 max_size 1 3209  </span>
<span class="s0">234 0 0 6 299 3209 0 0 299 /**</span>
 <span class="s0">* Returns an upper-bound estimate of the size of the largest contiguous block</span>
 <span class="s0">* that may be allocated.  It is guaranteed that an attempt to allocate a</span>
 <span class="s0">* block larger than this will fail, though it is not guaranteed that an</span>
 <span class="s0">* attempt to allocate a block this size or smaller will succeed.</span>
 <span class="s0">*/ 1 4 this 3 3382  </span>
<span class="s0">235 0 0 6 300 3381 0 0 103 /**</span>
 <span class="s0">* Returns a pointer to the first allocated block, or NULL if there are no</span>
 <span class="s0">* allocated blocks.</span>
 <span class="s0">*/ 1 4 this 3 3382  </span>
<span class="s0">236 0 0 4 301 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3382  3 out 1 3347  </span>
<span class="s0">237 0 0 4 302 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3382  3 out 1 3347  </span>
<span class="s0">238 0 0 6 290 3373 0 0 0 1 4 this 3 3380  </span>
<span class="s0">239 0 0 4 305 3346 0 0 40 /**</span>
 <span class="s0">* Releases the allocated space.</span>
 <span class="s0">*/ 1 4 this 3 3381  </span>
<span class="s0">240 0 0 6 306 3380 0 0 113 /**</span>
 <span class="s0">* Returns the SimpleAllocator object that owns this block.  Returns NULL if</span>
 <span class="s0">* the block has been freed.</span>
 <span class="s0">*/ 1 4 this 3 3384  </span>
<span class="s0">241 0 0 6 307 3209 0 0 113 /**</span>
 <span class="s0">* Returns the starting point of this block.  It is an error to call this if</span>
 <span class="s0">* the block has been freed.</span>
 <span class="s0">*/ 1 4 this 3 3384  </span>
<span class="s0">242 0 0 6 308 3209 0 0 103 /**</span>
 <span class="s0">* Returns the size of this block.  It is an error to call this if the block</span>
 <span class="s0">* has been freed.</span>
 <span class="s0">*/ 1 4 this 3 3384  </span>
<span class="s0">243 0 0 6 309 3178 0 0 80 /**</span>
 <span class="s0">* Returns true if the block has been freed, false if it is still valid.</span>
 <span class="s0">*/ 1 4 this 3 3384  </span>
<span class="s0">244 0 0 6 310 3209 0 0 107 /**</span>
 <span class="s0">* Returns the maximum size this block can be reallocated to, as limited by</span>
 <span class="s0">* the following block.</span>
 <span class="s0">*/ 1 4 this 3 3384  </span>
<span class="s0">245 0 0 6 311 3178 0 0 144 /**</span>
 <span class="s0">* Changes the size of this block to the specified size.  Returns true if the</span>
 <span class="s0">* change is accepted, false if there was not enough room.</span>
 <span class="s0">*/ 2 4 this 3 3381  4 size 1 3209  </span>
<span class="s0">246 0 0 6 312 3381 0 0 120 /**</span>
 <span class="s0">* Returns a pointer to the next allocated block in the chain, or NULL if</span>
 <span class="s0">* there are no more allocated blocks.</span>
 <span class="s0">*/ 1 4 this 3 3384  </span>
<span class="s0">247 0 0 4 313 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3384  3 out 1 3347  </span>
<span class="s0">248 0 0 6 315 3178 0 0 119 /**</span>
 <span class="s0">* Returns true if the save file was successfully created and is ready for</span>
 <span class="s0">* use, false if there was an error.</span>
 <span class="s0">*/ 1 4 this 3 3386  </span>
<span class="s0">249 0 0 6 316 3209 0 0 95 /**</span>
 <span class="s0">* Returns the amount of space consumed by the save file, including unused</span>
 <span class="s0">* portions.</span>
 <span class="s0">*/ 1 4 this 3 3386  </span>
<span class="s0">250 0 0 6 317 3209 0 0 85 /**</span>
 <span class="s0">* Returns the amount of space within the save file that is currently in use.</span>
 <span class="s0">*/ 1 4 this 3 3386  </span>
<span class="s0">251 0 0 6 324 3202 0 0 135 /**</span>
 <span class="s0">* Returns the current ram class of the array.  If this is other than</span>
 <span class="s0">* RC_resident, the array data is not resident in memory.</span>
 <span class="s0">*/ 1 4 this 3 3388  </span>
<span class="s0">252 0 0 6 325 3202 0 0 212 /**</span>
 <span class="s0">* Returns the pending ram class of the array.  If this is different from</span>
 <span class="s0">* get_ram_class(), this page has been queued to be processed by the thread.</span>
 <span class="s0">* Eventually the page will be set to this ram class.</span>
 <span class="s0">*/ 1 4 this 3 3388  </span>
<span class="s0">253 0 0 4 326 3346 0 0 128 /**</span>
 <span class="s0">* Ensures that the page will become resident soon.  Future calls to</span>
 <span class="s0">* get_page_data() will eventually return non-NULL.</span>
 <span class="s0">*/ 1 4 this 3 3390  </span>
<span class="s0">254 0 0 7 327 3391 1888 0 198 /**</span>
 <span class="s0">* Allocates a new block.  Returns NULL if a block of the requested size</span>
 <span class="s0">* cannot be allocated.</span>
 <span class="s0">*</span>
 <span class="s0">* To free the allocated block, call block-&gt;free(), or simply delete the block</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/ 2 4 this 3 3390  4 size 1 3209  </span>
<span class="s0">255 0 0 7 328 3391 1888 0 103 /**</span>
 <span class="s0">* Returns a pointer to the first allocated block, or NULL if there are no</span>
 <span class="s0">* allocated blocks.</span>
 <span class="s0">*/ 1 4 this 3 3388  </span>
<span class="s0">256 0 0 6 329 3392 0 0 61 /**</span>
 <span class="s0">* Returns a pointer to the book that owns this page.</span>
 <span class="s0">*/ 1 4 this 3 3388  </span>
<span class="s0">257 0 0 6 330 3370 0 0 119 /**</span>
 <span class="s0">* Returns a pointer to the global LRU object that manages the</span>
 <span class="s0">* VertexDataPage's with the indicated RamClass.</span>
 <span class="s0">*/ 1 6 rclass 1 3202  </span>
<span class="s0">258 0 0 6 331 3370 0 0 133 /**</span>
 <span class="s0">* Returns a pointer to the global LRU object that manages the</span>
 <span class="s0">* VertexDataPage's that are pending processing by the thread.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">259 0 0 6 332 3203 0 0 121 /**</span>
 <span class="s0">* Returns the global VertexDataSaveFile that will be used to save vertex data</span>
 <span class="s0">* buffers to disk when necessary.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">260 0 0 6 335 3178 0 0 205 /**</span>
 <span class="s0">* Writes the page to disk, but does not evict it from memory or affect its</span>
 <span class="s0">* LRU status.  If it gets evicted later without having been modified, it will</span>
 <span class="s0">* not need to write itself to disk again.</span>
 <span class="s0">*/ 1 4 this 3 3390  </span>
<span class="s0">261 0 0 6 336 3177 0 0 285 /**</span>
 <span class="s0">* Returns the number of threads that have been spawned to service vertex</span>
 <span class="s0">* paging requests, or 0 if no threads have been spawned (which may mean</span>
 <span class="s0">* either that all paging requests will be handled by the main thread, or</span>
 <span class="s0">* simply that no paging requests have yet been issued).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">262 0 0 6 337 3177 0 0 94 /**</span>
 <span class="s0">* Returns the number of read requests that are waiting to be serviced by a</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">263 0 0 6 338 3177 0 0 95 /**</span>
 <span class="s0">* Returns the number of write requests that are waiting to be serviced by a</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">264 0 0 4 339 3346 0 0 141 /**</span>
 <span class="s0">* Call this to stop the paging threads, if they were started.  This may block</span>
 <span class="s0">* until all of the pending tasks have been completed.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">265 0 0 4 340 3346 0 0 80 /**</span>
 <span class="s0">* Waits for all of the pending thread tasks to finish before returning.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">266 0 0 4 341 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3388  3 out 1 3347  </span>
<span class="s0">267 0 0 4 342 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3388  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">268 0 0 7 343 3362 0 0 0 0 </span>
<span class="s0">269 0 0 6 319 3380 0 0 0 1 4 this 3 3390  </span>
<span class="s0">270 0 0 6 321 3377 0 0 0 1 4 this 3 3390  </span>
<span class="s0">271 0 0 7 345 3392 1876 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 block_size 1 3209  </span>
<span class="s0">272 0 0 7 347 3391 1888 0 78 /**</span>
 <span class="s0">* Allocates and returns a new VertexDataBuffer of the requested size.</span>
 <span class="s0">*/ 2 4 this 3 3392  4 size 1 3209  </span>
<span class="s0">273 0 0 6 348 3209 0 0 60 /**</span>
 <span class="s0">* Returns the number of pages created for the book.</span>
 <span class="s0">*/ 1 4 this 3 3393  </span>
<span class="s0">274 0 0 6 349 3209 0 0 85 /**</span>
 <span class="s0">* Returns the total size of all bytes owned by all pages owned by this book.</span>
 <span class="s0">*/ 1 4 this 3 3393  </span>
<span class="s0">275 0 0 6 349 3209 0 0 122 /**</span>
 <span class="s0">* Returns the total size of all bytes owned by all pages owned by this book</span>
 <span class="s0">* that have the indicated ram class.</span>
 <span class="s0">*/ 2 4 this 3 3393  9 ram_class 1 3202  </span>
<span class="s0">276 0 0 6 350 3209 0 0 92 /**</span>
 <span class="s0">* Returns the total size of all bytes allocated within pages owned by this</span>
 <span class="s0">* book.</span>
 <span class="s0">*/ 1 4 this 3 3393  </span>
<span class="s0">277 0 0 6 350 3209 0 0 126 /**</span>
 <span class="s0">* Returns the total size of all bytes allocated within pages owned by this</span>
 <span class="s0">* book that have the indicated ram class.</span>
 <span class="s0">*/ 2 4 this 3 3393  9 ram_class 1 3202  </span>
<span class="s0">278 0 0 4 351 3346 0 0 223 /**</span>
 <span class="s0">* Writes all pages to disk immediately, just in case they get evicted later.</span>
 <span class="s0">* It makes sense to make this call just before taking down a loading screen,</span>
 <span class="s0">* to minimize chugs from saving pages inadvertently later.</span>
 <span class="s0">*/ 1 4 this 3 3392  </span>
<span class="s0">279 0 0 6 358 3390 0 0 65 /**</span>
 <span class="s0">* Returns the page from which this buffer was allocated.</span>
 <span class="s0">*/ 1 4 this 3 3395  </span>
<span class="s0">280 0 0 7 359 3391 1888 0 120 /**</span>
 <span class="s0">* Returns a pointer to the next allocated block in the chain, or NULL if</span>
 <span class="s0">* there are no more allocated blocks.</span>
 <span class="s0">*/ 1 4 this 3 3395  </span>
<span class="s0">281 0 0 6 353 3381 0 0 0 1 4 this 3 3391  </span>
<span class="s0">282 0 0 7 356 3397 0 0 0 1 4 this 3 3391  </span>
<span class="s0">283 0 0 15 369 3213 1897 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3365  </span>
<span class="s0">284 0 0 7 369 3213 1897 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 12 array_format 1 3191  10 usage_hint 1 3169  </span>
<span class="s0">285 0 0 7 370 3213 1897 0 0 2 4 this 3 3213  4 copy 1 3365  </span>
<span class="s0">286 0 0 4 372 3346 0 0 0 2 4 this 3 3213  4 size 1 3209  </span>
<span class="s0">287 0 0 6 375 3177 0 0 96 /**</span>
 <span class="s0">* Returns 0 if the two arrays are equivalent, even if they are not the same</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/ 2 4 this 3 3365  5 other 1 3365  </span>
<span class="s0">288 0 0 7 376 3191 0 0 63 /**</span>
 <span class="s0">* Returns the format object that describes this array.</span>
 <span class="s0">*/ 1 4 this 3 3365  </span>
<span class="s0">289 0 0 6 378 3169 0 0 154 /**</span>
 <span class="s0">* Returns the usage hint that describes to the rendering backend how often</span>
 <span class="s0">* the vertex data will be modified and/or rendered.  See geomEnums.h.</span>
 <span class="s0">*/ 1 4 this 3 3365  </span>
<span class="s0">290 0 0 4 379 3346 0 0 228 /**</span>
 <span class="s0">* Changes the UsageHint hint for this array.  See get_usage_hint().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3213  10 usage_hint 1 3169  </span>
<span class="s0">291 0 0 6 381 3178 0 0 153 /**</span>
 <span class="s0">* Returns true if the array has the named column, false otherwise.  This is</span>
 <span class="s0">* really just a shortcut for asking the same thing from the format.</span>
 <span class="s0">*/ 2 4 this 3 3365  4 name 1 3193  </span>
<span class="s0">292 0 0 6 382 3177 0 0 187 /**</span>
 <span class="s0">* Returns the number of rows stored in the array, based on the number of</span>
 <span class="s0">* bytes and the stride.  This should be the same for all arrays within a</span>
 <span class="s0">* given GeomVertexData object.</span>
 <span class="s0">*/ 1 4 this 3 3365  </span>
<span class="s0">293 0 0 6 383 3178 0 0 659 /**</span>
 <span class="s0">* Sets the length of the array to n rows.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, you would not call this directly, since all of the arrays in a</span>
 <span class="s0">* particular GeomVertexData must have the same number of rows; instead, call</span>
 <span class="s0">* GeomVertexData::set_num_rows().</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the number of rows was changed, false if the</span>
 <span class="s0">* object already contained n rows (or if there was some error).</span>
 <span class="s0">*</span>
 <span class="s0">* The new vertex data is initialized to 0, including the &quot;color&quot; column (but</span>
 <span class="s0">* see GeomVertexData::set_num_rows()).</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3213  1 n 1 3177  </span>
<span class="s0">294 0 0 6 384 3178 0 0 423 /**</span>
 <span class="s0">* This method behaves like set_num_rows(), except the new data is not</span>
 <span class="s0">* initialized.  Furthermore, after this call, *any* of the data in the</span>
 <span class="s0">* GeomVertexArrayData may be uninitialized, including the earlier rows.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, you would not call this directly, since all of the arrays in a</span>
 <span class="s0">* particular GeomVertexData must have the same number of rows; instead, call</span>
 <span class="s0">* GeomVertexData::unclean_set_num_rows().</span>
 <span class="s0">*/ 2 4 this 3 3213  1 n 1 3177  </span>
<span class="s0">295 0 0 6 385 3178 0 0 313 /**</span>
 <span class="s0">* This ensures that enough memory space for n rows is allocated, so that you</span>
 <span class="s0">* may increase the number of rows to n without causing a new memory</span>
 <span class="s0">* allocation.  This is a performance optimization only; it is especially</span>
 <span class="s0">* useful when you know ahead of time that you will be adding n rows to the</span>
 <span class="s0">* data.</span>
 <span class="s0">*/ 2 4 this 3 3213  1 n 1 3177  </span>
<span class="s0">296 0 0 4 386 3346 0 0 96 /**</span>
 <span class="s0">* Removes all of the rows in the array.  Functionally equivalent to</span>
 <span class="s0">* set_num_rows(0).</span>
 <span class="s0">*/ 1 4 this 3 3213  </span>
<span class="s0">297 0 0 6 387 3209 0 0 59 /**</span>
 <span class="s0">* Returns the number of bytes stored in the array.</span>
 <span class="s0">*/ 1 4 this 3 3365  </span>
<span class="s0">298 0 0 7 388 3398 0 0 124 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the array vertex data is modified.</span>
 <span class="s0">*/ 1 4 this 3 3365  </span>
<span class="s0">299 0 0 4 394 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3365  3 out 1 3347  </span>
<span class="s0">300 0 0 4 395 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3365  3 out 1 3347  12 indent_level 5 3177  </span>
<span class="s0">301 0 0 6 396 3178 0 0 281 /**</span>
 <span class="s0">* Returns true if the vertex data is currently resident in memory.  If this</span>
 <span class="s0">* returns true, the next call to get_handle()-&gt;get_read_pointer() will</span>
 <span class="s0">* probably not block.  If this returns false, the vertex data will be brought</span>
 <span class="s0">* back into memory shortly; try again later.</span>
 <span class="s0">*/ 2 4 this 3 3365  14 current_thread 5 3399  </span>
<span class="s0">302 0 0 7 397 3402 0 0 250 /**</span>
 <span class="s0">* Returns an object that can be used to read the actual data bytes stored in</span>
 <span class="s0">* the array.  Calling this method locks the data, and will block any other</span>
 <span class="s0">* threads attempting to read or write the data, until the returned object</span>
 <span class="s0">* destructs.</span>
 <span class="s0">*/ 2 4 this 3 3365  14 current_thread 5 3399  </span>
<span class="s0">303 0 0 7 398 3403 1934 0 259 /**</span>
 <span class="s0">* Returns an object that can be used to read or write the actual data bytes</span>
 <span class="s0">* stored in the array.  Calling this method locks the data, and will block</span>
 <span class="s0">* any other threads attempting to read or write the data, until the returned</span>
 <span class="s0">* object destructs.</span>
 <span class="s0">*/ 2 4 this 3 3213  14 current_thread 5 3399  </span>
<span class="s0">304 0 0 4 399 3346 0 0 344 /**</span>
 <span class="s0">* Indicates that the data should be enqueued to be prepared in the indicated</span>
 <span class="s0">* prepared_objects at the beginning of the next frame.  This will ensure the</span>
 <span class="s0">* data is already loaded into the GSG if it is expected to be rendered soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload datas from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/ 2 4 this 3 3213  16 prepared_objects 1 3404  </span>
<span class="s0">305 0 0 6 400 3178 0 0 131 /**</span>
 <span class="s0">* Returns true if the data has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3365  16 prepared_objects 1 3404  </span>
<span class="s0">306 0 0 6 401 3407 0 0 527 /**</span>
 <span class="s0">* Creates a context for the data on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) VertexBufferContext.  This assumes</span>
 <span class="s0">* that the GraphicsStateGuardian is the currently active rendering context</span>
 <span class="s0">* and that it is ready to accept new datas.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a data does not need to be explicitly prepared by the user before it may be</span>
 <span class="s0">* rendered.</span>
 <span class="s0">*/ 3 4 this 3 3213  16 prepared_objects 1 3404  3 gsg 1 3405  </span>
<span class="s0">307 0 0 6 402 3178 0 0 154 /**</span>
 <span class="s0">* Frees the data context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/ 2 4 this 3 3213  16 prepared_objects 1 3404  </span>
<span class="s0">308 0 0 6 403 3177 0 0 149 /**</span>
 <span class="s0">* Frees the context allocated on all objects for which the data has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/ 1 4 this 3 3213  </span>
<span class="s0">309 0 0 6 404 3370 0 0 131 /**</span>
 <span class="s0">* Returns a pointer to the global LRU object that manages the</span>
 <span class="s0">* GeomVertexArrayData's that have not (yet) been paged out.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">310 0 0 6 405 3370 0 0 138 /**</span>
 <span class="s0">* Returns a pointer to the global LRU object that manages the</span>
 <span class="s0">* GeomVertexArrayData's that are deemed too small to be paged out.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">311 0 0 4 406 3346 0 0 124 /**</span>
 <span class="s0">* Marks that an epoch has passed in each LRU.  Asks the LRU's to consider</span>
 <span class="s0">* whether they should perform evictions.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">312 0 0 6 407 3392 0 0 98 /**</span>
 <span class="s0">* Returns the global VertexDataBook that will be used to allocate vertex data</span>
 <span class="s0">* buffers.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">313 0 0 38 408 3177 0 0 0 3 4 this 3 3213  4 view 1 3408  5 flags 1 3177  </span>
<span class="s0">314 0 0 38 408 3177 0 0 0 3 4 this 3 3365  4 view 1 3408  5 flags 1 3177  </span>
<span class="s0">315 0 0 36 409 3346 0 0 0 2 4 this 3 3365  4 view 1 3408  </span>
<span class="s0">316 0 0 7 410 3362 0 0 0 0 </span>
<span class="s0">317 0 0 7 363 3411 0 0 0 1 4 this 3 3213  </span>
<span class="s0">318 0 0 6 365 3377 0 0 0 1 4 this 3 3213  </span>
<span class="s0">319 0 0 6 367 3353 0 0 0 1 4 this 3 3213  </span>
<span class="s0">320 0 0 7 417 3213 1897 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3403  </span>
<span class="s0">321 0 0 7 417 3365 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">322 0 0 7 420 3191 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">323 0 0 6 421 3169 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">324 0 0 6 424 3177 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">325 0 0 6 425 3178 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3403  1 n 1 3177  </span>
<span class="s0">326 0 0 6 426 3178 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3403  1 n 1 3177  </span>
<span class="s0">327 0 0 6 427 3178 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3403  1 n 1 3177  </span>
<span class="s0">328 0 0 4 428 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3403  </span>
<span class="s0">329 0 0 6 429 3209 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">330 0 0 7 430 3398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">331 0 0 6 433 3178 0 0 281 /**</span>
 <span class="s0">* Returns true if the vertex data is currently resident in memory.  If this</span>
 <span class="s0">* returns true, the next call to get_handle()-&gt;get_read_pointer() will</span>
 <span class="s0">* probably not block.  If this returns false, the vertex data will be brought</span>
 <span class="s0">* back into memory shortly; try again later.</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">332 0 0 6 434 3407 0 0 527 /**</span>
 <span class="s0">* Creates a context for the data on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) VertexBufferContext.  This assumes</span>
 <span class="s0">* that the GraphicsStateGuardian is the currently active rendering context</span>
 <span class="s0">* and that it is ready to accept new datas.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a data does not need to be explicitly prepared by the user before it may be</span>
 <span class="s0">* rendered.</span>
 <span class="s0">*/ 3 4 this 3 3402  16 prepared_objects 1 3404  3 gsg 1 3405  </span>
<span class="s0">333 0 0 4 435 3346 0 0 62 /**</span>
 <span class="s0">* Copies the entire data array from the other object.</span>
 <span class="s0">*/ 2 4 this 3 3403  5 other 1 3402  </span>
<span class="s0">334 0 0 36 435 3346 0 0 0 2 4 this 3 3403  6 buffer 1 3358  </span>
<span class="s0">335 0 0 4 436 3346 0 0 201 /**</span>
 <span class="s0">* Copies a portion of the data array from the other object into a portion of</span>
 <span class="s0">* the data array of this object.  If to_size != from_size, the size of this</span>
 <span class="s0">* data array is adjusted accordingly.</span>
 <span class="s0">*/ 6 4 this 3 3403  8 to_start 1 3209  7 to_size 1 3209  5 other 1 3402  10 from_start 1 3209  9 from_size 1 3209  </span>
<span class="s0">336 0 0 36 436 3346 0 0 0 4 4 this 3 3403  8 to_start 1 3209  7 to_size 1 3209  6 buffer 1 3358  </span>
<span class="s0">337 0 0 36 436 3346 0 0 0 6 4 this 3 3403  8 to_start 1 3209  7 to_size 1 3209  6 buffer 1 3358  10 from_start 1 3209  9 from_size 1 3209  </span>
<span class="s0">338 0 0 6 437 3412 0 0 177 /**</span>
 <span class="s0">* Returns the entire raw data of the GeomVertexArrayData object, formatted as</span>
 <span class="s0">* a string.  This is primarily for the benefit of high-level languages such</span>
 <span class="s0">* as Python.</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">339 0 0 4 438 3346 0 0 166 /**</span>
 <span class="s0">* Replaces the entire raw data array with the contents of the indicated</span>
 <span class="s0">* string.  This is primarily for the benefit of high-level languages like</span>
 <span class="s0">* Python.</span>
 <span class="s0">*/ 2 4 this 3 3403  4 data 1 3412  </span>
<span class="s0">340 0 0 6 439 3412 0 0 182 /**</span>
 <span class="s0">* Returns a subset of the raw data of the GeomVertexArrayData object,</span>
 <span class="s0">* formatted as a string.  This is primarily for the benefit of high-level</span>
 <span class="s0">* languages such as Python.</span>
 <span class="s0">*/ 3 4 this 3 3402  5 start 1 3209  4 size 1 3209  </span>
<span class="s0">341 0 0 4 440 3346 0 0 232 /**</span>
 <span class="s0">* Replaces a portion of the data array from the indicated string.  If size !=</span>
 <span class="s0">* data.size(), the size of this data array is adjusted accordingly.</span>
 <span class="s0">*</span>
 <span class="s0">* This is primarily for the benefit of high-level languages like Python.</span>
 <span class="s0">*/ 4 4 this 3 3403  5 start 1 3209  4 size 1 3209  4 data 1 3412  </span>
<span class="s0">342 0 0 4 441 3346 0 0 46 /**</span>
 <span class="s0">* Marks the array data recently-used.</span>
 <span class="s0">*/ 1 4 this 3 3402  </span>
<span class="s0">343 0 0 7 442 3362 0 0 0 0 </span>
<span class="s0">344 0 0 7 412 3397 0 0 0 1 4 this 3 3403  </span>
<span class="s0">345 0 0 6 414 3353 0 0 0 1 4 this 3 3403  </span>
<span class="s0">346 0 0 4 444 3346 0 0 482 /**</span>
 <span class="s0">* Specifies the maximum number of entries in the cache for storing pre-</span>
 <span class="s0">* processed data for rendering vertices.  This limit is flexible, and may be</span>
 <span class="s0">* temporarily exceeded if many different Geoms are pre-processed during the</span>
 <span class="s0">* space of a single frame.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not a limit on the actual vertex data, which is what it is; it is</span>
 <span class="s0">* also not a limit on the amount of memory used by the video driver or the</span>
 <span class="s0">* system graphics interface, which Panda has no control over.</span>
 <span class="s0">*/ 2 4 this 3 3414  8 max_size 1 3177  </span>
<span class="s0">347 0 0 6 445 3177 0 0 141 /**</span>
 <span class="s0">* Returns the maximum number of entries in the cache for storing pre-</span>
 <span class="s0">* processed data for rendering vertices.  See set_max_size().</span>
 <span class="s0">*/ 1 4 this 3 3414  </span>
<span class="s0">348 0 0 6 446 3177 0 0 64 /**</span>
 <span class="s0">* Returns the number of entries currently in the cache.</span>
 <span class="s0">*/ 1 4 this 3 3414  </span>
<span class="s0">349 0 0 4 447 3346 0 0 57 /**</span>
 <span class="s0">* Immediately empties all elements in the cache.</span>
 <span class="s0">*/ 1 4 this 3 3416  </span>
<span class="s0">350 0 0 6 448 3416 0 0 52 /**</span>
 <span class="s0">* Returns the global cache manager pointer.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">351 0 0 4 450 3346 0 0 0 2 4 this 3 3217  6 matrix 1 3417  </span>
<span class="s0">352 0 0 4 451 3346 0 0 277 /**</span>
 <span class="s0">* Premultiplies this transform's matrix with the indicated previous matrix,</span>
 <span class="s0">* so that the result is the net composition of the given transform with this</span>
 <span class="s0">* transform.  The result is stored in the parameter &quot;result&quot;, which should</span>
 <span class="s0">* not be the same matrix as previous.</span>
 <span class="s0">*/ 3 4 this 3 3217  6 result 1 3417  8 previous 1 3418  </span>
<span class="s0">353 0 0 4 452 3346 0 0 200 /**</span>
 <span class="s0">* Adds the value of this transform's matrix, modified by the indicated</span>
 <span class="s0">* weight, into the indicated accumulation matrix.  This is used to compute</span>
 <span class="s0">* the result of several blended transforms.</span>
 <span class="s0">*/ 3 4 this 3 3217  5 accum 1 3417  6 weight 1 3220  </span>
<span class="s0">354 0 0 7 453 3398 0 0 131 /**</span>
 <span class="s0">* Returns a sequence number that's guaranteed to change at least every time</span>
 <span class="s0">* the value reported by get_matrix() changes.</span>
 <span class="s0">*/ 2 4 this 3 3217  14 current_thread 5 3399  </span>
<span class="s0">355 0 0 4 455 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3217  3 out 1 3347  </span>
<span class="s0">356 0 0 4 456 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3217  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">357 0 0 7 457 3398 0 0 417 /**</span>
 <span class="s0">* Returns a monotonically increasing sequence.  Each time this is called, a</span>
 <span class="s0">* new sequence number is returned, higher than the previous value.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used to ensure that all VertexTransform::get_modified() calls</span>
 <span class="s0">* return an increasing number in the same space, so that</span>
 <span class="s0">* TransformBlend::get_modified() is easy to determine.  It is similar to</span>
 <span class="s0">* Geom::get_modified(), but it is in a different space.</span>
 <span class="s0">*/ 1 14 current_thread 1 3399  </span>
<span class="s0">358 0 0 7 458 3398 0 0 197 /**</span>
 <span class="s0">* Returns the currently highest VertexTransform::get_modified() value in the</span>
 <span class="s0">* world.  This can be used as a quick way to determine if any</span>
 <span class="s0">* VertexTransforms have changed value recently.</span>
 <span class="s0">*/ 1 14 current_thread 1 3399  </span>
<span class="s0">359 0 0 7 459 3362 0 0 0 0 </span>
<span class="s0">360 0 0 7 461 3419 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">361 0 0 15 461 3419 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3232  </span>
<span class="s0">362 0 0 7 462 3419 0 0 0 2 4 this 3 3419  4 copy 1 3232  </span>
<span class="s0">363 0 0 6 463 3178 0 0 228 /**</span>
 <span class="s0">* Returns true if this table has been registered.  Once it has been</span>
 <span class="s0">* registered, the set of transforms in a TransformTable may not be further</span>
 <span class="s0">* modified; but it must be registered before it can be assigned to a Geom.</span>
 <span class="s0">*/ 1 4 this 3 3232  </span>
<span class="s0">364 0 0 7 464 3232 0 0 551 /**</span>
 <span class="s0">* Registers a TransformTable for use.  This is similar to</span>
 <span class="s0">* GeomVertexFormat::register_format().  Once registered, a TransformTable may</span>
 <span class="s0">* no longer be modified (although the individual VertexTransform objects may</span>
 <span class="s0">* modify their reported transforms).</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called before a table may be used in a Geom.  After this call,</span>
 <span class="s0">* you should discard the original pointer you passed in (which may or may not</span>
 <span class="s0">* now be invalid) and let its reference count decrement normally; you should</span>
 <span class="s0">* use only the returned value from this point on.</span>
 <span class="s0">*/ 1 5 table 1 3232  </span>
<span class="s0">365 0 0 6 465 3209 0 0 57 /**</span>
 <span class="s0">* Returns the number of transforms in the table.</span>
 <span class="s0">*/ 1 4 this 3 3232  </span>
<span class="s0">366 0 0 7 466 3217 0 0 50 /**</span>
 <span class="s0">* Returns the nth transform in the table.</span>
 <span class="s0">*/ 2 4 this 3 3232  1 n 1 3209  </span>
<span class="s0">367 0 0 7 468 3398 0 0 276 /**</span>
 <span class="s0">* Returns a sequence number that's guaranteed to change at least when any</span>
 <span class="s0">* VertexTransforms in the table change.  (However, this is only true for a</span>
 <span class="s0">* registered table.  An unregistered table may or may not reflect an update</span>
 <span class="s0">* here when a VertexTransform changes.)</span>
 <span class="s0">*/ 2 4 this 3 3232  14 current_thread 5 3399  </span>
<span class="s0">368 0 0 4 469 3346 0 0 75 /**</span>
 <span class="s0">* Replaces the nth transform.  Only valid for unregistered tables.</span>
 <span class="s0">*/ 3 4 this 3 3419  1 n 1 3209  9 transform 1 3217  </span>
<span class="s0">369 0 0 4 470 3346 0 0 321 /**</span>
 <span class="s0">* Inserts a new transform to the table at the given index position.  If the</span>
 <span class="s0">* index is beyond the end of the table, appends it to the end.  Only valid</span>
 <span class="s0">* for unregistered tables.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not automatically uniquify the pointer; if the transform is</span>
 <span class="s0">* already present in the table, it will be added twice.</span>
 <span class="s0">*/ 3 4 this 3 3419  1 n 1 3209  9 transform 1 3217  </span>
<span class="s0">370 0 0 4 471 3346 0 0 74 /**</span>
 <span class="s0">* Removes the nth transform.  Only valid for unregistered tables.</span>
 <span class="s0">*/ 2 4 this 3 3419  1 n 1 3209  </span>
<span class="s0">371 0 0 6 472 3209 0 0 268 /**</span>
 <span class="s0">* Adds a new transform to the table and returns the index number of the new</span>
 <span class="s0">* transform.  Only valid for unregistered tables.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not automatically uniquify the pointer; if the transform is</span>
 <span class="s0">* already present in the table, it will be added twice.</span>
 <span class="s0">*/ 2 4 this 3 3419  9 transform 1 3217  </span>
<span class="s0">372 0 0 4 473 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3232  3 out 1 3347  </span>
<span class="s0">373 0 0 7 479 3362 0 0 0 0 </span>
<span class="s0">374 0 0 7 481 3420 1984 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">375 0 0 15 481 3420 1984 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3421  </span>
<span class="s0">376 0 0 23 481 3420 1984 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 10 transform0 1 3217  7 weight0 1 3220  </span>
<span class="s0">377 0 0 23 481 3420 1984 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 10 transform0 1 3217  7 weight0 1 3220  10 transform1 1 3217  7 weight1 1 3220  </span>
<span class="s0">378 0 0 23 481 3420 1984 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 6 10 transform0 1 3217  7 weight0 1 3220  10 transform1 1 3217  7 weight1 1 3220  10 transform2 1 3217  7 weight2 1 3220  </span>
<span class="s0">379 0 0 23 481 3420 1984 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 8 10 transform0 1 3217  7 weight0 1 3220  10 transform1 1 3217  7 weight1 1 3220  10 transform2 1 3217  7 weight2 1 3220  10 transform3 1 3217  7 weight3 1 3220  </span>
<span class="s0">380 0 0 6 482 3420 0 0 0 2 4 this 3 3420  4 copy 1 3421  </span>
<span class="s0">381 0 0 6 484 3177 0 0 68 /**</span>
 <span class="s0">* Defines an arbitrary ordering for TransformBlend objects.</span>
 <span class="s0">*/ 2 4 this 3 3421  5 other 1 3421  </span>
<span class="s0">382 0 0 6 485 3178 0 0 0 2 4 this 3 3421  5 other 1 3421  </span>
<span class="s0">383 0 0 6 486 3178 0 0 0 2 4 this 3 3421  5 other 1 3421  </span>
<span class="s0">384 0 0 6 487 3178 0 0 0 2 4 this 3 3421  5 other 1 3421  </span>
<span class="s0">385 0 0 4 488 3346 0 0 112 /**</span>
 <span class="s0">* Adds a new transform to the blend.  If the transform already existed,</span>
 <span class="s0">* increases its weight factor.</span>
 <span class="s0">*/ 3 4 this 3 3420  9 transform 1 3217  6 weight 1 3220  </span>
<span class="s0">386 0 0 4 489 3346 0 0 58 /**</span>
 <span class="s0">* Removes the indicated transform from the blend.</span>
 <span class="s0">*/ 2 4 this 3 3420  9 transform 1 3217  </span>
<span class="s0">387 0 0 4 489 3346 0 0 64 /**</span>
 <span class="s0">* Removes the nth transform stored in the blend object.</span>
 <span class="s0">*/ 2 4 this 3 3420  1 n 1 3209  </span>
<span class="s0">388 0 0 4 490 3346 0 0 192 /**</span>
 <span class="s0">* If the total number of transforms in the blend exceeds max_transforms,</span>
 <span class="s0">* removes the n least-important transforms as needed to reduce the number of</span>
 <span class="s0">* transforms to max_transforms.</span>
 <span class="s0">*/ 2 4 this 3 3420  14 max_transforms 1 3177  </span>
<span class="s0">389 0 0 4 491 3346 0 0 189 /**</span>
 <span class="s0">* Rescales all of the weights on the various transforms so that they sum to</span>
 <span class="s0">* 1.0.  It is generally a good idea to call this after adding or removing</span>
 <span class="s0">* transforms from the blend.</span>
 <span class="s0">*/ 1 4 this 3 3420  </span>
<span class="s0">390 0 0 6 492 3178 0 0 82 /**</span>
 <span class="s0">* Returns true if the blend has the indicated transform, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3421  9 transform 1 3217  </span>
<span class="s0">391 0 0 6 493 3220 0 0 118 /**</span>
 <span class="s0">* Returns the weight associated with the indicated transform, or 0 if there</span>
 <span class="s0">* is no entry for the transform.</span>
 <span class="s0">*/ 2 4 this 3 3421  9 transform 1 3217  </span>
<span class="s0">392 0 0 6 493 3220 0 0 94 /**</span>
 <span class="s0">* Returns the weight associated with the nth transform stored in the blend</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 2 4 this 3 3421  1 n 1 3209  </span>
<span class="s0">393 0 0 6 494 3209 0 0 71 /**</span>
 <span class="s0">* Returns the number of transforms stored in the blend object.</span>
 <span class="s0">*/ 1 4 this 3 3421  </span>
<span class="s0">394 0 0 7 495 3217 0 0 64 /**</span>
 <span class="s0">* Returns the nth transform stored in the blend object.</span>
 <span class="s0">*/ 2 4 this 3 3421  1 n 1 3209  </span>
<span class="s0">395 0 0 4 497 3346 0 0 65 /**</span>
 <span class="s0">* Replaces the nth transform stored in the blend object.</span>
 <span class="s0">*/ 3 4 this 3 3420  1 n 1 3209  9 transform 1 3217  </span>
<span class="s0">396 0 0 4 498 3346 0 0 95 /**</span>
 <span class="s0">* Replaces the weight associated with the nth transform stored in the blend</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 3 4 this 3 3420  1 n 1 3209  6 weight 1 3220  </span>
<span class="s0">397 0 0 4 503 3346 0 0 156 /**</span>
 <span class="s0">* Recomputes the internal representation of the blend value, if necessary.</span>
 <span class="s0">* You should call this before calling get_blend() or transform_point().</span>
 <span class="s0">*/ 2 4 this 3 3421  14 current_thread 1 3399  </span>
<span class="s0">398 0 0 4 504 3346 0 0 249 /**</span>
 <span class="s0">* Returns the current value of the blend, based on the current value of all</span>
 <span class="s0">* of the nested transform objects and their associated weights.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/ 3 4 this 3 3421  6 result 1 3417  14 current_thread 1 3399  </span>
<span class="s0">399 0 0 4 505 3346 0 0 162 /**</span>
 <span class="s0">* Transforms the indicated point by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/ 3 4 this 3 3421  5 point 1 3422  14 current_thread 1 3399  </span>
<span class="s0">400 0 0 4 505 3346 0 0 0 3 4 this 3 3421  5 point 1 3424  14 current_thread 1 3399  </span>
<span class="s0">401 0 0 4 505 3346 0 0 162 /**</span>
 <span class="s0">* Transforms the indicated point by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/ 3 4 this 3 3421  5 point 1 3425  14 current_thread 1 3399  </span>
<span class="s0">402 0 0 4 505 3346 0 0 0 3 4 this 3 3421  5 point 1 3427  14 current_thread 1 3399  </span>
<span class="s0">403 0 0 4 506 3346 0 0 163 /**</span>
 <span class="s0">* Transforms the indicated vector by the blend matrix.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call update_blend() to ensure that the cache is up-to-date</span>
 <span class="s0">* before calling this.</span>
 <span class="s0">*/ 3 4 this 3 3421  5 point 1 3429  14 current_thread 1 3399  </span>
<span class="s0">404 0 0 4 506 3346 0 0 0 3 4 this 3 3421  5 point 1 3431  14 current_thread 1 3399  </span>
<span class="s0">405 0 0 7 507 3398 0 0 120 /**</span>
 <span class="s0">* Returns a counter which is guaranteed to increment at least as often as the</span>
 <span class="s0">* result of get_blend() changes.</span>
 <span class="s0">*/ 2 4 this 3 3421  14 current_thread 5 3399  </span>
<span class="s0">406 0 0 4 509 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3421  3 out 1 3347  </span>
<span class="s0">407 0 0 4 510 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3421  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">408 0 0 7 511 3362 0 0 0 0 </span>
<span class="s0">409 0 0 7 513 3433 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">410 0 0 15 513 3433 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3434  </span>
<span class="s0">411 0 0 7 514 3433 0 0 0 2 4 this 3 3433  4 copy 1 3434  </span>
<span class="s0">412 0 0 6 515 3209 0 0 81 /**</span>
 <span class="s0">* Returns the total number of different blend combinations in the table.</span>
 <span class="s0">*/ 1 4 this 3 3434  </span>
<span class="s0">413 0 0 6 516 3421 0 0 46 /**</span>
 <span class="s0">* Returns the nth blend in the table.</span>
 <span class="s0">*/ 2 4 this 3 3434  1 n 1 3209  </span>
<span class="s0">414 0 0 7 518 3398 0 0 129 /**</span>
 <span class="s0">* Returns a counter which is guaranteed to increment at least when any</span>
 <span class="s0">* TransformBlends within the table have changed.</span>
 <span class="s0">*/ 2 4 this 3 3434  14 current_thread 5 3399  </span>
<span class="s0">415 0 0 4 519 3346 0 0 75 /**</span>
 <span class="s0">* Replaces the blend at the nth position with the indicated value.</span>
 <span class="s0">*/ 3 4 this 3 3433  1 n 1 3209  5 blend 1 3421  </span>
<span class="s0">416 0 0 4 520 3346 0 0 49 /**</span>
 <span class="s0">* Removes the blend at the nth position.</span>
 <span class="s0">*/ 2 4 this 3 3433  1 n 1 3209  </span>
<span class="s0">417 0 0 6 521 3209 0 0 167 /**</span>
 <span class="s0">* Adds a new blend to the table, and returns its index number.  If there is</span>
 <span class="s0">* already an identical blend in the table, simply returns that number</span>
 <span class="s0">* instead.</span>
 <span class="s0">*/ 2 4 this 3 3433  5 blend 1 3421  </span>
<span class="s0">418 0 0 6 522 3177 0 0 299 /**</span>
 <span class="s0">* Returns the number of unique VertexTransform objects represented in the</span>
 <span class="s0">* table.  This will correspond to the size of the TransformTable object that</span>
 <span class="s0">* would represent the same table.  This is also the same limit reflected by</span>
 <span class="s0">* GraphicsStateGuardian::get_max_vertex_transform_indices().</span>
 <span class="s0">*/ 1 4 this 3 3434  </span>
<span class="s0">419 0 0 6 523 3177 0 0 217 /**</span>
 <span class="s0">* Returns the maximum number of unique VertexTransform objects that are</span>
 <span class="s0">* applied to any one vertex simultaneously.  This is the same limit reflected</span>
 <span class="s0">* by GraphicsStateGuardian::get_max_vertex_transforms().</span>
 <span class="s0">*/ 1 4 this 3 3434  </span>
<span class="s0">420 0 0 4 524 3346 0 0 134 /**</span>
 <span class="s0">* Specifies the subset of rows (vertices) in the associated GeomVertexData</span>
 <span class="s0">* that this TransformBlendTable actually affects.</span>
 <span class="s0">*/ 2 4 this 3 3433  4 rows 1 3436  </span>
<span class="s0">421 0 0 6 525 3436 0 0 132 /**</span>
 <span class="s0">* Returns the subset of rows (vertices) in the associated GeomVertexData that</span>
 <span class="s0">* this TransformBlendTable actually affects.</span>
 <span class="s0">*/ 1 4 this 3 3434  </span>
<span class="s0">422 0 0 6 526 3437 0 0 192 /**</span>
 <span class="s0">* Returns a modifiable reference to the SparseArray that specifies the subset</span>
 <span class="s0">* of rows (vertices) in the associated GeomVertexData that this</span>
 <span class="s0">* TransformBlendTable actually affects.</span>
 <span class="s0">*/ 1 4 this 3 3433  </span>
<span class="s0">423 0 0 4 527 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3434  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">424 0 0 7 536 3362 0 0 0 0 </span>
<span class="s0">425 0 0 7 538 3193 0 0 201 /**</span>
 <span class="s0">* Returns the name of this particular slider.  Every unique blend shape</span>
 <span class="s0">* within a particular Geom must be identified with a different name, which is</span>
 <span class="s0">* shared by the slider that controls it.</span>
 <span class="s0">*/ 1 4 this 3 3438  </span>
<span class="s0">426 0 0 6 540 3220 0 0 0 1 4 this 3 3438  </span>
<span class="s0">427 0 0 7 541 3398 0 0 131 /**</span>
 <span class="s0">* Returns a sequence number that's guaranteed to change at least every time</span>
 <span class="s0">* the value reported by get_slider() changes.</span>
 <span class="s0">*/ 2 4 this 3 3438  14 current_thread 5 3399  </span>
<span class="s0">428 0 0 4 544 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3438  3 out 1 3347  </span>
<span class="s0">429 0 0 4 545 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3438  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">430 0 0 7 546 3362 0 0 0 0 </span>
<span class="s0">431 0 0 7 548 3440 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">432 0 0 15 548 3440 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3234  </span>
<span class="s0">433 0 0 7 549 3440 0 0 0 2 4 this 3 3440  4 copy 1 3234  </span>
<span class="s0">434 0 0 6 550 3178 0 0 222 /**</span>
 <span class="s0">* Returns true if this table has been registered.  Once it has been</span>
 <span class="s0">* registered, the set of sliders in a SliderTable may not be further</span>
 <span class="s0">* modified; but it must be registered before it can be assigned to a Geom.</span>
 <span class="s0">*/ 1 4 this 3 3234  </span>
<span class="s0">435 0 0 7 551 3234 0 0 539 /**</span>
 <span class="s0">* Registers a SliderTable for use.  This is similar to</span>
 <span class="s0">* GeomVertexFormat::register_format().  Once registered, a SliderTable may no</span>
 <span class="s0">* longer be modified (although the individual VertexSlider objects may modify</span>
 <span class="s0">* their reported sliders).</span>
 <span class="s0">*</span>
 <span class="s0">* This must be called before a table may be used in a Geom.  After this call,</span>
 <span class="s0">* you should discard the original pointer you passed in (which may or may not</span>
 <span class="s0">* now be invalid) and let its reference count decrement normally; you should</span>
 <span class="s0">* use only the returned value from this point on.</span>
 <span class="s0">*/ 1 5 table 1 3234  </span>
<span class="s0">436 0 0 6 552 3209 0 0 54 /**</span>
 <span class="s0">* Returns the number of sliders in the table.</span>
 <span class="s0">*/ 1 4 this 3 3234  </span>
<span class="s0">437 0 0 7 553 3438 0 0 47 /**</span>
 <span class="s0">* Returns the nth slider in the table.</span>
 <span class="s0">*/ 2 4 this 3 3234  1 n 1 3209  </span>
<span class="s0">438 0 0 6 555 3436 0 0 86 /**</span>
 <span class="s0">* Returns the set of rows (vertices) governed by the nth slider in the table.</span>
 <span class="s0">*/ 2 4 this 3 3234  1 n 1 3209  </span>
<span class="s0">439 0 0 6 556 3436 0 0 174 /**</span>
 <span class="s0">* Returns a list of slider indices that represent the list of sliders with</span>
 <span class="s0">* the indicated name, or an empty SparseArray if no slider in the table has</span>
 <span class="s0">* that name.</span>
 <span class="s0">*/ 2 4 this 3 3234  4 name 1 3193  </span>
<span class="s0">440 0 0 6 557 3178 0 0 103 /**</span>
 <span class="s0">* Returns true if the table has at least one slider by the indicated name,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3234  4 name 1 3193  </span>
<span class="s0">441 0 0 6 558 3178 0 0 82 /**</span>
 <span class="s0">* Returns true if the table has no sliders, false if it has at least one.</span>
 <span class="s0">*/ 1 4 this 3 3234  </span>
<span class="s0">442 0 0 7 559 3398 0 0 270 /**</span>
 <span class="s0">* Returns a sequence number that's guaranteed to change at least when any</span>
 <span class="s0">* VertexSliders in the table change.  (However, this is only true for a</span>
 <span class="s0">* registered table.  An unregistered table may or may not reflect an update</span>
 <span class="s0">* here when a VertexSlider changes.)</span>
 <span class="s0">*/ 2 4 this 3 3234  14 current_thread 5 3399  </span>
<span class="s0">443 0 0 4 561 3346 0 0 72 /**</span>
 <span class="s0">* Replaces the nth slider.  Only valid for unregistered tables.</span>
 <span class="s0">*/ 3 4 this 3 3440  1 n 1 3209  6 slider 1 3438  </span>
<span class="s0">444 0 0 4 562 3346 0 0 96 /**</span>
 <span class="s0">* Replaces the rows affected by the nth slider.  Only valid for unregistered</span>
 <span class="s0">* tables.</span>
 <span class="s0">*/ 3 4 this 3 3440  1 n 1 3209  4 rows 1 3436  </span>
<span class="s0">445 0 0 4 563 3346 0 0 71 /**</span>
 <span class="s0">* Removes the nth slider.  Only valid for unregistered tables.</span>
 <span class="s0">*/ 2 4 this 3 3440  1 n 1 3209  </span>
<span class="s0">446 0 0 6 564 3209 0 0 130 /**</span>
 <span class="s0">* Adds a new slider to the table, and returns the index number of the new</span>
 <span class="s0">* slider.  Only valid for unregistered tables.</span>
 <span class="s0">*/ 3 4 this 3 3440  6 slider 1 3438  4 rows 1 3436  </span>
<span class="s0">447 0 0 4 565 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3234  3 out 1 3347  </span>
<span class="s0">448 0 0 7 566 3362 0 0 0 0 </span>
<span class="s0">449 0 0 15 572 3441 2051 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3368  </span>
<span class="s0">450 0 0 7 572 3441 2051 0 216 /**</span>
 <span class="s0">* This constructor copies all of the basic properties of the source</span>
 <span class="s0">* VertexData, like usage_hint and animation tables, but does not copy the</span>
 <span class="s0">* actual data, and it allows you to specify a different format.</span>
 <span class="s0">*/ 2 4 copy 1 3368  6 format 1 3229  </span>
<span class="s0">451 0 0 7 572 3441 2051 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 name 1 3342  6 format 1 3229  10 usage_hint 1 3169  </span>
<span class="s0">452 0 0 7 573 3441 2051 0 0 2 4 this 3 3441  4 copy 1 3368  </span>
<span class="s0">453 0 0 4 575 3346 0 0 0 2 4 this 3 3441  4 size 1 3209  </span>
<span class="s0">454 0 0 6 578 3177 0 0 97 /**</span>
 <span class="s0">* Returns 0 if the two objects are equivalent, even if they are not the same</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/ 2 4 this 3 3368  5 other 1 3368  </span>
<span class="s0">455 0 0 6 579 3342 0 0 133 /**</span>
 <span class="s0">* Returns the name passed to the constructor, if any.  This name is reported</span>
 <span class="s0">* on the PStats graph for vertex computations.</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">456 0 0 4 580 3346 0 0 118 /**</span>
 <span class="s0">* Changes the name of the vertex data.  This name is reported on the PStats</span>
 <span class="s0">* graph for vertex computations.</span>
 <span class="s0">*/ 2 4 this 3 3441  4 name 1 3342  </span>
<span class="s0">457 0 0 6 582 3169 0 0 438 /**</span>
 <span class="s0">* Returns the usage hint that was passed to the constructor, and which will</span>
 <span class="s0">* be passed to each array data object created initially, and arrays created</span>
 <span class="s0">* as the result of a convert_to() operation.  See geomEnums.h.</span>
 <span class="s0">*</span>
 <span class="s0">* However, each individual array may be replaced with a different array</span>
 <span class="s0">* object with an independent usage hint specified, so there is no guarantee</span>
 <span class="s0">* that the individual arrays all have the same usage_hint.</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">458 0 0 4 583 3346 0 0 285 /**</span>
 <span class="s0">* Changes the UsageHint hint for this vertex data, and for all of the arrays</span>
 <span class="s0">* that share this data.  See get_usage_hint().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3441  10 usage_hint 1 3169  </span>
<span class="s0">459 0 0 7 585 3229 0 0 86 /**</span>
 <span class="s0">* Returns a pointer to the GeomVertexFormat structure that defines this data.</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">460 0 0 4 586 3346 0 0 294 /**</span>
 <span class="s0">* Changes the format of the vertex data.  If the data is not empty, this will</span>
 <span class="s0">* implicitly change every row to match the new format.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3441  6 format 1 3229  </span>
<span class="s0">461 0 0 4 587 3346 0 0 440 /**</span>
 <span class="s0">* Changes the format of the vertex data, without reformatting the data to</span>
 <span class="s0">* match.  The data is exactly the same after this operation, but will be</span>
 <span class="s0">* reinterpreted according to the new format.  This assumes that the new</span>
 <span class="s0">* format is fundamentally compatible with the old format; in particular, it</span>
 <span class="s0">* must have the same number of arrays with the same stride in each one.  No</span>
 <span class="s0">* checking is performed that the data remains sensible.</span>
 <span class="s0">*/ 2 4 this 3 3441  6 format 1 3229  </span>
<span class="s0">462 0 0 6 591 3178 0 0 152 /**</span>
 <span class="s0">* Returns true if the data has the named column, false otherwise.  This is</span>
 <span class="s0">* really just a shortcut for asking the same thing from the format.</span>
 <span class="s0">*/ 2 4 this 3 3368  4 name 1 3193  </span>
<span class="s0">463 0 0 6 592 3177 0 0 114 /**</span>
 <span class="s0">* Returns the number of rows stored within all the arrays.  All arrays store</span>
 <span class="s0">* data for the same n rows.</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">464 0 0 6 593 3178 0 0 736 /**</span>
 <span class="s0">* Sets the length of the array to n rows in all of the various arrays</span>
 <span class="s0">* (presumably by adding rows).</span>
 <span class="s0">*</span>
 <span class="s0">* The new vertex data is initialized to 0, except for the &quot;color&quot; column,</span>
 <span class="s0">* which is initialized to (1, 1, 1, 1).</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the number of rows was changed, false if the</span>
 <span class="s0">* object already contained n rows (or if there was some error).</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used when you know exactly how many rows you will be needing.</span>
 <span class="s0">* It is faster than reserve_num_rows().  Also see unclean_set_num_rows() if</span>
 <span class="s0">* you are planning to fill in all the data yourself.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3441  1 n 1 3177  </span>
<span class="s0">465 0 0 6 594 3178 0 0 518 /**</span>
 <span class="s0">* This method behaves like set_num_rows(), except the new data is not</span>
 <span class="s0">* initialized.  Furthermore, after this call, *any* of the data in the</span>
 <span class="s0">* GeomVertexData may be uninitialized, including the earlier rows.</span>
 <span class="s0">*</span>
 <span class="s0">* This is intended for applications that are about to completely fill the</span>
 <span class="s0">* GeomVertexData with new data anyway; it provides a tiny performance boost</span>
 <span class="s0">* over set_num_rows().</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used when you know exactly how many rows you will be needing.</span>
 <span class="s0">* It is faster than reserve_num_rows().</span>
 <span class="s0">*/ 2 4 this 3 3441  1 n 1 3177  </span>
<span class="s0">466 0 0 6 595 3178 0 0 461 /**</span>
 <span class="s0">* This ensures that enough memory space for n rows is allocated, so that you</span>
 <span class="s0">* may increase the number of rows to n without causing a new memory</span>
 <span class="s0">* allocation.  This is a performance optimization only; it is especially</span>
 <span class="s0">* useful when you know ahead of time that you will be adding n rows to the</span>
 <span class="s0">* data.</span>
 <span class="s0">*</span>
 <span class="s0">* If you know exactly how many rows you will be needing, it is significantly</span>
 <span class="s0">* faster to use set_num_rows() or unclean_set_num_rows() instead.</span>
 <span class="s0">*/ 2 4 this 3 3441  1 n 1 3177  </span>
<span class="s0">467 0 0 4 596 3346 0 0 263 /**</span>
 <span class="s0">* Removes all of the rows from the arrays; functionally equivalent to</span>
 <span class="s0">* set_num_rows(0) (but faster).</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3441  </span>
<span class="s0">468 0 0 6 597 3209 0 0 126 /**</span>
 <span class="s0">* Returns the number of individual arrays stored within the data.  This must</span>
 <span class="s0">* match get_format()-&gt;get_num_arrays().</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">469 0 0 7 598 3365 0 0 170 /**</span>
 <span class="s0">* Returns a const pointer to the vertex data for the indicated array, for</span>
 <span class="s0">* application code to directly examine (but not modify) the underlying vertex</span>
 <span class="s0">* data.</span>
 <span class="s0">*/ 2 4 this 3 3368  1 i 1 3209  </span>
<span class="s0">470 0 0 7 599 3402 0 0 51 /**</span>
 <span class="s0">* Equivalent to get_array(i).get_handle().</span>
 <span class="s0">*/ 2 4 this 3 3368  1 i 1 3209  </span>
<span class="s0">471 0 0 7 601 3213 1897 0 419 /**</span>
 <span class="s0">* Returns a modifiable pointer to the indicated vertex array, so that</span>
 <span class="s0">* application code may directly manipulate the data.  You should avoid</span>
 <span class="s0">* changing the length of this array, since all of the arrays should be kept</span>
 <span class="s0">* in sync--use set_num_rows() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3441  1 i 1 3209  </span>
<span class="s0">472 0 0 7 602 3403 1934 0 57 /**</span>
 <span class="s0">* Equivalent to modify_array(i).modify_handle().</span>
 <span class="s0">*/ 2 4 this 3 3441  1 i 1 3209  </span>
<span class="s0">473 0 0 4 603 3346 0 0 363 /**</span>
 <span class="s0">* Replaces the indicated vertex data array with a completely new array.  You</span>
 <span class="s0">* should be careful that the new array has the same length and format as the</span>
 <span class="s0">* old one, unless you know what you are doing.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 3 4 this 3 3441  1 i 1 3209  5 array 1 3365  </span>
<span class="s0">474 0 0 7 606 3232 0 0 494 /**</span>
 <span class="s0">* Returns a const pointer to the TransformTable assigned to this data.</span>
 <span class="s0">* Vertices within the table will index into this table to indicate their</span>
 <span class="s0">* dynamic skinning information; this table is used when the vertex animation</span>
 <span class="s0">* is to be performed by the graphics hardware (but also see</span>
 <span class="s0">* get_transform_blend_table()).</span>
 <span class="s0">*</span>
 <span class="s0">* This will return NULL if the vertex data does not have a TransformTable</span>
 <span class="s0">* assigned (which implies the vertices will not be animated by the graphics</span>
 <span class="s0">* hardware).</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">475 0 0 4 607 3346 0 0 376 /**</span>
 <span class="s0">* Replaces the TransformTable on this vertex data with the indicated table.</span>
 <span class="s0">* The length of this table should be consistent with the maximum table index</span>
 <span class="s0">* assigned to the vertices under the &quot;transform_index&quot; name.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3441  5 table 1 3232  </span>
<span class="s0">476 0 0 4 608 3346 0 0 144 /**</span>
 <span class="s0">* Sets the TransformTable pointer to NULL, removing the table from the vertex</span>
 <span class="s0">* data.  This disables hardware-driven vertex animation.</span>
 <span class="s0">*/ 1 4 this 3 3441  </span>
<span class="s0">477 0 0 7 612 3434 0 0 467 /**</span>
 <span class="s0">* Returns a const pointer to the TransformBlendTable assigned to this data.</span>
 <span class="s0">* Vertices within the table will index into this table to indicate their</span>
 <span class="s0">* dynamic skinning information; this table is used when the vertex animation</span>
 <span class="s0">* is to be performed by the CPU (but also see get_transform_table()).</span>
 <span class="s0">*</span>
 <span class="s0">* This will return NULL if the vertex data does not have a</span>
 <span class="s0">* TransformBlendTable assigned (which implies the vertices will not be</span>
 <span class="s0">* animated by the CPU).</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">478 0 0 7 613 3433 0 0 342 /**</span>
 <span class="s0">* Returns a modifiable pointer to the current TransformBlendTable on this</span>
 <span class="s0">* vertex data, if any, or NULL if there is not a TransformBlendTable.  See</span>
 <span class="s0">* get_transform_blend_table().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3441  </span>
<span class="s0">479 0 0 4 614 3346 0 0 382 /**</span>
 <span class="s0">* Replaces the TransformBlendTable on this vertex data with the indicated</span>
 <span class="s0">* table.  The length of this table should be consistent with the maximum</span>
 <span class="s0">* table index assigned to the vertices under the &quot;transform_blend&quot; name.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3441  5 table 1 3434  </span>
<span class="s0">480 0 0 4 615 3346 0 0 144 /**</span>
 <span class="s0">* Sets the TransformBlendTable pointer to NULL, removing the table from the</span>
 <span class="s0">* vertex data.  This disables CPU-driven vertex animation.</span>
 <span class="s0">*/ 1 4 this 3 3441  </span>
<span class="s0">481 0 0 7 616 3234 0 0 264 /**</span>
 <span class="s0">* Returns a const pointer to the SliderTable assigned to this data.  Vertices</span>
 <span class="s0">* within the vertex data will look up their morph offsets, if any, within</span>
 <span class="s0">* this table.</span>
 <span class="s0">*</span>
 <span class="s0">* This will return NULL if the vertex data does not have a SliderTable</span>
 <span class="s0">* assigned.</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">482 0 0 4 617 3346 0 0 437 /**</span>
 <span class="s0">* Replaces the SliderTable on this vertex data with the indicated table.</span>
 <span class="s0">* There should be an entry in this table for each kind of morph offset</span>
 <span class="s0">* defined in the vertex data.</span>
 <span class="s0">*</span>
 <span class="s0">* The SliderTable object must have been registered prior to setting it on the</span>
 <span class="s0">* GeomVertexData.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3441  5 table 1 3234  </span>
<span class="s0">483 0 0 4 618 3346 0 0 138 /**</span>
 <span class="s0">* Sets the SliderTable pointer to NULL, removing the table from the vertex</span>
 <span class="s0">* data.  This disables morph (blend shape) animation.</span>
 <span class="s0">*/ 1 4 this 3 3441  </span>
<span class="s0">484 0 0 6 622 3177 0 0 100 /**</span>
 <span class="s0">* Returns the total number of bytes consumed by the different arrays of the</span>
 <span class="s0">* vertex data.</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">485 0 0 7 623 3398 0 0 118 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the vertex data is modified.</span>
 <span class="s0">*/ 2 4 this 3 3368  14 current_thread 5 3399  </span>
<span class="s0">486 0 0 6 626 3178 0 0 180 /**</span>
 <span class="s0">* Returns true if the vertex data is currently resident in memory.  If this</span>
 <span class="s0">* returns false, the vertex data will be brought back into memory shortly;</span>
 <span class="s0">* try again later.</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">487 0 0 4 627 3346 0 0 691 /**</span>
 <span class="s0">* Copies all the data from the other array into the corresponding data types</span>
 <span class="s0">* in this array, by matching data types name-by-name.</span>
 <span class="s0">*</span>
 <span class="s0">* keep_data_objects specifies what to do when one or more of the arrays can</span>
 <span class="s0">* be copied without the need to apply any conversion operation.  If it is</span>
 <span class="s0">* true, the original GeomVertexArrayData objects in this object are retained,</span>
 <span class="s0">* and their data arrays are copied byte-by-byte from the source; if it is</span>
 <span class="s0">* false, then the GeomVertexArrayData objects are copied pointerwise from the</span>
 <span class="s0">* source.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 4 4 this 3 3441  6 source 1 3368  17 keep_data_objects 1 3178  14 current_thread 5 3399  </span>
<span class="s0">488 0 0 4 628 3346 0 0 335 /**</span>
 <span class="s0">* Copies a single row of the data from the other array into the indicated row</span>
 <span class="s0">* of this array.  In this case, the source format must exactly match the</span>
 <span class="s0">* destination format.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 5 4 this 3 3441  8 dest_row 1 3177  6 source 1 3368  10 source_row 1 3177  14 current_thread 1 3399  </span>
<span class="s0">489 0 0 7 629 3368 0 0 162 /**</span>
 <span class="s0">* Returns a new GeomVertexData that represents the same contents as this one,</span>
 <span class="s0">* with all data types matched up name-by-name to the indicated new format.</span>
 <span class="s0">*/ 2 4 this 3 3368  10 new_format 1 3229  </span>
<span class="s0">490 0 0 7 630 3368 0 0 208 /**</span>
 <span class="s0">* Returns a new GeomVertexData object with the color table modified in-place</span>
 <span class="s0">* to apply the indicated scale.</span>
 <span class="s0">*</span>
 <span class="s0">* If the vertex data does not include a color column, a new one will not be</span>
 <span class="s0">* added.</span>
 <span class="s0">*/ 2 4 this 3 3368  11 color_scale 1 3442  </span>
<span class="s0">491 0 0 7 630 3368 0 0 307 /**</span>
 <span class="s0">* Returns a new GeomVertexData object with the color table replaced with a</span>
 <span class="s0">* new color table that has been scaled by the indicated value.  The new color</span>
 <span class="s0">* table will be added as a new array; if the old color table was interleaved</span>
 <span class="s0">* with a previous array, the previous array will not be repacked.</span>
 <span class="s0">*/ 5 4 this 3 3368  11 color_scale 1 3442  14 num_components 1 3177  12 numeric_type 1 3173  8 contents 1 3174  </span>
<span class="s0">492 0 0 7 631 3368 0 0 197 /**</span>
 <span class="s0">* Returns a new GeomVertexData object with the color data modified in-place</span>
 <span class="s0">* with the new value.</span>
 <span class="s0">*</span>
 <span class="s0">* If the vertex data does not include a color column, a new one will not be</span>
 <span class="s0">* added.</span>
 <span class="s0">*/ 2 4 this 3 3368  5 color 1 3445  </span>
<span class="s0">493 0 0 7 631 3368 0 0 309 /**</span>
 <span class="s0">* Returns a new GeomVertexData object with the color table replaced with a</span>
 <span class="s0">* new color table for which each vertex has the indicated value.  The new</span>
 <span class="s0">* color table will be added as a new array; if the old color table was</span>
 <span class="s0">* interleaved with a previous array, the previous array will not be repacked.</span>
 <span class="s0">*/ 5 4 this 3 3368  5 color 1 3445  14 num_components 1 3177  12 numeric_type 1 3173  8 contents 1 3174  </span>
<span class="s0">494 0 0 7 632 3368 0 0 281 /**</span>
 <span class="s0">* Returns a new GeomVertexData object with the normal data modified in-place,</span>
 <span class="s0">* so that each lighting normal is now facing in the opposite direction.</span>
 <span class="s0">*</span>
 <span class="s0">* If the vertex data does not include a normal column, this returns the</span>
 <span class="s0">* original GeomVertexData object, unchanged.</span>
 <span class="s0">*/ 1 4 this 3 3368  </span>
<span class="s0">495 0 0 7 633 3368 0 0 861 /**</span>
 <span class="s0">* Returns a GeomVertexData that represents the results of computing the</span>
 <span class="s0">* vertex animation on the CPU for this GeomVertexData.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is no CPU-defined vertex animation on this object, this just</span>
 <span class="s0">* returns the original object.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is vertex animation, but the VertexTransform values have not</span>
 <span class="s0">* changed since last time, this may return the same pointer it returned</span>
 <span class="s0">* previously.  Even if the VertexTransform values have changed, it may still</span>
 <span class="s0">* return the same pointer, but with its contents modified (this is preferred,</span>
 <span class="s0">* since it allows the graphics backend to update vertex buffers optimally).</span>
 <span class="s0">*</span>
 <span class="s0">* If force is false, this method may return immediately with stale data, if</span>
 <span class="s0">* the vertex data is not completely resident.  If force is true, this method</span>
 <span class="s0">* will never return stale data, but may block until the data is available.</span>
 <span class="s0">*/ 3 4 this 3 3368  5 force 1 3178  14 current_thread 1 3399  </span>
<span class="s0">496 0 0 4 634 3346 0 0 268 /**</span>
 <span class="s0">* Removes the cache of animated vertices computed by a previous call to</span>
 <span class="s0">* animate_vertices() within the same frame.  This will force the next call to</span>
 <span class="s0">* animate_vertices() to recompute these values from scratch.  Normally it is</span>
 <span class="s0">* not necessary to call this.</span>
 <span class="s0">*/ 1 4 this 3 3441  </span>
<span class="s0">497 0 0 4 635 3346 0 0 193 /**</span>
 <span class="s0">* Applies the indicated transform matrix to all of the vertices in the</span>
 <span class="s0">* GeomVertexData.  The transform is applied to all &quot;point&quot; and &quot;vector&quot; type</span>
 <span class="s0">* columns described in the format.</span>
 <span class="s0">*/ 2 4 this 3 3441  3 mat 1 3418  </span>
<span class="s0">498 0 0 4 635 3346 0 0 201 /**</span>
 <span class="s0">* Applies the indicated transform matrix to all of the vertices mentioned in</span>
 <span class="s0">* the sparse array.  The transform is applied to all &quot;point&quot; and &quot;vector&quot;</span>
 <span class="s0">* type columns described in the format.</span>
 <span class="s0">*/ 3 4 this 3 3441  3 mat 1 3418  4 rows 1 3436  </span>
<span class="s0">499 0 0 4 635 3346 0 0 218 /**</span>
 <span class="s0">* Applies the indicated transform matrix to all of the vertices from</span>
 <span class="s0">* begin_row up to but not including end_row.  The transform is applied to all</span>
 <span class="s0">* &quot;point&quot; and &quot;vector&quot; type columns described in the format.</span>
 <span class="s0">*/ 4 4 this 3 3441  3 mat 1 3418  9 begin_row 1 3177  7 end_row 1 3177  </span>
<span class="s0">500 0 0 7 636 3441 2051 0 435 /**</span>
 <span class="s0">* Returns a new GeomVertexData object, suitable for modification, with the</span>
 <span class="s0">* indicated data type replaced with a new table filled with undefined values.</span>
 <span class="s0">* The new table will be added as a new array; if the old table was</span>
 <span class="s0">* interleaved with a previous array, the previous array will not be repacked.</span>
 <span class="s0">*</span>
 <span class="s0">* If num_components is 0, the indicated name is simply removed from the type,</span>
 <span class="s0">* without replacing it with anything else.</span>
 <span class="s0">*/ 5 4 this 3 3368  4 name 1 3181  14 num_components 1 3177  12 numeric_type 1 3173  8 contents 1 3174  </span>
<span class="s0">501 0 0 4 637 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3368  3 out 1 3347  </span>
<span class="s0">502 0 0 4 638 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3368  3 out 1 3347  12 indent_level 5 3177  </span>
<span class="s0">503 0 0 4 639 3346 0 0 90 /**</span>
 <span class="s0">* Writes a verbose, human-friendly description of the indicated vertex</span>
 <span class="s0">* number.</span>
 <span class="s0">*/ 3 4 this 3 3368  3 out 1 3347  3 row 1 3177  </span>
<span class="s0">504 0 0 4 640 3346 0 0 263 /**</span>
 <span class="s0">* Removes all of the previously-cached results of convert_to().</span>
 <span class="s0">*</span>
 <span class="s0">* This blows away the entire cache, upstream and downstream the pipeline.</span>
 <span class="s0">* Use clear_cache_stage() instead if you only want to blow away the cache at</span>
 <span class="s0">* the current stage and upstream.</span>
 <span class="s0">*/ 1 4 this 3 3441  </span>
<span class="s0">505 0 0 4 641 3346 0 0 310 /**</span>
 <span class="s0">* Removes all of the previously-cached results of convert_to(), at the</span>
 <span class="s0">* current pipeline stage and upstream.  Does not affect the downstream cache.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3441  </span>
<span class="s0">506 0 0 7 642 3362 0 0 0 0 </span>
<span class="s0">507 0 0 7 568 3411 0 0 0 1 4 this 3 3441  </span>
<span class="s0">508 0 0 6 570 3353 0 0 0 1 4 this 3 3441  </span>
<span class="s0">509 0 0 15 645 3448 2107 0 0 1 6 param0 0 3446  </span>
<span class="s0">510 0 0 7 645 3448 2107 0 47 /**</span>
 <span class="s0">* Create a new AnimateVerticesRequest.</span>
 <span class="s0">*/ 1 16 geom_vertex_data 1 3441  </span>
<span class="s0">511 0 0 6 646 3178 0 0 154 /**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending.</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/ 1 4 this 3 3446  </span>
<span class="s0">512 0 0 7 647 3362 0 0 0 0 </span>
<span class="s0">513 0 0 7 651 3362 0 0 0 0 </span>
<span class="s0">514 0 0 6 657 3209 0 0 271 /**</span>
 <span class="s0">* Returns the number of bytes previously reported for the data object.  This</span>
 <span class="s0">* is used to track changes in the data object's allocated size; if it changes</span>
 <span class="s0">* from this, we need to create a new buffer.  This is also used to track</span>
 <span class="s0">* memory utilization in PStats.</span>
 <span class="s0">*/ 1 4 this 3 3449  </span>
<span class="s0">515 0 0 7 658 3398 0 0 93 /**</span>
 <span class="s0">* Returns the UpdateSeq that was recorded the last time mark_loaded() was</span>
 <span class="s0">* called.</span>
 <span class="s0">*/ 1 4 this 3 3449  </span>
<span class="s0">516 0 0 6 659 3178 0 0 141 /**</span>
 <span class="s0">* Returns the active flag associated with this object.  An object is</span>
 <span class="s0">* considered &quot;active&quot; if it was rendered in the current frame.</span>
 <span class="s0">*/ 1 4 this 3 3449  </span>
<span class="s0">517 0 0 6 660 3178 0 0 152 /**</span>
 <span class="s0">* Returns the resident flag associated with this object.  An object is</span>
 <span class="s0">* considered &quot;resident&quot; if it appears to be resident in texture memory.</span>
 <span class="s0">*/ 1 4 this 3 3449  </span>
<span class="s0">518 0 0 7 668 3362 0 0 0 0 </span>
<span class="s0">519 0 0 6 654 3452 0 0 0 1 4 this 3 3451  </span>
<span class="s0">520 0 0 7 674 3453 2124 0 0 2 4 this 3 3453  4 copy 1 3454  </span>
<span class="s0">521 0 0 4 676 3346 0 0 0 2 4 this 3 3453  4 size 1 3209  </span>
<span class="s0">522 0 0 7 679 3453 2124 0 0 1 4 this 3 3454  </span>
<span class="s0">523 0 0 6 680 3172 0 0 0 1 4 this 3 3454  </span>
<span class="s0">524 0 0 6 681 3177 0 0 135 /**</span>
 <span class="s0">* Returns the set of GeomRendering bits that represent the rendering</span>
 <span class="s0">* properties required to properly render this primitive.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">525 0 0 6 684 3171 0 0 170 /**</span>
 <span class="s0">* Returns the ShadeModel hint for this primitive.  This is intended as a hint</span>
 <span class="s0">* to the renderer to tell it how the per-vertex colors and normals are</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">526 0 0 4 685 3346 0 0 512 /**</span>
 <span class="s0">* Changes the ShadeModel hint for this primitive.  This is different from the</span>
 <span class="s0">* ShadeModelAttrib that might also be applied from the scene graph.  This</span>
 <span class="s0">* does not affect the shade model that is in effect when rendering, but</span>
 <span class="s0">* rather serves as a hint to the renderer to tell it how the per-vertex</span>
 <span class="s0">* colors and normals on this primitive are applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3453  11 shade_model 1 3171  </span>
<span class="s0">527 0 0 6 687 3169 0 0 554 /**</span>
 <span class="s0">* Returns the usage hint for this primitive.  See geomEnums.h.  This has</span>
 <span class="s0">* nothing to do with the usage hint associated with the primitive's vertices;</span>
 <span class="s0">* this only specifies how often the vertex indices that define the primitive</span>
 <span class="s0">* will be modified.</span>
 <span class="s0">*</span>
 <span class="s0">* It is perfectly legal (and, in fact, common) for a GeomPrimitive to have</span>
 <span class="s0">* UH_static on itself, while referencing vertex data with UH_dynamic.  This</span>
 <span class="s0">* means that the vertices themselves will be animated, but the primitive will</span>
 <span class="s0">* always reference the same set of vertices from the pool.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">528 0 0 4 688 3346 0 0 232 /**</span>
 <span class="s0">* Changes the UsageHint hint for this primitive.  See get_usage_hint().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3453  10 usage_hint 1 3169  </span>
<span class="s0">529 0 0 6 690 3173 0 0 114 /**</span>
 <span class="s0">* Returns the numeric type of the index column.  Normally, this will be</span>
 <span class="s0">* either NT_uint16 or NT_uint32.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">530 0 0 4 691 3346 0 0 556 /**</span>
 <span class="s0">* Changes the numeric type of the index column.  Normally, this should be</span>
 <span class="s0">* either NT_uint16 or NT_uint32.</span>
 <span class="s0">*</span>
 <span class="s0">* The index type must be large enough to include all of the index values in</span>
 <span class="s0">* the primitive.  It may be automatically elevated, if necessary, to a larger</span>
 <span class="s0">* index type, by a subsequent call to add_index() that names an index value</span>
 <span class="s0">* that does not fit in the index type you specify.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3453  10 index_type 1 3173  </span>
<span class="s0">531 0 0 6 693 3178 0 0 178 /**</span>
 <span class="s0">* Returns true if the primitive is a composite primitive such as a tristrip</span>
 <span class="s0">* or trifan, or false if it is a fundamental primitive such as a collection</span>
 <span class="s0">* of triangles.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">532 0 0 6 694 3178 0 0 379 /**</span>
 <span class="s0">* Returns true if the primitive is indexed, false otherwise.  An indexed</span>
 <span class="s0">* primitive stores a table of index numbers into its GeomVertexData, so that</span>
 <span class="s0">* it can reference the vertices in any order.  A nonindexed primitive, on the</span>
 <span class="s0">* other hand, stores only the first vertex number and number of vertices</span>
 <span class="s0">* used, so that it can only reference the vertices consecutively.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">533 0 0 6 695 3177 0 0 257 /**</span>
 <span class="s0">* Returns the first vertex number referenced by the primitive.  This is</span>
 <span class="s0">* particularly important in the case of a nonindexed primitive, in which case</span>
 <span class="s0">* get_first_vertex() and get_num_vertices() completely define the extent of</span>
 <span class="s0">* the vertex range.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">534 0 0 6 696 3177 0 0 83 /**</span>
 <span class="s0">* Returns the number of indices used by all the primitives in this object.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">535 0 0 6 697 3177 0 0 53 /**</span>
 <span class="s0">* Returns the ith vertex index in the table.</span>
 <span class="s0">*/ 2 4 this 3 3454  1 i 1 3177  </span>
<span class="s0">536 0 0 4 699 3346 0 0 445 /**</span>
 <span class="s0">* Adds the indicated vertex to the list of vertex indices used by the</span>
 <span class="s0">* graphics primitive type.  To define a primitive, you must call add_vertex()</span>
 <span class="s0">* for each vertex of the new primitive, and then call close_primitive() after</span>
 <span class="s0">* you have specified the last vertex of each primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3453  6 vertex 1 3177  </span>
<span class="s0">537 0 0 4 700 3346 0 0 42 /**</span>
 <span class="s0">* Adds several vertices in a row.</span>
 <span class="s0">*/ 3 4 this 3 3453  2 v1 1 3177  2 v2 1 3177  </span>
<span class="s0">538 0 0 4 700 3346 0 0 42 /**</span>
 <span class="s0">* Adds several vertices in a row.</span>
 <span class="s0">*/ 4 4 this 3 3453  2 v1 1 3177  2 v2 1 3177  2 v3 1 3177  </span>
<span class="s0">539 0 0 4 700 3346 0 0 42 /**</span>
 <span class="s0">* Adds several vertices in a row.</span>
 <span class="s0">*/ 5 4 this 3 3453  2 v1 1 3177  2 v2 1 3177  2 v3 1 3177  2 v4 1 3177  </span>
<span class="s0">540 0 0 4 701 3346 0 0 244 /**</span>
 <span class="s0">* Adds a consecutive sequence of vertices, beginning at start, to the</span>
 <span class="s0">* primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 3 4 this 3 3453  5 start 1 3177  12 num_vertices 1 3177  </span>
<span class="s0">541 0 0 4 702 3346 0 0 327 /**</span>
 <span class="s0">* Adds the next n vertices in sequence, beginning from the last vertex added</span>
 <span class="s0">* to the primitive + 1.</span>
 <span class="s0">*</span>
 <span class="s0">* This is most useful when you are building up a primitive and a</span>
 <span class="s0">* GeomVertexData at the same time, and you just want the primitive to</span>
 <span class="s0">* reference the first n vertices from the data, then the next n, and so on.</span>
 <span class="s0">*/ 2 4 this 3 3453  12 num_vertices 1 3177  </span>
<span class="s0">542 0 0 4 703 3346 0 0 813 /**</span>
 <span class="s0">* This ensures that enough memory space for n vertices is allocated, so that</span>
 <span class="s0">* you may increase the number of vertices to n without causing a new memory</span>
 <span class="s0">* allocation.  This is a performance optimization only; it is especially</span>
 <span class="s0">* useful when you know ahead of time that you will be adding n vertices to</span>
 <span class="s0">* the primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the total you specify here should also include implicit vertices</span>
 <span class="s0">* which may be added at each close_primitive() call, according to</span>
 <span class="s0">* get_num_unused_vertices_per_primitive().</span>
 <span class="s0">*</span>
 <span class="s0">* Note also that making this call will implicitly make the primitive indexed</span>
 <span class="s0">* if it is not already, which could result in a performance *penalty*.  If</span>
 <span class="s0">* you would prefer not to lose the nonindexed nature of your existing</span>
 <span class="s0">* GeomPrimitives, check is_indexed() before making this call.</span>
 <span class="s0">*/ 2 4 this 3 3453  12 num_vertices 1 3177  </span>
<span class="s0">543 0 0 6 704 3178 0 0 345 /**</span>
 <span class="s0">* Indicates that the previous n calls to add_vertex(), since the last call to</span>
 <span class="s0">* close_primitive(), have fully defined a new primitive.  Returns true if</span>
 <span class="s0">* successful, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3453  </span>
<span class="s0">544 0 0 4 705 3346 0 0 250 /**</span>
 <span class="s0">* Removes all of the vertices and primitives from the object, so they can be</span>
 <span class="s0">* re-added.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3453  </span>
<span class="s0">545 0 0 4 706 3346 0 0 227 /**</span>
 <span class="s0">* Adds the indicated offset to all vertices used by the primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3453  6 offset 1 3177  </span>
<span class="s0">546 0 0 4 706 3346 0 0 508 /**</span>
 <span class="s0">* Adds the indicated offset to the indicated segment of vertices used by the</span>
 <span class="s0">* primitive.  Unlike the other version of offset_vertices, this makes the</span>
 <span class="s0">* geometry indexed if it isn't already.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that end_row indicates one past the last row that should be offset.</span>
 <span class="s0">* In other words, the number of vertices touched is (end_row - begin_row).</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 4 4 this 3 3453  6 offset 1 3177  9 begin_row 1 3177  7 end_row 1 3177  </span>
<span class="s0">547 0 0 4 707 3346 0 0 202 /**</span>
 <span class="s0">* Converts the primitive from indexed to nonindexed by duplicating vertices</span>
 <span class="s0">* as necessary into the indicated dest GeomVertexData.  Note: does not</span>
 <span class="s0">* support primitives with strip cut indices.</span>
 <span class="s0">*/ 3 4 this 3 3453  4 dest 1 3441  6 source 1 3368  </span>
<span class="s0">548 0 0 4 708 3346 0 0 135 /**</span>
 <span class="s0">* Packs the vertices used by the primitive from the indicated source array</span>
 <span class="s0">* onto the end of the indicated destination array.</span>
 <span class="s0">*/ 3 4 this 3 3453  4 dest 1 3441  6 source 1 3368  </span>
<span class="s0">549 0 0 4 709 3346 0 0 466 /**</span>
 <span class="s0">* Converts the primitive from nonindexed form to indexed form.  This will</span>
 <span class="s0">* simply create an index table that is numbered consecutively from</span>
 <span class="s0">* get_first_vertex(); it does not automatically collapse together identical</span>
 <span class="s0">* vertices that may have been split apart by a previous call to</span>
 <span class="s0">* make_nonindexed().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3453  </span>
<span class="s0">550 0 0 6 710 3177 0 0 119 /**</span>
 <span class="s0">* Returns the number of individual primitives stored within this object.  All</span>
 <span class="s0">* primitives are the same type.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">551 0 0 6 711 3177 0 0 457 /**</span>
 <span class="s0">* Returns the element within the _vertices list at which the nth primitive</span>
 <span class="s0">* starts.</span>
 <span class="s0">*</span>
 <span class="s0">* If i is one more than the highest valid primitive vertex, the return value</span>
 <span class="s0">* will be one more than the last valid vertex.  Thus, it is generally true</span>
 <span class="s0">* that the vertices used by a particular primitive i are the set</span>
 <span class="s0">* get_primitive_start(n) &lt;= vi &lt; get_primitive_start(n + 1) (although this</span>
 <span class="s0">* range also includes the unused vertices between primitives).</span>
 <span class="s0">*/ 2 4 this 3 3454  1 n 1 3177  </span>
<span class="s0">552 0 0 6 712 3177 0 0 156 /**</span>
 <span class="s0">* Returns the element within the _vertices list at which the nth primitive</span>
 <span class="s0">* ends.  This is one past the last valid element for the nth primitive.</span>
 <span class="s0">*/ 2 4 this 3 3454  1 n 1 3177  </span>
<span class="s0">553 0 0 6 713 3177 0 0 145 /**</span>
 <span class="s0">* Returns the number of vertices used by the nth primitive.  This is the same</span>
 <span class="s0">* thing as get_primitive_end(n) - get_primitive_start(n).</span>
 <span class="s0">*/ 2 4 this 3 3454  1 n 1 3177  </span>
<span class="s0">554 0 0 6 714 3177 0 0 278 /**</span>
 <span class="s0">* Returns the number of vertices used by all of the primitives.  This is the</span>
 <span class="s0">* same as summing get_primitive_num_vertices(n) for n in</span>
 <span class="s0">* get_num_primitives().  It is like get_num_vertices except that it excludes</span>
 <span class="s0">* all of the degenerate vertices and strip-cut indices.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">555 0 0 6 715 3177 0 0 145 /**</span>
 <span class="s0">* Returns the number of triangles or other fundamental type (such as line</span>
 <span class="s0">* segments) represented by all the primitives in this object.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">556 0 0 6 716 3177 0 0 144 /**</span>
 <span class="s0">* Returns the number of triangles or other fundamental type (such as line</span>
 <span class="s0">* segments) represented by the nth primitive in this object.</span>
 <span class="s0">*/ 2 4 this 3 3454  1 n 1 3177  </span>
<span class="s0">557 0 0 6 717 3177 0 0 96 /**</span>
 <span class="s0">* Returns the minimum vertex index number used by all the primitives in this</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">558 0 0 6 718 3177 0 0 95 /**</span>
 <span class="s0">* Returns the minimum vertex index number used by the nth primitive in this</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 2 4 this 3 3454  1 n 1 3177  </span>
<span class="s0">559 0 0 6 719 3177 0 0 96 /**</span>
 <span class="s0">* Returns the maximum vertex index number used by all the primitives in this</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">560 0 0 6 720 3177 0 0 95 /**</span>
 <span class="s0">* Returns the maximum vertex index number used by the nth primitive in this</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 2 4 this 3 3454  1 n 1 3177  </span>
<span class="s0">561 0 0 7 721 3454 0 0 464 /**</span>
 <span class="s0">* Decomposes a complex primitive type into a simpler primitive type, for</span>
 <span class="s0">* instance triangle strips to triangles, and returns a pointer to the new</span>
 <span class="s0">* primitive definition.  If the decomposition cannot be performed, this might</span>
 <span class="s0">* return the original object.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is useful for application code that wants to iterate through</span>
 <span class="s0">* the set of triangles on the primitive without having to write handlers for</span>
 <span class="s0">* each possible kind of primitive type.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">562 0 0 7 722 3454 0 0 408 /**</span>
 <span class="s0">* Returns a new primitive with the shade_model reversed (if it is flat</span>
 <span class="s0">* shaded), if possible.  If the primitive type cannot be rotated, returns the</span>
 <span class="s0">* original primitive, unrotated.</span>
 <span class="s0">*</span>
 <span class="s0">* If the current shade_model indicates flat_vertex_last, this should bring</span>
 <span class="s0">* the last vertex to the first position; if it indicates flat_vertex_first,</span>
 <span class="s0">* this should bring the first vertex to the last position.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">563 0 0 7 723 3454 0 0 493 /**</span>
 <span class="s0">* Duplicates triangles in the primitive so that each triangle is back-to-back</span>
 <span class="s0">* with another triangle facing in the opposite direction.  Note that this</span>
 <span class="s0">* doesn't affect vertex normals, so this operation alone won't work in the</span>
 <span class="s0">* presence of lighting (but see SceneGraphReducer::doubleside()).</span>
 <span class="s0">*</span>
 <span class="s0">* Also see CullFaceAttrib, which can enable rendering of both sides of a</span>
 <span class="s0">* triangle without having to duplicate it (but which doesn't necessarily work</span>
 <span class="s0">* in the presence of lighting).</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">564 0 0 7 724 3454 0 0 477 /**</span>
 <span class="s0">* Reverses the winding order in the primitive so that each triangle is facing</span>
 <span class="s0">* in the opposite direction it was originally.  Note that this doesn't affect</span>
 <span class="s0">* vertex normals, so this operation alone won't work in the presence of</span>
 <span class="s0">* lighting (but see SceneGraphReducer::reverse()).</span>
 <span class="s0">*</span>
 <span class="s0">* Also see CullFaceAttrib, which can change the visible direction of a</span>
 <span class="s0">* triangle without having to duplicate it (but which doesn't necessarily work</span>
 <span class="s0">* in the presence of lighting).</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">565 0 0 7 725 3454 0 0 346 /**</span>
 <span class="s0">* Returns a new primitive that is compatible with the indicated shade model,</span>
 <span class="s0">* if possible, or NULL if this is not possible.</span>
 <span class="s0">*</span>
 <span class="s0">* In most cases, this will return either NULL or the original primitive.  In</span>
 <span class="s0">* the case of a SM_flat_first_vertex vs.  a SM_flat_last_vertex (or vice-</span>
 <span class="s0">* versa), however, it will return a rotated primitive.</span>
 <span class="s0">*/ 2 4 this 3 3454  11 shade_model 1 3171  </span>
<span class="s0">566 0 0 7 726 3454 0 0 245 /**</span>
 <span class="s0">* Returns a new GeomPoints primitive that represents each of the vertices in</span>
 <span class="s0">* the original primitive, rendered exactly once.  If the original primitive</span>
 <span class="s0">* is already a GeomPoints primitive, returns the original primitive</span>
 <span class="s0">* unchanged.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">567 0 0 7 727 3454 0 0 233 /**</span>
 <span class="s0">* Returns a new GeomLines primitive that represents each of the edges in the</span>
 <span class="s0">* original primitive rendered as a line.  If the original primitive is</span>
 <span class="s0">* already a GeomLines primitive, returns the original primitive unchanged.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">568 0 0 7 728 3454 0 0 418 /**</span>
 <span class="s0">* Decomposes a complex primitive type into a simpler primitive type, for</span>
 <span class="s0">* instance triangle strips to triangles, puts these in a new GeomPatches</span>
 <span class="s0">* object and returns a pointer to the new primitive definition.  If the</span>
 <span class="s0">* decomposition cannot be performed, this might return the original object.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is useful for application code that wants to use tesselation</span>
 <span class="s0">* shaders on arbitrary geometry.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">569 0 0 7 729 3454 0 0 161 /**</span>
 <span class="s0">* Adds adjacency information to this primitive.  May return null if this type</span>
 <span class="s0">* of geometry does not support adjacency information.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">570 0 0 6 730 3177 0 0 91 /**</span>
 <span class="s0">* Returns the number of bytes consumed by the primitive and its index</span>
 <span class="s0">* table(s).</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">571 0 0 6 731 3177 0 0 68 /**</span>
 <span class="s0">* Returns the number of bytes stored in the vertices array.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">572 0 0 7 732 3398 0 0 125 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the vertex index array is modified.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">573 0 0 6 736 3178 0 0 186 /**</span>
 <span class="s0">* Returns true if the primitive data is currently resident in memory.  If</span>
 <span class="s0">* this returns false, the primitive data will be brought back into memory</span>
 <span class="s0">* shortly; try again later.</span>
 <span class="s0">*/ 2 4 this 3 3454  14 current_thread 5 3399  </span>
<span class="s0">574 0 0 6 737 3178 0 0 195 /**</span>
 <span class="s0">* Verifies that the primitive only references vertices that actually exist</span>
 <span class="s0">* within the indicated GeomVertexData.  Returns true if the primitive appears</span>
 <span class="s0">* to be valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3454  11 vertex_data 1 3368  </span>
<span class="s0">575 0 0 6 737 3178 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3454  11 data_reader 1 3456  </span>
<span class="s0">576 0 0 4 738 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3454  3 out 1 3347  </span>
<span class="s0">577 0 0 4 739 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3454  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">578 0 0 7 740 3365 0 0 479 /**</span>
 <span class="s0">* Returns a const pointer to the vertex index array so application code can</span>
 <span class="s0">* read it directly.  This might return NULL if the primitive is nonindexed.</span>
 <span class="s0">* Do not attempt to modify the returned array; use modify_vertices() or</span>
 <span class="s0">* set_vertices() for this.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">579 0 0 7 741 3402 0 0 53 /**</span>
 <span class="s0">* Equivalent to get_vertices().get_handle().</span>
 <span class="s0">*/ 2 4 this 3 3454  14 current_thread 1 3399  </span>
<span class="s0">580 0 0 7 742 3213 1897 0 869 /**</span>
 <span class="s0">* Returns a modifiable pointer to the vertex index list, so application code</span>
 <span class="s0">* can directly fiddle with this data.  Use with caution, since there are no</span>
 <span class="s0">* checks that the data will be left in a stable state.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is called on a nonindexed primitive, it will implicitly be</span>
 <span class="s0">* converted to an indexed primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* If num_vertices is not -1, it specifies an artificial limit to the number</span>
 <span class="s0">* of vertices in the array.  Otherwise, all of the vertices in the array will</span>
 <span class="s0">* be used.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 2 4 this 3 3453  12 num_vertices 5 3177  </span>
<span class="s0">581 0 0 7 743 3403 1934 0 56 /**</span>
 <span class="s0">* Equivalent to modify_vertices().get_handle().</span>
 <span class="s0">*/ 2 4 this 3 3453  14 current_thread 1 3399  </span>
<span class="s0">582 0 0 4 744 3346 0 0 711 /**</span>
 <span class="s0">* Completely replaces the vertex index list with a new table.  Chances are</span>
 <span class="s0">* good that you should also replace the ends list with set_ends() at the same</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* If num_vertices is not -1, it specifies an artificial limit to the number</span>
 <span class="s0">* of vertices in the array.  Otherwise, all of the vertices in the array will</span>
 <span class="s0">* be used.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 3 4 this 3 3453  8 vertices 1 3365  12 num_vertices 5 3177  </span>
<span class="s0">583 0 0 4 745 3346 0 0 465 /**</span>
 <span class="s0">* Sets the primitive up as a nonindexed primitive, using the indicated vertex</span>
 <span class="s0">* range.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 3 4 this 3 3453  12 first_vertex 1 3177  12 num_vertices 1 3177  </span>
<span class="s0">584 0 0 6 746 3177 0 0 334 /**</span>
 <span class="s0">* A convenience function to return the gap between successive index numbers,</span>
 <span class="s0">* in bytes, of the index data.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">585 0 0 6 747 3177 0 0 189 /**</span>
 <span class="s0">* If relevant, returns the index value that may be used in some cases to</span>
 <span class="s0">* signify the end of a primitive.  This is typically the highest value that</span>
 <span class="s0">* the numeric type can store.</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">586 0 0 7 750 3461 0 0 580 /**</span>
 <span class="s0">* Returns a const pointer to the primitive ends array so application code can</span>
 <span class="s0">* read it directly.  Do not attempt to modify the returned array; use</span>
 <span class="s0">* modify_ends() or set_ends() for this.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a ends array:</span>
 <span class="s0">* since all the primitives have the same number of vertices, it is not</span>
 <span class="s0">* needed.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">587 0 0 7 751 3464 0 0 755 /**</span>
 <span class="s0">* Returns a modifiable pointer to the primitive ends array, so application</span>
 <span class="s0">* code can directly fiddle with this data.  Use with caution, since there are</span>
 <span class="s0">* no checks that the data will be left in a stable state.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a ends array:</span>
 <span class="s0">* since all the primitives have the same number of vertices, it is not</span>
 <span class="s0">* needed.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3453  </span>
<span class="s0">588 0 0 4 752 3346 0 0 716 /**</span>
 <span class="s0">* Completely replaces the primitive ends array with a new table.  Chances are</span>
 <span class="s0">* good that you should also replace the vertices list with set_vertices() at</span>
 <span class="s0">* the same time.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a ends array:</span>
 <span class="s0">* since all the primitives have the same number of vertices, it is not</span>
 <span class="s0">* needed.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 2 4 this 3 3453  4 ends 1 3464  </span>
<span class="s0">589 0 0 7 753 3365 0 0 482 /**</span>
 <span class="s0">* Returns a const pointer to the primitive mins array so application code can</span>
 <span class="s0">* read it directly.  Do not attempt to modify the returned array; use</span>
 <span class="s0">* set_minmax() for this.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a mins array.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">590 0 0 7 754 3365 0 0 473 /**</span>
 <span class="s0">* Returns a const pointer to the primitive maxs array so application code can</span>
 <span class="s0">* read it directly.  Do not attempt to modify the returned array; use</span>
 <span class="s0">* set_minmax().</span>
 <span class="s0">*</span>
 <span class="s0">* Note that simple primitive types, like triangles, do not have a maxs array.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">591 0 0 4 757 3346 0 0 687 /**</span>
 <span class="s0">* Explicitly specifies the minimum and maximum vertices, as well as the lists</span>
 <span class="s0">* of per-component min and max.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this method with extreme caution.  It's generally better to let the</span>
 <span class="s0">* GeomPrimitive compute these explicitly, unless for some reason you can do</span>
 <span class="s0">* it faster and you absolutely need the speed improvement.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that any modification to the vertex array will normally cause this to</span>
 <span class="s0">* be recomputed, unless you set it immediately again.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 5 4 this 3 3453  10 min_vertex 1 3177  10 max_vertex 1 3177  4 mins 1 3213  4 maxs 1 3213  </span>
<span class="s0">592 0 0 4 758 3346 0 0 339 /**</span>
 <span class="s0">* Undoes a previous call to set_minmax(), and allows the minimum and maximum</span>
 <span class="s0">* values to be recomputed normally.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3453  </span>
<span class="s0">593 0 0 6 759 3177 0 0 558 /**</span>
 <span class="s0">* If the primitive type is a simple type in which all primitives have the</span>
 <span class="s0">* same number of vertices, like triangles, returns the number of vertices per</span>
 <span class="s0">* primitive.  If the primitive type is a more complex type in which different</span>
 <span class="s0">* primitives might have different numbers of vertices, for instance a</span>
 <span class="s0">* triangle strip, returns 0.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">594 0 0 6 760 3177 0 0 336 /**</span>
 <span class="s0">* Returns the minimum number of vertices that must be added before</span>
 <span class="s0">* close_primitive() may legally be called.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">595 0 0 6 761 3177 0 0 479 /**</span>
 <span class="s0">* Returns the number of vertices that are added between primitives that</span>
 <span class="s0">* aren't, strictly speaking, part of the primitives themselves.  This is</span>
 <span class="s0">* used, for instance, to define degenerate triangles to connect otherwise</span>
 <span class="s0">* disconnected triangle strips.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for low-level usage only.  There are higher-level</span>
 <span class="s0">* methods for more common usage.  We recommend you do not use this method</span>
 <span class="s0">* directly.  If you do, be sure you know what you are doing!</span>
 <span class="s0">*/ 1 4 this 3 3454  </span>
<span class="s0">596 0 0 7 765 3362 0 0 0 0 </span>
<span class="s0">597 0 0 7 670 3411 0 0 0 1 4 this 3 3453  </span>
<span class="s0">598 0 0 6 672 3353 0 0 0 1 4 this 3 3453  </span>
<span class="s0">599 0 0 15 767 3251 0 0 50 /**</span>
 <span class="s0">* Initialize the texture stage from other</span>
 <span class="s0">*/ 1 4 copy 1 3465  </span>
<span class="s0">600 0 0 7 767 3251 0 0 55 /**</span>
 <span class="s0">* Initialize the texture stage at construction</span>
 <span class="s0">*/ 1 4 name 1 3342  </span>
<span class="s0">601 0 0 7 768 3251 0 0 0 2 4 this 3 3251  4 copy 1 3465  </span>
<span class="s0">602 0 0 4 773 3346 0 0 49 /**</span>
 <span class="s0">* Changes the name of this texture stage</span>
 <span class="s0">*/ 2 4 this 3 3251  4 name 1 3342  </span>
<span class="s0">603 0 0 6 774 3342 0 0 49 /**</span>
 <span class="s0">* Returns the name of this texture stage</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">604 0 0 4 775 3346 0 0 439 /**</span>
 <span class="s0">* Changes the order in which the texture associated with this stage is</span>
 <span class="s0">* rendered relative to the other texture stages.  When geometry is rendered</span>
 <span class="s0">* with multiple textures, the textures are rendered in order from the lowest</span>
 <span class="s0">* sort number to the highest sort number.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_priority(), which is used to select the most important</span>
 <span class="s0">* textures for rendering when some must be omitted because of hardware</span>
 <span class="s0">* limitations.</span>
 <span class="s0">*/ 2 4 this 3 3251  4 sort 1 3177  </span>
<span class="s0">605 0 0 6 776 3177 0 0 56 /**</span>
 <span class="s0">* Returns the sort order of this texture stage.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">606 0 0 4 777 3346 0 0 555 /**</span>
 <span class="s0">* Changes the relative importance of the texture associated with this stage</span>
 <span class="s0">* relative to the other texture stages that are applied simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* This is unrelated to set_sort(), which controls the order in which multiple</span>
 <span class="s0">* textures are applied.  The priority number is used to decide which of the</span>
 <span class="s0">* requested textures are to be selected for rendering when more textures are</span>
 <span class="s0">* requested than the hardware will support.  The highest-priority n textures</span>
 <span class="s0">* are selected for rendering, and then rendered in order by their sort</span>
 <span class="s0">* factor.</span>
 <span class="s0">*/ 2 4 this 3 3251  8 priority 1 3177  </span>
<span class="s0">607 0 0 6 778 3177 0 0 163 /**</span>
 <span class="s0">* Returns the priority associated with this stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This is specially helpful for cards that do not support more than n stages</span>
 <span class="s0">* of multi-texturing.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">608 0 0 4 779 3346 0 0 161 /**</span>
 <span class="s0">* Indicate which set of UV's this texture stage will use.  Geometry may have</span>
 <span class="s0">* any number of associated UV sets, each of which must have a unique name.</span>
 <span class="s0">*/ 2 4 this 3 3251  4 name 1 3181  </span>
<span class="s0">609 0 0 4 779 3346 0 0 161 /**</span>
 <span class="s0">* Indicate which set of UV's this texture stage will use.  Geometry may have</span>
 <span class="s0">* any number of associated UV sets, each of which must have a unique name.</span>
 <span class="s0">*/ 2 4 this 3 3251  13 texcoord_name 1 3342  </span>
<span class="s0">610 0 0 7 780 3181 0 0 79 /**</span>
 <span class="s0">* See set_texcoord_name.  The default is InternalName::get_texcoord().</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">611 0 0 7 781 3181 0 0 153 /**</span>
 <span class="s0">* Returns the set of tangents this texture stage will use.  This is the same</span>
 <span class="s0">* as get_texcoord_name(), except that the first part is &quot;tangent&quot;.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">612 0 0 7 782 3181 0 0 155 /**</span>
 <span class="s0">* Returns the set of binormals this texture stage will use.  This is the same</span>
 <span class="s0">* as get_binormal_name(), except that the first part is &quot;binormal&quot;.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">613 0 0 4 783 3346 0 0 45 /**</span>
 <span class="s0">* Set the mode of this texture stage</span>
 <span class="s0">*/ 2 4 this 3 3251  4 mode 1 3244  </span>
<span class="s0">614 0 0 6 784 3244 0 0 40 /**</span>
 <span class="s0">* Return the mode of this stage</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">615 0 0 6 785 3178 0 0 168 /**</span>
 <span class="s0">* Returns true if the TextureStage is relevant to the classic fixed function</span>
 <span class="s0">* pipeline.  This excludes texture stages such as normal mapping and the</span>
 <span class="s0">* like.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">616 0 0 4 786 3346 0 0 39 /**</span>
 <span class="s0">* Set the color for this stage</span>
 <span class="s0">*/ 2 4 this 3 3251  5 color 1 3445  </span>
<span class="s0">617 0 0 7 787 3467 0 0 42 /**</span>
 <span class="s0">* return the color for this stage</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">618 0 0 4 788 3346 0 0 215 /**</span>
 <span class="s0">* Sets an additional factor that will scale all three r, g, b components</span>
 <span class="s0">* after the texture has been applied.  This is used only when the mode is</span>
 <span class="s0">* CM_combine.</span>
 <span class="s0">*</span>
 <span class="s0">* The only legal values are 1, 2, or 4.</span>
 <span class="s0">*/ 2 4 this 3 3251  9 rgb_scale 1 3177  </span>
<span class="s0">619 0 0 6 789 3177 0 0 31 /**</span>
 <span class="s0">* See set_rgb_scale().</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">620 0 0 4 790 3346 0 0 203 /**</span>
 <span class="s0">* Sets an additional factor that will scale the alpha component after the</span>
 <span class="s0">* texture has been applied.  This is used only when the mode is CM_combine.</span>
 <span class="s0">*</span>
 <span class="s0">* The only legal values are 1, 2, or 4.</span>
 <span class="s0">*/ 2 4 this 3 3251  11 alpha_scale 1 3177  </span>
<span class="s0">621 0 0 6 791 3177 0 0 33 /**</span>
 <span class="s0">* See set_alpha_scale().</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">622 0 0 4 792 3346 0 0 471 /**</span>
 <span class="s0">* Sets the saved_result flag.  When this is true, the output of this stage</span>
 <span class="s0">* will be supplied as the &quot;last_saved_result&quot; source for any future stages,</span>
 <span class="s0">* until the next TextureStage with a saved_result set true is encountered.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to reuse the results of this texture stage as input to</span>
 <span class="s0">* more than one stage later in the pipeline.</span>
 <span class="s0">*</span>
 <span class="s0">* The last texture in the pipeline (the one with the highest sort value)</span>
 <span class="s0">* should not have this flag set.</span>
 <span class="s0">*/ 2 4 this 3 3251  12 saved_result 1 3178  </span>
<span class="s0">623 0 0 6 793 3178 0 0 92 /**</span>
 <span class="s0">* Returns the current setting of the saved_result flag.  See</span>
 <span class="s0">* set_saved_result().</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">624 0 0 4 794 3346 0 0 342 /**</span>
 <span class="s0">* Sets the tex_view_offset value.  This is used only when a special multiview</span>
 <span class="s0">* texture is bound to the TextureStage, and it selects the particular view of</span>
 <span class="s0">* the texture that is to be used.</span>
 <span class="s0">*</span>
 <span class="s0">* This value is added to the similar parameter on DisplayRegion to derive the</span>
 <span class="s0">* final texture view index that is selected for rendering.</span>
 <span class="s0">*/ 2 4 this 3 3251  15 tex_view_offset 1 3177  </span>
<span class="s0">625 0 0 6 795 3177 0 0 93 /**</span>
 <span class="s0">* Returns the current setting of the tex_view_offset.  See</span>
 <span class="s0">* set_tex_view_offset().</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">626 0 0 4 796 3346 0 0 135 /**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a one-parameter</span>
 <span class="s0">* operation.  Specifically, this is CM_replace only.</span>
 <span class="s0">*/ 4 4 this 3 3251  4 mode 1 3245  7 source0 1 3246  8 operand0 1 3247  </span>
<span class="s0">627 0 0 4 796 3346 0 0 174 /**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a two-parameter</span>
 <span class="s0">* operation.  Specifically, this is everything except for CM_replace and</span>
 <span class="s0">* CM_interpolate.</span>
 <span class="s0">*/ 6 4 this 3 3251  4 mode 1 3245  7 source0 1 3246  8 operand0 1 3247  7 source1 1 3246  8 operand1 1 3247  </span>
<span class="s0">628 0 0 4 796 3346 0 0 139 /**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a one-parameter</span>
 <span class="s0">* operation.  Specifically, this is CM_interpolate only.</span>
 <span class="s0">*/ 8 4 this 3 3251  4 mode 1 3245  7 source0 1 3246  8 operand0 1 3247  7 source1 1 3246  8 operand1 1 3247  7 source2 1 3246  8 operand2 1 3247  </span>
<span class="s0">629 0 0 6 797 3245 0 0 35 /**</span>
 <span class="s0">* Get the combine_rgb_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">630 0 0 6 798 3177 0 0 139 /**</span>
 <span class="s0">* Returns the number of meaningful operands that may be retrieved via</span>
 <span class="s0">* get_combine_rgb_sourceN() and get_combine_rgb_operandN().</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">631 0 0 6 799 3246 0 0 42 /**</span>
 <span class="s0">* Get source0 of combine_rgb_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">632 0 0 6 800 3247 0 0 43 /**</span>
 <span class="s0">* Get operand0 of combine_rgb_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">633 0 0 6 801 3246 0 0 42 /**</span>
 <span class="s0">* Get source1 of combine_rgb_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">634 0 0 6 802 3247 0 0 43 /**</span>
 <span class="s0">* Get operand1 of combine_rgb_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">635 0 0 6 803 3246 0 0 42 /**</span>
 <span class="s0">* Get source2 of combine_rgb_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">636 0 0 6 804 3247 0 0 43 /**</span>
 <span class="s0">* Get operand2 of combine_rgb_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">637 0 0 4 805 3346 0 0 135 /**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a one-parameter</span>
 <span class="s0">* operation.  Specifically, this is CM_replace only.</span>
 <span class="s0">*/ 4 4 this 3 3251  4 mode 1 3245  7 source0 1 3246  8 operand0 1 3247  </span>
<span class="s0">638 0 0 4 805 3346 0 0 174 /**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a two-parameter</span>
 <span class="s0">* operation.  Specifically, this is everything except for CM_replace and</span>
 <span class="s0">* CM_interpolate.</span>
 <span class="s0">*/ 6 4 this 3 3251  4 mode 1 3245  7 source0 1 3246  8 operand0 1 3247  7 source1 1 3246  8 operand1 1 3247  </span>
<span class="s0">639 0 0 4 805 3346 0 0 139 /**</span>
 <span class="s0">* Specifies any of the CombineMode values that represent a one-parameter</span>
 <span class="s0">* operation.  Specifically, this is CM_interpolate only.</span>
 <span class="s0">*/ 8 4 this 3 3251  4 mode 1 3245  7 source0 1 3246  8 operand0 1 3247  7 source1 1 3246  8 operand1 1 3247  7 source2 1 3246  8 operand2 1 3247  </span>
<span class="s0">640 0 0 6 806 3245 0 0 33 /**</span>
 <span class="s0">* Get combine_alpha_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">641 0 0 6 807 3177 0 0 143 /**</span>
 <span class="s0">* Returns the number of meaningful operands that may be retrieved via</span>
 <span class="s0">* get_combine_alpha_sourceN() and get_combine_alpha_operandN().</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">642 0 0 6 808 3246 0 0 44 /**</span>
 <span class="s0">* Get source0 of combine_alpha_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">643 0 0 6 809 3247 0 0 45 /**</span>
 <span class="s0">* Get operand0 of combine_alpha_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">644 0 0 6 810 3246 0 0 44 /**</span>
 <span class="s0">* Get source1 of combine_alpha_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">645 0 0 6 811 3247 0 0 45 /**</span>
 <span class="s0">* Get operand1 of combine_alpha_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">646 0 0 6 812 3246 0 0 44 /**</span>
 <span class="s0">* Get source2 of combine_alpha_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">647 0 0 6 813 3247 0 0 45 /**</span>
 <span class="s0">* Get operand2 of combine_alpha_mode</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">648 0 0 6 814 3178 0 0 123 /**</span>
 <span class="s0">* Returns true if the TextureStage is affected by the setting of the current</span>
 <span class="s0">* ColorScaleAttrib, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">649 0 0 6 815 3178 0 0 120 /**</span>
 <span class="s0">* Returns true if the TextureStage makes use of whatever color is specified</span>
 <span class="s0">* in set_color(), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">650 0 0 6 816 3178 0 0 96 /**</span>
 <span class="s0">* Returns true if the TextureStage makes use of the CS_primary_color combine</span>
 <span class="s0">* source.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">651 0 0 6 817 3178 0 0 96 /**</span>
 <span class="s0">* Returns true if the TextureStage makes use of the CS_primary_color combine</span>
 <span class="s0">* source.</span>
 <span class="s0">*/ 1 4 this 3 3465  </span>
<span class="s0">652 0 0 6 818 3178 0 0 0 2 4 this 3 3465  5 other 1 3465  </span>
<span class="s0">653 0 0 6 819 3178 0 0 0 2 4 this 3 3465  5 other 1 3465  </span>
<span class="s0">654 0 0 6 820 3178 0 0 0 2 4 this 3 3465  5 other 1 3465  </span>
<span class="s0">655 0 0 6 821 3177 0 0 267 /**</span>
 <span class="s0">* Returns a number less than zero if this TextureStage sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">* The sorting order is arbitrary and largely meaningless, except to</span>
 <span class="s0">* differentiate different stages.</span>
 <span class="s0">*/ 2 4 this 3 3465  5 other 1 3465  </span>
<span class="s0">656 0 0 4 822 3346 0 0 43 /**</span>
 <span class="s0">* Writes the details of this stage</span>
 <span class="s0">*/ 2 4 this 3 3465  3 out 1 3347  </span>
<span class="s0">657 0 0 4 822 3346 0 0 43 /**</span>
 <span class="s0">* Writes the details of this stage</span>
 <span class="s0">*/ 3 4 this 3 3465  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">658 0 0 4 823 3346 0 0 36 /**</span>
 <span class="s0">* Just a single line output</span>
 <span class="s0">*/ 2 4 this 3 3465  3 out 1 3347  </span>
<span class="s0">659 0 0 7 824 3251 0 0 180 /**</span>
 <span class="s0">* Returns the default TextureStage that will be used for all texturing that</span>
 <span class="s0">* does not name a particular stage.  This generally handles the normal</span>
 <span class="s0">* single-texture case.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">660 0 0 7 842 3362 0 0 0 0 </span>
<span class="s0">661 0 0 7 848 3257 2260 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 data 1 3368  </span>
<span class="s0">662 0 0 7 849 3257 2260 0 0 2 4 this 3 3257  4 copy 1 3468  </span>
<span class="s0">663 0 0 4 851 3346 0 0 0 2 4 this 3 3257  4 size 1 3209  </span>
<span class="s0">664 0 0 7 854 3257 2260 0 200 /**</span>
 <span class="s0">* Returns a newly-allocated Geom that is a shallow copy of this one.  It will</span>
 <span class="s0">* be a different Geom pointer, but its internal data may or may not be shared</span>
 <span class="s0">* with that of the original Geom.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">665 0 0 6 855 3172 0 0 361 /**</span>
 <span class="s0">* Returns the fundamental primitive type that is common to all GeomPrimitives</span>
 <span class="s0">* added within the Geom.  All nested primitives within a particular Geom must</span>
 <span class="s0">* be the same type (that is, you can mix triangles and tristrips, because</span>
 <span class="s0">* they are both the same fundamental type PT_polygons, but you cannot mix</span>
 <span class="s0">* triangles and points withn the same Geom).</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">666 0 0 6 856 3171 0 0 118 /**</span>
 <span class="s0">* Returns the shade model common to all of the individual GeomPrimitives that</span>
 <span class="s0">* have been added to the geom.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">667 0 0 6 857 3177 0 0 130 /**</span>
 <span class="s0">* Returns the set of GeomRendering bits that represent the rendering</span>
 <span class="s0">* properties required to properly render this Geom.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">668 0 0 6 861 3169 0 0 189 /**</span>
 <span class="s0">* Returns the minimum (i.e.  most dynamic) usage_hint among all of the</span>
 <span class="s0">* individual GeomPrimitives that have been added to the geom.</span>
 <span class="s0">* @deprecated  This is no longer very useful.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">669 0 0 4 862 3346 0 0 273 /**</span>
 <span class="s0">* Changes the UsageHint hint for all of the primitives on this Geom to the</span>
 <span class="s0">* same value.  See get_usage_hint().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3257  10 usage_hint 1 3169  </span>
<span class="s0">670 0 0 7 863 3368 0 0 146 /**</span>
 <span class="s0">* Returns a const pointer to the GeomVertexData, for application code to</span>
 <span class="s0">* directly examine (but not modify) the geom's underlying data.</span>
 <span class="s0">*/ 2 4 this 3 3468  14 current_thread 5 3399  </span>
<span class="s0">671 0 0 7 864 3441 2051 0 294 /**</span>
 <span class="s0">* Returns a modifiable pointer to the GeomVertexData, so that application</span>
 <span class="s0">* code may directly maniuplate the geom's underlying data.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">672 0 0 4 865 3346 0 0 243 /**</span>
 <span class="s0">* Replaces the Geom's underlying vertex data table with a completely new</span>
 <span class="s0">* table.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3257  4 data 1 3368  </span>
<span class="s0">673 0 0 4 866 3346 0 0 501 /**</span>
 <span class="s0">* Replaces a Geom's vertex table with a new table, and simultaneously adds</span>
 <span class="s0">* the indicated offset to all vertex references within the Geom's primitives.</span>
 <span class="s0">* This is intended to be used to combine multiple GeomVertexDatas from</span>
 <span class="s0">* different Geoms into a single big buffer, with each Geom referencing a</span>
 <span class="s0">* subset of the vertices in the buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 3 4 this 3 3257  4 data 1 3368  6 offset 1 3177  </span>
<span class="s0">674 0 0 6 867 3177 0 0 414 /**</span>
 <span class="s0">* Converts the geom from indexed to nonindexed by duplicating vertices as</span>
 <span class="s0">* necessary.  If composite_only is true, then only composite primitives such</span>
 <span class="s0">* as trifans and tristrips are converted.  Returns the number of</span>
 <span class="s0">* GeomPrimitive objects converted.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3257  14 composite_only 1 3178  </span>
<span class="s0">675 0 0 7 868 3368 0 0 865 /**</span>
 <span class="s0">* Returns a GeomVertexData that represents the results of computing the</span>
 <span class="s0">* vertex animation on the CPU for this Geom's vertex data.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is no CPU-defined vertex animation on this object, this just</span>
 <span class="s0">* returns the original object.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is vertex animation, but the VertexTransform values have not</span>
 <span class="s0">* changed since last time, this may return the same pointer it returned</span>
 <span class="s0">* previously.  Even if the VertexTransform values have changed, it may still</span>
 <span class="s0">* return the same pointer, but with its contents modified (this is preferred,</span>
 <span class="s0">* since it allows the graphics backend to update vertex buffers optimally).</span>
 <span class="s0">*</span>
 <span class="s0">* If force is false, this method may return immediately with stale data, if</span>
 <span class="s0">* the vertex data is not completely resident.  If force is true, this method</span>
 <span class="s0">* will never return stale data, but may block until the data is available.</span>
 <span class="s0">*/ 3 4 this 3 3468  5 force 1 3178  14 current_thread 5 3399  </span>
<span class="s0">676 0 0 6 869 3178 0 0 120 /**</span>
 <span class="s0">* Returns true if there appear to be no vertices to be rendered by this Geom,</span>
 <span class="s0">* false if has some actual data.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">677 0 0 6 870 3209 0 0 151 /**</span>
 <span class="s0">* Returns the number of GeomPrimitive objects stored within the Geom, each of</span>
 <span class="s0">* which represents a number of primitives of a particular type.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">678 0 0 7 871 3454 0 0 211 /**</span>
 <span class="s0">* Returns a const pointer to the ith GeomPrimitive object stored within the</span>
 <span class="s0">* Geom.  Use this call only to inspect the ith object; use modify_primitive()</span>
 <span class="s0">* or set_primitive() if you want to modify it.</span>
 <span class="s0">*/ 2 4 this 3 3468  1 i 1 3209  </span>
<span class="s0">679 0 0 7 873 3453 2124 0 331 /**</span>
 <span class="s0">* Returns a modifiable pointer to the ith GeomPrimitive object stored within</span>
 <span class="s0">* the Geom, so application code can directly manipulate the properties of</span>
 <span class="s0">* this primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3257  1 i 1 3209  </span>
<span class="s0">680 0 0 4 874 3346 0 0 247 /**</span>
 <span class="s0">* Replaces the ith GeomPrimitive object stored within the Geom with the new</span>
 <span class="s0">* object.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 3 4 this 3 3257  1 i 1 3209  9 primitive 1 3454  </span>
<span class="s0">681 0 0 4 875 3346 0 0 342 /**</span>
 <span class="s0">* Inserts a new GeomPrimitive structure to the Geom object.  This specifies a</span>
 <span class="s0">* particular subset of vertices that are used to define geometric primitives</span>
 <span class="s0">* of the indicated type.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 3 4 this 3 3257  1 i 1 3209  9 primitive 1 3454  </span>
<span class="s0">682 0 0 4 876 3346 0 0 342 /**</span>
 <span class="s0">* Inserts a new GeomPrimitive structure to the Geom object.  This specifies a</span>
 <span class="s0">* particular subset of vertices that are used to define geometric primitives</span>
 <span class="s0">* of the indicated type.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3257  9 primitive 1 3454  </span>
<span class="s0">683 0 0 4 877 3346 0 0 203 /**</span>
 <span class="s0">* Removes the ith primitive from the list.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3257  1 i 1 3209  </span>
<span class="s0">684 0 0 4 878 3346 0 0 332 /**</span>
 <span class="s0">* Removes all the primitives from the Geom object (but keeps the same table</span>
 <span class="s0">* of vertices).  You may then re-add primitives one at a time via calls to</span>
 <span class="s0">* add_primitive().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">685 0 0 7 881 3257 2260 0 118 /**</span>
 <span class="s0">* Decomposes all of the primitives within this Geom, returning the result.</span>
 <span class="s0">* See GeomPrimitive::decompose().</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">686 0 0 7 882 3257 2260 0 120 /**</span>
 <span class="s0">* Doublesides all of the primitives within this Geom, returning the result.</span>
 <span class="s0">* See GeomPrimitive::doubleside().</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">687 0 0 7 883 3257 2260 0 115 /**</span>
 <span class="s0">* Reverses all of the primitives within this Geom, returning the result.  See</span>
 <span class="s0">* GeomPrimitive::reverse().</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">688 0 0 7 884 3257 2260 0 113 /**</span>
 <span class="s0">* Rotates all of the primitives within this Geom, returning the result.  See</span>
 <span class="s0">* GeomPrimitive::rotate().</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">689 0 0 7 885 3257 2260 0 541 /**</span>
 <span class="s0">* Unifies all of the primitives contained within this Geom into a single (or</span>
 <span class="s0">* as few as possible, within the constraints of max_indices) primitive</span>
 <span class="s0">* objects.  This may require decomposing the primitives if, for instance, the</span>
 <span class="s0">* Geom contains both triangle strips and triangle fans.</span>
 <span class="s0">*</span>
 <span class="s0">* max_indices represents the maximum number of indices that will be put in</span>
 <span class="s0">* any one GeomPrimitive.  If preserve_order is true, then the primitives will</span>
 <span class="s0">* not be reordered during the operation, even if this results in a suboptimal</span>
 <span class="s0">* result.</span>
 <span class="s0">*/ 3 4 this 3 3468  11 max_indices 1 3177  14 preserve_order 1 3178  </span>
<span class="s0">690 0 0 7 886 3257 2260 0 100 /**</span>
 <span class="s0">* Returns a new Geom with points at all the vertices.  See</span>
 <span class="s0">* GeomPrimitive::make_points().</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">691 0 0 7 887 3257 2260 0 95 /**</span>
 <span class="s0">* Returns a new Geom with lines at all the edges.  See</span>
 <span class="s0">* GeomPrimitive::make_lines().</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">692 0 0 7 888 3257 2260 0 102 /**</span>
 <span class="s0">* Returns a new Geom with each primitive converted into a patch.  Calls</span>
 <span class="s0">* decompose() first.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">693 0 0 7 889 3257 2260 0 139 /**</span>
 <span class="s0">* Returns a new Geom with each primitive converted into a corresponding</span>
 <span class="s0">* version with adjacency information.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">694 0 0 4 890 3346 0 0 279 /**</span>
 <span class="s0">* Decomposes all of the primitives within this Geom, leaving the results in</span>
 <span class="s0">* place.  See GeomPrimitive::decompose().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">695 0 0 4 891 3346 0 0 281 /**</span>
 <span class="s0">* Doublesides all of the primitives within this Geom, leaving the results in</span>
 <span class="s0">* place.  See GeomPrimitive::doubleside().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">696 0 0 4 892 3346 0 0 275 /**</span>
 <span class="s0">* Reverses all of the primitives within this Geom, leaving the results in</span>
 <span class="s0">* place.  See GeomPrimitive::reverse().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">697 0 0 4 893 3346 0 0 273 /**</span>
 <span class="s0">* Rotates all of the primitives within this Geom, leaving the results in</span>
 <span class="s0">* place.  See GeomPrimitive::rotate().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">698 0 0 4 894 3346 0 0 693 /**</span>
 <span class="s0">* Unifies all of the primitives contained within this Geom into a single (or</span>
 <span class="s0">* as few as possible, within the constraints of max_indices) primitive</span>
 <span class="s0">* objects.  This may require decomposing the primitives if, for instance, the</span>
 <span class="s0">* Geom contains both triangle strips and triangle fans.</span>
 <span class="s0">*</span>
 <span class="s0">* max_indices represents the maximum number of indices that will be put in</span>
 <span class="s0">* any one GeomPrimitive.  If preserve_order is true, then the primitives will</span>
 <span class="s0">* not be reordered during the operation, even if this results in a suboptimal</span>
 <span class="s0">* result.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 3 4 this 3 3257  11 max_indices 1 3177  14 preserve_order 1 3178  </span>
<span class="s0">699 0 0 4 895 3346 0 0 275 /**</span>
 <span class="s0">* Replaces the GeomPrimitives within this Geom with corresponding GeomPoints.</span>
 <span class="s0">* See GeomPrimitive::make_points().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">700 0 0 4 896 3346 0 0 321 /**</span>
 <span class="s0">* Replaces the GeomPrimitives within this Geom with corresponding GeomLines,</span>
 <span class="s0">* representing a wireframe of the primitives.  See</span>
 <span class="s0">* GeomPrimitive::make_lines().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">701 0 0 4 897 3346 0 0 278 /**</span>
 <span class="s0">* Replaces the GeomPrimitives within this Geom with corresponding</span>
 <span class="s0">* GeomPatches.  See GeomPrimitive::make_patches().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">702 0 0 4 898 3346 0 0 324 /**</span>
 <span class="s0">* Replaces the GeomPrimitives within this Geom with corresponding versions</span>
 <span class="s0">* with adjacency information.  See GeomPrimitive::make_adjacency().</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">703 0 0 6 899 3178 0 0 451 /**</span>
 <span class="s0">* Copies the primitives from the indicated Geom into this one.  This does</span>
 <span class="s0">* require that both Geoms contain the same fundamental type primitives, both</span>
 <span class="s0">* have a compatible shade model, and both use the same GeomVertexData.  Both</span>
 <span class="s0">* Geoms must also be the same specific class type (i.e.  if one is a</span>
 <span class="s0">* GeomTextGlyph, they both must be.)</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the copy is successful, or false otherwise (because the</span>
 <span class="s0">* Geoms were mismatched).</span>
 <span class="s0">*/ 2 4 this 3 3257  5 other 1 3468  </span>
<span class="s0">704 0 0 6 900 3177 0 0 119 /**</span>
 <span class="s0">* Returns the number of bytes consumed by the geom and its primitives (but</span>
 <span class="s0">* not including its vertex table).</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">705 0 0 7 901 3398 0 0 281 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* any of the primitives in the Geom is modified, or the set of primitives is</span>
 <span class="s0">* modified.  However, this does not include modifications to the vertex data,</span>
 <span class="s0">* which should be tested separately.</span>
 <span class="s0">*/ 2 4 this 3 3468  14 current_thread 5 3399  </span>
<span class="s0">706 0 0 6 904 3178 0 0 286 /**</span>
 <span class="s0">* Returns true if all the primitive arrays are currently resident in memory.</span>
 <span class="s0">* If this returns false, the data will be brought back into memory shortly;</span>
 <span class="s0">* try again later.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not also test the Geom's associated GeomVertexData.  That must be</span>
 <span class="s0">* tested separately.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">707 0 0 4 905 3346 0 0 477 /**</span>
 <span class="s0">* Applies the indicated transform to all of the vertices in the Geom.  If the</span>
 <span class="s0">* Geom happens to share a vertex table with another Geom, this operation will</span>
 <span class="s0">* duplicate the vertex table instead of breaking the other Geom; however, if</span>
 <span class="s0">* multiple Geoms with shared tables are transformed by the same matrix, they</span>
 <span class="s0">* will no longer share tables after the operation.  Consider using the</span>
 <span class="s0">* GeomTransformer if you will be applying the same transform to multiple</span>
 <span class="s0">* Geoms.</span>
 <span class="s0">*/ 2 4 this 3 3257  3 mat 1 3418  </span>
<span class="s0">708 0 0 6 906 3178 0 0 209 /**</span>
 <span class="s0">* Verifies that the all of the primitives within the geom reference vertices</span>
 <span class="s0">* that actually exist within the geom's GeomVertexData.  Returns true if the</span>
 <span class="s0">* geom appears to be valid, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">709 0 0 6 906 3178 0 0 212 /**</span>
 <span class="s0">* Verifies that the all of the primitives within the geom reference vertices</span>
 <span class="s0">* that actually exist within the indicated GeomVertexData.  Returns true if</span>
 <span class="s0">* the geom appears to be valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3468  11 vertex_data 1 3368  </span>
<span class="s0">710 0 0 7 907 3471 0 0 52 /**</span>
 <span class="s0">* Returns the bounding volume for the Geom.</span>
 <span class="s0">*/ 2 4 this 3 3468  14 current_thread 5 3399  </span>
<span class="s0">711 0 0 6 908 3177 0 0 85 /**</span>
 <span class="s0">* Returns the number of vertices rendered by all primitives within the Geom.</span>
 <span class="s0">*/ 2 4 this 3 3468  14 current_thread 5 3399  </span>
<span class="s0">712 0 0 4 909 3346 0 0 147 /**</span>
 <span class="s0">* Marks the bounding volume of the Geom as stale so that it should be</span>
 <span class="s0">* recomputed.  Usually it is not necessary to call this explicitly.</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">713 0 0 4 910 3346 0 0 594 /**</span>
 <span class="s0">* Specifies the desired type of bounding volume that will be created for this</span>
 <span class="s0">* Geom.  This is normally BoundingVolume::BT_default, which means to set the</span>
 <span class="s0">* type according to the config variable &quot;bounds-type&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is BT_sphere or BT_box, a BoundingSphere or BoundingBox is</span>
 <span class="s0">* explicitly created.  If it is BT_best, a BoundingBox is created.</span>
 <span class="s0">*</span>
 <span class="s0">* This affects the implicit bounding volume only.  If an explicit bounding</span>
 <span class="s0">* volume is set on the Geom with set_bounds(), that bounding volume type is</span>
 <span class="s0">* used.  (This is different behavior from the similar method on PandaNode.)</span>
 <span class="s0">*/ 2 4 this 3 3257  11 bounds_type 1 3254  </span>
<span class="s0">714 0 0 6 911 3254 0 0 71 /**</span>
 <span class="s0">* Returns the bounding volume type set with set_bounds_type().</span>
 <span class="s0">*/ 1 4 this 3 3468  </span>
<span class="s0">715 0 0 4 912 3346 0 0 417 /**</span>
 <span class="s0">* Resets the bounding volume so that it is the indicated volume.  When it is</span>
 <span class="s0">* explicitly set, the bounding volume will no longer be automatically</span>
 <span class="s0">* computed; call clear_bounds() if you would like to return the bounding</span>
 <span class="s0">* volume to its default behavior.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3257  6 volume 1 3471  </span>
<span class="s0">716 0 0 4 913 3346 0 0 317 /**</span>
 <span class="s0">* Reverses the effect of a previous call to set_bounds(), and allows the</span>
 <span class="s0">* bounding volume to be automatically computed once more based on the</span>
 <span class="s0">* vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">717 0 0 4 917 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3468  3 out 1 3347  </span>
<span class="s0">718 0 0 4 918 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3468  3 out 1 3347  12 indent_level 5 3177  </span>
<span class="s0">719 0 0 4 919 3346 0 0 263 /**</span>
 <span class="s0">* Removes all of the previously-cached results of munge_geom().</span>
 <span class="s0">*</span>
 <span class="s0">* This blows away the entire cache, upstream and downstream the pipeline.</span>
 <span class="s0">* Use clear_cache_stage() instead if you only want to blow away the cache at</span>
 <span class="s0">* the current stage and upstream.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">720 0 0 4 920 3346 0 0 310 /**</span>
 <span class="s0">* Removes all of the previously-cached results of munge_geom(), at the</span>
 <span class="s0">* current pipeline stage and upstream.  Does not affect the downstream cache.</span>
 <span class="s0">*</span>
 <span class="s0">* Don't call this in a downstream thread unless you don't mind it blowing</span>
 <span class="s0">* away other changes you might have recently made in an upstream thread.</span>
 <span class="s0">*/ 2 4 this 3 3257  14 current_thread 1 3399  </span>
<span class="s0">721 0 0 4 921 3346 0 0 351 /**</span>
 <span class="s0">* Indicates that the geom should be enqueued to be prepared in the indicated</span>
 <span class="s0">* prepared_objects at the beginning of the next frame.  This will ensure the</span>
 <span class="s0">* geom is already loaded into geom memory if it is expected to be rendered</span>
 <span class="s0">* soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload geoms from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/ 2 4 this 3 3257  16 prepared_objects 1 3404  </span>
<span class="s0">722 0 0 6 922 3178 0 0 131 /**</span>
 <span class="s0">* Returns true if the geom has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3468  16 prepared_objects 1 3404  </span>
<span class="s0">723 0 0 6 923 3178 0 0 154 /**</span>
 <span class="s0">* Frees the geom context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/ 2 4 this 3 3257  16 prepared_objects 1 3404  </span>
<span class="s0">724 0 0 6 924 3177 0 0 149 /**</span>
 <span class="s0">* Frees the context allocated on all objects for which the geom has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/ 1 4 this 3 3257  </span>
<span class="s0">725 0 0 6 925 3472 0 0 519 /**</span>
 <span class="s0">* Creates a context for the geom on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) GeomContext.  This assumes that</span>
 <span class="s0">* the GraphicsStateGuardian is the currently active rendering context and</span>
 <span class="s0">* that it is ready to accept new geoms.  If this is not necessarily the case,</span>
 <span class="s0">* you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a geom does not need to be explicitly prepared by the user before it may be</span>
 <span class="s0">* rendered.</span>
 <span class="s0">*/ 3 4 this 3 3257  16 prepared_objects 1 3404  3 gsg 1 3405  </span>
<span class="s0">726 0 0 7 926 3362 0 0 0 0 </span>
<span class="s0">727 0 0 7 844 3411 0 0 0 1 4 this 3 3257  </span>
<span class="s0">728 0 0 6 846 3353 0 0 0 1 4 this 3 3257  </span>
<span class="s0">729 0 0 7 928 3257 2260 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3473  </span>
<span class="s0">730 0 0 7 931 3362 0 0 0 0 </span>
<span class="s0">731 0 0 7 934 3475 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">732 0 0 15 934 3475 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3476  </span>
<span class="s0">733 0 0 4 935 3346 0 0 0 2 4 this 3 3475  4 size 1 3209  </span>
<span class="s0">734 0 0 7 938 3362 0 0 0 0 </span>
<span class="s0">735 0 0 7 940 3478 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">736 0 0 15 940 3478 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3479  </span>
<span class="s0">737 0 0 4 941 3346 0 0 0 2 4 this 3 3478  4 size 1 3209  </span>
<span class="s0">738 0 0 7 944 3362 0 0 0 0 </span>
<span class="s0">739 0 0 7 946 3481 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">740 0 0 15 946 3481 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3482  </span>
<span class="s0">741 0 0 4 947 3346 0 0 0 2 4 this 3 3481  4 size 1 3209  </span>
<span class="s0">742 0 0 7 950 3362 0 0 0 0 </span>
<span class="s0">743 0 0 7 952 3484 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">744 0 0 15 952 3484 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3485  </span>
<span class="s0">745 0 0 4 953 3346 0 0 0 2 4 this 3 3484  4 size 1 3209  </span>
<span class="s0">746 0 0 7 956 3362 0 0 0 0 </span>
<span class="s0">747 0 0 15 958 3489 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3487  </span>
<span class="s0">748 0 0 7 958 3489 2124 0 240 /**</span>
 <span class="s0">* The number of vertices per patch must be specified to the GeomPatches</span>
 <span class="s0">* constructor, and it may not be changed during the lifetime of the</span>
 <span class="s0">* GeomPatches object.  Create a new GeomPatches if you need to have a</span>
 <span class="s0">* different value.</span>
 <span class="s0">*/ 2 22 num_vertices_per_patch 1 3177  10 usage_hint 1 3169  </span>
<span class="s0">749 0 0 4 959 3346 0 0 0 2 4 this 3 3489  4 size 1 3209  </span>
<span class="s0">750 0 0 7 962 3362 0 0 0 0 </span>
<span class="s0">751 0 0 7 964 3490 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">752 0 0 15 964 3490 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3491  </span>
<span class="s0">753 0 0 4 965 3346 0 0 0 2 4 this 3 3490  4 size 1 3209  </span>
<span class="s0">754 0 0 7 968 3362 0 0 0 0 </span>
<span class="s0">755 0 0 7 970 3493 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">756 0 0 15 970 3493 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3494  </span>
<span class="s0">757 0 0 4 971 3346 0 0 0 2 4 this 3 3493  4 size 1 3209  </span>
<span class="s0">758 0 0 7 974 3362 0 0 0 0 </span>
<span class="s0">759 0 0 7 976 3496 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">760 0 0 15 976 3496 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3497  </span>
<span class="s0">761 0 0 4 977 3346 0 0 0 2 4 this 3 3496  4 size 1 3209  </span>
<span class="s0">762 0 0 7 980 3362 0 0 0 0 </span>
<span class="s0">763 0 0 7 982 3499 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">764 0 0 15 982 3499 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3500  </span>
<span class="s0">765 0 0 4 983 3346 0 0 0 2 4 this 3 3499  4 size 1 3209  </span>
<span class="s0">766 0 0 7 986 3362 0 0 0 0 </span>
<span class="s0">767 0 0 7 988 3502 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">768 0 0 15 988 3502 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3503  </span>
<span class="s0">769 0 0 4 989 3346 0 0 0 2 4 this 3 3502  4 size 1 3209  </span>
<span class="s0">770 0 0 7 992 3362 0 0 0 0 </span>
<span class="s0">771 0 0 7 994 3505 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 10 usage_hint 1 3169  </span>
<span class="s0">772 0 0 15 994 3505 2124 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3506  </span>
<span class="s0">773 0 0 4 995 3346 0 0 0 2 4 this 3 3505  4 size 1 3209  </span>
<span class="s0">774 0 0 7 998 3362 0 0 0 0 </span>
<span class="s0">775 0 0 23 1000 3508 2386 0 90 /**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/ 2 10 array_data 1 3365  14 current_thread 5 3399  </span>
<span class="s0">776 0 0 23 1000 3508 2386 0 90 /**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/ 3 10 array_data 1 3365  6 column 1 3177  14 current_thread 5 3399  </span>
<span class="s0">777 0 0 23 1000 3508 2386 0 171 /**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated data</span>
 <span class="s0">* object.  This flavor creates the reader specifically to process the named</span>
 <span class="s0">* data type.</span>
 <span class="s0">*/ 3 11 vertex_data 1 3368  4 name 1 3193  14 current_thread 5 3399  </span>
<span class="s0">778 0 0 23 1000 3508 2386 0 91 /**</span>
 <span class="s0">* Constructs a new reader to process the vertices of the indicated data</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 2 11 vertex_data 1 3368  14 current_thread 5 3399  </span>
<span class="s0">779 0 0 15 1000 3508 2386 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3509  </span>
<span class="s0">780 0 0 23 1000 3508 2386 0 167 /**</span>
 <span class="s0">* Constructs an invalid GeomVertexReader.  You must use the assignment</span>
 <span class="s0">* operator to assign a valid GeomVertexReader to this object before you can</span>
 <span class="s0">* use it.</span>
 <span class="s0">*/ 1 14 current_thread 5 3399  </span>
<span class="s0">781 0 0 6 1001 3508 0 0 0 2 4 this 3 3508  4 copy 1 3509  </span>
<span class="s0">782 0 0 7 1003 3368 0 0 155 /**</span>
 <span class="s0">* Returns the vertex data object that the reader is processing.  This may</span>
 <span class="s0">* return NULL if the reader was constructed with just an array pointer.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">783 0 0 7 1004 3365 0 0 90 /**</span>
 <span class="s0">* Returns the particular array object that the reader is currently</span>
 <span class="s0">* processing.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">784 0 0 7 1005 3402 0 0 146 /**</span>
 <span class="s0">* Returns the read handle to the array object that the read is currently</span>
 <span class="s0">* processing.  This low-level call should be used with caution.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">785 0 0 6 1006 3209 0 0 197 /**</span>
 <span class="s0">* Returns the per-row stride (bytes between consecutive rows) of the</span>
 <span class="s0">* underlying vertex array.  This low-level information is normally not needed</span>
 <span class="s0">* to use the GeomVertexReader directly.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">786 0 0 7 1007 3399 0 0 120 /**</span>
 <span class="s0">* Returns the Thread pointer of the currently-executing thread, as passed to</span>
 <span class="s0">* the constructor of this object.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">787 0 0 4 1008 3346 0 0 563 /**</span>
 <span class="s0">* Sets the value of the force flag.  When this is true (the default), vertex</span>
 <span class="s0">* data will be paged in from disk if necessary.  When this is false, the</span>
 <span class="s0">* GeomVertexData will simply return a failure code when attempting to read</span>
 <span class="s0">* vertex data that is not resident (but will put it on the queue to become</span>
 <span class="s0">* resident later).</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, vertex data is always resident, so this will not be an issue.  It</span>
 <span class="s0">* is only possible for vertex data to be nonresident if you have enabled</span>
 <span class="s0">* vertex paging via the GeomVertexArrayData and VertexDataPage interfaces.</span>
 <span class="s0">*/ 2 4 this 3 3508  5 force 1 3178  </span>
<span class="s0">788 0 0 6 1009 3178 0 0 65 /**</span>
 <span class="s0">* Returns the value of the force flag.  See set_force().</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">789 0 0 6 1010 3178 0 0 309 /**</span>
 <span class="s0">* Sets up the reader to use the data type with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the read row number to the start row (the same value</span>
 <span class="s0">* passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3508  4 name 1 3193  </span>
<span class="s0">790 0 0 6 1010 3178 0 0 334 /**</span>
 <span class="s0">* Sets up the reader to use the nth data type of the GeomVertexFormat,</span>
 <span class="s0">* numbering from 0.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the read row number to the start row (the same value</span>
 <span class="s0">* passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3508  6 column 1 3177  </span>
<span class="s0">791 0 0 6 1010 3178 0 0 334 /**</span>
 <span class="s0">* Sets up the reader to use the indicated column description on the given</span>
 <span class="s0">* array.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the current read row number to the start row (the same</span>
 <span class="s0">* value passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 3508  5 array 1 3177  6 column 1 3187  </span>
<span class="s0">792 0 0 4 1011 3346 0 0 60 /**</span>
 <span class="s0">* Resets the GeomVertexReader to the initial state.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">793 0 0 6 1012 3178 0 0 183 /**</span>
 <span class="s0">* Returns true if a valid data type has been successfully set, or false if</span>
 <span class="s0">* the data type does not exist (or if get_force() is false and the vertex</span>
 <span class="s0">* data is nonresident).</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">794 0 0 6 1013 3177 0 0 93 /**</span>
 <span class="s0">* Returns the array index containing the data type that the reader is working</span>
 <span class="s0">* on.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">795 0 0 6 1014 3187 0 0 82 /**</span>
 <span class="s0">* Returns the description of the data type that the reader is working on.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">796 0 0 4 1015 3346 0 0 344 /**</span>
 <span class="s0">* Sets the start row to the indicated value, without internal checks.  This</span>
 <span class="s0">* is the same as set_row(), but it does not check for the possibility that</span>
 <span class="s0">* the array has been reallocated internally for some reason; use only when</span>
 <span class="s0">* you are confident that the array is unchanged and you really need every bit</span>
 <span class="s0">* of available performance.</span>
 <span class="s0">*/ 2 4 this 3 3508  3 row 1 3177  </span>
<span class="s0">797 0 0 4 1016 3346 0 0 260 /**</span>
 <span class="s0">* Sets the start row to the indicated value.  The reader will begin reading</span>
 <span class="s0">* from the indicated row; each subsequent get_data*() call will return the</span>
 <span class="s0">* data from the subsequent row.  If set_column() is called, the reader will</span>
 <span class="s0">* return to this row.</span>
 <span class="s0">*/ 2 4 this 3 3508  3 row 1 3177  </span>
<span class="s0">798 0 0 6 1017 3177 0 0 125 /**</span>
 <span class="s0">* Returns the row index at which the reader started.  It will return to this</span>
 <span class="s0">* row if you reset the current column.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">799 0 0 6 1018 3177 0 0 106 /**</span>
 <span class="s0">* Returns the row index from which the data will be retrieved by the next</span>
 <span class="s0">* call to get_data*().</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">800 0 0 6 1019 3178 0 0 179 /**</span>
 <span class="s0">* Returns true if the reader is currently at the end of the list of vertices,</span>
 <span class="s0">* false otherwise.  If this is true, another call to get_data*() will result</span>
 <span class="s0">* in a crash.</span>
 <span class="s0">*/ 1 4 this 3 3509  </span>
<span class="s0">801 0 0 6 1020 3221 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 1-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">802 0 0 6 1021 3511 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 2-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">803 0 0 6 1022 3513 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 3-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">804 0 0 6 1023 3515 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 4-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">805 0 0 7 1024 3518 0 0 210 /**</span>
 <span class="s0">* Returns the 3-by-3 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">806 0 0 7 1025 3519 0 0 210 /**</span>
 <span class="s0">* Returns the 4-by-4 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">807 0 0 6 1026 3520 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 1-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">808 0 0 6 1027 3521 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 2-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">809 0 0 6 1028 3524 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 3-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">810 0 0 6 1029 3527 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 4-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">811 0 0 7 1030 3531 0 0 210 /**</span>
 <span class="s0">* Returns the 3-by-3 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">812 0 0 7 1031 3533 0 0 210 /**</span>
 <span class="s0">* Returns the 4-by-4 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">813 0 0 6 1032 3220 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 1-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">814 0 0 6 1033 3534 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 2-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">815 0 0 6 1034 3535 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 3-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">816 0 0 6 1035 3442 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 4-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">817 0 0 7 1036 3537 0 0 210 /**</span>
 <span class="s0">* Returns the 3-by-3 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">818 0 0 7 1037 3417 0 0 210 /**</span>
 <span class="s0">* Returns the 4-by-4 matrix associated with the read row and advances the</span>
 <span class="s0">* read row.  This is a special method that only works when the column in</span>
 <span class="s0">* question contains a matrix of an appropriate size.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">819 0 0 6 1038 3177 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 1-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">820 0 0 6 1039 3538 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 2-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">821 0 0 6 1040 3541 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 3-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">822 0 0 6 1041 3544 0 0 121 /**</span>
 <span class="s0">* Returns the data associated with the read row, expressed as a 4-component</span>
 <span class="s0">* value, and advances the read row.</span>
 <span class="s0">*/ 1 4 this 3 3508  </span>
<span class="s0">823 0 0 4 1042 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3509  3 out 1 3347  </span>
<span class="s0">824 0 0 23 1044 3547 2429 0 90 /**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/ 2 10 array_data 1 3213  14 current_thread 5 3399  </span>
<span class="s0">825 0 0 23 1044 3547 2429 0 90 /**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/ 3 10 array_data 1 3213  6 column 1 3177  14 current_thread 5 3399  </span>
<span class="s0">826 0 0 23 1044 3547 2429 0 171 /**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated data</span>
 <span class="s0">* object.  This flavor creates the writer specifically to process the named</span>
 <span class="s0">* data type.</span>
 <span class="s0">*/ 3 11 vertex_data 1 3441  4 name 1 3193  14 current_thread 5 3399  </span>
<span class="s0">827 0 0 23 1044 3547 2429 0 91 /**</span>
 <span class="s0">* Constructs a new writer to process the vertices of the indicated data</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 2 11 vertex_data 1 3441  14 current_thread 5 3399  </span>
<span class="s0">828 0 0 15 1044 3547 2429 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3548  </span>
<span class="s0">829 0 0 23 1044 3547 2429 0 167 /**</span>
 <span class="s0">* Constructs an invalid GeomVertexWriter.  You must use the assignment</span>
 <span class="s0">* operator to assign a valid GeomVertexWriter to this object before you can</span>
 <span class="s0">* use it.</span>
 <span class="s0">*/ 1 14 current_thread 5 3399  </span>
<span class="s0">830 0 0 6 1045 3547 0 0 0 2 4 this 3 3547  4 copy 1 3548  </span>
<span class="s0">831 0 0 7 1047 3441 2051 0 155 /**</span>
 <span class="s0">* Returns the vertex data object that the writer is processing.  This may</span>
 <span class="s0">* return NULL if the writer was constructed with just an array pointer.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">832 0 0 7 1048 3213 1897 0 90 /**</span>
 <span class="s0">* Returns the particular array object that the writer is currently</span>
 <span class="s0">* processing.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">833 0 0 7 1049 3403 1934 0 238 /**</span>
 <span class="s0">* Returns the write handle to the array object that the writer is currently</span>
 <span class="s0">* processing.  This low-level call should be used with caution; be careful</span>
 <span class="s0">* with modifying the data in the handle out from under the GeomVertexWriter.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">834 0 0 6 1050 3209 0 0 197 /**</span>
 <span class="s0">* Returns the per-row stride (bytes between consecutive rows) of the</span>
 <span class="s0">* underlying vertex array.  This low-level information is normally not needed</span>
 <span class="s0">* to use the GeomVertexWriter directly.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">835 0 0 7 1051 3399 0 0 120 /**</span>
 <span class="s0">* Returns the Thread pointer of the currently-executing thread, as passed to</span>
 <span class="s0">* the constructor of this object.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">836 0 0 6 1052 3178 0 0 303 /**</span>
 <span class="s0">* Sets up the writer to use the data type with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the write number to the start row (the same value passed</span>
 <span class="s0">* to a previous call to set_row(), or 0 if set_row() was never called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 name 1 3193  </span>
<span class="s0">837 0 0 6 1052 3178 0 0 335 /**</span>
 <span class="s0">* Sets up the writer to use the nth data type of the GeomVertexFormat,</span>
 <span class="s0">* numbering from 0.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the write row number to the start row (the same value</span>
 <span class="s0">* passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3547  6 column 1 3177  </span>
<span class="s0">838 0 0 6 1052 3178 0 0 335 /**</span>
 <span class="s0">* Sets up the writer to use the indicated column description on the given</span>
 <span class="s0">* array.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets the current write row number to the start row (the same</span>
 <span class="s0">* value passed to a previous call to set_row(), or 0 if set_row() was never</span>
 <span class="s0">* called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 3547  5 array 1 3177  6 column 1 3187  </span>
<span class="s0">839 0 0 4 1053 3346 0 0 60 /**</span>
 <span class="s0">* Resets the GeomVertexWriter to the initial state.</span>
 <span class="s0">*/ 1 4 this 3 3547  </span>
<span class="s0">840 0 0 6 1054 3178 0 0 297 /**</span>
 <span class="s0">* This ensures that enough memory space for num_rows is allocated, so that</span>
 <span class="s0">* you may add up to num_rows rows without causing a new memory allocation.</span>
 <span class="s0">* This is a performance optimization only; it is especially useful when you</span>
 <span class="s0">* know the number of rows you will be adding ahead of time.</span>
 <span class="s0">*/ 2 4 this 3 3547  8 num_rows 1 3177  </span>
<span class="s0">841 0 0 6 1055 3178 0 0 116 /**</span>
 <span class="s0">* Returns true if a valid data type has been successfully set, or false if</span>
 <span class="s0">* the data type does not exist.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">842 0 0 6 1056 3177 0 0 93 /**</span>
 <span class="s0">* Returns the array index containing the data type that the writer is working</span>
 <span class="s0">* on.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">843 0 0 6 1057 3187 0 0 82 /**</span>
 <span class="s0">* Returns the description of the data type that the writer is working on.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">844 0 0 4 1058 3346 0 0 344 /**</span>
 <span class="s0">* Sets the start row to the indicated value, without internal checks.  This</span>
 <span class="s0">* is the same as set_row(), but it does not check for the possibility that</span>
 <span class="s0">* the array has been reallocated internally for some reason; use only when</span>
 <span class="s0">* you are confident that the array is unchanged and you really need every bit</span>
 <span class="s0">* of available performance.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 row 1 3177  </span>
<span class="s0">845 0 0 4 1059 3346 0 0 257 /**</span>
 <span class="s0">* Sets the start row to the indicated value.  The writer will begin writing</span>
 <span class="s0">* to the indicated row; each subsequent set_data*() call will store the data</span>
 <span class="s0">* into the subsequent row.  If set_column() is called, the writer will return</span>
 <span class="s0">* to this row.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 row 1 3177  </span>
<span class="s0">846 0 0 6 1060 3177 0 0 125 /**</span>
 <span class="s0">* Returns the row index at which the writer started.  It will return to this</span>
 <span class="s0">* row if you reset the current column.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">847 0 0 6 1061 3177 0 0 117 /**</span>
 <span class="s0">* Returns the row index to which the data will be written at the next call to</span>
 <span class="s0">* set_data*() or add_data*().</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">848 0 0 6 1062 3178 0 0 231 /**</span>
 <span class="s0">* Returns true if the writer is currently at the end of the list of vertices,</span>
 <span class="s0">* false otherwise.  If this is true, another call to set_data*() will result</span>
 <span class="s0">* in a crash, but another call to add_data*() will add a new row.</span>
 <span class="s0">*/ 1 4 this 3 3548  </span>
<span class="s0">849 0 0 4 1063 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3221  </span>
<span class="s0">850 0 0 4 1064 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3511  </span>
<span class="s0">851 0 0 4 1064 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 3 4 this 3 3547  1 x 1 3221  1 y 1 3221  </span>
<span class="s0">852 0 0 4 1065 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3513  </span>
<span class="s0">853 0 0 4 1065 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 4 4 this 3 3547  1 x 1 3221  1 y 1 3221  1 z 1 3221  </span>
<span class="s0">854 0 0 4 1066 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3515  </span>
<span class="s0">855 0 0 4 1066 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 5 4 this 3 3547  1 x 1 3221  1 y 1 3221  1 z 1 3221  1 w 1 3221  </span>
<span class="s0">856 0 0 4 1067 3346 0 0 219 /**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3550  </span>
<span class="s0">857 0 0 4 1068 3346 0 0 219 /**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3552  </span>
<span class="s0">858 0 0 4 1069 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3520  </span>
<span class="s0">859 0 0 4 1070 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3521  </span>
<span class="s0">860 0 0 4 1070 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 3 4 this 3 3547  1 x 1 3520  1 y 1 3520  </span>
<span class="s0">861 0 0 4 1071 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3524  </span>
<span class="s0">862 0 0 4 1071 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 4 4 this 3 3547  1 x 1 3520  1 y 1 3520  1 z 1 3520  </span>
<span class="s0">863 0 0 4 1072 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3527  </span>
<span class="s0">864 0 0 4 1072 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 5 4 this 3 3547  1 x 1 3520  1 y 1 3520  1 z 1 3520  1 w 1 3520  </span>
<span class="s0">865 0 0 4 1073 3346 0 0 219 /**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3554  </span>
<span class="s0">866 0 0 4 1074 3346 0 0 219 /**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3556  </span>
<span class="s0">867 0 0 4 1075 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3220  </span>
<span class="s0">868 0 0 4 1076 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3534  </span>
<span class="s0">869 0 0 4 1076 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 3 4 this 3 3547  1 x 1 3220  1 y 1 3220  </span>
<span class="s0">870 0 0 4 1077 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3535  </span>
<span class="s0">871 0 0 4 1077 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 4 4 this 3 3547  1 x 1 3220  1 y 1 3220  1 z 1 3220  </span>
<span class="s0">872 0 0 4 1078 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3442  </span>
<span class="s0">873 0 0 4 1078 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 5 4 this 3 3547  1 x 1 3220  1 y 1 3220  1 z 1 3220  1 w 1 3220  </span>
<span class="s0">874 0 0 4 1079 3346 0 0 219 /**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3558  </span>
<span class="s0">875 0 0 4 1080 3346 0 0 219 /**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3418  </span>
<span class="s0">876 0 0 4 1081 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3177  </span>
<span class="s0">877 0 0 4 1082 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3538  </span>
<span class="s0">878 0 0 4 1082 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 3 4 this 3 3547  1 a 1 3177  1 b 1 3177  </span>
<span class="s0">879 0 0 4 1083 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3541  </span>
<span class="s0">880 0 0 4 1083 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 4 4 this 3 3547  1 a 1 3177  1 b 1 3177  1 c 1 3177  </span>
<span class="s0">881 0 0 4 1084 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3544  </span>
<span class="s0">882 0 0 4 1084 3346 0 0 167 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error for the write row to advance past the end of data.</span>
 <span class="s0">*/ 5 4 this 3 3547  1 a 1 3177  1 b 1 3177  1 c 1 3177  1 d 1 3177  </span>
<span class="s0">883 0 0 4 1085 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3221  </span>
<span class="s0">884 0 0 4 1086 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3511  </span>
<span class="s0">885 0 0 4 1086 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 3 4 this 3 3547  1 x 1 3221  1 y 1 3221  </span>
<span class="s0">886 0 0 4 1087 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3513  </span>
<span class="s0">887 0 0 4 1087 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 4 4 this 3 3547  1 x 1 3221  1 y 1 3221  1 z 1 3221  </span>
<span class="s0">888 0 0 4 1088 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3515  </span>
<span class="s0">889 0 0 4 1088 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 5 4 this 3 3547  1 x 1 3221  1 y 1 3221  1 z 1 3221  1 w 1 3221  </span>
<span class="s0">890 0 0 4 1089 3346 0 0 243 /**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3550  </span>
<span class="s0">891 0 0 4 1090 3346 0 0 243 /**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3552  </span>
<span class="s0">892 0 0 4 1091 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3520  </span>
<span class="s0">893 0 0 4 1092 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3521  </span>
<span class="s0">894 0 0 4 1092 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 3 4 this 3 3547  1 x 1 3520  1 y 1 3520  </span>
<span class="s0">895 0 0 4 1093 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3524  </span>
<span class="s0">896 0 0 4 1093 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 4 4 this 3 3547  1 x 1 3520  1 y 1 3520  1 z 1 3520  </span>
<span class="s0">897 0 0 4 1094 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3527  </span>
<span class="s0">898 0 0 4 1094 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 5 4 this 3 3547  1 x 1 3520  1 y 1 3520  1 z 1 3520  1 w 1 3520  </span>
<span class="s0">899 0 0 4 1095 3346 0 0 243 /**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3554  </span>
<span class="s0">900 0 0 4 1096 3346 0 0 243 /**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3556  </span>
<span class="s0">901 0 0 4 1097 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3220  </span>
<span class="s0">902 0 0 4 1098 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3534  </span>
<span class="s0">903 0 0 4 1098 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 3 4 this 3 3547  1 x 1 3220  1 y 1 3220  </span>
<span class="s0">904 0 0 4 1099 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3535  </span>
<span class="s0">905 0 0 4 1099 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 4 4 this 3 3547  1 x 1 3220  1 y 1 3220  1 z 1 3220  </span>
<span class="s0">906 0 0 4 1100 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3442  </span>
<span class="s0">907 0 0 4 1100 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 5 4 this 3 3547  1 x 1 3220  1 y 1 3220  1 z 1 3220  1 w 1 3220  </span>
<span class="s0">908 0 0 4 1101 3346 0 0 243 /**</span>
 <span class="s0">* Sets the write row to a 3-by-3 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3558  </span>
<span class="s0">909 0 0 4 1102 3346 0 0 243 /**</span>
 <span class="s0">* Sets the write row to a 4-by-4 matrix, and advances the write row.  This is</span>
 <span class="s0">* a special method that can only be used on matrix columns.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  3 mat 1 3418  </span>
<span class="s0">910 0 0 4 1103 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 1-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3177  </span>
<span class="s0">911 0 0 4 1104 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3538  </span>
<span class="s0">912 0 0 4 1104 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 2-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 3 4 this 3 3547  1 a 1 3177  1 b 1 3177  </span>
<span class="s0">913 0 0 4 1105 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3541  </span>
<span class="s0">914 0 0 4 1105 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 3-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 4 4 this 3 3547  1 a 1 3177  1 b 1 3177  1 c 1 3177  </span>
<span class="s0">915 0 0 4 1106 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 2 4 this 3 3547  4 data 1 3544  </span>
<span class="s0">916 0 0 4 1106 3346 0 0 191 /**</span>
 <span class="s0">* Sets the write row to a particular 4-component value, and advances the</span>
 <span class="s0">* write row.</span>
 <span class="s0">*</span>
 <span class="s0">* If the write row advances past the end of data, implicitly adds a new row</span>
 <span class="s0">* to the data.</span>
 <span class="s0">*/ 5 4 this 3 3547  1 a 1 3177  1 b 1 3177  1 c 1 3177  1 d 1 3177  </span>
<span class="s0">917 0 0 4 1107 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3548  3 out 1 3347  </span>
<span class="s0">918 0 0 23 1113 3560 2497 0 92 /**</span>
 <span class="s0">* Constructs a new rewriter to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/ 2 10 array_data 1 3213  14 current_thread 5 3399  </span>
<span class="s0">919 0 0 23 1113 3560 2497 0 92 /**</span>
 <span class="s0">* Constructs a new rewriter to process the vertices of the indicated array</span>
 <span class="s0">* only.</span>
 <span class="s0">*/ 3 10 array_data 1 3213  6 column 1 3177  14 current_thread 5 3399  </span>
<span class="s0">920 0 0 23 1113 3560 2497 0 175 /**</span>
 <span class="s0">* Constructs a new rewriter to process the vertices of the indicated data</span>
 <span class="s0">* object.  This flavor creates the rewriter specifically to process the named</span>
 <span class="s0">* data type.</span>
 <span class="s0">*/ 3 11 vertex_data 1 3441  4 name 1 3193  14 current_thread 5 3399  </span>
<span class="s0">921 0 0 23 1113 3560 2497 0 93 /**</span>
 <span class="s0">* Constructs a new rewriter to process the vertices of the indicated data</span>
 <span class="s0">* object.</span>
 <span class="s0">*/ 2 11 vertex_data 1 3441  14 current_thread 5 3399  </span>
<span class="s0">922 0 0 15 1113 3560 2497 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3561  </span>
<span class="s0">923 0 0 23 1113 3560 2497 0 171 /**</span>
 <span class="s0">* Constructs an invalid GeomVertexRewriter.  You must use the assignment</span>
 <span class="s0">* operator to assign a valid GeomVertexRewriter to this object before you can</span>
 <span class="s0">* use it.</span>
 <span class="s0">*/ 1 14 current_thread 5 3399  </span>
<span class="s0">924 0 0 6 1114 3560 0 0 0 2 4 this 3 3560  4 copy 1 3561  </span>
<span class="s0">925 0 0 7 1116 3441 2051 0 74 /**</span>
 <span class="s0">* Returns the vertex data object that the rewriter is processing.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">926 0 0 7 1117 3213 1897 0 92 /**</span>
 <span class="s0">* Returns the particular array object that the rewriter is currently</span>
 <span class="s0">* processing.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">927 0 0 7 1118 3403 1934 0 245 /**</span>
 <span class="s0">* Returns the write handle to the array object that the rewriter is currently</span>
 <span class="s0">* processing.  This low-level call should be used with caution; be careful</span>
 <span class="s0">* with modifying the data in the handle out from under the</span>
 <span class="s0">* GeomVertexRewriter.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">928 0 0 6 1119 3209 0 0 199 /**</span>
 <span class="s0">* Returns the per-row stride (bytes between consecutive rows) of the</span>
 <span class="s0">* underlying vertex array.  This low-level information is normally not needed</span>
 <span class="s0">* to use the GeomVertexRewriter directly.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">929 0 0 7 1120 3399 0 0 120 /**</span>
 <span class="s0">* Returns the Thread pointer of the currently-executing thread, as passed to</span>
 <span class="s0">* the constructor of this object.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">930 0 0 6 1121 3178 0 0 327 /**</span>
 <span class="s0">* Sets up the rewriter to use the data type with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets both the read and write row numbers to the start row (the</span>
 <span class="s0">* same value passed to a previous call to set_row(), or 0 if set_row() was</span>
 <span class="s0">* never called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3560  4 name 1 3193  </span>
<span class="s0">931 0 0 6 1121 3178 0 0 352 /**</span>
 <span class="s0">* Sets up the rewriter to use the nth data type of the GeomVertexFormat,</span>
 <span class="s0">* numbering from 0.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets both the read and write row numbers to the start row (the</span>
 <span class="s0">* same value passed to a previous call to set_row(), or 0 if set_row() was</span>
 <span class="s0">* never called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3560  6 column 1 3177  </span>
<span class="s0">932 0 0 6 1121 3178 0 0 344 /**</span>
 <span class="s0">* Sets up the rewriter to use the indicated column description on the given</span>
 <span class="s0">* array.</span>
 <span class="s0">*</span>
 <span class="s0">* This also resets both the read and write row numbers to the start row (the</span>
 <span class="s0">* same value passed to a previous call to set_row(), or 0 if set_row() was</span>
 <span class="s0">* never called.)</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the data type is valid, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 3560  5 array 1 3177  6 column 1 3187  </span>
<span class="s0">933 0 0 4 1122 3346 0 0 62 /**</span>
 <span class="s0">* Resets the GeomVertexRewriter to the initial state.</span>
 <span class="s0">*/ 1 4 this 3 3560  </span>
<span class="s0">934 0 0 6 1123 3178 0 0 116 /**</span>
 <span class="s0">* Returns true if a valid data type has been successfully set, or false if</span>
 <span class="s0">* the data type does not exist.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">935 0 0 6 1124 3177 0 0 95 /**</span>
 <span class="s0">* Returns the array index containing the data type that the rewriter is</span>
 <span class="s0">* working on.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">936 0 0 6 1125 3187 0 0 84 /**</span>
 <span class="s0">* Returns the description of the data type that the rewriter is working on.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">937 0 0 4 1126 3346 0 0 344 /**</span>
 <span class="s0">* Sets the start row to the indicated value, without internal checks.  This</span>
 <span class="s0">* is the same as set_row(), but it does not check for the possibility that</span>
 <span class="s0">* the array has been reallocated internally for some reason; use only when</span>
 <span class="s0">* you are confident that the array is unchanged and you really need every bit</span>
 <span class="s0">* of available performance.</span>
 <span class="s0">*/ 2 4 this 3 3560  3 row 1 3177  </span>
<span class="s0">938 0 0 4 1127 3346 0 0 132 /**</span>
 <span class="s0">* Sets the start, write, and write index to the indicated value.  The</span>
 <span class="s0">* rewriter will begin traversing from the given row.</span>
 <span class="s0">*/ 2 4 this 3 3560  3 row 1 3177  </span>
<span class="s0">939 0 0 6 1128 3177 0 0 127 /**</span>
 <span class="s0">* Returns the row index at which the rewriter started.  It will return to</span>
 <span class="s0">* this row if you reset the current column.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">940 0 0 6 1129 3178 0 0 116 /**</span>
 <span class="s0">* Returns true if the reader or writer is currently at the end of the list of</span>
 <span class="s0">* vertices, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3561  </span>
<span class="s0">941 0 0 4 1130 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3561  3 out 1 3347  </span>
<span class="s0">942 0 0 6 1109 3547 0 0 0 1 4 this 3 3560  </span>
<span class="s0">943 0 0 6 1111 3508 0 0 0 1 4 this 3 3560  </span>
<span class="s0">944 0 0 7 1134 3563 2552 0 72 /**</span>
 <span class="s0">* Creates a new SamplerState initialized to the default values.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">945 0 0 15 1134 3563 2552 0 0 1 6 param0 0 3564  </span>
<span class="s0">946 0 0 6 1135 3564 0 0 83 /**</span>
 <span class="s0">* Returns a reference to the global default immutable SamplerState object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">947 0 0 4 1136 3346 0 0 221 /**</span>
 <span class="s0">* This setting determines what happens when the SamplerState is sampled with</span>
 <span class="s0">* a U value outside the range 0.0-1.0.  The default is WM_repeat, which</span>
 <span class="s0">* indicates that the SamplerState should repeat indefinitely.</span>
 <span class="s0">*/ 2 4 this 3 3563  4 wrap 1 3274  </span>
<span class="s0">948 0 0 4 1137 3346 0 0 221 /**</span>
 <span class="s0">* This setting determines what happens when the SamplerState is sampled with</span>
 <span class="s0">* a V value outside the range 0.0-1.0.  The default is WM_repeat, which</span>
 <span class="s0">* indicates that the SamplerState should repeat indefinitely.</span>
 <span class="s0">*/ 2 4 this 3 3563  4 wrap 1 3274  </span>
<span class="s0">949 0 0 4 1138 3346 0 0 67 /**</span>
 <span class="s0">* The W wrap direction is only used for 3-d SamplerStates.</span>
 <span class="s0">*/ 2 4 this 3 3563  4 wrap 1 3274  </span>
<span class="s0">950 0 0 4 1139 3346 0 0 106 /**</span>
 <span class="s0">* Sets the filtering method that should be used when viewing the SamplerState</span>
 <span class="s0">* from a distance.</span>
 <span class="s0">*/ 2 4 this 3 3563  6 filter 1 3273  </span>
<span class="s0">951 0 0 4 1140 3346 0 0 99 /**</span>
 <span class="s0">* Sets the filtering method that should be used when viewing the SamplerState</span>
 <span class="s0">* up close.</span>
 <span class="s0">*/ 2 4 this 3 3563  6 filter 1 3273  </span>
<span class="s0">952 0 0 4 1141 3346 0 0 418 /**</span>
 <span class="s0">* Specifies the level of anisotropic filtering to apply to the SamplerState.</span>
 <span class="s0">* Set this 0 to indicate the default value, which is specified in the</span>
 <span class="s0">* SamplerState-anisotropic-degree config variable.</span>
 <span class="s0">*</span>
 <span class="s0">* To explicitly disable anisotropic filtering, set this value to 1.  To</span>
 <span class="s0">* explicitly enable anisotropic filtering, set it to a value higher than 1;</span>
 <span class="s0">* larger numbers indicate greater degrees of filtering.</span>
 <span class="s0">*/ 2 4 this 3 3563  18 anisotropic_degree 1 3177  </span>
<span class="s0">953 0 0 4 1142 3346 0 0 198 /**</span>
 <span class="s0">* Specifies the solid color of the SamplerState's border.  Some OpenGL</span>
 <span class="s0">* implementations use a border for tiling SamplerStates; in Panda, it is only</span>
 <span class="s0">* used for specifying the clamp color.</span>
 <span class="s0">*/ 2 4 this 3 3563  5 color 1 3445  </span>
<span class="s0">954 0 0 4 1143 3346 0 0 123 /**</span>
 <span class="s0">* Sets the minimum level of detail that will be used when sampling this</span>
 <span class="s0">* texture.  This may be a negative value.</span>
 <span class="s0">*/ 2 4 this 3 3563  7 min_lod 1 3220  </span>
<span class="s0">955 0 0 4 1144 3346 0 0 159 /**</span>
 <span class="s0">* Sets the maximum level of detail that will be used when sampling this</span>
 <span class="s0">* texture.  This may exceed the number of mipmap levels that the texture has.</span>
 <span class="s0">*/ 2 4 this 3 3563  7 max_lod 1 3220  </span>
<span class="s0">956 0 0 4 1145 3346 0 0 211 /**</span>
 <span class="s0">* Sets the value that will be added to the level of detail when sampling the</span>
 <span class="s0">* texture.  This may be a negative value, although some graphics hardware may</span>
 <span class="s0">* not support the use of negative LOD values.</span>
 <span class="s0">*/ 2 4 this 3 3563  8 lod_bias 1 3220  </span>
<span class="s0">957 0 0 6 1146 3274 0 0 67 /**</span>
 <span class="s0">* Returns the wrap mode of the texture in the U direction.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">958 0 0 6 1147 3274 0 0 67 /**</span>
 <span class="s0">* Returns the wrap mode of the texture in the V direction.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">959 0 0 6 1148 3274 0 0 116 /**</span>
 <span class="s0">* Returns the wrap mode of the texture in the W direction.  This is the depth</span>
 <span class="s0">* direction of 3-d textures.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">960 0 0 6 1149 3273 0 0 214 /**</span>
 <span class="s0">* Returns the filter mode of the texture for minification.  If this is one of</span>
 <span class="s0">* the mipmap constants, then the texture requires mipmaps.  This may return</span>
 <span class="s0">* FT_default; see also get_effective_minfilter().</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">961 0 0 6 1150 3273 0 0 179 /**</span>
 <span class="s0">* Returns the filter mode of the texture for magnification.  The mipmap</span>
 <span class="s0">* constants are invalid here.  This may return FT_default; see also</span>
 <span class="s0">* get_effective_minfilter().</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">962 0 0 6 1151 3273 0 0 200 /**</span>
 <span class="s0">* Returns the filter mode of the texture for minification, with special</span>
 <span class="s0">* treatment for FT_default.  This will normally not return FT_default, unless</span>
 <span class="s0">* there is an error in the config file.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">963 0 0 6 1152 3273 0 0 201 /**</span>
 <span class="s0">* Returns the filter mode of the texture for magnification, with special</span>
 <span class="s0">* treatment for FT_default.  This will normally not return FT_default, unless</span>
 <span class="s0">* there is an error in the config file.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">964 0 0 6 1153 3177 0 0 198 /**</span>
 <span class="s0">* Returns the degree of anisotropic filtering that should be applied to the</span>
 <span class="s0">* texture.  This value may return 0, indicating the default value; see also</span>
 <span class="s0">* get_effective_anisotropic_degree.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">965 0 0 6 1154 3177 0 0 184 /**</span>
 <span class="s0">* Returns the degree of anisotropic filtering that should be applied to the</span>
 <span class="s0">* texture.  This value will normally not return 0, unless there is an error</span>
 <span class="s0">* in the config file.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">966 0 0 6 1155 3445 0 0 186 /**</span>
 <span class="s0">* Returns the solid color of the texture's border.  Some OpenGL</span>
 <span class="s0">* implementations use a border for tiling textures; in Panda, it is only used</span>
 <span class="s0">* for specifying the clamp color.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">967 0 0 6 1156 3220 0 0 99 /**</span>
 <span class="s0">* Returns the minimum level of detail that will be observed when sampling</span>
 <span class="s0">* this texture.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">968 0 0 6 1157 3220 0 0 99 /**</span>
 <span class="s0">* Returns the maximum level of detail that will be observed when sampling</span>
 <span class="s0">* this texture.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">969 0 0 6 1158 3220 0 0 108 /**</span>
 <span class="s0">* Returns the bias that will be added to the texture level of detail when</span>
 <span class="s0">* sampling this texture.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">970 0 0 6 1173 3178 0 0 117 /**</span>
 <span class="s0">* Returns true if the minfilter settings on this sampler indicate the use of</span>
 <span class="s0">* mipmapping, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3564  </span>
<span class="s0">971 0 0 6 1174 3178 0 0 109 /**</span>
 <span class="s0">* Returns true if the indicated filter type requires the use of mipmaps, or</span>
 <span class="s0">* false if it does not.</span>
 <span class="s0">*/ 1 4 type 1 3273  </span>
<span class="s0">972 0 0 6 1175 3342 0 0 71 /**</span>
 <span class="s0">* Returns the indicated FilterType converted to a string word.</span>
 <span class="s0">*/ 1 2 ft 1 3273  </span>
<span class="s0">973 0 0 6 1176 3273 0 0 165 /**</span>
 <span class="s0">* Returns the FilterType value associated with the given string</span>
 <span class="s0">* representation, or FT_invalid if the string does not match any known</span>
 <span class="s0">* FilterType value.</span>
 <span class="s0">*/ 1 3 str 1 3342  </span>
<span class="s0">974 0 0 6 1177 3342 0 0 69 /**</span>
 <span class="s0">* Returns the indicated WrapMode converted to a string word.</span>
 <span class="s0">*/ 1 2 wm 1 3274  </span>
<span class="s0">975 0 0 6 1178 3274 0 0 158 /**</span>
 <span class="s0">* Returns the WrapMode value associated with the given string representation,</span>
 <span class="s0">* or WM_invalid if the string does not match any known WrapMode value.</span>
 <span class="s0">*/ 1 3 str 1 3342  </span>
<span class="s0">976 0 0 6 1179 3178 0 0 0 2 4 this 3 3564  5 other 1 3564  </span>
<span class="s0">977 0 0 6 1180 3178 0 0 0 2 4 this 3 3564  5 other 1 3564  </span>
<span class="s0">978 0 0 6 1181 3178 0 0 0 2 4 this 3 3564  5 other 1 3564  </span>
<span class="s0">979 0 0 4 1182 3346 0 0 250 /**</span>
 <span class="s0">* Indicates that the sampler should be enqueued to be prepared in the</span>
 <span class="s0">* indicated prepared_objects at the beginning of the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload samplers from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/ 2 4 this 3 3564  16 prepared_objects 1 3404  </span>
<span class="s0">980 0 0 6 1183 3178 0 0 134 /**</span>
 <span class="s0">* Returns true if the sampler has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3564  16 prepared_objects 1 3404  </span>
<span class="s0">981 0 0 4 1184 3346 0 0 157 /**</span>
 <span class="s0">* Frees the texture context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/ 2 4 this 3 3564  16 prepared_objects 1 3404  </span>
<span class="s0">982 0 0 6 1185 3565 0 0 531 /**</span>
 <span class="s0">* Creates a context for the sampler on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) SamplerContext.  This assumes that</span>
 <span class="s0">* the GraphicsStateGuardian is the currently active rendering context and</span>
 <span class="s0">* that it is ready to accept new textures.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a sampler does not need to be explicitly prepared by the user before it may</span>
 <span class="s0">* be rendered.</span>
 <span class="s0">*/ 3 4 this 3 3564  16 prepared_objects 1 3404  3 gsg 1 3405  </span>
<span class="s0">983 0 0 7 1186 3362 0 0 0 0 </span>
<span class="s0">984 0 0 7 1200 3325 2558 0 192 /**</span>
 <span class="s0">* Constructs an empty texture.  The default is to set up the texture as an</span>
 <span class="s0">* empty 2-d texture; follow up with one of the variants of setup_texture() if</span>
 <span class="s0">* this is not what you want.</span>
 <span class="s0">*/ 1 4 name 5 3342  </span>
<span class="s0">985 0 0 7 1202 3325 2558 0 369 /**</span>
 <span class="s0">* Returns a new copy of the same Texture.  This copy, if applied to geometry,</span>
 <span class="s0">* will be copied into texture as a separate texture from the original, so it</span>
 <span class="s0">* will be duplicated in texture memory (and may be independently modified if</span>
 <span class="s0">* desired).</span>
 <span class="s0">*</span>
 <span class="s0">* If the Texture is a VideoTexture, the resulting duplicate may be animated</span>
 <span class="s0">* independently of the original.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">986 0 0 4 1203 3346 0 0 90 /**</span>
 <span class="s0">* Reinitializes the texture to its default, empty state (except for the</span>
 <span class="s0">* name).</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">987 0 0 4 1204 3346 0 0 243 /**</span>
 <span class="s0">* Sets the texture to the indicated type and dimensions, presumably in</span>
 <span class="s0">* preparation for calling read() or load(), or set_ram_image() or</span>
 <span class="s0">* modify_ram_image(), or use set_clear_color to let the texture be cleared to</span>
 <span class="s0">* a solid color.</span>
 <span class="s0">*/ 7 4 this 3 3325  12 texture_type 1 3277  6 x_size 1 3177  6 y_size 1 3177  6 z_size 1 3177  14 component_type 1 3278  6 format 1 3279  </span>
<span class="s0">988 0 0 4 1205 3346 0 0 228 /**</span>
 <span class="s0">* Sets the texture as an empty 1-d texture with no dimensions.  Follow up</span>
 <span class="s0">* with read() or load() to fill the texture properties and image data, or use</span>
 <span class="s0">* set_clear_color to let the texture be cleared to a solid color.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">989 0 0 4 1205 3346 0 0 255 /**</span>
 <span class="s0">* Sets the texture as an empty 1-d texture with the specified dimensions and</span>
 <span class="s0">* properties.  Follow up with set_ram_image() or modify_ram_image() to fill</span>
 <span class="s0">* the image data, or use set_clear_color to let the texture be cleared to a</span>
 <span class="s0">* solid color.</span>
 <span class="s0">*/ 4 4 this 3 3325  6 x_size 1 3177  14 component_type 1 3278  6 format 1 3279  </span>
<span class="s0">990 0 0 4 1206 3346 0 0 228 /**</span>
 <span class="s0">* Sets the texture as an empty 2-d texture with no dimensions.  Follow up</span>
 <span class="s0">* with read() or load() to fill the texture properties and image data, or use</span>
 <span class="s0">* set_clear_color to let the texture be cleared to a solid color.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">991 0 0 4 1206 3346 0 0 255 /**</span>
 <span class="s0">* Sets the texture as an empty 2-d texture with the specified dimensions and</span>
 <span class="s0">* properties.  Follow up with set_ram_image() or modify_ram_image() to fill</span>
 <span class="s0">* the image data, or use set_clear_color to let the texture be cleared to a</span>
 <span class="s0">* solid color.</span>
 <span class="s0">*/ 5 4 this 3 3325  6 x_size 1 3177  6 y_size 1 3177  14 component_type 1 3278  6 format 1 3279  </span>
<span class="s0">992 0 0 4 1207 3346 0 0 313 /**</span>
 <span class="s0">* Sets the texture as an empty 3-d texture with no dimensions (though if you</span>
 <span class="s0">* know the depth ahead of time, it saves a bit of reallocation later). Follow</span>
 <span class="s0">* up with read() or load() to fill the texture properties and image data, or</span>
 <span class="s0">* use set_clear_color to let the texture be cleared to a solid color.</span>
 <span class="s0">*/ 2 4 this 3 3325  6 z_size 5 3177  </span>
<span class="s0">993 0 0 4 1207 3346 0 0 181 /**</span>
 <span class="s0">* Sets the texture as an empty 3-d texture with the specified dimensions and</span>
 <span class="s0">* properties.  Follow up with set_ram_image() or modify_ram_image() to fill</span>
 <span class="s0">* the image data.</span>
 <span class="s0">*/ 6 4 this 3 3325  6 x_size 1 3177  6 y_size 1 3177  6 z_size 1 3177  14 component_type 1 3278  6 format 1 3279  </span>
<span class="s0">994 0 0 4 1208 3346 0 0 233 /**</span>
 <span class="s0">* Sets the texture as an empty cube map texture with no dimensions.  Follow</span>
 <span class="s0">* up with read() or load() to fill the texture properties and image data, or</span>
 <span class="s0">* use set_clear_color to let the texture be cleared to a solid color.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">995 0 0 4 1208 3346 0 0 397 /**</span>
 <span class="s0">* Sets the texture as an empty cube map texture with the specified dimensions</span>
 <span class="s0">* and properties.  Follow up with set_ram_image() or modify_ram_image() to</span>
 <span class="s0">* fill the image data, or use set_clear_color to let the texture be cleared</span>
 <span class="s0">* to a solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that a cube map should always consist of six square images, so x_size</span>
 <span class="s0">* and y_size will be the same, and z_size is always 6.</span>
 <span class="s0">*/ 4 4 this 3 3325  4 size 1 3177  14 component_type 1 3278  6 format 1 3279  </span>
<span class="s0">996 0 0 4 1209 3346 0 0 322 /**</span>
 <span class="s0">* Sets the texture as an empty 2-d texture array with no dimensions (though</span>
 <span class="s0">* if you know the depth ahead of time, it saves a bit of reallocation later).</span>
 <span class="s0">* Follow up with read() or load() to fill the texture properties and image</span>
 <span class="s0">* data, or use set_clear_color to let the texture be cleared to a solid</span>
 <span class="s0">* color.</span>
 <span class="s0">*/ 2 4 this 3 3325  6 z_size 5 3177  </span>
<span class="s0">997 0 0 4 1209 3346 0 0 261 /**</span>
 <span class="s0">* Sets the texture as an empty 2-d texture array with the specified</span>
 <span class="s0">* dimensions and properties.  Follow up with set_ram_image() or</span>
 <span class="s0">* modify_ram_image() to fill the image data, or use set_clear_color to let</span>
 <span class="s0">* the texture be cleared to a solid color.</span>
 <span class="s0">*/ 6 4 this 3 3325  6 x_size 1 3177  6 y_size 1 3177  6 z_size 1 3177  14 component_type 1 3278  6 format 1 3279  </span>
<span class="s0">998 0 0 4 1210 3346 0 0 297 /**</span>
 <span class="s0">* Sets the texture as cube map array with N cube maps.  Note that this number</span>
 <span class="s0">* is not the same as the z_size.  Follow up with read() or load() to fill the</span>
 <span class="s0">* texture properties and image data, or use set_clear_color to let the</span>
 <span class="s0">* texture be cleared to a solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 2 4 this 3 3325  13 num_cube_maps 1 3177  </span>
<span class="s0">999 0 0 4 1210 3346 0 0 376 /**</span>
 <span class="s0">* Sets the texture as cube map array with N cube maps with the specified</span>
 <span class="s0">* dimensions and format.  Follow up with set_ram_image() or</span>
 <span class="s0">* modify_ram_image() to fill the image data, or use set_clear_color to let</span>
 <span class="s0">* the texture be cleared to a solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* The num_cube_maps given here is multiplied by six to become the z_size of</span>
 <span class="s0">* the image.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 5 4 this 3 3325  4 size 1 3177  13 num_cube_maps 1 3177  14 component_type 1 3278  6 format 1 3279  </span>
<span class="s0">1000 0 0 4 1211 3346 0 0 329 /**</span>
 <span class="s0">* Sets the texture as an empty buffer texture with the specified size and</span>
 <span class="s0">* properties.  Follow up with set_ram_image() or modify_ram_image() to fill</span>
 <span class="s0">* the image data, or use set_clear_color to let the texture be cleared to a</span>
 <span class="s0">* solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that a buffer texture's format needs to match the component type.</span>
 <span class="s0">*/ 5 4 this 3 3325  4 size 1 3177  14 component_type 1 3278  6 format 1 3279  5 usage 1 3169  </span>
<span class="s0">1001 0 0 4 1212 3346 0 0 296 /**</span>
 <span class="s0">* Generates a special cube map image in the texture that can be used to apply</span>
 <span class="s0">* bump mapping effects: for each texel in the cube map that is indexed by the</span>
 <span class="s0">* 3-d texture coordinates (x, y, z), the resulting value is the normalized</span>
 <span class="s0">* vector (x, y, z) (compressed from -1..1 into 0..1).</span>
 <span class="s0">*/ 2 4 this 3 3325  4 size 1 3177  </span>
<span class="s0">1002 0 0 4 1213 3346 0 0 253 /**</span>
 <span class="s0">* Generates a special 256x1 1-d texture that can be used to apply an</span>
 <span class="s0">* arbitrary alpha scale to objects by judicious use of texture matrix.  The</span>
 <span class="s0">* texture is a gradient, with an alpha of 0 on the left (U = 0), and 255 on</span>
 <span class="s0">* the right (U = 1).</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1003 0 0 4 1214 3346 0 0 445 /**</span>
 <span class="s0">* Clears the texture data without changing its format or resolution.  The</span>
 <span class="s0">* texture is cleared on both the graphics hardware and from RAM, unlike</span>
 <span class="s0">* clear_ram_image, which only removes the data from RAM.</span>
 <span class="s0">*</span>
 <span class="s0">* If a clear color has been specified using set_clear_color, the texture will</span>
 <span class="s0">* be cleared using a solid color.</span>
 <span class="s0">*</span>
 <span class="s0">* The texture data will be cleared the first time in which the texture is</span>
 <span class="s0">* used after this method is called.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1004 0 0 6 1215 3178 0 0 76 /**</span>
 <span class="s0">* Returns true if a color was previously set using set_clear_color.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1005 0 0 7 1216 3467 0 0 75 /**</span>
 <span class="s0">* Returns the color that was previously set using set_clear_color.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1006 0 0 4 1217 3346 0 0 359 /**</span>
 <span class="s0">* Sets the color that will be used to fill the texture image in absence of</span>
 <span class="s0">* any image data.  It is used when any of the setup_texture functions or</span>
 <span class="s0">* clear_image is called and image data is not provided using read() or</span>
 <span class="s0">* modify_ram_image().</span>
 <span class="s0">*</span>
 <span class="s0">* This does not affect a texture that has already been cleared; call</span>
 <span class="s0">* clear_image to clear it again.</span>
 <span class="s0">*/ 2 4 this 3 3325  5 color 1 3445  </span>
<span class="s0">1007 0 0 4 1218 3346 0 0 161 /**</span>
 <span class="s0">* The opposite of set_clear_color.  If the image is cleared after setting</span>
 <span class="s0">* this, its contents may be undefined (or may in fact not be cleared at all).</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1008 0 0 6 1219 3412 0 0 94 /**</span>
 <span class="s0">* Returns the raw image data for a single pixel if it were set to the clear</span>
 <span class="s0">* color.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1009 0 0 6 1221 3178 0 0 241 /**</span>
 <span class="s0">* Combine a 3-component image with a grayscale image to get a 4-component</span>
 <span class="s0">* image.</span>
 <span class="s0">*</span>
 <span class="s0">* See the description of the full-parameter read() method for the meaning of</span>
 <span class="s0">* the primary_file_num_channels and alpha_file_channel parameters.</span>
 <span class="s0">*/ 6 4 this 3 3325  8 fullpath 1 3569  14 alpha_fullpath 1 3569  25 primary_file_num_channels 1 3177  18 alpha_file_channel 1 3177  7 options 5 3570  </span>
<span class="s0">1010 0 0 6 1221 3178 0 0 2873 /**</span>
 <span class="s0">* Reads the texture from the indicated filename.  If</span>
 <span class="s0">* primary_file_num_channels is not 0, it specifies the number of components</span>
 <span class="s0">* to downgrade the image to if it is greater than this number.</span>
 <span class="s0">*</span>
 <span class="s0">* If the filename has the extension .txo, this implicitly reads a texture</span>
 <span class="s0">* object instead of a filename (which replaces all of the texture</span>
 <span class="s0">* properties).  In this case, all the rest of the parameters are ignored, and</span>
 <span class="s0">* the filename should not contain any hash marks; just the one named file</span>
 <span class="s0">* will be read, since a single .txo file can contain all pages and mipmaps</span>
 <span class="s0">* necessary to define a texture.</span>
 <span class="s0">*</span>
 <span class="s0">* If alpha_fullpath is not empty, it specifies the name of a file from which</span>
 <span class="s0">* to retrieve the alpha.  In this case, alpha_file_channel represents the</span>
 <span class="s0">* numeric channel of this image file to use as the resulting texture's alpha</span>
 <span class="s0">* channel; usually, this is 0 to indicate the grayscale combination of r, g,</span>
 <span class="s0">* b; or it may be a one-based channel number, e.g.  1 for the red channel, 2</span>
 <span class="s0">* for the green channel, and so on.</span>
 <span class="s0">*</span>
 <span class="s0">* If read pages is false, then z indicates the page number into which this</span>
 <span class="s0">* image will be assigned.  Normally this is 0 for the first (or only) page of</span>
 <span class="s0">* the texture.  3-D textures have one page for each level of depth, and cube</span>
 <span class="s0">* map textures always have six pages.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_pages is true, multiple images will be read at once, one for each</span>
 <span class="s0">* page of a cube map or a 3-D texture.  In this case, the filename should</span>
 <span class="s0">* contain a sequence of one or more hash marks (&quot;#&quot;) which will be filled in</span>
 <span class="s0">* with the z value of each page, zero-based.  In this case, the z parameter</span>
 <span class="s0">* indicates the maximum z value that will be loaded, or 0 to load all</span>
 <span class="s0">* filenames that exist.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is false, then n indicates the mipmap level to which this</span>
 <span class="s0">* image will be assigned.  Normally this is 0 for the base texture image, but</span>
 <span class="s0">* it is possible to load custom mipmap levels into the later images.  After</span>
 <span class="s0">* the base texture image is loaded (thus defining the size of the texture),</span>
 <span class="s0">* you can call get_expected_num_mipmap_levels() to determine the maximum</span>
 <span class="s0">* sensible value for n.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, multiple images will be read as above, but this</span>
 <span class="s0">* time the images represent the different mipmap levels of the texture image.</span>
 <span class="s0">* In this case, the n parameter indicates the maximum n value that will be</span>
 <span class="s0">* loaded, or 0 to load all filenames that exist (up to the expected number of</span>
 <span class="s0">* mipmap levels).</span>
 <span class="s0">*</span>
 <span class="s0">* If both read_pages and read_mipmaps is true, then both sequences will be</span>
 <span class="s0">* read; the filename should contain two sequences of hash marks, separated by</span>
 <span class="s0">* some character such as a hyphen, underscore, or dot.  The first hash mark</span>
 <span class="s0">* sequence will be filled in with the mipmap level, while the second hash</span>
 <span class="s0">* mark sequence will be the page index.</span>
 <span class="s0">*</span>
 <span class="s0">* This method implicitly sets keep_ram_image to false.</span>
 <span class="s0">*/ 11 4 this 3 3325  8 fullpath 1 3569  14 alpha_fullpath 1 3569  25 primary_file_num_channels 1 3177  18 alpha_file_channel 1 3177  1 z 1 3177  1 n 1 3177  10 read_pages 1 3178  12 read_mipmaps 1 3178  6 record 5 3573  7 options 5 3570  </span>
<span class="s0">1011 0 0 6 1221 3178 0 0 53 /**</span>
 <span class="s0">* Reads the named filename into the texture.</span>
 <span class="s0">*/ 3 4 this 3 3325  8 fullpath 1 3569  7 options 5 3570  </span>
<span class="s0">1012 0 0 6 1221 3178 0 0 263 /**</span>
 <span class="s0">* Reads a single file into a single page or mipmap level, or automatically</span>
 <span class="s0">* reads a series of files into a series of pages and/or mipmap levels.</span>
 <span class="s0">*</span>
 <span class="s0">* See the description of the full-parameter read() method for the meaning of</span>
 <span class="s0">* the various parameters.</span>
 <span class="s0">*/ 7 4 this 3 3325  8 fullpath 1 3569  1 z 1 3177  1 n 1 3177  10 read_pages 1 3178  12 read_mipmaps 1 3178  7 options 5 3570  </span>
<span class="s0">1013 0 0 6 1222 3178 0 0 52 /**</span>
 <span class="s0">* Writes the texture to the named filename.</span>
 <span class="s0">*/ 2 4 this 3 3325  8 fullpath 1 3569  </span>
<span class="s0">1014 0 0 6 1222 3178 0 0 2253 /**</span>
 <span class="s0">* Writes a single page or mipmap level to a single file, or automatically</span>
 <span class="s0">* writes a series of pages and/or mipmap levels to a numbered series of</span>
 <span class="s0">* files.</span>
 <span class="s0">*</span>
 <span class="s0">* If the filename ends in the extension .txo, this implicitly writes a Panda</span>
 <span class="s0">* texture object (.txo) instead of an image file.  In this case, the</span>
 <span class="s0">* remaining parameters are ignored, and only one file is written, which will</span>
 <span class="s0">* contain all of the pages and resident mipmap levels in the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* If write_pages is false, then z indicates the page number to write.  3-D</span>
 <span class="s0">* textures have one page number for each level of depth; cube maps have six</span>
 <span class="s0">* pages number 0 through 5.  Other kinds of textures have only one page,</span>
 <span class="s0">* numbered 0.  If there are multiple views, the range of z is increased; the</span>
 <span class="s0">* total range is [0, get_num_pages()).</span>
 <span class="s0">*</span>
 <span class="s0">* If write_pages is true, then all pages of the texture will be written.  In</span>
 <span class="s0">* this case z is ignored, and the filename should contain a sequence of hash</span>
 <span class="s0">* marks (&quot;#&quot;) which will be filled in with the page index number.</span>
 <span class="s0">*</span>
 <span class="s0">* If write_mipmaps is false, then n indicates the mipmap level number to</span>
 <span class="s0">* write.  Normally, this is 0, for the base texture image.  Normally, the</span>
 <span class="s0">* mipmap levels of a texture are not available in RAM (they are generated</span>
 <span class="s0">* automatically by the graphics card). However, if you have the mipmap levels</span>
 <span class="s0">* available, for instance because you called generate_ram_mipmap_images() to</span>
 <span class="s0">* generate them internally, or you called</span>
 <span class="s0">* GraphicsEngine::extract_texture_data() to retrieve them from the graphics</span>
 <span class="s0">* card, then you may write out each mipmap level with this parameter.</span>
 <span class="s0">*</span>
 <span class="s0">* If write_mipmaps is true, then all mipmap levels of the texture will be</span>
 <span class="s0">* written.  In this case n is ignored, and the filename should contain a</span>
 <span class="s0">* sequence of hash marks (&quot;#&quot;) which will be filled in with the mipmap level</span>
 <span class="s0">* number.</span>
 <span class="s0">*</span>
 <span class="s0">* If both write_pages and write_mipmaps is true, then all pages and all</span>
 <span class="s0">* mipmap levels will be written.  In this case, the filename should contain</span>
 <span class="s0">* two different sequences of hash marks, separated by a character such as a</span>
 <span class="s0">* hyphen, underscore, or dot.  The first hash mark sequence will be filled in</span>
 <span class="s0">* with the mipmap level, while the second hash mark sequence will be the page</span>
 <span class="s0">* index.</span>
 <span class="s0">*/ 6 4 this 3 3325  8 fullpath 1 3569  1 z 1 3177  1 n 1 3177  11 write_pages 1 3178  13 write_mipmaps 1 3178  </span>
<span class="s0">1015 0 0 4 1222 3346 0 0 107 /**</span>
 <span class="s0">* Not to be confused with write(Filename), this method simply describes the</span>
 <span class="s0">* texture properties.</span>
 <span class="s0">*/ 3 4 this 3 3567  3 out 1 3347  12 indent_level 1 3177  </span>
<span class="s0">1016 0 0 6 1223 3178 0 0 380 /**</span>
 <span class="s0">* Reads the texture from a Panda texture object.  This defines the complete</span>
 <span class="s0">* Texture specification, including the image data as well as all texture</span>
 <span class="s0">* properties.  This only works if the txo file contains a static Texture</span>
 <span class="s0">* image, as opposed to a subclass of Texture such as a movie texture.</span>
 <span class="s0">*</span>
 <span class="s0">* Pass a real filename if it is available, or empty string if it is not.</span>
 <span class="s0">*/ 3 4 this 3 3325  2 in 1 3575  8 filename 5 3342  </span>
<span class="s0">1017 0 0 7 1224 3325 2558 0 310 /**</span>
 <span class="s0">* Constructs a new Texture object from the txo file.  This is similar to</span>
 <span class="s0">* Texture::read_txo(), but it constructs and returns a new object, which</span>
 <span class="s0">* allows it to return a subclass of Texture (for instance, a movie texture).</span>
 <span class="s0">*</span>
 <span class="s0">* Pass a real filename if it is available, or empty string if it is not.</span>
 <span class="s0">*/ 2 2 in 1 3575  8 filename 5 3342  </span>
<span class="s0">1018 0 0 6 1225 3178 0 0 214 /**</span>
 <span class="s0">* Writes the texture to a Panda texture object.  This defines the complete</span>
 <span class="s0">* Texture specification, including the image data as well as all texture</span>
 <span class="s0">* properties.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename is just for reference.</span>
 <span class="s0">*/ 3 4 this 3 3567  3 out 1 3347  8 filename 5 3342  </span>
<span class="s0">1019 0 0 6 1226 3178 0 0 381 /**</span>
 <span class="s0">* Reads the texture from a DDS file object.  This is a Microsoft-defined file</span>
 <span class="s0">* format; it is similar in principle to a txo object, in that it is designed</span>
 <span class="s0">* to contain the texture image in a form as similar as possible to its</span>
 <span class="s0">* runtime image, and it can contain mipmaps, pre-compressed textures, and so</span>
 <span class="s0">* on.</span>
 <span class="s0">*</span>
 <span class="s0">* As with read_txo, the filename is just for reference.</span>
 <span class="s0">*/ 4 4 this 3 3325  2 in 1 3575  8 filename 5 3342  11 header_only 5 3178  </span>
<span class="s0">1020 0 0 6 1227 3178 0 0 379 /**</span>
 <span class="s0">* Reads the texture from a KTX file object.  This is a Khronos-defined file</span>
 <span class="s0">* format; it is similar in principle to a dds object, in that it is designed</span>
 <span class="s0">* to contain the texture image in a form as similar as possible to its</span>
 <span class="s0">* runtime image, and it can contain mipmaps, pre-compressed textures, and so</span>
 <span class="s0">* on.</span>
 <span class="s0">*</span>
 <span class="s0">* As with read_dds, the filename is just for reference.</span>
 <span class="s0">*/ 4 4 this 3 3325  2 in 1 3575  8 filename 5 3342  11 header_only 5 3178  </span>
<span class="s0">1021 0 0 6 1228 3178 0 0 57 /**</span>
 <span class="s0">* Replaces the texture with the indicated image.</span>
 <span class="s0">*/ 3 4 this 3 3325  8 pnmimage 1 3577  7 options 5 3570  </span>
<span class="s0">1022 0 0 6 1228 3178 0 0 86 /**</span>
 <span class="s0">* Stores the indicated image in the given page and mipmap level.  See read().</span>
 <span class="s0">*/ 5 4 this 3 3325  8 pnmimage 1 3577  1 z 1 3177  1 n 1 3177  7 options 5 3570  </span>
<span class="s0">1023 0 0 6 1228 3178 0 0 57 /**</span>
 <span class="s0">* Replaces the texture with the indicated image.</span>
 <span class="s0">*/ 3 4 this 3 3325  3 pfm 1 3580  7 options 5 3570  </span>
<span class="s0">1024 0 0 6 1228 3178 0 0 86 /**</span>
 <span class="s0">* Stores the indicated image in the given page and mipmap level.  See read().</span>
 <span class="s0">*/ 5 4 this 3 3325  3 pfm 1 3580  1 z 1 3177  1 n 1 3177  7 options 5 3570  </span>
<span class="s0">1025 0 0 6 1229 3178 0 0 328 /**</span>
 <span class="s0">* Stores the indicated image in a region of the texture.  The texture</span>
 <span class="s0">* properties remain unchanged.  This can be more efficient than updating an</span>
 <span class="s0">* entire texture, but has a few restrictions: for one, you must ensure that</span>
 <span class="s0">* the texture is still in RAM (eg.  using set_keep_ram_image) and it may not</span>
 <span class="s0">* be compressed.</span>
 <span class="s0">*/ 6 4 this 3 3325  8 pnmimage 1 3577  1 x 1 3177  1 y 1 3177  1 z 5 3177  1 n 5 3177  </span>
<span class="s0">1026 0 0 6 1230 3178 0 0 86 /**</span>
 <span class="s0">* Saves the texture to the indicated PNMImage, but does not write it to disk.</span>
 <span class="s0">*/ 2 4 this 3 3567  8 pnmimage 1 3583  </span>
<span class="s0">1027 0 0 6 1230 3178 0 0 84 /**</span>
 <span class="s0">* Saves the indicated page and mipmap level of the texture to the PNMImage.</span>
 <span class="s0">*/ 4 4 this 3 3567  8 pnmimage 1 3583  1 z 1 3177  1 n 1 3177  </span>
<span class="s0">1028 0 0 6 1230 3178 0 0 85 /**</span>
 <span class="s0">* Saves the texture to the indicated PfmFile, but does not write it to disk.</span>
 <span class="s0">*/ 2 4 this 3 3567  3 pfm 1 3584  </span>
<span class="s0">1029 0 0 6 1230 3178 0 0 83 /**</span>
 <span class="s0">* Saves the indicated page and mipmap level of the texture to the PfmFile.</span>
 <span class="s0">*/ 4 4 this 3 3567  3 pfm 1 3584  1 z 1 3177  1 n 1 3177  </span>
<span class="s0">1030 0 0 6 1231 3178 0 0 269 /**</span>
 <span class="s0">* Re-reads the Texture from its disk file.  Useful when you know the image on</span>
 <span class="s0">* disk has recently changed, and you want to update the Texture image.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure (in which case, the Texture may</span>
 <span class="s0">* or may not still be valid).</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1031 0 0 7 1232 3325 2558 0 189 /**</span>
 <span class="s0">* Loads a texture whose filename is derived by concatenating a suffix to the</span>
 <span class="s0">* filename of this texture.  May return NULL, for example, if this texture</span>
 <span class="s0">* doesn't have a filename.</span>
 <span class="s0">*/ 2 4 this 3 3567  6 suffix 1 3193  </span>
<span class="s0">1032 0 0 6 1233 3178 0 0 94 /**</span>
 <span class="s0">* Returns true if the filename has been set and is available.  See</span>
 <span class="s0">* set_filename().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1033 0 0 6 1234 3569 0 0 130 /**</span>
 <span class="s0">* Returns the filename that has been set.  This is the name of the file as it</span>
 <span class="s0">* was requested.  Also see get_fullpath().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1034 0 0 4 1235 3346 0 0 376 /**</span>
 <span class="s0">* Sets the name of the file that contains the image's contents.  Normally,</span>
 <span class="s0">* this is set automatically when the image is loaded, for instance via</span>
 <span class="s0">* Texture::read().</span>
 <span class="s0">*</span>
 <span class="s0">* The Texture's get_name() function used to return the filename, but now</span>
 <span class="s0">* returns just the basename (without the extension), which is a more useful</span>
 <span class="s0">* name for identifying an image in show code.</span>
 <span class="s0">*/ 2 4 this 3 3325  8 filename 1 3569  </span>
<span class="s0">1035 0 0 4 1236 3346 0 0 85 /**</span>
 <span class="s0">* Removes the alpha filename, if it was previously set.  See set_filename().</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1036 0 0 6 1240 3178 0 0 106 /**</span>
 <span class="s0">* Returns true if the alpha_filename has been set and is available.  See</span>
 <span class="s0">* set_alpha_filename().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1037 0 0 6 1241 3569 0 0 214 /**</span>
 <span class="s0">* Returns the alpha_filename that has been set.  If this is set, it</span>
 <span class="s0">* represents the name of the alpha component, which is stored in a separate</span>
 <span class="s0">* file.  See also get_filename(), and get_alpha_fullpath().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1038 0 0 4 1242 3346 0 0 549 /**</span>
 <span class="s0">* Sets the name of the file that contains the image's alpha channel contents.</span>
 <span class="s0">* Normally, this is set automatically when the image is loaded, for instance</span>
 <span class="s0">* via Texture::read().</span>
 <span class="s0">*</span>
 <span class="s0">* The Texture's get_filename() function returns the name of the image file</span>
 <span class="s0">* that was loaded into the buffer.  In the case where a texture specified two</span>
 <span class="s0">* separate files to load, a 1- or 3-channel color image and a 1-channel alpha</span>
 <span class="s0">* image, this Filename is update to contain the name of the image file that</span>
 <span class="s0">* was loaded into the buffer's alpha channel.</span>
 <span class="s0">*/ 2 4 this 3 3325  14 alpha_filename 1 3569  </span>
<span class="s0">1039 0 0 4 1243 3346 0 0 94 /**</span>
 <span class="s0">* Removes the alpha filename, if it was previously set.  See</span>
 <span class="s0">* set_alpha_filename().</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1040 0 0 6 1245 3178 0 0 94 /**</span>
 <span class="s0">* Returns true if the fullpath has been set and is available.  See</span>
 <span class="s0">* set_fullpath().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1041 0 0 6 1246 3569 0 0 135 /**</span>
 <span class="s0">* Returns the fullpath that has been set.  This is the full path to the file</span>
 <span class="s0">* as it was found along the texture search path.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1042 0 0 4 1247 3346 0 0 216 /**</span>
 <span class="s0">* Sets the full pathname to the file that contains the image's contents, as</span>
 <span class="s0">* found along the search path.  Normally, this is set automatically when the</span>
 <span class="s0">* image is loaded, for instance via Texture::read().</span>
 <span class="s0">*/ 2 4 this 3 3325  8 fullpath 1 3569  </span>
<span class="s0">1043 0 0 4 1248 3346 0 0 85 /**</span>
 <span class="s0">* Removes the alpha fullpath, if it was previously set.  See set_fullpath().</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1044 0 0 6 1250 3178 0 0 106 /**</span>
 <span class="s0">* Returns true if the alpha_fullpath has been set and is available.  See</span>
 <span class="s0">* set_alpha_fullpath().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1045 0 0 6 1251 3569 0 0 168 /**</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the alpha_fullpath that has been set.  This is the full path to the</span>
 <span class="s0">* alpha part of the image file as it was found along the texture search path.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1046 0 0 4 1252 3346 0 0 230 /**</span>
 <span class="s0">* Sets the full pathname to the file that contains the image's alpha channel</span>
 <span class="s0">* contents, as found along the search path.  Normally, this is set</span>
 <span class="s0">* automatically when the image is loaded, for instance via Texture::read().</span>
 <span class="s0">*/ 2 4 this 3 3325  14 alpha_fullpath 1 3569  </span>
<span class="s0">1047 0 0 4 1253 3346 0 0 94 /**</span>
 <span class="s0">* Removes the alpha fullpath, if it was previously set.  See</span>
 <span class="s0">* set_alpha_fullpath().</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1048 0 0 6 1255 3177 0 0 60 /**</span>
 <span class="s0">* Returns the width of the texture image in texels.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1049 0 0 4 1256 3346 0 0 132 /**</span>
 <span class="s0">* Changes the x size indicated for the texture.  This also implicitly unloads</span>
 <span class="s0">* the texture if it has already been loaded.</span>
 <span class="s0">*/ 2 4 this 3 3325  6 x_size 1 3177  </span>
<span class="s0">1050 0 0 6 1258 3177 0 0 100 /**</span>
 <span class="s0">* Returns the height of the texture image in texels.  For a 1-d texture, this</span>
 <span class="s0">* will be 1.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1051 0 0 4 1259 3346 0 0 132 /**</span>
 <span class="s0">* Changes the y size indicated for the texture.  This also implicitly unloads</span>
 <span class="s0">* the texture if it has already been loaded.</span>
 <span class="s0">*/ 2 4 this 3 3325  6 y_size 1 3177  </span>
<span class="s0">1052 0 0 6 1261 3177 0 0 154 /**</span>
 <span class="s0">* Returns the depth of the texture image in texels.  For a 1-d texture or 2-d</span>
 <span class="s0">* texture, this will be 1. For a cube map texture, this will be 6.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1053 0 0 4 1262 3346 0 0 132 /**</span>
 <span class="s0">* Changes the z size indicated for the texture.  This also implicitly unloads</span>
 <span class="s0">* the texture if it has already been loaded.</span>
 <span class="s0">*/ 2 4 this 3 3325  6 z_size 1 3177  </span>
<span class="s0">1054 0 0 6 1264 3177 0 0 426 /**</span>
 <span class="s0">* Returns the number of &quot;views&quot; in the texture.  A view is a completely</span>
 <span class="s0">* separate image stored within the Texture object.  Most textures have only</span>
 <span class="s0">* one view, but a stereo texture, for instance, may have two views, a left</span>
 <span class="s0">* and a right image.  Other uses for multiple views are not yet defined.</span>
 <span class="s0">*</span>
 <span class="s0">* If this value is greater than one, the additional views are accessed as</span>
 <span class="s0">* additional pages beyond get_z_size().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1055 0 0 4 1265 3346 0 0 503 /**</span>
 <span class="s0">* Sets the number of &quot;views&quot; within a texture.  A view is a completely</span>
 <span class="s0">* separate image stored within the Texture object.  Most textures have only</span>
 <span class="s0">* one view, but a stereo texture, for instance, may have two views, a left</span>
 <span class="s0">* and a right image.  Other uses for multiple views are not yet defined.</span>
 <span class="s0">*</span>
 <span class="s0">* If this value is greater than one, the additional views are accessed as</span>
 <span class="s0">* additional pages beyond get_z_size().</span>
 <span class="s0">*</span>
 <span class="s0">* This also implicitly unloads the texture if it has already been loaded.</span>
 <span class="s0">*/ 2 4 this 3 3325  9 num_views 1 3177  </span>
<span class="s0">1056 0 0 6 1267 3177 0 0 318 /**</span>
 <span class="s0">* Returns the total number of pages in the texture.  Each &quot;page&quot; is a 2-d</span>
 <span class="s0">* texture image within the larger image--a face of a cube map, or a level of</span>
 <span class="s0">* a 3-d texture.  Normally, get_num_pages() is the same as get_z_size().</span>
 <span class="s0">* However, in a multiview texture, this returns get_z_size() *</span>
 <span class="s0">* get_num_views().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1057 0 0 6 1268 3177 0 0 194 /**</span>
 <span class="s0">* Returns the number of color components for each texel of the texture image.</span>
 <span class="s0">* This is 3 for an rgb texture or 4 for an rgba texture; it may also be 1 or</span>
 <span class="s0">* 2 for a grayscale texture.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1058 0 0 6 1269 3177 0 0 141 /**</span>
 <span class="s0">* Returns the number of bytes stored for each color component of a texel.</span>
 <span class="s0">* Typically this is 1, but it may be 2 for 16-bit texels.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1059 0 0 6 1270 3277 0 0 61 /**</span>
 <span class="s0">* Returns the overall interpretation of the texture.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1060 0 0 6 1271 3169 0 0 114 /**</span>
 <span class="s0">* Returns the usage hint specified for buffer textures, or UH_unspecified for</span>
 <span class="s0">* all other texture types.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1061 0 0 6 1277 3279 0 0 153 /**</span>
 <span class="s0">* Returns the format of the texture, which represents both the semantic</span>
 <span class="s0">* meaning of the texels and, to some extent, their storage information.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1062 0 0 4 1278 3346 0 0 112 /**</span>
 <span class="s0">* Changes the format value for the texture components.  This implicitly sets</span>
 <span class="s0">* num_components as well.</span>
 <span class="s0">*/ 2 4 this 3 3325  6 format 1 3279  </span>
<span class="s0">1063 0 0 6 1280 3278 0 0 79 /**</span>
 <span class="s0">* Returns the numeric interpretation of each component of the texture.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1064 0 0 4 1281 3346 0 0 111 /**</span>
 <span class="s0">* Changes the data value for the texture components.  This implicitly sets</span>
 <span class="s0">* component_width as well.</span>
 <span class="s0">*/ 2 4 this 3 3325  14 component_type 1 3278  </span>
<span class="s0">1065 0 0 6 1283 3274 0 0 208 /**</span>
 <span class="s0">* Returns the wrap mode of the texture in the U direction.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1066 0 0 4 1284 3346 0 0 0 2 4 this 3 3325  4 wrap 1 3585  </span>
<span class="s0">1067 0 0 6 1286 3274 0 0 208 /**</span>
 <span class="s0">* Returns the wrap mode of the texture in the V direction.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1068 0 0 4 1287 3346 0 0 0 2 4 this 3 3325  4 wrap 1 3585  </span>
<span class="s0">1069 0 0 6 1289 3274 0 0 257 /**</span>
 <span class="s0">* Returns the wrap mode of the texture in the W direction.  This is the depth</span>
 <span class="s0">* direction of 3-d textures.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1070 0 0 4 1290 3346 0 0 0 2 4 this 3 3325  4 wrap 1 3585  </span>
<span class="s0">1071 0 0 6 1292 3273 0 0 355 /**</span>
 <span class="s0">* Returns the filter mode of the texture for minification.  If this is one of</span>
 <span class="s0">* the mipmap constants, then the texture requires mipmaps.  This may return</span>
 <span class="s0">* FT_default; see also get_effective_minfilter().</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1072 0 0 6 1293 3273 0 0 341 /**</span>
 <span class="s0">* Returns the filter mode of the texture for minification, with special</span>
 <span class="s0">* treatment for FT_default.  This will normally not return FT_default, unless</span>
 <span class="s0">* there is an error in the config file.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1073 0 0 4 1294 3346 0 0 0 2 4 this 3 3325  6 filter 1 3586  </span>
<span class="s0">1074 0 0 6 1297 3273 0 0 320 /**</span>
 <span class="s0">* Returns the filter mode of the texture for magnification.  The mipmap</span>
 <span class="s0">* constants are invalid here.  This may return FT_default; see also</span>
 <span class="s0">* get_effective_minfilter().</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1075 0 0 6 1298 3273 0 0 342 /**</span>
 <span class="s0">* Returns the filter mode of the texture for magnification, with special</span>
 <span class="s0">* treatment for FT_default.  This will normally not return FT_default, unless</span>
 <span class="s0">* there is an error in the config file.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1076 0 0 4 1299 3346 0 0 0 2 4 this 3 3325  6 filter 1 3586  </span>
<span class="s0">1077 0 0 6 1302 3177 0 0 339 /**</span>
 <span class="s0">* Returns the degree of anisotropic filtering that should be applied to the</span>
 <span class="s0">* texture.  This value may return 0, indicating the default value; see also</span>
 <span class="s0">* get_effective_anisotropic_degree.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1078 0 0 6 1303 3177 0 0 325 /**</span>
 <span class="s0">* Returns the degree of anisotropic filtering that should be applied to the</span>
 <span class="s0">* texture.  This value will normally not return 0, unless there is an error</span>
 <span class="s0">* in the config file.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1079 0 0 4 1304 3346 0 0 548 /**</span>
 <span class="s0">* Specifies the level of anisotropic filtering to apply to the texture.  Set</span>
 <span class="s0">* this 0 to indicate the default value, which is specified in the texture-</span>
 <span class="s0">* anisotropic-degree config variable.</span>
 <span class="s0">*</span>
 <span class="s0">* To explicitly disable anisotropic filtering, set this value to 1.  To</span>
 <span class="s0">* explicitly enable anisotropic filtering, set it to a value higher than 1;</span>
 <span class="s0">* larger numbers indicate greater degrees of filtering.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 2 4 this 3 3325  18 anisotropic_degree 1 3177  </span>
<span class="s0">1080 0 0 7 1307 3467 0 0 327 /**</span>
 <span class="s0">* Returns the solid color of the texture's border.  Some OpenGL</span>
 <span class="s0">* implementations use a border for tiling textures; in Panda, it is only used</span>
 <span class="s0">* for specifying the clamp color.</span>
 <span class="s0">*</span>
 <span class="s0">* This returns the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1081 0 0 4 1308 3346 0 0 326 /**</span>
 <span class="s0">* Specifies the solid color of the texture's border.  Some OpenGL</span>
 <span class="s0">* implementations use a border for tiling textures; in Panda, it is only used</span>
 <span class="s0">* for specifying the clamp color.</span>
 <span class="s0">*</span>
 <span class="s0">* This sets the default sampler state for this texture; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 2 4 this 3 3325  5 color 1 3445  </span>
<span class="s0">1082 0 0 6 1310 3178 0 0 430 /**</span>
 <span class="s0">* Returns true if the texture indicates it wants to be compressed, either</span>
 <span class="s0">* with CM_on or higher, or CM_default and compressed-textures is true.</span>
 <span class="s0">*</span>
 <span class="s0">* If true returned, this is not a guarantee that the texture is actually</span>
 <span class="s0">* successfully compressed on the GSG.  It may be that the GSG does not</span>
 <span class="s0">* support the requested compression mode, in which case the texture may</span>
 <span class="s0">* actually be stored uncompressed in texture memory.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1083 0 0 6 1311 3282 0 0 431 /**</span>
 <span class="s0">* Returns the compression mode requested for this particular texture, or</span>
 <span class="s0">* CM_off if the texture is not to be compressed.</span>
 <span class="s0">*</span>
 <span class="s0">* If a value other than CM_off is returned, this is not a guarantee that the</span>
 <span class="s0">* texture is actually successfully compressed on the GSG.  It may be that the</span>
 <span class="s0">* GSG does not support the requested compression mode, in which case the</span>
 <span class="s0">* texture may actually be stored uncompressed in texture memory.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1084 0 0 4 1312 3346 0 0 645 /**</span>
 <span class="s0">* Requests that this particular Texture be compressed when it is loaded into</span>
 <span class="s0">* texture memory.</span>
 <span class="s0">*</span>
 <span class="s0">* This refers to the internal compression of the texture image within texture</span>
 <span class="s0">* memory; it is not related to jpeg or png compression, which are disk file</span>
 <span class="s0">* compression formats.  The actual disk file that generated this texture may</span>
 <span class="s0">* be stored in a compressed or uncompressed format supported by Panda; it</span>
 <span class="s0">* will be decompressed on load, and then recompressed by the graphics API if</span>
 <span class="s0">* this parameter is not CM_off.</span>
 <span class="s0">*</span>
 <span class="s0">* If the GSG does not support this texture compression mode, the texture will</span>
 <span class="s0">* silently be loaded uncompressed.</span>
 <span class="s0">*/ 2 4 this 3 3325  11 compression 1 3282  </span>
<span class="s0">1085 0 0 6 1314 3178 0 0 378 /**</span>
 <span class="s0">* Returns a flag on the texture that indicates whether the texture is</span>
 <span class="s0">* intended to be used as a direct-render target, by binding a framebuffer to</span>
 <span class="s0">* a texture and rendering directly into the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, a user should not need to set this flag directly; it is set</span>
 <span class="s0">* automatically by the low-level display code when a texture is bound to a</span>
 <span class="s0">* framebuffer.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1086 0 0 4 1315 3346 0 0 539 /**</span>
 <span class="s0">* Sets a flag on the texture that indicates whether the texture is intended</span>
 <span class="s0">* to be used as a direct-render target, by binding a framebuffer to a texture</span>
 <span class="s0">* and rendering directly into the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* This controls some low-level choices made about the texture object itself.</span>
 <span class="s0">* For instance, compressed textures are disallowed when this flag is set</span>
 <span class="s0">* true.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, a user should not need to set this flag directly; it is set</span>
 <span class="s0">* automatically by the low-level display code when a texture is bound to a</span>
 <span class="s0">* framebuffer.</span>
 <span class="s0">*/ 2 4 this 3 3325  17 render_to_texture 1 3178  </span>
<span class="s0">1087 0 0 6 1317 3564 0 0 222 /**</span>
 <span class="s0">* This returns the default sampler state for this texture, containing the</span>
 <span class="s0">* wrap and filter properties specified on the texture level; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1088 0 0 4 1318 3346 0 0 502 /**</span>
 <span class="s0">* This sets the default sampler state for this texture, containing the wrap</span>
 <span class="s0">* and filter properties specified on the texture level; it may still be</span>
 <span class="s0">* overridden by a sampler state specified at a higher level.  This</span>
 <span class="s0">* encompasses the settings for get_wrap_u, get_minfilter,</span>
 <span class="s0">* get_anisotropic_degree, etc.</span>
 <span class="s0">*</span>
 <span class="s0">* This makes a copy of the SamplerState object, so future modifications of</span>
 <span class="s0">* the same SamplerState will have no effect on this texture unless you call</span>
 <span class="s0">* set_default_sampler again.</span>
 <span class="s0">*/ 2 4 this 3 3325  7 sampler 1 3564  </span>
<span class="s0">1089 0 0 6 1321 3178 0 0 117 /**</span>
 <span class="s0">* Returns true if the minfilter settings on this texture indicate the use of</span>
 <span class="s0">* mipmapping, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1090 0 0 6 1322 3283 0 0 149 /**</span>
 <span class="s0">* Returns the current quality_level hint.  See set_quality_level().  This</span>
 <span class="s0">* value may return QL_default; see get_effective_quality_level().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1091 0 0 6 1323 3283 0 0 235 /**</span>
 <span class="s0">* Returns the current quality_level hint, or the global default quality_level</span>
 <span class="s0">* if this texture doesn't specify a quality level.  This value will not</span>
 <span class="s0">* normally return QL_default (unless there is an error in the config file)</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1092 0 0 4 1324 3346 0 0 264 /**</span>
 <span class="s0">* Sets a hint to the renderer about the desired performance / quality</span>
 <span class="s0">* tradeoff for this particular texture.  This is most useful for the</span>
 <span class="s0">* tinydisplay software renderer; for normal, hardware-accelerated renderers,</span>
 <span class="s0">* this may have little or no effect.</span>
 <span class="s0">*/ 2 4 this 3 3325  13 quality_level 1 3283  </span>
<span class="s0">1093 0 0 6 1327 3177 0 0 249 /**</span>
 <span class="s0">* Returns the number of mipmap levels that should be defined for this</span>
 <span class="s0">* texture, given the texture's size.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this returns a number appropriate for mipmapping, even if the</span>
 <span class="s0">* texture does not currently have mipmapping enabled.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1094 0 0 6 1328 3177 0 0 100 /**</span>
 <span class="s0">* Returns the x_size that the nth mipmap level should have, based on the</span>
 <span class="s0">* texture's size.</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1095 0 0 6 1329 3177 0 0 100 /**</span>
 <span class="s0">* Returns the y_size that the nth mipmap level should have, based on the</span>
 <span class="s0">* texture's size.</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1096 0 0 6 1330 3177 0 0 100 /**</span>
 <span class="s0">* Returns the z_size that the nth mipmap level should have, based on the</span>
 <span class="s0">* texture's size.</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1097 0 0 6 1331 3177 0 0 280 /**</span>
 <span class="s0">* Returns the total number of pages that the nth mipmap level should have,</span>
 <span class="s0">* based on the texture's size.  This is usually the same as</span>
 <span class="s0">* get_expected_mipmap_z_size(), except for a multiview texture, in which case</span>
 <span class="s0">* it is get_expected_mipmap_z_size() * get_num_views().</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1098 0 0 6 1333 3178 0 0 1090 /**</span>
 <span class="s0">* Returns true if the Texture has its image contents available in main RAM,</span>
 <span class="s0">* false if it exists only in texture memory or in the prepared GSG context.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this has nothing to do with whether get_ram_image() will fail or</span>
 <span class="s0">* not.  Even if has_ram_image() returns false, get_ram_image() may still</span>
 <span class="s0">* return a valid RAM image, because get_ram_image() will automatically load</span>
 <span class="s0">* the texture from disk if necessary.  The only thing has_ram_image() tells</span>
 <span class="s0">* you is whether the texture is available right now without hitting the disk</span>
 <span class="s0">* first.</span>
 <span class="s0">*</span>
 <span class="s0">* Note also that if an application uses only one GSG, it may appear that</span>
 <span class="s0">* has_ram_image() returns true if the texture has not yet been loaded by the</span>
 <span class="s0">* GSG, but this correlation is not true in general and should not be depended</span>
 <span class="s0">* on.  Specifically, if an application ever uses multiple GSG's in its</span>
 <span class="s0">* lifetime (for instance, by opening more than one window, or by closing its</span>
 <span class="s0">* window and opening another one later), then has_ram_image() may well return</span>
 <span class="s0">* false on textures that have never been loaded on the current GSG.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1099 0 0 6 1334 3178 0 0 146 /**</span>
 <span class="s0">* Returns true if the Texture has its image contents available in main RAM</span>
 <span class="s0">* and is uncompressed, false otherwise.  See has_ram_image().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1100 0 0 6 1335 3178 0 0 284 /**</span>
 <span class="s0">* Returns true if the texture's image contents are currently available in</span>
 <span class="s0">* main RAM, or there is reason to believe it can be loaded on demand.  That</span>
 <span class="s0">* is, this function returns a &quot;best guess&quot; as to whether get_ram_image() will</span>
 <span class="s0">* succeed without actually calling it first.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1101 0 0 6 1336 3209 0 0 141 /**</span>
 <span class="s0">* Returns the total number of bytes used by the in-memory image, across all</span>
 <span class="s0">* pages and views, or 0 if there is no in-memory image.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1102 0 0 6 1337 3209 0 0 208 /**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image per view, or 0 if</span>
 <span class="s0">* there is no in-memory image.  Since each view is a stack of z_size pages,</span>
 <span class="s0">* this is get_z_size() * get_ram_page_size().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1103 0 0 6 1338 3209 0 0 345 /**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image per page, or 0 if</span>
 <span class="s0">* there is no in-memory image.</span>
 <span class="s0">*</span>
 <span class="s0">* For a non-compressed texture, this is the same as</span>
 <span class="s0">* get_expected_ram_page_size().  For a compressed texture, this may be a</span>
 <span class="s0">* smaller value.  (We do assume that all pages will be the same size on a</span>
 <span class="s0">* compressed texture).</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1104 0 0 6 1339 3209 0 0 122 /**</span>
 <span class="s0">* Returns the number of bytes that *ought* to be used by the in-memory image,</span>
 <span class="s0">* based on the texture parameters.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1105 0 0 6 1340 3209 0 0 178 /**</span>
 <span class="s0">* Returns the number of bytes that should be used per each Z page of the 3-d</span>
 <span class="s0">* texture.  For a 2-d or 1-d texture, this is the same as</span>
 <span class="s0">* get_expected_ram_image_size().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1106 0 0 7 1346 3587 0 0 1159 /**</span>
 <span class="s0">* Returns the system-RAM image data associated with the texture.  If the</span>
 <span class="s0">* texture does not currently have an associated RAM image, and the texture</span>
 <span class="s0">* was generated by loading an image from a disk file (the most common case),</span>
 <span class="s0">* this forces the reload of the same texture.  This can happen if</span>
 <span class="s0">* keep_texture_ram is configured to false, and we have previously prepared</span>
 <span class="s0">* this texture with a GSG.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that it is not correct to call has_ram_image() first to test whether</span>
 <span class="s0">* this function will fail.  A false return value from has_ram_image()</span>
 <span class="s0">* indicates only that get_ram_image() may need to reload the texture from</span>
 <span class="s0">* disk, which it will do automatically.  However, you can call</span>
 <span class="s0">* might_have_ram_image(), which will return true if the ram image exists, or</span>
 <span class="s0">* there is a reasonable reason to believe it can be loaded.</span>
 <span class="s0">*</span>
 <span class="s0">* On the other hand, it is possible that the texture cannot be found on disk</span>
 <span class="s0">* or is otherwise unavailable.  If that happens, this function will return</span>
 <span class="s0">* NULL. There is no way to predict with 100% accuracy whether get_ram_image()</span>
 <span class="s0">* will return NULL without calling it first; might_have_ram_image() is the</span>
 <span class="s0">* closest.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1107 0 0 6 1347 3282 0 0 338 /**</span>
 <span class="s0">* Returns the compression mode in which the ram image is already stored pre-</span>
 <span class="s0">* compressed.  If this is other than CM_off, you cannot rely on the contents</span>
 <span class="s0">* of the ram image to be anything predicatable (it will not be an array of x</span>
 <span class="s0">* by y pixels, and it probably won't have the same length as</span>
 <span class="s0">* get_expected_ram_image_size()).</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1108 0 0 7 1348 3587 0 0 586 /**</span>
 <span class="s0">* Returns the system-RAM image associated with the texture, in an</span>
 <span class="s0">* uncompressed form if at all possible.</span>
 <span class="s0">*</span>
 <span class="s0">* If get_ram_image_compression() is CM_off, then the system-RAM image is</span>
 <span class="s0">* already uncompressed, and this returns the same thing as get_ram_image().</span>
 <span class="s0">*</span>
 <span class="s0">* If get_ram_image_compression() is anything else, then the system-RAM image</span>
 <span class="s0">* is compressed.  In this case, the image will be reloaded from the</span>
 <span class="s0">* *original* file (not from the cache), in the hopes that an uncompressed</span>
 <span class="s0">* image will be found there.</span>
 <span class="s0">*</span>
 <span class="s0">* If an uncompressed image cannot be found, returns NULL.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1109 0 0 7 1349 3587 0 0 1220 /**</span>
 <span class="s0">* Returns the uncompressed system-RAM image data associated with the texture.</span>
 <span class="s0">* Rather than just returning a pointer to the data, like</span>
 <span class="s0">* get_uncompressed_ram_image, this function first processes the data and</span>
 <span class="s0">* reorders the components using the specified format string, and places these</span>
 <span class="s0">* into a new char array.</span>
 <span class="s0">*</span>
 <span class="s0">* The 'format' argument should specify in which order the components of the</span>
 <span class="s0">* texture must be.  For example, valid format strings are &quot;RGBA&quot;, &quot;GA&quot;,</span>
 <span class="s0">* &quot;ABRG&quot; or &quot;AAA&quot;.  A component can also be written as &quot;0&quot; or &quot;1&quot;, which</span>
 <span class="s0">* means an empty/black or a full/white channel, respectively.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is particularly useful to copy an image in-memory to a</span>
 <span class="s0">* different library (for example, PIL or wxWidgets) that require a different</span>
 <span class="s0">* component order than Panda's internal format, BGRA. Note, however, that</span>
 <span class="s0">* this conversion can still be too slow if you want to do it every frame, and</span>
 <span class="s0">* should thus be avoided for that purpose.</span>
 <span class="s0">*</span>
 <span class="s0">* The only requirement for the reordering is that an uncompressed image must</span>
 <span class="s0">* be available.  If the RAM image is compressed, it will attempt to re-load</span>
 <span class="s0">* the texture from disk, if it doesn't find an uncompressed image there, it</span>
 <span class="s0">* will return NULL.</span>
 <span class="s0">*/ 2 4 this 3 3325  16 requested_format 1 3342  </span>
<span class="s0">1110 0 0 7 1350 3590 0 0 246 /**</span>
 <span class="s0">* Returns a modifiable pointer to the system-RAM image.  This assumes the RAM</span>
 <span class="s0">* image should be uncompressed.  If the RAM image has been dumped, or is</span>
 <span class="s0">* stored compressed, creates a new one.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1111 0 0 7 1351 3590 0 0 198 /**</span>
 <span class="s0">* Discards the current system-RAM image for the texture, if any, and</span>
 <span class="s0">* allocates a new buffer of the appropriate size.  Returns the new buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1112 0 0 36 1352 3346 0 0 0 4 4 this 3 3325  5 image 1 3358  11 compression 5 3282  9 page_size 5 3209  </span>
<span class="s0">1113 0 0 36 1353 3346 0 0 0 3 4 this 3 3325  5 image 1 3358  15 provided_format 1 3342  </span>
<span class="s0">1114 0 0 4 1354 3346 0 0 49 /**</span>
 <span class="s0">* Discards the current system-RAM image.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1115 0 0 4 1355 3346 0 0 476 /**</span>
 <span class="s0">* Sets the flag that indicates whether this Texture is eligible to have its</span>
 <span class="s0">* main RAM copy of the texture memory dumped when the texture is prepared for</span>
 <span class="s0">* rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* This will be false for most textures, which can reload their images if</span>
 <span class="s0">* needed by rereading the input file.  However, textures that were generated</span>
 <span class="s0">* dynamically and cannot be easily reloaded will want to set this flag to</span>
 <span class="s0">* true, so that the texture will always keep its image copy around.</span>
 <span class="s0">*/ 2 4 this 3 3325  14 keep_ram_image 1 3178  </span>
<span class="s0">1116 0 0 6 1356 3178 0 0 207 /**</span>
 <span class="s0">* Returns the flag that indicates whether this Texture is eligible to have</span>
 <span class="s0">* its main RAM copy of the texture memory dumped when the texture is prepared</span>
 <span class="s0">* for rendering.  See set_keep_ram_image().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1117 0 0 6 1357 3178 0 0 200 /**</span>
 <span class="s0">* Returns true if there is enough information in this Texture object to write</span>
 <span class="s0">* it to the bam cache successfully, false otherwise.  For most textures, this</span>
 <span class="s0">* is the same as has_ram_image().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1118 0 0 39 1361 3325 2558 0 0 2 4 this 3 3567  4 memo 1 3358  </span>
<span class="s0">1119 0 0 6 1362 3178 0 0 802 /**</span>
 <span class="s0">* Attempts to compress the texture's RAM image internally, to a format</span>
 <span class="s0">* supported by the indicated GSG.  In order for this to work, the squish</span>
 <span class="s0">* library must have been compiled into Panda.</span>
 <span class="s0">*</span>
 <span class="s0">* If compression is CM_on, then an appropriate compression method that is</span>
 <span class="s0">* supported by the indicated GSG is automatically chosen.  If the GSG pointer</span>
 <span class="s0">* is NULL, any of the standard DXT1/3/5 compression methods will be used,</span>
 <span class="s0">* regardless of whether it is supported.</span>
 <span class="s0">*</span>
 <span class="s0">* If compression is any specific compression method, that method is used</span>
 <span class="s0">* regardless of whether the GSG supports it.</span>
 <span class="s0">*</span>
 <span class="s0">* quality_level determines the speed/quality tradeoff of the compression.  If</span>
 <span class="s0">* it is QL_default, the texture's own quality_level parameter is used.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false otherwise.</span>
 <span class="s0">*/ 4 4 this 3 3325  11 compression 5 3282  13 quality_level 5 3283  3 gsg 5 3405  </span>
<span class="s0">1120 0 0 6 1363 3178 0 0 279 /**</span>
 <span class="s0">* Attempts to uncompress the texture's RAM image internally.  In order for</span>
 <span class="s0">* this to work, the squish library must have been compiled into Panda, and</span>
 <span class="s0">* the ram image must be compressed in a format supported by squish.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1121 0 0 6 1364 3177 0 0 285 /**</span>
 <span class="s0">* Returns the maximum number of mipmap level images available in system</span>
 <span class="s0">* memory.  The actual number may be less than this (that is, there might be</span>
 <span class="s0">* gaps in the sequence); use has_ram_mipmap_image() to verify each level.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see get_num_loadable_ram_mipmap_images().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1122 0 0 6 1365 3178 0 0 317 /**</span>
 <span class="s0">* Returns true if the Texture has the nth mipmap level available in system</span>
 <span class="s0">* memory, false otherwise.  If the texture's minfilter mode requires</span>
 <span class="s0">* mipmapping (see uses_mipmaps()), and all the texture's mipmap levels are</span>
 <span class="s0">* not available when the texture is rendered, they will be generated</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1123 0 0 6 1366 3177 0 0 558 /**</span>
 <span class="s0">* Returns the number of contiguous mipmap levels that exist in RAM, up until</span>
 <span class="s0">* the first gap in the sequence.  It is guaranteed that at least mipmap</span>
 <span class="s0">* levels [0, get_num_ram_mipmap_images()) exist.</span>
 <span class="s0">*</span>
 <span class="s0">* The number returned will never exceed the number of required mipmap images</span>
 <span class="s0">* based on the size of the texture and its filter mode.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is different from get_num_ram_mipmap_images() in that it</span>
 <span class="s0">* returns only the number of mipmap levels that can actually be usefully</span>
 <span class="s0">* loaded, regardless of the actual number that may be stored.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1124 0 0 6 1367 3178 0 0 149 /**</span>
 <span class="s0">* Returns true if all expected mipmap levels have been defined and exist in</span>
 <span class="s0">* the system RAM, or false if even one mipmap level is missing.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1125 0 0 6 1368 3209 0 0 148 /**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image for mipmap level n,</span>
 <span class="s0">* or 0 if there is no in-memory image for this mipmap level.</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1126 0 0 6 1369 3209 0 0 542 /**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image per view for mipmap</span>
 <span class="s0">* level n, or 0 if there is no in-memory image for this mipmap level.</span>
 <span class="s0">*</span>
 <span class="s0">* A &quot;view&quot; is a collection of z_size pages for each mipmap level.  Most</span>
 <span class="s0">* textures have only one view, except for multiview or stereo textures.</span>
 <span class="s0">*</span>
 <span class="s0">* For a non-compressed texture, this is the same as</span>
 <span class="s0">* get_expected_ram_mipmap_view_size().  For a compressed texture, this may be</span>
 <span class="s0">* a smaller value.  (We do assume that all pages will be the same size on a</span>
 <span class="s0">* compressed texture).</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1127 0 0 6 1370 3209 0 0 393 /**</span>
 <span class="s0">* Returns the number of bytes used by the in-memory image per page for mipmap</span>
 <span class="s0">* level n, or 0 if there is no in-memory image for this mipmap level.</span>
 <span class="s0">*</span>
 <span class="s0">* For a non-compressed texture, this is the same as</span>
 <span class="s0">* get_expected_ram_mipmap_page_size().  For a compressed texture, this may be</span>
 <span class="s0">* a smaller value.  (We do assume that all pages will be the same size on a</span>
 <span class="s0">* compressed texture).</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1128 0 0 6 1371 3209 0 0 141 /**</span>
 <span class="s0">* Returns the number of bytes that *ought* to be used by the in-memory image</span>
 <span class="s0">* for mipmap level n, based on the texture parameters.</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1129 0 0 6 1372 3209 0 0 258 /**</span>
 <span class="s0">* Returns the number of bytes that *ought* to be used by each view of the in-</span>
 <span class="s0">* memory image for mipmap level n, based on the texture parameters.  For a</span>
 <span class="s0">* normal, non-multiview texture, this is the same as</span>
 <span class="s0">* get_expected_ram_mipmap_image_size(n).</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1130 0 0 6 1373 3209 0 0 205 /**</span>
 <span class="s0">* Returns the number of bytes that should be used per each Z page of the 3-d</span>
 <span class="s0">* texture, for mipmap level n.  For a 2-d or 1-d texture, this is the same as</span>
 <span class="s0">* get_expected_ram_mipmap_view_size(n).</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1131 0 0 7 1374 3587 0 0 151 /**</span>
 <span class="s0">* Returns the system-RAM image data associated with the nth mipmap level, if</span>
 <span class="s0">* present.  Returns NULL if the nth mipmap level is not present.</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1132 0 0 4 1375 3346 0 0 182 /**</span>
 <span class="s0">* Similiar to get_ram_mipmap_image(), however, in this case the void pointer</span>
 <span class="s0">* for the given ram image is returned.  This will be NULL unless it has been</span>
 <span class="s0">* explicitly set.</span>
 <span class="s0">*/ 2 4 this 3 3567  1 n 1 3177  </span>
<span class="s0">1133 0 0 7 1376 3590 0 0 231 /**</span>
 <span class="s0">* Returns a modifiable pointer to the system-RAM image for the nth mipmap</span>
 <span class="s0">* level.  This assumes the RAM image is uncompressed; if this is not the</span>
 <span class="s0">* case, raises an assertion.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/ 2 4 this 3 3325  1 n 1 3177  </span>
<span class="s0">1134 0 0 7 1377 3590 0 0 207 /**</span>
 <span class="s0">* Discards the current system-RAM image for the nth mipmap level, if any, and</span>
 <span class="s0">* allocates a new buffer of the appropriate size.  Returns the new buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/ 2 4 this 3 3325  1 n 1 3177  </span>
<span class="s0">1135 0 0 4 1379 3346 0 0 287 /**</span>
 <span class="s0">* Accepts a raw pointer cast as an int, which is then passed to</span>
 <span class="s0">* set_ram_mipmap_pointer(); see the documentation for that method.</span>
 <span class="s0">*</span>
 <span class="s0">* This variant is particularly useful to set an external pointer from a</span>
 <span class="s0">* language like Python, which doesn't support void pointers directly.</span>
 <span class="s0">*/ 4 4 this 3 3325  7 pointer 1 3591  1 n 1 3177  9 page_size 1 3177  </span>
<span class="s0">1136 0 0 4 1380 3346 0 0 262 /**</span>
 <span class="s0">* Replaces the current system-RAM image for the indicated mipmap level with</span>
 <span class="s0">* the new data.  If compression is not CM_off, it indicates that the new data</span>
 <span class="s0">* is already pre-compressed in the indicated format.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* affect keep_ram_image.</span>
 <span class="s0">*/ 4 4 this 3 3325  1 n 1 3177  5 image 1 3587  9 page_size 5 3209  </span>
<span class="s0">1137 0 0 4 1381 3346 0 0 74 /**</span>
 <span class="s0">* Discards the current system-RAM image for the nth mipmap level.</span>
 <span class="s0">*/ 2 4 this 3 3325  1 n 1 3177  </span>
<span class="s0">1138 0 0 4 1382 3346 0 0 107 /**</span>
 <span class="s0">* Discards the current system-RAM image for all mipmap levels, except level 0</span>
 <span class="s0">* (the base image).</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1139 0 0 4 1383 3346 0 0 453 /**</span>
 <span class="s0">* Automatically fills in the n mipmap levels of the Texture, based on the</span>
 <span class="s0">* texture's source image.  This requires the texture's uncompressed ram image</span>
 <span class="s0">* to be available in system memory.  If it is not already, it will be fetched</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is not normally necessary, since the mipmap levels will be</span>
 <span class="s0">* generated automatically if needed.  But there may be certain cases in which</span>
 <span class="s0">* you would like to call this explicitly.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1140 0 0 6 1386 3177 0 0 61 /**</span>
 <span class="s0">* Returns the width of the &quot;simple&quot; image in texels.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1141 0 0 6 1387 3177 0 0 62 /**</span>
 <span class="s0">* Returns the height of the &quot;simple&quot; image in texels.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1142 0 0 6 1388 3178 0 0 82 /**</span>
 <span class="s0">* Returns true if the Texture has a &quot;simple&quot; image available in main RAM.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1143 0 0 6 1389 3209 0 0 103 /**</span>
 <span class="s0">* Returns the number of bytes used by the &quot;simple&quot; image, or 0 if there is no</span>
 <span class="s0">* simple image.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1144 0 0 7 1390 3587 0 0 511 /**</span>
 <span class="s0">* Returns the image data associated with the &quot;simple&quot; texture image.  This is</span>
 <span class="s0">* provided for some textures as an option to display while the main texture</span>
 <span class="s0">* image is being loaded from disk.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike get_ram_image(), this function will always return immediately.</span>
 <span class="s0">* Either the simple image is available, or it is not.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;simple&quot; image is always 4 components, 1 byte each, regardless of the</span>
 <span class="s0">* parameters of the full texture.  The simple image is only supported for</span>
 <span class="s0">* ordinary 2-d textures.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1145 0 0 4 1391 3346 0 0 638 /**</span>
 <span class="s0">* Replaces the internal &quot;simple&quot; texture image.  This can be used as an</span>
 <span class="s0">* option to display while the main texture image is being loaded from disk.</span>
 <span class="s0">* It is normally a very small image, 16x16 or smaller (and maybe even 1x1),</span>
 <span class="s0">* that is designed to give just enough sense of color to serve as a</span>
 <span class="s0">* placeholder until the full texture is available.</span>
 <span class="s0">*</span>
 <span class="s0">* The &quot;simple&quot; image is always 4 components, 1 byte each, regardless of the</span>
 <span class="s0">* parameters of the full texture.  The simple image is only supported for</span>
 <span class="s0">* ordinary 2-d textures.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see generate_simple_ram_image(), modify_simple_ram_image(), and</span>
 <span class="s0">* new_simple_ram_image().</span>
 <span class="s0">*/ 4 4 this 3 3325  5 image 1 3587  6 x_size 1 3177  6 y_size 1 3177  </span>
<span class="s0">1146 0 0 7 1392 3590 0 0 111 /**</span>
 <span class="s0">* Returns a modifiable pointer to the internal &quot;simple&quot; texture image.  See</span>
 <span class="s0">* set_simple_ram_image().</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1147 0 0 7 1393 3590 0 0 164 /**</span>
 <span class="s0">* Creates an empty array for the simple ram image of the indicated size, and</span>
 <span class="s0">* returns a modifiable pointer to the new array.  See set_simple_ram_image().</span>
 <span class="s0">*/ 3 4 this 3 3325  6 x_size 1 3177  6 y_size 1 3177  </span>
<span class="s0">1148 0 0 4 1394 3346 0 0 185 /**</span>
 <span class="s0">* Computes the &quot;simple&quot; ram image by loading the main RAM image, if it is not</span>
 <span class="s0">* already available, and reducing it to 16x16 or smaller.  This may be an</span>
 <span class="s0">* expensive operation.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1149 0 0 4 1395 3346 0 0 47 /**</span>
 <span class="s0">* Discards the current &quot;simple&quot; image.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1150 0 0 7 1401 3592 3153 0 492 /**</span>
 <span class="s0">* Returns a TexturePeeker object that can be used to examine the individual</span>
 <span class="s0">* texels stored within this Texture by (u, v) coordinate.</span>
 <span class="s0">*</span>
 <span class="s0">* If the texture has a ram image resident, that image is used.  If it does</span>
 <span class="s0">* not have a full ram image but does have a simple_ram_image resident, that</span>
 <span class="s0">* image is used instead.  If neither image is resident the full image is</span>
 <span class="s0">* reloaded.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns NULL if the texture cannot find an image to load, or the texture</span>
 <span class="s0">* format is incompatible.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1151 0 0 7 1402 3398 0 0 151 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture properties (unrelated to the image) are modified.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1152 0 0 7 1403 3398 0 0 152 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture image data (including mipmap levels) are modified.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1153 0 0 7 1404 3398 0 0 136 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture's &quot;simple&quot; image data is modified.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1154 0 0 6 1408 3178 0 0 136 /**</span>
 <span class="s0">* Returns true if set_auto_texture_scale() has been set to something other</span>
 <span class="s0">* than ATS_unspecified for this particular texture.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1155 0 0 6 1409 3289 0 0 171 /**</span>
 <span class="s0">* Returns the power-of-2 texture-scaling mode that will be applied to this</span>
 <span class="s0">* particular texture when it is next loaded from disk.  See</span>
 <span class="s0">* set_textures_power_2().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1156 0 0 4 1410 3346 0 0 173 /**</span>
 <span class="s0">* Specifies the power-of-2 texture-scaling mode that will be applied to this</span>
 <span class="s0">* particular texture when it is next loaded from disk.  See</span>
 <span class="s0">* set_textures_power_2().</span>
 <span class="s0">*/ 2 4 this 3 3325  5 scale 1 3289  </span>
<span class="s0">1157 0 0 7 1413 3594 0 0 363 /**</span>
 <span class="s0">* Indicates that the texture should be enqueued to be prepared in the</span>
 <span class="s0">* indicated prepared_objects at the beginning of the next frame.  This will</span>
 <span class="s0">* ensure the texture is already loaded into texture memory if it is expected</span>
 <span class="s0">* to be rendered soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload textures from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/ 2 4 this 3 3325  16 prepared_objects 1 3404  </span>
<span class="s0">1158 0 0 6 1414 3178 0 0 134 /**</span>
 <span class="s0">* Returns true if the texture has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3567  16 prepared_objects 1 3404  </span>
<span class="s0">1159 0 0 6 1415 3178 0 0 176 /**</span>
 <span class="s0">* Returns true if the texture needs to be re-loaded onto the indicated GSG,</span>
 <span class="s0">* either because its image data is out-of-date, or because it's not fully</span>
 <span class="s0">* prepared now.</span>
 <span class="s0">*/ 2 4 this 3 3567  16 prepared_objects 1 3404  </span>
<span class="s0">1160 0 0 6 1416 3209 0 0 335 /**</span>
 <span class="s0">* Returns the number of bytes which the texture is reported to consume within</span>
 <span class="s0">* graphics memory, for the indicated GSG.  This may return a nonzero value</span>
 <span class="s0">* even if the texture is not currently resident; you should also check</span>
 <span class="s0">* get_resident() if you want to know how much space the texture is actually</span>
 <span class="s0">* consuming right now.</span>
 <span class="s0">*/ 2 4 this 3 3567  16 prepared_objects 1 3404  </span>
<span class="s0">1161 0 0 6 1417 3178 0 0 106 /**</span>
 <span class="s0">* Returns true if this Texture was rendered in the most recent frame within</span>
 <span class="s0">* the indicated GSG.</span>
 <span class="s0">*/ 2 4 this 3 3567  16 prepared_objects 1 3404  </span>
<span class="s0">1162 0 0 6 1418 3178 0 0 115 /**</span>
 <span class="s0">* Returns true if this Texture is reported to be resident within graphics</span>
 <span class="s0">* memory for the indicated GSG.</span>
 <span class="s0">*/ 2 4 this 3 3567  16 prepared_objects 1 3404  </span>
<span class="s0">1163 0 0 6 1419 3178 0 0 157 /**</span>
 <span class="s0">* Frees the texture context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/ 2 4 this 3 3325  16 prepared_objects 1 3404  </span>
<span class="s0">1164 0 0 6 1420 3177 0 0 152 /**</span>
 <span class="s0">* Frees the context allocated on all objects for which the texture has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1165 0 0 6 1421 3209 0 0 437 /**</span>
 <span class="s0">* Estimates the amount of texture memory that will be consumed by loading</span>
 <span class="s0">* this texture.  This returns a value that is not specific to any particular</span>
 <span class="s0">* graphics card or driver; it tries to make a reasonable assumption about how</span>
 <span class="s0">* a driver will load the texture.  It does not account for texture</span>
 <span class="s0">* compression or anything fancy.  This is mainly useful for debugging and</span>
 <span class="s0">* reporting purposes.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns a value in bytes.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1166 0 0 4 1422 3346 0 0 237 /**</span>
 <span class="s0">* Records an arbitrary object in the Texture, associated with a specified</span>
 <span class="s0">* key.  The object may later be retrieved by calling get_aux_data() with the</span>
 <span class="s0">* same key.</span>
 <span class="s0">*</span>
 <span class="s0">* These data objects are not recorded to a bam or txo file.</span>
 <span class="s0">*/ 3 4 this 3 3325  3 key 1 3342  8 aux_data 1 3290  </span>
<span class="s0">1167 0 0 4 1423 3346 0 0 67 /**</span>
 <span class="s0">* Removes a record previously recorded via set_aux_data().</span>
 <span class="s0">*/ 2 4 this 3 3325  3 key 1 3342  </span>
<span class="s0">1168 0 0 7 1424 3290 0 0 142 /**</span>
 <span class="s0">* Returns a record previously recorded via set_aux_data().  Returns NULL if</span>
 <span class="s0">* there was no record associated with the indicated key.</span>
 <span class="s0">*/ 2 4 this 3 3567  3 key 1 3342  </span>
<span class="s0">1169 0 0 4 1428 3346 0 0 232 /**</span>
 <span class="s0">* Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control the</span>
 <span class="s0">* scaling of textures in general, if a particular texture does not override</span>
 <span class="s0">* this.  See also set_auto_texture_scale() for the per-texture override.</span>
 <span class="s0">*/ 1 5 scale 1 3289  </span>
<span class="s0">1170 0 0 6 1429 3289 0 0 251 /**</span>
 <span class="s0">* This flag returns ATS_none, ATS_up, or ATS_down and controls the scaling of</span>
 <span class="s0">* textures in general.  It is initialized from the config variable of the</span>
 <span class="s0">* same name, but it can be subsequently adjusted.  See also</span>
 <span class="s0">* get_auto_texture_scale().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1171 0 0 6 1430 3178 0 0 181 /**</span>
 <span class="s0">* If true, then get_textures_power_2 has been set using set_textures_power_2.</span>
 <span class="s0">* If false, then get_textures_power_2 simply returns the config variable of</span>
 <span class="s0">* the same name.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1172 0 0 6 1431 3177 0 0 61 /**</span>
 <span class="s0">* Returns size of the pad region.  See set_pad_size.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1173 0 0 6 1432 3177 0 0 61 /**</span>
 <span class="s0">* Returns size of the pad region.  See set_pad_size.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1174 0 0 6 1433 3177 0 0 61 /**</span>
 <span class="s0">* Returns size of the pad region.  See set_pad_size.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1175 0 0 7 1434 3595 0 0 523 /**</span>
 <span class="s0">* Returns a scale pair that is suitable for applying to geometry via</span>
 <span class="s0">* NodePath::set_tex_scale(), which will convert texture coordinates on the</span>
 <span class="s0">* geometry from the range 0..1 into the appropriate range to render the video</span>
 <span class="s0">* part of the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* This is necessary only if a padding size has been set via set_pad_size()</span>
 <span class="s0">* (or implicitly via something like &quot;textures-power-2 pad&quot; in the config.prc</span>
 <span class="s0">* file).  In this case, this is a convenient way to generate UV's that</span>
 <span class="s0">* reflect the built-in padding size.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1176 0 0 4 1435 3346 0 0 468 /**</span>
 <span class="s0">* Sets the size of the pad region.</span>
 <span class="s0">*</span>
 <span class="s0">* Sometimes, when a video card demands power-of-two textures, it is necessary</span>
 <span class="s0">* to create a big texture and then only use a portion of it.  The pad region</span>
 <span class="s0">* indicates which portion of the texture is not really in use.  All</span>
 <span class="s0">* operations use the texture as a whole, including the pad region, unless</span>
 <span class="s0">* they explicitly state that they use only the non-pad region.</span>
 <span class="s0">*</span>
 <span class="s0">* Changing the texture's size clears the pad region.</span>
 <span class="s0">*/ 4 4 this 3 3325  1 x 5 3177  1 y 5 3177  1 z 5 3177  </span>
<span class="s0">1177 0 0 4 1436 3346 0 0 104 /**</span>
 <span class="s0">* Changes the size of the texture, padding if necessary, and setting the pad</span>
 <span class="s0">* region as well.</span>
 <span class="s0">*/ 4 4 this 3 3325  1 x 5 3177  1 y 5 3177  1 z 5 3177  </span>
<span class="s0">1178 0 0 6 1437 3177 0 0 168 /**</span>
 <span class="s0">* Returns the X size of the original disk image that this Texture was loaded</span>
 <span class="s0">* from (if it came from a disk file), before any automatic rescaling by</span>
 <span class="s0">* Panda.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1179 0 0 6 1438 3177 0 0 168 /**</span>
 <span class="s0">* Returns the Y size of the original disk image that this Texture was loaded</span>
 <span class="s0">* from (if it came from a disk file), before any automatic rescaling by</span>
 <span class="s0">* Panda.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1180 0 0 6 1439 3177 0 0 168 /**</span>
 <span class="s0">* Returns the Z size of the original disk image that this Texture was loaded</span>
 <span class="s0">* from (if it came from a disk file), before any automatic rescaling by</span>
 <span class="s0">* Panda.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1181 0 0 4 1443 3346 0 0 113 /**</span>
 <span class="s0">* Specifies the size of the texture as it exists in its original disk file,</span>
 <span class="s0">* before any Panda scaling.</span>
 <span class="s0">*/ 4 4 this 3 3325  1 x 1 3177  1 y 1 3177  1 z 5 3177  </span>
<span class="s0">1182 0 0 4 1444 3346 0 0 274 /**</span>
 <span class="s0">* Sets the flag that indicates the texture has been loaded from a disk file</span>
 <span class="s0">* or PNMImage.  You should also ensure the filename has been set correctly.</span>
 <span class="s0">* When this flag is true, the texture may be automatically reloaded when its</span>
 <span class="s0">* ram image needs to be replaced.</span>
 <span class="s0">*/ 2 4 this 3 3325  4 flag 5 3178  </span>
<span class="s0">1183 0 0 6 1445 3178 0 0 133 /**</span>
 <span class="s0">* Returns the flag that indicates the texture has been loaded from a disk</span>
 <span class="s0">* file or PNMImage.  See set_loaded_from_image().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1184 0 0 4 1447 3346 0 0 189 /**</span>
 <span class="s0">* Sets the flag that indicates the texture has been loaded from a txo file.</span>
 <span class="s0">* You probably shouldn't be setting this directly; it is set automatically</span>
 <span class="s0">* when a Texture is loaded.</span>
 <span class="s0">*/ 2 4 this 3 3325  4 flag 5 3178  </span>
<span class="s0">1185 0 0 6 1448 3178 0 0 90 /**</span>
 <span class="s0">* Returns the flag that indicates the texture has been loaded from a txo</span>
 <span class="s0">* file.</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1186 0 0 6 1450 3178 0 0 289 /**</span>
 <span class="s0">* Returns true if the special flag was set that indicates to the GSG that the</span>
 <span class="s0">* Texture's format should be chosen to exactly match the framebuffer's</span>
 <span class="s0">* format, presumably because the application intends to copy image data from</span>
 <span class="s0">* the framebuffer into the Texture (or vice-versa).</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1187 0 0 4 1451 3346 0 0 399 /**</span>
 <span class="s0">* Sets the special flag that, if true, indicates to the GSG that the</span>
 <span class="s0">* Texture's format should be chosen to exactly match the framebuffer's</span>
 <span class="s0">* format, presumably because the application intends to copy image data from</span>
 <span class="s0">* the framebuffer into the Texture (or vice-versa).</span>
 <span class="s0">*</span>
 <span class="s0">* This sets only the graphics card's idea of the texture format; it is not</span>
 <span class="s0">* related to the system-memory format.</span>
 <span class="s0">*/ 2 4 this 3 3325  4 flag 1 3178  </span>
<span class="s0">1188 0 0 6 1453 3178 0 0 102 /**</span>
 <span class="s0">* Returns the setting of the post_load_store_cache flag.  See</span>
 <span class="s0">* set_post_load_store_cache().</span>
 <span class="s0">*/ 1 4 this 3 3567  </span>
<span class="s0">1189 0 0 4 1454 3346 0 0 418 /**</span>
 <span class="s0">* Sets the post_load_store_cache flag.  When this is set, the next time the</span>
 <span class="s0">* texture is loaded on a GSG, it will automatically extract its RAM image</span>
 <span class="s0">* from the GSG and save it to the global BamCache.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used to store compressed RAM images in the BamCache.  This flag</span>
 <span class="s0">* should not be set explicitly; it is set automatically by the TexturePool</span>
 <span class="s0">* when model-cache-compressed-textures is set true.</span>
 <span class="s0">*/ 2 4 this 3 3325  4 flag 1 3178  </span>
<span class="s0">1190 0 0 6 1456 3596 0 0 531 /**</span>
 <span class="s0">* Creates a context for the texture on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) TextureContext.  This assumes that</span>
 <span class="s0">* the GraphicsStateGuardian is the currently active rendering context and</span>
 <span class="s0">* that it is ready to accept new textures.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a texture does not need to be explicitly prepared by the user before it may</span>
 <span class="s0">* be rendered.</span>
 <span class="s0">*/ 4 4 this 3 3325  4 view 1 3177  16 prepared_objects 1 3404  3 gsg 1 3405  </span>
<span class="s0">1191 0 0 6 1457 3177 0 0 74 /**</span>
 <span class="s0">* Returns the smallest power of 2 greater than or equal to value.</span>
 <span class="s0">*/ 1 5 value 1 3177  </span>
<span class="s0">1192 0 0 6 1458 3177 0 0 70 /**</span>
 <span class="s0">* Returns the largest power of 2 less than or equal to value.</span>
 <span class="s0">*/ 1 5 value 1 3177  </span>
<span class="s0">1193 0 0 4 1459 3346 0 0 451 /**</span>
 <span class="s0">* Asks the PNMImage to change its scale when it reads the image, according to</span>
 <span class="s0">* the whims of the Config.prc file.</span>
 <span class="s0">*</span>
 <span class="s0">* For most efficient results, this method should be called after</span>
 <span class="s0">* pnmimage.read_header() has been called, but before pnmimage.read().  This</span>
 <span class="s0">* method may also be called after pnmimage.read(), i.e.  when the pnmimage is</span>
 <span class="s0">* already loaded; in this case it will rescale the image on the spot.  Also</span>
 <span class="s0">* see rescale_texture().</span>
 <span class="s0">*/ 2 4 this 3 3325  8 pnmimage 1 3583  </span>
<span class="s0">1194 0 0 4 1459 3346 0 0 451 /**</span>
 <span class="s0">* Asks the PNMImage to change its scale when it reads the image, according to</span>
 <span class="s0">* the whims of the Config.prc file.</span>
 <span class="s0">*</span>
 <span class="s0">* For most efficient results, this method should be called after</span>
 <span class="s0">* pnmimage.read_header() has been called, but before pnmimage.read().  This</span>
 <span class="s0">* method may also be called after pnmimage.read(), i.e.  when the pnmimage is</span>
 <span class="s0">* already loaded; in this case it will rescale the image on the spot.  Also</span>
 <span class="s0">* see rescale_texture().</span>
 <span class="s0">*/ 3 8 pnmimage 1 3583  4 name 1 3342  18 auto_texture_scale 5 3289  </span>
<span class="s0">1195 0 0 6 1460 3178 0 0 391 /**</span>
 <span class="s0">* This method is similar to consider_rescale(), but instead of scaling a</span>
 <span class="s0">* separate PNMImage, it will ask the Texture to rescale its own internal</span>
 <span class="s0">* image to a power of 2, according to the config file requirements.  This may</span>
 <span class="s0">* be useful after loading a Texture image by hand, instead of reading it from</span>
 <span class="s0">* a disk file.  Returns true if the texture is changed, false if it was not.</span>
 <span class="s0">*/ 1 4 this 3 3325  </span>
<span class="s0">1196 0 0 6 1461 3342 0 0 72 /**</span>
 <span class="s0">* Returns the indicated TextureType converted to a string word.</span>
 <span class="s0">*/ 1 2 tt 1 3277  </span>
<span class="s0">1197 0 0 6 1462 3277 0 0 78 /**</span>
 <span class="s0">* Returns the TextureType corresponding to the indicated string word.</span>
 <span class="s0">*/ 1 3 str 1 3342  </span>
<span class="s0">1198 0 0 6 1463 3342 0 0 74 /**</span>
 <span class="s0">* Returns the indicated ComponentType converted to a string word.</span>
 <span class="s0">*/ 1 2 ct 1 3278  </span>
<span class="s0">1199 0 0 6 1464 3278 0 0 80 /**</span>
 <span class="s0">* Returns the ComponentType corresponding to the indicated string word.</span>
 <span class="s0">*/ 1 3 str 1 3342  </span>
<span class="s0">1200 0 0 6 1465 3342 0 0 67 /**</span>
 <span class="s0">* Returns the indicated Format converted to a string word.</span>
 <span class="s0">*/ 1 1 f 1 3279  </span>
<span class="s0">1201 0 0 6 1466 3279 0 0 73 /**</span>
 <span class="s0">* Returns the Format corresponding to the indicated string word.</span>
 <span class="s0">*/ 1 3 str 1 3342  </span>
<span class="s0">1202 0 0 6 1467 3342 0 0 76 /**</span>
 <span class="s0">* Returns the indicated CompressionMode converted to a string word.</span>
 <span class="s0">*/ 1 2 cm 1 3282  </span>
<span class="s0">1203 0 0 6 1468 3282 0 0 96 /**</span>
 <span class="s0">* Returns the CompressionMode value associated with the given string</span>
 <span class="s0">* representation.</span>
 <span class="s0">*/ 1 3 str 1 3342  </span>
<span class="s0">1204 0 0 6 1469 3342 0 0 73 /**</span>
 <span class="s0">* Returns the indicated QualityLevel converted to a string word.</span>
 <span class="s0">*/ 1 3 tql 1 3283  </span>
<span class="s0">1205 0 0 6 1470 3283 0 0 93 /**</span>
 <span class="s0">* Returns the QualityLevel value associated with the given string</span>
 <span class="s0">* representation.</span>
 <span class="s0">*/ 1 3 str 1 3342  </span>
<span class="s0">1206 0 0 7 1471 3362 0 0 0 0 </span>
<span class="s0">1207 0 0 7 1189 3241 0 0 0 1 4 this 3 3325  </span>
<span class="s0">1208 0 0 6 1191 3374 0 0 0 1 4 this 3 3325  </span>
<span class="s0">1209 0 0 15 1496 3331 0 0 0 1 6 param0 0 3597  </span>
<span class="s0">1210 0 0 7 1477 3331 0 0 52 /**</span>
 <span class="s0">* Loads the shader with the given filename.</span>
 <span class="s0">*/ 2 4 file 1 3569  4 lang 5 3293  </span>
<span class="s0">1211 0 0 7 1477 3331 0 0 77 /**</span>
 <span class="s0">* This variant of Shader::load loads all shader programs separately.</span>
 <span class="s0">*/ 6 4 lang 1 3293  6 vertex 1 3569  8 fragment 1 3569  8 geometry 5 3569  12 tess_control 5 3569  15 tess_evaluation 5 3569  </span>
<span class="s0">1212 0 0 23 1478 3331 0 0 64 /**</span>
 <span class="s0">* Loads the shader, using the strings as shader bodies.</span>
 <span class="s0">*/ 6 4 lang 1 3293  6 vertex 1 3342  8 fragment 1 3342  8 geometry 5 3342  12 tess_control 5 3342  15 tess_evaluation 5 3342  </span>
<span class="s0">1213 0 0 23 1478 3331 0 0 61 /**</span>
 <span class="s0">* Loads the shader, using the string as shader body.</span>
 <span class="s0">*/ 2 4 body 1 3342  4 lang 5 3293  </span>
<span class="s0">1214 0 0 7 1479 3331 0 0 34 /**</span>
 <span class="s0">* Loads a compute shader.</span>
 <span class="s0">*/ 2 4 lang 1 3293  2 fn 1 3569  </span>
<span class="s0">1215 0 0 7 1480 3331 0 0 58 /**</span>
 <span class="s0">* Loads the compute shader from the given string.</span>
 <span class="s0">*/ 2 4 lang 1 3293  4 body 1 3342  </span>
<span class="s0">1216 0 0 7 1481 3599 0 0 66 /**</span>
 <span class="s0">* Return the Shader's filename for the given shader type.</span>
 <span class="s0">*/ 2 4 this 3 3597  4 type 5 3294  </span>
<span class="s0">1217 0 0 4 1482 3346 0 0 154 /**</span>
 <span class="s0">* Sets the Shader's filename for the given shader type.  Useful for</span>
 <span class="s0">* associating a shader created with Shader.make with a name for diagnostics.</span>
 <span class="s0">*/ 3 4 this 3 3331  4 type 1 3294  8 filename 1 3569  </span>
<span class="s0">1218 0 0 6 1483 3342 0 0 62 /**</span>
 <span class="s0">* Return the Shader's text for the given shader type.</span>
 <span class="s0">*/ 2 4 this 3 3597  4 type 5 3294  </span>
<span class="s0">1219 0 0 6 1484 3178 0 0 160 /**</span>
 <span class="s0">* Returns true if the shader contains a compile-time error.  This doesn't</span>
 <span class="s0">* tell you whether or not the shader is supported on the current video card.</span>
 <span class="s0">*/ 1 4 this 3 3597  </span>
<span class="s0">1220 0 0 6 1485 3293 0 0 72 /**</span>
 <span class="s0">* Returns the shader language in which this shader was written.</span>
 <span class="s0">*/ 1 4 this 3 3597  </span>
<span class="s0">1221 0 0 6 1486 3178 0 0 94 /**</span>
 <span class="s0">* Returns true if the fullpath has been set and is available.  See</span>
 <span class="s0">* set_fullpath().</span>
 <span class="s0">*/ 1 4 this 3 3597  </span>
<span class="s0">1222 0 0 6 1487 3569 0 0 126 /**</span>
 <span class="s0">* Returns the fullpath that has been set.  This is the full path to the file</span>
 <span class="s0">* as it was found along the model-path.</span>
 <span class="s0">*/ 1 4 this 3 3597  </span>
<span class="s0">1223 0 0 6 1488 3178 0 0 102 /**</span>
 <span class="s0">* Returns the setting of the cache_compiled_shader flag.  See</span>
 <span class="s0">* set_cache_compiled_shader().</span>
 <span class="s0">*/ 1 4 this 3 3597  </span>
<span class="s0">1224 0 0 4 1489 3346 0 0 414 /**</span>
 <span class="s0">* Sets the cache_compiled_shader flag.  When this is set, the next time the</span>
 <span class="s0">* Shader is loaded on a GSG, it will automatically extract the compiled</span>
 <span class="s0">* shader from the GSG and save it to the global BamCache.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used to store compiled shaders in the BamCache.  This flag should</span>
 <span class="s0">* not be set explicitly; it is set automatically by the ShaderPool when</span>
 <span class="s0">* model-cache-compiled-shaders is set true.</span>
 <span class="s0">*/ 2 4 this 3 3331  4 flag 1 3178  </span>
<span class="s0">1225 0 0 7 1490 3594 0 0 362 /**</span>
 <span class="s0">* Indicates that the shader should be enqueued to be prepared in the</span>
 <span class="s0">* indicated prepared_objects at the beginning of the next frame.  This will</span>
 <span class="s0">* ensure the texture is already loaded into texture memory if it is expected</span>
 <span class="s0">* to be rendered soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload textures from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/ 2 4 this 3 3331  16 prepared_objects 1 3404  </span>
<span class="s0">1226 0 0 6 1491 3178 0 0 133 /**</span>
 <span class="s0">* Returns true if the shader has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3597  16 prepared_objects 1 3404  </span>
<span class="s0">1227 0 0 6 1492 3178 0 0 157 /**</span>
 <span class="s0">* Frees the texture context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/ 2 4 this 3 3331  16 prepared_objects 1 3404  </span>
<span class="s0">1228 0 0 6 1493 3177 0 0 152 /**</span>
 <span class="s0">* Frees the context allocated on all objects for which the texture has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/ 1 4 this 3 3331  </span>
<span class="s0">1229 0 0 6 1494 3600 0 0 528 /**</span>
 <span class="s0">* Creates a context for the shader on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) ShaderContext.  This assumes that</span>
 <span class="s0">* the GraphicsStateGuardian is the currently active rendering context and</span>
 <span class="s0">* that it is ready to accept new textures.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a shader does not need to be explicitly prepared by the user before it may</span>
 <span class="s0">* be rendered.</span>
 <span class="s0">*/ 3 4 this 3 3331  16 prepared_objects 1 3404  3 gsg 1 3405  </span>
<span class="s0">1230 0 0 7 1495 3362 0 0 0 0 </span>
<span class="s0">1231 0 0 15 1505 3603 2790 0 0 1 6 param0 0 3601  </span>
<span class="s0">1232 0 0 7 1505 3603 2790 0 155 /**</span>
 <span class="s0">* Creates an uninitialized buffer object with the given size.  For now, these</span>
 <span class="s0">* parameters cannot be modified, but this may change in the future.</span>
 <span class="s0">*/ 3 4 name 1 3342  4 size 1 3298  10 usage_hint 1 3169  </span>
<span class="s0">1233 0 0 7 1505 3603 2790 0 152 /**</span>
 <span class="s0">* Creates a buffer object initialized with the given data.  For now, these</span>
 <span class="s0">* parameters cannot be modified, but this may change in the future.</span>
 <span class="s0">*/ 3 4 name 1 3342  12 initial_data 1 3412  10 usage_hint 1 3169  </span>
<span class="s0">1234 0 0 4 1511 3346 0 0 344 /**</span>
 <span class="s0">* Indicates that the data should be enqueued to be prepared in the indicated</span>
 <span class="s0">* prepared_objects at the beginning of the next frame.  This will ensure the</span>
 <span class="s0">* data is already loaded into the GSG if it is expected to be rendered soon.</span>
 <span class="s0">*</span>
 <span class="s0">* Use this function instead of prepare_now() to preload datas from a user</span>
 <span class="s0">* interface standpoint.</span>
 <span class="s0">*/ 2 4 this 3 3603  16 prepared_objects 1 3404  </span>
<span class="s0">1235 0 0 6 1512 3178 0 0 131 /**</span>
 <span class="s0">* Returns true if the data has already been prepared or enqueued for</span>
 <span class="s0">* preparation on the indicated GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3601  16 prepared_objects 1 3404  </span>
<span class="s0">1236 0 0 6 1513 3451 0 0 521 /**</span>
 <span class="s0">* Creates a context for the data on the particular GSG, if it does not</span>
 <span class="s0">* already exist.  Returns the new (or old) BufferContext.  This assumes</span>
 <span class="s0">* that the GraphicsStateGuardian is the currently active rendering context</span>
 <span class="s0">* and that it is ready to accept new datas.  If this is not necessarily the</span>
 <span class="s0">* case, you should use prepare() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this is not called directly except by the GraphicsStateGuardian;</span>
 <span class="s0">* a data does not need to be explicitly prepared by the user before it may be</span>
 <span class="s0">* rendered.</span>
 <span class="s0">*/ 3 4 this 3 3603  16 prepared_objects 1 3404  3 gsg 1 3405  </span>
<span class="s0">1237 0 0 6 1514 3178 0 0 154 /**</span>
 <span class="s0">* Frees the data context only on the indicated object, if it exists there.</span>
 <span class="s0">* Returns true if it was released, false if it had not been prepared.</span>
 <span class="s0">*/ 2 4 this 3 3603  16 prepared_objects 1 3404  </span>
<span class="s0">1238 0 0 6 1515 3177 0 0 149 /**</span>
 <span class="s0">* Frees the context allocated on all objects for which the data has been</span>
 <span class="s0">* declared.  Returns the number of contexts which have been freed.</span>
 <span class="s0">*/ 1 4 this 3 3603  </span>
<span class="s0">1239 0 0 7 1516 3362 0 0 0 0 </span>
<span class="s0">1240 0 0 7 1498 3241 0 0 0 1 4 this 3 3603  </span>
<span class="s0">1241 0 0 6 1500 3374 0 0 0 1 4 this 3 3603  </span>
<span class="s0">1242 0 0 6 1502 3353 0 0 0 1 4 this 3 3603  </span>
<span class="s0">1243 0 0 6 1518 3342 0 0 167 /**</span>
 <span class="s0">* Returns the name of the PreparedGraphicsObjects structure.  This is an</span>
 <span class="s0">* arbitrary name that serves mainly to uniquify the context for PStats</span>
 <span class="s0">* reporting.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1244 0 0 4 1519 3346 0 0 503 /**</span>
 <span class="s0">* Sets an artificial cap on graphics memory that will be imposed on this GSG.</span>
 <span class="s0">*</span>
 <span class="s0">* This limits the total amount of graphics memory, including texture memory</span>
 <span class="s0">* and vertex buffer memory, that will be consumed by the GSG, regardless of</span>
 <span class="s0">* whether the hardware claims to provide more graphics memory than this.  It</span>
 <span class="s0">* is useful to put a ceiling on graphics memory consumed, since some drivers</span>
 <span class="s0">* seem to allow the application to consume more memory than the hardware can</span>
 <span class="s0">* realistically support.</span>
 <span class="s0">*/ 2 4 this 3 3404  5 limit 1 3209  </span>
<span class="s0">1245 0 0 6 1520 3209 0 0 127 /**</span>
 <span class="s0">* Returns the artificial cap on graphics memory that will be imposed on this</span>
 <span class="s0">* GSG.  See set_graphics_memory_limit().</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1246 0 0 4 1521 3346 0 0 127 /**</span>
 <span class="s0">* Writes to the indicated ostream a report of how the various textures and</span>
 <span class="s0">* vertex buffers are allocated in the LRU.</span>
 <span class="s0">*/ 2 4 this 3 3604  3 out 1 3347  </span>
<span class="s0">1247 0 0 4 1522 3346 0 0 127 /**</span>
 <span class="s0">* Writes to the indicated ostream a report of how the various textures and</span>
 <span class="s0">* vertex buffers are allocated in the LRU.</span>
 <span class="s0">*/ 2 4 this 3 3604  3 out 1 3347  </span>
<span class="s0">1248 0 0 4 1523 3346 0 0 62 /**</span>
 <span class="s0">* Releases all prepared objects of all kinds at once.</span>
 <span class="s0">*/ 1 4 this 3 3404  </span>
<span class="s0">1249 0 0 6 1524 3177 0 0 107 /**</span>
 <span class="s0">* Returns the number of objects of any kind that have been enqueued to be</span>
 <span class="s0">* prepared on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1250 0 0 6 1525 3177 0 0 100 /**</span>
 <span class="s0">* Returns the number of objects of any kind that have already been prepared</span>
 <span class="s0">* on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1251 0 0 4 1526 3346 0 0 156 /**</span>
 <span class="s0">* Indicates that a texture would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/ 2 4 this 3 3404  3 tex 1 3325  </span>
<span class="s0">1252 0 0 6 1527 3178 0 0 84 /**</span>
 <span class="s0">* Returns true if the texture has been queued on this GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  3 tex 1 3567  </span>
<span class="s0">1253 0 0 6 1528 3178 0 0 385 /**</span>
 <span class="s0">* Removes a texture from the queued list of textures to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the texture will automatically</span>
 <span class="s0">* be dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the texture is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/ 2 4 this 3 3404  3 tex 1 3325  </span>
<span class="s0">1254 0 0 6 1529 3178 0 0 86 /**</span>
 <span class="s0">* Returns true if the texture has been prepared on this GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  3 tex 1 3567  </span>
<span class="s0">1255 0 0 4 1530 3346 0 0 107 /**</span>
 <span class="s0">* Releases a texture if it has already been prepared, or removes it from the</span>
 <span class="s0">* preparation queue.</span>
 <span class="s0">*/ 2 4 this 3 3404  3 tex 1 3325  </span>
<span class="s0">1256 0 0 4 1530 3346 0 0 478 /**</span>
 <span class="s0">* Indicates that a texture context, created by a previous call to</span>
 <span class="s0">* prepare_texture(), is no longer needed.  The driver resources will not be</span>
 <span class="s0">* freed until some GSG calls update(), indicating it is at a stage where it</span>
 <span class="s0">* is ready to release textures--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing textures (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_texture is called).</span>
 <span class="s0">*/ 2 4 this 3 3404  2 tc 1 3596  </span>
<span class="s0">1257 0 0 6 1531 3177 0 0 184 /**</span>
 <span class="s0">* Releases all textures at once.  This will force them to be reloaded into</span>
 <span class="s0">* texture memory for all GSG's that share this object.  Returns the number of</span>
 <span class="s0">* textures released.</span>
 <span class="s0">*/ 1 4 this 3 3404  </span>
<span class="s0">1258 0 0 6 1532 3177 0 0 96 /**</span>
 <span class="s0">* Returns the number of textures that have been enqueued to be prepared on</span>
 <span class="s0">* this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1259 0 0 6 1533 3177 0 0 86 /**</span>
 <span class="s0">* Returns the number of textures that have already been prepared on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1260 0 0 6 1534 3596 0 0 727 /**</span>
 <span class="s0">* Immediately creates a new TextureContext for the indicated texture and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new textures.  If</span>
 <span class="s0">* this is not necessarily the case, you should use enqueue_texture() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call</span>
 <span class="s0">* Texture::prepare_now() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The TextureContext contains all of the pertinent information needed by the</span>
 <span class="s0">* GSG to keep track of this one particular texture, and will exist as long as</span>
 <span class="s0">* the texture is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Texture or the PreparedGraphicsObjects object destructs,</span>
 <span class="s0">* the TextureContext will be deleted.</span>
 <span class="s0">*/ 4 4 this 3 3404  3 tex 1 3325  4 view 1 3177  3 gsg 1 3405  </span>
<span class="s0">1261 0 0 4 1535 3346 0 0 156 /**</span>
 <span class="s0">* Indicates that a sampler would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/ 2 4 this 3 3404  7 sampler 1 3564  </span>
<span class="s0">1262 0 0 6 1536 3178 0 0 84 /**</span>
 <span class="s0">* Returns true if the sampler has been queued on this GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  7 sampler 1 3564  </span>
<span class="s0">1263 0 0 6 1537 3178 0 0 385 /**</span>
 <span class="s0">* Removes a sampler from the queued list of samplers to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the sampler will automatically</span>
 <span class="s0">* be dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the sampler is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/ 2 4 this 3 3404  7 sampler 1 3564  </span>
<span class="s0">1264 0 0 6 1538 3178 0 0 86 /**</span>
 <span class="s0">* Returns true if the sampler has been prepared on this GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  7 sampler 1 3564  </span>
<span class="s0">1265 0 0 4 1539 3346 0 0 261 /**</span>
 <span class="s0">* Indicates that a sampler context, created by a previous call to</span>
 <span class="s0">* prepare_sampler(), is no longer needed.  The driver resources will not be</span>
 <span class="s0">* freed until some GSG calls update(), indicating it is at a stage where it</span>
 <span class="s0">* is ready to release samplers.</span>
 <span class="s0">*/ 2 4 this 3 3404  2 sc 1 3565  </span>
<span class="s0">1266 0 0 4 1539 3346 0 0 107 /**</span>
 <span class="s0">* Releases a sampler if it has already been prepared, or removes it from the</span>
 <span class="s0">* preparation queue.</span>
 <span class="s0">*/ 2 4 this 3 3404  7 sampler 1 3564  </span>
<span class="s0">1267 0 0 6 1540 3177 0 0 161 /**</span>
 <span class="s0">* Releases all samplers at once.  This will force them to be reloaded for all</span>
 <span class="s0">* GSG's that share this object.  Returns the number of samplers released.</span>
 <span class="s0">*/ 1 4 this 3 3404  </span>
<span class="s0">1268 0 0 6 1541 3177 0 0 96 /**</span>
 <span class="s0">* Returns the number of samplers that have been enqueued to be prepared on</span>
 <span class="s0">* this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1269 0 0 6 1542 3177 0 0 86 /**</span>
 <span class="s0">* Returns the number of samplers that have already been prepared on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1270 0 0 6 1543 3565 0 0 727 /**</span>
 <span class="s0">* Immediately creates a new SamplerContext for the indicated sampler and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new samplers.  If</span>
 <span class="s0">* this is not necessarily the case, you should use enqueue_sampler() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call</span>
 <span class="s0">* Sampler::prepare_now() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The SamplerContext contains all of the pertinent information needed by the</span>
 <span class="s0">* GSG to keep track of this one particular sampler, and will exist as long as</span>
 <span class="s0">* the sampler is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Sampler or the PreparedGraphicsObjects object destructs,</span>
 <span class="s0">* the SamplerContext will be deleted.</span>
 <span class="s0">*/ 3 4 this 3 3404  7 sampler 1 3564  3 gsg 1 3405  </span>
<span class="s0">1271 0 0 4 1544 3346 0 0 153 /**</span>
 <span class="s0">* Indicates that a geom would like to be put on the list to be prepared when</span>
 <span class="s0">* the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/ 2 4 this 3 3404  4 geom 1 3257  </span>
<span class="s0">1272 0 0 6 1545 3178 0 0 81 /**</span>
 <span class="s0">* Returns true if the geom has been queued on this GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  4 geom 1 3468  </span>
<span class="s0">1273 0 0 6 1546 3178 0 0 374 /**</span>
 <span class="s0">* Removes a geom from the queued list of geoms to be prepared.  Normally it</span>
 <span class="s0">* is not necessary to call this, unless you change your mind about preparing</span>
 <span class="s0">* it at the last minute, since the geom will automatically be dequeued and</span>
 <span class="s0">* prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the geom is successfully dequeued, false if it</span>
 <span class="s0">* had not been queued.</span>
 <span class="s0">*/ 2 4 this 3 3404  4 geom 1 3257  </span>
<span class="s0">1274 0 0 6 1547 3178 0 0 95 /**</span>
 <span class="s0">* Returns true if the vertex buffer has been prepared on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  4 geom 1 3468  </span>
<span class="s0">1275 0 0 4 1548 3346 0 0 463 /**</span>
 <span class="s0">* Indicates that a geom context, created by a previous call to</span>
 <span class="s0">* prepare_geom(), is no longer needed.  The driver resources will not be</span>
 <span class="s0">* freed until some GSG calls update(), indicating it is at a stage where it</span>
 <span class="s0">* is ready to release geoms--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing geoms (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_geom is called).</span>
 <span class="s0">*/ 2 4 this 3 3404  2 gc 1 3472  </span>
<span class="s0">1276 0 0 6 1549 3177 0 0 175 /**</span>
 <span class="s0">* Releases all geoms at once.  This will force them to be reloaded into geom</span>
 <span class="s0">* memory for all GSG's that share this object.  Returns the number of geoms</span>
 <span class="s0">* released.</span>
 <span class="s0">*/ 1 4 this 3 3404  </span>
<span class="s0">1277 0 0 6 1550 3177 0 0 93 /**</span>
 <span class="s0">* Returns the number of geoms that have been enqueued to be prepared on this</span>
 <span class="s0">* GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1278 0 0 6 1551 3177 0 0 83 /**</span>
 <span class="s0">* Returns the number of geoms that have already been prepared on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1279 0 0 6 1552 3472 0 0 697 /**</span>
 <span class="s0">* Immediately creates a new GeomContext for the indicated geom and returns</span>
 <span class="s0">* it.  This assumes that the GraphicsStateGuardian is the currently active</span>
 <span class="s0">* rendering context and that it is ready to accept new geoms.  If this is not</span>
 <span class="s0">* necessarily the case, you should use enqueue_geom() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Geom::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The GeomContext contains all of the pertinent information needed by the GSG</span>
 <span class="s0">* to keep track of this one particular geom, and will exist as long as the</span>
 <span class="s0">* geom is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Geom or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* GeomContext will be deleted.</span>
 <span class="s0">*/ 3 4 this 3 3404  4 geom 1 3257  3 gsg 1 3405  </span>
<span class="s0">1280 0 0 4 1553 3346 0 0 155 /**</span>
 <span class="s0">* Indicates that a shader would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/ 2 4 this 3 3404  6 shader 1 3331  </span>
<span class="s0">1281 0 0 6 1554 3178 0 0 83 /**</span>
 <span class="s0">* Returns true if the shader has been queued on this GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  6 shader 1 3597  </span>
<span class="s0">1282 0 0 6 1555 3178 0 0 382 /**</span>
 <span class="s0">* Removes a shader from the queued list of shaders to be prepared.  Normally</span>
 <span class="s0">* it is not necessary to call this, unless you change your mind about</span>
 <span class="s0">* preparing it at the last minute, since the shader will automatically be</span>
 <span class="s0">* dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the shader is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/ 2 4 this 3 3404  6 shader 1 3331  </span>
<span class="s0">1283 0 0 6 1556 3178 0 0 85 /**</span>
 <span class="s0">* Returns true if the shader has been prepared on this GSG, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  6 shader 1 3597  </span>
<span class="s0">1284 0 0 4 1557 3346 0 0 473 /**</span>
 <span class="s0">* Indicates that a shader context, created by a previous call to</span>
 <span class="s0">* prepare_shader(), is no longer needed.  The driver resources will not be</span>
 <span class="s0">* freed until some GSG calls update(), indicating it is at a stage where it</span>
 <span class="s0">* is ready to release shaders--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing shaders (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_shader is called).</span>
 <span class="s0">*/ 2 4 this 3 3404  2 sc 1 3600  </span>
<span class="s0">1285 0 0 6 1558 3177 0 0 181 /**</span>
 <span class="s0">* Releases all shaders at once.  This will force them to be reloaded into</span>
 <span class="s0">* shader memory for all GSG's that share this object.  Returns the number of</span>
 <span class="s0">* shaders released.</span>
 <span class="s0">*/ 1 4 this 3 3404  </span>
<span class="s0">1286 0 0 6 1559 3177 0 0 95 /**</span>
 <span class="s0">* Returns the number of shaders that have been enqueued to be prepared on</span>
 <span class="s0">* this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1287 0 0 6 1560 3177 0 0 85 /**</span>
 <span class="s0">* Returns the number of shaders that have already been prepared on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1288 0 0 6 1561 3600 0 0 717 /**</span>
 <span class="s0">* Immediately creates a new ShaderContext for the indicated shader and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new shaders.  If</span>
 <span class="s0">* this is not necessarily the case, you should use enqueue_shader() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Shader::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The ShaderContext contains all of the pertinent information needed by the</span>
 <span class="s0">* GSG to keep track of this one particular shader, and will exist as long as</span>
 <span class="s0">* the shader is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Shader or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* ShaderContext will be deleted.</span>
 <span class="s0">*/ 3 4 this 3 3404  6 shader 1 3331  3 gsg 1 3405  </span>
<span class="s0">1289 0 0 4 1562 3346 0 0 155 /**</span>
 <span class="s0">* Indicates that a buffer would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/ 2 4 this 3 3404  4 data 1 3213  </span>
<span class="s0">1290 0 0 6 1563 3178 0 0 93 /**</span>
 <span class="s0">* Returns true if the vertex buffer has been queued on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  4 data 1 3365  </span>
<span class="s0">1291 0 0 6 1564 3178 0 0 383 /**</span>
 <span class="s0">* Removes a buffer from the queued list of data arrays to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the data will automatically be</span>
 <span class="s0">* dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the buffer is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/ 2 4 this 3 3404  4 data 1 3213  </span>
<span class="s0">1292 0 0 6 1565 3178 0 0 95 /**</span>
 <span class="s0">* Returns true if the vertex buffer has been prepared on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  4 data 1 3365  </span>
<span class="s0">1293 0 0 4 1566 3346 0 0 481 /**</span>
 <span class="s0">* Indicates that a data context, created by a previous call to</span>
 <span class="s0">* prepare_vertex_buffer(), is no longer needed.  The driver resources will</span>
 <span class="s0">* not be freed until some GSG calls update(), indicating it is at a stage</span>
 <span class="s0">* where it is ready to release datas--this prevents conflicts from threading</span>
 <span class="s0">* or multiple GSG's sharing datas (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_vertex_buffer is called).</span>
 <span class="s0">*/ 2 4 this 3 3404  3 vbc 1 3407  </span>
<span class="s0">1294 0 0 6 1567 3177 0 0 175 /**</span>
 <span class="s0">* Releases all datas at once.  This will force them to be reloaded into data</span>
 <span class="s0">* memory for all GSG's that share this object.  Returns the number of datas</span>
 <span class="s0">* released.</span>
 <span class="s0">*/ 1 4 this 3 3404  </span>
<span class="s0">1295 0 0 6 1568 3177 0 0 102 /**</span>
 <span class="s0">* Returns the number of vertex buffers that have been enqueued to be prepared</span>
 <span class="s0">* on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1296 0 0 6 1569 3177 0 0 95 /**</span>
 <span class="s0">* Returns the number of vertex buffers that have already been prepared on</span>
 <span class="s0">* this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1297 0 0 6 1570 3407 0 0 733 /**</span>
 <span class="s0">* Immediately creates a new VertexBufferContext for the indicated data and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new datas.  If this</span>
 <span class="s0">* is not necessarily the case, you should use enqueue_vertex_buffer()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Data::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The VertexBufferContext contains all of the pertinent information needed by</span>
 <span class="s0">* the GSG to keep track of this one particular data, and will exist as long</span>
 <span class="s0">* as the data is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Data or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* VertexBufferContext will be deleted.</span>
 <span class="s0">*/ 3 4 this 3 3404  4 data 1 3213  3 gsg 1 3405  </span>
<span class="s0">1298 0 0 4 1571 3346 0 0 155 /**</span>
 <span class="s0">* Indicates that a buffer would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/ 2 4 this 3 3404  4 data 1 3453  </span>
<span class="s0">1299 0 0 6 1572 3178 0 0 92 /**</span>
 <span class="s0">* Returns true if the index buffer has been queued on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  4 data 1 3454  </span>
<span class="s0">1300 0 0 6 1573 3178 0 0 383 /**</span>
 <span class="s0">* Removes a buffer from the queued list of data arrays to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the data will automatically be</span>
 <span class="s0">* dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the buffer is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/ 2 4 this 3 3404  4 data 1 3453  </span>
<span class="s0">1301 0 0 6 1574 3178 0 0 94 /**</span>
 <span class="s0">* Returns true if the index buffer has been prepared on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  4 data 1 3454  </span>
<span class="s0">1302 0 0 4 1575 3346 0 0 479 /**</span>
 <span class="s0">* Indicates that a data context, created by a previous call to</span>
 <span class="s0">* prepare_index_buffer(), is no longer needed.  The driver resources will not</span>
 <span class="s0">* be freed until some GSG calls update(), indicating it is at a stage where</span>
 <span class="s0">* it is ready to release datas--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing datas (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_index_buffer is called).</span>
 <span class="s0">*/ 2 4 this 3 3404  3 ibc 1 3606  </span>
<span class="s0">1303 0 0 6 1576 3177 0 0 175 /**</span>
 <span class="s0">* Releases all datas at once.  This will force them to be reloaded into data</span>
 <span class="s0">* memory for all GSG's that share this object.  Returns the number of datas</span>
 <span class="s0">* released.</span>
 <span class="s0">*/ 1 4 this 3 3404  </span>
<span class="s0">1304 0 0 6 1577 3177 0 0 101 /**</span>
 <span class="s0">* Returns the number of index buffers that have been enqueued to be prepared</span>
 <span class="s0">* on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1305 0 0 6 1578 3177 0 0 94 /**</span>
 <span class="s0">* Returns the number of index buffers that have already been prepared on this</span>
 <span class="s0">* GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1306 0 0 6 1579 3606 0 0 726 /**</span>
 <span class="s0">* Immediately creates a new IndexBufferContext for the indicated data and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new datas.  If this</span>
 <span class="s0">* is not necessarily the case, you should use enqueue_index_buffer() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Data::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The IndexBufferContext contains all of the pertinent information needed by</span>
 <span class="s0">* the GSG to keep track of this one particular data, and will exist as long</span>
 <span class="s0">* as the data is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Data or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* IndexBufferContext will be deleted.</span>
 <span class="s0">*/ 3 4 this 3 3404  4 data 1 3453  3 gsg 1 3405  </span>
<span class="s0">1307 0 0 4 1580 3346 0 0 155 /**</span>
 <span class="s0">* Indicates that a buffer would like to be put on the list to be prepared</span>
 <span class="s0">* when the GSG is next ready to do this (presumably at the next frame).</span>
 <span class="s0">*/ 2 4 this 3 3404  4 data 1 3603  </span>
<span class="s0">1308 0 0 6 1581 3178 0 0 92 /**</span>
 <span class="s0">* Returns true if the index buffer has been queued on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  4 data 1 3601  </span>
<span class="s0">1309 0 0 6 1582 3178 0 0 383 /**</span>
 <span class="s0">* Removes a buffer from the queued list of data arrays to be prepared.</span>
 <span class="s0">* Normally it is not necessary to call this, unless you change your mind</span>
 <span class="s0">* about preparing it at the last minute, since the data will automatically be</span>
 <span class="s0">* dequeued and prepared at the next frame.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the buffer is successfully dequeued, false if</span>
 <span class="s0">* it had not been queued.</span>
 <span class="s0">*/ 2 4 this 3 3404  4 data 1 3603  </span>
<span class="s0">1310 0 0 6 1583 3178 0 0 94 /**</span>
 <span class="s0">* Returns true if the index buffer has been prepared on this GSG, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3604  4 data 1 3601  </span>
<span class="s0">1311 0 0 4 1584 3346 0 0 481 /**</span>
 <span class="s0">* Indicates that a data context, created by a previous call to</span>
 <span class="s0">* prepare_shader_buffer(), is no longer needed.  The driver resources will not</span>
 <span class="s0">* be freed until some GSG calls update(), indicating it is at a stage where</span>
 <span class="s0">* it is ready to release datas--this prevents conflicts from threading or</span>
 <span class="s0">* multiple GSG's sharing datas (we have no way of knowing which graphics</span>
 <span class="s0">* context is currently active, or what state it's in, at the time</span>
 <span class="s0">* release_shader_buffer is called).</span>
 <span class="s0">*/ 2 4 this 3 3404  2 bc 1 3451  </span>
<span class="s0">1312 0 0 6 1585 3177 0 0 175 /**</span>
 <span class="s0">* Releases all datas at once.  This will force them to be reloaded into data</span>
 <span class="s0">* memory for all GSG's that share this object.  Returns the number of datas</span>
 <span class="s0">* released.</span>
 <span class="s0">*/ 1 4 this 3 3404  </span>
<span class="s0">1313 0 0 6 1586 3177 0 0 101 /**</span>
 <span class="s0">* Returns the number of index buffers that have been enqueued to be prepared</span>
 <span class="s0">* on this GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1314 0 0 6 1587 3177 0 0 94 /**</span>
 <span class="s0">* Returns the number of index buffers that have already been prepared on this</span>
 <span class="s0">* GSG.</span>
 <span class="s0">*/ 1 4 this 3 3604  </span>
<span class="s0">1315 0 0 6 1588 3451 0 0 712 /**</span>
 <span class="s0">* Immediately creates a new BufferContext for the indicated data and</span>
 <span class="s0">* returns it.  This assumes that the GraphicsStateGuardian is the currently</span>
 <span class="s0">* active rendering context and that it is ready to accept new datas.  If this</span>
 <span class="s0">* is not necessarily the case, you should use enqueue_shader_buffer() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this function is not called directly.  Call Data::prepare_now()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*</span>
 <span class="s0">* The BufferContext contains all of the pertinent information needed by</span>
 <span class="s0">* the GSG to keep track of this one particular data, and will exist as long</span>
 <span class="s0">* as the data is ready to be rendered.</span>
 <span class="s0">*</span>
 <span class="s0">* When either the Data or the PreparedGraphicsObjects object destructs, the</span>
 <span class="s0">* BufferContext will be deleted.</span>
 <span class="s0">*/ 3 4 this 3 3404  4 data 1 3603  3 gsg 1 3405  </span>
<span class="s0">1316 0 0 7 1594 3453 2124 0 68 /**</span>
 <span class="s0">* Returns the pointer to the client-side array data object.</span>
 <span class="s0">*/ 1 4 this 3 3607  </span>
<span class="s0">1317 0 0 6 1595 3178 0 0 101 /**</span>
 <span class="s0">* Returns true if the data has changed size since the last time mark_loaded()</span>
 <span class="s0">* was called.</span>
 <span class="s0">*/ 2 4 this 3 3607  6 reader 1 3609  </span>
<span class="s0">1318 0 0 6 1596 3178 0 0 111 /**</span>
 <span class="s0">* Returns true if the data has changed its usage hint since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/ 2 4 this 3 3607  6 reader 1 3609  </span>
<span class="s0">1319 0 0 6 1597 3178 0 0 102 /**</span>
 <span class="s0">* Returns true if the data has been modified since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/ 2 4 this 3 3607  6 reader 1 3609  </span>
<span class="s0">1320 0 0 7 1598 3362 0 0 0 0 </span>
<span class="s0">1321 0 0 6 1590 3451 0 0 0 1 4 this 3 3606  </span>
<span class="s0">1322 0 0 6 1592 3351 0 0 0 1 4 this 3 3606  </span>
<span class="s0">1323 0 0 7 1602 3614 2948 0 0 1 4 this 3 3612  </span>
<span class="s0">1324 0 0 6 1603 3178 0 0 447 /**</span>
 <span class="s0">* Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is</span>
 <span class="s0">* the center of the lens and (-1,-1) is the lower-left corner, compute the</span>
 <span class="s0">* corresponding vector in space that maps to this point, if such a vector can</span>
 <span class="s0">* be determined.  The vector is returned by indicating the points on the near</span>
 <span class="s0">* plane and far plane that both map to the indicated 2-d point.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the vector is defined, or false otherwise.</span>
 <span class="s0">*/ 4 4 this 3 3612  7 point2d 1 3615  10 near_point 1 3619  9 far_point 1 3619  </span>
<span class="s0">1325 0 0 6 1603 3178 0 0 499 /**</span>
 <span class="s0">* Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is</span>
 <span class="s0">* the center of the lens and (-1,-1) is the lower-left corner, compute the</span>
 <span class="s0">* corresponding vector in space that maps to this point, if such a vector can</span>
 <span class="s0">* be determined.  The vector is returned by indicating the points on the near</span>
 <span class="s0">* plane and far plane that both map to the indicated 2-d point.</span>
 <span class="s0">*</span>
 <span class="s0">* The z coordinate of the 2-d point is ignored.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the vector is defined, or false otherwise.</span>
 <span class="s0">*/ 4 4 this 3 3612  7 point2d 1 3620  10 near_point 1 3619  9 far_point 1 3619  </span>
<span class="s0">1326 0 0 6 1604 3178 0 0 262 /**</span>
 <span class="s0">* Uses the depth component of the 3-d result from project() to compute the</span>
 <span class="s0">* original point in 3-d space corresponding to a particular point on the</span>
 <span class="s0">* lens.  This exactly reverses project(), assuming the point does fall</span>
 <span class="s0">* legitimately within the lens.</span>
 <span class="s0">*/ 3 4 this 3 3612  7 point2d 1 3620  7 point3d 1 3619  </span>
<span class="s0">1327 0 0 6 1605 3178 0 0 513 /**</span>
 <span class="s0">* Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is</span>
 <span class="s0">* the center of the lens and (-1,-1) is the lower-left corner, compute the</span>
 <span class="s0">* vector that corresponds to the view direction.  This will be parallel to</span>
 <span class="s0">* the normal on the surface (the far plane) corresponding to the lens shape</span>
 <span class="s0">* at this point.</span>
 <span class="s0">*</span>
 <span class="s0">* See the comment block on Lens::extrude_vec_impl() for a more in-depth</span>
 <span class="s0">* comment on the meaning of this vector.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the vector is defined, or false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 3612  7 point2d 1 3615  5 vec3d 1 3622  </span>
<span class="s0">1328 0 0 6 1605 3178 0 0 565 /**</span>
 <span class="s0">* Given a 2-d point in the range (-1,1) in both dimensions, where (0,0) is</span>
 <span class="s0">* the center of the lens and (-1,-1) is the lower-left corner, compute the</span>
 <span class="s0">* vector that corresponds to the view direction.  This will be parallel to</span>
 <span class="s0">* the normal on the surface (the far plane) corresponding to the lens shape</span>
 <span class="s0">* at this point.</span>
 <span class="s0">*</span>
 <span class="s0">* See the comment block on Lens::extrude_vec_impl() for a more in-depth</span>
 <span class="s0">* comment on the meaning of this vector.</span>
 <span class="s0">*</span>
 <span class="s0">* The z coordinate of the 2-d point is ignored.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the vector is defined, or false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 3612  7 point2d 1 3620  5 vec3d 1 3622  </span>
<span class="s0">1329 0 0 6 1606 3178 0 0 449 /**</span>
 <span class="s0">* Given a 3-d point in space, determine the 2-d point this maps to, in the</span>
 <span class="s0">* range (-1,1) in both dimensions, where (0,0) is the center of the lens and</span>
 <span class="s0">* (-1,-1) is the lower-left corner.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the 3-d point is in front of the lens and within the</span>
 <span class="s0">* viewing frustum (in which case point2d is filled in), or false otherwise</span>
 <span class="s0">* (in which case point2d will be filled in with something, which may or may</span>
 <span class="s0">* not be meaningful).</span>
 <span class="s0">*/ 3 4 this 3 3612  7 point3d 1 3620  7 point2d 1 3624  </span>
<span class="s0">1330 0 0 6 1606 3178 0 0 618 /**</span>
 <span class="s0">* Given a 3-d point in space, determine the 2-d point this maps to, in the</span>
 <span class="s0">* range (-1,1) in both dimensions, where (0,0) is the center of the lens and</span>
 <span class="s0">* (-1,-1) is the lower-left corner.</span>
 <span class="s0">*</span>
 <span class="s0">* The z coordinate will also be set to a value in the range (-1, 1), where 1</span>
 <span class="s0">* represents a point on the near plane, and -1 represents a point on the far</span>
 <span class="s0">* plane.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the 3-d point is in front of the lens and within the</span>
 <span class="s0">* viewing frustum (in which case point2d is filled in), or false otherwise</span>
 <span class="s0">* (in which case point2d will be filled in with something, which may or may</span>
 <span class="s0">* not be meaningful).</span>
 <span class="s0">*/ 3 4 this 3 3612  7 point3d 1 3620  7 point2d 1 3619  </span>
<span class="s0">1331 0 0 4 1607 3346 0 0 343 /**</span>
 <span class="s0">* Sets the name of the event that will be generated whenever any properties</span>
 <span class="s0">* of the Lens have changed.  If this is not set for a particular lens, no</span>
 <span class="s0">* event will be generated.</span>
 <span class="s0">*</span>
 <span class="s0">* The event is thrown with one parameter, the lens itself.  This can be used</span>
 <span class="s0">* to automatically track changes to camera fov, etc.  in the application.</span>
 <span class="s0">*/ 2 4 this 3 3614  5 event 1 3342  </span>
<span class="s0">1332 0 0 6 1608 3342 0 0 128 /**</span>
 <span class="s0">* Returns the name of the event that will be generated whenever any</span>
 <span class="s0">* properties of this particular Lens have changed.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1333 0 0 4 1610 3346 0 0 138 /**</span>
 <span class="s0">* Specifies the coordinate system that all 3-d computations are performed</span>
 <span class="s0">* within for this Lens.  Normally, this is CS_default.</span>
 <span class="s0">*/ 2 4 this 3 3614  2 cs 1 3303  </span>
<span class="s0">1334 0 0 6 1611 3303 0 0 136 /**</span>
 <span class="s0">* Returns the coordinate system that all 3-d computations are performed</span>
 <span class="s0">* within for this Lens.  Normally, this is CS_default.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1335 0 0 4 1614 3346 0 0 72 /**</span>
 <span class="s0">* Resets all lens parameters to their initial default settings.</span>
 <span class="s0">*/ 1 4 this 3 3614  </span>
<span class="s0">1336 0 0 4 1615 3346 0 0 767 /**</span>
 <span class="s0">* Sets the size and shape of the &quot;film&quot; within the lens.  This both</span>
 <span class="s0">* establishes the units used by calls like set_focal_length(), and</span>
 <span class="s0">* establishes the aspect ratio of the frame.</span>
 <span class="s0">*</span>
 <span class="s0">* In a physical camera, the field of view of a lens is determined by the</span>
 <span class="s0">* lens' focal length and by the size of the film area exposed by the lens.</span>
 <span class="s0">* For instance, a 35mm camera exposes a rectangle on the film about 24mm x</span>
 <span class="s0">* 36mm, which means a 50mm lens gives about a 40-degree horizontal field of</span>
 <span class="s0">* view.</span>
 <span class="s0">*</span>
 <span class="s0">* In the virtual camera, you may set the film size to any units here, and</span>
 <span class="s0">* specify a focal length in the same units to simulate the same effect.  Or,</span>
 <span class="s0">* you may ignore this parameter, and specify the field of view and aspect</span>
 <span class="s0">* ratio of the lens directly.</span>
 <span class="s0">*/ 2 4 this 3 3614  9 film_size 1 3534  </span>
<span class="s0">1337 0 0 4 1615 3346 0 0 206 /**</span>
 <span class="s0">* Sets the horizontal size of the film without changing its shape.  The</span>
 <span class="s0">* aspect ratio remains unchanged; this computes the vertical size of the film</span>
 <span class="s0">* to automatically maintain the aspect ratio.</span>
 <span class="s0">*/ 2 4 this 3 3614  5 width 1 3220  </span>
<span class="s0">1338 0 0 4 1615 3346 0 0 767 /**</span>
 <span class="s0">* Sets the size and shape of the &quot;film&quot; within the lens.  This both</span>
 <span class="s0">* establishes the units used by calls like set_focal_length(), and</span>
 <span class="s0">* establishes the aspect ratio of the frame.</span>
 <span class="s0">*</span>
 <span class="s0">* In a physical camera, the field of view of a lens is determined by the</span>
 <span class="s0">* lens' focal length and by the size of the film area exposed by the lens.</span>
 <span class="s0">* For instance, a 35mm camera exposes a rectangle on the film about 24mm x</span>
 <span class="s0">* 36mm, which means a 50mm lens gives about a 40-degree horizontal field of</span>
 <span class="s0">* view.</span>
 <span class="s0">*</span>
 <span class="s0">* In the virtual camera, you may set the film size to any units here, and</span>
 <span class="s0">* specify a focal length in the same units to simulate the same effect.  Or,</span>
 <span class="s0">* you may ignore this parameter, and specify the field of view and aspect</span>
 <span class="s0">* ratio of the lens directly.</span>
 <span class="s0">*/ 3 4 this 3 3614  5 width 1 3220  6 height 1 3220  </span>
<span class="s0">1339 0 0 6 1616 3534 0 0 102 /**</span>
 <span class="s0">* Returns the horizontal and vertical film size of the virtual film.  See</span>
 <span class="s0">* set_film_size().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1340 0 0 4 1621 3346 0 0 193 /**</span>
 <span class="s0">* Sets the horizontal and vertical offset amounts of this Lens.  These are</span>
 <span class="s0">* both in the same units specified in set_film_size().</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to establish an off-axis lens.</span>
 <span class="s0">*/ 2 4 this 3 3614  11 film_offset 1 3534  </span>
<span class="s0">1341 0 0 4 1621 3346 0 0 193 /**</span>
 <span class="s0">* Sets the horizontal and vertical offset amounts of this Lens.  These are</span>
 <span class="s0">* both in the same units specified in set_film_size().</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to establish an off-axis lens.</span>
 <span class="s0">*/ 3 4 this 3 3614  1 x 1 3220  1 y 1 3220  </span>
<span class="s0">1342 0 0 6 1622 3625 0 0 102 /**</span>
 <span class="s0">* Returns the horizontal and vertical offset amounts of this Lens.  See</span>
 <span class="s0">* set_film_offset().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1343 0 0 4 1627 3346 0 0 246 /**</span>
 <span class="s0">* Sets the focal length of the lens.  This may adjust the field-of-view</span>
 <span class="s0">* correspondingly, and is an alternate way to specify field of view.</span>
 <span class="s0">*</span>
 <span class="s0">* For certain kinds of lenses (e.g.  OrthographicLens), the focal length has</span>
 <span class="s0">* no meaning.</span>
 <span class="s0">*/ 2 4 this 3 3614  12 focal_length 1 3220  </span>
<span class="s0">1344 0 0 6 1628 3220 0 0 257 /**</span>
 <span class="s0">* Returns the focal length of the lens.  This may have been set explicitly by</span>
 <span class="s0">* a previous call to set_focal_length(), or it may be computed based on the</span>
 <span class="s0">* lens' fov and film_size.  For certain kinds of lenses, the focal length has</span>
 <span class="s0">* no meaning.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1345 0 0 4 1630 3346 0 0 499 /**</span>
 <span class="s0">* Sets the field of view of the smallest dimension of the window.  If the</span>
 <span class="s0">* window is wider than it is tall, this specifies the vertical field of view;</span>
 <span class="s0">* if it is taller than it is wide, this specifies the horizontal field of</span>
 <span class="s0">* view.</span>
 <span class="s0">*</span>
 <span class="s0">* In many cases, this is preferable to setting either the horizontal or</span>
 <span class="s0">* vertical field of view explicitly.  Setting this parameter means that</span>
 <span class="s0">* pulling the window wider will widen the field of view, which is usually</span>
 <span class="s0">* what you expect to happen.</span>
 <span class="s0">*/ 2 4 this 3 3614  7 min_fov 1 3220  </span>
<span class="s0">1346 0 0 4 1631 3346 0 0 334 /**</span>
 <span class="s0">* Sets the field of view of the lens in both dimensions.  This establishes</span>
 <span class="s0">* both the field of view and the aspect ratio of the lens.  This is one way</span>
 <span class="s0">* to specify the field of view of a lens; set_focal_length() is another way.</span>
 <span class="s0">*</span>
 <span class="s0">* For certain kinds of lenses (like OrthographicLens), the field of view has</span>
 <span class="s0">* no meaning.</span>
 <span class="s0">*/ 2 4 this 3 3614  3 fov 1 3534  </span>
<span class="s0">1347 0 0 4 1631 3346 0 0 172 /**</span>
 <span class="s0">* Sets the horizontal field of view of the lens without changing the aspect</span>
 <span class="s0">* ratio.  The vertical field of view is adjusted to maintain the same aspect</span>
 <span class="s0">* ratio.</span>
 <span class="s0">*/ 2 4 this 3 3614  3 fov 1 3220  </span>
<span class="s0">1348 0 0 4 1631 3346 0 0 327 /**</span>
 <span class="s0">* Sets the field of view of the lens in both dimensions.  This establishes</span>
 <span class="s0">* both the field of view and the aspect ratio of the lens.  This is one way</span>
 <span class="s0">* to specify the field of view of a lens; set_focal_length() is another way.</span>
 <span class="s0">*</span>
 <span class="s0">* For certain kinds of lenses (like OrthoLens), the field of view has no</span>
 <span class="s0">* meaning.</span>
 <span class="s0">*/ 3 4 this 3 3614  4 hfov 1 3220  4 vfov 1 3220  </span>
<span class="s0">1349 0 0 6 1632 3534 0 0 96 /**</span>
 <span class="s0">* Returns the horizontal and vertical film size of the virtual film.  See</span>
 <span class="s0">* set_fov().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1350 0 0 6 1633 3220 0 0 72 /**</span>
 <span class="s0">* Returns the horizontal component of fov only.  See get_fov().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1351 0 0 6 1634 3220 0 0 70 /**</span>
 <span class="s0">* Returns the vertical component of fov only.  See get_fov().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1352 0 0 6 1635 3220 0 0 101 /**</span>
 <span class="s0">* Returns the field of view of the narrowest dimension of the window.  See</span>
 <span class="s0">* set_min_fov().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1353 0 0 4 1638 3346 0 0 189 /**</span>
 <span class="s0">* Sets the aspect ratio of the lens.  This is the ratio of the height to the</span>
 <span class="s0">* width of the generated image.  Setting this overrides the two-parameter fov</span>
 <span class="s0">* or film size setting.</span>
 <span class="s0">*/ 2 4 this 3 3614  12 aspect_ratio 1 3220  </span>
<span class="s0">1354 0 0 6 1639 3220 0 0 126 /**</span>
 <span class="s0">* Returns the aspect ratio of the Lens.  This is determined based on the</span>
 <span class="s0">* indicated film size; see set_film_size().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1355 0 0 4 1641 3346 0 0 142 /**</span>
 <span class="s0">* Defines the position of the near plane (or cylinder, sphere, whatever).</span>
 <span class="s0">* Points closer to the lens than this may not be rendered.</span>
 <span class="s0">*/ 2 4 this 3 3614  13 near_distance 1 3220  </span>
<span class="s0">1356 0 0 6 1642 3220 0 0 82 /**</span>
 <span class="s0">* Returns the position of the near plane (or cylinder, sphere, whatever).</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1357 0 0 4 1643 3346 0 0 144 /**</span>
 <span class="s0">* Defines the position of the far plane (or cylinder, sphere, whatever).</span>
 <span class="s0">* Points farther from the lens than this may not be rendered.</span>
 <span class="s0">*/ 2 4 this 3 3614  12 far_distance 1 3220  </span>
<span class="s0">1358 0 0 6 1644 3220 0 0 81 /**</span>
 <span class="s0">* Returns the position of the far plane (or cylinder, sphere, whatever).</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1359 0 0 4 1645 3346 0 0 58 /**</span>
 <span class="s0">* Simultaneously changes the near and far planes.</span>
 <span class="s0">*/ 3 4 this 3 3614  13 near_distance 1 3220  12 far_distance 1 3220  </span>
<span class="s0">1360 0 0 6 1648 3220 0 0 143 /**</span>
 <span class="s0">* Returns the default near plane distance that will be assigned to each</span>
 <span class="s0">* newly-created lens.  This is read from the Config.prc file.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1361 0 0 6 1649 3220 0 0 143 /**</span>
 <span class="s0">* Returns the default far plane distance that will be assigned to each newly-</span>
 <span class="s0">* created lens.  This is read from the Config.prc file.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1362 0 0 4 1650 3346 0 0 311 /**</span>
 <span class="s0">* Sets the direction in which the lens is facing.  Normally, this is down the</span>
 <span class="s0">* forward axis (usually the Y axis), but it may be rotated.  This is only one</span>
 <span class="s0">* way of specifying the rotation; you may also specify an explicit vector in</span>
 <span class="s0">* which to look, or you may give a complete transformation matrix.</span>
 <span class="s0">*/ 2 4 this 3 3614  8 view_hpr 1 3535  </span>
<span class="s0">1363 0 0 4 1650 3346 0 0 311 /**</span>
 <span class="s0">* Sets the direction in which the lens is facing.  Normally, this is down the</span>
 <span class="s0">* forward axis (usually the Y axis), but it may be rotated.  This is only one</span>
 <span class="s0">* way of specifying the rotation; you may also specify an explicit vector in</span>
 <span class="s0">* which to look, or you may give a complete transformation matrix.</span>
 <span class="s0">*/ 4 4 this 3 3614  1 h 1 3220  1 p 1 3220  1 r 1 3220  </span>
<span class="s0">1364 0 0 6 1651 3535 0 0 61 /**</span>
 <span class="s0">* Returns the direction in which the lens is facing.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1365 0 0 4 1656 3346 0 0 185 /**</span>
 <span class="s0">* Specifies the direction in which the lens is facing by giving an axis to</span>
 <span class="s0">* look along, and a perpendicular (or at least non-parallel) up axis.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_view_hpr().</span>
 <span class="s0">*/ 3 4 this 3 3614  11 view_vector 1 3626  9 up_vector 1 3626  </span>
<span class="s0">1366 0 0 4 1656 3346 0 0 185 /**</span>
 <span class="s0">* Specifies the direction in which the lens is facing by giving an axis to</span>
 <span class="s0">* look along, and a perpendicular (or at least non-parallel) up axis.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_view_hpr().</span>
 <span class="s0">*/ 7 4 this 3 3614  1 x 1 3220  1 y 1 3220  1 z 1 3220  1 i 1 3220  1 j 1 3220  1 k 1 3220  </span>
<span class="s0">1367 0 0 6 1657 3626 0 0 59 /**</span>
 <span class="s0">* Returns the axis along which the lens is facing.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1368 0 0 6 1658 3626 0 0 107 /**</span>
 <span class="s0">* Returns the axis perpendicular to the camera's view vector that indicates</span>
 <span class="s0">* the &quot;up&quot; direction.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1369 0 0 7 1659 3619 0 0 93 /**</span>
 <span class="s0">* Returns the center point of the lens: the point from which the lens is</span>
 <span class="s0">* viewing.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1370 0 0 4 1663 3346 0 0 459 /**</span>
 <span class="s0">* Sets the distance between the left and right eyes of a stereo camera.  This</span>
 <span class="s0">* distance is used to apply a stereo effect when the lens is rendered on a</span>
 <span class="s0">* stereo display region.  It only has an effect on a PerspectiveLens.</span>
 <span class="s0">*</span>
 <span class="s0">* The left eye and the right eye are each offset along the X axis by half of</span>
 <span class="s0">* this distance, so that this parameter specifies the total distance between</span>
 <span class="s0">* them.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_convergence_distance(), which relates.</span>
 <span class="s0">*/ 2 4 this 3 3614  20 interocular_distance 1 3220  </span>
<span class="s0">1371 0 0 6 1664 3220 0 0 42 /**</span>
 <span class="s0">* See set_interocular_distance().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1372 0 0 4 1665 3346 0 0 1332 /**</span>
 <span class="s0">* Sets the distance between between the camera plane and the point in the</span>
 <span class="s0">* distance that the left and right eyes are both looking at.  This distance</span>
 <span class="s0">* is used to apply a stereo effect when the lens is rendered on a stereo</span>
 <span class="s0">* display region.  It only has an effect on a PerspectiveLens.</span>
 <span class="s0">*</span>
 <span class="s0">* This parameter must be greater than 0, but may be as large as you like.  It</span>
 <span class="s0">* controls the distance at which the two stereo images will appear to</span>
 <span class="s0">* converge, which is a normal property of stereo vision.  Normally this</span>
 <span class="s0">* should be set to the distance from the camera to the area of interest in</span>
 <span class="s0">* your scene.  Anything beyond this distance will appear to go into the</span>
 <span class="s0">* screen, and anything closer will appear to come out of the screen.  If you</span>
 <span class="s0">* want to simulate parallel stereo, set this to infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this creates an off-axis frustum, which means that the lenses are</span>
 <span class="s0">* still pointing in the same direction, which is usually more desirable than</span>
 <span class="s0">* the more naive toe-in approach, where the two lenses are simply tilted</span>
 <span class="s0">* toward each other.</span>
 <span class="s0">*</span>
 <span class="s0">* Prior to Panda3D 1.9.0, the convergence was being calculated incorrectly.</span>
 <span class="s0">* It has since been corrected.  To restore the legacy behavior you can set</span>
 <span class="s0">* the stereo-lens-old-convergence variable to true.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see set_interocular_distance(), which relates.</span>
 <span class="s0">*/ 2 4 this 3 3614  20 convergence_distance 1 3220  </span>
<span class="s0">1373 0 0 6 1666 3220 0 0 42 /**</span>
 <span class="s0">* See set_convergence_distance().</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1374 0 0 4 1669 3346 0 0 489 /**</span>
 <span class="s0">* Sets an arbitrary transformation on the lens.  This replaces the individual</span>
 <span class="s0">* transformation components like set_view_hpr().</span>
 <span class="s0">*</span>
 <span class="s0">* Setting a transformation here will have a slightly different effect than</span>
 <span class="s0">* putting one on the LensNode that contains this lens.  In particular,</span>
 <span class="s0">* lighting and other effects computations will still be performed on the lens</span>
 <span class="s0">* in its untransformed (facing forward) position, but the actual projection</span>
 <span class="s0">* matrix will be transformed by this matrix.</span>
 <span class="s0">*/ 2 4 this 3 3614  8 view_mat 1 3418  </span>
<span class="s0">1375 0 0 6 1670 3418 0 0 61 /**</span>
 <span class="s0">* Returns the direction in which the lens is facing.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1376 0 0 4 1671 3346 0 0 49 /**</span>
 <span class="s0">* Resets the lens transform to identity.</span>
 <span class="s0">*/ 1 4 this 3 3614  </span>
<span class="s0">1377 0 0 4 1676 3346 0 0 617 /**</span>
 <span class="s0">* Indicates the ratio of keystone correction to perform on the lens, in each</span>
 <span class="s0">* of three axes.  This will build a special non-affine scale factor into the</span>
 <span class="s0">* projection matrix that will compensate for keystoning of a projected image;</span>
 <span class="s0">* this can be used to compensate for a projector that for physical reasons</span>
 <span class="s0">* cannot be aimed directly at its screen.</span>
 <span class="s0">*</span>
 <span class="s0">* The default value is taken from the default-keystone Config variable.  0, 0</span>
 <span class="s0">* indicates no keystone correction; specify a small value (usually in the</span>
 <span class="s0">* range -1 .. 1) in either the x or y position to generate a keystone</span>
 <span class="s0">* correction in that axis.</span>
 <span class="s0">*/ 2 4 this 3 3614  8 keystone 1 3534  </span>
<span class="s0">1378 0 0 6 1677 3534 0 0 66 /**</span>
 <span class="s0">* Returns the keystone correction specified for the lens.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1379 0 0 4 1678 3346 0 0 49 /**</span>
 <span class="s0">* Disables the lens keystone correction.</span>
 <span class="s0">*/ 1 4 this 3 3614  </span>
<span class="s0">1380 0 0 4 1680 3346 0 0 425 /**</span>
 <span class="s0">* Specifies a custom matrix to transform the points on the film after they</span>
 <span class="s0">* have been converted into nominal film space (-1 .. 1 in U and V).  This can</span>
 <span class="s0">* be used to introduce arbitrary scales, rotations, or other linear</span>
 <span class="s0">* transforms to the media plane.  This is normally a 2-d matrix, but a full</span>
 <span class="s0">* 4x4 matrix may be specified.  This is applied on top of any film size, lens</span>
 <span class="s0">* shift, and/or keystone correction.</span>
 <span class="s0">*/ 2 4 this 3 3614  15 custom_film_mat 1 3418  </span>
<span class="s0">1381 0 0 6 1681 3418 0 0 62 /**</span>
 <span class="s0">* Returns the custom_film_mat specified for the lens.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1382 0 0 4 1682 3346 0 0 56 /**</span>
 <span class="s0">* Disables the lens custom_film_mat correction.</span>
 <span class="s0">*/ 1 4 this 3 3614  </span>
<span class="s0">1383 0 0 4 1684 3346 0 0 2188 /**</span>
 <span class="s0">* Sets up the lens to use the frustum defined by the four indicated points.</span>
 <span class="s0">* This is most useful for a PerspectiveLens, but it may be called for other</span>
 <span class="s0">* kinds of lenses as well.</span>
 <span class="s0">*</span>
 <span class="s0">* The frustum will be rooted at the origin (or by whatever translation might</span>
 <span class="s0">* have been specified in a previous call to set_view_mat).</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal for the four points not to be arranged in a rectangle; if this</span>
 <span class="s0">* is the case, the frustum will be fitted as tightly as possible to cover all</span>
 <span class="s0">* four points.</span>
 <span class="s0">*</span>
 <span class="s0">* The flags parameter contains the union of one or more of the following bits</span>
 <span class="s0">* to control the behavior of this function:</span>
 <span class="s0">*</span>
 <span class="s0">* FC_roll - If this is included, the camera may be rotated so that its up</span>
 <span class="s0">* vector is perpendicular to the top line.  Otherwise, the standard up vector</span>
 <span class="s0">* is used.</span>
 <span class="s0">*</span>
 <span class="s0">* FC_camera_plane - This allows the camera plane to be adjusted to be as</span>
 <span class="s0">* nearly perpendicular to the center of the frustum as possible.  Without</span>
 <span class="s0">* this bit, the orientation camera plane is defined by position of the four</span>
 <span class="s0">* points (which should all be coplanar).  With this bit, the camera plane is</span>
 <span class="s0">* arbitrary, and may be chosen so that the four points do not themselves lie</span>
 <span class="s0">* in the camera plane (but the points will still be within the frustum).</span>
 <span class="s0">*</span>
 <span class="s0">* FC_off_axis - This allows the resulting frustum to be off-axis to get the</span>
 <span class="s0">* tightest possible fit.  Without this bit, the viewing axis will be centered</span>
 <span class="s0">* within the frustum, but there may be more wasted space along the edges.</span>
 <span class="s0">*</span>
 <span class="s0">* FC_aspect_ratio - This allows the frustum to be scaled non-proportionately</span>
 <span class="s0">* in the vertical and horizontal dimensions, if necessary, to get a tighter</span>
 <span class="s0">* fit.  Without this bit, the current aspect ratio will be preserved.</span>
 <span class="s0">*</span>
 <span class="s0">* FC_shear - This allows the frustum to be sheared, if necessary, to get the</span>
 <span class="s0">* tightest possible fit.  This may result in a parallelogram-based frustum,</span>
 <span class="s0">* which will give a slanted appearance to the rendered image.  Without this</span>
 <span class="s0">* bit, the frustum will be rectangle-based.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, if 0 is passed in as the value for flags, the generated frustum</span>
 <span class="s0">* will be a loose fit but sane; if -1 is passed in, it will be a tighter fit</span>
 <span class="s0">* and possibly screwy.</span>
 <span class="s0">*/ 6 4 this 3 3614  2 ul 1 3535  2 ur 1 3535  2 ll 1 3535  2 lr 1 3535  5 flags 1 3177  </span>
<span class="s0">1384 0 0 4 1685 3346 0 0 169 /**</span>
 <span class="s0">* Forces all internal parameters of the Lens to be recomputed.  Normally,</span>
 <span class="s0">* this should never need to be called; it is provided only to assist in</span>
 <span class="s0">* debugging.</span>
 <span class="s0">*/ 1 4 this 3 3614  </span>
<span class="s0">1385 0 0 6 1686 3178 0 0 206 /**</span>
 <span class="s0">* Returns true if the lens represents a linear projection (e.g.</span>
 <span class="s0">* PerspectiveLens, OrthographicLens), and therefore there is a valid matrix</span>
 <span class="s0">* returned by get_projection_mat(), or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1386 0 0 6 1687 3178 0 0 124 /**</span>
 <span class="s0">* Returns true if the lens represents a perspective projection (i.e.  it is a</span>
 <span class="s0">* PerspectiveLens), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1387 0 0 6 1688 3178 0 0 126 /**</span>
 <span class="s0">* Returns true if the lens represents a orthographic projection (i.e.  it is</span>
 <span class="s0">* a OrthographicLens), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1388 0 0 7 1689 3257 2260 0 236 /**</span>
 <span class="s0">* Allocates and returns a new Geom that can be rendered to show a visible</span>
 <span class="s0">* representation of the frustum used for this kind of lens, if it makes sense</span>
 <span class="s0">* to do so.  If a visible representation cannot be created, returns NULL.</span>
 <span class="s0">*/ 1 4 this 3 3614  </span>
<span class="s0">1389 0 0 7 1690 3628 0 0 190 /**</span>
 <span class="s0">* Allocates and returns a new BoundingVolume that encloses the frustum used</span>
 <span class="s0">* for this kind of lens, if possible.  If a suitable bounding volume cannot</span>
 <span class="s0">* be created, returns NULL.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1390 0 0 6 1691 3418 0 0 183 /**</span>
 <span class="s0">* Returns the complete transformation matrix from a 3-d point in space to a</span>
 <span class="s0">* point on the film, if such a matrix exists, or the identity matrix if the</span>
 <span class="s0">* lens is nonlinear.</span>
 <span class="s0">*/ 2 4 this 3 3612  7 channel 5 3302  </span>
<span class="s0">1391 0 0 6 1692 3418 0 0 128 /**</span>
 <span class="s0">* Returns the matrix that transforms from a 2-d point on the film to a 3-d</span>
 <span class="s0">* vector in space, if such a matrix exists.</span>
 <span class="s0">*/ 2 4 this 3 3612  7 channel 5 3302  </span>
<span class="s0">1392 0 0 6 1693 3418 0 0 101 /**</span>
 <span class="s0">* Returns the matrix that transforms from a point behind the lens to a point</span>
 <span class="s0">* on the film.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1393 0 0 6 1694 3418 0 0 101 /**</span>
 <span class="s0">* Returns the matrix that transforms from a point on the film to a point</span>
 <span class="s0">* behind the lens.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1394 0 0 6 1695 3418 0 0 103 /**</span>
 <span class="s0">* Returns the matrix that transforms from a point in front of the lens to a</span>
 <span class="s0">* point in space.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1395 0 0 6 1696 3418 0 0 103 /**</span>
 <span class="s0">* Returns the matrix that transforms from a point in space to a point in</span>
 <span class="s0">* front of the lens.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1396 0 0 4 1697 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3612  3 out 1 3347  </span>
<span class="s0">1397 0 0 4 1698 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3612  3 out 1 3347  12 indent_level 5 3177  </span>
<span class="s0">1398 0 0 7 1699 3398 0 0 192 /**</span>
 <span class="s0">* Returns the UpdateSeq that is incremented whenever the lens properties are</span>
 <span class="s0">* changed.  As long as this number remains the same, you may assume the lens</span>
 <span class="s0">* properties are unchanged.</span>
 <span class="s0">*/ 1 4 this 3 3612  </span>
<span class="s0">1399 0 0 7 1700 3362 0 0 0 0 </span>
<span class="s0">1400 0 0 15 1707 3631 2955 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3629  </span>
<span class="s0">1401 0 0 7 1707 3631 2955 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 5 3342  </span>
<span class="s0">1402 0 0 7 1708 3631 2955 0 0 2 4 this 3 3631  4 copy 1 3629  </span>
<span class="s0">1403 0 0 7 1710 3631 2955 0 40 /**</span>
 <span class="s0">* Returns the default material.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1404 0 0 6 1711 3178 0 0 104 /**</span>
 <span class="s0">* Returns true if the base color has been explicitly set for this material,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1405 0 0 6 1712 3445 0 0 162 /**</span>
 <span class="s0">* Returns the base_color color setting, if it has been set.  If neither the</span>
 <span class="s0">* base color nor the metallic have been set, this returns the diffuse color.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1406 0 0 4 1713 3346 0 0 444 /**</span>
 <span class="s0">* Specifies the base color of the material.  In conjunction with</span>
 <span class="s0">* set_metallic, this is an alternate way to specify the color of a material.</span>
 <span class="s0">* For dielectrics, this will determine the value of the diffuse color, and</span>
 <span class="s0">* for metals, this will determine the value of the specular color.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this will clear an explicit specular, diffuse or ambient color</span>
 <span class="s0">* assignment.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the object color will be used.</span>
 <span class="s0">*/ 2 4 this 3 3631  5 color 1 3445  </span>
<span class="s0">1407 0 0 4 1714 3346 0 0 67 /**</span>
 <span class="s0">* Removes the explicit base_color color from the material.</span>
 <span class="s0">*/ 1 4 this 3 3631  </span>
<span class="s0">1408 0 0 6 1715 3178 0 0 107 /**</span>
 <span class="s0">* Returns true if the ambient color has been explicitly set for this</span>
 <span class="s0">* material, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1409 0 0 6 1716 3445 0 0 126 /**</span>
 <span class="s0">* Returns the ambient color setting, if it has been set.  Returns (0,0,0,0)</span>
 <span class="s0">* if the ambient color has not been set.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1410 0 0 4 1717 3346 0 0 313 /**</span>
 <span class="s0">* Specifies the ambient color setting of the material.  This will be the</span>
 <span class="s0">* multiplied by any ambient lights in effect on the material to set its base</span>
 <span class="s0">* color.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the color of the object as it appears in the absence of direct</span>
 <span class="s0">* light.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the object color will be used.</span>
 <span class="s0">*/ 2 4 this 3 3631  5 color 1 3445  </span>
<span class="s0">1411 0 0 4 1718 3346 0 0 64 /**</span>
 <span class="s0">* Removes the explicit ambient color from the material.</span>
 <span class="s0">*/ 1 4 this 3 3631  </span>
<span class="s0">1412 0 0 6 1719 3178 0 0 107 /**</span>
 <span class="s0">* Returns true if the diffuse color has been explicitly set for this</span>
 <span class="s0">* material, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1413 0 0 6 1720 3445 0 0 126 /**</span>
 <span class="s0">* Returns the diffuse color setting, if it has been set.  Returns (1,1,1,1)</span>
 <span class="s0">* if the diffuse color has not been set.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1414 0 0 4 1721 3346 0 0 396 /**</span>
 <span class="s0">* Specifies the diffuse color setting of the material.  This will be</span>
 <span class="s0">* multiplied by any lights in effect on the material to get the color in the</span>
 <span class="s0">* parts of the object illuminated by the lights.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the primary color of an object; the color of the object as it</span>
 <span class="s0">* appears in direct light, in the absence of highlights.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the object color will be used.</span>
 <span class="s0">*/ 2 4 this 3 3631  5 color 1 3445  </span>
<span class="s0">1415 0 0 4 1722 3346 0 0 64 /**</span>
 <span class="s0">* Removes the explicit diffuse color from the material.</span>
 <span class="s0">*/ 1 4 this 3 3631  </span>
<span class="s0">1416 0 0 6 1723 3178 0 0 108 /**</span>
 <span class="s0">* Returns true if the specular color has been explicitly set for this</span>
 <span class="s0">* material, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1417 0 0 6 1724 3445 0 0 128 /**</span>
 <span class="s0">* Returns the specular color setting, if it has been set.  Returns (0,0,0,0)</span>
 <span class="s0">* if the specular color has not been set.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1418 0 0 4 1725 3346 0 0 448 /**</span>
 <span class="s0">* Specifies the specular color setting of the material.  This will be</span>
 <span class="s0">* multiplied by any lights in effect on the material to compute the color of</span>
 <span class="s0">* specular highlights on the object.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the highlight color of an object: the color of small highlight</span>
 <span class="s0">* reflections.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the specular color is taken from the index of</span>
 <span class="s0">* refraction, which is 1 by default (meaning no specular reflections are</span>
 <span class="s0">* generated).</span>
 <span class="s0">*/ 2 4 this 3 3631  5 color 1 3445  </span>
<span class="s0">1419 0 0 4 1726 3346 0 0 65 /**</span>
 <span class="s0">* Removes the explicit specular color from the material.</span>
 <span class="s0">*/ 1 4 this 3 3631  </span>
<span class="s0">1420 0 0 6 1727 3178 0 0 108 /**</span>
 <span class="s0">* Returns true if the emission color has been explicitly set for this</span>
 <span class="s0">* material, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1421 0 0 6 1728 3445 0 0 128 /**</span>
 <span class="s0">* Returns the emission color setting, if it has been set.  Returns (0,0,0,0)</span>
 <span class="s0">* if the emission color has not been set.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1422 0 0 4 1729 3346 0 0 437 /**</span>
 <span class="s0">* Specifies the emission color setting of the material.  This is the color of</span>
 <span class="s0">* the object as it appears in the absence of any light whatsover, including</span>
 <span class="s0">* ambient light.  It is as if the object is glowing by this color (although</span>
 <span class="s0">* of course it will not illuminate neighboring objects).</span>
 <span class="s0">*</span>
 <span class="s0">* If this is not set, the object will not glow by its own light and will only</span>
 <span class="s0">* appear visible in the presence of one or more lights.</span>
 <span class="s0">*/ 2 4 this 3 3631  5 color 1 3445  </span>
<span class="s0">1423 0 0 4 1730 3346 0 0 65 /**</span>
 <span class="s0">* Removes the explicit emission color from the material.</span>
 <span class="s0">*/ 1 4 this 3 3631  </span>
<span class="s0">1424 0 0 6 1731 3220 0 0 58 /**</span>
 <span class="s0">* Returns the shininess exponent of the material.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1425 0 0 4 1732 3346 0 0 429 /**</span>
 <span class="s0">* Sets the shininess exponent of the material.  This controls the size of the</span>
 <span class="s0">* specular highlight spot.  In general, larger number produce a smaller</span>
 <span class="s0">* specular highlight, which makes the object appear shinier.  Smaller numbers</span>
 <span class="s0">* produce a larger highlight, which makes the object appear less shiny.</span>
 <span class="s0">*</span>
 <span class="s0">* This is usually in the range 0..128.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting a shininess value removes any previous roughness assignment.</span>
 <span class="s0">*/ 2 4 this 3 3631  9 shininess 1 3220  </span>
<span class="s0">1426 0 0 6 1733 3178 0 0 103 /**</span>
 <span class="s0">* Returns true if the roughness has been explicitly set for this material,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1427 0 0 6 1734 3220 0 0 152 /**</span>
 <span class="s0">* Returns the roughness previously specified by set_roughness.  If none was</span>
 <span class="s0">* previously set, this value is computed from the shininess value.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1428 0 0 4 1735 3346 0 0 379 /**</span>
 <span class="s0">* Sets the roughness exponent of the material, where 0 is completely shiny</span>
 <span class="s0">* (infinite shininess), and 1 is a completely dull object (0 shininess).</span>
 <span class="s0">* This is a different, more perceptually intuitive way of controlling the</span>
 <span class="s0">* size of the specular spot, and more commonly used in physically-based</span>
 <span class="s0">* rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting a roughness recalculates the shininess value.</span>
 <span class="s0">*/ 2 4 this 3 3631  9 roughness 1 3220  </span>
<span class="s0">1429 0 0 6 1736 3178 0 0 102 /**</span>
 <span class="s0">* Returns true if the metallic has been explicitly set for this material,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1430 0 0 6 1737 3220 0 0 98 /**</span>
 <span class="s0">* Returns the metallic setting, if it has been set.  Returns 0 if it has not</span>
 <span class="s0">* been set.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1431 0 0 4 1738 3346 0 0 369 /**</span>
 <span class="s0">* Sets the metallic setting of the material, which is is used for physically-</span>
 <span class="s0">* based rendering models.  This is usually 0 for dielectric materials and 1</span>
 <span class="s0">* for metals.  It really does not make sense to set this to a value other</span>
 <span class="s0">* than 0 or 1, but it is nonetheless a float for compatibility with tools</span>
 <span class="s0">* that allow setting this to values other than 0 or 1.</span>
 <span class="s0">*/ 2 4 this 3 3631  8 metallic 1 3220  </span>
<span class="s0">1432 0 0 4 1739 3346 0 0 67 /**</span>
 <span class="s0">* Removes the explicit metallic setting from the material.</span>
 <span class="s0">*/ 1 4 this 3 3631  </span>
<span class="s0">1433 0 0 6 1740 3178 0 0 97 /**</span>
 <span class="s0">* Returns true if a refractive index has explicitly been specified for this</span>
 <span class="s0">* material.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1434 0 0 6 1741 3220 0 0 91 /**</span>
 <span class="s0">* Returns the index of refraction, or 1 if none has been set for this</span>
 <span class="s0">* material.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1435 0 0 4 1742 3346 0 0 356 /**</span>
 <span class="s0">* Sets the index of refraction of the material, which is used to determine</span>
 <span class="s0">* the specular color in absence of an explicit specular color assignment.</span>
 <span class="s0">* This is usually 1.5 for dielectric materials.  It is not very useful for</span>
 <span class="s0">* metals, since they cannot be described as easily with a single number.</span>
 <span class="s0">*</span>
 <span class="s0">* Should be 1 or higher.  The default is 1.</span>
 <span class="s0">*/ 2 4 this 3 3631  16 refractive_index 1 3220  </span>
<span class="s0">1436 0 0 6 1743 3178 0 0 59 /**</span>
 <span class="s0">* Returns the local viewer flag.  Set set_local().</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1437 0 0 4 1744 3346 0 0 252 /**</span>
 <span class="s0">* Sets the local viewer flag.  Set this true to enable camera-relative</span>
 <span class="s0">* specular highlights, or false to use orthogonal specular highlights.  The</span>
 <span class="s0">* default value is true.  Applications that use orthogonal projection should</span>
 <span class="s0">* specify false.</span>
 <span class="s0">*/ 2 4 this 3 3631  5 local 1 3178  </span>
<span class="s0">1438 0 0 6 1745 3178 0 0 80 /**</span>
 <span class="s0">* Returns the state of the two-sided lighting flag.  See set_twoside().</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1439 0 0 4 1746 3346 0 0 241 /**</span>
 <span class="s0">* Set this true to enable two-sided lighting.  When two-sided lighting is on,</span>
 <span class="s0">* both sides of a polygon will be lit by this material.  The default is for</span>
 <span class="s0">* two-sided lighting to be off, in which case only the front surface is lit.</span>
 <span class="s0">*/ 2 4 this 3 3631  7 twoside 1 3178  </span>
<span class="s0">1440 0 0 6 1747 3178 0 0 0 2 4 this 3 3629  5 other 1 3629  </span>
<span class="s0">1441 0 0 6 1748 3178 0 0 0 2 4 this 3 3629  5 other 1 3629  </span>
<span class="s0">1442 0 0 6 1749 3178 0 0 0 2 4 this 3 3629  5 other 1 3629  </span>
<span class="s0">1443 0 0 6 1750 3177 0 0 266 /**</span>
 <span class="s0">* Returns a number less than zero if this material sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">* The sorting order is arbitrary and largely meaningless, except to</span>
 <span class="s0">* differentiate different materials.</span>
 <span class="s0">*/ 2 4 this 3 3629  5 other 1 3629  </span>
<span class="s0">1444 0 0 4 1751 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3629  3 out 1 3347  </span>
<span class="s0">1445 0 0 4 1752 3346 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3629  3 out 1 3347  6 indent 1 3177  </span>
<span class="s0">1446 0 0 6 1753 3178 0 0 62 /**</span>
 <span class="s0">* @deprecated This no longer has any meaning in 1.10.</span>
 <span class="s0">*/ 1 4 this 3 3629  </span>
<span class="s0">1447 0 0 4 1754 3346 0 0 62 /**</span>
 <span class="s0">* @deprecated This no longer has any meaning in 1.10.</span>
 <span class="s0">*/ 1 4 this 3 3631  </span>
<span class="s0">1448 0 0 7 1766 3362 0 0 0 0 </span>
<span class="s0">1449 0 0 7 1703 3241 0 0 0 1 4 this 3 3631  </span>
<span class="s0">1450 0 0 6 1705 3374 0 0 0 1 4 this 3 3631  </span>
<span class="s0">1451 0 0 7 1768 3631 2955 0 657 /**</span>
 <span class="s0">* Returns a Material pointer that represents the same material described by</span>
 <span class="s0">* temp, except that it is a shared pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* Each call to get_material() passing an equivalent Material pointer will</span>
 <span class="s0">* return the same shared pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* If you modify the shared pointer, it will automatically disassociate it</span>
 <span class="s0">* from the pool.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, the return value may be a different pointer than that passed in, or</span>
 <span class="s0">* it may be the same pointer.  In either case, the passed in pointer has now</span>
 <span class="s0">* been sacrificed to the greater good and should not be used again (like any</span>
 <span class="s0">* other PointerTo, it will be freed when the last reference count is</span>
 <span class="s0">* removed).</span>
 <span class="s0">*/ 1 4 temp 1 3631  </span>
<span class="s0">1452 0 0 4 1769 3346 0 0 56 /**</span>
 <span class="s0">* Removes the indicated material from the pool.</span>
 <span class="s0">*/ 1 4 temp 1 3631  </span>
<span class="s0">1453 0 0 4 1770 3346 0 0 90 /**</span>
 <span class="s0">* Releases all materials in the pool and restores the pool to the empty</span>
 <span class="s0">* state.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1454 0 0 6 1771 3177 0 0 215 /**</span>
 <span class="s0">* Releases only those materials in the pool that have a reference count of</span>
 <span class="s0">* exactly 1; i.e.  only those materials that are not being used outside of</span>
 <span class="s0">* the pool.  Returns the number of materials released.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1455 0 0 4 1772 3346 0 0 82 /**</span>
 <span class="s0">* Lists the contents of the material pool to the indicated output stream.</span>
 <span class="s0">*/ 1 3 out 1 3347  </span>
<span class="s0">1456 0 0 4 1773 3346 0 0 82 /**</span>
 <span class="s0">* Lists the contents of the material pool to the indicated output stream.</span>
 <span class="s0">*/ 1 3 out 1 3347  </span>
<span class="s0">1457 0 0 7 1776 3632 3021 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1458 0 0 4 1777 3346 0 0 559 /**</span>
 <span class="s0">* Explicitly specifies the projection matrix.  This matrix should convert X</span>
 <span class="s0">* and Y to the range [-film_size/2, film_size/2], where (-fs/2,-fs/2) is the</span>
 <span class="s0">* lower left corner of the screen and (fs/2, fs/2) is the upper right.  Z</span>
 <span class="s0">* should go to the range [-1, 1], where -1 is the near plane and 1 is the far</span>
 <span class="s0">* plane.  Note that this is a left-handed Y-up coordinate system.</span>
 <span class="s0">*</span>
 <span class="s0">* The default film_size for a MatrixLens is 2, so the default range is [-1,</span>
 <span class="s0">* 1] for both X and Y.  This is consistent with the GL conventions for</span>
 <span class="s0">* projection matrices.</span>
 <span class="s0">*/ 2 4 this 3 3632  8 user_mat 1 3418  </span>
<span class="s0">1459 0 0 6 1778 3418 0 0 161 /**</span>
 <span class="s0">* Returns the explicit projection matrix as set by the user.  This does not</span>
 <span class="s0">* include transforms on the lens or film (e.g.  a film offset or view hpr).</span>
 <span class="s0">*/ 1 4 this 3 3633  </span>
<span class="s0">1460 0 0 4 1780 3346 0 0 424 /**</span>
 <span class="s0">* Sets a custom projection matrix for the left eye.  This is only used if the</span>
 <span class="s0">* lens is attached to a stereo camera, in which case the left eye matrix will</span>
 <span class="s0">* be used to draw the scene in the left eye (but the center matrix--the</span>
 <span class="s0">* user_mat--will still be used to cull the scene).</span>
 <span class="s0">*</span>
 <span class="s0">* This matrix should not be too different from the center matrix (set by</span>
 <span class="s0">* set_user_mat()) or culling errors may become obvious.</span>
 <span class="s0">*/ 2 4 this 3 3632  8 user_mat 1 3418  </span>
<span class="s0">1461 0 0 4 1781 3346 0 0 130 /**</span>
 <span class="s0">* Removes the custom projection matrix set for the left eye, and uses the</span>
 <span class="s0">* center matrix (set by set_user_mat) instead.</span>
 <span class="s0">*/ 1 4 this 3 3632  </span>
<span class="s0">1462 0 0 6 1782 3178 0 0 179 /**</span>
 <span class="s0">* Returns true if the camera has a custom projection matrix set for the left</span>
 <span class="s0">* eye, or false if the center matrix (set by set_user_mat) will be used for</span>
 <span class="s0">* the left eye.</span>
 <span class="s0">*/ 1 4 this 3 3633  </span>
<span class="s0">1463 0 0 6 1783 3418 0 0 148 /**</span>
 <span class="s0">* Returns the custom projection matrix for the left eye, if any, or the</span>
 <span class="s0">* center matrix if there is no custom matrix set for the left eye.</span>
 <span class="s0">*/ 1 4 this 3 3633  </span>
<span class="s0">1464 0 0 4 1784 3346 0 0 427 /**</span>
 <span class="s0">* Sets a custom projection matrix for the right eye.  This is only used if</span>
 <span class="s0">* the lens is attached to a stereo camera, in which case the right eye matrix</span>
 <span class="s0">* will be used to draw the scene in the right eye (but the center matrix--the</span>
 <span class="s0">* user_mat--will still be used to cull the scene).</span>
 <span class="s0">*</span>
 <span class="s0">* This matrix should not be too different from the center matrix (set by</span>
 <span class="s0">* set_user_mat()) or culling errors may become obvious.</span>
 <span class="s0">*/ 2 4 this 3 3632  8 user_mat 1 3418  </span>
<span class="s0">1465 0 0 4 1785 3346 0 0 131 /**</span>
 <span class="s0">* Removes the custom projection matrix set for the right eye, and uses the</span>
 <span class="s0">* center matrix (set by set_user_mat) instead.</span>
 <span class="s0">*/ 1 4 this 3 3632  </span>
<span class="s0">1466 0 0 6 1786 3178 0 0 181 /**</span>
 <span class="s0">* Returns true if the camera has a custom projection matrix set for the right</span>
 <span class="s0">* eye, or false if the center matrix (set by set_user_mat) will be used for</span>
 <span class="s0">* the right eye.</span>
 <span class="s0">*/ 1 4 this 3 3633  </span>
<span class="s0">1467 0 0 6 1787 3418 0 0 150 /**</span>
 <span class="s0">* Returns the custom projection matrix for the right eye, if any, or the</span>
 <span class="s0">* center matrix if there is no custom matrix set for the right eye.</span>
 <span class="s0">*/ 1 4 this 3 3633  </span>
<span class="s0">1468 0 0 7 1788 3362 0 0 0 0 </span>
<span class="s0">1469 0 0 7 1791 3635 3024 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1470 0 0 7 1792 3362 0 0 0 0 </span>
<span class="s0">1471 0 0 23 1796 3636 3029 0 94 /**</span>
 <span class="s0">* Creates a new ParamTextureSampler storing the given texture and sampler</span>
 <span class="s0">* objects.</span>
 <span class="s0">*/ 2 3 tex 1 3325  7 sampler 1 3564  </span>
<span class="s0">1472 0 0 7 1797 3325 2558 0 57 /**</span>
 <span class="s0">* Retrieves the texture stored in the parameter.</span>
 <span class="s0">*/ 1 4 this 3 3637  </span>
<span class="s0">1473 0 0 6 1798 3564 0 0 63 /**</span>
 <span class="s0">* Retrieves the sampler state stored in the parameter.</span>
 <span class="s0">*/ 1 4 this 3 3637  </span>
<span class="s0">1474 0 0 7 1802 3362 0 0 0 0 </span>
<span class="s0">1475 0 0 23 1805 3639 3038 0 101 /**</span>
 <span class="s0">* Creates a new ParamTextureImage storing the given texture and image binding</span>
 <span class="s0">* parameters.</span>
 <span class="s0">*/ 5 3 tex 1 3325  4 read 1 3178  5 write 1 3178  1 z 5 3177  1 n 5 3177  </span>
<span class="s0">1476 0 0 7 1806 3325 2558 0 57 /**</span>
 <span class="s0">* Retrieves the texture stored in the parameter.</span>
 <span class="s0">*/ 1 4 this 3 3640  </span>
<span class="s0">1477 0 0 6 1807 3178 0 0 79 /**</span>
 <span class="s0">* Returns true if this image should be bound with read access enabled.</span>
 <span class="s0">*/ 1 4 this 3 3640  </span>
<span class="s0">1478 0 0 6 1808 3178 0 0 80 /**</span>
 <span class="s0">* Returns true if this image should be bound with write access enabled.</span>
 <span class="s0">*/ 1 4 this 3 3640  </span>
<span class="s0">1479 0 0 6 1809 3178 0 0 83 /**</span>
 <span class="s0">* Returns true if all layers of this image should be bound simultaneously.</span>
 <span class="s0">*/ 1 4 this 3 3640  </span>
<span class="s0">1480 0 0 6 1810 3177 0 0 56 /**</span>
 <span class="s0">* Returns the image level that should be bound.</span>
 <span class="s0">*/ 1 4 this 3 3640  </span>
<span class="s0">1481 0 0 6 1811 3177 0 0 115 /**</span>
 <span class="s0">* Returns the image layer that should be bound.  This is undefined if</span>
 <span class="s0">* get_bind_layered() returns false.</span>
 <span class="s0">*/ 1 4 this 3 3640  </span>
<span class="s0">1482 0 0 7 1817 3362 0 0 0 0 </span>
<span class="s0">1483 0 0 7 1820 3642 3041 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1484 0 0 7 1820 3642 3041 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 hfov 1 3220  4 vfov 1 3220  </span>
<span class="s0">1485 0 0 7 1821 3362 0 0 0 0 </span>
<span class="s0">1486 0 0 15 1824 3645 3048 0 0 1 6 param0 0 3643  </span>
<span class="s0">1487 0 0 7 1824 3645 3048 0 122 /**</span>
 <span class="s0">* Create a new TextureReloadRequest, and add it to the loader via</span>
 <span class="s0">* load_async(), to begin an asynchronous load.</span>
 <span class="s0">*/ 4 4 name 1 3342  3 pgo 1 3404  7 texture 1 3325  16 allow_compressed 1 3178  </span>
<span class="s0">1488 0 0 7 1825 3404 0 0 112 /**</span>
 <span class="s0">* Returns the PreparedGraphicsObjects object associated with this</span>
 <span class="s0">* asynchronous TextureReloadRequest.</span>
 <span class="s0">*/ 1 4 this 3 3643  </span>
<span class="s0">1489 0 0 7 1826 3325 2558 0 96 /**</span>
 <span class="s0">* Returns the Texture object associated with this asynchronous</span>
 <span class="s0">* TextureReloadRequest.</span>
 <span class="s0">*/ 1 4 this 3 3643  </span>
<span class="s0">1490 0 0 6 1827 3178 0 0 105 /**</span>
 <span class="s0">* Returns the &quot;allow compressed&quot; flag associated with this asynchronous</span>
 <span class="s0">* TextureReloadRequest.</span>
 <span class="s0">*/ 1 4 this 3 3643  </span>
<span class="s0">1491 0 0 6 1828 3178 0 0 154 /**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending.</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/ 1 4 this 3 3643  </span>
<span class="s0">1492 0 0 7 1830 3362 0 0 0 0 </span>
<span class="s0">1493 0 0 7 1837 3325 2558 0 64 /**</span>
 <span class="s0">* Returns the pointer to the associated Texture object.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1494 0 0 6 1838 3177 0 0 152 /**</span>
 <span class="s0">* Returns the specific view of a multiview texture this context represents.</span>
 <span class="s0">* In the usual case, with a non-multiview texture, this will be 0.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1495 0 0 6 1839 3298 0 0 198 /**</span>
 <span class="s0">* Returns an implementation-defined handle or pointer that can be used</span>
 <span class="s0">* to interface directly with the underlying API.</span>
 <span class="s0">* Returns 0 if the underlying implementation does not support this.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1496 0 0 6 1840 3298 0 0 253 /**</span>
 <span class="s0">* Similar to get_native_id, but some implementations use a separate</span>
 <span class="s0">* identifier for the buffer object associated with buffer textures.</span>
 <span class="s0">* Returns 0 if the underlying implementation does not support this, or</span>
 <span class="s0">* if this is not a buffer texture.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1497 0 0 6 1841 3178 0 0 126 /**</span>
 <span class="s0">* Returns true if the texture properties or image have been modified since</span>
 <span class="s0">* the last time mark_loaded() was called.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1498 0 0 6 1842 3178 0 0 142 /**</span>
 <span class="s0">* Returns true if the texture properties (unrelated to the image) have been</span>
 <span class="s0">* modified since the last time mark_loaded() was called.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1499 0 0 6 1843 3178 0 0 111 /**</span>
 <span class="s0">* Returns true if the texture image has been modified since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1500 0 0 6 1844 3178 0 0 129 /**</span>
 <span class="s0">* Returns true if the texture's &quot;simple&quot; image has been modified since the</span>
 <span class="s0">* last time mark_simple_loaded() was called.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1501 0 0 7 1845 3398 0 0 151 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture properties (unrelated to the image) are modified.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1502 0 0 7 1846 3398 0 0 152 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture image data (including mipmap levels) are modified.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1503 0 0 7 1847 3398 0 0 136 /**</span>
 <span class="s0">* Returns a sequence number which is guaranteed to change at least every time</span>
 <span class="s0">* the texture's &quot;simple&quot; image data is modified.</span>
 <span class="s0">*/ 1 4 this 3 3646  </span>
<span class="s0">1504 0 0 7 1848 3362 0 0 0 0 </span>
<span class="s0">1505 0 0 6 1833 3451 0 0 0 1 4 this 3 3596  </span>
<span class="s0">1506 0 0 6 1835 3351 0 0 0 1 4 this 3 3596  </span>
<span class="s0">1507 0 0 7 1851 3331 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3648  </span>
<span class="s0">1508 0 0 7 1854 3362 0 0 0 0 </span>
<span class="s0">1509 0 0 7 1857 3650 3072 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3193  </span>
<span class="s0">1510 0 0 7 1857 3650 3072 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3342  </span>
<span class="s0">1511 0 0 4 1858 3346 0 0 45 /**</span>
 <span class="s0">* Stores the indicated slider value.</span>
 <span class="s0">*/ 2 4 this 3 3650  6 slider 1 3220  </span>
<span class="s0">1512 0 0 7 1859 3362 0 0 0 0 </span>
<span class="s0">1513 0 0 7 1862 3651 3077 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3342  </span>
<span class="s0">1514 0 0 6 1863 3342 0 0 77 /**</span>
 <span class="s0">* Returns the name passed to the constructor.  Completely arbitrary.</span>
 <span class="s0">*/ 1 4 this 3 3652  </span>
<span class="s0">1515 0 0 4 1864 3346 0 0 39 /**</span>
 <span class="s0">* Stores the indicated matrix.</span>
 <span class="s0">*/ 2 4 this 3 3651  6 matrix 1 3418  </span>
<span class="s0">1516 0 0 7 1865 3362 0 0 0 0 </span>
<span class="s0">1517 0 0 6 1873 3178 0 0 207 /**</span>
 <span class="s0">* Returns the flag that indicates whether this Texture is eligible to have</span>
 <span class="s0">* its main RAM copy of the texture memory dumped when the texture is prepared</span>
 <span class="s0">* for rendering.  See set_keep_ram_image().</span>
 <span class="s0">*/ 1 4 this 3 3654  </span>
<span class="s0">1518 0 0 6 1874 3177 0 0 200 /**</span>
 <span class="s0">* Returns the width in texels of the source video stream.  This is not</span>
 <span class="s0">* necessarily the width of the actual texture, since the texture may have</span>
 <span class="s0">* been expanded to raise it to a power of 2.</span>
 <span class="s0">*/ 1 4 this 3 3654  </span>
<span class="s0">1519 0 0 6 1875 3177 0 0 202 /**</span>
 <span class="s0">* Returns the height in texels of the source video stream.  This is not</span>
 <span class="s0">* necessarily the height of the actual texture, since the texture may have</span>
 <span class="s0">* been expanded to raise it to a power of 2.</span>
 <span class="s0">*/ 1 4 this 3 3654  </span>
<span class="s0">1520 0 0 7 1878 3362 0 0 0 0 </span>
<span class="s0">1521 0 0 7 1868 3325 2558 0 0 1 4 this 3 3656  </span>
<span class="s0">1522 0 0 6 1871 3657 0 0 0 1 4 this 3 3656  </span>
<span class="s0">1523 0 0 7 1885 3213 1897 0 68 /**</span>
 <span class="s0">* Returns the pointer to the client-side array data object.</span>
 <span class="s0">*/ 1 4 this 3 3658  </span>
<span class="s0">1524 0 0 6 1886 3178 0 0 101 /**</span>
 <span class="s0">* Returns true if the data has changed size since the last time mark_loaded()</span>
 <span class="s0">* was called.</span>
 <span class="s0">*/ 2 4 this 3 3658  6 reader 1 3402  </span>
<span class="s0">1525 0 0 6 1887 3178 0 0 111 /**</span>
 <span class="s0">* Returns true if the data has changed its usage hint since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/ 2 4 this 3 3658  6 reader 1 3402  </span>
<span class="s0">1526 0 0 6 1888 3178 0 0 102 /**</span>
 <span class="s0">* Returns true if the data has been modified since the last time</span>
 <span class="s0">* mark_loaded() was called.</span>
 <span class="s0">*/ 2 4 this 3 3658  6 reader 1 3402  </span>
<span class="s0">1527 0 0 7 1889 3362 0 0 0 0 </span>
<span class="s0">1528 0 0 6 1881 3451 0 0 0 1 4 this 3 3407  </span>
<span class="s0">1529 0 0 6 1883 3351 0 0 0 1 4 this 3 3407  </span>
<span class="s0">1530 0 0 7 1892 3660 3099 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1531 0 0 55 1892 3660 3099 0 0 1 8 sequence 1 3358  </span>
<span class="s0">1532 0 0 15 1892 3660 3099 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3661  </span>
<span class="s0">1533 0 0 6 1893 3660 0 0 0 2 4 this 3 3660  4 copy 1 3661  </span>
<span class="s0">1534 0 0 38 1895 3358 0 0 0 1 4 this 3 3661  </span>
<span class="s0">1535 0 0 4 1896 3346 0 0 48 /**</span>
 <span class="s0">* Adds a new Texture to the collection.</span>
 <span class="s0">*/ 2 4 this 3 3660  7 texture 1 3325  </span>
<span class="s0">1536 0 0 6 1897 3178 0 0 154 /**</span>
 <span class="s0">* Removes the indicated Texture from the collection.  Returns true if the</span>
 <span class="s0">* texture was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/ 2 4 this 3 3660  7 texture 1 3325  </span>
<span class="s0">1537 0 0 4 1898 3346 0 0 211 /**</span>
 <span class="s0">* Adds all the Textures indicated in the other collection to this texture.</span>
 <span class="s0">* The other textures are simply appended to the end of the textures in this</span>
 <span class="s0">* list; duplicates are not automatically removed.</span>
 <span class="s0">*/ 2 4 this 3 3660  5 other 1 3661  </span>
<span class="s0">1538 0 0 4 1899 3346 0 0 94 /**</span>
 <span class="s0">* Removes from this collection all of the Textures listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/ 2 4 this 3 3660  5 other 1 3661  </span>
<span class="s0">1539 0 0 4 1900 3346 0 0 195 /**</span>
 <span class="s0">* Removes any duplicate entries of the same Textures on this collection.  If</span>
 <span class="s0">* a Texture appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/ 1 4 this 3 3660  </span>
<span class="s0">1540 0 0 6 1901 3178 0 0 96 /**</span>
 <span class="s0">* Returns true if the indicated Texture appears in this collection, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3661  7 texture 1 3325  </span>
<span class="s0">1541 0 0 4 1902 3346 0 0 52 /**</span>
 <span class="s0">* Removes all Textures from the collection.</span>
 <span class="s0">*/ 1 4 this 3 3660  </span>
<span class="s0">1542 0 0 4 1903 3346 0 0 157 /**</span>
 <span class="s0">* This is a hint to Panda to allocate enough memory to hold the given number</span>
 <span class="s0">* of NodePaths, if you know ahead of time how many you will be adding.</span>
 <span class="s0">*/ 2 4 this 3 3660  3 num 1 3209  </span>
<span class="s0">1543 0 0 7 1904 3325 2558 0 121 /**</span>
 <span class="s0">* Returns the texture in the collection with the indicated name, if any, or</span>
 <span class="s0">* NULL if no texture has that name.</span>
 <span class="s0">*/ 2 4 this 3 3661  4 name 1 3342  </span>
<span class="s0">1544 0 0 6 1905 3177 0 0 60 /**</span>
 <span class="s0">* Returns the number of Textures in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3661  </span>
<span class="s0">1545 0 0 7 1906 3325 2558 0 53 /**</span>
 <span class="s0">* Returns the nth Texture in the collection.</span>
 <span class="s0">*/ 2 4 this 3 3661  5 index 1 3177  </span>
<span class="s0">1546 0 0 7 1908 3325 2558 0 142 /**</span>
 <span class="s0">* Returns the nth Texture in the collection.  This is the same as</span>
 <span class="s0">* get_texture(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/ 2 4 this 3 3661  5 index 1 3177  </span>
<span class="s0">1547 0 0 6 1909 3177 0 0 110 /**</span>
 <span class="s0">* Returns the number of textures in the collection.  This is the same thing</span>
 <span class="s0">* as get_num_textures().</span>
 <span class="s0">*/ 1 4 this 3 3661  </span>
<span class="s0">1548 0 0 6 1910 3660 0 0 0 2 4 this 3 3660  5 other 1 3661  </span>
<span class="s0">1549 0 0 7 1911 3660 3099 0 0 2 4 this 3 3661  5 other 1 3661  </span>
<span class="s0">1550 0 0 4 1912 3346 0 0 155 /**</span>
 <span class="s0">* Adds a new Texture to the collection.  This method duplicates the</span>
 <span class="s0">* add_texture() method; it is provided to satisfy Python's naming convention.</span>
 <span class="s0">*/ 2 4 this 3 3660  7 texture 1 3325  </span>
<span class="s0">1551 0 0 4 1913 3346 0 0 157 /**</span>
 <span class="s0">* Appends the other list onto the end of this one.  This method duplicates</span>
 <span class="s0">* the += operator; it is provided to satisfy Python's naming convention.</span>
 <span class="s0">*/ 2 4 this 3 3660  5 other 1 3661  </span>
<span class="s0">1552 0 0 4 1914 3346 0 0 106 /**</span>
 <span class="s0">* Writes a brief one-line description of the TextureCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 3661  3 out 1 3347  </span>
<span class="s0">1553 0 0 4 1915 3346 0 0 111 /**</span>
 <span class="s0">* Writes a complete multi-line description of the TextureCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 3 4 this 3 3661  3 out 1 3347  12 indent_level 5 3177  </span>
<span class="s0">1554 0 0 6 1917 3178 0 0 77 /**</span>
 <span class="s0">* Returns true if the texture has ever been loaded, false otherwise.</span>
 <span class="s0">*/ 1 8 filename 1 3569  </span>
<span class="s0">1555 0 0 6 1918 3178 0 0 313 /**</span>
 <span class="s0">* Loads the given filename up into a texture, if it has not already been</span>
 <span class="s0">* loaded, and returns true to indicate success, or false to indicate failure.</span>
 <span class="s0">* If this returns true, it is guaranteed that a subsequent call to</span>
 <span class="s0">* load_texture() with the same texture name will return a valid Texture</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/ 1 8 filename 1 3569  </span>
<span class="s0">1556 0 0 7 1919 3325 2558 0 93 /**</span>
 <span class="s0">* Returns the texture that has already been previously loaded, or NULL</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 5 8 filename 1 3569  14 alpha_filename 1 3569  25 primary_file_num_channels 5 3177  18 alpha_file_channel 5 3177  12 read_mipmaps 5 3178  </span>
<span class="s0">1557 0 0 7 1919 3325 2558 0 93 /**</span>
 <span class="s0">* Returns the texture that has already been previously loaded, or NULL</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 3 8 filename 1 3569  25 primary_file_num_channels 5 3177  12 read_mipmaps 5 3178  </span>
<span class="s0">1558 0 0 7 1920 3325 2558 0 489 /**</span>
 <span class="s0">* Loads the given filename up into a texture, if it has not already been</span>
 <span class="s0">* loaded, and returns the new texture.  If a texture with the same filename</span>
 <span class="s0">* was previously loaded, returns that one instead.  If the texture file</span>
 <span class="s0">* cannot be found, returns NULL.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, both filenames should contain a hash mark ('#'),</span>
 <span class="s0">* which will be filled in with the mipmap level number; and the texture will</span>
 <span class="s0">* be defined with a series of images, two for each mipmap level.</span>
 <span class="s0">*/ 6 8 filename 1 3569  14 alpha_filename 1 3569  25 primary_file_num_channels 5 3177  18 alpha_file_channel 5 3177  12 read_mipmaps 5 3178  7 options 5 3570  </span>
<span class="s0">1559 0 0 7 1920 3325 2558 0 487 /**</span>
 <span class="s0">* Loads the given filename up into a texture, if it has not already been</span>
 <span class="s0">* loaded, and returns the new texture.  If a texture with the same filename</span>
 <span class="s0">* was previously loaded, returns that one instead.  If the texture file</span>
 <span class="s0">* cannot be found, returns NULL.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, the filename should contain a hash mark ('#'),</span>
 <span class="s0">* which will be filled in with the mipmap level number; and the texture will</span>
 <span class="s0">* be defined with a series of images, one for each mipmap level.</span>
 <span class="s0">*/ 4 8 filename 1 3569  25 primary_file_num_channels 5 3177  12 read_mipmaps 5 3178  7 options 5 3570  </span>
<span class="s0">1560 0 0 7 1921 3325 2558 0 490 /**</span>
 <span class="s0">* Loads a 3-D texture that is specified with a series of n pages, all</span>
 <span class="s0">* numbered in sequence, and beginning with index 0.  The filename should</span>
 <span class="s0">* include a sequence of one or more hash characters (&quot;#&quot;) which will be</span>
 <span class="s0">* filled in with the index number of each level.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, the filename should contain an additional hash</span>
 <span class="s0">* mark.  The first hash mark will be filled in with the mipmap level number,</span>
 <span class="s0">* and the second with the index number of each 3-d level.</span>
 <span class="s0">*/ 3 16 filename_pattern 1 3569  12 read_mipmaps 5 3178  7 options 5 3570  </span>
<span class="s0">1561 0 0 7 1922 3325 2558 0 496 /**</span>
 <span class="s0">* Loads a 2-D texture array that is specified with a series of n pages, all</span>
 <span class="s0">* numbered in sequence, and beginning with index 0.  The filename should</span>
 <span class="s0">* include a sequence of one or more hash characters (&quot;#&quot;) which will be</span>
 <span class="s0">* filled in with the index number of each level.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, the filename should contain an additional hash</span>
 <span class="s0">* mark.  The first hash mark will be filled in with the mipmap level number,</span>
 <span class="s0">* and the second with the index number of each 2-d level.</span>
 <span class="s0">*/ 3 16 filename_pattern 1 3569  12 read_mipmaps 5 3178  7 options 5 3570  </span>
<span class="s0">1562 0 0 7 1923 3325 2558 0 457 /**</span>
 <span class="s0">* Loads a cube map texture that is specified with a series of 6 pages,</span>
 <span class="s0">* numbered 0 through 5.  The filename should include a sequence of one or</span>
 <span class="s0">* more hash characters (&quot;#&quot;) which will be filled in with the index number of</span>
 <span class="s0">* each pagee.</span>
 <span class="s0">*</span>
 <span class="s0">* If read_mipmaps is true, the filename should contain an additional hash</span>
 <span class="s0">* mark.  The first hash mark will be filled in with the mipmap level number,</span>
 <span class="s0">* and the second with the face number, 0 through 5.</span>
 <span class="s0">*/ 3 16 filename_pattern 1 3569  12 read_mipmaps 5 3178  7 options 5 3570  </span>
<span class="s0">1563 0 0 7 1924 3325 2558 0 290 /**</span>
 <span class="s0">* Returns a standard Texture object that has been created with</span>
 <span class="s0">* Texture::generate_normalization_cube_map().  This Texture may be shared by</span>
 <span class="s0">* any application code requiring a normalization cube map.  It will be at</span>
 <span class="s0">* least as large as the specified size, though it may be larger.</span>
 <span class="s0">*/ 1 4 size 1 3177  </span>
<span class="s0">1564 0 0 7 1925 3325 2558 0 296 /**</span>
 <span class="s0">* Returns a standard Texture object that has been created with</span>
 <span class="s0">* Texture::generate_alpha_scale_map().</span>
 <span class="s0">*</span>
 <span class="s0">* This Texture object is used internally by Panda to apply an alpha scale to</span>
 <span class="s0">* an object (instead of munging its vertices) when</span>
 <span class="s0">* gsg-&gt;get_alpha_scale_via_texture() returns true.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1565 0 0 4 1926 3346 0 0 226 /**</span>
 <span class="s0">* Adds the indicated already-loaded texture to the pool.  The texture must</span>
 <span class="s0">* have a filename set for its name.  The texture will always replace any</span>
 <span class="s0">* previously-loaded texture in the pool that had the same filename.</span>
 <span class="s0">*/ 1 7 texture 1 3325  </span>
<span class="s0">1566 0 0 4 1927 3346 0 0 404 /**</span>
 <span class="s0">* Removes the indicated texture from the pool, indicating it will never be</span>
 <span class="s0">* loaded again; the texture may then be freed.  If this function is never</span>
 <span class="s0">* called, a reference count will be maintained on every texture every loaded,</span>
 <span class="s0">* and textures will never be freed.</span>
 <span class="s0">*</span>
 <span class="s0">* The texture's name should not have been changed during its lifetime, or</span>
 <span class="s0">* this function may fail to locate it in the pool.</span>
 <span class="s0">*/ 1 7 texture 1 3325  </span>
<span class="s0">1567 0 0 4 1928 3346 0 0 86 /**</span>
 <span class="s0">* Releases all textures in the pool and restores the pool to the empty state.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1568 0 0 4 1929 3346 0 0 131 /**</span>
 <span class="s0">* Should be called when the model-path changes, to blow away the cache of</span>
 <span class="s0">* texture pathnames found along the model-path.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1569 0 0 6 1930 3177 0 0 212 /**</span>
 <span class="s0">* Releases only those textures in the pool that have a reference count of</span>
 <span class="s0">* exactly 1; i.e.  only those textures that are not being used outside of the</span>
 <span class="s0">* pool.  Returns the number of textures released.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1570 0 0 4 1931 3346 0 0 57 /**</span>
 <span class="s0">* Lists the contents of the texture pool to cout</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1571 0 0 4 1931 3346 0 0 81 /**</span>
 <span class="s0">* Lists the contents of the texture pool to the indicated output stream.</span>
 <span class="s0">*/ 1 3 out 1 3347  </span>
<span class="s0">1572 0 0 7 1932 3325 2558 0 182 /**</span>
 <span class="s0">* Returns the first texture found in the pool that matches the indicated name</span>
 <span class="s0">* (which may contain wildcards).  Returns the texture if it is found, or NULL</span>
 <span class="s0">* if it is not.</span>
 <span class="s0">*/ 1 4 name 1 3342  </span>
<span class="s0">1573 0 0 7 1933 3660 3099 0 124 /**</span>
 <span class="s0">* Returns the set of all textures found in the pool that match the indicated</span>
 <span class="s0">* name (which may contain wildcards).</span>
 <span class="s0">*/ 1 4 name 5 3342  </span>
<span class="s0">1574 0 0 4 1934 3346 0 0 109 /**</span>
 <span class="s0">* Sets a bogus filename that will be loaded in lieu of any textures requested</span>
 <span class="s0">* from this point on.</span>
 <span class="s0">*/ 1 8 filename 1 3569  </span>
<span class="s0">1575 0 0 4 1935 3346 0 0 79 /**</span>
 <span class="s0">* Restores normal behavior of loading the textures actually requested.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1576 0 0 6 1936 3178 0 0 107 /**</span>
 <span class="s0">* Returns true if fake_texture_image mode has been enabled, false if we are</span>
 <span class="s0">* in the normal mode.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1577 0 0 6 1937 3569 0 0 103 /**</span>
 <span class="s0">* Returns the filename that was specified with a previous call to</span>
 <span class="s0">* set_fake_texture_image().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1578 0 0 7 1938 3325 2558 0 185 /**</span>
 <span class="s0">* Creates a new Texture object of the appropriate type for the indicated</span>
 <span class="s0">* filename extension, according to the types that have been registered via</span>
 <span class="s0">* register_texture_type().</span>
 <span class="s0">*/ 1 9 extension 1 3342  </span>
<span class="s0">1579 0 0 4 1939 3346 0 0 100 /**</span>
 <span class="s0">* Lists the contents of the texture pool to the indicated output stream.  For</span>
 <span class="s0">* debugging.</span>
 <span class="s0">*/ 1 3 out 1 3347  </span>
<span class="s0">1580 0 0 15 1950 3592 3153 0 0 1 6 param0 0 3663  </span>
<span class="s0">1581 0 0 6 1942 3177 0 0 191 /**</span>
 <span class="s0">* Returns the width of the texture image that is contributing to the</span>
 <span class="s0">* TexturePeeker's information.  This may be either the Texture's full width,</span>
 <span class="s0">* or its simple ram image's width.</span>
 <span class="s0">*/ 1 4 this 3 3663  </span>
<span class="s0">1582 0 0 6 1943 3177 0 0 194 /**</span>
 <span class="s0">* Returns the height of the texture image that is contributing to the</span>
 <span class="s0">* TexturePeeker's information.  This may be either the Texture's full height,</span>
 <span class="s0">* or its simple ram image's height.</span>
 <span class="s0">*/ 1 4 this 3 3663  </span>
<span class="s0">1583 0 0 6 1944 3177 0 0 109 /**</span>
 <span class="s0">* Returns the depth of the texture image that is contributing to the</span>
 <span class="s0">* TexturePeeker's information.</span>
 <span class="s0">*/ 1 4 this 3 3663  </span>
<span class="s0">1584 0 0 6 1945 3178 0 0 82 /**</span>
 <span class="s0">* Returns whether a given coordinate is inside of the texture dimensions.</span>
 <span class="s0">*/ 3 4 this 3 3663  1 x 1 3177  1 y 1 3177  </span>
<span class="s0">1585 0 0 6 1945 3178 0 0 82 /**</span>
 <span class="s0">* Returns whether a given coordinate is inside of the texture dimensions.</span>
 <span class="s0">*/ 4 4 this 3 3663  1 x 1 3177  1 y 1 3177  1 z 1 3177  </span>
<span class="s0">1586 0 0 4 1946 3346 0 0 309 /**</span>
 <span class="s0">* Fills &quot;color&quot; with the RGBA color of the texel at point (u, v).</span>
 <span class="s0">*</span>
 <span class="s0">* The texel color is determined via nearest-point sampling (no filtering of</span>
 <span class="s0">* adjacent pixels), regardless of the filter type associated with the</span>
 <span class="s0">* texture.  u, v, and w will wrap around regardless of the texture's wrap</span>
 <span class="s0">* mode.</span>
 <span class="s0">*/ 4 4 this 3 3663  5 color 1 3467  1 u 1 3220  1 v 1 3220  </span>
<span class="s0">1587 0 0 4 1946 3346 0 0 312 /**</span>
 <span class="s0">* Fills &quot;color&quot; with the RGBA color of the texel at point (u, v, w).</span>
 <span class="s0">*</span>
 <span class="s0">* The texel color is determined via nearest-point sampling (no filtering of</span>
 <span class="s0">* adjacent pixels), regardless of the filter type associated with the</span>
 <span class="s0">* texture.  u, v, and w will wrap around regardless of the texture's wrap</span>
 <span class="s0">* mode.</span>
 <span class="s0">*/ 5 4 this 3 3663  5 color 1 3467  1 u 1 3220  1 v 1 3220  1 w 1 3220  </span>
<span class="s0">1588 0 0 4 1947 3346 0 0 110 /**</span>
 <span class="s0">* Works like TexturePeeker::lookup(), but instead of uv-coordinates, integer</span>
 <span class="s0">* coordinates are used.</span>
 <span class="s0">*/ 4 4 this 3 3663  5 color 1 3467  1 x 1 3177  1 y 1 3177  </span>
<span class="s0">1589 0 0 4 1947 3346 0 0 110 /**</span>
 <span class="s0">* Works like TexturePeeker::lookup(), but instead of uv-coordinates, integer</span>
 <span class="s0">* coordinates are used.</span>
 <span class="s0">*/ 5 4 this 3 3663  5 color 1 3467  1 x 1 3177  1 y 1 3177  1 z 1 3177  </span>
<span class="s0">1590 0 0 6 1948 3178 0 0 233 /**</span>
 <span class="s0">* Performs a bilinear lookup to retrieve the color value stored at the uv</span>
 <span class="s0">* coordinate (u, v).</span>
 <span class="s0">*</span>
 <span class="s0">* In case the point is outside of the uv range, color is set to zero,</span>
 <span class="s0">* and false is returned.  Otherwise true is returned.</span>
 <span class="s0">*/ 4 4 this 3 3663  5 color 1 3467  1 u 1 3220  1 v 1 3220  </span>
<span class="s0">1591 0 0 4 1949 3346 0 0 245 /**</span>
 <span class="s0">* Fills &quot;color&quot; with the average RGBA color of the texels within the</span>
 <span class="s0">* rectangle defined by the specified coordinate range.</span>
 <span class="s0">*</span>
 <span class="s0">* The texel color is linearly filtered over the entire region.  u, v, and w</span>
 <span class="s0">* must be in the range [0, 1].</span>
 <span class="s0">*/ 6 4 this 3 3663  5 color 1 3467  5 min_u 1 3220  5 min_v 1 3220  5 max_u 1 3220  5 max_v 1 3220  </span>
<span class="s0">1592 0 0 4 1949 3346 0 0 245 /**</span>
 <span class="s0">* Fills &quot;color&quot; with the average RGBA color of the texels within the</span>
 <span class="s0">* rectangle defined by the specified coordinate range.</span>
 <span class="s0">*</span>
 <span class="s0">* The texel color is linearly filtered over the entire region.  u, v, and w</span>
 <span class="s0">* must be in the range [0, 1].</span>
 <span class="s0">*/ 8 4 this 3 3663  5 color 1 3467  5 min_u 1 3220  5 min_v 1 3220  5 min_w 1 3220  5 max_u 1 3220  5 max_v 1 3220  5 max_w 1 3220  </span>
<span class="s0">1593 0 0 7 1954 3251 0 0 666 /**</span>
 <span class="s0">* Returns a TextureStage pointer that represents the same TextureStage</span>
 <span class="s0">* described by temp, except that it is a shared pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* Each call to get_stage() passing an equivalent TextureStage pointer will</span>
 <span class="s0">* return the same shared pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* If you modify the shared pointer, it will automatically disassociate it</span>
 <span class="s0">* from the pool.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, the return value may be a different pointer than that passed in, or</span>
 <span class="s0">* it may be the same pointer.  In either case, the passed in pointer has now</span>
 <span class="s0">* been sacrificed to the greater good and should not be used again (like any</span>
 <span class="s0">* other PointerTo, it will be freed when the last reference count is</span>
 <span class="s0">* removed).</span>
 <span class="s0">*/ 1 4 temp 1 3251  </span>
<span class="s0">1594 0 0 4 1955 3346 0 0 60 /**</span>
 <span class="s0">* Removes the indicated TextureStage from the pool.</span>
 <span class="s0">*/ 1 4 temp 1 3251  </span>
<span class="s0">1595 0 0 4 1956 3346 0 0 94 /**</span>
 <span class="s0">* Releases all TextureStages in the pool and restores the pool to the empty</span>
 <span class="s0">* state.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1596 0 0 4 1957 3346 0 0 489 /**</span>
 <span class="s0">* Specifies the fundamental operating mode of the TextureStagePool.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is M_none, each call to get_stage() returns the same TextureStage</span>
 <span class="s0">* pointer that was passed in (the pool is effectively disabled).  If this is</span>
 <span class="s0">* M_name, each call to get_stage() returns the last TextureStage passed in</span>
 <span class="s0">* with the same name, whether it has different properties or not.  If this is</span>
 <span class="s0">* M_unique, then each call to get_stage() returns only TextureStages with</span>
 <span class="s0">* identical properties.</span>
 <span class="s0">*/ 1 4 mode 1 3341  </span>
<span class="s0">1597 0 0 6 1958 3341 0 0 94 /**</span>
 <span class="s0">* Returns the fundamental operating mode of the TextureStagePool.  See</span>
 <span class="s0">* set_mode().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1598 0 0 6 1960 3177 0 0 227 /**</span>
 <span class="s0">* Releases only those TextureStages in the pool that have a reference count</span>
 <span class="s0">* of exactly 1; i.e.  only those TextureStages that are not being used</span>
 <span class="s0">* outside of the pool.  Returns the number of TextureStages released.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1599 0 0 4 1961 3346 0 0 86 /**</span>
 <span class="s0">* Lists the contents of the TextureStage pool to the indicated output stream.</span>
 <span class="s0">*/ 1 3 out 1 3347  </span>
<span class="s0">1600 0 0 4 1962 3346 0 0 86 /**</span>
 <span class="s0">* Lists the contents of the TextureStage pool to the indicated output stream.</span>
 <span class="s0">*/ 1 3 out 1 3347  </span>
<span class="s0">502</span>
<span class="s0">3163 11 AdaptiveLru 0 26625 11 AdaptiveLru 11 AdaptiveLru 0 0 0 1 1601 1602 0 14 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 0 0 1 0 3164 0 0 0 0 309</span>
<span class="s0">/**</span>
 <span class="s0">* A basic LRU-type algorithm, except that it is adaptive and attempts to</span>
 <span class="s0">* avoid evicting pages that have been used more frequently (even if less</span>
 <span class="s0">* recently) than other pages.</span>
 <span class="s0">*</span>
 <span class="s0">* The interface is designed to be identical to that for SimpleLru, so that it</span>
 <span class="s0">* may be used as a drop-in replacement.</span>
 <span class="s0">*/</span>

<span class="s0">3164 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">3165 15 AdaptiveLruPage 0 26625 15 AdaptiveLruPage 15 AdaptiveLruPage 0 0 0 1 1621 1623 0 12 1622 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 0 0 2 3 3166 1617 1618 3 3167 1619 1620 0 0 575</span>
<span class="s0">/**</span>
 <span class="s0">* One atomic piece that may be managed by a AdaptiveLru chain.  To use this</span>
 <span class="s0">* class, inherit from it and override evict_lru().</span>
 <span class="s0">*</span>
 <span class="s0">* This class multiply inherits from two classes which in turn both inherit</span>
 <span class="s0">* from LinkedListNode.  This is just a sneaky C++ trick to allow this class</span>
 <span class="s0">* to inherit from LinkedListNode twice, so that pages can be stored on two</span>
 <span class="s0">* different linked lists simultaneously.  The AdaptiveLru class depends on</span>
 <span class="s0">* this; it maintains its pages in two different lists, one grouped by</span>
 <span class="s0">* priority, and one in order by next partial update needs.</span>
 <span class="s0">*/</span>

<span class="s0">3166 26 AdaptiveLruPageDynamicList 0 1050624 26 AdaptiveLruPageDynamicList 26 AdaptiveLruPageDynamicList 0 0 0 0 0 0 0 0 0 0 0 0 114</span>
<span class="s0">// See the comment in the head of AdaptiveLruPage, below, for an explanation</span>
<span class="s0">// of these two silly little classes.</span>

<span class="s0">3167 25 AdaptiveLruPageStaticList 0 1050624 25 AdaptiveLruPageStaticList 25 AdaptiveLruPageStaticList 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3168 9 GeomEnums 0 141313 9 GeomEnums 9 GeomEnums 0 0 0 1 1635 1636 0 0 0 0 0 0 7 3169 3170 3171 3172 3173 3174 3175 184</span>
<span class="s0">/**</span>
 <span class="s0">* This class exists just to provide scoping for the various enumerated types</span>
 <span class="s0">* used by Geom, GeomVertexData, GeomVertexArrayData, GeomPrimitive, and other</span>
 <span class="s0">* related classes.</span>
 <span class="s0">*/</span>

<span class="s0">3169 9 UsageHint 0 794624 20 GeomEnums::UsageHint 20 GeomEnums::UsageHint 3168 0 0 0 0 0 0 0 0 0 5 9 UH_client 20 GeomEnums::UH_client 80</span>
<span class="s0">// UH_client: don't attempt to upload the data; always keep it on the</span>
<span class="s0">// client.</span>
<span class="s0">0 9 UH_stream 20 GeomEnums::UH_stream 154</span>
<span class="s0">// UH_stream: the data will be created once, used to render a few times,</span>
<span class="s0">// and then discarded.  This should be used for short-lived temporary</span>
<span class="s0">// objects.</span>
<span class="s0">1 10 UH_dynamic 21 GeomEnums::UH_dynamic 170</span>
<span class="s0">// UH_dynamic: the data will be repeatedly modified and re-rendered.  This</span>
<span class="s0">// is for data that will be modified at runtime, such as animated or soft-</span>
<span class="s0">// skinned vertices.</span>
<span class="s0">2 9 UH_static 20 GeomEnums::UH_static 281</span>
<span class="s0">// UH_static: the data will be created once, and used to render many</span>
<span class="s0">// times, without modification.  This is the most common case, since</span>
<span class="s0">// typically vertex data is not directly animated (this is not related to</span>
<span class="s0">// scene graph animation, e.g.  from adjusting transforms on a node).</span>
<span class="s0">3 14 UH_unspecified 25 GeomEnums::UH_unspecified 265</span>
<span class="s0">// UH_unspecified: the usage is unspecified.  This is intended as a &quot;don't</span>
<span class="s0">// care&quot; option for abstract objects; it should not be applied to any</span>
<span class="s0">// actual geometry to be rendered.  You take your chances if a geom</span>
<span class="s0">// actually gets into the scene graph with this set.</span>
<span class="s0">4 0 0</span>

<span class="s0">3170 13 GeomRendering 0 794624 24 GeomEnums::GeomRendering 24 GeomEnums::GeomRendering 3168 0 0 0 0 0 0 0 0 0 24 16 GR_indexed_point 27 GeomEnums::GR_indexed_point 31</span>
<span class="s0">// If there are indexed points.</span>
<span class="s0">1 16 GR_indexed_other 27 GeomEnums::GR_indexed_other 50</span>
<span class="s0">// If there is indexed geometry of any other type.</span>
<span class="s0">65536 15 GR_indexed_bits 26 GeomEnums::GR_indexed_bits 46</span>
<span class="s0">// The union of all of the indexed attributes.</span>
<span class="s0">65537 8 GR_point 19 GeomEnums::GR_point 34</span>
<span class="s0">// If there are any points at all.</span>
<span class="s0">2 21 GR_point_uniform_size 32 GeomEnums::GR_point_uniform_size 59</span>
<span class="s0">// If the points are all the same size, other than 1 pixel.</span>
<span class="s0">4 17 GR_per_point_size 28 GeomEnums::GR_per_point_size 52</span>
<span class="s0">// If the points have a per-vertex size designation.</span>
<span class="s0">8 20 GR_point_perspective 31 GeomEnums::GR_point_perspective 81</span>
<span class="s0">// If the points' size is specified in camera units rather than screen</span>
<span class="s0">// pixels.</span>
<span class="s0">16 21 GR_point_aspect_ratio 32 GeomEnums::GR_point_aspect_ratio 48</span>
<span class="s0">// If the points have a non-square aspect ratio.</span>
<span class="s0">32 14 GR_point_scale 25 GeomEnums::GR_point_scale 69</span>
<span class="s0">// If the points are under a scale transform, uniform or non-uniform.</span>
<span class="s0">64 15 GR_point_rotate 26 GeomEnums::GR_point_rotate 54</span>
<span class="s0">// If the points are rotated off the orthonormal axis.</span>
<span class="s0">128 15 GR_point_sprite 26 GeomEnums::GR_point_sprite 110</span>
<span class="s0">// If the points require texture coordinates interpolated across their</span>
<span class="s0">// face, to render textures as sprites.</span>
<span class="s0">256 26 GR_point_sprite_tex_matrix 37 GeomEnums::GR_point_sprite_tex_matrix 89</span>
<span class="s0">// If there is a texture matrix applied to the sprite's generated texture</span>
<span class="s0">// coordinates.</span>
<span class="s0">512 13 GR_point_bits 24 GeomEnums::GR_point_bits 72</span>
<span class="s0">// The union of all the above point attributes, except GR_indexed_point.</span>
<span class="s0">1022 17 GR_triangle_strip 28 GeomEnums::GR_triangle_strip 45</span>
<span class="s0">// If there are any of these composite types.</span>
<span class="s0">1024 15 GR_triangle_fan 26 GeomEnums::GR_triangle_fan 0</span>
<span class="s0">2048 13 GR_line_strip 24 GeomEnums::GR_line_strip 0</span>
<span class="s0">4096 17 GR_composite_bits 28 GeomEnums::GR_composite_bits 49</span>
<span class="s0">// The union of all of the above composite types.</span>
<span class="s0">7168 18 GR_strip_cut_index 29 GeomEnums::GR_strip_cut_index 66</span>
<span class="s0">// If strip-cut indices are used to restart a composite primitive.</span>
<span class="s0">131072 20 GR_flat_first_vertex 31 GeomEnums::GR_flat_first_vertex 68</span>
<span class="s0">// If the shade model requires a particular vertex for flat shading.</span>
<span class="s0">8192 19 GR_flat_last_vertex 30 GeomEnums::GR_flat_last_vertex 0</span>
<span class="s0">16384 19 GR_shade_model_bits 30 GeomEnums::GR_shade_model_bits 44</span>
<span class="s0">// The union of the above shade model types.</span>
<span class="s0">24576 24 GR_render_mode_wireframe 35 GeomEnums::GR_render_mode_wireframe 49</span>
<span class="s0">// If a particular non-fill polygon mode is used.</span>
<span class="s0">262144 20 GR_render_mode_point 31 GeomEnums::GR_render_mode_point 0</span>
<span class="s0">524288 12 GR_adjacency 23 GeomEnums::GR_adjacency 43</span>
<span class="s0">// The primitive has adjacency information.</span>
<span class="s0">1048576 0 265</span>
<span class="s0">// This type specifies a number of bits that are used to represent the</span>
<span class="s0">// rendering requirements of a particular Geom, as well as the rendering</span>
<span class="s0">// capabilities of the GSG.  The difference between the two indicates</span>
<span class="s0">// whether the Geom needs to be munged for the GSG.</span>

<span class="s0">3171 10 ShadeModel 0 794624 21 GeomEnums::ShadeModel 21 GeomEnums::ShadeModel 3168 0 0 0 0 0 0 0 0 0 4 10 SM_uniform 21 GeomEnums::SM_uniform 172</span>
<span class="s0">// SM_uniform: all vertices across all faces have the same colors and</span>
<span class="s0">// normals.  It doesn't really matter which ShadeModelAttrib mode is used</span>
<span class="s0">// to render this primitive.</span>
<span class="s0">0 9 SM_smooth 20 GeomEnums::SM_smooth 188</span>
<span class="s0">// SM_smooth: vertices within a single face have different colorsnormals</span>
<span class="s0">// that should be smoothed across the face.  This primitive should be</span>
<span class="s0">// rendered with SmoothModelAttrib::M_smooth.</span>
<span class="s0">1 20 SM_flat_first_vertex 31 GeomEnums::SM_flat_first_vertex 335</span>
<span class="s0">// SM_flat_(first,last)_vertex: each face within the primitive might have</span>
<span class="s0">// a different colornormal than the other faces, but across a particular</span>
<span class="s0">// face there is only one colornormal.  Each face's colornormal is taken</span>
<span class="s0">// from the (first, last) vertex of the face.  This primitive should be</span>
<span class="s0">// rendered with SmoothModelAttrib::M_flat.</span>
<span class="s0">2 19 SM_flat_last_vertex 30 GeomEnums::SM_flat_last_vertex 0</span>
<span class="s0">3 0 235</span>
<span class="s0">// The shade model specifies whether the per-vertex colors and normals</span>
<span class="s0">// indexed by a given primitive truly represent per-vertex colors and</span>
<span class="s0">// normals, or whether they actually represent per-triangle flat-shaded</span>
<span class="s0">// colors and normals.</span>

<span class="s0">3172 13 PrimitiveType 0 794624 24 GeomEnums::PrimitiveType 24 GeomEnums::PrimitiveType 3168 0 0 0 0 0 0 0 0 0 5 7 PT_none 18 GeomEnums::PT_none 0</span>
<span class="s0">0 11 PT_polygons 22 GeomEnums::PT_polygons 0</span>
<span class="s0">1 8 PT_lines 19 GeomEnums::PT_lines 0</span>
<span class="s0">2 9 PT_points 20 GeomEnums::PT_points 0</span>
<span class="s0">3 10 PT_patches 21 GeomEnums::PT_patches 0</span>
<span class="s0">4 0 165</span>
<span class="s0">// The primitive type represents the core primitive type of a particular</span>
<span class="s0">// GeomPrimitive.  It's used for determining what kind of antialiasing</span>
<span class="s0">// should be enabled.</span>

<span class="s0">3173 11 NumericType 0 794624 22 GeomEnums::NumericType 22 GeomEnums::NumericType 3168 0 0 0 0 0 0 0 0 0 12 8 NT_uint8 19 GeomEnums::NT_uint8 20</span>
<span class="s0">// An integer 0..255</span>
<span class="s0">0 9 NT_uint16 20 GeomEnums::NT_uint16 22</span>
<span class="s0">// An integer 0..65535</span>
<span class="s0">1 9 NT_uint32 20 GeomEnums::NT_uint32 27</span>
<span class="s0">// An integer 0..4294967295</span>
<span class="s0">2 14 NT_packed_dcba 25 GeomEnums::NT_packed_dcba 53</span>
<span class="s0">// DirectX style, four byte values packed in a uint32</span>
<span class="s0">3 14 NT_packed_dabc 25 GeomEnums::NT_packed_dabc 36</span>
<span class="s0">// DirectX packed color order (ARGB)</span>
<span class="s0">4 10 NT_float32 21 GeomEnums::NT_float32 27</span>
<span class="s0">// A single-precision float</span>
<span class="s0">5 10 NT_float64 21 GeomEnums::NT_float64 27</span>
<span class="s0">// A double-precision float</span>
<span class="s0">6 11 NT_stdfloat 22 GeomEnums::NT_stdfloat 69</span>
<span class="s0">// Either single- or double-precision, according to vertices-float64.</span>
<span class="s0">7 7 NT_int8 18 GeomEnums::NT_int8 23</span>
<span class="s0">// An integer -128..127</span>
<span class="s0">8 8 NT_int16 19 GeomEnums::NT_int16 27</span>
<span class="s0">// An integer -32768..32767</span>
<span class="s0">9 8 NT_int32 19 GeomEnums::NT_int32 37</span>
<span class="s0">// An integer -2147483648..2147483647</span>
<span class="s0">10 16 NT_packed_ufloat 27 GeomEnums::NT_packed_ufloat 54</span>
<span class="s0">// Three 10/11-bit float components packed in a uint32</span>
<span class="s0">11 0 120</span>
<span class="s0">// The numeric type determines what physical representation is used to</span>
<span class="s0">// encode a numeric value within the vertex data.</span>

<span class="s0">3174 8 Contents 0 794624 19 GeomEnums::Contents 19 GeomEnums::Contents 3168 0 0 0 0 0 0 0 0 0 10 7 C_other 18 GeomEnums::C_other 36</span>
<span class="s0">// Arbitrary meaning, leave it alone</span>
<span class="s0">0 7 C_point 18 GeomEnums::C_point 32</span>
<span class="s0">// A point in 3-space or 4-space</span>
<span class="s0">1 12 C_clip_point 23 GeomEnums::C_clip_point 48</span>
<span class="s0">// A point pre-transformed into clip coordinates</span>
<span class="s0">2 8 C_vector 19 GeomEnums::C_vector 59</span>
<span class="s0">// A surface tangent or binormal (see C_normal for normals)</span>
<span class="s0">3 10 C_texcoord 21 GeomEnums::C_texcoord 23</span>
<span class="s0">// A texture coordinate</span>
<span class="s0">4 7 C_color 18 GeomEnums::C_color 48</span>
<span class="s0">// 3- or 4-component color, ordered R, G, B, [A]</span>
<span class="s0">5 7 C_index 18 GeomEnums::C_index 39</span>
<span class="s0">// An index value into some other table</span>
<span class="s0">6 13 C_morph_delta 24 GeomEnums::C_morph_delta 55</span>
<span class="s0">// A delta from some base value, defining a blend shape</span>
<span class="s0">7 8 C_matrix 19 GeomEnums::C_matrix 118</span>
<span class="s0">// A transformation matrix.  This is typically three or four columns, but</span>
<span class="s0">// we pretend it's only one for convenience.</span>
<span class="s0">8 8 C_normal 19 GeomEnums::C_normal 124</span>
<span class="s0">// A special version of C_vector that should be used for normal vectors,</span>
<span class="s0">// which are scaled differently from other vectors.</span>
<span class="s0">9 0 194</span>
<span class="s0">// The contents determine the semantic meaning of a numeric value within the</span>
<span class="s0">// vertex data.  This is also used to determine what automatic transforms</span>
<span class="s0">// might be applied to the various columns.</span>

<span class="s0">3175 13 AnimationType 0 794624 24 GeomEnums::AnimationType 24 GeomEnums::AnimationType 3168 0 0 0 0 0 0 0 0 0 3 7 AT_none 18 GeomEnums::AT_none 23</span>
<span class="s0">// No vertex animation.</span>
<span class="s0">0 8 AT_panda 19 GeomEnums::AT_panda 51</span>
<span class="s0">// Vertex animation calculated on the CPU by Panda.</span>
<span class="s0">1 11 AT_hardware 22 GeomEnums::AT_hardware 55</span>
<span class="s0">// Hardware-accelerated animation on the graphics card.</span>
<span class="s0">2 0 86</span>
<span class="s0">// The type of animation data that is represented by a particular</span>
<span class="s0">// GeomVertexFormat.</span>

<span class="s0">3176 23 GeomVertexAnimationSpec 0 141313 23 GeomVertexAnimationSpec 23 GeomVertexAnimationSpec 0 0 0 1 1637 1646 3 3665 3666 3667 8 1638 1639 1640 1641 1642 1643 1644 1645 0 0 1 0 3168 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* This object describes how the vertex animation, if any, represented in a</span>
 <span class="s0">* GeomVertexData is encoded.</span>
 <span class="s0">*</span>
 <span class="s0">* Vertex animation includes soft-skinned skeleton animation and morphs (blend</span>
 <span class="s0">* shapes), and might be performed on the CPU by Panda, or passed down to the</span>
 <span class="s0">* graphics backed to be performed on the hardware (depending on the</span>
 <span class="s0">* hardware's advertised capabilities).</span>
 <span class="s0">*</span>
 <span class="s0">* Changing this setting doesn't by itself change the way the animation is</span>
 <span class="s0">* actually performed; this just specifies how the vertices are set up to be</span>
 <span class="s0">* animated.</span>
 <span class="s0">*/</span>

<span class="s0">3177 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3178 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3179 12 InternalName 0 16852993 12 InternalName 12 InternalName 0 0 0 0 0 3 3668 3669 3670 35 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 0 0 1 0 3180 0 0 0 0 514</span>
<span class="s0">/**</span>
 <span class="s0">* Encodes a string name in a hash table, mapping it to a pointer.  This is</span>
 <span class="s0">* used to tokenify names so they may be used efficiently in low-level Panda</span>
 <span class="s0">* structures, for instance to differentiate the multiple sets of texture</span>
 <span class="s0">* coordinates that might be stored on a Geom.</span>
 <span class="s0">*</span>
 <span class="s0">* InternalNames are hierarchical, with the '.' used by convention as a</span>
 <span class="s0">* separator character.  You can construct a single InternalName as a</span>
 <span class="s0">* composition of one or more other names, or by giving it a source string</span>
 <span class="s0">* directly.</span>
 <span class="s0">*/</span>

<span class="s0">3180 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedWritable and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedWritables and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">3181 14 InternalName * 0 8576 14 InternalName * 14 InternalName * 0 0 3179 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3182 6 string 0 2105344 11 std::string 11 std::string 0 0 3183 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3183 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3184 12 string const 0 8832 17 std::string const 17 std::string const 0 0 3182 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3185 16 GeomVertexColumn 0 26625 16 GeomVertexColumn 16 GeomVertexColumn 0 0 0 1 1682 1684 0 22 1683 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 0 0 1 0 3168 0 0 0 0 218</span>
<span class="s0">/**</span>
 <span class="s0">* This defines how a single column is interleaved within a vertex array</span>
 <span class="s0">* stored within a Geom.  The GeomVertexArrayFormat class maintains a list of</span>
 <span class="s0">* these to completely define a particular array structure.</span>
 <span class="s0">*/</span>

<span class="s0">3186 21 GeomVertexArrayFormat 0 16803841 21 GeomVertexArrayFormat 21 GeomVertexArrayFormat 0 0 0 1 1710 1712 6 3671 3672 3673 3674 3675 3676 26 1711 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1 3870 0 2 3 3180 1706 1707 3 3168 1708 1709 0 0 717</span>
<span class="s0">/**</span>
 <span class="s0">* This describes the structure of a single array within a Geom data.  See</span>
 <span class="s0">* GeomVertexFormat for the parent class which collects together all of the</span>
 <span class="s0">* individual GeomVertexArrayFormat objects.</span>
 <span class="s0">*</span>
 <span class="s0">* A particular array may include any number of standard or user-defined</span>
 <span class="s0">* columns.  All columns consist of a sequence of one or more numeric values,</span>
 <span class="s0">* packed in any of a variety of formats; the semantic meaning of each column</span>
 <span class="s0">* is defined in general with its contents member, and in particular by its</span>
 <span class="s0">* name.  The standard array types used most often are named &quot;vertex&quot;,</span>
 <span class="s0">* &quot;normal&quot;, &quot;texcoord&quot;, and &quot;color&quot;; other kinds of data may be piggybacked</span>
 <span class="s0">* into the data record simply by choosing a unique name.</span>
 <span class="s0">*/</span>

<span class="s0">3187 24 GeomVertexColumn const * 0 8576 24 GeomVertexColumn const * 24 GeomVertexColumn const * 0 0 3188 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3188 22 GeomVertexColumn const 0 8832 22 GeomVertexColumn const 22 GeomVertexColumn const 0 0 3185 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3189 16 GeomVertexFormat 0 16803841 16 GeomVertexFormat 16 GeomVertexFormat 0 0 0 1 1742 1744 6 3677 3678 3679 3680 3681 3682 53 1743 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 8 3871 3872 3873 3874 3875 3876 3877 3878 0 2 3 3180 1738 1739 3 3168 1740 1741 0 0 924</span>
<span class="s0">/**</span>
 <span class="s0">* This class defines the physical layout of the vertex data stored within a</span>
 <span class="s0">* Geom.  The layout consists of a list of named columns, each of which has a</span>
 <span class="s0">* numeric type and a size.</span>
 <span class="s0">*</span>
 <span class="s0">* The columns are typically interleaved within a single array, but they may</span>
 <span class="s0">* also be distributed among multiple different arrays; at the extreme, each</span>
 <span class="s0">* column may be alone within its own array (which amounts to a parallel-array</span>
 <span class="s0">* definition).</span>
 <span class="s0">*</span>
 <span class="s0">* Thus, a GeomVertexFormat is really a list of GeomVertexArrayFormats, each</span>
 <span class="s0">* of which contains a list of columns.  However, a particular column name</span>
 <span class="s0">* should not appear more than once in the format, even between different</span>
 <span class="s0">* arrays.</span>
 <span class="s0">*</span>
 <span class="s0">* There are a handful of standard pre-defined GeomVertexFormat objects, or</span>
 <span class="s0">* you may define your own as needed.  You may record any combination of</span>
 <span class="s0">* standard and/or user-defined columns in your custom GeomVertexFormat</span>
 <span class="s0">* constructions.</span>
 <span class="s0">*/</span>

<span class="s0">3190 29 GeomVertexAnimationSpec const 0 8832 29 GeomVertexAnimationSpec const 29 GeomVertexAnimationSpec const 0 0 3176 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3191 29 GeomVertexArrayFormat const * 0 8576 29 GeomVertexArrayFormat const * 29 GeomVertexArrayFormat const * 0 0 3192 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3192 27 GeomVertexArrayFormat const 0 8832 27 GeomVertexArrayFormat const 27 GeomVertexArrayFormat const 0 0 3186 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3193 20 InternalName const * 0 8576 20 InternalName const * 20 InternalName const * 0 0 3194 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3194 18 InternalName const 0 8832 18 InternalName const 18 InternalName const 0 0 3179 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3195 9 SimpleLru 0 26625 9 SimpleLru 9 SimpleLru 0 0 0 1 1801 1802 0 10 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 0 0 2 3 3196 1797 1798 3 3164 1799 1800 0 0 83</span>
<span class="s0">/**</span>
 <span class="s0">* An implementation of a very simple LRU algorithm.  Also see AdaptiveLru.</span>
 <span class="s0">*/</span>

<span class="s0">3196 14 LinkedListNode 0 2048 14 LinkedListNode 14 LinkedListNode 0 0 0 0 0 0 0 0 0 0 0 0 468</span>
<span class="s0">/**</span>
 <span class="s0">* This just stores the pointers to implement a doubly-linked list of some</span>
 <span class="s0">* kind of object.  There are occasions when a hand-rolled linked list is more</span>
 <span class="s0">* appropriate than an STL container.</span>
 <span class="s0">*</span>
 <span class="s0">* Typically, each node of the linked list, as well as the root of the list,</span>
 <span class="s0">* will inherit from this class.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this class is not inherently thread-safe; derived classes are</span>
 <span class="s0">* responsible for protecting any calls into it within mutexes, if necessary.</span>
 <span class="s0">*/</span>

<span class="s0">3197 13 SimpleLruPage 0 26625 13 SimpleLruPage 13 SimpleLruPage 0 0 0 1 1815 1817 0 10 1816 1818 1819 1820 1821 1822 1823 1824 1825 1826 0 0 1 3 3196 1813 1814 0 0 134</span>
<span class="s0">/**</span>
 <span class="s0">* One atomic piece that may be managed by a SimpleLru chain.  To use this</span>
 <span class="s0">* class, inherit from it and override evict_lru().</span>
 <span class="s0">*/</span>

<span class="s0">3198 15 SimpleAllocator 0 26625 15 SimpleAllocator 15 SimpleAllocator 0 0 0 1 1829 1830 0 9 1831 1832 1833 1834 1835 1836 1837 1838 1839 0 0 1 3 3196 1827 1828 0 0 227</span>
<span class="s0">/**</span>
 <span class="s0">* An implementation of a very simple block allocator.  This class can</span>
 <span class="s0">* allocate ranges of nonnegative integers within a specified upper limit; it</span>
 <span class="s0">* uses a simple first-fit algorithm to find the next available space.</span>
 <span class="s0">*/</span>

<span class="s0">3199 20 SimpleAllocatorBlock 0 26625 20 SimpleAllocatorBlock 20 SimpleAllocatorBlock 0 0 0 0 1840 0 9 1841 1842 1843 1844 1845 1846 1847 1848 1849 0 0 1 0 3196 0 0 0 0 68</span>
<span class="s0">/**</span>
 <span class="s0">* A single block as returned from SimpleAllocator::alloc().</span>
 <span class="s0">*/</span>

<span class="s0">3200 18 VertexDataSaveFile 0 75777 18 VertexDataSaveFile 18 VertexDataSaveFile 0 0 0 0 1830 0 3 1850 1851 1852 0 0 1 0 3198 0 0 0 0 174</span>
<span class="s0">/**</span>
 <span class="s0">* A temporary file to hold the vertex data that has been evicted from memory</span>
 <span class="s0">* and written to disk.  All vertex data arrays are written into one large</span>
 <span class="s0">* flat file.</span>
 <span class="s0">*/</span>

<span class="s0">3201 14 VertexDataPage 0 43009 14 VertexDataPage 14 VertexDataPage 0 0 0 0 0 1 3683 18 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 0 0 2 3 3198 1853 1854 3 3197 1855 1856 0 1 3202 189</span>
<span class="s0">/**</span>
 <span class="s0">* A block of bytes that holds one or more VertexDataBlocks.  The entire page</span>
 <span class="s0">* may be paged out, in the form of in-memory compression or to an on-disk</span>
 <span class="s0">* cache file, if necessary.</span>
 <span class="s0">*/</span>

<span class="s0">3202 8 RamClass 0 794624 24 VertexDataPage::RamClass 24 VertexDataPage::RamClass 3201 0 0 0 0 0 0 0 0 0 4 11 RC_resident 27 VertexDataPage::RC_resident 0</span>
<span class="s0">0 13 RC_compressed 29 VertexDataPage::RC_compressed 0</span>
<span class="s0">1 7 RC_disk 23 VertexDataPage::RC_disk 0</span>
<span class="s0">2 14 RC_end_of_list 30 VertexDataPage::RC_end_of_list 26</span>
<span class="s0">// list marker; do not use</span>
<span class="s0">3 0 159</span>
<span class="s0">// These are used to indicate the current residency state of the page, which</span>
<span class="s0">// may or may not have been temporarily evicted to satisfy memory</span>
<span class="s0">// requirements.</span>

<span class="s0">3203 20 VertexDataSaveFile * 0 8576 20 VertexDataSaveFile * 20 VertexDataSaveFile * 0 0 3200 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3204 14 VertexDataBook 0 26625 14 VertexDataBook 14 VertexDataBook 0 0 0 1 1875 1876 0 5 1877 1878 1879 1880 1881 0 0 0 0 0 105</span>
<span class="s0">/**</span>
 <span class="s0">* A collection of VertexDataPages, which can be used to allocate new</span>
 <span class="s0">* VertexDataBlock objects.</span>
 <span class="s0">*/</span>

<span class="s0">3205 15 VertexDataBlock 0 141313 15 VertexDataBlock 15 VertexDataBlock 0 0 0 0 1888 0 2 1886 1887 0 0 2 3 3199 1882 1883 3 3206 1884 1885 0 0 113</span>
<span class="s0">/**</span>
 <span class="s0">* A block of bytes that stores the actual raw vertex data referenced by a</span>
 <span class="s0">* GeomVertexArrayData object.</span>
 <span class="s0">*/</span>

<span class="s0">3206 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">3207 19 GeomVertexArrayData 0 26625 19 GeomVertexArrayData 19 GeomVertexArrayData 0 0 0 1 1895 1897 4 3684 3685 3686 3687 33 1896 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 0 0 3 3 3208 1889 1890 3 3197 1891 1892 3 3168 1893 1894 0 0 678</span>
<span class="s0">/**</span>
 <span class="s0">* This is the data for one array of a GeomVertexData structure.  Many</span>
 <span class="s0">* GeomVertexData structures will only define one array, with all data</span>
 <span class="s0">* elements interleaved (DirectX 8.0 and before insisted on this format); some</span>
 <span class="s0">* will define multiple arrays.</span>
 <span class="s0">*</span>
 <span class="s0">* DirectX calls this concept of one array a &quot;stream&quot;. It also closely</span>
 <span class="s0">* correlates with the concept of a vertex buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* This object is just a block of data.  In general, you should not be</span>
 <span class="s0">* directly messing with this object from application code.  See</span>
 <span class="s0">* GeomVertexData for the organizing structure, and see</span>
 <span class="s0">* GeomVertexReader/Writer/Rewriter for high-level tools to manipulate the</span>
 <span class="s0">* actual vertex data.</span>
 <span class="s0">*/</span>

<span class="s0">3208 17 CopyOnWriteObject 0 2048 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169</span>
<span class="s0">/**</span>
 <span class="s0">* This base class provides basic reference counting, but also can be used</span>
 <span class="s0">* with a CopyOnWritePointer to provide get_read_pointer() and</span>
 <span class="s0">* get_write_pointer().</span>
 <span class="s0">*/</span>

<span class="s0">3209 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3210 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3210 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3211 9 UpdateSeq 0 2048 9 UpdateSeq 9 UpdateSeq 0 0 0 0 0 0 0 0 0 0 0 0 761</span>
<span class="s0">/**</span>
 <span class="s0">* This is a sequence number that increments monotonically.  It can be used to</span>
 <span class="s0">* track cache updates, or serve as a kind of timestamp for any changing</span>
 <span class="s0">* properties.</span>
 <span class="s0">*</span>
 <span class="s0">* A special class is used instead of simply an int, so we can elegantly</span>
 <span class="s0">* handle such things as wraparound and special cases.  There are two special</span>
 <span class="s0">* cases.  Firstly, a sequence number is 'initial' when it is first created.</span>
 <span class="s0">* This sequence is older than any other sequence number.  Secondly, a</span>
 <span class="s0">* sequence number may be explicitly set to 'old'.  This is older than any</span>
 <span class="s0">* other sequence number except 'initial'.  Finally, we have the explicit</span>
 <span class="s0">* number 'fresh', which is newer than any other sequence number.  All other</span>
 <span class="s0">* sequences are numeric and are monotonically increasing.</span>
 <span class="s0">*/</span>

<span class="s0">3212 25 GeomVertexArrayDataHandle 0 26625 25 GeomVertexArrayDataHandle 25 GeomVertexArrayDataHandle 0 0 0 0 1934 5 3688 3689 3690 3691 3692 20 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 0 0 2 3 3206 1930 1931 3 3168 1932 1933 0 0 504</span>
<span class="s0">/**</span>
 <span class="s0">* This data object is returned by GeomVertexArrayData::get_handle() or</span>
 <span class="s0">* modify_handle(). As long as it exists, the data is locked; when the last of</span>
 <span class="s0">* these destructs, the data is unlocked.</span>
 <span class="s0">*</span>
 <span class="s0">* Only one thread at a time may lock the data; other threads attempting to</span>
 <span class="s0">* lock the data will block.  A given thread may simultaneously lock the data</span>
 <span class="s0">* multiple times.</span>
 <span class="s0">*</span>
 <span class="s0">* This class serves in lieu of a pair of GeomVertexArrayDataPipelineReader</span>
 <span class="s0">* and GeomVertexArrayDataPipelineWriter classes</span>
 <span class="s0">*/</span>

<span class="s0">3213 21 GeomVertexArrayData * 0 8576 21 GeomVertexArrayData * 21 GeomVertexArrayData * 0 0 3207 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3214 16 GeomCacheManager 0 43009 16 GeomCacheManager 16 GeomCacheManager 0 0 0 0 0 0 5 1955 1956 1957 1958 1959 0 0 0 0 0 640</span>
<span class="s0">/**</span>
 <span class="s0">* This is used to keep track of, and limit the size of, the cache of munged</span>
 <span class="s0">* vertices, which would otherwise be distributed through all of the</span>
 <span class="s0">* GeomVertexData objects in the system.</span>
 <span class="s0">*</span>
 <span class="s0">* The actual data in the cache is not stored here, but rather it is</span>
 <span class="s0">* distributed among the various GeomVertexData source objects.  This allows</span>
 <span class="s0">* the cache data to propagate through the multiprocess pipeline.</span>
 <span class="s0">*</span>
 <span class="s0">* This structure actually caches any of a number of different types of</span>
 <span class="s0">* pointers, and mixes them all up in the same LRU cache list.  Some of them</span>
 <span class="s0">* (such as GeomMunger) are reference-counted here in the cache; most are not.</span>
 <span class="s0">*/</span>

<span class="s0">3215 15 VertexTransform 0 75777 15 VertexTransform 15 VertexTransform 0 0 0 0 0 1 3693 9 1960 1961 1962 1963 1964 1965 1966 1967 1968 0 0 1 0 3180 0 0 0 0 305</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class that holds a pointer to some transform,</span>
 <span class="s0">* computed in some arbitrary way, that is to be applied to vertices during</span>
 <span class="s0">* rendering.  This is used to implement soft-skinned and animated vertices.</span>
 <span class="s0">* Derived classes will define how the transform is actually computed.</span>
 <span class="s0">*/</span>

<span class="s0">3216 14 TransformTable 0 75777 14 TransformTable 14 TransformTable 0 0 0 1 1969 0 3 3694 3695 3696 12 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1 3879 0 1 0 3180 0 0 0 0 328</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the total set of VertexTransforms that the vertices in a particular</span>
 <span class="s0">* GeomVertexData object might depend on.</span>
 <span class="s0">*</span>
 <span class="s0">* This structure is used for a GeomVertexData set up to compute its dynamic</span>
 <span class="s0">* vertices on the graphics card.  See TransformBlendTable for one set up to</span>
 <span class="s0">* compute its dynamic vertices on the CPU.</span>
 <span class="s0">*/</span>

<span class="s0">3217 23 VertexTransform const * 0 8576 23 VertexTransform const * 23 VertexTransform const * 0 0 3218 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3218 21 VertexTransform const 0 8832 21 VertexTransform const 21 VertexTransform const 0 0 3215 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3219 14 TransformBlend 0 26625 14 TransformBlend 14 TransformBlend 0 0 0 1 1982 1984 3 3697 3698 3699 23 1983 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 1 3880 0 0 0 0 150</span>
<span class="s0">/**</span>
 <span class="s0">* This defines a single entry in a TransformBlendTable.  It represents a</span>
 <span class="s0">* unique combination of VertexTransform pointers and blend amounts.</span>
 <span class="s0">*/</span>

<span class="s0">3220 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3221 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3221 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3222 19 TransformBlendTable 0 75777 19 TransformBlendTable 19 TransformBlendTable 0 0 0 1 2007 0 5 3700 3701 3702 3703 3704 14 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 1 3881 0 1 0 3208 0 0 0 0 537</span>
<span class="s0">/**</span>
 <span class="s0">* This structure collects together the different combinations of transforms</span>
 <span class="s0">* and blend amounts used by a GeomVertexData, to facilitate computing dynamic</span>
 <span class="s0">* vertices on the CPU at runtime.  Each vertex has a pointer to exactly one</span>
 <span class="s0">* of the entries in this table, and each entry defines a number of</span>
 <span class="s0">* transform/blend combinations.</span>
 <span class="s0">*</span>
 <span class="s0">* This structure is used for a GeomVertexData set up to compute its dynamic</span>
 <span class="s0">* vertices on the CPU.  See TransformTable for one set up to compute its</span>
 <span class="s0">* dynamic vertices on the graphics card.</span>
 <span class="s0">*/</span>

<span class="s0">3223 20 TransformBlend const 0 8832 20 TransformBlend const 20 TransformBlend const 0 0 3219 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3224 17 SparseArray const 0 8832 17 SparseArray const 17 SparseArray const 0 0 3225 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3225 11 SparseArray 0 2048 11 SparseArray 11 SparseArray 0 0 0 0 0 0 0 0 0 0 0 0 736</span>
<span class="s0">/**</span>
 <span class="s0">* This class records a set of integers, where each integer is either present</span>
 <span class="s0">* or not present in the set.</span>
 <span class="s0">*</span>
 <span class="s0">* It is similar in principle and in interface to a BitArray (which can be</span>
 <span class="s0">* thought of as a set of integers, one integer corresponding to each</span>
 <span class="s0">* different bit position), but the SparseArray is implemented as a list of</span>
 <span class="s0">* min/max subrange lists, rather than as a bitmask.</span>
 <span class="s0">*</span>
 <span class="s0">* This makes it particularly efficient for storing sets which consist of</span>
 <span class="s0">* large sections of consecutively included or consecutively excluded</span>
 <span class="s0">* elements, with arbitrarily large integers, but particularly inefficient for</span>
 <span class="s0">* doing boolean operations such as &amp; or |.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, unlike BitArray, the SparseArray can store negative integers.</span>
 <span class="s0">*/</span>

<span class="s0">3226 12 VertexSlider 0 75777 12 VertexSlider 12 VertexSlider 0 0 0 0 0 3 3705 3706 3707 6 2022 2023 2024 2025 2026 2027 0 0 1 0 3180 0 0 0 0 343</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class that retains some slider value, which is a</span>
 <span class="s0">* linear value that typically ranges from 0.0 to 1.0, and is used to control</span>
 <span class="s0">* the animation of morphs (blend shapes).</span>
 <span class="s0">*</span>
 <span class="s0">* It is similar to VertexTransform, which keeps a full 4x4 transform matrix,</span>
 <span class="s0">* but the VertexSlider only keeps a single float value.</span>
 <span class="s0">*/</span>

<span class="s0">3227 11 SliderTable 0 75777 11 SliderTable 11 SliderTable 0 0 0 1 2028 0 1 3708 16 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 1 3882 0 1 0 3180 0 0 0 0 402</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the total set of VertexSliders that the vertices in a particular</span>
 <span class="s0">* GeomVertexData object might depend on.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to a TransformTable, but it stores VertexSliders instead of</span>
 <span class="s0">* VertexTransforms, and it stores them by name instead of by index number.</span>
 <span class="s0">* Also, it is only used when animating vertices on the CPU, since GPU's don't</span>
 <span class="s0">* support morphs at this point in time.</span>
 <span class="s0">*/</span>

<span class="s0">3228 14 GeomVertexData 0 26625 14 GeomVertexData 14 GeomVertexData 0 0 0 1 2049 2051 8 3709 3710 3711 3712 3713 3714 3715 3716 53 2050 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 1 3883 0 2 3 3208 2045 2046 3 3168 2047 2048 0 0 1085</span>
<span class="s0">/**</span>
 <span class="s0">* This defines the actual numeric vertex data stored in a Geom, in the</span>
 <span class="s0">* structure defined by a particular GeomVertexFormat object.</span>
 <span class="s0">*</span>
 <span class="s0">* The data consists of one or more arrays, each of which in turn consists of</span>
 <span class="s0">* a series of rows, one per vertex.  All arrays should have the same number</span>
 <span class="s0">* of rows; each vertex is defined by the column data from a particular row</span>
 <span class="s0">* across all arrays.</span>
 <span class="s0">*</span>
 <span class="s0">* Often, there will be only one array per Geom, and the various columns</span>
 <span class="s0">* defined in the GeomVertexFormat will be interleaved within that array.</span>
 <span class="s0">* However, it is also possible to have multiple different arrays, with a</span>
 <span class="s0">* certain subset of the total columns defined in each array.</span>
 <span class="s0">*</span>
 <span class="s0">* However the data is distributed, the effect is of a single table of</span>
 <span class="s0">* vertices, where each vertex is represented by one row of the table.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, application code should not attempt to directly manipulate the</span>
 <span class="s0">* vertex data through this structure; instead, use the GeomVertexReader,</span>
 <span class="s0">* GeomVertexWriter, and GeomVertexRewriter objects to read and write vertex</span>
 <span class="s0">* data at a high level.</span>
 <span class="s0">*/</span>

<span class="s0">3229 24 GeomVertexFormat const * 0 8576 24 GeomVertexFormat const * 24 GeomVertexFormat const * 0 0 3230 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3230 22 GeomVertexFormat const 0 8832 22 GeomVertexFormat const 22 GeomVertexFormat const 0 0 3189 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3231 37 ConstPointerTo&lt; GeomVertexArrayData &gt; 0 2048 37 ConstPointerTo&lt; GeomVertexArrayData &gt; 37 ConstPointerTo&lt; GeomVertexArrayData &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3232 22 TransformTable const * 0 8576 22 TransformTable const * 22 TransformTable const * 0 0 3233 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3233 20 TransformTable const 0 8832 20 TransformTable const 20 TransformTable const 0 0 3216 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3234 19 SliderTable const * 0 8576 19 SliderTable const * 19 SliderTable const * 0 0 3235 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3235 17 SliderTable const 0 8832 17 SliderTable const 17 SliderTable const 0 0 3227 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3236 22 AnimateVerticesRequest 0 141313 22 AnimateVerticesRequest 22 AnimateVerticesRequest 0 0 0 1 2104 2107 0 2 2105 2106 0 0 1 0 3237 0 0 0 0 587</span>
<span class="s0">/**</span>
 <span class="s0">* This class object manages a single asynchronous request to animate vertices</span>
 <span class="s0">* on a GeomVertexData object.  animate_vertices will be called with</span>
 <span class="s0">* force=true (i.e.  blocking) in a sub-thread (if threading is available).</span>
 <span class="s0">* No result is stored or returned from this object.  It is expected that the</span>
 <span class="s0">* result will be cached and available for immediate use later during</span>
 <span class="s0">* rendering.  Thus it is important that the main thread block while these</span>
 <span class="s0">* requests are being run (presumably on multiple CPUs/cores), to ensure that</span>
 <span class="s0">* the data has been computed by the time it's needed.</span>
 <span class="s0">*/</span>

<span class="s0">3237 9 AsyncTask 0 2048 9 AsyncTask 9 AsyncTask 0 0 0 0 0 0 0 0 0 0 0 0 217</span>
<span class="s0">/**</span>
 <span class="s0">* This class represents a concrete task performed by an AsyncManager.</span>
 <span class="s0">* Normally, you would subclass from this class, and override do_task(), to</span>
 <span class="s0">* define the functionality you wish to have the task perform.</span>
 <span class="s0">*/</span>

<span class="s0">3238 12 SavedContext 0 141313 12 SavedContext 12 SavedContext 0 0 0 0 2109 0 1 2108 0 0 1 0 3239 0 0 0 0 176</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all GSG-specific context objects, such as</span>
 <span class="s0">* TextureContext and GeomContext.  It exists mainly to provide some</span>
 <span class="s0">* structural organization.</span>
 <span class="s0">*/</span>

<span class="s0">3239 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">3240 13 BufferContext 0 26625 13 BufferContext 13 BufferContext 0 0 0 0 2112 5 3717 3718 3719 3720 3721 5 2113 2114 2115 2116 2118 0 0 1 3 3238 2110 2111 0 0 459</span>
<span class="s0">/**</span>
 <span class="s0">* This is a base class for those kinds of SavedContexts that occupy an</span>
 <span class="s0">* easily-measured (and substantial) number of bytes in the video card's frame</span>
 <span class="s0">* buffer memory or AGP memory.  At the present, this includes most of the</span>
 <span class="s0">* SavedContext types: VertexBufferContext and IndexBufferContext, as well as</span>
 <span class="s0">* TextureContext.</span>
 <span class="s0">*</span>
 <span class="s0">* This class provides methods for tracking the video memory utilization, as</span>
 <span class="s0">* well as residency of each object, via PStats.</span>
 <span class="s0">*/</span>

<span class="s0">3241 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 3180 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3242 13 GeomPrimitive 0 26625 13 GeomPrimitive 13 GeomPrimitive 0 0 0 0 2124 15 3722 3723 3724 3725 3726 3727 3728 3729 3730 3731 3732 3733 3734 3735 3736 75 2123 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 1 3884 0 2 3 3208 2119 2120 3 3168 2121 2122 0 0 803</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class for a family of classes that represent the</span>
 <span class="s0">* fundamental geometry primitives that may be stored in a Geom.</span>
 <span class="s0">*</span>
 <span class="s0">* They all have in common the fact that they are defined by tables of vertex</span>
 <span class="s0">* data stored in a GeomVertexData object.  Each GeomPrimitive object contains</span>
 <span class="s0">* an ordered list of integers, which index into the vertex array defined by</span>
 <span class="s0">* the GeomVertexData and define the particular vertices of the GeomVertexData</span>
 <span class="s0">* that are used for this primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* The meaning of a given arrangement of vertices is defined by each</span>
 <span class="s0">* individual primitive type; for instance, a GeomTriangle renders a triangle</span>
 <span class="s0">* from each three consecutive vertices, while a GeomTriangleStrip renders a</span>
 <span class="s0">* strip of (n - 2) connected triangles from each sequence of n vertices.</span>
 <span class="s0">*/</span>

<span class="s0">3243 12 TextureStage 0 75777 12 TextureStage 12 TextureStage 0 0 0 1 2199 0 13 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746 3747 3748 3749 54 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 0 0 1 0 3180 0 0 0 4 3244 3245 3246 3247 336</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the properties of a named stage of the multitexture pipeline.  The</span>
 <span class="s0">* TextureAttrib will associated a number of these stages with Texture</span>
 <span class="s0">* objects, and the GSG will render geometry by sorting all of the currently</span>
 <span class="s0">* active TextureStages in order and then issuing the appropriate rendering</span>
 <span class="s0">* calls to activate them.</span>
 <span class="s0">*/</span>

<span class="s0">3244 4 Mode 0 794624 18 TextureStage::Mode 18 TextureStage::Mode 3243 0 0 0 0 0 0 0 0 0 17 10 M_modulate 24 TextureStage::M_modulate 0</span>
<span class="s0">0 7 M_decal 21 TextureStage::M_decal 0</span>
<span class="s0">1 7 M_blend 21 TextureStage::M_blend 0</span>
<span class="s0">2 9 M_replace 23 TextureStage::M_replace 0</span>
<span class="s0">3 5 M_add 19 TextureStage::M_add 0</span>
<span class="s0">4 9 M_combine 23 TextureStage::M_combine 0</span>
<span class="s0">5 19 M_blend_color_scale 33 TextureStage::M_blend_color_scale 0</span>
<span class="s0">6 15 M_modulate_glow 29 TextureStage::M_modulate_glow 47</span>
<span class="s0">// When fixed-function, equivalent to modulate.</span>
<span class="s0">7 16 M_modulate_gloss 30 TextureStage::M_modulate_gloss 47</span>
<span class="s0">// When fixed-function, equivalent to modulate.</span>
<span class="s0">8 8 M_normal 22 TextureStage::M_normal 0</span>
<span class="s0">9 15 M_normal_height 29 TextureStage::M_normal_height 0</span>
<span class="s0">10 6 M_glow 20 TextureStage::M_glow 49</span>
<span class="s0">// Rarely used: modulate_glow  is more efficient.</span>
<span class="s0">11 7 M_gloss 21 TextureStage::M_gloss 49</span>
<span class="s0">// Rarely used: modulate_gloss is more efficient.</span>
<span class="s0">12 8 M_height 22 TextureStage::M_height 49</span>
<span class="s0">// Rarely used: normal_height  is more efficient.</span>
<span class="s0">13 10 M_selector 24 TextureStage::M_selector 0</span>
<span class="s0">14 14 M_normal_gloss 28 TextureStage::M_normal_gloss 0</span>
<span class="s0">15 10 M_emission 24 TextureStage::M_emission 0</span>
<span class="s0">16 0 0</span>

<span class="s0">3245 11 CombineMode 0 794624 25 TextureStage::CombineMode 25 TextureStage::CombineMode 3243 0 0 0 0 0 0 0 0 0 9 12 CM_undefined 26 TextureStage::CM_undefined 0</span>
<span class="s0">0 10 CM_replace 24 TextureStage::CM_replace 0</span>
<span class="s0">1 11 CM_modulate 25 TextureStage::CM_modulate 0</span>
<span class="s0">2 6 CM_add 20 TextureStage::CM_add 0</span>
<span class="s0">3 13 CM_add_signed 27 TextureStage::CM_add_signed 0</span>
<span class="s0">4 14 CM_interpolate 28 TextureStage::CM_interpolate 0</span>
<span class="s0">5 11 CM_subtract 25 TextureStage::CM_subtract 0</span>
<span class="s0">6 11 CM_dot3_rgb 25 TextureStage::CM_dot3_rgb 67</span>
<span class="s0">// The following are valid only for combine_rgb, not combine_alpha.</span>
<span class="s0">7 12 CM_dot3_rgba 26 TextureStage::CM_dot3_rgba 0</span>
<span class="s0">8 0 0</span>

<span class="s0">3246 13 CombineSource 0 794624 27 TextureStage::CombineSource 27 TextureStage::CombineSource 3243 0 0 0 0 0 0 0 0 0 7 12 CS_undefined 26 TextureStage::CS_undefined 0</span>
<span class="s0">0 10 CS_texture 24 TextureStage::CS_texture 0</span>
<span class="s0">1 11 CS_constant 25 TextureStage::CS_constant 0</span>
<span class="s0">2 16 CS_primary_color 30 TextureStage::CS_primary_color 0</span>
<span class="s0">3 11 CS_previous 25 TextureStage::CS_previous 0</span>
<span class="s0">4 23 CS_constant_color_scale 37 TextureStage::CS_constant_color_scale 0</span>
<span class="s0">5 20 CS_last_saved_result 34 TextureStage::CS_last_saved_result 0</span>
<span class="s0">6 0 0</span>

<span class="s0">3247 14 CombineOperand 0 794624 28 TextureStage::CombineOperand 28 TextureStage::CombineOperand 3243 0 0 0 0 0 0 0 0 0 5 12 CO_undefined 26 TextureStage::CO_undefined 0</span>
<span class="s0">0 12 CO_src_color 26 TextureStage::CO_src_color 0</span>
<span class="s0">1 22 CO_one_minus_src_color 36 TextureStage::CO_one_minus_src_color 0</span>
<span class="s0">2 12 CO_src_alpha 26 TextureStage::CO_src_alpha 0</span>
<span class="s0">3 22 CO_one_minus_src_alpha 36 TextureStage::CO_one_minus_src_alpha 0</span>
<span class="s0">4 0 0</span>

<span class="s0">3248 6 LColor 0 2105344 6 LColor 6 LColor 0 0 3249 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3249 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 3250 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3250 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3251 14 TextureStage * 0 8576 14 TextureStage * 14 TextureStage * 0 0 3243 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3252 4 Geom 0 26625 4 Geom 4 Geom 0 0 0 1 2258 2260 7 3750 3751 3752 3753 3754 3755 3756 66 2259 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 1 3885 0 2 3 3208 2254 2255 3 3168 2256 2257 0 0 418</span>
<span class="s0">/**</span>
 <span class="s0">* A container for geometry primitives.  This class associates one or more</span>
 <span class="s0">* GeomPrimitive objects with a table of vertices defined by a GeomVertexData</span>
 <span class="s0">* object.  All of the primitives stored in a particular Geom are drawn from</span>
 <span class="s0">* the same set of vertices (each primitive uses a subset of all of the</span>
 <span class="s0">* vertices in the table), and all of them must be rendered at the same time,</span>
 <span class="s0">* in the same graphics state.</span>
 <span class="s0">*/</span>

<span class="s0">3253 31 ConstPointerTo&lt; GeomPrimitive &gt; 0 2048 31 ConstPointerTo&lt; GeomPrimitive &gt; 31 ConstPointerTo&lt; GeomPrimitive &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3254 10 BoundsType 0 794624 26 BoundingVolume::BoundsType 26 BoundingVolume::BoundsType 3255 0 0 0 0 0 0 0 0 0 5 10 BT_default 26 BoundingVolume::BT_default 0</span>
<span class="s0">0 7 BT_best 23 BoundingVolume::BT_best 0</span>
<span class="s0">1 9 BT_sphere 25 BoundingVolume::BT_sphere 0</span>
<span class="s0">2 6 BT_box 22 BoundingVolume::BT_box 0</span>
<span class="s0">3 10 BT_fastest 26 BoundingVolume::BT_fastest 0</span>
<span class="s0">4 0 80</span>
<span class="s0">// This enum is used to control the automatic generation of bounding</span>
<span class="s0">// volumes.</span>

<span class="s0">3255 14 BoundingVolume 0 2048 14 BoundingVolume 14 BoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 330</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class for any volume in any sense which can be said to</span>
 <span class="s0">* define the locality of reference of a node in a graph, along with all of</span>
 <span class="s0">* its descendants.  It is not necessarily a geometric volume (although see</span>
 <span class="s0">* GeometricBoundingVolume); this is simply an abstract interface for bounds</span>
 <span class="s0">* of any sort.</span>
 <span class="s0">*/</span>

<span class="s0">3256 11 GeomContext 0 141313 11 GeomContext 11 GeomContext 0 0 0 0 2328 1 3757 2 2326 2327 0 0 1 0 3238 0 0 0 0 534</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special class object that holds all the information returned by a</span>
 <span class="s0">* particular GSG to indicate the geom's internal context identifier.</span>
 <span class="s0">*</span>
 <span class="s0">* Geoms typically have an immediate-mode and a retained-mode operation.  When</span>
 <span class="s0">* using geoms in retained-mode (in response to Geom::prepare()), the GSG will</span>
 <span class="s0">* create some internal handle for the geom and store it here.  The geom</span>
 <span class="s0">* stores all of these handles internally.</span>
 <span class="s0">*</span>
 <span class="s0">* In the case of OpenGL, for example, a GeomContext corresponds to a display</span>
 <span class="s0">* list identifier.</span>
 <span class="s0">*/</span>

<span class="s0">3257 6 Geom * 0 8576 6 Geom * 6 Geom * 0 0 3252 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3258 9 GeomLines 0 75777 9 GeomLines 9 GeomLines 0 0 0 1 2329 2124 0 4 2330 2331 2332 2333 0 0 1 0 3242 0 0 0 0 58</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of disconnected line segments.</span>
 <span class="s0">*/</span>

<span class="s0">3259 18 GeomLinesAdjacency 0 75777 18 GeomLinesAdjacency 18 GeomLinesAdjacency 0 0 0 1 2334 2124 0 4 2335 2336 2337 2338 0 0 1 0 3242 0 0 0 0 139</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of disconnected line segments with adjacency information,</span>
 <span class="s0">* for use with geometry shaders.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">3260 14 GeomLinestrips 0 75777 14 GeomLinestrips 14 GeomLinestrips 0 0 0 1 2339 2124 0 4 2340 2341 2342 2343 0 0 1 0 3242 0 0 0 0 43</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of line strips.</span>
 <span class="s0">*/</span>

<span class="s0">3261 23 GeomLinestripsAdjacency 0 75777 23 GeomLinestripsAdjacency 23 GeomLinestripsAdjacency 0 0 0 1 2344 2124 0 4 2345 2346 2347 2348 0 0 1 0 3242 0 0 0 0 90</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of line strips with adjacency information.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">3262 11 GeomPatches 0 75777 11 GeomPatches 11 GeomPatches 0 0 0 1 2349 2124 0 4 2350 2351 2352 2353 0 0 1 0 3242 0 0 0 0 126</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of &quot;patches&quot;, fixed-size groupings of vertices that must</span>
 <span class="s0">* be processed by a tessellation shader.</span>
 <span class="s0">*/</span>

<span class="s0">3263 10 GeomPoints 0 75777 10 GeomPoints 10 GeomPoints 0 0 0 1 2354 2124 0 4 2355 2356 2357 2358 0 0 1 0 3242 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of disconnected points.</span>
 <span class="s0">*/</span>

<span class="s0">3264 13 GeomTriangles 0 75777 13 GeomTriangles 13 GeomTriangles 0 0 0 1 2359 2124 0 4 2360 2361 2362 2363 0 0 1 0 3242 0 0 0 0 54</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of disconnected triangles.</span>
 <span class="s0">*/</span>

<span class="s0">3265 22 GeomTrianglesAdjacency 0 75777 22 GeomTrianglesAdjacency 22 GeomTrianglesAdjacency 0 0 0 1 2364 2124 0 4 2365 2366 2367 2368 0 0 1 0 3242 0 0 0 0 102</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of disconnected triangles, with adjacency information.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">3266 11 GeomTrifans 0 75777 11 GeomTrifans 11 GeomTrifans 0 0 0 1 2369 2124 0 4 2370 2371 2372 2373 0 0 1 0 3242 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of triangle fans.</span>
 <span class="s0">*/</span>

<span class="s0">3267 13 GeomTristrips 0 75777 13 GeomTristrips 13 GeomTristrips 0 0 0 1 2374 2124 0 4 2375 2376 2377 2378 0 0 1 0 3242 0 0 0 0 47</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of triangle strips.</span>
 <span class="s0">*/</span>

<span class="s0">3268 22 GeomTristripsAdjacency 0 75777 22 GeomTristripsAdjacency 22 GeomTristripsAdjacency 0 0 0 1 2379 2124 0 4 2380 2381 2382 2383 0 0 1 0 3242 0 0 0 0 94</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a series of triangle strips with adjacency information.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">3269 16 GeomVertexReader 0 26625 16 GeomVertexReader 16 GeomVertexReader 0 0 0 1 2384 2386 0 41 2385 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 0 0 1 0 3168 0 0 0 0 1256</span>
<span class="s0">/**</span>
 <span class="s0">* This object provides a high-level interface for quickly reading a sequence</span>
 <span class="s0">* of numeric values from a vertex table.</span>
 <span class="s0">*</span>
 <span class="s0">* It is particularly optimized for reading a single column of data values for</span>
 <span class="s0">* a series of vertices, without changing columns between each number.</span>
 <span class="s0">* Although you can also use one GeomVertexReader to read across the columns</span>
 <span class="s0">* if it is convenient, by calling set_column() repeatedly at each vertex, it</span>
 <span class="s0">* is faster to read down the columns, and to use a different GeomVertexReader</span>
 <span class="s0">* for each column.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that a GeomVertexReader does not keep a reference count to the actual</span>
 <span class="s0">* vertex data buffer (it grabs the current data buffer from the</span>
 <span class="s0">* GeomVertexData whenever set_column() is called).  This means that it is</span>
 <span class="s0">* important not to keep a GeomVertexReader object around over a long period</span>
 <span class="s0">* of time in which the data buffer is likely to be deallocated; it is</span>
 <span class="s0">* intended for making a quick pass over the data in one session.</span>
 <span class="s0">*</span>
 <span class="s0">* It also means that you should create any GeomVertexWriters *before*</span>
 <span class="s0">* creating GeomVertexReaders on the same data, since the writer itself might</span>
 <span class="s0">* cause the vertex buffer to be deallocated.  Better yet, use a</span>
 <span class="s0">* GeomVertexRewriter if you are going to create both of them anyway.</span>
 <span class="s0">*/</span>

<span class="s0">3270 16 GeomVertexWriter 0 26625 16 GeomVertexWriter 16 GeomVertexWriter 0 0 0 1 2427 2429 0 62 2428 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 0 0 1 0 3168 0 0 0 0 1822</span>
<span class="s0">/**</span>
 <span class="s0">* This object provides a high-level interface for quickly writing a sequence</span>
 <span class="s0">* of numeric values from a vertex table.</span>
 <span class="s0">*</span>
 <span class="s0">* This object can be used both to replace existing vertices in the table, or</span>
 <span class="s0">* to extend the table with new vertices.  The set_data*() family of methods</span>
 <span class="s0">* can only be used to replace existing data; it is an error to allow these to</span>
 <span class="s0">* run past the end of the data.  The add_data*() family of methods, on the</span>
 <span class="s0">* other hand, can be used to replace existing data or add new data; if you</span>
 <span class="s0">* call set_row() into the middle of existing data the add_data*() methods</span>
 <span class="s0">* will behave like the corresponding set_data*(), but if they run past the</span>
 <span class="s0">* end of existing data they will quietly add new vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* Like GeomVertexReader, the writer is particularly optimized for writing a</span>
 <span class="s0">* single column of data values for a series of vertices, without changing</span>
 <span class="s0">* columns between each number.  Although you can also use one</span>
 <span class="s0">* GeomVertexWriter to write across the columns if it is convenient, by</span>
 <span class="s0">* calling set_column() repeatedly at each vertex, it is faster to write down</span>
 <span class="s0">* the columns, and to use a different GeomVertexWriter for each column.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that, like a GeomVertexReader, a GeomVertexWriter does not keep a</span>
 <span class="s0">* reference count to the actual vertex data buffer.  This means that it is</span>
 <span class="s0">* important not to keep a GeomVertexWriter object around over a long period</span>
 <span class="s0">* of time in which the data buffer is likely to be deallocated; it is</span>
 <span class="s0">* intended for making a quick pass over the data in one session.</span>
 <span class="s0">*</span>
 <span class="s0">* It also means that you should create any GeomVertexWriters *before*</span>
 <span class="s0">* creating GeomVertexReaders on the same data, since the writer itself might</span>
 <span class="s0">* cause the vertex buffer to be deallocated.  Better yet, use a</span>
 <span class="s0">* GeomVertexRewriter if you are going to create both of them anyway.</span>
 <span class="s0">*/</span>

<span class="s0">3271 18 GeomVertexRewriter 0 26625 18 GeomVertexRewriter 18 GeomVertexRewriter 0 0 0 1 2495 2497 0 16 2496 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 0 0 2 3 3270 2491 2492 3 3269 2493 2494 0 0 628</span>
<span class="s0">/**</span>
 <span class="s0">* This object provides the functionality of both a GeomVertexReader and a</span>
 <span class="s0">* GeomVertexWriter, combined together into one convenient package.  It is</span>
 <span class="s0">* designed for making a single pass over a GeomVertexData object, modifying</span>
 <span class="s0">* rows as it goes.</span>
 <span class="s0">*</span>
 <span class="s0">* Although it doesn't provide any real performance benefit over using a</span>
 <span class="s0">* separate reader and writer on the same data, it should probably be used in</span>
 <span class="s0">* preference to a separate reader and writer, because it makes an effort to</span>
 <span class="s0">* manage the reference counts properly between the reader and the writer to</span>
 <span class="s0">* avoid accidentally dereferencing either array while recopying.</span>
 <span class="s0">*/</span>

<span class="s0">3272 12 SamplerState 0 141313 12 SamplerState 12 SamplerState 0 0 0 1 2513 2552 13 3758 3759 3760 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 38 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 0 0 0 0 2 3273 3274 176</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a set of settings that indicate how a texture is sampled.  This</span>
 <span class="s0">* can be used to sample the same texture using different settings in</span>
 <span class="s0">* different places.</span>
 <span class="s0">*/</span>

<span class="s0">3273 10 FilterType 0 794624 24 SamplerState::FilterType 24 SamplerState::FilterType 3272 0 0 0 0 0 0 0 0 0 9 10 FT_nearest 24 SamplerState::FT_nearest 25</span>
<span class="s0">// Point sample the pixel</span>
<span class="s0">0 9 FT_linear 23 SamplerState::FT_linear 48</span>
<span class="s0">// Bilinear filtering of four neighboring pixels</span>
<span class="s0">1 25 FT_nearest_mipmap_nearest 39 SamplerState::FT_nearest_mipmap_nearest 55</span>
<span class="s0">// Point sample the pixel from the nearest mipmap level</span>
<span class="s0">2 24 FT_linear_mipmap_nearest 38 SamplerState::FT_linear_mipmap_nearest 58</span>
<span class="s0">// Bilinear filter the pixel from the nearest mipmap level</span>
<span class="s0">3 24 FT_nearest_mipmap_linear 38 SamplerState::FT_nearest_mipmap_linear 68</span>
<span class="s0">// Point sample the pixel from two mipmap levels, and linearly blend</span>
<span class="s0">4 23 FT_linear_mipmap_linear 37 SamplerState::FT_linear_mipmap_linear 116</span>
<span class="s0">// A.k.a.  trilinear filtering: Bilinear filter the pixel from two mipmap</span>
<span class="s0">// levels, and linearly blend the results.</span>
<span class="s0">5 9 FT_shadow 23 SamplerState::FT_shadow 79</span>
<span class="s0">// The OpenGL ARB_shadow extension can be thought of as a kind of</span>
<span class="s0">// filtering.</span>
<span class="s0">6 10 FT_default 24 SamplerState::FT_default 129</span>
<span class="s0">// Default is usually linear, but it depends on format.  This was added at</span>
<span class="s0">// the end of the list to avoid bumping TXO version #.</span>
<span class="s0">7 10 FT_invalid 24 SamplerState::FT_invalid 57</span>
<span class="s0">// Returned by string_filter_type() for an invalid match.</span>
<span class="s0">8 0 0</span>

<span class="s0">3274 8 WrapMode 0 794624 22 SamplerState::WrapMode 22 SamplerState::WrapMode 3272 0 0 0 0 0 0 0 0 0 6 8 WM_clamp 22 SamplerState::WM_clamp 59</span>
<span class="s0">// coords that would be outside [0-1] are clamped to 0 or 1</span>
<span class="s0">0 9 WM_repeat 23 SamplerState::WM_repeat 0</span>
<span class="s0">1 9 WM_mirror 23 SamplerState::WM_mirror 0</span>
<span class="s0">2 14 WM_mirror_once 28 SamplerState::WM_mirror_once 26</span>
<span class="s0">// mirror once, then clamp</span>
<span class="s0">3 15 WM_border_color 29 SamplerState::WM_border_color 105</span>
<span class="s0">// coords outside [0-1] use explicit border color</span>
<span class="s0">// Returned by string_wrap_mode() for an invalid match.</span>
<span class="s0">4 10 WM_invalid 24 SamplerState::WM_invalid 105</span>
<span class="s0">// coords outside [0-1] use explicit border color</span>
<span class="s0">// Returned by string_wrap_mode() for an invalid match.</span>
<span class="s0">5 0 0</span>

<span class="s0">3275 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3248 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3276 7 Texture 0 26625 7 Texture 7 Texture 0 0 0 1 2557 2558 57 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 205 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 0 0 2 3 3180 2553 2554 3 3164 2555 2556 0 7 3277 3278 3279 3280 3281 3282 3283 688</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a texture object, which is typically a single 2-d image but may</span>
 <span class="s0">* also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube</span>
 <span class="s0">* map texture.</span>
 <span class="s0">*</span>
 <span class="s0">* A texture's image data might be stored in system RAM (see get_ram_image())</span>
 <span class="s0">* or its image may be represented in texture memory on one or more</span>
 <span class="s0">* GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern</span>
 <span class="s0">* is that a texture is loaded from an image file on disk, which copies its</span>
 <span class="s0">* image data into system RAM; then the first time the texture is rendered its</span>
 <span class="s0">* image data is copied to texture memory (actually, to the graphics API), and</span>
 <span class="s0">* the system RAM image is automatically freed.</span>
 <span class="s0">*/</span>

<span class="s0">3277 11 TextureType 0 794624 20 Texture::TextureType 20 Texture::TextureType 3276 0 0 0 0 0 0 0 0 0 8 13 TT_1d_texture 22 Texture::TT_1d_texture 0</span>
<span class="s0">0 13 TT_2d_texture 22 Texture::TT_2d_texture 0</span>
<span class="s0">1 13 TT_3d_texture 22 Texture::TT_3d_texture 0</span>
<span class="s0">2 19 TT_2d_texture_array 28 Texture::TT_2d_texture_array 0</span>
<span class="s0">3 11 TT_cube_map 20 Texture::TT_cube_map 0</span>
<span class="s0">4 17 TT_buffer_texture 26 Texture::TT_buffer_texture 0</span>
<span class="s0">5 17 TT_cube_map_array 26 Texture::TT_cube_map_array 0</span>
<span class="s0">6 19 TT_1d_texture_array 28 Texture::TT_1d_texture_array 0</span>
<span class="s0">7 0 0</span>

<span class="s0">3278 13 ComponentType 0 794624 22 Texture::ComponentType 22 Texture::ComponentType 3276 0 0 0 0 0 0 0 0 0 9 15 T_unsigned_byte 24 Texture::T_unsigned_byte 0</span>
<span class="s0">0 16 T_unsigned_short 25 Texture::T_unsigned_short 0</span>
<span class="s0">1 7 T_float 16 Texture::T_float 0</span>
<span class="s0">2 19 T_unsigned_int_24_8 28 Texture::T_unsigned_int_24_8 9</span>
<span class="s0">// Packed</span>
<span class="s0">3 5 T_int 14 Texture::T_int 0</span>
<span class="s0">4 6 T_byte 15 Texture::T_byte 0</span>
<span class="s0">5 7 T_short 16 Texture::T_short 0</span>
<span class="s0">6 12 T_half_float 21 Texture::T_half_float 0</span>
<span class="s0">7 14 T_unsigned_int 23 Texture::T_unsigned_int 0</span>
<span class="s0">8 0 0</span>

<span class="s0">3279 6 Format 0 794624 15 Texture::Format 15 Texture::Format 3276 0 0 0 0 0 0 0 0 0 52 15 F_depth_stencil 24 Texture::F_depth_stencil 0</span>
<span class="s0">1 13 F_color_index 22 Texture::F_color_index 0</span>
<span class="s0">2 5 F_red 14 Texture::F_red 0</span>
<span class="s0">3 7 F_green 16 Texture::F_green 0</span>
<span class="s0">4 6 F_blue 15 Texture::F_blue 0</span>
<span class="s0">5 7 F_alpha 16 Texture::F_alpha 0</span>
<span class="s0">6 5 F_rgb 14 Texture::F_rgb 55</span>
<span class="s0">// any suitable RGB mode, whatever the hardware prefers</span>
<span class="s0">7 6 F_rgb5 15 Texture::F_rgb5 27</span>
<span class="s0">// 5 bits per R,G,B channel</span>
<span class="s0">8 6 F_rgb8 15 Texture::F_rgb8 27</span>
<span class="s0">// 8 bits per R,G,B channel</span>
<span class="s0">9 7 F_rgb12 16 Texture::F_rgb12 28</span>
<span class="s0">// 12 bits per R,G,B channel</span>
<span class="s0">10 8 F_rgb332 17 Texture::F_rgb332 33</span>
<span class="s0">// 3 bits per R &amp; G, 2 bits for B</span>
<span class="s0">11 6 F_rgba 15 Texture::F_rgba 56</span>
<span class="s0">// any suitable RGBA mode, whatever the hardware prefers</span>
<span class="s0">12 6 F_rgbm 15 Texture::F_rgbm 58</span>
<span class="s0">// as above, but only requires 1 bit for alpha (i.e. mask)</span>
<span class="s0">13 7 F_rgba4 16 Texture::F_rgba4 29</span>
<span class="s0">// 4 bits per R,G,B,A channel</span>
<span class="s0">14 7 F_rgba5 16 Texture::F_rgba5 40</span>
<span class="s0">// 5 bits per R,G,B channel, 1 bit alpha</span>
<span class="s0">15 7 F_rgba8 16 Texture::F_rgba8 29</span>
<span class="s0">// 8 bits per R,G,B,A channel</span>
<span class="s0">16 8 F_rgba12 17 Texture::F_rgba12 30</span>
<span class="s0">// 12 bits per R,G,B,A channel</span>
<span class="s0">17 11 F_luminance 20 Texture::F_luminance 0</span>
<span class="s0">18 17 F_luminance_alpha 26 Texture::F_luminance_alpha 33</span>
<span class="s0">// 8 bits luminance, 8 bits alpha</span>
<span class="s0">19 21 F_luminance_alphamask 30 Texture::F_luminance_alphamask 46</span>
<span class="s0">// 8 bits luminance, only needs 1 bit of alpha</span>
<span class="s0">20 8 F_rgba16 17 Texture::F_rgba16 30</span>
<span class="s0">// 16 bits per R,G,B,A channel</span>
<span class="s0">21 8 F_rgba32 17 Texture::F_rgba32 30</span>
<span class="s0">// 32 bits per R,G,B,A channel</span>
<span class="s0">22 17 F_depth_component 26 Texture::F_depth_component 0</span>
<span class="s0">23 19 F_depth_component16 28 Texture::F_depth_component16 0</span>
<span class="s0">24 19 F_depth_component24 28 Texture::F_depth_component24 0</span>
<span class="s0">25 19 F_depth_component32 28 Texture::F_depth_component32 0</span>
<span class="s0">26 5 F_r16 14 Texture::F_r16 0</span>
<span class="s0">27 6 F_rg16 15 Texture::F_rg16 0</span>
<span class="s0">28 7 F_rgb16 16 Texture::F_rgb16 0</span>
<span class="s0">29 6 F_srgb 15 Texture::F_srgb 101</span>
<span class="s0">// These formats are in the sRGB color space.  RGB is 2.2 gamma corrected,</span>
<span class="s0">// alpha is always linear.</span>
<span class="s0">30 12 F_srgb_alpha 21 Texture::F_srgb_alpha 0</span>
<span class="s0">31 12 F_sluminance 21 Texture::F_sluminance 0</span>
<span class="s0">32 18 F_sluminance_alpha 27 Texture::F_sluminance_alpha 0</span>
<span class="s0">33 6 F_r32i 15 Texture::F_r32i 41</span>
<span class="s0">// 32-bit integer, used for atomic access</span>
<span class="s0">34 5 F_r32 14 Texture::F_r32 0</span>
<span class="s0">35 6 F_rg32 15 Texture::F_rg32 0</span>
<span class="s0">36 7 F_rgb32 16 Texture::F_rgb32 0</span>
<span class="s0">37 5 F_r8i 14 Texture::F_r8i 31</span>
<span class="s0">// 8 integer bits per R channel</span>
<span class="s0">38 6 F_rg8i 15 Texture::F_rg8i 33</span>
<span class="s0">// 8 integer bits per R,G channel</span>
<span class="s0">39 7 F_rgb8i 16 Texture::F_rgb8i 35</span>
<span class="s0">// 8 integer bits per R,G,B channel</span>
<span class="s0">40 8 F_rgba8i 17 Texture::F_rgba8i 37</span>
<span class="s0">// 8 integer bits per R,G,B,A channel</span>
<span class="s0">41 13 F_r11_g11_b10 22 Texture::F_r11_g11_b10 58</span>
<span class="s0">// unsigned floating-point, 11 Red, 11 Green, 10 Blue Bits</span>
<span class="s0">42 9 F_rgb9_e5 18 Texture::F_rgb9_e5 0</span>
<span class="s0">43 10 F_rgb10_a2 19 Texture::F_rgb10_a2 0</span>
<span class="s0">44 4 F_rg 13 Texture::F_rg 0</span>
<span class="s0">45 6 F_r16i 15 Texture::F_r16i 0</span>
<span class="s0">46 7 F_rg16i 16 Texture::F_rg16i 0</span>
<span class="s0">47 8 F_rgb16i 17 Texture::F_rgb16i 18</span>
<span class="s0">// not recommended</span>
<span class="s0">48 9 F_rgba16i 18 Texture::F_rgba16i 0</span>
<span class="s0">49 7 F_rg32i 16 Texture::F_rg32i 0</span>
<span class="s0">50 8 F_rgb32i 17 Texture::F_rgb32i 0</span>
<span class="s0">51 9 F_rgba32i 18 Texture::F_rgba32i 0</span>
<span class="s0">52 0 0</span>

<span class="s0">3280 20 DeprecatedFilterType 0 794624 29 Texture::DeprecatedFilterType 29 Texture::DeprecatedFilterType 3276 0 0 0 0 0 0 0 0 0 9 10 FT_nearest 19 Texture::FT_nearest 0</span>
<span class="s0">0 9 FT_linear 18 Texture::FT_linear 0</span>
<span class="s0">1 25 FT_nearest_mipmap_nearest 34 Texture::FT_nearest_mipmap_nearest 0</span>
<span class="s0">2 24 FT_linear_mipmap_nearest 33 Texture::FT_linear_mipmap_nearest 0</span>
<span class="s0">3 24 FT_nearest_mipmap_linear 33 Texture::FT_nearest_mipmap_linear 0</span>
<span class="s0">4 23 FT_linear_mipmap_linear 32 Texture::FT_linear_mipmap_linear 0</span>
<span class="s0">5 9 FT_shadow 18 Texture::FT_shadow 0</span>
<span class="s0">6 10 FT_default 19 Texture::FT_default 0</span>
<span class="s0">7 10 FT_invalid 19 Texture::FT_invalid 0</span>
<span class="s0">8 0 44</span>
<span class="s0">// Deprecated.  See SamplerState.FilterType.</span>

<span class="s0">3281 18 DeprecatedWrapMode 0 794624 27 Texture::DeprecatedWrapMode 27 Texture::DeprecatedWrapMode 3276 0 0 0 0 0 0 0 0 0 6 8 WM_clamp 17 Texture::WM_clamp 0</span>
<span class="s0">0 9 WM_repeat 18 Texture::WM_repeat 0</span>
<span class="s0">1 9 WM_mirror 18 Texture::WM_mirror 0</span>
<span class="s0">2 14 WM_mirror_once 23 Texture::WM_mirror_once 0</span>
<span class="s0">3 15 WM_border_color 24 Texture::WM_border_color 0</span>
<span class="s0">4 10 WM_invalid 19 Texture::WM_invalid 0</span>
<span class="s0">5 0 42</span>
<span class="s0">// Deprecated.  See SamplerState.WrapMode.</span>

<span class="s0">3282 15 CompressionMode 0 794624 24 Texture::CompressionMode 24 Texture::CompressionMode 3276 0 0 0 0 0 0 0 0 0 15 10 CM_default 19 Texture::CM_default 46</span>
<span class="s0">// on or off, according to compressed-textures</span>
<span class="s0">0 6 CM_off 15 Texture::CM_off 21</span>
<span class="s0">// uncompressed image</span>
<span class="s0">1 5 CM_on 14 Texture::CM_on 43</span>
<span class="s0">// whatever compression the driver supports</span>
<span class="s0">2 7 CM_fxt1 16 Texture::CM_fxt1 304</span>
<span class="s0">// Specific compression modes.  Use only when you really want to use a</span>
<span class="s0">// particular compression algorithm.  Use with caution; not all drivers</span>
<span class="s0">// support all compression modes.  You can use</span>
<span class="s0">// GSG::get_supports_compressed_texture_format() to query the available</span>
<span class="s0">// compression modes for a particular GSG.</span>
<span class="s0">3 7 CM_dxt1 16 Texture::CM_dxt1 39</span>
<span class="s0">// BC1: RGB with optional binary alpha.</span>
<span class="s0">4 7 CM_dxt2 16 Texture::CM_dxt2 45</span>
<span class="s0">// Like DXT3, but assumes premultiplied alpha</span>
<span class="s0">5 7 CM_dxt3 16 Texture::CM_dxt3 42</span>
<span class="s0">// BC2: RGB with uncompressed 4-bit alpha.</span>
<span class="s0">6 7 CM_dxt4 16 Texture::CM_dxt4 45</span>
<span class="s0">// Like DXT5, but assumes premultiplied alpha</span>
<span class="s0">7 7 CM_dxt5 16 Texture::CM_dxt5 51</span>
<span class="s0">// BC3: RGB with separately compressed 8-bit alpha.</span>
<span class="s0">8 12 CM_pvr1_2bpp 21 Texture::CM_pvr1_2bpp 0</span>
<span class="s0">9 12 CM_pvr1_4bpp 21 Texture::CM_pvr1_4bpp 0</span>
<span class="s0">10 7 CM_rgtc 16 Texture::CM_rgtc 53</span>
<span class="s0">// BC4/BC5: 1 or 2 channels, individually compressed.</span>
<span class="s0">11 7 CM_etc1 16 Texture::CM_etc1 0</span>
<span class="s0">12 7 CM_etc2 16 Texture::CM_etc2 0</span>
<span class="s0">13 6 CM_eac 15 Texture::CM_eac 24</span>
<span class="s0">// EAC: 1 or 2 channels.</span>
<span class="s0">14 0 0</span>

<span class="s0">3283 12 QualityLevel 0 794624 21 Texture::QualityLevel 21 Texture::QualityLevel 3276 0 0 0 0 0 0 0 0 0 4 10 QL_default 19 Texture::QL_default 37</span>
<span class="s0">// according to texture-quality-level</span>
<span class="s0">0 10 QL_fastest 19 Texture::QL_fastest 0</span>
<span class="s0">1 9 QL_normal 18 Texture::QL_normal 0</span>
<span class="s0">2 7 QL_best 16 Texture::QL_best 0</span>
<span class="s0">3 0 0</span>

<span class="s0">3284 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 3285 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3285 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">3286 18 SamplerState const 0 8832 18 SamplerState const 18 SamplerState const 0 0 3272 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3287 10 CPTA_uchar 0 2105344 10 CPTA_uchar 10 CPTA_uchar 0 0 3288 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3288 36 ConstPointerToArray&lt; unsigned char &gt; 0 2048 36 ConstPointerToArray&lt; unsigned char &gt; 36 ConstPointerToArray&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3289 16 AutoTextureScale 0 532480 16 AutoTextureScale 16 AutoTextureScale 0 0 0 0 0 0 0 0 0 0 5 8 ATS_none 8 ATS_none 0</span>
<span class="s0">0 8 ATS_down 8 ATS_down 0</span>
<span class="s0">1 6 ATS_up 6 ATS_up 0</span>
<span class="s0">2 7 ATS_pad 7 ATS_pad 0</span>
<span class="s0">3 15 ATS_unspecified 15 ATS_unspecified 0</span>
<span class="s0">4 0 0</span>

<span class="s0">3290 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 3291 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3291 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">3292 6 Shader 0 75777 6 Shader 6 Shader 0 0 0 1 2783 0 0 19 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 0 0 1 0 3180 0 0 0 4 3293 3294 3295 3296 8</span>
<span class="s0">/**</span>

 <span class="s0">*/</span>

<span class="s0">3293 14 ShaderLanguage 0 794624 22 Shader::ShaderLanguage 22 Shader::ShaderLanguage 3292 0 0 0 0 0 0 0 0 0 5 7 SL_none 15 Shader::SL_none 0</span>
<span class="s0">0 5 SL_Cg 13 Shader::SL_Cg 0</span>
<span class="s0">1 7 SL_GLSL 15 Shader::SL_GLSL 0</span>
<span class="s0">2 7 SL_HLSL 15 Shader::SL_HLSL 0</span>
<span class="s0">3 9 SL_SPIR_V 17 Shader::SL_SPIR_V 0</span>
<span class="s0">4 0 0</span>

<span class="s0">3294 10 ShaderType 0 794624 18 Shader::ShaderType 18 Shader::ShaderType 3292 0 0 0 0 0 0 0 0 0 8 7 ST_none 15 Shader::ST_none 0</span>
<span class="s0">0 9 ST_vertex 17 Shader::ST_vertex 0</span>
<span class="s0">1 11 ST_fragment 19 Shader::ST_fragment 0</span>
<span class="s0">2 11 ST_geometry 19 Shader::ST_geometry 0</span>
<span class="s0">3 15 ST_tess_control 23 Shader::ST_tess_control 0</span>
<span class="s0">4 18 ST_tess_evaluation 26 Shader::ST_tess_evaluation 0</span>
<span class="s0">5 10 ST_compute 18 Shader::ST_compute 0</span>
<span class="s0">6 8 ST_COUNT 16 Shader::ST_COUNT 0</span>
<span class="s0">7 0 0</span>

<span class="s0">3295 16 AutoShaderSwitch 0 794624 24 Shader::AutoShaderSwitch 24 Shader::AutoShaderSwitch 3292 0 0 0 0 0 0 0 0 0 5 9 AS_normal 17 Shader::AS_normal 0</span>
<span class="s0">1 7 AS_glow 15 Shader::AS_glow 0</span>
<span class="s0">2 8 AS_gloss 16 Shader::AS_gloss 0</span>
<span class="s0">4 7 AS_ramp 15 Shader::AS_ramp 0</span>
<span class="s0">8 9 AS_shadow 17 Shader::AS_shadow 0</span>
<span class="s0">16 0 0</span>

<span class="s0">3296 13 AutoShaderBit 0 794624 21 Shader::AutoShaderBit 21 Shader::AutoShaderBit 3292 0 0 0 0 0 0 0 0 0 5 20 bit_AutoShaderNormal 28 Shader::bit_AutoShaderNormal 20</span>
<span class="s0">// bit for AS_normal</span>
<span class="s0">0 18 bit_AutoShaderGlow 26 Shader::bit_AutoShaderGlow 18</span>
<span class="s0">// bit for AS_glow</span>
<span class="s0">1 19 bit_AutoShaderGloss 27 Shader::bit_AutoShaderGloss 19</span>
<span class="s0">// bit for AS_gloss</span>
<span class="s0">2 18 bit_AutoShaderRamp 26 Shader::bit_AutoShaderRamp 18</span>
<span class="s0">// bit for AS_ramp</span>
<span class="s0">3 20 bit_AutoShaderShadow 28 Shader::bit_AutoShaderShadow 20</span>
<span class="s0">// bit for AS_shadow</span>
<span class="s0">4 0 0</span>

<span class="s0">3297 12 ShaderBuffer 0 26625 12 ShaderBuffer 12 ShaderBuffer 0 0 0 1 2791 2790 2 3828 3829 6 2794 2795 2796 2797 2798 2799 0 0 3 3 3180 2784 2785 3 3164 2786 2787 3 3168 2788 2789 0 0 93</span>
<span class="s0">/**</span>
 <span class="s0">* This is a generic buffer object that lives in graphics memory.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">3298 8 uint64_t 0 2105344 8 uint64_t 8 uint64_t 0 0 3210 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3299 23 PreparedGraphicsObjects 0 75777 23 PreparedGraphicsObjects 23 PreparedGraphicsObjects 0 0 0 0 0 0 71 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 0 0 1 0 3206 0 0 0 0 658</span>
<span class="s0">/**</span>
 <span class="s0">* A table of objects that are saved within the graphics context for reference</span>
 <span class="s0">* by handle later.  Generally, this represents things like OpenGL texture</span>
 <span class="s0">* objects or display lists (or their equivalent on other platforms).</span>
 <span class="s0">*</span>
 <span class="s0">* This object simply records the pointers to the context objects created by</span>
 <span class="s0">* the individual GSG's; these context objects will contain enough information</span>
 <span class="s0">* to reference or release the actual object stored within the graphics</span>
 <span class="s0">* context.</span>
 <span class="s0">*</span>
 <span class="s0">* These tables may potentially be shared between related graphics contexts,</span>
 <span class="s0">* hence their storage here in a separate object rather than as a part of the</span>
 <span class="s0">* GraphicsStateGuardian.</span>
 <span class="s0">*/</span>

<span class="s0">3300 18 IndexBufferContext 0 141313 18 IndexBufferContext 18 IndexBufferContext 0 0 0 0 2880 0 5 2875 2876 2877 2878 2879 0 0 2 3 3240 2871 2872 3 3165 2873 2874 0 0 366</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special class object that holds all the information returned by a</span>
 <span class="s0">* particular GSG to indicate the vertex data array's internal context</span>
 <span class="s0">* identifier.</span>
 <span class="s0">*</span>
 <span class="s0">* This allows the GSG to cache the vertex data array in whatever way makes</span>
 <span class="s0">* sense.  For instance, DirectX can allocate a vertex buffer for the array.</span>
 <span class="s0">* OpenGL can create a buffer object.</span>
 <span class="s0">*/</span>

<span class="s0">3301 4 Lens 0 141313 4 Lens 4 Lens 0 0 0 0 2948 16 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 67 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 0 0 1 0 3180 0 0 0 2 3302 3318 398</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for any number of different kinds of lenses, linear and</span>
 <span class="s0">* otherwise.  Presently, this includes perspective and orthographic lenses.</span>
 <span class="s0">*</span>
 <span class="s0">* A Lens object is the main part of a Camera node, which defines the</span>
 <span class="s0">* fundamental interface to point-of-view for rendering.  Lenses are also used</span>
 <span class="s0">* in other contexts, however; for instance, a Spotlight is also defined using</span>
 <span class="s0">* a lens.</span>
 <span class="s0">*/</span>

<span class="s0">3302 13 StereoChannel 0 794624 19 Lens::StereoChannel 19 Lens::StereoChannel 3301 0 0 0 0 0 0 0 0 0 4 7 SC_mono 13 Lens::SC_mono 0</span>
<span class="s0">0 7 SC_left 13 Lens::SC_left 0</span>
<span class="s0">1 8 SC_right 14 Lens::SC_right 0</span>
<span class="s0">2 9 SC_stereo 15 Lens::SC_stereo 24</span>
<span class="s0">// == SC_left | SC_right</span>
<span class="s0">3 0 0</span>

<span class="s0">3303 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210</span>
<span class="s0">// The CS_default entry does not refer to a particular coordinate system,</span>
<span class="s0">// but rather to the value stored in default_coordinate_system, which in</span>
<span class="s0">// turn is loaded from the config variable &quot;coordinate-system&quot;.</span>
<span class="s0">0 12 CS_zup_right 12 CS_zup_right 21</span>
<span class="s0">// Z-Up, Right-handed</span>
<span class="s0">1 12 CS_yup_right 12 CS_yup_right 21</span>
<span class="s0">// Y-Up, Right-handed</span>
<span class="s0">2 11 CS_zup_left 11 CS_zup_left 20</span>
<span class="s0">// Z-Up, Left-handed</span>
<span class="s0">3 11 CS_yup_left 11 CS_yup_left 20</span>
<span class="s0">// Y-Up, Left-handed</span>
<span class="s0">4 10 CS_invalid 10 CS_invalid 156</span>
<span class="s0">// CS_invalid is not a coordinate system at all.  It can be used in user-</span>
<span class="s0">// input processing code to indicate a contradictory coordinate system</span>
<span class="s0">// request.</span>
<span class="s0">5 0 0</span>

<span class="s0">3304 15 LVecBase2 const 0 8832 15 LVecBase2 const 15 LVecBase2 const 0 0 3305 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3305 9 LVecBase2 0 2105344 9 LVecBase2 9 LVecBase2 0 0 3306 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3306 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3307 14 LVector2 const 0 8832 14 LVector2 const 14 LVector2 const 0 0 3308 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3308 8 LVector2 0 2105344 8 LVector2 8 LVector2 0 0 3309 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3309 9 LVector2f 0 2048 9 LVector2f 9 LVector2f 0 0 0 0 0 0 0 0 0 0 0 0 49</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component vector offset.</span>
 <span class="s0">*/</span>

<span class="s0">3310 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 3311 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3311 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 3312 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3312 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3313 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 3314 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3314 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3315 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 3316 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3316 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 3317 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3317 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3318 11 FromCorners 0 794624 17 Lens::FromCorners 17 Lens::FromCorners 3301 0 0 0 0 0 0 0 0 0 6 7 FC_roll 13 Lens::FC_roll 0</span>
<span class="s0">1 15 FC_camera_plane 21 Lens::FC_camera_plane 0</span>
<span class="s0">2 11 FC_off_axis 17 Lens::FC_off_axis 0</span>
<span class="s0">4 15 FC_aspect_ratio 21 Lens::FC_aspect_ratio 0</span>
<span class="s0">8 8 FC_shear 14 Lens::FC_shear 0</span>
<span class="s0">16 11 FC_keystone 17 Lens::FC_keystone 0</span>
<span class="s0">32 0 183</span>
<span class="s0">// These flags are passed in as the last parameter to control the behavior</span>
<span class="s0">// of set_frustum_from_corners().  See the documentation for that method for</span>
<span class="s0">// an explanation of each flag.</span>

<span class="s0">3319 8 Material 0 26625 8 Material 8 Material 0 0 0 1 2953 2955 11 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 47 2954 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 0 0 2 3 3180 2949 2950 3 3164 2951 2952 0 0 682</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the way an object appears in the presence of lighting.  A material</span>
 <span class="s0">* is only necessary if lighting is to be enabled; otherwise, the material</span>
 <span class="s0">* isn't used.</span>
 <span class="s0">*</span>
 <span class="s0">* There are two workflows that are supported: the &quot;classic&quot; workflow of</span>
 <span class="s0">* providing separate ambient, diffuse and specular colors, and the</span>
 <span class="s0">* &quot;metalness&quot; workflow, in which a base color is specified along with a</span>
 <span class="s0">* &quot;metallic&quot; value that indicates whether the material is a metal or a</span>
 <span class="s0">* dielectric.</span>
 <span class="s0">*</span>
 <span class="s0">* The size of the specular highlight can be specified by either specifying</span>
 <span class="s0">* the specular exponent (shininess) or by specifying a roughness value that</span>
 <span class="s0">* in perceptually linear in the range of 0-1.</span>
 <span class="s0">*/</span>

<span class="s0">3320 12 MaterialPool 0 141313 12 MaterialPool 12 MaterialPool 0 0 0 0 3008 0 6 3002 3003 3004 3005 3006 3007 0 0 0 0 0 661</span>
<span class="s0">/**</span>
 <span class="s0">* The MaterialPool (there is only one in the universe) serves to unify</span>
 <span class="s0">* different pointers to the same Material, so we do not (a) waste memory with</span>
 <span class="s0">* many different Material objects that are all equivalent, and (b) waste time</span>
 <span class="s0">* switching the graphics engine between different Material states that are</span>
 <span class="s0">* really the same thing.</span>
 <span class="s0">*</span>
 <span class="s0">* The idea is to create a temporary Material representing the lighting state</span>
 <span class="s0">* you want to apply, then call get_material(), passing in your temporary</span>
 <span class="s0">* Material.  The return value will either be a new Material object, or it may</span>
 <span class="s0">* be the the same object you supplied; in either case, it will have the same</span>
 <span class="s0">* value.</span>
 <span class="s0">*/</span>

<span class="s0">3321 10 MatrixLens 0 141313 10 MatrixLens 10 MatrixLens 0 0 0 1 3009 3021 1 3857 11 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 0 0 1 0 3301 0 0 0 0 274</span>
<span class="s0">/**</span>
 <span class="s0">* A completely generic linear lens.  This is provided for the benefit of low-</span>
 <span class="s0">* level code that wants to specify a perspective or orthographic frustum via</span>
 <span class="s0">* an explicit projection matrix, but not mess around with fov's or focal</span>
 <span class="s0">* lengths or any of that nonsense.</span>
 <span class="s0">*/</span>

<span class="s0">3322 16 OrthographicLens 0 141313 16 OrthographicLens 16 OrthographicLens 0 0 0 1 3022 3024 0 1 3023 0 0 1 0 3301 0 0 0 0 400</span>
<span class="s0">/**</span>
 <span class="s0">* An orthographic lens.  Although this kind of lens is linear, like a</span>
 <span class="s0">* PerspectiveLens, it doesn't respect field-of-view or focal length</span>
 <span class="s0">* parameters, and adjusting these will have no effect.  Instead, its field of</span>
 <span class="s0">* view is controlled by adjusting the film_size; the orthographic lens</span>
 <span class="s0">* represents a planar projection onto its imaginary film of the specified</span>
 <span class="s0">* size, hanging in space.</span>
 <span class="s0">*/</span>

<span class="s0">3323 19 ParamTextureSampler 0 141313 19 ParamTextureSampler 19 ParamTextureSampler 0 0 0 1 3025 3029 2 3858 3859 3 3026 3027 3028 0 0 1 0 3324 0 0 0 0 141</span>
<span class="s0">/**</span>
 <span class="s0">* A class object for storing a pointer to a Texture along with a sampler</span>
 <span class="s0">* state that indicates how to to sample the given texture.</span>
 <span class="s0">*/</span>

<span class="s0">3324 14 ParamValueBase 0 2048 14 ParamValueBase 14 ParamValueBase 0 0 0 0 0 0 0 0 0 0 0 0 141</span>
<span class="s0">/**</span>
 <span class="s0">* A non-template base class of ParamValue (below), which serves mainly to</span>
 <span class="s0">* define the placeholder for the virtual output function.</span>
 <span class="s0">*/</span>

<span class="s0">3325 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 3276 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3326 17 ParamTextureImage 0 141313 17 ParamTextureImage 17 ParamTextureImage 0 0 0 1 3030 3038 5 3860 3861 3862 3863 3864 7 3031 3032 3033 3034 3035 3036 3037 0 0 1 0 3324 0 0 0 0 254</span>
<span class="s0">/**</span>
 <span class="s0">* A class object for storing a pointer to a Texture along with a set of</span>
 <span class="s0">* properties that indicates which image to bind to a shader input.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is useful for binding texture images to a shader, which is a</span>
 <span class="s0">* fairly esoteric feature.</span>
 <span class="s0">*/</span>

<span class="s0">3327 15 PerspectiveLens 0 141313 15 PerspectiveLens 15 PerspectiveLens 0 0 0 1 3039 3041 0 1 3040 0 0 1 0 3301 0 0 0 0 52</span>
<span class="s0">/**</span>
 <span class="s0">* A perspective-type lens: a normal camera.</span>
 <span class="s0">*/</span>

<span class="s0">3328 20 TextureReloadRequest 0 141313 20 TextureReloadRequest 20 TextureReloadRequest 0 0 0 1 3042 3048 1 3865 5 3043 3044 3045 3046 3047 0 0 1 0 3237 0 0 0 0 245</span>
<span class="s0">/**</span>
 <span class="s0">* This loader request will call Texture::get_ram_image() in a sub-thread, to</span>
 <span class="s0">* force the texture's image to be re-read from disk.  It is used by</span>
 <span class="s0">* GraphicsStateGuardian::async_reload_texture(), when get_incomplete_render()</span>
 <span class="s0">* is true.</span>
 <span class="s0">*/</span>

<span class="s0">3329 14 TextureContext 0 141313 14 TextureContext 14 TextureContext 0 0 0 0 3065 0 12 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 0 0 2 3 3240 3049 3050 3 3165 3051 3052 0 0 449</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special class object that holds all the information returned by a</span>
 <span class="s0">* particular GSG to indicate the texture's internal context identifier.</span>
 <span class="s0">*</span>
 <span class="s0">* Textures typically have an immediate-mode and a retained-mode operation.</span>
 <span class="s0">* When using textures in retained-mode (in response to Texture::prepare()),</span>
 <span class="s0">* the GSG will create some internal handle for the texture and store it here.</span>
 <span class="s0">* The texture stores all of these handles internally.</span>
 <span class="s0">*/</span>

<span class="s0">3330 13 ShaderContext 0 141313 13 ShaderContext 13 ShaderContext 0 0 0 0 3068 1 3866 2 3066 3067 0 0 1 0 3238 0 0 0 0 0</span>

<span class="s0">3331 8 Shader * 0 8576 8 Shader * 8 Shader * 0 0 3292 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3332 16 UserVertexSlider 0 141313 16 UserVertexSlider 16 UserVertexSlider 0 0 0 1 3069 3072 0 2 3070 3071 0 0 1 0 3226 0 0 0 0 167</span>
<span class="s0">/**</span>
 <span class="s0">* This is a specialization on VertexSlider that allows the user to specify</span>
 <span class="s0">* any arbitrary slider valie he likes.  This is rarely used except for</span>
 <span class="s0">* testing.</span>
 <span class="s0">*/</span>

<span class="s0">3333 19 UserVertexTransform 0 141313 19 UserVertexTransform 19 UserVertexTransform 0 0 0 1 3073 3077 0 3 3074 3075 3076 0 0 1 0 3215 0 0 0 0 174</span>
<span class="s0">/**</span>
 <span class="s0">* This is a specialization on VertexTransform that allows the user to specify</span>
 <span class="s0">* any arbitrary transform matrix he likes.  This is rarely used except for</span>
 <span class="s0">* testing.</span>
 <span class="s0">*/</span>

<span class="s0">3334 12 VideoTexture 0 141313 12 VideoTexture 12 VideoTexture 0 0 0 0 3086 2 3867 3868 4 3082 3083 3084 3085 0 0 2 3 3276 3078 3079 3 3335 3080 3081 0 0 248</span>
<span class="s0">/**</span>
 <span class="s0">* The base class for a family of animated Textures that take their input from</span>
 <span class="s0">* a video source, such as a movie file.  These Textures may be stopped,</span>
 <span class="s0">* started, etc.  using the AnimInterface controls, similar to an animated</span>
 <span class="s0">* character.</span>
 <span class="s0">*/</span>

<span class="s0">3335 13 AnimInterface 0 2048 13 AnimInterface 13 AnimInterface 0 0 0 0 0 0 0 0 0 0 0 0 226</span>
<span class="s0">/**</span>
 <span class="s0">* This is the fundamental interface for things that have a play/loop/stop</span>
 <span class="s0">* type interface for frame-based animation, such as animated characters.</span>
 <span class="s0">* This is the base class for AnimControl and other, similar classes.</span>
 <span class="s0">*/</span>

<span class="s0">3336 19 VertexBufferContext 0 141313 19 VertexBufferContext 19 VertexBufferContext 0 0 0 0 3096 0 5 3091 3092 3093 3094 3095 0 0 2 3 3240 3087 3088 3 3165 3089 3090 0 0 366</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special class object that holds all the information returned by a</span>
 <span class="s0">* particular GSG to indicate the vertex data array's internal context</span>
 <span class="s0">* identifier.</span>
 <span class="s0">*</span>
 <span class="s0">* This allows the GSG to cache the vertex data array in whatever way makes</span>
 <span class="s0">* sense.  For instance, DirectX can allocate a vertex buffer for the array.</span>
 <span class="s0">* OpenGL can create a buffer object.</span>
 <span class="s0">*/</span>

<span class="s0">3337 17 TextureCollection 0 26625 17 TextureCollection 17 TextureCollection 0 0 0 1 3097 3099 0 21 3098 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 1 3886 0 0 0 0 97</span>
<span class="s0">/**</span>
 <span class="s0">* Manages a list of Texture objects, as returned by</span>
 <span class="s0">* TexturePool::find_all_textures().</span>
 <span class="s0">*/</span>

<span class="s0">3338 11 TexturePool 0 141313 11 TexturePool 11 TexturePool 0 0 0 0 3143 0 23 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 0 0 0 0 0 235</span>
<span class="s0">/**</span>
 <span class="s0">* This is the preferred interface for loading textures from image files.  It</span>
 <span class="s0">* unifies all references to the same filename, so that multiple models that</span>
 <span class="s0">* reference the same textures don't waste texture memory unnecessarily.</span>
 <span class="s0">*/</span>

<span class="s0">3339 13 TexturePeeker 0 141313 13 TexturePeeker 13 TexturePeeker 0 0 0 1 3152 3153 0 8 3144 3145 3146 3147 3148 3149 3150 3151 0 0 1 0 3206 0 0 0 0 166</span>
<span class="s0">/**</span>
 <span class="s0">* An instance of this object is returned by Texture::peek().  This object</span>
 <span class="s0">* allows quick and easy inspection of a texture's texels by (u, v)</span>
 <span class="s0">* coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">3340 16 TextureStagePool 0 141313 16 TextureStagePool 16 TextureStagePool 0 0 0 0 3162 1 3869 8 3154 3155 3156 3157 3158 3159 3160 3161 0 0 0 0 1 3341 359</span>
<span class="s0">/**</span>
 <span class="s0">* The TextureStagePool (there is only one in the universe) serves to unify</span>
 <span class="s0">* different pointers to the same TextureStage, mainly to help developers use</span>
 <span class="s0">* a common pointer to access things that are loaded from different model</span>
 <span class="s0">* files.</span>
 <span class="s0">*</span>
 <span class="s0">* It runs in one of three different modes, according to set_mode().  See that</span>
 <span class="s0">* method for more information.</span>
 <span class="s0">*/</span>

<span class="s0">3341 4 Mode 0 794624 22 TextureStagePool::Mode 22 TextureStagePool::Mode 3340 0 0 0 0 0 0 0 0 0 3 6 M_none 24 TextureStagePool::M_none 0</span>
<span class="s0">0 6 M_name 24 TextureStagePool::M_name 0</span>
<span class="s0">1 8 M_unique 26 TextureStagePool::M_unique 0</span>
<span class="s0">2 0 0</span>

<span class="s0">3342 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3343 13 AdaptiveLru * 0 8576 13 AdaptiveLru * 13 AdaptiveLru * 0 0 3163 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3344 19 AdaptiveLru const * 0 8576 19 AdaptiveLru const * 19 AdaptiveLru const * 0 0 3345 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3345 17 AdaptiveLru const 0 8832 17 AdaptiveLru const 17 AdaptiveLru const 0 0 3163 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3346 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3347 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3348 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3348 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3349 23 AdaptiveLruPage const * 0 8576 23 AdaptiveLruPage const * 23 AdaptiveLruPage const * 0 0 3350 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3350 21 AdaptiveLruPage const 0 8832 21 AdaptiveLruPage const 21 AdaptiveLruPage const 0 0 3165 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3351 17 AdaptiveLruPage * 0 8576 17 AdaptiveLruPage * 17 AdaptiveLruPage * 0 0 3165 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3352 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3353 11 GeomEnums * 0 8576 11 GeomEnums * 11 GeomEnums * 0 0 3168 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3354 17 GeomEnums const * 0 8576 17 GeomEnums const * 17 GeomEnums const * 0 0 3355 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3355 15 GeomEnums const 0 8832 15 GeomEnums const 15 GeomEnums const 0 0 3168 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3356 25 GeomVertexAnimationSpec * 0 8576 25 GeomVertexAnimationSpec * 25 GeomVertexAnimationSpec * 0 0 3176 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3357 31 GeomVertexAnimationSpec const * 0 8576 31 GeomVertexAnimationSpec const * 31 GeomVertexAnimationSpec const * 0 0 3190 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3358 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3359 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3359 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3360 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3360 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3361 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">3362 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3361 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3363 18 GeomVertexColumn * 0 8576 18 GeomVertexColumn * 18 GeomVertexColumn * 0 0 3185 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3364 23 GeomVertexArrayFormat * 0 8576 23 GeomVertexArrayFormat * 23 GeomVertexArrayFormat * 0 0 3186 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3365 27 GeomVertexArrayData const * 0 8576 27 GeomVertexArrayData const * 27 GeomVertexArrayData const * 0 0 3366 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3366 25 GeomVertexArrayData const 0 8832 25 GeomVertexArrayData const 25 GeomVertexArrayData const 0 0 3207 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3367 18 GeomVertexFormat * 0 8576 18 GeomVertexFormat * 18 GeomVertexFormat * 0 0 3189 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3368 22 GeomVertexData const * 0 8576 22 GeomVertexData const * 22 GeomVertexData const * 0 0 3369 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3369 20 GeomVertexData const 0 8832 20 GeomVertexData const 20 GeomVertexData const 0 0 3228 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3370 11 SimpleLru * 0 8576 11 SimpleLru * 11 SimpleLru * 0 0 3195 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3371 17 SimpleLru const * 0 8576 17 SimpleLru const * 17 SimpleLru const * 0 0 3372 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3372 15 SimpleLru const 0 8832 15 SimpleLru const 15 SimpleLru const 0 0 3195 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3373 16 LinkedListNode * 0 8576 16 LinkedListNode * 16 LinkedListNode * 0 0 3196 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3374 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 3164 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3375 21 SimpleLruPage const * 0 8576 21 SimpleLruPage const * 21 SimpleLruPage const * 0 0 3376 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3376 19 SimpleLruPage const 0 8832 19 SimpleLruPage const 19 SimpleLruPage const 0 0 3197 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3377 15 SimpleLruPage * 0 8576 15 SimpleLruPage * 15 SimpleLruPage * 0 0 3197 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3378 7 Mutex * 0 8576 7 Mutex * 7 Mutex * 0 0 3379 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3379 5 Mutex 0 2048 5 Mutex 5 Mutex 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3380 17 SimpleAllocator * 0 8576 17 SimpleAllocator * 17 SimpleAllocator * 0 0 3198 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3381 22 SimpleAllocatorBlock * 0 8576 22 SimpleAllocatorBlock * 22 SimpleAllocatorBlock * 0 0 3199 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3382 23 SimpleAllocator const * 0 8576 23 SimpleAllocator const * 23 SimpleAllocator const * 0 0 3383 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3383 21 SimpleAllocator const 0 8832 21 SimpleAllocator const 21 SimpleAllocator const 0 0 3198 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3384 28 SimpleAllocatorBlock const * 0 8576 28 SimpleAllocatorBlock const * 28 SimpleAllocatorBlock const * 0 0 3385 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3385 26 SimpleAllocatorBlock const 0 8832 26 SimpleAllocatorBlock const 26 SimpleAllocatorBlock const 0 0 3199 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3386 26 VertexDataSaveFile const * 0 8576 26 VertexDataSaveFile const * 26 VertexDataSaveFile const * 0 0 3387 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3387 24 VertexDataSaveFile const 0 8832 24 VertexDataSaveFile const 24 VertexDataSaveFile const 0 0 3200 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3388 22 VertexDataPage const * 0 8576 22 VertexDataPage const * 22 VertexDataPage const * 0 0 3389 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3389 20 VertexDataPage const 0 8832 20 VertexDataPage const 20 VertexDataPage const 0 0 3201 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3390 16 VertexDataPage * 0 8576 16 VertexDataPage * 16 VertexDataPage * 0 0 3201 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3391 17 VertexDataBlock * 0 8576 17 VertexDataBlock * 17 VertexDataBlock * 0 0 3205 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3392 16 VertexDataBook * 0 8576 16 VertexDataBook * 16 VertexDataBook * 0 0 3204 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3393 22 VertexDataBook const * 0 8576 22 VertexDataBook const * 22 VertexDataBook const * 0 0 3394 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3394 20 VertexDataBook const 0 8832 20 VertexDataBook const 20 VertexDataBook const 0 0 3204 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3395 23 VertexDataBlock const * 0 8576 23 VertexDataBlock const * 23 VertexDataBlock const * 0 0 3396 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3396 21 VertexDataBlock const 0 8832 21 VertexDataBlock const 21 VertexDataBlock const 0 0 3205 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3397 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 3206 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3398 11 UpdateSeq * 0 8576 11 UpdateSeq * 11 UpdateSeq * 0 0 3211 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3399 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 3400 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3400 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 396</span>
<span class="s0">/**</span>
 <span class="s0">* A thread; that is, a lightweight process.  This is an abstract base class;</span>
 <span class="s0">* to use it, you must subclass from it and redefine thread_main().</span>
 <span class="s0">*</span>
 <span class="s0">* The thread itself will keep a reference count on the Thread object while it</span>
 <span class="s0">* is running; when the thread returns from its root function, the Thread</span>
 <span class="s0">* object will automatically be destructed if no other pointers are</span>
 <span class="s0">* referencing it.</span>
 <span class="s0">*/</span>

<span class="s0">3401 31 GeomVertexArrayDataHandle const 0 8832 31 GeomVertexArrayDataHandle const 31 GeomVertexArrayDataHandle const 0 0 3212 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3402 33 GeomVertexArrayDataHandle const * 0 8576 33 GeomVertexArrayDataHandle const * 33 GeomVertexArrayDataHandle const * 0 0 3401 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3403 27 GeomVertexArrayDataHandle * 0 8576 27 GeomVertexArrayDataHandle * 27 GeomVertexArrayDataHandle * 0 0 3212 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3404 25 PreparedGraphicsObjects * 0 8576 25 PreparedGraphicsObjects * 25 PreparedGraphicsObjects * 0 0 3299 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3405 27 GraphicsStateGuardianBase * 0 8576 27 GraphicsStateGuardianBase * 27 GraphicsStateGuardianBase * 0 0 3406 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3406 25 GraphicsStateGuardianBase 0 2048 25 GraphicsStateGuardianBase 25 GraphicsStateGuardianBase 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3407 21 VertexBufferContext * 0 8576 21 VertexBufferContext * 21 VertexBufferContext * 0 0 3336 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3408 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 3409 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3409 9 Py_buffer 0 2105344 9 Py_buffer 9 Py_buffer 0 0 3410 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3410 10 bufferinfo 0 1024 10 bufferinfo 10 bufferinfo 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3411 19 CopyOnWriteObject * 0 8576 19 CopyOnWriteObject * 19 CopyOnWriteObject * 0 0 3208 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3412 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 3413 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3413 24 pvector&lt; unsigned char &gt; 0 2048 24 pvector&lt; unsigned char &gt; 24 pvector&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3414 24 GeomCacheManager const * 0 8576 24 GeomCacheManager const * 24 GeomCacheManager const * 0 0 3415 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3415 22 GeomCacheManager const 0 8832 22 GeomCacheManager const 22 GeomCacheManager const 0 0 3214 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3416 18 GeomCacheManager * 0 8576 18 GeomCacheManager * 18 GeomCacheManager * 0 0 3214 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3417 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 3316 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3418 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 3315 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3419 16 TransformTable * 0 8576 16 TransformTable * 16 TransformTable * 0 0 3216 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3420 16 TransformBlend * 0 8576 16 TransformBlend * 16 TransformBlend * 0 0 3219 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3421 22 TransformBlend const * 0 8576 22 TransformBlend const * 22 TransformBlend const * 0 0 3223 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3422 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3423 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3423 8 LPoint3d 0 2048 8 LPoint3d 8 LPoint3d 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3424 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3314 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3425 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3426 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3426 8 LPoint4d 0 2048 8 LPoint4d 8 LPoint4d 0 0 0 0 0 0 0 0 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3427 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3428 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3428 8 LPoint4f 0 2048 8 LPoint4f 8 LPoint4f 0 0 0 0 0 0 0 0 0 0 0 0 51</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3429 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3430 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3430 9 LVector3d 0 2048 9 LVector3d 9 LVector3d 0 0 0 0 0 0 0 0 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3431 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3432 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3432 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3433 21 TransformBlendTable * 0 8576 21 TransformBlendTable * 21 TransformBlendTable * 0 0 3222 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3434 27 TransformBlendTable const * 0 8576 27 TransformBlendTable const * 27 TransformBlendTable const * 0 0 3435 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3435 25 TransformBlendTable const 0 8832 25 TransformBlendTable const 25 TransformBlendTable const 0 0 3222 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3436 19 SparseArray const * 0 8576 19 SparseArray const * 19 SparseArray const * 0 0 3224 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3437 13 SparseArray * 0 8576 13 SparseArray * 13 SparseArray * 0 0 3225 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3438 20 VertexSlider const * 0 8576 20 VertexSlider const * 20 VertexSlider const * 0 0 3439 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3439 18 VertexSlider const 0 8832 18 VertexSlider const 18 VertexSlider const 0 0 3226 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3440 13 SliderTable * 0 8576 13 SliderTable * 13 SliderTable * 0 0 3227 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3441 16 GeomVertexData * 0 8576 16 GeomVertexData * 16 GeomVertexData * 0 0 3228 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3442 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 3443 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3443 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 3444 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3444 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 3250 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3445 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3275 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3446 30 AnimateVerticesRequest const * 0 8576 30 AnimateVerticesRequest const * 30 AnimateVerticesRequest const * 0 0 3447 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3447 28 AnimateVerticesRequest const 0 8832 28 AnimateVerticesRequest const 28 AnimateVerticesRequest const 0 0 3236 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3448 24 AnimateVerticesRequest * 0 8576 24 AnimateVerticesRequest * 24 AnimateVerticesRequest * 0 0 3236 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3449 21 BufferContext const * 0 8576 21 BufferContext const * 21 BufferContext const * 0 0 3450 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3450 19 BufferContext const 0 8832 19 BufferContext const 19 BufferContext const 0 0 3240 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3451 15 BufferContext * 0 8576 15 BufferContext * 15 BufferContext * 0 0 3240 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3452 14 SavedContext * 0 8576 14 SavedContext * 14 SavedContext * 0 0 3238 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3453 15 GeomPrimitive * 0 8576 15 GeomPrimitive * 15 GeomPrimitive * 0 0 3242 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3454 21 GeomPrimitive const * 0 8576 21 GeomPrimitive const * 21 GeomPrimitive const * 0 0 3455 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3455 19 GeomPrimitive const 0 8832 19 GeomPrimitive const 19 GeomPrimitive const 0 0 3242 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3456 36 GeomVertexDataPipelineReader const * 0 8576 36 GeomVertexDataPipelineReader const * 36 GeomVertexDataPipelineReader const * 0 0 3457 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3457 34 GeomVertexDataPipelineReader const 0 8832 34 GeomVertexDataPipelineReader const 34 GeomVertexDataPipelineReader const 0 0 3458 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3458 28 GeomVertexDataPipelineReader 0 1050624 28 GeomVertexDataPipelineReader 28 GeomVertexDataPipelineReader 0 0 0 0 0 0 0 0 0 0 0 0 198</span>
<span class="s0">/**</span>
 <span class="s0">* Encapsulates the data from a GeomVertexData, pre-fetched for one stage of</span>
 <span class="s0">* the pipeline.</span>
 <span class="s0">* Does not hold a reference to the GeomVertexData, so make sure it does not</span>
 <span class="s0">* go out of scope.</span>
 <span class="s0">*/</span>

<span class="s0">3459 8 CPTA_int 0 2105344 8 CPTA_int 8 CPTA_int 0 0 3460 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3460 26 ConstPointerToArray&lt; int &gt; 0 2048 26 ConstPointerToArray&lt; int &gt; 26 ConstPointerToArray&lt; int &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3461 10 CPTA_int * 0 8576 10 CPTA_int * 10 CPTA_int * 0 0 3459 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3462 7 PTA_int 0 2105344 7 PTA_int 7 PTA_int 0 0 3463 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3463 21 PointerToArray&lt; int &gt; 0 2048 21 PointerToArray&lt; int &gt; 21 PointerToArray&lt; int &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3464 9 PTA_int * 0 8576 9 PTA_int * 9 PTA_int * 0 0 3462 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3465 20 TextureStage const * 0 8576 20 TextureStage const * 20 TextureStage const * 0 0 3466 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3466 18 TextureStage const 0 8832 18 TextureStage const 18 TextureStage const 0 0 3243 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3467 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3248 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3468 12 Geom const * 0 8576 12 Geom const * 12 Geom const * 0 0 3469 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3469 10 Geom const 0 8832 10 Geom const 10 Geom const 0 0 3252 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3470 20 BoundingVolume const 0 8832 20 BoundingVolume const 20 BoundingVolume const 0 0 3255 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3471 22 BoundingVolume const * 0 8576 22 BoundingVolume const * 22 BoundingVolume const * 0 0 3470 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3472 13 GeomContext * 0 8576 13 GeomContext * 13 GeomContext * 0 0 3256 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3473 19 GeomContext const * 0 8576 19 GeomContext const * 19 GeomContext const * 0 0 3474 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3474 17 GeomContext const 0 8832 17 GeomContext const 17 GeomContext const 0 0 3256 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3475 11 GeomLines * 0 8576 11 GeomLines * 11 GeomLines * 0 0 3258 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3476 17 GeomLines const * 0 8576 17 GeomLines const * 17 GeomLines const * 0 0 3477 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3477 15 GeomLines const 0 8832 15 GeomLines const 15 GeomLines const 0 0 3258 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3478 20 GeomLinesAdjacency * 0 8576 20 GeomLinesAdjacency * 20 GeomLinesAdjacency * 0 0 3259 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3479 26 GeomLinesAdjacency const * 0 8576 26 GeomLinesAdjacency const * 26 GeomLinesAdjacency const * 0 0 3480 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3480 24 GeomLinesAdjacency const 0 8832 24 GeomLinesAdjacency const 24 GeomLinesAdjacency const 0 0 3259 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3481 16 GeomLinestrips * 0 8576 16 GeomLinestrips * 16 GeomLinestrips * 0 0 3260 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3482 22 GeomLinestrips const * 0 8576 22 GeomLinestrips const * 22 GeomLinestrips const * 0 0 3483 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3483 20 GeomLinestrips const 0 8832 20 GeomLinestrips const 20 GeomLinestrips const 0 0 3260 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3484 25 GeomLinestripsAdjacency * 0 8576 25 GeomLinestripsAdjacency * 25 GeomLinestripsAdjacency * 0 0 3261 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3485 31 GeomLinestripsAdjacency const * 0 8576 31 GeomLinestripsAdjacency const * 31 GeomLinestripsAdjacency const * 0 0 3486 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3486 29 GeomLinestripsAdjacency const 0 8832 29 GeomLinestripsAdjacency const 29 GeomLinestripsAdjacency const 0 0 3261 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3487 19 GeomPatches const * 0 8576 19 GeomPatches const * 19 GeomPatches const * 0 0 3488 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3488 17 GeomPatches const 0 8832 17 GeomPatches const 17 GeomPatches const 0 0 3262 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3489 13 GeomPatches * 0 8576 13 GeomPatches * 13 GeomPatches * 0 0 3262 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3490 12 GeomPoints * 0 8576 12 GeomPoints * 12 GeomPoints * 0 0 3263 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3491 18 GeomPoints const * 0 8576 18 GeomPoints const * 18 GeomPoints const * 0 0 3492 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3492 16 GeomPoints const 0 8832 16 GeomPoints const 16 GeomPoints const 0 0 3263 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3493 15 GeomTriangles * 0 8576 15 GeomTriangles * 15 GeomTriangles * 0 0 3264 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3494 21 GeomTriangles const * 0 8576 21 GeomTriangles const * 21 GeomTriangles const * 0 0 3495 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3495 19 GeomTriangles const 0 8832 19 GeomTriangles const 19 GeomTriangles const 0 0 3264 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3496 24 GeomTrianglesAdjacency * 0 8576 24 GeomTrianglesAdjacency * 24 GeomTrianglesAdjacency * 0 0 3265 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3497 30 GeomTrianglesAdjacency const * 0 8576 30 GeomTrianglesAdjacency const * 30 GeomTrianglesAdjacency const * 0 0 3498 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3498 28 GeomTrianglesAdjacency const 0 8832 28 GeomTrianglesAdjacency const 28 GeomTrianglesAdjacency const 0 0 3265 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3499 13 GeomTrifans * 0 8576 13 GeomTrifans * 13 GeomTrifans * 0 0 3266 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3500 19 GeomTrifans const * 0 8576 19 GeomTrifans const * 19 GeomTrifans const * 0 0 3501 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3501 17 GeomTrifans const 0 8832 17 GeomTrifans const 17 GeomTrifans const 0 0 3266 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3502 15 GeomTristrips * 0 8576 15 GeomTristrips * 15 GeomTristrips * 0 0 3267 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3503 21 GeomTristrips const * 0 8576 21 GeomTristrips const * 21 GeomTristrips const * 0 0 3504 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3504 19 GeomTristrips const 0 8832 19 GeomTristrips const 19 GeomTristrips const 0 0 3267 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3505 24 GeomTristripsAdjacency * 0 8576 24 GeomTristripsAdjacency * 24 GeomTristripsAdjacency * 0 0 3268 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3506 30 GeomTristripsAdjacency const * 0 8576 30 GeomTristripsAdjacency const * 30 GeomTristripsAdjacency const * 0 0 3507 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3507 28 GeomTristripsAdjacency const 0 8832 28 GeomTristripsAdjacency const 28 GeomTristripsAdjacency const 0 0 3268 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3508 18 GeomVertexReader * 0 8576 18 GeomVertexReader * 18 GeomVertexReader * 0 0 3269 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3509 24 GeomVertexReader const * 0 8576 24 GeomVertexReader const * 24 GeomVertexReader const * 0 0 3510 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3510 22 GeomVertexReader const 0 8832 22 GeomVertexReader const 22 GeomVertexReader const 0 0 3269 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3511 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3512 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3512 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3306 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3513 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3514 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3514 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3312 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3515 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3516 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3516 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3250 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3517 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 3-by-3 transform matrix.  It typically will represent either a</span>
 <span class="s0">* rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix</span>
 <span class="s0">* (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3518 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3517 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3519 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3317 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3520 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3521 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3522 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3522 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3523 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3523 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3524 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3525 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3525 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3526 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3526 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3527 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3528 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3528 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3529 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3529 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3530 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 3-by-3 transform matrix.  It typically will represent either a</span>
 <span class="s0">* rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix</span>
 <span class="s0">* (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3531 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3530 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3532 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3533 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3534 17 LVecBase2 const * 0 8576 17 LVecBase2 const * 17 LVecBase2 const * 0 0 3304 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3535 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 3310 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3536 8 LMatrix3 0 2105344 8 LMatrix3 8 LMatrix3 0 0 3517 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3537 10 LMatrix3 * 0 8576 10 LMatrix3 * 10 LMatrix3 * 0 0 3536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3538 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3539 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3539 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3540 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3540 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3541 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3542 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3542 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3543 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3543 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3544 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3545 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3545 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3546 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3546 10 LVecBase4i 0 2048 10 LVecBase4i 10 LVecBase4i 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3547 18 GeomVertexWriter * 0 8576 18 GeomVertexWriter * 18 GeomVertexWriter * 0 0 3270 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3548 24 GeomVertexWriter const * 0 8576 24 GeomVertexWriter const * 24 GeomVertexWriter const * 0 0 3549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3549 22 GeomVertexWriter const 0 8832 22 GeomVertexWriter const 22 GeomVertexWriter const 0 0 3270 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3550 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3551 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3551 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3517 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3552 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3553 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3553 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3317 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3554 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3555 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3555 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3530 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3556 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3557 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3557 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3558 16 LMatrix3 const * 0 8576 16 LMatrix3 const * 16 LMatrix3 const * 0 0 3559 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3559 14 LMatrix3 const 0 8832 14 LMatrix3 const 14 LMatrix3 const 0 0 3536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3560 20 GeomVertexRewriter * 0 8576 20 GeomVertexRewriter * 20 GeomVertexRewriter * 0 0 3271 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3561 26 GeomVertexRewriter const * 0 8576 26 GeomVertexRewriter const * 26 GeomVertexRewriter const * 0 0 3562 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3562 24 GeomVertexRewriter const 0 8832 24 GeomVertexRewriter const 24 GeomVertexRewriter const 0 0 3271 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3563 14 SamplerState * 0 8576 14 SamplerState * 14 SamplerState * 0 0 3272 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3564 20 SamplerState const * 0 8576 20 SamplerState const * 20 SamplerState const * 0 0 3286 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3565 16 SamplerContext * 0 8576 16 SamplerContext * 16 SamplerContext * 0 0 3566 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3566 14 SamplerContext 0 1050624 14 SamplerContext 14 SamplerContext 0 0 0 0 0 0 0 0 0 0 0 0 468</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special class object that holds a handle to the sampler state</span>
 <span class="s0">* object given by the graphics back-end for a particular combination of</span>
 <span class="s0">* texture sampling settings.</span>
 <span class="s0">*</span>
 <span class="s0">* Some graphics back-ends (like OpenGL) use mutable sampler objects, whereas</span>
 <span class="s0">* others (Direct3D 10+) use immutable ones.  In Panda3D, each unique sampler</span>
 <span class="s0">* state has its own SamplerContext, which simplifies the implementation and</span>
 <span class="s0">* makes redundant sampler objects impossible.</span>
 <span class="s0">*/</span>

<span class="s0">3567 15 Texture const * 0 8576 15 Texture const * 15 Texture const * 0 0 3568 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3568 13 Texture const 0 8832 13 Texture const 13 Texture const 0 0 3276 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3569 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 3284 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3570 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 3571 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3571 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 3572 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3572 13 LoaderOptions 0 2048 13 LoaderOptions 13 LoaderOptions 0 0 0 0 0 0 0 0 0 0 0 0 65</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies parameters that may be passed to the loader.</span>
 <span class="s0">*/</span>

<span class="s0">3573 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 3574 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3574 14 BamCacheRecord 0 2048 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 0 0 0 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* An instance of this class is written to the front of a Bam or Txo file to</span>
 <span class="s0">* make the file a cached instance of some other loadable resource.  This</span>
 <span class="s0">* record contains information needed to test the validity of the cache.</span>
 <span class="s0">*/</span>

<span class="s0">3575 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 3576 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3576 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3577 16 PNMImage const * 0 8576 16 PNMImage const * 16 PNMImage const * 0 0 3578 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3578 14 PNMImage const 0 8832 14 PNMImage const 14 PNMImage const 0 0 3579 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3579 8 PNMImage 0 2048 8 PNMImage 8 PNMImage 0 0 0 0 0 0 0 0 0 0 0 0 1516</span>
<span class="s0">/**</span>
 <span class="s0">* The name of this class derives from the fact that we originally implemented</span>
 <span class="s0">* it as a layer on top of the &quot;pnm library&quot;, based on netpbm, which was built</span>
 <span class="s0">* to implement pbm, pgm, and pbm files, and is the underlying support of a</span>
 <span class="s0">* number of public-domain image file converters.  Nowadays we are no longer</span>
 <span class="s0">* derived directly from the pnm library, mainly to allow support of C++</span>
 <span class="s0">* iostreams instead of the C stdio FILE interface.</span>
 <span class="s0">*</span>
 <span class="s0">* Conceptually, a PNMImage is a two-dimensional array of xels, which are the</span>
 <span class="s0">* PNM-defined generic pixel type.  Each xel may have a red, green, and blue</span>
 <span class="s0">* component, or (if the image is grayscale) a gray component.  The image may</span>
 <span class="s0">* be read in, the individual xels manipulated, and written out again, or a</span>
 <span class="s0">* black image may be constructed from scratch.</span>
 <span class="s0">*</span>
 <span class="s0">* A PNMImage has a color space and a maxval, the combination of which defines</span>
 <span class="s0">* how a floating-point linear color value is encoded as an integer value in</span>
 <span class="s0">* memory.  The functions ending in _val operate on encoded colors, whereas</span>
 <span class="s0">* the regular ones work with linear floating-point values.  All operations</span>
 <span class="s0">* are color space correct unless otherwise specified.</span>
 <span class="s0">*</span>
 <span class="s0">* The image is of size XSize() by YSize() xels, numbered from top to bottom,</span>
 <span class="s0">* left to right, beginning at zero.</span>
 <span class="s0">*</span>
 <span class="s0">* Files can be specified by filename, or by an iostream pointer.  The</span>
 <span class="s0">* filename &quot;-&quot; refers to stdin or stdout.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is not inherently thread-safe; use it from a single thread or</span>
 <span class="s0">* protect access using a mutex.</span>
 <span class="s0">*/</span>

<span class="s0">3580 15 PfmFile const * 0 8576 15 PfmFile const * 15 PfmFile const * 0 0 3581 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3581 13 PfmFile const 0 8832 13 PfmFile const 13 PfmFile const 0 0 3582 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3582 7 PfmFile 0 2048 7 PfmFile 7 PfmFile 0 0 0 0 0 0 0 0 0 0 0 0 155</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a pfm file, a 2-d table of floating-point numbers, either</span>
 <span class="s0">* 3-component or 1-component, or with a special extension, 2- or 4-component.</span>
 <span class="s0">*/</span>

<span class="s0">3583 10 PNMImage * 0 8576 10 PNMImage * 10 PNMImage * 0 0 3579 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3584 9 PfmFile * 0 8576 9 PfmFile * 9 PfmFile * 0 0 3582 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3585 8 WrapMode 0 2367488 17 Texture::WrapMode 17 Texture::WrapMode 3276 0 3274 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3586 10 FilterType 0 2367488 19 Texture::FilterType 19 Texture::FilterType 3276 0 3273 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3587 12 CPTA_uchar * 0 8576 12 CPTA_uchar * 12 CPTA_uchar * 0 0 3287 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3588 9 PTA_uchar 0 2105344 9 PTA_uchar 9 PTA_uchar 0 0 3589 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3589 31 PointerToArray&lt; unsigned char &gt; 0 2048 31 PointerToArray&lt; unsigned char &gt; 31 PointerToArray&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3590 11 PTA_uchar * 0 8576 11 PTA_uchar * 11 PTA_uchar * 0 0 3588 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3591 13 long long int 0 8226 13 long long int 13 long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3592 15 TexturePeeker * 0 8576 15 TexturePeeker * 15 TexturePeeker * 0 0 3339 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3593 11 AsyncFuture 0 2048 11 AsyncFuture 11 AsyncFuture 0 0 0 0 0 0 0 0 0 0 0 0 1711</span>
<span class="s0">/**</span>
 <span class="s0">* This class represents a thread-safe handle to a promised future result of</span>
 <span class="s0">* an asynchronous operation, providing methods to query its status and result</span>
 <span class="s0">* as well as register callbacks for this future's completion.</span>
 <span class="s0">*</span>
 <span class="s0">* An AsyncFuture can be awaited from within a coroutine or task.  It keeps</span>
 <span class="s0">* track of tasks waiting for this future and automatically reactivates them</span>
 <span class="s0">* upon this future's completion.</span>
 <span class="s0">*</span>
 <span class="s0">* A task itself is also a subclass of AsyncFuture.  Other subclasses are</span>
 <span class="s0">* not generally necessary, except to override the function of `cancel()`.</span>
 <span class="s0">*</span>
 <span class="s0">* Until the future is done, it is &quot;owned&quot; by the resolver thread, though it's</span>
 <span class="s0">* still legal for other threads to query its state.  When the resolver thread</span>
 <span class="s0">* resolves this future using `set_result()`, or any thread calls `cancel()`,</span>
 <span class="s0">* it instantly enters the &quot;done&quot; state, after which the result becomes a</span>
 <span class="s0">* read-only field that all threads can access.</span>
 <span class="s0">*</span>
 <span class="s0">* When the future returns true for done(), a thread can use cancelled() to</span>
 <span class="s0">* determine whether the future was cancelled or get_result() to access the</span>
 <span class="s0">* result of the operation.  Not all operations define a meaningful result</span>
 <span class="s0">* value, so some will always return nullptr.</span>
 <span class="s0">*</span>
 <span class="s0">* In Python, the `cancelled()`, `wait()` and `get_result()` methods are</span>
 <span class="s0">* wrapped up into a single `result()` method which waits for the future to</span>
 <span class="s0">* complete before either returning the result or throwing an exception if the</span>
 <span class="s0">* future was cancelled.</span>
 <span class="s0">* However, it is preferable to use the `await` keyword when running from a</span>
 <span class="s0">* coroutine, which only suspends the current task and not the entire thread.</span>
 <span class="s0">*</span>
 <span class="s0">* This API aims to mirror and be compatible with Python's Future class.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">3594 13 AsyncFuture * 0 8576 13 AsyncFuture * 13 AsyncFuture * 0 0 3593 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3595 11 LVecBase2 * 0 8576 11 LVecBase2 * 11 LVecBase2 * 0 0 3305 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3596 16 TextureContext * 0 8576 16 TextureContext * 16 TextureContext * 0 0 3329 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3597 14 Shader const * 0 8576 14 Shader const * 14 Shader const * 0 0 3598 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3598 12 Shader const 0 8832 12 Shader const 12 Shader const 0 0 3292 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3599 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 3285 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3600 15 ShaderContext * 0 8576 15 ShaderContext * 15 ShaderContext * 0 0 3330 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3601 20 ShaderBuffer const * 0 8576 20 ShaderBuffer const * 20 ShaderBuffer const * 0 0 3602 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3602 18 ShaderBuffer const 0 8832 18 ShaderBuffer const 18 ShaderBuffer const 0 0 3297 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3603 14 ShaderBuffer * 0 8576 14 ShaderBuffer * 14 ShaderBuffer * 0 0 3297 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3604 31 PreparedGraphicsObjects const * 0 8576 31 PreparedGraphicsObjects const * 31 PreparedGraphicsObjects const * 0 0 3605 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3605 29 PreparedGraphicsObjects const 0 8832 29 PreparedGraphicsObjects const 29 PreparedGraphicsObjects const 0 0 3299 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3606 20 IndexBufferContext * 0 8576 20 IndexBufferContext * 20 IndexBufferContext * 0 0 3300 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3607 26 IndexBufferContext const * 0 8576 26 IndexBufferContext const * 26 IndexBufferContext const * 0 0 3608 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3608 24 IndexBufferContext const 0 8832 24 IndexBufferContext const 24 IndexBufferContext const 0 0 3300 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3609 35 GeomPrimitivePipelineReader const * 0 8576 35 GeomPrimitivePipelineReader const * 35 GeomPrimitivePipelineReader const * 0 0 3610 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3610 33 GeomPrimitivePipelineReader const 0 8832 33 GeomPrimitivePipelineReader const 33 GeomPrimitivePipelineReader const 0 0 3611 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3611 27 GeomPrimitivePipelineReader 0 1050624 27 GeomPrimitivePipelineReader 27 GeomPrimitivePipelineReader 0 0 0 0 0 0 0 0 0 0 0 0 100</span>
<span class="s0">/**</span>
 <span class="s0">* Encapsulates the data from a GeomPrimitive, pre-fetched for one stage of</span>
 <span class="s0">* the pipeline.</span>
 <span class="s0">*/</span>

<span class="s0">3612 12 Lens const * 0 8576 12 Lens const * 12 Lens const * 0 0 3613 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3613 10 Lens const 0 8832 10 Lens const 10 Lens const 0 0 3301 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3614 6 Lens * 0 8576 6 Lens * 6 Lens * 0 0 3301 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3615 15 LPoint2 const * 0 8576 15 LPoint2 const * 15 LPoint2 const * 0 0 3616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3616 13 LPoint2 const 0 8832 13 LPoint2 const 13 LPoint2 const 0 0 3617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3617 7 LPoint2 0 2105344 7 LPoint2 7 LPoint2 0 0 3618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3618 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">3619 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 3313 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3620 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 3621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3621 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 3313 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3622 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 3623 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3623 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 3432 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3624 9 LPoint2 * 0 8576 9 LPoint2 * 9 LPoint2 * 0 0 3617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3625 16 LVector2 const * 0 8576 16 LVector2 const * 16 LVector2 const * 0 0 3307 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3626 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 3627 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3627 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 3623 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3628 16 BoundingVolume * 0 8576 16 BoundingVolume * 16 BoundingVolume * 0 0 3255 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3629 16 Material const * 0 8576 16 Material const * 16 Material const * 0 0 3630 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3630 14 Material const 0 8832 14 Material const 14 Material const 0 0 3319 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3631 10 Material * 0 8576 10 Material * 10 Material * 0 0 3319 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3632 12 MatrixLens * 0 8576 12 MatrixLens * 12 MatrixLens * 0 0 3321 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3633 18 MatrixLens const * 0 8576 18 MatrixLens const * 18 MatrixLens const * 0 0 3634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3634 16 MatrixLens const 0 8832 16 MatrixLens const 16 MatrixLens const 0 0 3321 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3635 18 OrthographicLens * 0 8576 18 OrthographicLens * 18 OrthographicLens * 0 0 3322 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3636 21 ParamTextureSampler * 0 8576 21 ParamTextureSampler * 21 ParamTextureSampler * 0 0 3323 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3637 27 ParamTextureSampler const * 0 8576 27 ParamTextureSampler const * 27 ParamTextureSampler const * 0 0 3638 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3638 25 ParamTextureSampler const 0 8832 25 ParamTextureSampler const 25 ParamTextureSampler const 0 0 3323 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3639 19 ParamTextureImage * 0 8576 19 ParamTextureImage * 19 ParamTextureImage * 0 0 3326 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3640 25 ParamTextureImage const * 0 8576 25 ParamTextureImage const * 25 ParamTextureImage const * 0 0 3641 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3641 23 ParamTextureImage const 0 8832 23 ParamTextureImage const 23 ParamTextureImage const 0 0 3326 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3642 17 PerspectiveLens * 0 8576 17 PerspectiveLens * 17 PerspectiveLens * 0 0 3327 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3643 28 TextureReloadRequest const * 0 8576 28 TextureReloadRequest const * 28 TextureReloadRequest const * 0 0 3644 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3644 26 TextureReloadRequest const 0 8832 26 TextureReloadRequest const 26 TextureReloadRequest const 0 0 3328 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3645 22 TextureReloadRequest * 0 8576 22 TextureReloadRequest * 22 TextureReloadRequest * 0 0 3328 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3646 22 TextureContext const * 0 8576 22 TextureContext const * 22 TextureContext const * 0 0 3647 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3647 20 TextureContext const 0 8832 20 TextureContext const 20 TextureContext const 0 0 3329 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3648 21 ShaderContext const * 0 8576 21 ShaderContext const * 21 ShaderContext const * 0 0 3649 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3649 19 ShaderContext const 0 8832 19 ShaderContext const 19 ShaderContext const 0 0 3330 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3650 18 UserVertexSlider * 0 8576 18 UserVertexSlider * 18 UserVertexSlider * 0 0 3332 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3651 21 UserVertexTransform * 0 8576 21 UserVertexTransform * 21 UserVertexTransform * 0 0 3333 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3652 27 UserVertexTransform const * 0 8576 27 UserVertexTransform const * 27 UserVertexTransform const * 0 0 3653 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3653 25 UserVertexTransform const 0 8832 25 UserVertexTransform const 25 UserVertexTransform const 0 0 3333 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3654 20 VideoTexture const * 0 8576 20 VideoTexture const * 20 VideoTexture const * 0 0 3655 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3655 18 VideoTexture const 0 8832 18 VideoTexture const 18 VideoTexture const 0 0 3334 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3656 14 VideoTexture * 0 8576 14 VideoTexture * 14 VideoTexture * 0 0 3334 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3657 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 3335 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3658 27 VertexBufferContext const * 0 8576 27 VertexBufferContext const * 27 VertexBufferContext const * 0 0 3659 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3659 25 VertexBufferContext const 0 8832 25 VertexBufferContext const 25 VertexBufferContext const 0 0 3336 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3660 19 TextureCollection * 0 8576 19 TextureCollection * 19 TextureCollection * 0 0 3337 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3661 25 TextureCollection const * 0 8576 25 TextureCollection const * 25 TextureCollection const * 0 0 3662 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3662 23 TextureCollection const 0 8832 23 TextureCollection const 23 TextureCollection const 0 0 3337 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3663 21 TexturePeeker const * 0 8576 21 TexturePeeker const * 21 TexturePeeker const * 0 0 3664 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3664 19 TexturePeeker const 0 8832 19 TexturePeeker const 19 TexturePeeker const 0 0 3339 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">205</span>
<span class="s0">3665 14 animation_type 0 2 3175 1639 0 0 0 0 0 0 0 39 GeomVertexAnimationSpec::animation_type 0</span>

<span class="s0">3666 14 num_transforms 0 2 3177 1640 0 0 0 0 0 0 0 39 GeomVertexAnimationSpec::num_transforms 0</span>

<span class="s0">3667 18 indexed_transforms 0 2 3178 1641 0 0 0 0 0 0 0 43 GeomVertexAnimationSpec::indexed_transforms 0</span>

<span class="s0">3668 6 parent 0 2 3181 1649 0 0 0 0 0 0 0 20 InternalName::parent 0</span>

<span class="s0">3669 4 name 0 2 3182 1650 0 0 0 0 0 0 0 18 InternalName::name 0</span>

<span class="s0">3670 8 basename 0 2 3184 1652 0 0 0 0 0 0 0 22 InternalName::basename 0</span>

<span class="s0">3671 10 registered 0 2 3178 1714 0 0 0 0 0 0 0 33 GeomVertexArrayFormat::registered 0</span>

<span class="s0">3672 6 stride 0 6 3177 1716 1717 0 0 0 0 0 0 29 GeomVertexArrayFormat::stride 0</span>

<span class="s0">3673 6 pad_to 0 6 3177 1718 1719 0 0 0 0 0 0 29 GeomVertexArrayFormat::pad_to 0</span>

<span class="s0">3674 7 divisor 0 6 3177 1720 1721 0 0 0 0 0 0 30 GeomVertexArrayFormat::divisor 0</span>

<span class="s0">3675 11 total_bytes 0 2 3177 1722 0 0 0 0 0 0 0 34 GeomVertexArrayFormat::total_bytes 0</span>

<span class="s0">3676 7 columns 0 66 3187 1729 0 0 0 0 1728 0 0 30 GeomVertexArrayFormat::columns 0</span>

<span class="s0">3677 10 registered 0 2 3178 1746 0 0 0 0 0 0 0 28 GeomVertexFormat::registered 0</span>

<span class="s0">3678 9 animation 0 6 3190 1748 1749 0 0 0 0 0 0 27 GeomVertexFormat::animation 0</span>

<span class="s0">3679 6 arrays 0 358 3191 1753 1755 0 0 1756 1752 1758 0 24 GeomVertexFormat::arrays 0</span>

<span class="s0">3680 6 points 0 66 3193 1771 0 0 0 0 1770 0 0 24 GeomVertexFormat::points 0</span>

<span class="s0">3681 7 vectors 0 66 3193 1773 0 0 0 0 1772 0 0 25 GeomVertexFormat::vectors 0</span>

<span class="s0">3682 7 columns 0 650 3187 1763 0 1764 0 0 1761 0 1765 25 GeomVertexFormat::columns 67</span>
<span class="s0">// We also define this as a mapping interface, for lookups by name.</span>

<span class="s0">3683 9 save_file 0 2 3203 1865 0 0 0 0 0 0 0 25 VertexDataPage::save_file 0</span>

<span class="s0">3684 12 array_format 0 2 3191 1902 0 0 0 0 0 0 0 33 GeomVertexArrayData::array_format 0</span>

<span class="s0">3685 10 usage_hint 0 6 3169 1903 1904 0 0 0 0 0 0 31 GeomVertexArrayData::usage_hint 0</span>

<span class="s0">3686 15 data_size_bytes 0 2 3209 1911 0 0 0 0 0 0 0 36 GeomVertexArrayData::data_size_bytes 0</span>

<span class="s0">3687 8 modified 0 2 3211 1912 0 0 0 0 0 0 0 29 GeomVertexArrayData::modified 0</span>

<span class="s0">3688 6 object 0 2 3213 1935 0 0 0 0 0 0 0 33 GeomVertexArrayDataHandle::object 0</span>

<span class="s0">3689 12 array_format 0 2 3191 1936 0 0 0 0 0 0 0 39 GeomVertexArrayDataHandle::array_format 0</span>

<span class="s0">3690 10 usage_hint 0 2 3169 1937 0 0 0 0 0 0 0 37 GeomVertexArrayDataHandle::usage_hint 0</span>

<span class="s0">3691 15 data_size_bytes 0 2 3209 1943 0 0 0 0 0 0 0 42 GeomVertexArrayDataHandle::data_size_bytes 0</span>

<span class="s0">3692 8 modified 0 2 3211 1944 0 0 0 0 0 0 0 35 GeomVertexArrayDataHandle::modified 0</span>

<span class="s0">3693 8 modified 0 2 3211 1963 0 0 0 0 0 0 0 25 VertexTransform::modified 0</span>

<span class="s0">3694 10 registered 0 2 3178 1971 0 0 0 0 0 0 0 26 TransformTable::registered 0</span>

<span class="s0">3695 8 modified 0 2 3211 1975 0 0 0 0 0 0 0 24 TransformTable::modified 0</span>

<span class="s0">3696 10 transforms 0 358 3217 1974 1976 0 0 1978 1973 1977 0 26 TransformTable::transforms 0</span>

<span class="s0">3697 10 transforms 0 102 3217 1996 1997 0 0 1990 1995 0 0 26 TransformBlend::transforms 0</span>

<span class="s0">3698 7 weights 0 650 3220 1994 0 1993 0 0 1995 0 1996 23 TransformBlend::weights 0</span>

<span class="s0">3699 8 modified 0 2 3211 2003 0 0 0 0 0 0 0 24 TransformBlend::modified 0</span>

<span class="s0">3700 6 blends 0 102 3223 2010 2012 0 0 2013 2009 0 0 27 TransformBlendTable::blends 0</span>

<span class="s0">3701 8 modified 0 2 3211 2011 0 0 0 0 0 0 0 29 TransformBlendTable::modified 0</span>

<span class="s0">3702 14 num_transforms 0 2 3177 2015 0 0 0 0 0 0 0 35 TransformBlendTable::num_transforms 0</span>

<span class="s0">3703 27 max_simultaneous_transforms 0 2 3177 2016 0 0 0 0 0 0 0 48 TransformBlendTable::max_simultaneous_transforms 0</span>

<span class="s0">3704 4 rows 0 6 3224 2018 2017 0 0 0 0 0 0 25 TransformBlendTable::rows 0</span>

<span class="s0">3705 4 name 0 2 3193 2022 0 0 0 0 0 0 0 18 VertexSlider::name 0</span>

<span class="s0">3706 6 slider 0 2 3220 2023 0 0 0 0 0 0 0 20 VertexSlider::slider 0</span>

<span class="s0">3707 8 modified 0 2 3211 2024 0 0 0 0 0 0 0 22 VertexSlider::modified 0</span>

<span class="s0">3708 8 modified 0 2 3211 2038 0 0 0 0 0 0 0 21 SliderTable::modified 0</span>

<span class="s0">3709 4 name 0 6 3184 2056 2057 0 0 0 0 0 0 20 GeomVertexData::name 0</span>

<span class="s0">3710 10 usage_hint 0 6 3169 2058 2059 0 0 0 0 0 0 26 GeomVertexData::usage_hint 0</span>

<span class="s0">3711 6 format 0 6 3229 2060 2061 0 0 0 0 0 0 22 GeomVertexData::format 0</span>

<span class="s0">3712 6 arrays 0 70 3231 2070 2074 0 0 0 2069 0 0 22 GeomVertexData::arrays 0</span>

<span class="s0">3713 15 transform_table 0 6 3232 2075 2076 0 0 0 0 0 0 31 GeomVertexData::transform_table 0</span>

<span class="s0">3714 12 slider_table 0 6 3234 2082 2083 0 0 0 0 0 0 28 GeomVertexData::slider_table 0</span>

<span class="s0">3715 9 num_bytes 0 2 3177 2085 0 0 0 0 0 0 0 25 GeomVertexData::num_bytes 0</span>

<span class="s0">3716 8 modified 0 2 3211 2086 0 0 0 0 0 0 0 24 GeomVertexData::modified 0</span>

<span class="s0">3717 6 object 0 2 3241 2117 0 0 0 0 0 0 0 21 BufferContext::object 0</span>

<span class="s0">3718 15 data_size_bytes 0 2 3209 2113 0 0 0 0 0 0 0 30 BufferContext::data_size_bytes 0</span>

<span class="s0">3719 8 modified 0 2 3211 2114 0 0 0 0 0 0 0 23 BufferContext::modified 0</span>

<span class="s0">3720 6 active 0 2 3178 2115 0 0 0 0 0 0 0 21 BufferContext::active 0</span>

<span class="s0">3721 8 resident 0 2 3178 2116 0 0 0 0 0 0 0 23 BufferContext::resident 0</span>

<span class="s0">3722 14 primitive_type 0 2 3172 2129 0 0 0 0 0 0 0 29 GeomPrimitive::primitive_type 0</span>

<span class="s0">3723 14 geom_rendering 0 2 3177 2130 0 0 0 0 0 0 0 29 GeomPrimitive::geom_rendering 0</span>

<span class="s0">3724 11 shade_model 0 2 3171 2131 0 0 0 0 0 0 0 26 GeomPrimitive::shade_model 0</span>

<span class="s0">3725 10 usage_hint 0 2 3169 2133 0 0 0 0 0 0 0 25 GeomPrimitive::usage_hint 0</span>

<span class="s0">3726 10 index_type 0 2 3173 2135 0 0 0 0 0 0 0 25 GeomPrimitive::index_type 0</span>

<span class="s0">3727 9 num_bytes 0 2 3177 2173 0 0 0 0 0 0 0 24 GeomPrimitive::num_bytes 0</span>

<span class="s0">3728 15 data_size_bytes 0 2 3177 2174 0 0 0 0 0 0 0 30 GeomPrimitive::data_size_bytes 0</span>

<span class="s0">3729 8 modified 0 2 3211 2175 0 0 0 0 0 0 0 23 GeomPrimitive::modified 0</span>

<span class="s0">3730 12 index_stride 0 2 3177 2186 0 0 0 0 0 0 0 27 GeomPrimitive::index_stride 0</span>

<span class="s0">3731 15 strip_cut_index 0 2 3177 2187 0 0 0 0 0 0 0 30 GeomPrimitive::strip_cut_index 0</span>

<span class="s0">3732 4 mins 0 2 3231 2191 0 0 0 0 0 0 0 19 GeomPrimitive::mins 0</span>

<span class="s0">3733 4 maxs 0 2 3231 2192 0 0 0 0 0 0 0 19 GeomPrimitive::maxs 0</span>

<span class="s0">3734 26 num_vertices_per_primitive 0 2 3177 2195 0 0 0 0 0 0 0 41 GeomPrimitive::num_vertices_per_primitive 0</span>

<span class="s0">3735 30 min_num_vertices_per_primitive 0 2 3177 2196 0 0 0 0 0 0 0 45 GeomPrimitive::min_num_vertices_per_primitive 0</span>

<span class="s0">3736 33 num_unused_vertices_per_primitive 0 2 3177 2197 0 0 0 0 0 0 0 48 GeomPrimitive::num_unused_vertices_per_primitive 0</span>

<span class="s0">3737 4 name 0 6 3184 2202 2201 0 0 0 0 0 0 18 TextureStage::name 0</span>

<span class="s0">3738 4 sort 0 6 3177 2204 2203 0 0 0 0 0 0 18 TextureStage::sort 0</span>

<span class="s0">3739 8 priority 0 6 3177 2206 2205 0 0 0 0 0 0 22 TextureStage::priority 0</span>

<span class="s0">3740 13 texcoord_name 0 6 3181 2208 2207 0 0 0 0 0 0 27 TextureStage::texcoord_name 0</span>

<span class="s0">3741 12 tangent_name 0 2 3181 2209 0 0 0 0 0 0 0 26 TextureStage::tangent_name 0</span>

<span class="s0">3742 13 binormal_name 0 2 3181 2210 0 0 0 0 0 0 0 27 TextureStage::binormal_name 0</span>

<span class="s0">3743 4 mode 0 6 3244 2212 2211 0 0 0 0 0 0 18 TextureStage::mode 0</span>

<span class="s0">3744 5 color 0 6 3248 2215 2214 0 0 0 0 0 0 19 TextureStage::color 0</span>

<span class="s0">3745 9 rgb_scale 0 6 3177 2217 2216 0 0 0 0 0 0 23 TextureStage::rgb_scale 0</span>

<span class="s0">3746 11 alpha_scale 0 6 3177 2219 2218 0 0 0 0 0 0 25 TextureStage::alpha_scale 0</span>

<span class="s0">3747 12 saved_result 0 6 3178 2221 2220 0 0 0 0 0 0 26 TextureStage::saved_result 0</span>

<span class="s0">3748 15 tex_view_offset 0 6 3177 2223 2222 0 0 0 0 0 0 29 TextureStage::tex_view_offset 0</span>

<span class="s0">3749 7 default 0 2 3251 2252 0 0 0 0 0 0 0 21 TextureStage::default 0</span>

<span class="s0">3750 14 primitive_type 0 2 3172 2265 0 0 0 0 0 0 0 20 Geom::primitive_type 0</span>

<span class="s0">3751 11 shade_model 0 2 3171 2266 0 0 0 0 0 0 0 17 Geom::shade_model 0</span>

<span class="s0">3752 14 geom_rendering 0 2 3177 2267 0 0 0 0 0 0 0 20 Geom::geom_rendering 0</span>

<span class="s0">3753 10 primitives 0 358 3253 2278 2280 0 0 2283 2277 2281 0 16 Geom::primitives 0</span>

<span class="s0">3754 9 num_bytes 0 2 3177 2304 0 0 0 0 0 0 0 15 Geom::num_bytes 0</span>

<span class="s0">3755 8 modified 0 2 3211 2305 0 0 0 0 0 0 0 14 Geom::modified 0</span>

<span class="s0">3756 11 bounds_type 0 6 3254 2313 2312 0 0 0 0 0 0 17 Geom::bounds_type 0</span>

<span class="s0">3757 4 geom 0 2 3257 2326 0 0 0 0 0 0 0 17 GeomContext::geom 0</span>

<span class="s0">3758 6 wrap_u 0 6 3274 2525 2515 0 0 0 0 0 0 20 SamplerState::wrap_u 0</span>

<span class="s0">3759 6 wrap_v 0 6 3274 2526 2516 0 0 0 0 0 0 20 SamplerState::wrap_v 0</span>

<span class="s0">3760 6 wrap_w 0 6 3274 2527 2517 0 0 0 0 0 0 20 SamplerState::wrap_w 0</span>

<span class="s0">3761 9 minfilter 0 6 3273 2528 2518 0 0 0 0 0 0 23 SamplerState::minfilter 0</span>

<span class="s0">3762 9 magfilter 0 6 3273 2529 2519 0 0 0 0 0 0 23 SamplerState::magfilter 0</span>

<span class="s0">3763 19 effective_minfilter 0 2 3273 2530 0 0 0 0 0 0 0 33 SamplerState::effective_minfilter 0</span>

<span class="s0">3764 19 effective_magfilter 0 2 3273 2531 0 0 0 0 0 0 0 33 SamplerState::effective_magfilter 0</span>

<span class="s0">3765 18 anisotropic_degree 0 6 3177 2532 2520 0 0 0 0 0 0 32 SamplerState::anisotropic_degree 0</span>

<span class="s0">3766 28 effective_anisotropic_degree 0 2 3177 2533 0 0 0 0 0 0 0 42 SamplerState::effective_anisotropic_degree 0</span>

<span class="s0">3767 12 border_color 0 6 3275 2534 2521 0 0 0 0 0 0 26 SamplerState::border_color 0</span>

<span class="s0">3768 7 min_lod 0 6 3220 2535 2522 0 0 0 0 0 0 21 SamplerState::min_lod 0</span>

<span class="s0">3769 7 max_lod 0 6 3220 2536 2523 0 0 0 0 0 0 21 SamplerState::max_lod 0</span>

<span class="s0">3770 8 lod_bias 0 6 3220 2537 2524 0 0 0 0 0 0 22 SamplerState::lod_bias 0</span>

<span class="s0">3771 11 clear_color 0 30 3248 2573 2574 2572 2575 0 0 0 0 20 Texture::clear_color 0</span>

<span class="s0">3772 8 filename 0 30 3284 2590 2591 2589 2592 0 0 0 0 17 Texture::filename 0</span>

<span class="s0">3773 14 alpha_filename 0 30 3284 2594 2595 2593 2596 0 0 0 0 23 Texture::alpha_filename 0</span>

<span class="s0">3774 8 fullpath 0 30 3284 2598 2599 2597 2600 0 0 0 0 17 Texture::fullpath 0</span>

<span class="s0">3775 14 alpha_fullpath 0 30 3284 2602 2603 2601 2604 0 0 0 0 23 Texture::alpha_fullpath 0</span>

<span class="s0">3776 6 x_size 0 6 3177 2605 2606 0 0 0 0 0 0 15 Texture::x_size 0</span>

<span class="s0">3777 6 y_size 0 6 3177 2607 2608 0 0 0 0 0 0 15 Texture::y_size 0</span>

<span class="s0">3778 6 z_size 0 6 3177 2609 2610 0 0 0 0 0 0 15 Texture::z_size 0</span>

<span class="s0">3779 9 num_views 0 6 3177 2611 2612 0 0 0 0 0 0 18 Texture::num_views 0</span>

<span class="s0">3780 9 num_pages 0 2 3177 2613 0 0 0 0 0 0 0 18 Texture::num_pages 0</span>

<span class="s0">3781 14 num_components 0 2 3177 2614 0 0 0 0 0 0 0 23 Texture::num_components 0</span>

<span class="s0">3782 15 component_width 0 2 3177 2615 0 0 0 0 0 0 0 24 Texture::component_width 0</span>

<span class="s0">3783 12 texture_type 0 2 3277 2616 0 0 0 0 0 0 0 21 Texture::texture_type 0</span>

<span class="s0">3784 10 usage_hint 0 2 3169 2617 0 0 0 0 0 0 0 19 Texture::usage_hint 0</span>

<span class="s0">3785 6 format 0 6 3279 2618 2619 0 0 0 0 0 0 15 Texture::format 0</span>

<span class="s0">3786 14 component_type 0 6 3278 2620 2621 0 0 0 0 0 0 23 Texture::component_type 0</span>

<span class="s0">3787 6 wrap_u 0 6 3274 2622 2623 0 0 0 0 0 0 15 Texture::wrap_u 0</span>

<span class="s0">3788 6 wrap_v 0 6 3274 2624 2625 0 0 0 0 0 0 15 Texture::wrap_v 0</span>

<span class="s0">3789 6 wrap_w 0 6 3274 2626 2627 0 0 0 0 0 0 15 Texture::wrap_w 0</span>

<span class="s0">3790 9 minfilter 0 6 3273 2628 2630 0 0 0 0 0 0 18 Texture::minfilter 0</span>

<span class="s0">3791 19 effective_minfilter 0 2 3273 2629 0 0 0 0 0 0 0 28 Texture::effective_minfilter 0</span>

<span class="s0">3792 9 magfilter 0 6 3273 2631 2633 0 0 0 0 0 0 18 Texture::magfilter 0</span>

<span class="s0">3793 19 effective_magfilter 0 2 3273 2632 0 0 0 0 0 0 0 28 Texture::effective_magfilter 0</span>

<span class="s0">3794 18 anisotropic_degree 0 6 3177 2634 2636 0 0 0 0 0 0 27 Texture::anisotropic_degree 0</span>

<span class="s0">3795 28 effective_anisotropic_degree 0 2 3177 2635 0 0 0 0 0 0 0 37 Texture::effective_anisotropic_degree 0</span>

<span class="s0">3796 12 border_color 0 6 3248 2637 2638 0 0 0 0 0 0 21 Texture::border_color 0</span>

<span class="s0">3797 11 compression 0 6 3282 2640 2641 0 0 0 0 0 0 20 Texture::compression 44</span>
<span class="s0">// Could maybe use has_compression here, too</span>

<span class="s0">3798 17 render_to_texture 0 6 3178 2642 2643 0 0 0 0 0 0 26 Texture::render_to_texture 0</span>

<span class="s0">3799 15 default_sampler 0 6 3286 2644 2645 0 0 0 0 0 0 24 Texture::default_sampler 0</span>

<span class="s0">3800 13 quality_level 0 6 3283 2647 2649 0 0 0 0 0 0 22 Texture::quality_level 0</span>

<span class="s0">3801 23 effective_quality_level 0 2 3283 2648 0 0 0 0 0 0 0 32 Texture::effective_quality_level 0</span>

<span class="s0">3802 26 expected_num_mipmap_levels 0 2 3177 2650 0 0 0 0 0 0 0 35 Texture::expected_num_mipmap_levels 0</span>

<span class="s0">3803 14 ram_image_size 0 2 3209 2658 0 0 0 0 0 0 0 23 Texture::ram_image_size 0</span>

<span class="s0">3804 13 ram_view_size 0 2 3209 2659 0 0 0 0 0 0 0 22 Texture::ram_view_size 0</span>

<span class="s0">3805 13 ram_page_size 0 2 3209 2660 0 0 0 0 0 0 0 22 Texture::ram_page_size 0</span>

<span class="s0">3806 23 expected_ram_image_size 0 2 3209 2661 0 0 0 0 0 0 0 32 Texture::expected_ram_image_size 0</span>

<span class="s0">3807 22 expected_ram_page_size 0 2 3209 2662 0 0 0 0 0 0 0 31 Texture::expected_ram_page_size 0</span>

<span class="s0">3808 21 ram_image_compression 0 2 3282 2664 0 0 0 0 0 0 0 30 Texture::ram_image_compression 0</span>

<span class="s0">3809 14 keep_ram_image 0 6 3178 2673 2672 0 0 0 0 0 0 23 Texture::keep_ram_image 0</span>

<span class="s0">3810 9 cacheable 0 2 3178 2674 0 0 0 0 0 0 0 18 Texture::cacheable 0</span>

<span class="s0">3811 21 num_ram_mipmap_images 0 2 3177 2678 0 0 0 0 0 0 0 30 Texture::num_ram_mipmap_images 0</span>

<span class="s0">3812 30 num_loadable_ram_mipmap_images 0 2 3177 2680 0 0 0 0 0 0 0 39 Texture::num_loadable_ram_mipmap_images 0</span>

<span class="s0">3813 13 simple_x_size 0 2 3177 2698 0 0 0 0 0 0 0 22 Texture::simple_x_size 0</span>

<span class="s0">3814 13 simple_y_size 0 2 3177 2699 0 0 0 0 0 0 0 22 Texture::simple_y_size 0</span>

<span class="s0">3815 16 simple_ram_image 0 10 3287 2702 0 2700 0 0 0 0 0 25 Texture::simple_ram_image 0</span>

<span class="s0">3816 19 properties_modified 0 2 3211 2709 0 0 0 0 0 0 0 28 Texture::properties_modified 0</span>

<span class="s0">3817 14 image_modified 0 2 3211 2710 0 0 0 0 0 0 0 23 Texture::image_modified 0</span>

<span class="s0">3818 21 simple_image_modified 0 2 3211 2711 0 0 0 0 0 0 0 30 Texture::simple_image_modified 0</span>

<span class="s0">3819 18 auto_texture_scale 0 6 3289 2713 2714 0 0 0 0 0 0 27 Texture::auto_texture_scale 0</span>

<span class="s0">3820 8 aux_data 0 174 3290 2726 2724 2726 0 2725 0 0 0 17 Texture::aux_data 0</span>

<span class="s0">3821 16 orig_file_x_size 0 2 3177 2736 0 0 0 0 0 0 0 25 Texture::orig_file_x_size 0</span>

<span class="s0">3822 16 orig_file_y_size 0 2 3177 2737 0 0 0 0 0 0 0 25 Texture::orig_file_y_size 0</span>

<span class="s0">3823 16 orig_file_z_size 0 2 3177 2738 0 0 0 0 0 0 0 25 Texture::orig_file_z_size 0</span>

<span class="s0">3824 17 loaded_from_image 0 6 3178 2741 2740 0 0 0 0 0 0 26 Texture::loaded_from_image 0</span>

<span class="s0">3825 15 loaded_from_txo 0 6 3178 2743 2742 0 0 0 0 0 0 24 Texture::loaded_from_txo 0</span>

<span class="s0">3826 24 match_framebuffer_format 0 6 3178 2744 2745 0 0 0 0 0 0 33 Texture::match_framebuffer_format 0</span>

<span class="s0">3827 21 post_load_store_cache 0 6 3178 2746 2747 0 0 0 0 0 0 30 Texture::post_load_store_cache 0</span>

<span class="s0">3828 15 data_size_bytes 0 2 3298 2792 0 0 0 0 0 0 0 29 ShaderBuffer::data_size_bytes 0</span>

<span class="s0">3829 10 usage_hint 0 2 3169 2793 0 0 0 0 0 0 0 24 ShaderBuffer::usage_hint 0</span>

<span class="s0">3830 12 change_event 0 6 3184 2887 2886 0 0 0 0 0 0 18 Lens::change_event 0</span>

<span class="s0">3831 17 coordinate_system 0 6 3303 2889 2888 0 0 0 0 0 0 23 Lens::coordinate_system 0</span>

<span class="s0">3832 9 film_size 0 6 3304 2892 2891 0 0 0 0 0 0 15 Lens::film_size 0</span>

<span class="s0">3833 11 film_offset 0 6 3307 2894 2893 0 0 0 0 0 0 17 Lens::film_offset 0</span>

<span class="s0">3834 12 focal_length 0 6 3220 2896 2895 0 0 0 0 0 0 18 Lens::focal_length 0</span>

<span class="s0">3835 3 fov 0 6 3304 2899 2898 0 0 0 0 0 0 9 Lens::fov 0</span>

<span class="s0">3836 7 min_fov 0 6 3220 2902 2897 0 0 0 0 0 0 13 Lens::min_fov 0</span>

<span class="s0">3837 12 aspect_ratio 0 6 3220 2904 2903 0 0 0 0 0 0 18 Lens::aspect_ratio 0</span>

<span class="s0">3838 4 near 0 6 3220 2906 2905 0 0 0 0 0 0 10 Lens::near 0</span>

<span class="s0">3839 3 far 0 6 3220 2908 2907 0 0 0 0 0 0 9 Lens::far 0</span>

<span class="s0">3840 8 view_hpr 0 6 3310 2913 2912 0 0 0 0 0 0 14 Lens::view_hpr 0</span>

<span class="s0">3841 11 nodal_point 0 2 3313 2917 0 0 0 0 0 0 0 17 Lens::nodal_point 0</span>

<span class="s0">3842 20 interocular_distance 0 6 3220 2919 2918 0 0 0 0 0 0 26 Lens::interocular_distance 0</span>

<span class="s0">3843 20 convergence_distance 0 6 3220 2921 2920 0 0 0 0 0 0 26 Lens::convergence_distance 0</span>

<span class="s0">3844 8 view_mat 0 6 3315 2923 2922 0 0 0 0 0 0 14 Lens::view_mat 0</span>

<span class="s0">3845 8 keystone 0 6 3304 2926 2925 0 0 0 0 0 0 14 Lens::keystone 0</span>

<span class="s0">3846 10 base_color 0 30 3275 2958 2959 2957 2960 0 0 0 0 20 Material::base_color 0</span>

<span class="s0">3847 7 ambient 0 30 3275 2962 2963 2961 2964 0 0 0 0 17 Material::ambient 0</span>

<span class="s0">3848 7 diffuse 0 30 3275 2966 2967 2965 2968 0 0 0 0 17 Material::diffuse 0</span>

<span class="s0">3849 8 specular 0 30 3275 2970 2971 2969 2972 0 0 0 0 18 Material::specular 0</span>

<span class="s0">3850 8 emission 0 30 3275 2974 2975 2973 2976 0 0 0 0 18 Material::emission 0</span>

<span class="s0">3851 9 shininess 0 6 3220 2977 2978 0 0 0 0 0 0 19 Material::shininess 0</span>

<span class="s0">3852 9 roughness 0 6 3220 2980 2981 0 0 0 0 0 0 19 Material::roughness 0</span>

<span class="s0">3853 8 metallic 0 6 3220 2983 2984 0 0 0 0 0 0 18 Material::metallic 0</span>

<span class="s0">3854 16 refractive_index 0 6 3220 2987 2988 0 0 0 0 0 0 26 Material::refractive_index 0</span>

<span class="s0">3855 5 local 0 6 3178 2989 2990 0 0 0 0 0 0 15 Material::local 0</span>

<span class="s0">3856 7 twoside 0 6 3178 2991 2992 0 0 0 0 0 0 17 Material::twoside 0</span>

<span class="s0">3857 8 user_mat 0 6 3315 3011 3010 0 0 0 0 0 0 20 MatrixLens::user_mat 0</span>

<span class="s0">3858 7 texture 0 2 3325 3026 0 0 0 0 0 0 0 28 ParamTextureSampler::texture 0</span>

<span class="s0">3859 7 sampler 0 2 3286 3027 0 0 0 0 0 0 0 28 ParamTextureSampler::sampler 0</span>

<span class="s0">3860 7 texture 0 2 3325 3031 0 0 0 0 0 0 0 26 ParamTextureImage::texture 0</span>

<span class="s0">3861 11 read_access 0 2 3178 3032 0 0 0 0 0 0 0 30 ParamTextureImage::read_access 0</span>

<span class="s0">3862 12 write_access 0 2 3178 3033 0 0 0 0 0 0 0 31 ParamTextureImage::write_access 0</span>

<span class="s0">3863 10 bind_level 0 2 3177 3035 0 0 0 0 0 0 0 29 ParamTextureImage::bind_level 0</span>

<span class="s0">3864 10 bind_layer 0 10 3177 3036 0 3034 0 0 0 0 0 29 ParamTextureImage::bind_layer 0</span>

<span class="s0">3865 7 texture 0 2 3325 3044 0 0 0 0 0 0 0 29 TextureReloadRequest::texture 0</span>

<span class="s0">3866 6 shader 0 2 3331 3066 0 0 0 0 0 0 0 21 ShaderContext::shader 0</span>

<span class="s0">3867 11 video_width 0 2 3177 3083 0 0 0 0 0 0 0 25 VideoTexture::video_width 0</span>

<span class="s0">3868 12 video_height 0 2 3177 3084 0 0 0 0 0 0 0 26 VideoTexture::video_height 0</span>

<span class="s0">3869 4 mode 0 6 3341 3158 3157 0 0 0 0 0 0 22 TextureStagePool::mode 0</span>

<span class="s0">17</span>
<span class="s0">3870 11 get_columns 0 1728 1729 34 GeomVertexArrayFormat::get_columns 0</span>

<span class="s0">3871 10 get_arrays 0 1752 1753 28 GeomVertexFormat::get_arrays 0</span>

<span class="s0">3872 11 get_columns 0 1761 1763 29 GeomVertexFormat::get_columns 0</span>

<span class="s0">3873 10 get_points 0 1770 1771 28 GeomVertexFormat::get_points 0</span>

<span class="s0">3874 11 get_vectors 0 1772 1773 29 GeomVertexFormat::get_vectors 0</span>

<span class="s0">3875 13 get_texcoords 0 1774 1775 31 GeomVertexFormat::get_texcoords 0</span>

<span class="s0">3876 17 get_morph_sliders 0 1776 1777 35 GeomVertexFormat::get_morph_sliders 0</span>

<span class="s0">3877 15 get_morph_bases 0 1776 1778 33 GeomVertexFormat::get_morph_bases 0</span>

<span class="s0">3878 16 get_morph_deltas 0 1776 1779 34 GeomVertexFormat::get_morph_deltas 0</span>

<span class="s0">3879 14 get_transforms 0 1973 1974 30 TransformTable::get_transforms 0</span>

<span class="s0">3880 14 get_transforms 0 1995 1996 30 TransformBlend::get_transforms 0</span>

<span class="s0">3881 10 get_blends 0 2009 2010 31 TransformBlendTable::get_blends 0</span>

<span class="s0">3882 11 get_sliders 0 2032 2033 24 SliderTable::get_sliders 0</span>

<span class="s0">3883 10 get_arrays 0 2069 2070 26 GeomVertexData::get_arrays 0</span>

<span class="s0">3884 15 get_vertex_list 0 2140 2141 30 GeomPrimitive::get_vertex_list 0</span>

<span class="s0">3885 14 get_primitives 0 2277 2278 20 Geom::get_primitives 0</span>

<span class="s0">3886 12 get_textures 0 3110 3111 31 TextureCollection::get_textures 0</span>

</pre>
</body>
</html>