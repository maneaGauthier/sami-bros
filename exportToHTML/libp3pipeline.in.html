<html>
<head>
<title>libp3pipeline.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3pipeline.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">13 libp3pipeline 4 kd_i 12 panda3d.core </span>
<span class="s0">112</span>
<span class="s0">106 29 upcast_to_TypedReferenceCount 0 12 219 37 Thread::upcast_to_TypedReferenceCount 0 1 31 41</span>
<span class="s0">upcast from Thread to TypedReferenceCount</span>
<span class="s0">65</span>
<span class="s0">TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void);</span>

<span class="s0">107 18 downcast_to_Thread 0 12 220 39 TypedReferenceCount::downcast_to_Thread 0 0 43</span>
<span class="s0">downcast from TypedReferenceCount to Thread</span>
<span class="s0">54</span>
<span class="s0">Thread *TypedReferenceCount::downcast_to_Thread(void);</span>

<span class="s0">108 17 upcast_to_Namable 0 12 219 25 Thread::upcast_to_Namable 0 1 32 29</span>
<span class="s0">upcast from Thread to Namable</span>
<span class="s0">41</span>
<span class="s0">Namable *Thread::upcast_to_Namable(void);</span>

<span class="s0">109 18 downcast_to_Thread 0 12 221 27 Namable::downcast_to_Thread 0 0 31</span>
<span class="s0">downcast from Namable to Thread</span>
<span class="s0">42</span>
<span class="s0">Thread *Namable::downcast_to_Thread(void);</span>

<span class="s0">110 7 ~Thread 0 518 219 15 Thread::~Thread 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">virtual Thread::~Thread(void);</span>

<span class="s0">111 11 bind_thread 0 4 219 19 Thread::bind_thread 0 1 1 952</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new Panda Thread object associated with the current thread (which</span>
 <span class="s0">* has been created externally). This can be used to bind a unique Panda</span>
 <span class="s0">* Thread object with an external thread, such as a new Python thread.</span>
 <span class="s0">*</span>
 <span class="s0">* It is particularly useful to bind a Panda Thread object to an external</span>
 <span class="s0">* thread for the purposes of PStats monitoring.  Without this call, each</span>
 <span class="s0">* external thread will be assigned the same global ExternalThread object,</span>
 <span class="s0">* which means they will all appear in the same PStats graph.</span>
 <span class="s0">*</span>
 <span class="s0">* It is the caller's responsibility to save the returned Thread pointer for</span>
 <span class="s0">* the lifetime of the external thread.  It is an error for the Thread pointer</span>
 <span class="s0">* to destruct while the external thread is still in the system.</span>
 <span class="s0">*</span>
 <span class="s0">* It is also an error to call this method from the main thread, or twice</span>
 <span class="s0">* within a given thread, unless it is given the same name each time (in which</span>
 <span class="s0">* case the same pointer will be returned each time).</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">static PointerTo&lt; Thread &gt; Thread::bind_thread(std::string const &amp;name, std::string const &amp;sync_name);</span>

<span class="s0">112 13 get_sync_name 0 4 219 21 Thread::get_sync_name 0 1 2 279</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sync name of the thread.  This name collects threads into &quot;sync</span>
 <span class="s0">* groups&quot;, which are expected to run synchronously.  This is mainly used for</span>
 <span class="s0">* the benefit of PStats; threads with the same sync name can be ticked all at</span>
 <span class="s0">* once via the thread_tick() call.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline std::string const &amp;Thread::get_sync_name(void) const;</span>

<span class="s0">113 16 get_pstats_index 0 4 219 24 Thread::get_pstats_index 0 1 3 218</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the PStats index associated with this thread, or -1 if no index has</span>
 <span class="s0">* yet been associated with this thread.  This is used internally by the</span>
 <span class="s0">* PStatClient; you should not need to call this directly.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int Thread::get_pstats_index(void) const;</span>

<span class="s0">114 16 get_python_index 0 4 219 24 Thread::get_python_index 0 1 4 233</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Python index associated with this thread, or -1 if no index has</span>
 <span class="s0">* yet been associated with this thread.  This is used internally by the</span>
 <span class="s0">* direct.stdpy.thread module; you should not need to call this directly.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int Thread::get_python_index(void) const;</span>

<span class="s0">115 13 get_unique_id 0 4 219 21 Thread::get_unique_id 0 1 5 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string that is guaranteed to be unique to this thread, across all</span>
 <span class="s0">* processes on the machine, during at least the lifetime of this process.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::string Thread::get_unique_id(void) const;</span>

<span class="s0">116 18 get_pipeline_stage 0 4 219 26 Thread::get_pipeline_stage 0 1 6 163</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Pipeline stage number associated with this thread.  The default</span>
 <span class="s0">* stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int Thread::get_pipeline_stage(void) const;</span>

<span class="s0">117 18 set_pipeline_stage 0 4 219 26 Thread::set_pipeline_stage 0 1 7 479</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the Pipeline stage number associated with this thread.  The</span>
 <span class="s0">* default stage is 0 if no stage is specified otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be a value in the range [0 .. pipeline-&gt;get_num_stages() - 1].</span>
 <span class="s0">* It specifies the values that this thread observes for all pipelined data.</span>
 <span class="s0">* Typically, an application thread will leave this at 0, but a render thread</span>
 <span class="s0">* may set it to 1 or 2 (to operate on the previous frame's data, or the</span>
 <span class="s0">* second previous frame's data).</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void Thread::set_pipeline_stage(int pipeline_stage);</span>

<span class="s0">118 22 set_min_pipeline_stage 0 4 219 30 Thread::set_min_pipeline_stage 0 1 8 143</span>
<span class="s0">/**</span>
 <span class="s0">* Sets this thread's pipeline stage number to at least the indicated value,</span>
 <span class="s0">* unless it is already larger.  See set_pipeline_stage().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void Thread::set_min_pipeline_stage(int min_pipeline_stage);</span>

<span class="s0">119 15 get_main_thread 0 4 219 23 Thread::get_main_thread 0 1 9 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the &quot;main&quot; Thread object--this is the Thread that</span>
 <span class="s0">* started the whole process.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static inline Thread *Thread::get_main_thread(void);</span>

<span class="s0">120 19 get_external_thread 0 4 219 27 Thread::get_external_thread 0 1 10 248</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the &quot;external&quot; Thread object--this is a special Thread</span>
 <span class="s0">* object that corresponds to any thread spawned outside of Panda's threading</span>
 <span class="s0">* interface.  Note that multiple different threads may share this same</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static inline Thread *Thread::get_external_thread(void);</span>

<span class="s0">121 18 get_current_thread 0 4 219 26 Thread::get_current_thread 0 1 11 415</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the currently-executing Thread object.  If this is</span>
 <span class="s0">* called from the main thread, this will return the same value as</span>
 <span class="s0">* get_main_thread().</span>
 <span class="s0">*</span>
 <span class="s0">* This will always return some valid Thread pointer.  It will never return</span>
 <span class="s0">* NULL, even if the current thread was spawned outside of Panda's threading</span>
 <span class="s0">* system, although all non-Panda threads will return the exact same Thread</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline Thread *Thread::get_current_thread(void);</span>

<span class="s0">122 26 get_current_pipeline_stage 0 4 219 34 Thread::get_current_pipeline_stage 0 1 12 208</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the integer pipeline stage associated with the current thread.</span>
 <span class="s0">* This is the same thing as get_current_thread()-&gt;get_pipeline_stage(), but</span>
 <span class="s0">* it may be faster to retrieve in some contexts.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">static inline int Thread::get_current_pipeline_stage(void);</span>

<span class="s0">123 22 is_threading_supported 0 4 219 30 Thread::is_threading_supported 0 1 13 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if threading support has been compiled in and enabled, or</span>
 <span class="s0">* false if no threading is available (and Thread::start() will always fail).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static inline bool Thread::is_threading_supported(void);</span>

<span class="s0">124 15 is_true_threads 0 4 219 23 Thread::is_true_threads 0 1 14 196</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a real threading library is available that supports actual</span>
 <span class="s0">* OS-implemented threads, or false if the only threading we can provide is</span>
 <span class="s0">* simulated user-space threading.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static inline bool Thread::is_true_threads(void);</span>

<span class="s0">125 17 is_simple_threads 0 4 219 25 Thread::is_simple_threads 0 1 15 393</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if Panda is currently compiled for &quot;simple threads&quot;, which is</span>
 <span class="s0">* to say, cooperative context switching only, reducing the need for quite so</span>
 <span class="s0">* many critical section protections.  This is not necessarily the opposite of</span>
 <span class="s0">* &quot;true threads&quot;, since one possible implementation of simple threads is via</span>
 <span class="s0">* true threads with mutex protection to ensure only one runs at a time.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline bool Thread::is_simple_threads(void);</span>

<span class="s0">126 5 sleep 0 4 219 13 Thread::sleep 0 1 16 119</span>
<span class="s0">/**</span>
 <span class="s0">* Suspends the current thread for at least the indicated amount of time.  It</span>
 <span class="s0">* might be suspended for longer.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static inline void Thread::sleep(double seconds);</span>

<span class="s0">127 11 force_yield 0 4 219 19 Thread::force_yield 0 1 17 73</span>
<span class="s0">/**</span>
 <span class="s0">* Suspends the current thread for the rest of the current epoch.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static inline void Thread::force_yield(void);</span>

<span class="s0">128 14 consider_yield 0 4 219 22 Thread::consider_yield 0 1 18 239</span>
<span class="s0">/**</span>
 <span class="s0">* Possibly suspends the current thread for the rest of the current epoch, if</span>
 <span class="s0">* it has run for enough this epoch.  This is especially important for the</span>
 <span class="s0">* simple thread implementation, which relies on cooperative yields like this.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">static inline void Thread::consider_yield(void);</span>

<span class="s0">129 6 output 0 6 219 14 Thread::output 0 1 19 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">virtual void Thread::output(std::ostream &amp;out) const;</span>

<span class="s0">130 14 output_blocker 0 4 219 22 Thread::output_blocker 0 1 20 184</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a description of the mutex or condition variable that this thread is</span>
 <span class="s0">* blocked on.  Writes nothing if there is no blocker, or if we are not in</span>
 <span class="s0">* DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void Thread::output_blocker(std::ostream &amp;out) const;</span>

<span class="s0">131 12 write_status 0 4 219 20 Thread::write_status 0 1 21 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static void Thread::write_status(std::ostream &amp;out);</span>

<span class="s0">132 10 is_started 0 4 219 18 Thread::is_started 0 1 22 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the thread has been started, false if it has not, or if</span>
 <span class="s0">* join() has already been called.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool Thread::is_started(void) const;</span>

<span class="s0">133 11 is_joinable 0 4 219 19 Thread::is_joinable 0 1 23 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value of joinable that was passed to the start() call.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool Thread::is_joinable(void) const;</span>

<span class="s0">134 5 start 0 4 219 13 Thread::start 0 1 24 862</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the thread executing.  It is only valid to call this once.</span>
 <span class="s0">*</span>
 <span class="s0">* The thread will begin executing its thread_main() function, and will</span>
 <span class="s0">* terminate when thread_main() returns.</span>
 <span class="s0">*</span>
 <span class="s0">* priority is intended as a hint to the relative importance of this thread.</span>
 <span class="s0">* This may be ignored by the thread implementation.</span>
 <span class="s0">*</span>
 <span class="s0">* joinable should be set true if you intend to call join() to wait for the</span>
 <span class="s0">* thread to terminate, or false if you don't care and you will never call</span>
 <span class="s0">* join(). Note that the reference count on the Thread object is incremented</span>
 <span class="s0">* while the thread itself is running, so if you just want to fire and forget</span>
 <span class="s0">* a thread, you may pass joinable = false, and never store the Thread object.</span>
 <span class="s0">* It will automatically destruct itself when it finishes.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the thread is successfully started, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">bool Thread::start(ThreadPriority priority, bool joinable);</span>

<span class="s0">135 4 join 0 4 219 12 Thread::join 0 1 25 134</span>
<span class="s0">/**</span>
 <span class="s0">* Blocks the calling process until the thread terminates.  If the thread has</span>
 <span class="s0">* already terminated, this returns immediately.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">inline void Thread::join(void);</span>

<span class="s0">136 7 preempt 0 4 219 15 Thread::preempt 0 1 26 183</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that this thread should run as soon as possible, preemptying any</span>
 <span class="s0">* other threads that may be scheduled to run.  This may not be implemented on</span>
 <span class="s0">* every platform.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">inline void Thread::preempt(void);</span>

<span class="s0">137 16 get_current_task 0 4 219 24 Thread::get_current_task 0 1 27 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the task currently executing on this thread (via the</span>
 <span class="s0">* AsyncTaskManager), if any, or NULL if the thread is not currently servicing</span>
 <span class="s0">* a task.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline TypedReferenceCount *Thread::get_current_task(void) const;</span>

<span class="s0">138 16 set_python_index 0 4 219 24 Thread::set_python_index 0 1 28 160</span>
<span class="s0">/**</span>
 <span class="s0">* Stores a Python index to be associated with this thread.  This is used</span>
 <span class="s0">* internally by the thread module; you should not need to call this directly.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void Thread::set_python_index(int index);</span>

<span class="s0">139 16 prepare_for_exit 0 4 219 24 Thread::prepare_for_exit 0 1 29 143</span>
<span class="s0">/**</span>
 <span class="s0">* Should be called by the main thread just before exiting the program, this</span>
 <span class="s0">* blocks until any remaining thread cleanup has finished.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static inline void Thread::prepare_for_exit(void);</span>

<span class="s0">140 14 get_class_type 0 4 219 22 Thread::get_class_type 0 1 30 0</span>
<span class="s0">47</span>
<span class="s0">static TypeHandle Thread::get_class_type(void);</span>

<span class="s0">141 7 acquire 0 4 229 20 MutexDirect::acquire 0 1 33 405</span>
<span class="s0">/**</span>
 <span class="s0">* Grabs the mutex if it is available.  If it is not available, blocks until</span>
 <span class="s0">* it becomes available, then grabs it.  In either case, the function does not</span>
 <span class="s0">* return until the mutex is held; you should then call unlock().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* mutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see MutexHolder.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void MutexDirect::acquire(void) const;</span>

<span class="s0">142 11 try_acquire 0 4 229 24 MutexDirect::try_acquire 0 1 34 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns immediately, with a true value indicating the mutex has been</span>
 <span class="s0">* acquired, and false indicating it has not.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool MutexDirect::try_acquire(void) const;</span>

<span class="s0">143 7 release 0 4 229 20 MutexDirect::release 0 1 35 247</span>
<span class="s0">/**</span>
 <span class="s0">* Releases the mutex.  It is an error to call this if the mutex was not</span>
 <span class="s0">* already locked.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* mutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void MutexDirect::release(void) const;</span>

<span class="s0">144 15 debug_is_locked 0 4 229 28 MutexDirect::debug_is_locked 0 1 36 278</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the current thread has locked the Mutex, false otherwise.</span>
 <span class="s0">* This method is only intended for use in debugging, hence the method name;</span>
 <span class="s0">* in the MutexDirect case, it always returns true, since there's not a</span>
 <span class="s0">* reliable way to determine this otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool MutexDirect::debug_is_locked(void) const;</span>

<span class="s0">145 8 set_name 0 4 229 21 MutexDirect::set_name 0 1 37 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void MutexDirect::set_name(std::string const &amp;name);</span>

<span class="s0">146 10 clear_name 0 4 229 23 MutexDirect::clear_name 0 1 38 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void MutexDirect::clear_name(void);</span>

<span class="s0">147 8 has_name 0 4 229 21 MutexDirect::has_name 0 1 39 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool MutexDirect::has_name(void) const;</span>

<span class="s0">148 8 get_name 0 4 229 21 MutexDirect::get_name 0 1 40 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::string MutexDirect::get_name(void) const;</span>

<span class="s0">149 6 output 0 4 229 19 MutexDirect::output 0 1 41 92</span>
<span class="s0">/**</span>
 <span class="s0">* This method is declared virtual in MutexDebug, but non-virtual in</span>
 <span class="s0">* MutexDirect.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void MutexDirect::output(std::ostream &amp;out) const;</span>

<span class="s0">150 5 Mutex 0 260 230 12 Mutex::Mutex 0 2 42 43 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline Mutex::Mutex(void);</span>
<span class="s0">inline explicit Mutex::Mutex(std::string const &amp;name);</span>

<span class="s0">151 6 ~Mutex 0 516 230 13 Mutex::~Mutex 0 0 0</span>
<span class="s0">30</span>
<span class="s0">Mutex::~Mutex(void) = default;</span>

<span class="s0">152 19 ~ConditionVarDirect 0 516 231 39 ConditionVarDirect::~ConditionVarDirect 0 0 0</span>
<span class="s0">56</span>
<span class="s0">ConditionVarDirect::~ConditionVarDirect(void) = default;</span>

<span class="s0">153 9 get_mutex 0 4 231 29 ConditionVarDirect::get_mutex 0 1 44 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the mutex associated with this condition variable.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline MutexDirect &amp;ConditionVarDirect::get_mutex(void) const;</span>

<span class="s0">154 4 wait 0 4 231 24 ConditionVarDirect::wait 0 2 45 46 1192</span>
<span class="s0">/**</span>
 <span class="s0">* Waits on the condition.  The caller must already be holding the lock</span>
 <span class="s0">* associated with the condition variable before calling this function.</span>
 <span class="s0">*</span>
 <span class="s0">* wait() will release the lock, then go to sleep until some other thread</span>
 <span class="s0">* calls notify() on this condition variable.  At that time at least one</span>
 <span class="s0">* thread waiting on the same ConditionVarDirect will grab the lock again, and</span>
 <span class="s0">* then return from wait().</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible that wait() will return even if no one has called notify().</span>
 <span class="s0">* It is the responsibility of the calling process to verify the condition on</span>
 <span class="s0">* return from wait, and possibly loop back to wait again if necessary.</span>
 <span class="s0">*</span>
 <span class="s0">* Note the semantics of a condition variable: the mutex must be held before</span>
 <span class="s0">* wait() is called, and it will still be held when wait() returns.  However,</span>
 <span class="s0">* it will be temporarily released during the wait() call itself.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Waits on the condition, with a timeout.  The function will return when the</span>
 <span class="s0">* condition variable is notified, or the timeout occurs.  There is no way to</span>
 <span class="s0">* directly tell which happened, and it is possible that neither in fact</span>
 <span class="s0">* happened (spurious wakeups are possible).</span>
 <span class="s0">*</span>
 <span class="s0">* See wait() with no parameters for more.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">inline void ConditionVarDirect::wait(void);</span>
<span class="s0">inline void ConditionVarDirect::wait(double timeout);</span>

<span class="s0">155 6 notify 0 4 231 26 ConditionVarDirect::notify 0 1 47 542</span>
<span class="s0">/**</span>
 <span class="s0">* Informs one of the other threads who are currently blocked on wait() that</span>
 <span class="s0">* the relevant condition has changed.  If multiple threads are currently</span>
 <span class="s0">* waiting, at least one of them will be woken up, although there is no way to</span>
 <span class="s0">* predict which one.  It is possible that more than one thread will be woken</span>
 <span class="s0">* up.</span>
 <span class="s0">*</span>
 <span class="s0">* The caller must be holding the mutex associated with the condition variable</span>
 <span class="s0">* before making this call, which will not release the mutex.</span>
 <span class="s0">*</span>
 <span class="s0">* If no threads are waiting, this is a no-op: the notify event is lost.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void ConditionVarDirect::notify(void);</span>

<span class="s0">156 6 output 0 4 231 26 ConditionVarDirect::output 0 1 48 106</span>
<span class="s0">/**</span>
 <span class="s0">* This method is declared virtual in ConditionVarDebug, but non-virtual in</span>
 <span class="s0">* ConditionVarDirect.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void ConditionVarDirect::output(std::ostream &amp;out) const;</span>

<span class="s0">157 12 ConditionVar 0 260 232 26 ConditionVar::ConditionVar 0 1 49 278</span>
<span class="s0">/**</span>
 <span class="s0">* You must pass in a Mutex to the condition variable constructor.  This mutex</span>
 <span class="s0">* may be shared by other condition variables, if desired.  It is the caller's</span>
 <span class="s0">* responsibility to ensure the Mutex object does not destruct during the</span>
 <span class="s0">* lifetime of the condition variable.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline explicit ConditionVar::ConditionVar(Mutex &amp;mutex);</span>

<span class="s0">158 13 ~ConditionVar 0 516 232 27 ConditionVar::~ConditionVar 0 0 0</span>
<span class="s0">44</span>
<span class="s0">ConditionVar::~ConditionVar(void) = default;</span>

<span class="s0">159 9 get_mutex 0 4 232 23 ConditionVar::get_mutex 0 1 50 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the mutex associated with this condition variable.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline Mutex &amp;ConditionVar::get_mutex(void) const;</span>

<span class="s0">160 23 ~ConditionVarFullDirect 0 516 233 47 ConditionVarFullDirect::~ConditionVarFullDirect 0 0 0</span>
<span class="s0">64</span>
<span class="s0">ConditionVarFullDirect::~ConditionVarFullDirect(void) = default;</span>

<span class="s0">161 9 get_mutex 0 4 233 33 ConditionVarFullDirect::get_mutex 0 1 51 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the mutex associated with this condition variable.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline MutexDirect &amp;ConditionVarFullDirect::get_mutex(void) const;</span>

<span class="s0">162 4 wait 0 4 233 28 ConditionVarFullDirect::wait 0 2 52 53 1196</span>
<span class="s0">/**</span>
 <span class="s0">* Waits on the condition.  The caller must already be holding the lock</span>
 <span class="s0">* associated with the condition variable before calling this function.</span>
 <span class="s0">*</span>
 <span class="s0">* wait() will release the lock, then go to sleep until some other thread</span>
 <span class="s0">* calls notify() on this condition variable.  At that time at least one</span>
 <span class="s0">* thread waiting on the same ConditionVarFullDirect will grab the lock again,</span>
 <span class="s0">* and then return from wait().</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible that wait() will return even if no one has called notify().</span>
 <span class="s0">* It is the responsibility of the calling process to verify the condition on</span>
 <span class="s0">* return from wait, and possibly loop back to wait again if necessary.</span>
 <span class="s0">*</span>
 <span class="s0">* Note the semantics of a condition variable: the mutex must be held before</span>
 <span class="s0">* wait() is called, and it will still be held when wait() returns.  However,</span>
 <span class="s0">* it will be temporarily released during the wait() call itself.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Waits on the condition, with a timeout.  The function will return when the</span>
 <span class="s0">* condition variable is notified, or the timeout occurs.  There is no way to</span>
 <span class="s0">* directly tell which happened, and it is possible that neither in fact</span>
 <span class="s0">* happened (spurious wakeups are possible).</span>
 <span class="s0">*</span>
 <span class="s0">* See wait() with no parameters for more.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">inline void ConditionVarFullDirect::wait(void);</span>
<span class="s0">inline void ConditionVarFullDirect::wait(double timeout);</span>

<span class="s0">163 6 notify 0 4 233 30 ConditionVarFullDirect::notify 0 1 54 536</span>
<span class="s0">/**</span>
 <span class="s0">* Informs one of the other threads who are currently blocked on wait() that</span>
 <span class="s0">* the relevant condition has changed.  If multiple threads are currently</span>
 <span class="s0">* waiting, at least one of them will be woken up, although there is no way to</span>
 <span class="s0">* predict which one.  It is possible that more than one thread will be woken</span>
 <span class="s0">* up.</span>
 <span class="s0">*</span>
 <span class="s0">* The caller must be holding the mutex associated with the condition variable</span>
 <span class="s0">* before making this call, which will not release the mutex.</span>
 <span class="s0">*</span>
 <span class="s0">* If no threads are waiting, this is a no-op: the notify is lost.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void ConditionVarFullDirect::notify(void);</span>

<span class="s0">164 10 notify_all 0 4 233 34 ConditionVarFullDirect::notify_all 0 1 55 343</span>
<span class="s0">/**</span>
 <span class="s0">* Informs all of the other threads who are currently blocked on wait() that</span>
 <span class="s0">* the relevant condition has changed.</span>
 <span class="s0">*</span>
 <span class="s0">* The caller must be holding the mutex associated with the condition variable</span>
 <span class="s0">* before making this call, which will not release the mutex.</span>
 <span class="s0">*</span>
 <span class="s0">* If no threads are waiting, this is a no-op: the notify event is lost.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void ConditionVarFullDirect::notify_all(void);</span>

<span class="s0">165 6 output 0 4 233 30 ConditionVarFullDirect::output 0 1 56 114</span>
<span class="s0">/**</span>
 <span class="s0">* This method is declared virtual in ConditionVarFullDebug, but non-virtual</span>
 <span class="s0">* in ConditionVarFullDirect.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void ConditionVarFullDirect::output(std::ostream &amp;out) const;</span>

<span class="s0">166 16 ConditionVarFull 0 260 234 34 ConditionVarFull::ConditionVarFull 0 1 57 278</span>
<span class="s0">/**</span>
 <span class="s0">* You must pass in a Mutex to the condition variable constructor.  This mutex</span>
 <span class="s0">* may be shared by other condition variables, if desired.  It is the caller's</span>
 <span class="s0">* responsibility to ensure the Mutex object does not destruct during the</span>
 <span class="s0">* lifetime of the condition variable.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline explicit ConditionVarFull::ConditionVarFull(Mutex &amp;mutex);</span>

<span class="s0">167 17 ~ConditionVarFull 0 516 234 35 ConditionVarFull::~ConditionVarFull 0 0 0</span>
<span class="s0">52</span>
<span class="s0">ConditionVarFull::~ConditionVarFull(void) = default;</span>

<span class="s0">168 9 get_mutex 0 4 234 27 ConditionVarFull::get_mutex 0 1 58 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the mutex associated with this condition variable.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline Mutex &amp;ConditionVarFull::get_mutex(void) const;</span>

<span class="s0">169 7 acquire 0 4 235 22 ReMutexDirect::acquire 0 2 59 60 541</span>
<span class="s0">/**</span>
 <span class="s0">* Grabs the reMutex if it is available.  If it is not available, blocks until</span>
 <span class="s0">* it becomes available, then grabs it.  In either case, the function does not</span>
 <span class="s0">* return until the reMutex is held; you should then call unlock().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* reMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see ReMutexHolder.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This variant on acquire() accepts the current thread as a parameter, if it</span>
 <span class="s0">* is already known, as an optimization.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">inline void ReMutexDirect::acquire(void) const;</span>
<span class="s0">inline void ReMutexDirect::acquire(Thread *current_thread) const;</span>

<span class="s0">170 11 try_acquire 0 4 235 26 ReMutexDirect::try_acquire 0 2 61 62 252</span>
<span class="s0">/**</span>
 <span class="s0">* Returns immediately, with a true value indicating the mutex has been</span>
 <span class="s0">* acquired, and false indicating it has not.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns immediately, with a true value indicating the mutex has been</span>
 <span class="s0">* acquired, and false indicating it has not.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">inline bool ReMutexDirect::try_acquire(void) const;</span>
<span class="s0">inline bool ReMutexDirect::try_acquire(Thread *current_thread) const;</span>

<span class="s0">171 12 elevate_lock 0 4 235 27 ReMutexDirect::elevate_lock 0 1 63 468</span>
<span class="s0">/**</span>
 <span class="s0">* This method increments the lock count, assuming the calling thread already</span>
 <span class="s0">* holds the lock.  After this call, release() will need to be called one</span>
 <span class="s0">* additional time to release the lock.</span>
 <span class="s0">*</span>
 <span class="s0">* This method really performs the same function as acquire(), but it offers a</span>
 <span class="s0">* potential (slight) performance benefit when the calling thread knows that</span>
 <span class="s0">* it already holds the lock.  It is an error to call this when the calling</span>
 <span class="s0">* thread does not hold the lock.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void ReMutexDirect::elevate_lock(void) const;</span>

<span class="s0">172 7 release 0 4 235 22 ReMutexDirect::release 0 1 64 253</span>
<span class="s0">/**</span>
 <span class="s0">* Releases the reMutex.  It is an error to call this if the reMutex was not</span>
 <span class="s0">* already locked.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* reMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void ReMutexDirect::release(void) const;</span>

<span class="s0">173 15 debug_is_locked 0 4 235 30 ReMutexDirect::debug_is_locked 0 1 65 282</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the current thread has locked the ReMutex, false otherwise.</span>
 <span class="s0">* This method is only intended for use in debugging, hence the method name;</span>
 <span class="s0">* in the ReMutexDirect case, it always returns true, since there's not a</span>
 <span class="s0">* reliable way to determine this otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool ReMutexDirect::debug_is_locked(void) const;</span>

<span class="s0">174 8 set_name 0 4 235 23 ReMutexDirect::set_name 0 1 66 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void ReMutexDirect::set_name(std::string const &amp;name);</span>

<span class="s0">175 10 clear_name 0 4 235 25 ReMutexDirect::clear_name 0 1 67 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void ReMutexDirect::clear_name(void);</span>

<span class="s0">176 8 has_name 0 4 235 23 ReMutexDirect::has_name 0 1 68 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool ReMutexDirect::has_name(void) const;</span>

<span class="s0">177 8 get_name 0 4 235 23 ReMutexDirect::get_name 0 1 69 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline std::string ReMutexDirect::get_name(void) const;</span>

<span class="s0">178 6 output 0 4 235 21 ReMutexDirect::output 0 1 70 94</span>
<span class="s0">/**</span>
 <span class="s0">* This method is declared virtual in MutexDebug, but non-virtual in</span>
 <span class="s0">* ReMutexDirect.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void ReMutexDirect::output(std::ostream &amp;out) const;</span>

<span class="s0">179 7 ReMutex 0 260 236 16 ReMutex::ReMutex 0 2 71 72 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline ReMutex::ReMutex(void);</span>
<span class="s0">inline explicit ReMutex::ReMutex(std::string const &amp;name);</span>

<span class="s0">180 8 ~ReMutex 0 516 236 17 ReMutex::~ReMutex 0 0 0</span>
<span class="s0">34</span>
<span class="s0">ReMutex::~ReMutex(void) = default;</span>

<span class="s0">181 14 get_class_type 0 4 237 30 ExternalThread::get_class_type 0 1 73 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle ExternalThread::get_class_type(void);</span>

<span class="s0">182 15 ~ExternalThread 0 516 237 31 ExternalThread::~ExternalThread 0 0 0</span>
<span class="s0">38</span>
<span class="s0">ExternalThread::~ExternalThread(void);</span>

<span class="s0">183 7 acquire 0 4 238 25 LightMutexDirect::acquire 0 1 74 428</span>
<span class="s0">/**</span>
 <span class="s0">* Grabs the lightMutex if it is available.  If it is not available, blocks</span>
 <span class="s0">* until it becomes available, then grabs it.  In either case, the function</span>
 <span class="s0">* does not return until the lightMutex is held; you should then call</span>
 <span class="s0">* unlock().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* lightMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see LightMutexHolder.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void LightMutexDirect::acquire(void) const;</span>

<span class="s0">184 7 release 0 4 238 25 LightMutexDirect::release 0 1 75 262</span>
<span class="s0">/**</span>
 <span class="s0">* Releases the lightMutex.  It is an error to call this if the lightMutex was</span>
 <span class="s0">* not already locked.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* lightMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void LightMutexDirect::release(void) const;</span>

<span class="s0">185 15 debug_is_locked 0 4 238 33 LightMutexDirect::debug_is_locked 0 1 76 289</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the current thread has locked the LightMutex, false</span>
 <span class="s0">* otherwise.  This method is only intended for use in debugging, hence the</span>
 <span class="s0">* method name; in the LightMutexDirect case, it always returns true, since</span>
 <span class="s0">* there's not a reliable way to determine this otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool LightMutexDirect::debug_is_locked(void) const;</span>

<span class="s0">186 8 set_name 0 4 238 26 LightMutexDirect::set_name 0 1 77 84</span>
<span class="s0">/**</span>
 <span class="s0">* The lightMutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void LightMutexDirect::set_name(std::string const &amp;name);</span>

<span class="s0">187 10 clear_name 0 4 238 28 LightMutexDirect::clear_name 0 1 78 84</span>
<span class="s0">/**</span>
 <span class="s0">* The lightMutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void LightMutexDirect::clear_name(void);</span>

<span class="s0">188 8 has_name 0 4 238 26 LightMutexDirect::has_name 0 1 79 84</span>
<span class="s0">/**</span>
 <span class="s0">* The lightMutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool LightMutexDirect::has_name(void) const;</span>

<span class="s0">189 8 get_name 0 4 238 26 LightMutexDirect::get_name 0 1 80 84</span>
<span class="s0">/**</span>
 <span class="s0">* The lightMutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline std::string LightMutexDirect::get_name(void) const;</span>

<span class="s0">190 6 output 0 4 238 24 LightMutexDirect::output 0 1 81 102</span>
<span class="s0">/**</span>
 <span class="s0">* This method is declared virtual in LightMutexDebug, but non-virtual in</span>
 <span class="s0">* LightMutexDirect.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void LightMutexDirect::output(std::ostream &amp;out) const;</span>

<span class="s0">191 10 LightMutex 0 260 239 22 LightMutex::LightMutex 0 2 82 83 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">inline LightMutex::LightMutex(void);</span>
<span class="s0">inline explicit LightMutex::LightMutex(std::string const &amp;name);</span>

<span class="s0">192 11 ~LightMutex 0 516 239 23 LightMutex::~LightMutex 0 0 0</span>
<span class="s0">40</span>
<span class="s0">LightMutex::~LightMutex(void) = default;</span>

<span class="s0">193 7 acquire 0 4 240 27 LightReMutexDirect::acquire 0 2 84 85 564</span>
<span class="s0">/**</span>
 <span class="s0">* Grabs the lightReMutex if it is available.  If it is not available, blocks</span>
 <span class="s0">* until it becomes available, then grabs it.  In either case, the function</span>
 <span class="s0">* does not return until the lightReMutex is held; you should then call</span>
 <span class="s0">* unlock().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* lightReMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see LightReMutexHolder.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This variant on acquire() accepts the current thread as a parameter, if it</span>
 <span class="s0">* is already known, as an optimization.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void LightReMutexDirect::acquire(void) const;</span>
<span class="s0">inline void LightReMutexDirect::acquire(Thread *current_thread) const;</span>

<span class="s0">194 12 elevate_lock 0 4 240 32 LightReMutexDirect::elevate_lock 0 1 86 468</span>
<span class="s0">/**</span>
 <span class="s0">* This method increments the lock count, assuming the calling thread already</span>
 <span class="s0">* holds the lock.  After this call, release() will need to be called one</span>
 <span class="s0">* additional time to release the lock.</span>
 <span class="s0">*</span>
 <span class="s0">* This method really performs the same function as acquire(), but it offers a</span>
 <span class="s0">* potential (slight) performance benefit when the calling thread knows that</span>
 <span class="s0">* it already holds the lock.  It is an error to call this when the calling</span>
 <span class="s0">* thread does not hold the lock.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void LightReMutexDirect::elevate_lock(void) const;</span>

<span class="s0">195 7 release 0 4 240 27 LightReMutexDirect::release 0 1 87 268</span>
<span class="s0">/**</span>
 <span class="s0">* Releases the lightReMutex.  It is an error to call this if the lightReMutex</span>
 <span class="s0">* was not already locked.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* lightReMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void LightReMutexDirect::release(void) const;</span>

<span class="s0">196 15 debug_is_locked 0 4 240 35 LightReMutexDirect::debug_is_locked 0 1 88 293</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the current thread has locked the LightReMutex, false</span>
 <span class="s0">* otherwise.  This method is only intended for use in debugging, hence the</span>
 <span class="s0">* method name; in the LightReMutexDirect case, it always returns true, since</span>
 <span class="s0">* there's not a reliable way to determine this otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool LightReMutexDirect::debug_is_locked(void) const;</span>

<span class="s0">197 8 set_name 0 4 240 28 LightReMutexDirect::set_name 0 1 89 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void LightReMutexDirect::set_name(std::string const &amp;name);</span>

<span class="s0">198 10 clear_name 0 4 240 30 LightReMutexDirect::clear_name 0 1 90 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void LightReMutexDirect::clear_name(void);</span>

<span class="s0">199 8 has_name 0 4 240 28 LightReMutexDirect::has_name 0 1 91 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool LightReMutexDirect::has_name(void) const;</span>

<span class="s0">200 8 get_name 0 4 240 28 LightReMutexDirect::get_name 0 1 92 79</span>
<span class="s0">/**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline std::string LightReMutexDirect::get_name(void) const;</span>

<span class="s0">201 6 output 0 4 240 26 LightReMutexDirect::output 0 1 93 99</span>
<span class="s0">/**</span>
 <span class="s0">* This method is declared virtual in MutexDebug, but non-virtual in</span>
 <span class="s0">* LightReMutexDirect.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void LightReMutexDirect::output(std::ostream &amp;out) const;</span>

<span class="s0">202 12 LightReMutex 0 260 241 26 LightReMutex::LightReMutex 0 2 94 95 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">inline LightReMutex::LightReMutex(void);</span>
<span class="s0">inline explicit LightReMutex::LightReMutex(std::string const &amp;name);</span>

<span class="s0">203 13 ~LightReMutex 0 516 241 27 LightReMutex::~LightReMutex 0 0 0</span>
<span class="s0">44</span>
<span class="s0">LightReMutex::~LightReMutex(void) = default;</span>

<span class="s0">204 14 get_class_type 0 4 242 26 MainThread::get_class_type 0 1 96 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle MainThread::get_class_type(void);</span>

<span class="s0">205 11 ~MainThread 0 516 242 23 MainThread::~MainThread 0 0 0</span>
<span class="s0">30</span>
<span class="s0">MainThread::~MainThread(void);</span>

<span class="s0">206 9 Semaphore 0 260 243 20 Semaphore::Semaphore 0 1 97 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline explicit Semaphore::Semaphore(int initial_count = 1);</span>

<span class="s0">207 10 ~Semaphore 0 516 243 21 Semaphore::~Semaphore 0 0 0</span>
<span class="s0">38</span>
<span class="s0">Semaphore::~Semaphore(void) = default;</span>

<span class="s0">208 7 acquire 0 4 243 18 Semaphore::acquire 0 1 98 134</span>
<span class="s0">/**</span>
 <span class="s0">* Decrements the internal count.  If the count was already at zero, blocks</span>
 <span class="s0">* until the count is nonzero, then decrements it.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">inline void Semaphore::acquire(void);</span>

<span class="s0">209 11 try_acquire 0 4 243 22 Semaphore::try_acquire 0 1 99 117</span>
<span class="s0">/**</span>
 <span class="s0">* If the semaphore can be acquired without blocking, does so and returns</span>
 <span class="s0">* true.  Otherwise, returns false.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline bool Semaphore::try_acquire(void);</span>

<span class="s0">210 7 release 0 4 243 18 Semaphore::release 0 1 100 166</span>
<span class="s0">/**</span>
 <span class="s0">* Increments the semaphore's internal count.  This may wake up another thread</span>
 <span class="s0">* blocked on acquire().</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the count of the semaphore upon release.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">inline int Semaphore::release(void);</span>

<span class="s0">211 9 get_count 0 4 243 20 Semaphore::get_count 0 1 101 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current semaphore count.  Note that this call is not thread-</span>
 <span class="s0">* safe (the count may change at any time).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline int Semaphore::get_count(void) const;</span>

<span class="s0">212 6 output 0 4 243 17 Semaphore::output 0 1 102 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void Semaphore::output(std::ostream &amp;out) const;</span>

<span class="s0">213 12 PythonThread 0 260 244 26 PythonThread::PythonThread 0 1 103 0</span>
<span class="s0">127</span>
<span class="s0">explicit PythonThread::PythonThread(PyObject *function, PyObject *args, std::string const &amp;name, std::string const &amp;sync_name);</span>

<span class="s0">214 4 join 0 4 244 18 PythonThread::join 0 1 104 0</span>
<span class="s0">35</span>
<span class="s0">PyObject *PythonThread::join(void);</span>

<span class="s0">215 8 get_args 0 4 244 22 PythonThread::get_args 0 0 0</span>
<span class="s0">45</span>
<span class="s0">PyObject *PythonThread::get_args(void) const;</span>

<span class="s0">216 8 set_args 0 4 244 22 PythonThread::set_args 0 0 0</span>
<span class="s0">40</span>
<span class="s0">void PythonThread::set_args(PyObject *);</span>

<span class="s0">217 14 get_class_type 0 4 244 28 PythonThread::get_class_type 0 1 105 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle PythonThread::get_class_type(void);</span>

<span class="s0">105</span>
<span class="s0">1 0 0 7 10 226 110 0 952 /**</span>
 <span class="s0">* Returns a new Panda Thread object associated with the current thread (which</span>
 <span class="s0">* has been created externally). This can be used to bind a unique Panda</span>
 <span class="s0">* Thread object with an external thread, such as a new Python thread.</span>
 <span class="s0">*</span>
 <span class="s0">* It is particularly useful to bind a Panda Thread object to an external</span>
 <span class="s0">* thread for the purposes of PStats monitoring.  Without this call, each</span>
 <span class="s0">* external thread will be assigned the same global ExternalThread object,</span>
 <span class="s0">* which means they will all appear in the same PStats graph.</span>
 <span class="s0">*</span>
 <span class="s0">* It is the caller's responsibility to save the returned Thread pointer for</span>
 <span class="s0">* the lifetime of the external thread.  It is an error for the Thread pointer</span>
 <span class="s0">* to destruct while the external thread is still in the system.</span>
 <span class="s0">*</span>
 <span class="s0">* It is also an error to call this method from the main thread, or twice</span>
 <span class="s0">* within a given thread, unless it is given the same name each time (in which</span>
 <span class="s0">* case the same pointer will be returned each time).</span>
 <span class="s0">*/ 2 4 name 1 248  9 sync_name 1 248  </span>
<span class="s0">2 0 0 6 11 248 0 0 279 /**</span>
 <span class="s0">* Returns the sync name of the thread.  This name collects threads into &quot;sync</span>
 <span class="s0">* groups&quot;, which are expected to run synchronously.  This is mainly used for</span>
 <span class="s0">* the benefit of PStats; threads with the same sync name can be ticked all at</span>
 <span class="s0">* once via the thread_tick() call.</span>
 <span class="s0">*/ 1 4 this 3 249  </span>
<span class="s0">3 0 0 6 12 225 0 0 218 /**</span>
 <span class="s0">* Returns the PStats index associated with this thread, or -1 if no index has</span>
 <span class="s0">* yet been associated with this thread.  This is used internally by the</span>
 <span class="s0">* PStatClient; you should not need to call this directly.</span>
 <span class="s0">*/ 1 4 this 3 249  </span>
<span class="s0">4 0 0 6 13 225 0 0 233 /**</span>
 <span class="s0">* Returns the Python index associated with this thread, or -1 if no index has</span>
 <span class="s0">* yet been associated with this thread.  This is used internally by the</span>
 <span class="s0">* direct.stdpy.thread module; you should not need to call this directly.</span>
 <span class="s0">*/ 1 4 this 3 249  </span>
<span class="s0">5 0 0 6 14 248 0 0 161 /**</span>
 <span class="s0">* Returns a string that is guaranteed to be unique to this thread, across all</span>
 <span class="s0">* processes on the machine, during at least the lifetime of this process.</span>
 <span class="s0">*/ 1 4 this 3 249  </span>
<span class="s0">6 0 0 6 15 225 0 0 163 /**</span>
 <span class="s0">* Returns the Pipeline stage number associated with this thread.  The default</span>
 <span class="s0">* stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().</span>
 <span class="s0">*/ 1 4 this 3 249  </span>
<span class="s0">7 0 0 4 16 251 0 0 479 /**</span>
 <span class="s0">* Specifies the Pipeline stage number associated with this thread.  The</span>
 <span class="s0">* default stage is 0 if no stage is specified otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This must be a value in the range [0 .. pipeline-&gt;get_num_stages() - 1].</span>
 <span class="s0">* It specifies the values that this thread observes for all pipelined data.</span>
 <span class="s0">* Typically, an application thread will leave this at 0, but a render thread</span>
 <span class="s0">* may set it to 1 or 2 (to operate on the previous frame's data, or the</span>
 <span class="s0">* second previous frame's data).</span>
 <span class="s0">*/ 2 4 this 3 226  14 pipeline_stage 1 225  </span>
<span class="s0">8 0 0 4 17 251 0 0 143 /**</span>
 <span class="s0">* Sets this thread's pipeline stage number to at least the indicated value,</span>
 <span class="s0">* unless it is already larger.  See set_pipeline_stage().</span>
 <span class="s0">*/ 2 4 this 3 226  18 min_pipeline_stage 1 225  </span>
<span class="s0">9 0 0 7 18 226 110 0 111 /**</span>
 <span class="s0">* Returns a pointer to the &quot;main&quot; Thread object--this is the Thread that</span>
 <span class="s0">* started the whole process.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">10 0 0 7 19 226 110 0 248 /**</span>
 <span class="s0">* Returns a pointer to the &quot;external&quot; Thread object--this is a special Thread</span>
 <span class="s0">* object that corresponds to any thread spawned outside of Panda's threading</span>
 <span class="s0">* interface.  Note that multiple different threads may share this same</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">11 0 0 7 20 226 110 0 415 /**</span>
 <span class="s0">* Returns a pointer to the currently-executing Thread object.  If this is</span>
 <span class="s0">* called from the main thread, this will return the same value as</span>
 <span class="s0">* get_main_thread().</span>
 <span class="s0">*</span>
 <span class="s0">* This will always return some valid Thread pointer.  It will never return</span>
 <span class="s0">* NULL, even if the current thread was spawned outside of Panda's threading</span>
 <span class="s0">* system, although all non-Panda threads will return the exact same Thread</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">12 0 0 6 21 225 0 0 208 /**</span>
 <span class="s0">* Returns the integer pipeline stage associated with the current thread.</span>
 <span class="s0">* This is the same thing as get_current_thread()-&gt;get_pipeline_stage(), but</span>
 <span class="s0">* it may be faster to retrieve in some contexts.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">13 0 0 6 22 227 0 0 159 /**</span>
 <span class="s0">* Returns true if threading support has been compiled in and enabled, or</span>
 <span class="s0">* false if no threading is available (and Thread::start() will always fail).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">14 0 0 6 23 227 0 0 196 /**</span>
 <span class="s0">* Returns true if a real threading library is available that supports actual</span>
 <span class="s0">* OS-implemented threads, or false if the only threading we can provide is</span>
 <span class="s0">* simulated user-space threading.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">15 0 0 6 24 227 0 0 393 /**</span>
 <span class="s0">* Returns true if Panda is currently compiled for &quot;simple threads&quot;, which is</span>
 <span class="s0">* to say, cooperative context switching only, reducing the need for quite so</span>
 <span class="s0">* many critical section protections.  This is not necessarily the opposite of</span>
 <span class="s0">* &quot;true threads&quot;, since one possible implementation of simple threads is via</span>
 <span class="s0">* true threads with mutex protection to ensure only one runs at a time.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">16 0 0 4 25 251 0 0 119 /**</span>
 <span class="s0">* Suspends the current thread for at least the indicated amount of time.  It</span>
 <span class="s0">* might be suspended for longer.</span>
 <span class="s0">*/ 1 7 seconds 1 252  </span>
<span class="s0">17 0 0 4 26 251 0 0 73 /**</span>
 <span class="s0">* Suspends the current thread for the rest of the current epoch.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">18 0 0 4 27 251 0 0 239 /**</span>
 <span class="s0">* Possibly suspends the current thread for the rest of the current epoch, if</span>
 <span class="s0">* it has run for enough this epoch.  This is especially important for the</span>
 <span class="s0">* simple thread implementation, which relies on cooperative yields like this.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">19 0 0 4 28 251 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 249  3 out 1 253  </span>
<span class="s0">20 0 0 4 29 251 0 0 184 /**</span>
 <span class="s0">* Writes a description of the mutex or condition variable that this thread is</span>
 <span class="s0">* blocked on.  Writes nothing if there is no blocker, or if we are not in</span>
 <span class="s0">* DEBUG_THREADS mode.</span>
 <span class="s0">*/ 2 4 this 3 249  3 out 1 253  </span>
<span class="s0">21 0 0 4 30 251 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 3 out 1 253  </span>
<span class="s0">22 0 0 6 31 227 0 0 117 /**</span>
 <span class="s0">* Returns true if the thread has been started, false if it has not, or if</span>
 <span class="s0">* join() has already been called.</span>
 <span class="s0">*/ 1 4 this 3 249  </span>
<span class="s0">23 0 0 6 32 227 0 0 77 /**</span>
 <span class="s0">* Returns the value of joinable that was passed to the start() call.</span>
 <span class="s0">*/ 1 4 this 3 249  </span>
<span class="s0">24 0 0 6 33 227 0 0 862 /**</span>
 <span class="s0">* Starts the thread executing.  It is only valid to call this once.</span>
 <span class="s0">*</span>
 <span class="s0">* The thread will begin executing its thread_main() function, and will</span>
 <span class="s0">* terminate when thread_main() returns.</span>
 <span class="s0">*</span>
 <span class="s0">* priority is intended as a hint to the relative importance of this thread.</span>
 <span class="s0">* This may be ignored by the thread implementation.</span>
 <span class="s0">*</span>
 <span class="s0">* joinable should be set true if you intend to call join() to wait for the</span>
 <span class="s0">* thread to terminate, or false if you don't care and you will never call</span>
 <span class="s0">* join(). Note that the reference count on the Thread object is incremented</span>
 <span class="s0">* while the thread itself is running, so if you just want to fire and forget</span>
 <span class="s0">* a thread, you may pass joinable = false, and never store the Thread object.</span>
 <span class="s0">* It will automatically destruct itself when it finishes.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the thread is successfully started, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 3 4 this 3 226  8 priority 1 218  8 joinable 1 227  </span>
<span class="s0">25 0 0 4 34 251 0 0 134 /**</span>
 <span class="s0">* Blocks the calling process until the thread terminates.  If the thread has</span>
 <span class="s0">* already terminated, this returns immediately.</span>
 <span class="s0">*/ 1 4 this 3 226  </span>
<span class="s0">26 0 0 4 35 251 0 0 183 /**</span>
 <span class="s0">* Indicates that this thread should run as soon as possible, preemptying any</span>
 <span class="s0">* other threads that may be scheduled to run.  This may not be implemented on</span>
 <span class="s0">* every platform.</span>
 <span class="s0">*/ 1 4 this 3 226  </span>
<span class="s0">27 0 0 7 36 228 0 0 161 /**</span>
 <span class="s0">* Returns the task currently executing on this thread (via the</span>
 <span class="s0">* AsyncTaskManager), if any, or NULL if the thread is not currently servicing</span>
 <span class="s0">* a task.</span>
 <span class="s0">*/ 1 4 this 3 249  </span>
<span class="s0">28 0 0 4 37 251 0 0 160 /**</span>
 <span class="s0">* Stores a Python index to be associated with this thread.  This is used</span>
 <span class="s0">* internally by the thread module; you should not need to call this directly.</span>
 <span class="s0">*/ 2 4 this 3 226  5 index 1 225  </span>
<span class="s0">29 0 0 4 38 251 0 0 143 /**</span>
 <span class="s0">* Should be called by the main thread just before exiting the program, this</span>
 <span class="s0">* blocks until any remaining thread cleanup has finished.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">30 0 0 7 61 256 0 0 0 0 </span>
<span class="s0">31 0 0 7 4 228 0 0 0 1 4 this 3 226  </span>
<span class="s0">32 0 0 6 7 257 0 0 0 1 4 this 3 226  </span>
<span class="s0">33 0 0 4 63 251 0 0 405 /**</span>
 <span class="s0">* Grabs the mutex if it is available.  If it is not available, blocks until</span>
 <span class="s0">* it becomes available, then grabs it.  In either case, the function does not</span>
 <span class="s0">* return until the mutex is held; you should then call unlock().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* mutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see MutexHolder.</span>
 <span class="s0">*/ 1 4 this 3 258  </span>
<span class="s0">34 0 0 6 64 227 0 0 125 /**</span>
 <span class="s0">* Returns immediately, with a true value indicating the mutex has been</span>
 <span class="s0">* acquired, and false indicating it has not.</span>
 <span class="s0">*/ 1 4 this 3 258  </span>
<span class="s0">35 0 0 4 65 251 0 0 247 /**</span>
 <span class="s0">* Releases the mutex.  It is an error to call this if the mutex was not</span>
 <span class="s0">* already locked.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* mutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*/ 1 4 this 3 258  </span>
<span class="s0">36 0 0 6 66 227 0 0 278 /**</span>
 <span class="s0">* Returns true if the current thread has locked the Mutex, false otherwise.</span>
 <span class="s0">* This method is only intended for use in debugging, hence the method name;</span>
 <span class="s0">* in the MutexDirect case, it always returns true, since there's not a</span>
 <span class="s0">* reliable way to determine this otherwise.</span>
 <span class="s0">*/ 1 4 this 3 258  </span>
<span class="s0">37 0 0 4 67 251 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 2 4 this 3 260  4 name 1 248  </span>
<span class="s0">38 0 0 4 68 251 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 260  </span>
<span class="s0">39 0 0 6 69 227 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 258  </span>
<span class="s0">40 0 0 6 70 248 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 258  </span>
<span class="s0">41 0 0 4 71 251 0 0 92 /**</span>
 <span class="s0">* This method is declared virtual in MutexDebug, but non-virtual in</span>
 <span class="s0">* MutexDirect.</span>
 <span class="s0">*/ 2 4 this 3 258  3 out 1 253  </span>
<span class="s0">42 0 0 7 73 261 151 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">43 0 0 7 73 261 151 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 248  </span>
<span class="s0">44 0 0 6 77 260 0 0 69 /**</span>
 <span class="s0">* Returns the mutex associated with this condition variable.</span>
 <span class="s0">*/ 1 4 this 3 262  </span>
<span class="s0">45 0 0 4 78 251 0 0 863 /**</span>
 <span class="s0">* Waits on the condition.  The caller must already be holding the lock</span>
 <span class="s0">* associated with the condition variable before calling this function.</span>
 <span class="s0">*</span>
 <span class="s0">* wait() will release the lock, then go to sleep until some other thread</span>
 <span class="s0">* calls notify() on this condition variable.  At that time at least one</span>
 <span class="s0">* thread waiting on the same ConditionVarDirect will grab the lock again, and</span>
 <span class="s0">* then return from wait().</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible that wait() will return even if no one has called notify().</span>
 <span class="s0">* It is the responsibility of the calling process to verify the condition on</span>
 <span class="s0">* return from wait, and possibly loop back to wait again if necessary.</span>
 <span class="s0">*</span>
 <span class="s0">* Note the semantics of a condition variable: the mutex must be held before</span>
 <span class="s0">* wait() is called, and it will still be held when wait() returns.  However,</span>
 <span class="s0">* it will be temporarily released during the wait() call itself.</span>
 <span class="s0">*/ 1 4 this 3 264  </span>
<span class="s0">46 0 0 4 78 251 0 0 327 /**</span>
 <span class="s0">* Waits on the condition, with a timeout.  The function will return when the</span>
 <span class="s0">* condition variable is notified, or the timeout occurs.  There is no way to</span>
 <span class="s0">* directly tell which happened, and it is possible that neither in fact</span>
 <span class="s0">* happened (spurious wakeups are possible).</span>
 <span class="s0">*</span>
 <span class="s0">* See wait() with no parameters for more.</span>
 <span class="s0">*/ 2 4 this 3 264  7 timeout 1 252  </span>
<span class="s0">47 0 0 4 79 251 0 0 542 /**</span>
 <span class="s0">* Informs one of the other threads who are currently blocked on wait() that</span>
 <span class="s0">* the relevant condition has changed.  If multiple threads are currently</span>
 <span class="s0">* waiting, at least one of them will be woken up, although there is no way to</span>
 <span class="s0">* predict which one.  It is possible that more than one thread will be woken</span>
 <span class="s0">* up.</span>
 <span class="s0">*</span>
 <span class="s0">* The caller must be holding the mutex associated with the condition variable</span>
 <span class="s0">* before making this call, which will not release the mutex.</span>
 <span class="s0">*</span>
 <span class="s0">* If no threads are waiting, this is a no-op: the notify event is lost.</span>
 <span class="s0">*/ 1 4 this 3 264  </span>
<span class="s0">48 0 0 4 80 251 0 0 106 /**</span>
 <span class="s0">* This method is declared virtual in ConditionVarDebug, but non-virtual in</span>
 <span class="s0">* ConditionVarDirect.</span>
 <span class="s0">*/ 2 4 this 3 262  3 out 1 253  </span>
<span class="s0">49 0 0 7 82 265 158 0 278 /**</span>
 <span class="s0">* You must pass in a Mutex to the condition variable constructor.  This mutex</span>
 <span class="s0">* may be shared by other condition variables, if desired.  It is the caller's</span>
 <span class="s0">* responsibility to ensure the Mutex object does not destruct during the</span>
 <span class="s0">* lifetime of the condition variable.</span>
 <span class="s0">*/ 1 5 mutex 1 261  </span>
<span class="s0">50 0 0 6 84 261 0 0 69 /**</span>
 <span class="s0">* Returns the mutex associated with this condition variable.</span>
 <span class="s0">*/ 1 4 this 3 266  </span>
<span class="s0">51 0 0 6 87 260 0 0 69 /**</span>
 <span class="s0">* Returns the mutex associated with this condition variable.</span>
 <span class="s0">*/ 1 4 this 3 268  </span>
<span class="s0">52 0 0 4 88 251 0 0 867 /**</span>
 <span class="s0">* Waits on the condition.  The caller must already be holding the lock</span>
 <span class="s0">* associated with the condition variable before calling this function.</span>
 <span class="s0">*</span>
 <span class="s0">* wait() will release the lock, then go to sleep until some other thread</span>
 <span class="s0">* calls notify() on this condition variable.  At that time at least one</span>
 <span class="s0">* thread waiting on the same ConditionVarFullDirect will grab the lock again,</span>
 <span class="s0">* and then return from wait().</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible that wait() will return even if no one has called notify().</span>
 <span class="s0">* It is the responsibility of the calling process to verify the condition on</span>
 <span class="s0">* return from wait, and possibly loop back to wait again if necessary.</span>
 <span class="s0">*</span>
 <span class="s0">* Note the semantics of a condition variable: the mutex must be held before</span>
 <span class="s0">* wait() is called, and it will still be held when wait() returns.  However,</span>
 <span class="s0">* it will be temporarily released during the wait() call itself.</span>
 <span class="s0">*/ 1 4 this 3 270  </span>
<span class="s0">53 0 0 4 88 251 0 0 327 /**</span>
 <span class="s0">* Waits on the condition, with a timeout.  The function will return when the</span>
 <span class="s0">* condition variable is notified, or the timeout occurs.  There is no way to</span>
 <span class="s0">* directly tell which happened, and it is possible that neither in fact</span>
 <span class="s0">* happened (spurious wakeups are possible).</span>
 <span class="s0">*</span>
 <span class="s0">* See wait() with no parameters for more.</span>
 <span class="s0">*/ 2 4 this 3 270  7 timeout 1 252  </span>
<span class="s0">54 0 0 4 89 251 0 0 536 /**</span>
 <span class="s0">* Informs one of the other threads who are currently blocked on wait() that</span>
 <span class="s0">* the relevant condition has changed.  If multiple threads are currently</span>
 <span class="s0">* waiting, at least one of them will be woken up, although there is no way to</span>
 <span class="s0">* predict which one.  It is possible that more than one thread will be woken</span>
 <span class="s0">* up.</span>
 <span class="s0">*</span>
 <span class="s0">* The caller must be holding the mutex associated with the condition variable</span>
 <span class="s0">* before making this call, which will not release the mutex.</span>
 <span class="s0">*</span>
 <span class="s0">* If no threads are waiting, this is a no-op: the notify is lost.</span>
 <span class="s0">*/ 1 4 this 3 270  </span>
<span class="s0">55 0 0 4 90 251 0 0 343 /**</span>
 <span class="s0">* Informs all of the other threads who are currently blocked on wait() that</span>
 <span class="s0">* the relevant condition has changed.</span>
 <span class="s0">*</span>
 <span class="s0">* The caller must be holding the mutex associated with the condition variable</span>
 <span class="s0">* before making this call, which will not release the mutex.</span>
 <span class="s0">*</span>
 <span class="s0">* If no threads are waiting, this is a no-op: the notify event is lost.</span>
 <span class="s0">*/ 1 4 this 3 270  </span>
<span class="s0">56 0 0 4 91 251 0 0 114 /**</span>
 <span class="s0">* This method is declared virtual in ConditionVarFullDebug, but non-virtual</span>
 <span class="s0">* in ConditionVarFullDirect.</span>
 <span class="s0">*/ 2 4 this 3 268  3 out 1 253  </span>
<span class="s0">57 0 0 7 93 271 167 0 278 /**</span>
 <span class="s0">* You must pass in a Mutex to the condition variable constructor.  This mutex</span>
 <span class="s0">* may be shared by other condition variables, if desired.  It is the caller's</span>
 <span class="s0">* responsibility to ensure the Mutex object does not destruct during the</span>
 <span class="s0">* lifetime of the condition variable.</span>
 <span class="s0">*/ 1 5 mutex 1 261  </span>
<span class="s0">58 0 0 6 95 261 0 0 69 /**</span>
 <span class="s0">* Returns the mutex associated with this condition variable.</span>
 <span class="s0">*/ 1 4 this 3 272  </span>
<span class="s0">59 0 0 4 97 251 0 0 413 /**</span>
 <span class="s0">* Grabs the reMutex if it is available.  If it is not available, blocks until</span>
 <span class="s0">* it becomes available, then grabs it.  In either case, the function does not</span>
 <span class="s0">* return until the reMutex is held; you should then call unlock().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* reMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see ReMutexHolder.</span>
 <span class="s0">*/ 1 4 this 3 274  </span>
<span class="s0">60 0 0 4 97 251 0 0 126 /**</span>
 <span class="s0">* This variant on acquire() accepts the current thread as a parameter, if it</span>
 <span class="s0">* is already known, as an optimization.</span>
 <span class="s0">*/ 2 4 this 3 274  14 current_thread 1 226  </span>
<span class="s0">61 0 0 6 98 227 0 0 125 /**</span>
 <span class="s0">* Returns immediately, with a true value indicating the mutex has been</span>
 <span class="s0">* acquired, and false indicating it has not.</span>
 <span class="s0">*/ 1 4 this 3 274  </span>
<span class="s0">62 0 0 6 98 227 0 0 125 /**</span>
 <span class="s0">* Returns immediately, with a true value indicating the mutex has been</span>
 <span class="s0">* acquired, and false indicating it has not.</span>
 <span class="s0">*/ 2 4 this 3 274  14 current_thread 1 226  </span>
<span class="s0">63 0 0 4 99 251 0 0 468 /**</span>
 <span class="s0">* This method increments the lock count, assuming the calling thread already</span>
 <span class="s0">* holds the lock.  After this call, release() will need to be called one</span>
 <span class="s0">* additional time to release the lock.</span>
 <span class="s0">*</span>
 <span class="s0">* This method really performs the same function as acquire(), but it offers a</span>
 <span class="s0">* potential (slight) performance benefit when the calling thread knows that</span>
 <span class="s0">* it already holds the lock.  It is an error to call this when the calling</span>
 <span class="s0">* thread does not hold the lock.</span>
 <span class="s0">*/ 1 4 this 3 274  </span>
<span class="s0">64 0 0 4 100 251 0 0 253 /**</span>
 <span class="s0">* Releases the reMutex.  It is an error to call this if the reMutex was not</span>
 <span class="s0">* already locked.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* reMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*/ 1 4 this 3 274  </span>
<span class="s0">65 0 0 6 101 227 0 0 282 /**</span>
 <span class="s0">* Returns true if the current thread has locked the ReMutex, false otherwise.</span>
 <span class="s0">* This method is only intended for use in debugging, hence the method name;</span>
 <span class="s0">* in the ReMutexDirect case, it always returns true, since there's not a</span>
 <span class="s0">* reliable way to determine this otherwise.</span>
 <span class="s0">*/ 1 4 this 3 274  </span>
<span class="s0">66 0 0 4 102 251 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 2 4 this 3 276  4 name 1 248  </span>
<span class="s0">67 0 0 4 103 251 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 276  </span>
<span class="s0">68 0 0 6 104 227 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 274  </span>
<span class="s0">69 0 0 6 105 248 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 274  </span>
<span class="s0">70 0 0 4 106 251 0 0 94 /**</span>
 <span class="s0">* This method is declared virtual in MutexDebug, but non-virtual in</span>
 <span class="s0">* ReMutexDirect.</span>
 <span class="s0">*/ 2 4 this 3 274  3 out 1 253  </span>
<span class="s0">71 0 0 7 108 277 180 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">72 0 0 7 108 277 180 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 248  </span>
<span class="s0">73 0 0 7 111 256 0 0 0 0 </span>
<span class="s0">74 0 0 4 114 251 0 0 428 /**</span>
 <span class="s0">* Grabs the lightMutex if it is available.  If it is not available, blocks</span>
 <span class="s0">* until it becomes available, then grabs it.  In either case, the function</span>
 <span class="s0">* does not return until the lightMutex is held; you should then call</span>
 <span class="s0">* unlock().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* lightMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see LightMutexHolder.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">75 0 0 4 115 251 0 0 262 /**</span>
 <span class="s0">* Releases the lightMutex.  It is an error to call this if the lightMutex was</span>
 <span class="s0">* not already locked.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* lightMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">76 0 0 6 116 227 0 0 289 /**</span>
 <span class="s0">* Returns true if the current thread has locked the LightMutex, false</span>
 <span class="s0">* otherwise.  This method is only intended for use in debugging, hence the</span>
 <span class="s0">* method name; in the LightMutexDirect case, it always returns true, since</span>
 <span class="s0">* there's not a reliable way to determine this otherwise.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">77 0 0 4 117 251 0 0 84 /**</span>
 <span class="s0">* The lightMutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 2 4 this 3 280  4 name 1 248  </span>
<span class="s0">78 0 0 4 118 251 0 0 84 /**</span>
 <span class="s0">* The lightMutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 280  </span>
<span class="s0">79 0 0 6 119 227 0 0 84 /**</span>
 <span class="s0">* The lightMutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">80 0 0 6 120 248 0 0 84 /**</span>
 <span class="s0">* The lightMutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 278  </span>
<span class="s0">81 0 0 4 121 251 0 0 102 /**</span>
 <span class="s0">* This method is declared virtual in LightMutexDebug, but non-virtual in</span>
 <span class="s0">* LightMutexDirect.</span>
 <span class="s0">*/ 2 4 this 3 278  3 out 1 253  </span>
<span class="s0">82 0 0 7 123 281 192 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">83 0 0 7 123 281 192 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 248  </span>
<span class="s0">84 0 0 4 126 251 0 0 436 /**</span>
 <span class="s0">* Grabs the lightReMutex if it is available.  If it is not available, blocks</span>
 <span class="s0">* until it becomes available, then grabs it.  In either case, the function</span>
 <span class="s0">* does not return until the lightReMutex is held; you should then call</span>
 <span class="s0">* unlock().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* lightReMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see LightReMutexHolder.</span>
 <span class="s0">*/ 1 4 this 3 282  </span>
<span class="s0">85 0 0 4 126 251 0 0 126 /**</span>
 <span class="s0">* This variant on acquire() accepts the current thread as a parameter, if it</span>
 <span class="s0">* is already known, as an optimization.</span>
 <span class="s0">*/ 2 4 this 3 282  14 current_thread 1 226  </span>
<span class="s0">86 0 0 4 127 251 0 0 468 /**</span>
 <span class="s0">* This method increments the lock count, assuming the calling thread already</span>
 <span class="s0">* holds the lock.  After this call, release() will need to be called one</span>
 <span class="s0">* additional time to release the lock.</span>
 <span class="s0">*</span>
 <span class="s0">* This method really performs the same function as acquire(), but it offers a</span>
 <span class="s0">* potential (slight) performance benefit when the calling thread knows that</span>
 <span class="s0">* it already holds the lock.  It is an error to call this when the calling</span>
 <span class="s0">* thread does not hold the lock.</span>
 <span class="s0">*/ 1 4 this 3 282  </span>
<span class="s0">87 0 0 4 128 251 0 0 268 /**</span>
 <span class="s0">* Releases the lightReMutex.  It is an error to call this if the lightReMutex</span>
 <span class="s0">* was not already locked.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is considered const so that you can lock and unlock const</span>
 <span class="s0">* lightReMutexes, mainly to allow thread-safe access to otherwise const data.</span>
 <span class="s0">*/ 1 4 this 3 282  </span>
<span class="s0">88 0 0 6 129 227 0 0 293 /**</span>
 <span class="s0">* Returns true if the current thread has locked the LightReMutex, false</span>
 <span class="s0">* otherwise.  This method is only intended for use in debugging, hence the</span>
 <span class="s0">* method name; in the LightReMutexDirect case, it always returns true, since</span>
 <span class="s0">* there's not a reliable way to determine this otherwise.</span>
 <span class="s0">*/ 1 4 this 3 282  </span>
<span class="s0">89 0 0 4 130 251 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 2 4 this 3 284  4 name 1 248  </span>
<span class="s0">90 0 0 4 131 251 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 284  </span>
<span class="s0">91 0 0 6 132 227 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 282  </span>
<span class="s0">92 0 0 6 133 248 0 0 79 /**</span>
 <span class="s0">* The mutex name is only defined when compiling in DEBUG_THREADS mode.</span>
 <span class="s0">*/ 1 4 this 3 282  </span>
<span class="s0">93 0 0 4 134 251 0 0 99 /**</span>
 <span class="s0">* This method is declared virtual in MutexDebug, but non-virtual in</span>
 <span class="s0">* LightReMutexDirect.</span>
 <span class="s0">*/ 2 4 this 3 282  3 out 1 253  </span>
<span class="s0">94 0 0 7 136 285 203 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">95 0 0 7 136 285 203 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 248  </span>
<span class="s0">96 0 0 7 139 256 0 0 0 0 </span>
<span class="s0">97 0 0 7 142 286 207 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 13 initial_count 5 225  </span>
<span class="s0">98 0 0 4 144 251 0 0 134 /**</span>
 <span class="s0">* Decrements the internal count.  If the count was already at zero, blocks</span>
 <span class="s0">* until the count is nonzero, then decrements it.</span>
 <span class="s0">*/ 1 4 this 3 286  </span>
<span class="s0">99 0 0 6 145 227 0 0 117 /**</span>
 <span class="s0">* If the semaphore can be acquired without blocking, does so and returns</span>
 <span class="s0">* true.  Otherwise, returns false.</span>
 <span class="s0">*/ 1 4 this 3 286  </span>
<span class="s0">100 0 0 6 146 225 0 0 166 /**</span>
 <span class="s0">* Increments the semaphore's internal count.  This may wake up another thread</span>
 <span class="s0">* blocked on acquire().</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the count of the semaphore upon release.</span>
 <span class="s0">*/ 1 4 this 3 286  </span>
<span class="s0">101 0 0 6 147 225 0 0 127 /**</span>
 <span class="s0">* Returns the current semaphore count.  Note that this call is not thread-</span>
 <span class="s0">* safe (the count may change at any time).</span>
 <span class="s0">*/ 1 4 this 3 287  </span>
<span class="s0">102 0 0 4 148 251 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 287  3 out 1 253  </span>
<span class="s0">103 0 0 7 150 289 110 0 0 4 8 function 1 245  4 args 1 245  4 name 1 248  9 sync_name 1 248  </span>
<span class="s0">104 0 0 6 151 245 0 0 0 1 4 this 3 289  </span>
<span class="s0">105 0 0 7 158 256 0 0 0 0 </span>
<span class="s0">72</span>
<span class="s0">218 14 ThreadPriority 0 532481 14 ThreadPriority 14 ThreadPriority 0 0 0 0 0 0 0 0 0 0 4 6 TP_low 6 TP_low 0</span>
<span class="s0">0 9 TP_normal 9 TP_normal 0</span>
<span class="s0">1 7 TP_high 7 TP_high 0</span>
<span class="s0">2 9 TP_urgent 9 TP_urgent 0</span>
<span class="s0">3 0 105</span>
<span class="s0">// An enumerated type used by Thread to specify a suggested relative priority</span>
<span class="s0">// for a particular thread.</span>

<span class="s0">219 6 Thread 0 26625 6 Thread 6 Thread 0 0 0 0 110 15 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 30 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 0 0 2 3 220 106 107 3 221 108 109 0 0 396</span>
<span class="s0">/**</span>
 <span class="s0">* A thread; that is, a lightweight process.  This is an abstract base class;</span>
 <span class="s0">* to use it, you must subclass from it and redefine thread_main().</span>
 <span class="s0">*</span>
 <span class="s0">* The thread itself will keep a reference count on the Thread object while it</span>
 <span class="s0">* is running; when the thread returns from its root function, the Thread</span>
 <span class="s0">* object will automatically be destructed if no other pointers are</span>
 <span class="s0">* referencing it.</span>
 <span class="s0">*/</span>

<span class="s0">220 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">221 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">222 12 string const 0 8832 17 std::string const 17 std::string const 0 0 223 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">223 6 string 0 2105344 11 std::string 11 std::string 0 0 224 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">224 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">225 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">226 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 219 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">227 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">228 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 220 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">229 11 MutexDirect 0 43009 11 MutexDirect 11 MutexDirect 0 0 0 0 0 0 9 141 142 143 144 145 146 147 148 149 0 0 0 0 0 164</span>
<span class="s0">/**</span>
 <span class="s0">* This class implements a standard mutex by making direct calls to the</span>
 <span class="s0">* underlying implementation layer.  It doesn't perform any debugging</span>
 <span class="s0">* operations.</span>
 <span class="s0">*/</span>

<span class="s0">230 5 Mutex 0 26625 5 Mutex 5 Mutex 0 0 0 1 150 151 0 0 0 0 1 0 229 0 0 0 0 0</span>

<span class="s0">231 18 ConditionVarDirect 0 26625 18 ConditionVarDirect 18 ConditionVarDirect 0 0 0 0 152 0 4 153 154 155 156 0 0 0 0 0 377</span>
<span class="s0">/**</span>
 <span class="s0">* A condition variable, usually used to communicate information about</span>
 <span class="s0">* changing state to a thread that is waiting for something to happen.  A</span>
 <span class="s0">* condition variable can be used to &quot;wake up&quot; a thread when some arbitrary</span>
 <span class="s0">* condition has changed.</span>
 <span class="s0">*</span>
 <span class="s0">* A condition variable is associated with a single mutex, and several</span>
 <span class="s0">* condition variables may share the same mutex.</span>
 <span class="s0">*/</span>

<span class="s0">232 12 ConditionVar 0 26625 12 ConditionVar 12 ConditionVar 0 0 0 1 157 158 0 1 159 0 0 1 0 231 0 0 0 0 0</span>

<span class="s0">233 22 ConditionVarFullDirect 0 26625 22 ConditionVarFullDirect 22 ConditionVarFullDirect 0 0 0 0 160 0 5 161 162 163 164 165 0 0 0 0 0 377</span>
<span class="s0">/**</span>
 <span class="s0">* A condition variable, usually used to communicate information about</span>
 <span class="s0">* changing state to a thread that is waiting for something to happen.  A</span>
 <span class="s0">* condition variable can be used to &quot;wake up&quot; a thread when some arbitrary</span>
 <span class="s0">* condition has changed.</span>
 <span class="s0">*</span>
 <span class="s0">* A condition variable is associated with a single mutex, and several</span>
 <span class="s0">* condition variables may share the same mutex.</span>
 <span class="s0">*/</span>

<span class="s0">234 16 ConditionVarFull 0 26625 16 ConditionVarFull 16 ConditionVarFull 0 0 0 1 166 167 0 1 168 0 0 1 0 233 0 0 0 0 0</span>

<span class="s0">235 13 ReMutexDirect 0 43009 13 ReMutexDirect 13 ReMutexDirect 0 0 0 0 0 0 10 169 170 171 172 173 174 175 176 177 178 0 0 0 0 0 166</span>
<span class="s0">/**</span>
 <span class="s0">* This class implements a standard reMutex by making direct calls to the</span>
 <span class="s0">* underlying implementation layer.  It doesn't perform any debugging</span>
 <span class="s0">* operations.</span>
 <span class="s0">*/</span>

<span class="s0">236 7 ReMutex 0 26625 7 ReMutex 7 ReMutex 0 0 0 1 179 180 0 0 0 0 1 0 235 0 0 0 0 0</span>

<span class="s0">237 14 ExternalThread 0 141313 14 ExternalThread 14 ExternalThread 0 0 0 0 182 0 1 181 0 0 1 0 219 0 0 0 0 149</span>
<span class="s0">/**</span>
 <span class="s0">* The special &quot;external thread&quot; class.  There is one instance of these in the</span>
 <span class="s0">* world, and it is returned by Thread::get_external_thread().</span>
 <span class="s0">*/</span>

<span class="s0">238 16 LightMutexDirect 0 43009 16 LightMutexDirect 16 LightMutexDirect 0 0 0 0 0 0 8 183 184 185 186 187 188 189 190 0 0 0 0 0 167</span>
<span class="s0">/**</span>
 <span class="s0">* This class implements a lightweight Mutex by making direct calls to the</span>
 <span class="s0">* underlying implementation layer.  It doesn't perform any debugging</span>
 <span class="s0">* operations.</span>
 <span class="s0">*/</span>

<span class="s0">239 10 LightMutex 0 26625 10 LightMutex 10 LightMutex 0 0 0 1 191 192 0 0 0 0 1 0 238 0 0 0 0 0</span>

<span class="s0">240 18 LightReMutexDirect 0 43009 18 LightReMutexDirect 18 LightReMutexDirect 0 0 0 0 0 0 9 193 194 195 196 197 198 199 200 201 0 0 0 0 0 171</span>
<span class="s0">/**</span>
 <span class="s0">* This class implements a standard lightReMutex by making direct calls to the</span>
 <span class="s0">* underlying implementation layer.  It doesn't perform any debugging</span>
 <span class="s0">* operations.</span>
 <span class="s0">*/</span>

<span class="s0">241 12 LightReMutex 0 26625 12 LightReMutex 12 LightReMutex 0 0 0 1 202 203 0 0 0 0 1 0 240 0 0 0 0 0</span>

<span class="s0">242 10 MainThread 0 141313 10 MainThread 10 MainThread 0 0 0 0 205 0 1 204 0 0 1 0 219 0 0 0 0 141</span>
<span class="s0">/**</span>
 <span class="s0">* The special &quot;main thread&quot; class.  There is one instance of these in the</span>
 <span class="s0">* world, and it is returned by Thread::get_main_thread().</span>
 <span class="s0">*/</span>

<span class="s0">243 9 Semaphore 0 26625 9 Semaphore 9 Semaphore 0 0 0 1 206 207 0 5 208 209 210 211 212 0 0 0 0 0 332</span>
<span class="s0">/**</span>
 <span class="s0">* A classic semaphore synchronization primitive.</span>
 <span class="s0">*</span>
 <span class="s0">* A semaphore manages an internal counter which is decremented by each</span>
 <span class="s0">* acquire() call and incremented by each release() call.  The counter can</span>
 <span class="s0">* never go below zero; when acquire() finds that it is zero, it blocks,</span>
 <span class="s0">* waiting until some other thread calls release().</span>
 <span class="s0">*/</span>

<span class="s0">244 12 PythonThread 0 75777 12 PythonThread 12 PythonThread 0 0 0 1 213 110 1 305 2 214 217 0 0 1 0 219 0 0 0 0 174</span>
<span class="s0">/**</span>
 <span class="s0">* This class is exposed to Python to allow creation of a Panda thread from</span>
 <span class="s0">* the Python level.  It will spawn a thread that executes an arbitrary Python</span>
 <span class="s0">* functor.</span>
 <span class="s0">*/</span>

<span class="s0">245 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 246 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">246 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 247 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">247 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">248 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">249 14 Thread const * 0 8576 14 Thread const * 14 Thread const * 0 0 250 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">250 12 Thread const 0 8832 12 Thread const 12 Thread const 0 0 219 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">251 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">252 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">253 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 254 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">254 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">255 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">256 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 255 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">257 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 221 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">258 19 MutexDirect const * 0 8576 19 MutexDirect const * 19 MutexDirect const * 0 0 259 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">259 17 MutexDirect const 0 8832 17 MutexDirect const 17 MutexDirect const 0 0 229 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">260 13 MutexDirect * 0 8576 13 MutexDirect * 13 MutexDirect * 0 0 229 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">261 7 Mutex * 0 8576 7 Mutex * 7 Mutex * 0 0 230 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">262 26 ConditionVarDirect const * 0 8576 26 ConditionVarDirect const * 26 ConditionVarDirect const * 0 0 263 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">263 24 ConditionVarDirect const 0 8832 24 ConditionVarDirect const 24 ConditionVarDirect const 0 0 231 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">264 20 ConditionVarDirect * 0 8576 20 ConditionVarDirect * 20 ConditionVarDirect * 0 0 231 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">265 14 ConditionVar * 0 8576 14 ConditionVar * 14 ConditionVar * 0 0 232 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">266 20 ConditionVar const * 0 8576 20 ConditionVar const * 20 ConditionVar const * 0 0 267 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">267 18 ConditionVar const 0 8832 18 ConditionVar const 18 ConditionVar const 0 0 232 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">268 30 ConditionVarFullDirect const * 0 8576 30 ConditionVarFullDirect const * 30 ConditionVarFullDirect const * 0 0 269 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">269 28 ConditionVarFullDirect const 0 8832 28 ConditionVarFullDirect const 28 ConditionVarFullDirect const 0 0 233 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">270 24 ConditionVarFullDirect * 0 8576 24 ConditionVarFullDirect * 24 ConditionVarFullDirect * 0 0 233 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">271 18 ConditionVarFull * 0 8576 18 ConditionVarFull * 18 ConditionVarFull * 0 0 234 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">272 24 ConditionVarFull const * 0 8576 24 ConditionVarFull const * 24 ConditionVarFull const * 0 0 273 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">273 22 ConditionVarFull const 0 8832 22 ConditionVarFull const 22 ConditionVarFull const 0 0 234 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">274 21 ReMutexDirect const * 0 8576 21 ReMutexDirect const * 21 ReMutexDirect const * 0 0 275 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">275 19 ReMutexDirect const 0 8832 19 ReMutexDirect const 19 ReMutexDirect const 0 0 235 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">276 15 ReMutexDirect * 0 8576 15 ReMutexDirect * 15 ReMutexDirect * 0 0 235 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">277 9 ReMutex * 0 8576 9 ReMutex * 9 ReMutex * 0 0 236 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">278 24 LightMutexDirect const * 0 8576 24 LightMutexDirect const * 24 LightMutexDirect const * 0 0 279 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">279 22 LightMutexDirect const 0 8832 22 LightMutexDirect const 22 LightMutexDirect const 0 0 238 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">280 18 LightMutexDirect * 0 8576 18 LightMutexDirect * 18 LightMutexDirect * 0 0 238 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">281 12 LightMutex * 0 8576 12 LightMutex * 12 LightMutex * 0 0 239 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">282 26 LightReMutexDirect const * 0 8576 26 LightReMutexDirect const * 26 LightReMutexDirect const * 0 0 283 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">283 24 LightReMutexDirect const 0 8832 24 LightReMutexDirect const 24 LightReMutexDirect const 0 0 240 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">284 20 LightReMutexDirect * 0 8576 20 LightReMutexDirect * 20 LightReMutexDirect * 0 0 240 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">285 14 LightReMutex * 0 8576 14 LightReMutex * 14 LightReMutex * 0 0 241 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">286 11 Semaphore * 0 8576 11 Semaphore * 11 Semaphore * 0 0 243 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">287 17 Semaphore const * 0 8576 17 Semaphore const * 17 Semaphore const * 0 0 288 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">288 15 Semaphore const 0 8832 15 Semaphore const 15 Semaphore const 0 0 243 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">289 14 PythonThread * 0 8576 14 PythonThread * 14 PythonThread * 0 0 244 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">16</span>
<span class="s0">290 9 sync_name 0 2 222 112 0 0 0 0 0 0 0 17 Thread::sync_name 0</span>

<span class="s0">291 12 pstats_index 0 2 225 113 0 0 0 0 0 0 0 20 Thread::pstats_index 0</span>

<span class="s0">292 12 python_index 0 2 225 114 0 0 0 0 0 0 0 20 Thread::python_index 0</span>

<span class="s0">293 9 unique_id 0 2 223 115 0 0 0 0 0 0 0 17 Thread::unique_id 0</span>

<span class="s0">294 14 pipeline_stage 0 6 225 116 117 0 0 0 0 0 0 22 Thread::pipeline_stage 0</span>

<span class="s0">295 11 main_thread 0 2 226 119 0 0 0 0 0 0 0 19 Thread::main_thread 0</span>

<span class="s0">296 15 external_thread 0 2 226 120 0 0 0 0 0 0 0 23 Thread::external_thread 0</span>

<span class="s0">297 14 current_thread 0 2 226 121 0 0 0 0 0 0 0 22 Thread::current_thread 0</span>

<span class="s0">298 22 current_pipeline_stage 0 2 225 122 0 0 0 0 0 0 0 30 Thread::current_pipeline_stage 0</span>

<span class="s0">299 19 threading_supported 0 2 227 123 0 0 0 0 0 0 0 27 Thread::threading_supported 0</span>

<span class="s0">300 12 true_threads 0 2 227 124 0 0 0 0 0 0 0 20 Thread::true_threads 0</span>

<span class="s0">301 14 simple_threads 0 2 227 125 0 0 0 0 0 0 0 22 Thread::simple_threads 0</span>

<span class="s0">302 7 started 0 2 227 132 0 0 0 0 0 0 0 15 Thread::started 0</span>

<span class="s0">303 8 joinable 0 2 227 133 0 0 0 0 0 0 0 16 Thread::joinable 0</span>

<span class="s0">304 12 current_task 0 2 228 137 0 0 0 0 0 0 0 20 Thread::current_task 0</span>

<span class="s0">305 4 args 0 6 245 215 216 0 0 0 0 0 0 18 PythonThread::args 0</span>

<span class="s0">0</span>
</pre>
</body>
</html>