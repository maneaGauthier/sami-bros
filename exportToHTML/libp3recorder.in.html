<html>
<head>
<title>libp3recorder.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3recorder.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">13 libp3recorder 4 ayCl 12 panda3d.core </span>
<span class="s0">51</span>
<span class="s0">46 13 ~RecorderBase 0 518 97 27 RecorderBase::~RecorderBase 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">virtual RecorderBase::~RecorderBase(void);</span>

<span class="s0">47 12 is_recording 0 4 97 26 RecorderBase::is_recording 0 1 1 187</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this recorder is presently recording data for saving to a</span>
 <span class="s0">* session file, false otherwise.  If this is true, record_data() will be</span>
 <span class="s0">* called from time to time.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool RecorderBase::is_recording(void) const;</span>

<span class="s0">48 10 is_playing 0 4 97 24 RecorderBase::is_playing 0 1 2 177</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this recorder is presently playing back data from session</span>
 <span class="s0">* file, false otherwise.  If this is true, play_data() will be called from</span>
 <span class="s0">* time to time.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool RecorderBase::is_playing(void) const;</span>

<span class="s0">49 14 get_class_type 0 4 97 28 RecorderBase::get_class_type 0 1 3 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle RecorderBase::get_class_type(void);</span>

<span class="s0">50 18 upcast_to_DataNode 0 12 98 33 MouseRecorder::upcast_to_DataNode 0 1 6 37</span>
<span class="s0">upcast from MouseRecorder to DataNode</span>
<span class="s0">50</span>
<span class="s0">DataNode *MouseRecorder::upcast_to_DataNode(void);</span>

<span class="s0">51 25 downcast_to_MouseRecorder 0 12 99 35 DataNode::downcast_to_MouseRecorder 0 0 39</span>
<span class="s0">downcast from DataNode to MouseRecorder</span>
<span class="s0">57</span>
<span class="s0">MouseRecorder *DataNode::downcast_to_MouseRecorder(void);</span>

<span class="s0">52 22 upcast_to_RecorderBase 0 12 98 37 MouseRecorder::upcast_to_RecorderBase 0 1 7 41</span>
<span class="s0">upcast from MouseRecorder to RecorderBase</span>
<span class="s0">58</span>
<span class="s0">RecorderBase *MouseRecorder::upcast_to_RecorderBase(void);</span>

<span class="s0">53 25 downcast_to_MouseRecorder 0 12 97 39 RecorderBase::downcast_to_MouseRecorder 0 0 43</span>
<span class="s0">downcast from RecorderBase to MouseRecorder</span>
<span class="s0">61</span>
<span class="s0">MouseRecorder *RecorderBase::downcast_to_MouseRecorder(void);</span>

<span class="s0">54 13 MouseRecorder 0 260 98 28 MouseRecorder::MouseRecorder 0 1 4 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">explicit MouseRecorder::MouseRecorder(std::string const &amp;name);</span>

<span class="s0">55 14 ~MouseRecorder 0 518 98 29 MouseRecorder::~MouseRecorder 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual MouseRecorder::~MouseRecorder(void);</span>

<span class="s0">56 14 get_class_type 0 4 98 29 MouseRecorder::get_class_type 0 1 5 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle MouseRecorder::get_class_type(void);</span>

<span class="s0">57 18 RecorderController 0 260 100 38 RecorderController::RecorderController 0 1 8 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">RecorderController::RecorderController(void);</span>

<span class="s0">58 12 begin_record 0 4 100 32 RecorderController::begin_record 0 1 9 123</span>
<span class="s0">/**</span>
 <span class="s0">* Begins recording data to the indicated filename.  All of the recorders in</span>
 <span class="s0">* use should already have been added.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool RecorderController::begin_record(Filename const &amp;filename);</span>

<span class="s0">59 14 begin_playback 0 4 100 34 RecorderController::begin_playback 0 1 10 349</span>
<span class="s0">/**</span>
 <span class="s0">* Begins playing back data from the indicated filename.  All of the recorders</span>
 <span class="s0">* in use should already have been added, although this may define additional</span>
 <span class="s0">* recorders if they are present in the file (these new recorders will not be</span>
 <span class="s0">* used).  This may also undefine recorders that were previously added but are</span>
 <span class="s0">* not present in the file.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">bool RecorderController::begin_playback(Filename const &amp;filename);</span>

<span class="s0">60 5 close 0 4 100 25 RecorderController::close 0 1 11 61</span>
<span class="s0">/**</span>
 <span class="s0">* Finishes recording data to the indicated filename.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void RecorderController::close(void);</span>

<span class="s0">61 14 get_start_time 0 4 100 34 RecorderController::get_start_time 0 1 12 167</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time (and date) at which the current session was originally</span>
 <span class="s0">* recorded (or, in recording mode, the time at which the current session</span>
 <span class="s0">* began).</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline time_t RecorderController::get_start_time(void) const;</span>

<span class="s0">62 15 set_random_seed 0 4 100 35 RecorderController::set_random_seed 0 1 13 203</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates an arbitrary number to be recorded in the session file as a</span>
 <span class="s0">* random seed, should the application wish to take advantage of it.  This</span>
 <span class="s0">* must be set before begin_record() is called.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void RecorderController::set_random_seed(int random_seed);</span>

<span class="s0">63 15 get_random_seed 0 4 100 35 RecorderController::get_random_seed 0 1 14 175</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the random seed that was set by a previous call to</span>
 <span class="s0">* set_random_seed(), or the number read from the session file after</span>
 <span class="s0">* begin_playback() has been called.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int RecorderController::get_random_seed(void) const;</span>

<span class="s0">64 12 is_recording 0 4 100 32 RecorderController::is_recording 0 1 15 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the controller has been opened for output, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool RecorderController::is_recording(void) const;</span>

<span class="s0">65 10 is_playing 0 4 100 30 RecorderController::is_playing 0 1 16 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the controller has been opened for input, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool RecorderController::is_playing(void) const;</span>

<span class="s0">66 7 is_open 0 4 100 27 RecorderController::is_open 0 1 17 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the controller has been opened for either input or output,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool RecorderController::is_open(void) const;</span>

<span class="s0">67 12 get_filename 0 4 100 32 RecorderController::get_filename 0 1 18 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename that was passed to the most recent call to</span>
 <span class="s0">* begin_record() or begin_playback().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline Filename const &amp;RecorderController::get_filename(void) const;</span>

<span class="s0">68 8 is_error 0 4 100 28 RecorderController::is_error 0 1 19 191</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the controller has been opened for input or output output</span>
 <span class="s0">* and there is an error on the stream, or false if the controller is closed</span>
 <span class="s0">* or if there is no problem.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool RecorderController::is_error(void);</span>

<span class="s0">69 16 get_clock_offset 0 4 100 36 RecorderController::get_clock_offset 0 1 20 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the delta offset between the actual frame time and the frame time</span>
 <span class="s0">* written to the log.  This is essentially the time at which the recording</span>
 <span class="s0">* (or playback) started.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline double RecorderController::get_clock_offset(void) const;</span>

<span class="s0">70 16 get_frame_offset 0 4 100 36 RecorderController::get_frame_offset 0 1 21 196</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the delta offset between the actual frame count and the frame count</span>
 <span class="s0">* written to the log.  This is essentially the frame number at which the</span>
 <span class="s0">* recording (or playback) started.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int RecorderController::get_frame_offset(void) const;</span>

<span class="s0">71 12 add_recorder 0 4 100 32 RecorderController::add_recorder 0 1 22 343</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the named recorder to the set of recorders that are in use.</span>
 <span class="s0">*</span>
 <span class="s0">* If the controller is in recording mode, the named recorder will begin</span>
 <span class="s0">* recording its status to the session file.  If the controller is in playback</span>
 <span class="s0">* mode and the name and type matches a recorder in the session file, the</span>
 <span class="s0">* recorder will begin receiving data.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline void RecorderController::add_recorder(std::string const &amp;name, RecorderBase *recorder);</span>

<span class="s0">72 12 has_recorder 0 4 100 32 RecorderController::has_recorder 0 1 23 331</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the named recorder has been added to the table by a</span>
 <span class="s0">* previous call to add_recorder(), false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* If the controller is in playback mode, this will also return false for a</span>
 <span class="s0">* recorder that was found in the session file but was never explicitly added</span>
 <span class="s0">* via add_recorder(); see get_recorder().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline bool RecorderController::has_recorder(std::string const &amp;name) const;</span>

<span class="s0">73 12 get_recorder 0 4 100 32 RecorderController::get_recorder 0 1 24 389</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the recorder with the indicated name, or NULL if there is no such</span>
 <span class="s0">* recorder.</span>
 <span class="s0">*</span>
 <span class="s0">* If the controller is in playback mode, this may return the recorder</span>
 <span class="s0">* matching the indicated name as read from the session file, even if it was</span>
 <span class="s0">* never added to the table by the user.  In this case, has_recorder() may</span>
 <span class="s0">* return false, but get_recorder() will return a non-NULL value.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline RecorderBase *RecorderController::get_recorder(std::string const &amp;name) const;</span>

<span class="s0">74 15 remove_recorder 0 4 100 35 RecorderController::remove_recorder 0 1 25 463</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the named recorder from the table.  Returns true if successful,</span>
 <span class="s0">* false if there was no such recorder.</span>
 <span class="s0">*</span>
 <span class="s0">* If the controller is in recording mode, the named recorder will stop</span>
 <span class="s0">* recording.  If the controller is in playback mode, the named recorder will</span>
 <span class="s0">* disassociate itself from the session file (but if the session file still</span>
 <span class="s0">* has data for this name, a default recorder will take its place to decode</span>
 <span class="s0">* the data from the session file).</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline bool RecorderController::remove_recorder(std::string const &amp;name);</span>

<span class="s0">75 13 set_frame_tie 0 4 100 33 RecorderController::set_frame_tie 0 1 26 528</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the frame_tie flag.</span>
 <span class="s0">*</span>
 <span class="s0">* When this is true, sessions are played back frame-for-frame, based on the</span>
 <span class="s0">* frame count of the recorded session.  This gives the most accurate</span>
 <span class="s0">* playback, but the playback rate will vary according to the frame rate of</span>
 <span class="s0">* the playback machine.</span>
 <span class="s0">*</span>
 <span class="s0">* When this is false, sessions are played back at real time, based on the</span>
 <span class="s0">* clock of the recorded session.  This may introduce playback discrepencies</span>
 <span class="s0">* if the frames do not fall at exactly the same times as they did in the</span>
 <span class="s0">* original.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void RecorderController::set_frame_tie(bool frame_tie);</span>

<span class="s0">76 13 get_frame_tie 0 4 100 33 RecorderController::get_frame_tie 0 1 27 31</span>
<span class="s0">/**</span>
 <span class="s0">* See set_frame_tie().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool RecorderController::get_frame_tie(void) const;</span>

<span class="s0">77 12 record_frame 0 4 100 32 RecorderController::record_frame 0 1 28 106</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the next frame of data from all of the active recorders and adds it to</span>
 <span class="s0">* the output file.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void RecorderController::record_frame(void);</span>

<span class="s0">78 10 play_frame 0 4 100 30 RecorderController::play_frame 0 1 29 106</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the next frame of data from all of the active recorders and adds it to</span>
 <span class="s0">* the output file.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void RecorderController::play_frame(void);</span>

<span class="s0">79 14 get_class_type 0 4 100 34 RecorderController::get_class_type 0 1 30 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle RecorderController::get_class_type(void);</span>

<span class="s0">80 22 upcast_to_RecorderBase 0 12 102 44 SocketStreamRecorder::upcast_to_RecorderBase 0 1 44 48</span>
<span class="s0">upcast from SocketStreamRecorder to RecorderBase</span>
<span class="s0">65</span>
<span class="s0">RecorderBase *SocketStreamRecorder::upcast_to_RecorderBase(void);</span>

<span class="s0">81 32 downcast_to_SocketStreamRecorder 0 12 97 46 RecorderBase::downcast_to_SocketStreamRecorder 0 0 50</span>
<span class="s0">downcast from RecorderBase to SocketStreamRecorder</span>
<span class="s0">75</span>
<span class="s0">SocketStreamRecorder *RecorderBase::downcast_to_SocketStreamRecorder(void);</span>

<span class="s0">82 24 upcast_to_ReferenceCount 0 12 102 46 SocketStreamRecorder::upcast_to_ReferenceCount 0 1 45 50</span>
<span class="s0">upcast from SocketStreamRecorder to ReferenceCount</span>
<span class="s0">69</span>
<span class="s0">ReferenceCount *SocketStreamRecorder::upcast_to_ReferenceCount(void);</span>

<span class="s0">83 32 downcast_to_SocketStreamRecorder 0 12 103 48 ReferenceCount::downcast_to_SocketStreamRecorder 0 0 52</span>
<span class="s0">downcast from ReferenceCount to SocketStreamRecorder</span>
<span class="s0">77</span>
<span class="s0">SocketStreamRecorder *ReferenceCount::downcast_to_SocketStreamRecorder(void);</span>

<span class="s0">84 20 SocketStreamRecorder 0 260 102 42 SocketStreamRecorder::SocketStreamRecorder 0 2 31 32 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">inline SocketStreamRecorder::SocketStreamRecorder(void);</span>
<span class="s0">inline explicit SocketStreamRecorder::SocketStreamRecorder(SocketStream *stream, bool owns_stream);</span>

<span class="s0">85 21 ~SocketStreamRecorder 0 518 102 43 SocketStreamRecorder::~SocketStreamRecorder 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">virtual inline SocketStreamRecorder::~SocketStreamRecorder(void);</span>

<span class="s0">86 16 receive_datagram 0 4 102 38 SocketStreamRecorder::receive_datagram 0 1 33 253</span>
<span class="s0">/**</span>
 <span class="s0">* Receives a datagram over the socket by expecting a little-endian 16-bit</span>
 <span class="s0">* byte count as a prefix.  If the socket stream is non-blocking, may return</span>
 <span class="s0">* false if the data is not available; otherwise, returns false only if the</span>
 <span class="s0">* socket closes.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">bool SocketStreamRecorder::receive_datagram(Datagram &amp;dg);</span>

<span class="s0">87 13 send_datagram 0 4 102 35 SocketStreamRecorder::send_datagram 0 1 34 45</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::send_datagram().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool SocketStreamRecorder::send_datagram(Datagram const &amp;dg);</span>

<span class="s0">88 9 is_closed 0 4 102 31 SocketStreamRecorder::is_closed 0 1 35 41</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::is_closed().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool SocketStreamRecorder::is_closed(void);</span>

<span class="s0">89 5 close 0 4 102 27 SocketStreamRecorder::close 0 1 36 37</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::close().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void SocketStreamRecorder::close(void);</span>

<span class="s0">90 15 set_collect_tcp 0 4 102 37 SocketStreamRecorder::set_collect_tcp 0 1 37 47</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::set_collect_tcp().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void SocketStreamRecorder::set_collect_tcp(bool collect_tcp);</span>

<span class="s0">91 15 get_collect_tcp 0 4 102 37 SocketStreamRecorder::get_collect_tcp 0 1 38 47</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::get_collect_tcp().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool SocketStreamRecorder::get_collect_tcp(void) const;</span>

<span class="s0">92 24 set_collect_tcp_interval 0 4 102 46 SocketStreamRecorder::set_collect_tcp_interval 0 1 39 56</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::set_collect_tcp_interval().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void SocketStreamRecorder::set_collect_tcp_interval(double interval);</span>

<span class="s0">93 24 get_collect_tcp_interval 0 4 102 46 SocketStreamRecorder::get_collect_tcp_interval 0 1 40 56</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::get_collect_tcp_interval().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline double SocketStreamRecorder::get_collect_tcp_interval(void) const;</span>

<span class="s0">94 14 consider_flush 0 4 102 36 SocketStreamRecorder::consider_flush 0 1 41 45</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::consider_flush()</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool SocketStreamRecorder::consider_flush(void);</span>

<span class="s0">95 5 flush 0 4 102 27 SocketStreamRecorder::flush 0 1 42 36</span>
<span class="s0">/**</span>
 <span class="s0">* See SocketStream::flush()</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool SocketStreamRecorder::flush(void);</span>

<span class="s0">96 14 get_class_type 0 4 102 36 SocketStreamRecorder::get_class_type 0 1 43 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle SocketStreamRecorder::get_class_type(void);</span>

<span class="s0">45</span>
<span class="s0">1 0 0 6 3 106 0 0 187 /**</span>
 <span class="s0">* Returns true if this recorder is presently recording data for saving to a</span>
 <span class="s0">* session file, false otherwise.  If this is true, record_data() will be</span>
 <span class="s0">* called from time to time.</span>
 <span class="s0">*/ 1 4 this 3 104  </span>
<span class="s0">2 0 0 6 4 106 0 0 177 /**</span>
 <span class="s0">* Returns true if this recorder is presently playing back data from session</span>
 <span class="s0">* file, false otherwise.  If this is true, play_data() will be called from</span>
 <span class="s0">* time to time.</span>
 <span class="s0">*/ 1 4 this 3 104  </span>
<span class="s0">3 0 0 7 5 108 0 0 0 0 </span>
<span class="s0">4 0 0 7 12 110 55 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 109  </span>
<span class="s0">5 0 0 7 14 108 0 0 0 0 </span>
<span class="s0">6 0 0 7 8 111 0 0 0 1 4 this 3 110  </span>
<span class="s0">7 0 0 7 10 112 46 0 0 1 4 this 3 110  </span>
<span class="s0">8 0 0 7 17 113 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">9 0 0 6 18 106 0 0 123 /**</span>
 <span class="s0">* Begins recording data to the indicated filename.  All of the recorders in</span>
 <span class="s0">* use should already have been added.</span>
 <span class="s0">*/ 2 4 this 3 113  8 filename 1 114  </span>
<span class="s0">10 0 0 6 19 106 0 0 349 /**</span>
 <span class="s0">* Begins playing back data from the indicated filename.  All of the recorders</span>
 <span class="s0">* in use should already have been added, although this may define additional</span>
 <span class="s0">* recorders if they are present in the file (these new recorders will not be</span>
 <span class="s0">* used).  This may also undefine recorders that were previously added but are</span>
 <span class="s0">* not present in the file.</span>
 <span class="s0">*/ 2 4 this 3 113  8 filename 1 114  </span>
<span class="s0">11 0 0 4 20 117 0 0 61 /**</span>
 <span class="s0">* Finishes recording data to the indicated filename.</span>
 <span class="s0">*/ 1 4 this 3 113  </span>
<span class="s0">12 0 0 6 21 120 0 0 167 /**</span>
 <span class="s0">* Returns the time (and date) at which the current session was originally</span>
 <span class="s0">* recorded (or, in recording mode, the time at which the current session</span>
 <span class="s0">* began).</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">13 0 0 4 22 117 0 0 203 /**</span>
 <span class="s0">* Indicates an arbitrary number to be recorded in the session file as a</span>
 <span class="s0">* random seed, should the application wish to take advantage of it.  This</span>
 <span class="s0">* must be set before begin_record() is called.</span>
 <span class="s0">*/ 2 4 this 3 113  11 random_seed 1 122  </span>
<span class="s0">14 0 0 6 23 122 0 0 175 /**</span>
 <span class="s0">* Returns the random seed that was set by a previous call to</span>
 <span class="s0">* set_random_seed(), or the number read from the session file after</span>
 <span class="s0">* begin_playback() has been called.</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">15 0 0 6 24 106 0 0 86 /**</span>
 <span class="s0">* Returns true if the controller has been opened for output, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">16 0 0 6 25 106 0 0 85 /**</span>
 <span class="s0">* Returns true if the controller has been opened for input, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">17 0 0 6 26 106 0 0 105 /**</span>
 <span class="s0">* Returns true if the controller has been opened for either input or output,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">18 0 0 6 27 114 0 0 113 /**</span>
 <span class="s0">* Returns the filename that was passed to the most recent call to</span>
 <span class="s0">* begin_record() or begin_playback().</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">19 0 0 6 28 106 0 0 191 /**</span>
 <span class="s0">* Returns true if the controller has been opened for input or output output</span>
 <span class="s0">* and there is an error on the stream, or false if the controller is closed</span>
 <span class="s0">* or if there is no problem.</span>
 <span class="s0">*/ 1 4 this 3 113  </span>
<span class="s0">20 0 0 6 29 123 0 0 186 /**</span>
 <span class="s0">* Returns the delta offset between the actual frame time and the frame time</span>
 <span class="s0">* written to the log.  This is essentially the time at which the recording</span>
 <span class="s0">* (or playback) started.</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">21 0 0 6 30 122 0 0 196 /**</span>
 <span class="s0">* Returns the delta offset between the actual frame count and the frame count</span>
 <span class="s0">* written to the log.  This is essentially the frame number at which the</span>
 <span class="s0">* recording (or playback) started.</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">22 0 0 4 31 117 0 0 343 /**</span>
 <span class="s0">* Adds the named recorder to the set of recorders that are in use.</span>
 <span class="s0">*</span>
 <span class="s0">* If the controller is in recording mode, the named recorder will begin</span>
 <span class="s0">* recording its status to the session file.  If the controller is in playback</span>
 <span class="s0">* mode and the name and type matches a recorder in the session file, the</span>
 <span class="s0">* recorder will begin receiving data.</span>
 <span class="s0">*/ 3 4 this 3 113  4 name 1 109  8 recorder 1 112  </span>
<span class="s0">23 0 0 6 32 106 0 0 331 /**</span>
 <span class="s0">* Returns true if the named recorder has been added to the table by a</span>
 <span class="s0">* previous call to add_recorder(), false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* If the controller is in playback mode, this will also return false for a</span>
 <span class="s0">* recorder that was found in the session file but was never explicitly added</span>
 <span class="s0">* via add_recorder(); see get_recorder().</span>
 <span class="s0">*/ 2 4 this 3 118  4 name 1 109  </span>
<span class="s0">24 0 0 7 33 112 46 0 389 /**</span>
 <span class="s0">* Returns the recorder with the indicated name, or NULL if there is no such</span>
 <span class="s0">* recorder.</span>
 <span class="s0">*</span>
 <span class="s0">* If the controller is in playback mode, this may return the recorder</span>
 <span class="s0">* matching the indicated name as read from the session file, even if it was</span>
 <span class="s0">* never added to the table by the user.  In this case, has_recorder() may</span>
 <span class="s0">* return false, but get_recorder() will return a non-NULL value.</span>
 <span class="s0">*/ 2 4 this 3 118  4 name 1 109  </span>
<span class="s0">25 0 0 6 34 106 0 0 463 /**</span>
 <span class="s0">* Removes the named recorder from the table.  Returns true if successful,</span>
 <span class="s0">* false if there was no such recorder.</span>
 <span class="s0">*</span>
 <span class="s0">* If the controller is in recording mode, the named recorder will stop</span>
 <span class="s0">* recording.  If the controller is in playback mode, the named recorder will</span>
 <span class="s0">* disassociate itself from the session file (but if the session file still</span>
 <span class="s0">* has data for this name, a default recorder will take its place to decode</span>
 <span class="s0">* the data from the session file).</span>
 <span class="s0">*/ 2 4 this 3 113  4 name 1 109  </span>
<span class="s0">26 0 0 4 35 117 0 0 528 /**</span>
 <span class="s0">* Sets the frame_tie flag.</span>
 <span class="s0">*</span>
 <span class="s0">* When this is true, sessions are played back frame-for-frame, based on the</span>
 <span class="s0">* frame count of the recorded session.  This gives the most accurate</span>
 <span class="s0">* playback, but the playback rate will vary according to the frame rate of</span>
 <span class="s0">* the playback machine.</span>
 <span class="s0">*</span>
 <span class="s0">* When this is false, sessions are played back at real time, based on the</span>
 <span class="s0">* clock of the recorded session.  This may introduce playback discrepencies</span>
 <span class="s0">* if the frames do not fall at exactly the same times as they did in the</span>
 <span class="s0">* original.</span>
 <span class="s0">*/ 2 4 this 3 113  9 frame_tie 1 106  </span>
<span class="s0">27 0 0 6 36 106 0 0 31 /**</span>
 <span class="s0">* See set_frame_tie().</span>
 <span class="s0">*/ 1 4 this 3 118  </span>
<span class="s0">28 0 0 4 37 117 0 0 106 /**</span>
 <span class="s0">* Gets the next frame of data from all of the active recorders and adds it to</span>
 <span class="s0">* the output file.</span>
 <span class="s0">*/ 1 4 this 3 113  </span>
<span class="s0">29 0 0 4 38 117 0 0 106 /**</span>
 <span class="s0">* Gets the next frame of data from all of the active recorders and adds it to</span>
 <span class="s0">* the output file.</span>
 <span class="s0">*/ 1 4 this 3 113  </span>
<span class="s0">30 0 0 7 39 108 0 0 0 0 </span>
<span class="s0">31 0 0 7 46 124 85 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">32 0 0 7 46 124 85 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 stream 1 125  11 owns_stream 1 106  </span>
<span class="s0">33 0 0 6 48 106 0 0 253 /**</span>
 <span class="s0">* Receives a datagram over the socket by expecting a little-endian 16-bit</span>
 <span class="s0">* byte count as a prefix.  If the socket stream is non-blocking, may return</span>
 <span class="s0">* false if the data is not available; otherwise, returns false only if the</span>
 <span class="s0">* socket closes.</span>
 <span class="s0">*/ 2 4 this 3 124  2 dg 1 127  </span>
<span class="s0">34 0 0 6 49 106 0 0 45 /**</span>
 <span class="s0">* See SocketStream::send_datagram().</span>
 <span class="s0">*/ 2 4 this 3 124  2 dg 1 129  </span>
<span class="s0">35 0 0 6 50 106 0 0 41 /**</span>
 <span class="s0">* See SocketStream::is_closed().</span>
 <span class="s0">*/ 1 4 this 3 124  </span>
<span class="s0">36 0 0 4 51 117 0 0 37 /**</span>
 <span class="s0">* See SocketStream::close().</span>
 <span class="s0">*/ 1 4 this 3 124  </span>
<span class="s0">37 0 0 4 52 117 0 0 47 /**</span>
 <span class="s0">* See SocketStream::set_collect_tcp().</span>
 <span class="s0">*/ 2 4 this 3 124  11 collect_tcp 1 106  </span>
<span class="s0">38 0 0 6 53 106 0 0 47 /**</span>
 <span class="s0">* See SocketStream::get_collect_tcp().</span>
 <span class="s0">*/ 1 4 this 3 131  </span>
<span class="s0">39 0 0 4 54 117 0 0 56 /**</span>
 <span class="s0">* See SocketStream::set_collect_tcp_interval().</span>
 <span class="s0">*/ 2 4 this 3 124  8 interval 1 123  </span>
<span class="s0">40 0 0 6 55 123 0 0 56 /**</span>
 <span class="s0">* See SocketStream::get_collect_tcp_interval().</span>
 <span class="s0">*/ 1 4 this 3 131  </span>
<span class="s0">41 0 0 6 56 106 0 0 45 /**</span>
 <span class="s0">* See SocketStream::consider_flush()</span>
 <span class="s0">*/ 1 4 this 3 124  </span>
<span class="s0">42 0 0 6 57 106 0 0 36 /**</span>
 <span class="s0">* See SocketStream::flush()</span>
 <span class="s0">*/ 1 4 this 3 124  </span>
<span class="s0">43 0 0 7 58 108 0 0 0 0 </span>
<span class="s0">44 0 0 7 41 112 46 0 0 1 4 this 3 124  </span>
<span class="s0">45 0 0 7 44 133 0 0 0 1 4 this 3 124  </span>
<span class="s0">37</span>
<span class="s0">97 12 RecorderBase 0 26625 12 RecorderBase 12 RecorderBase 0 0 0 0 46 0 3 47 48 49 0 0 0 0 0 1028</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class to a number of objects that record particular kinds</span>
 <span class="s0">* of user input (like a MouseRecorder) to use in conjunction with a</span>
 <span class="s0">* RecorderController to record the user's inputs for a session.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that RecorderBase does not actually inherit from TypedObject, even</span>
 <span class="s0">* though it defines get_type().  The assumption is that the classes that</span>
 <span class="s0">* derive from RecorderBase might also inherit independently from TypedObject.</span>
 <span class="s0">*</span>
 <span class="s0">* It also does not inherit from TypedWritable, but it defines a method called</span>
 <span class="s0">* write_recorder() which is very similar to a TypedWritable's</span>
 <span class="s0">* write_datagram(). Classes that derive from RecorderBase and also inherit</span>
 <span class="s0">* from TypedWritable may choose to remap write_recorder() to do exactly the</span>
 <span class="s0">* same thing as write_datagram(), or they may choose to write something</span>
 <span class="s0">* slightly different.</span>
 <span class="s0">*</span>
 <span class="s0">* Most types of recorders should derive from Recorder, as it derives from</span>
 <span class="s0">* ReferenceCount, except for MouseRecorder, which would otherwise doubly</span>
 <span class="s0">* inherit from ReferenceCount.</span>
 <span class="s0">*/</span>

<span class="s0">98 13 MouseRecorder 0 26625 13 MouseRecorder 13 MouseRecorder 0 0 0 1 54 55 0 1 56 0 0 2 3 99 50 51 3 97 52 53 0 0 362</span>
<span class="s0">/**</span>
 <span class="s0">* This object records any data generated by a particular MouseAndKeyboard</span>
 <span class="s0">* node on the datagraph for a session for eventual playback via a</span>
 <span class="s0">* DataGraphPlayback (and a PlaybackController).  To use it, make it a child</span>
 <span class="s0">* of the node you wish to record.  It also serves as a pass-through, so that</span>
 <span class="s0">* additional child nodes may be parented directly to it.</span>
 <span class="s0">*/</span>

<span class="s0">99 8 DataNode 0 2048 8 DataNode 8 DataNode 0 0 0 0 0 0 0 0 0 0 0 0 422</span>
<span class="s0">/**</span>
 <span class="s0">* The fundamental type of node for the data graph.  The DataNode class is</span>
 <span class="s0">* itself primarily intended as an abstract class; it defines no inputs and no</span>
 <span class="s0">* outputs.  Most kinds of data nodes will derive from this to specify the</span>
 <span class="s0">* inputs and outputs in the constructor.</span>
 <span class="s0">*</span>
 <span class="s0">* DataNode does not attempt to cycle its data with a PipelineCycler.  The</span>
 <span class="s0">* data graph is intended to be used only within a single thread.</span>
 <span class="s0">*/</span>

<span class="s0">100 18 RecorderController 0 75777 18 RecorderController 18 RecorderController 0 0 0 1 57 0 0 22 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 0 0 1 0 101 0 0 0 0 142</span>
<span class="s0">/**</span>
 <span class="s0">* This object manages the process of recording the user's runtime inputs to a</span>
 <span class="s0">* bam file so that the session can be recreated later.</span>
 <span class="s0">*/</span>

<span class="s0">101 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">102 20 SocketStreamRecorder 0 26625 20 SocketStreamRecorder 20 SocketStreamRecorder 0 0 0 1 84 85 0 11 86 87 88 89 90 91 92 93 94 95 96 0 0 2 3 97 80 81 3 103 82 83 0 0 350</span>
<span class="s0">/**</span>
 <span class="s0">* Records any data received from the indicated socket stream.  On playback,</span>
 <span class="s0">* it will act as if the incoming data is coming over the wire again even if</span>
 <span class="s0">* an actual connection is not available.</span>
 <span class="s0">*</span>
 <span class="s0">* Outbound data will not be recorded, but will be sent straight through to</span>
 <span class="s0">* the socket if it is connected, or silently ignored if it is not.</span>
 <span class="s0">*/</span>

<span class="s0">103 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">104 20 RecorderBase const * 0 8576 20 RecorderBase const * 20 RecorderBase const * 0 0 105 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">105 18 RecorderBase const 0 8832 18 RecorderBase const 18 RecorderBase const 0 0 97 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">106 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">107 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">108 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 107 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">109 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">110 15 MouseRecorder * 0 8576 15 MouseRecorder * 15 MouseRecorder * 0 0 98 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">111 10 DataNode * 0 8576 10 DataNode * 10 DataNode * 0 0 99 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">112 14 RecorderBase * 0 8576 14 RecorderBase * 14 RecorderBase * 0 0 97 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">113 20 RecorderController * 0 8576 20 RecorderController * 20 RecorderController * 0 0 100 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">114 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 115 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">115 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 116 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">116 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">117 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">118 26 RecorderController const * 0 8576 26 RecorderController const * 26 RecorderController const * 0 0 119 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">119 24 RecorderController const 0 8832 24 RecorderController const 24 RecorderController const 0 0 100 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">120 6 time_t 0 2105344 6 time_t 6 time_t 0 0 121 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">121 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">122 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">123 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">124 22 SocketStreamRecorder * 0 8576 22 SocketStreamRecorder * 22 SocketStreamRecorder * 0 0 102 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">125 14 SocketStream * 0 8576 14 SocketStream * 14 SocketStream * 0 0 126 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">126 12 SocketStream 0 2048 12 SocketStream 12 SocketStream 0 0 0 0 0 0 0 0 0 0 0 0 97</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for iostreams that read and write to a (possibly non-blocking)</span>
 <span class="s0">* socket.</span>
 <span class="s0">*/</span>

<span class="s0">127 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 128 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">128 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">129 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 130 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">130 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 128 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">131 28 SocketStreamRecorder const * 0 8576 28 SocketStreamRecorder const * 28 SocketStreamRecorder const * 0 0 132 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">132 26 SocketStreamRecorder const 0 8832 26 SocketStreamRecorder const 26 SocketStreamRecorder const 0 0 102 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">133 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 103 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">0</span>
<span class="s0">0</span>
</pre>
</body>
</html>