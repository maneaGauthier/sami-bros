<html>
<head>
<title>libp3grutil.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3grutil.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">11 libp3grutil 4 sM0l 12 panda3d.core </span>
<span class="s0">237</span>
<span class="s0">263 9 CardMaker 0 260 500 20 CardMaker::CardMaker 0 2 1 2 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">inline explicit CardMaker::CardMaker(std::string const &amp;name);</span>
<span class="s0">inline CardMaker::CardMaker(CardMaker const &amp;) = default;</span>

<span class="s0">264 10 ~CardMaker 0 516 500 21 CardMaker::~CardMaker 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">inline CardMaker::~CardMaker(void);</span>

<span class="s0">265 5 reset 0 4 500 16 CardMaker::reset 0 1 3 63</span>
<span class="s0">/**</span>
 <span class="s0">* Resets all the parameters to their initial defaults.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">void CardMaker::reset(void);</span>

<span class="s0">266 12 set_uv_range 0 4 500 23 CardMaker::set_uv_range 0 5 4 5 6 7 8 1098</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices.  If</span>
 <span class="s0">* set_has_uvs() is true (as it is by default), the vertices will be generated</span>
 <span class="s0">* with the indicated range of UV's, which will be useful if a texture is</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices.  If</span>
 <span class="s0">* set_has_uvs() is true (as it is by default), the vertices will be generated</span>
 <span class="s0">* with the indicated range of UV's, which will be useful if a texture is</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices.  If</span>
 <span class="s0">* set_has_uvs() is true (as it is by default), the vertices will be generated</span>
 <span class="s0">* with the indicated range of UV's, which will be useful if a texture is</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices.  If</span>
 <span class="s0">* set_has_uvs() is true (as it is by default), the vertices will be generated</span>
 <span class="s0">* with the indicated range of UV's, which will be useful if a texture is</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices appropriately</span>
 <span class="s0">* to show the non-pad region of the texture.</span>
 <span class="s0">*/</span>
<span class="s0">440</span>
<span class="s0">void CardMaker::set_uv_range(LTexCoord const &amp;ll, LTexCoord const &amp;ur);</span>
<span class="s0">void CardMaker::set_uv_range(LTexCoord const &amp;ll, LTexCoord const &amp;lr, LTexCoord const &amp;ur, LTexCoord const &amp;ul);</span>
<span class="s0">void CardMaker::set_uv_range(LTexCoord3 const &amp;ll, LTexCoord3 const &amp;lr, LTexCoord3 const &amp;ur, LTexCoord3 const &amp;ul);</span>
<span class="s0">void CardMaker::set_uv_range(LVector4 const &amp;x, LVector4 const &amp;y, LVector4 const &amp;z);</span>
<span class="s0">void CardMaker::set_uv_range(Texture const *tex);</span>

<span class="s0">267 17 set_uv_range_cube 0 4 500 28 CardMaker::set_uv_range_cube 0 1 9 108</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices appropriately</span>
 <span class="s0">* for a cube-map face.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void CardMaker::set_uv_range_cube(int face);</span>

<span class="s0">268 11 set_has_uvs 0 4 500 22 CardMaker::set_has_uvs 0 1 10 91</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating whether vertices will be generated with UV's or</span>
 <span class="s0">* not.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void CardMaker::set_has_uvs(bool flag);</span>

<span class="s0">269 14 set_has_3d_uvs 0 4 500 25 CardMaker::set_has_3d_uvs 0 1 11 211</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating whether vertices will be generated with</span>
 <span class="s0">* 3-component UVW's (true) or 2-component UV's (the default, false).</span>
 <span class="s0">* Normally, this will be implicitly set by setting the uv_range.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void CardMaker::set_has_3d_uvs(bool flag);</span>

<span class="s0">270 9 set_frame 0 4 500 20 CardMaker::set_frame 0 3 12 13 14 115</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the size of the card.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the size of the card.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the size of the card.</span>
 <span class="s0">*/</span>
<span class="s0">275</span>
<span class="s0">inline void CardMaker::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);</span>
<span class="s0">inline void CardMaker::set_frame(LVecBase4 const &amp;frame);</span>
<span class="s0">inline void CardMaker::set_frame(LVertex const &amp;ll, LVertex const &amp;lr, LVertex const &amp;ur, LVertex const &amp;ul);</span>

<span class="s0">271 25 set_frame_fullscreen_quad 0 4 500 36 CardMaker::set_frame_fullscreen_quad 0 1 15 134</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the card to (-1,1,-1,1), which is appropriate if you plan to parent it</span>
 <span class="s0">* to render2d and use it as a fullscreen quad.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void CardMaker::set_frame_fullscreen_quad(void);</span>

<span class="s0">272 9 set_color 0 4 500 20 CardMaker::set_color 0 2 16 17 78</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color of the card.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the color of the card.</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">inline void CardMaker::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a);</span>
<span class="s0">inline void CardMaker::set_color(LColor const &amp;color);</span>

<span class="s0">273 15 set_has_normals 0 4 500 26 CardMaker::set_has_normals 0 1 18 355</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating whether vertices will be generated with normals or</span>
 <span class="s0">* not.  Normals are required if you intend to enable lighting on the card,</span>
 <span class="s0">* but are just wasted space and bandwidth otherwise, so there is a (slight)</span>
 <span class="s0">* optimization for disabling them.  If enabled, the normals will be generated</span>
 <span class="s0">* perpendicular to the card's face.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void CardMaker::set_has_normals(bool flag);</span>

<span class="s0">274 19 set_source_geometry 0 4 500 30 CardMaker::set_source_geometry 0 1 19 445</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a node that will be copied (and scaled and translated) to generate the</span>
 <span class="s0">* frame, instead of generating a new polygon.  The node may contain arbitrary</span>
 <span class="s0">* geometry that describes a flat polygon contained within the indicated left,</span>
 <span class="s0">* right, bottom, top frame.</span>
 <span class="s0">*</span>
 <span class="s0">* When generate() is called, the geometry in this node will be scaled and</span>
 <span class="s0">* translated appropriately to give it the size and aspect ratio specified by</span>
 <span class="s0">* set_frame().</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline void CardMaker::set_source_geometry(PandaNode *node, LVecBase4 const &amp;frame);</span>

<span class="s0">275 21 clear_source_geometry 0 4 500 32 CardMaker::clear_source_geometry 0 1 20 82</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the node specified by an earlier call to set_source_geometry().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void CardMaker::clear_source_geometry(void);</span>

<span class="s0">276 8 generate 0 4 500 19 CardMaker::generate 0 1 21 68</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a GeomNode that renders the specified geometry.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">PointerTo&lt; PandaNode &gt; CardMaker::generate(void);</span>

<span class="s0">277 12 FisheyeMaker 0 260 502 26 FisheyeMaker::FisheyeMaker 0 2 22 23 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">inline explicit FisheyeMaker::FisheyeMaker(std::string const &amp;name);</span>
<span class="s0">inline FisheyeMaker::FisheyeMaker(FisheyeMaker const &amp;) = default;</span>

<span class="s0">278 13 ~FisheyeMaker 0 516 502 27 FisheyeMaker::~FisheyeMaker 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline FisheyeMaker::~FisheyeMaker(void);</span>

<span class="s0">279 5 reset 0 4 502 19 FisheyeMaker::reset 0 1 24 63</span>
<span class="s0">/**</span>
 <span class="s0">* Resets all the parameters to their initial defaults.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void FisheyeMaker::reset(void);</span>

<span class="s0">280 7 set_fov 0 4 502 21 FisheyeMaker::set_fov 0 1 25 146</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the field of view of the fisheye projection.  A sphere map will</span>
 <span class="s0">* have a 360-degree field of view (and this is the default).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void FisheyeMaker::set_fov(PN_stdfloat fov);</span>

<span class="s0">281 16 set_num_vertices 0 4 502 30 FisheyeMaker::set_num_vertices 0 1 26 303</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the approximate number of vertices to be used to generate the</span>
 <span class="s0">* rose.  This is the approximate number of vertices that will be located</span>
 <span class="s0">* within the rose's unit circle, not counting the inscribing square (if any).</span>
 <span class="s0">* The actual number of vertices used may be +/- 25% of this value.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void FisheyeMaker::set_num_vertices(int num_vertices);</span>

<span class="s0">282 20 set_square_inscribed 0 4 502 34 FisheyeMaker::set_square_inscribed 0 1 27 577</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates whether the rose should be inscribed within a</span>
 <span class="s0">* square.  When this is true, an additional square is generated to inscribed</span>
 <span class="s0">* the circular rose, with the indicated &quot;radius&quot; (the sides of the square</span>
 <span class="s0">* will be 2 * square_radius).  The texture coordinates of the square will</span>
 <span class="s0">* uniformly map to the back pole of the cube map.</span>
 <span class="s0">*</span>
 <span class="s0">* This is mainly useful to provide a good uniform background color for a</span>
 <span class="s0">* sphere map so that it does not have a sharp circular edge that might</span>
 <span class="s0">* produce artifacts due to numerical imprecision when mapping.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">inline void FisheyeMaker::set_square_inscribed(bool square_inscribed, PN_stdfloat square_radius);</span>

<span class="s0">283 14 set_reflection 0 4 502 28 FisheyeMaker::set_reflection 0 1 28 327</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating whether the texture image should be mirrored</span>
 <span class="s0">* (true) or normal (false).  When this is true, the 3-D texture coordinates</span>
 <span class="s0">* will be reversed so that the image is appropriate for a reflection.  This</span>
 <span class="s0">* is the best choice for generating a sphere map from a cube map.  The</span>
 <span class="s0">* default is false.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void FisheyeMaker::set_reflection(bool reflection);</span>

<span class="s0">284 8 generate 0 4 502 22 FisheyeMaker::generate 0 1 29 68</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a GeomNode that renders the specified geometry.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">PointerTo&lt; PandaNode &gt; FisheyeMaker::generate(void);</span>

<span class="s0">285 14 FrameRateMeter 0 260 503 30 FrameRateMeter::FrameRateMeter 0 2 30 31 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">138</span>
<span class="s0">explicit FrameRateMeter::FrameRateMeter(std::string const &amp;name);</span>
<span class="s0">inline FrameRateMeter::FrameRateMeter(FrameRateMeter const &amp;) = default;</span>

<span class="s0">286 12 setup_window 0 4 503 28 FrameRateMeter::setup_window 0 1 32 112</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the frame rate meter to create a DisplayRegion to render itself</span>
 <span class="s0">* into the indicated window.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void FrameRateMeter::setup_window(GraphicsOutput *window);</span>

<span class="s0">287 12 clear_window 0 4 503 28 FrameRateMeter::clear_window 0 1 33 66</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of a previous call to setup_window().</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void FrameRateMeter::clear_window(void);</span>

<span class="s0">288 10 get_window 0 4 503 26 FrameRateMeter::get_window 0 1 34 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the GraphicsOutput that was passed to setup_window(), or NULL if</span>
 <span class="s0">* setup_window() has not been called.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline GraphicsOutput *FrameRateMeter::get_window(void) const;</span>

<span class="s0">289 18 get_display_region 0 4 503 34 FrameRateMeter::get_display_region 0 1 35 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DisplayRegion that the meter has created to render itself into</span>
 <span class="s0">* the window to setup_window(), or NULL if setup_window() has not been</span>
 <span class="s0">* called.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline DisplayRegion *FrameRateMeter::get_display_region(void) const;</span>

<span class="s0">290 19 set_update_interval 0 4 503 35 FrameRateMeter::set_update_interval 0 1 36 255</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of seconds that should elapse between updates to the</span>
 <span class="s0">* frame rate indication.  This should be reasonably slow (e.g.  0.2 to 1.0)</span>
 <span class="s0">* so that the calculation of the frame rate text does not itself dominate the</span>
 <span class="s0">* frame rate.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void FrameRateMeter::set_update_interval(double update_interval);</span>

<span class="s0">291 19 get_update_interval 0 4 503 35 FrameRateMeter::get_update_interval 0 1 37 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of seconds that will elapse between updates to the frame</span>
 <span class="s0">* rate indication.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline double FrameRateMeter::get_update_interval(void) const;</span>

<span class="s0">292 16 set_text_pattern 0 4 503 32 FrameRateMeter::set_text_pattern 0 1 38 176</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the sprintf() pattern that is used to format the text.  The string</span>
 <span class="s0">* &quot;%f&quot; or some variant will be replaced with the current frame rate in frames</span>
 <span class="s0">* per second.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline void FrameRateMeter::set_text_pattern(std::string const &amp;text_pattern);</span>

<span class="s0">293 16 get_text_pattern 0 4 503 32 FrameRateMeter::get_text_pattern 0 1 39 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sprintf() pattern that is used to format the text.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline std::string const &amp;FrameRateMeter::get_text_pattern(void) const;</span>

<span class="s0">294 16 set_clock_object 0 4 503 32 FrameRateMeter::set_clock_object 0 1 40 152</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the clock that is used to determine the frame rate.  The default is</span>
 <span class="s0">* the application's global clock (ClockObject::get_global_clock()).</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void FrameRateMeter::set_clock_object(ClockObject *clock_object);</span>

<span class="s0">295 16 get_clock_object 0 4 503 32 FrameRateMeter::get_clock_object 0 1 41 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the clock that is used to determine the frame rate.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline ClockObject *FrameRateMeter::get_clock_object(void) const;</span>

<span class="s0">296 6 update 0 4 503 22 FrameRateMeter::update 0 1 42 186</span>
<span class="s0">/**</span>
 <span class="s0">* You can call this to explicitly force the FrameRateMeter to update itself</span>
 <span class="s0">* with the latest frame rate information.  Normally, it is not necessary to</span>
 <span class="s0">* call this explicitly.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void FrameRateMeter::update(void);</span>

<span class="s0">297 14 get_class_type 0 4 503 30 FrameRateMeter::get_class_type 0 1 43 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle FrameRateMeter::get_class_type(void);</span>

<span class="s0">298 13 GeoMipTerrain 0 260 505 28 GeoMipTerrain::GeoMipTerrain 0 1 44 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline explicit GeoMipTerrain::GeoMipTerrain(std::string const &amp;name);</span>

<span class="s0">299 11 heightfield 0 4 505 26 GeoMipTerrain::heightfield 0 1 45 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a reference to the heightfield (a PNMImage) contained inside</span>
 <span class="s0">* GeoMipTerrain.  You can use the reference to alter the heightfield.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline PNMImage &amp;GeoMipTerrain::heightfield(void);</span>

<span class="s0">300 15 set_heightfield 0 4 505 30 GeoMipTerrain::set_heightfield 0 2 46 47 466</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the specified heightmap image file into the heightfield.  Returns</span>
 <span class="s0">* true if succeeded, or false if an error has occured.  If the heightmap is</span>
 <span class="s0">* not a power of two plus one, it is scaled up using a gaussian filter.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Loads the specified heightmap image file into the heightfield.  Returns</span>
 <span class="s0">* true if succeeded, or false if an error has occured.  If the heightmap is</span>
 <span class="s0">* not a power of two plus one, it is scaled up using a gaussian filter.</span>
 <span class="s0">*/</span>
<span class="s0">158</span>
<span class="s0">bool GeoMipTerrain::set_heightfield(Filename const &amp;filename, PNMFileType *type = nullptr);</span>
<span class="s0">inline bool GeoMipTerrain::set_heightfield(PNMImage const &amp;image);</span>

<span class="s0">301 9 color_map 0 4 505 24 GeoMipTerrain::color_map 0 1 48 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a reference to the color map (a PNMImage) contained inside</span>
 <span class="s0">* GeoMipTerrain.  You can use the reference to alter the color map.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline PNMImage &amp;GeoMipTerrain::color_map(void);</span>

<span class="s0">302 13 set_color_map 0 4 505 28 GeoMipTerrain::set_color_map 0 4 49 50 51 52 234</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the specified image as color map.  The next time generate() is</span>
 <span class="s0">* called, the terrain is painted with this color map using the vertex color</span>
 <span class="s0">* column.  Returns a boolean indicating whether the operation has succeeded.</span>
 <span class="s0">*/</span>
<span class="s0">292</span>
<span class="s0">inline bool GeoMipTerrain::set_color_map(Filename const &amp;filename, PNMFileType *type = nullptr);</span>
<span class="s0">inline bool GeoMipTerrain::set_color_map(PNMImage const &amp;image);</span>
<span class="s0">inline bool GeoMipTerrain::set_color_map(Texture const *image);</span>
<span class="s0">inline bool GeoMipTerrain::set_color_map(std::string const &amp;path);</span>

<span class="s0">303 13 has_color_map 0 4 505 28 GeoMipTerrain::has_color_map 0 1 53 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether a color map has been set.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool GeoMipTerrain::has_color_map(void) const;</span>

<span class="s0">304 15 clear_color_map 0 4 505 30 GeoMipTerrain::clear_color_map 0 1 54 32</span>
<span class="s0">/**</span>
 <span class="s0">* Clears the color map.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void GeoMipTerrain::clear_color_map(void);</span>

<span class="s0">305 22 calc_ambient_occlusion 0 4 505 37 GeoMipTerrain::calc_ambient_occlusion 0 1 55 250</span>
<span class="s0">/**</span>
 <span class="s0">* Calculates an approximate for the ambient occlusion and stores it in the</span>
 <span class="s0">* color map, so that it will be written to the vertex colors.  Any existing</span>
 <span class="s0">* color map will be discarded.  You need to call this before generating the</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/</span>
<span class="s0">141</span>
<span class="s0">void GeoMipTerrain::calc_ambient_occlusion(PN_stdfloat radius = 32, PN_stdfloat contrast = 2.0, PN_stdfloat brightness = 0.7500000000000001);</span>

<span class="s0">306 13 get_elevation 0 4 505 28 GeoMipTerrain::get_elevation 0 1 56 410</span>
<span class="s0">/**</span>
 <span class="s0">* Fetches the elevation at (x, y), where the input coordinate is specified in</span>
 <span class="s0">* pixels.  This ignores the current LOD level and instead provides an</span>
 <span class="s0">* accurate number.  Linear blending is used for non-integral coordinates.</span>
 <span class="s0">* Terrain scale is NOT taken into account!  To get accurate normals, please</span>
 <span class="s0">* multiply this with the terrain Z scale!</span>
 <span class="s0">*</span>
 <span class="s0">* trueElev = terr.get_elevation(x,y) * terr.get_sz();</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">double GeoMipTerrain::get_elevation(double x, double y);</span>

<span class="s0">307 10 get_normal 0 4 505 25 GeoMipTerrain::get_normal 0 2 57 58 829</span>
<span class="s0">/**</span>
 <span class="s0">* Fetches the terrain normal at (x,y), where the input coordinate is</span>
 <span class="s0">* specified in pixels.  This ignores the current LOD level and instead</span>
 <span class="s0">* provides an accurate number.  Terrain scale is NOT taken into account!  To</span>
 <span class="s0">* get accurate normals, please divide it by the terrain scale and normalize</span>
 <span class="s0">* it again!</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fetches the terrain normal at (x, y), where the input coordinate is</span>
 <span class="s0">* specified in pixels.  This ignores the current LOD level and instead</span>
 <span class="s0">* provides an accurate number.  Terrain scale is NOT taken into account!  To</span>
 <span class="s0">* get accurate normals, please divide it by the terrain scale and normalize</span>
 <span class="s0">* it again, like this:</span>
 <span class="s0">*</span>
 <span class="s0">* LVector3 normal (terr.get_normal(x, y)); normal.set(normal.get_x() /</span>
 <span class="s0">* root.get_sx(), normal.get_y() / root.get_sy(), normal.get_z() /</span>
 <span class="s0">* root.get_sz()); normal.normalize();</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">LVector3 GeoMipTerrain::get_normal(int x, int y);</span>
<span class="s0">inline LVector3 GeoMipTerrain::get_normal(unsigned short int mx, unsigned short int my, int x, int y);</span>

<span class="s0">308 14 set_bruteforce 0 4 505 29 GeoMipTerrain::set_bruteforce 0 1 59 238</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a boolean specifying whether the terrain will be rendered bruteforce.</span>
 <span class="s0">* If the terrain is rendered bruteforce, there will be no Level of Detail,</span>
 <span class="s0">* and the update() call will only update the terrain if it is marked dirty.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void GeoMipTerrain::set_bruteforce(bool bf);</span>

<span class="s0">309 14 get_bruteforce 0 4 505 29 GeoMipTerrain::get_bruteforce 0 1 60 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a boolean whether the terrain is rendered bruteforce or not.  See</span>
 <span class="s0">* set_bruteforce for more information.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool GeoMipTerrain::get_bruteforce(void);</span>

<span class="s0">310 16 set_auto_flatten 0 4 505 31 GeoMipTerrain::set_auto_flatten 0 1 61 210</span>
<span class="s0">/**</span>
 <span class="s0">* The terrain can be automatically flattened (using flatten_light,</span>
 <span class="s0">* flatten_medium, or flatten_strong) after each update.  This only affects</span>
 <span class="s0">* future updates, it doesn't flatten the current terrain.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void GeoMipTerrain::set_auto_flatten(int mode);</span>

<span class="s0">311 15 set_focal_point 0 4 505 30 GeoMipTerrain::set_focal_point 0 6 62 63 64 65 66 67 628</span>
<span class="s0">// The focal point is the point at which the terrain will have the highest</span>
<span class="s0">// quality (lowest level of detail). Parts farther away from the focal point</span>
<span class="s0">// will have a lower quality (higher level of detail). The focal point is</span>
<span class="s0">// not taken in respect if bruteforce is set true.</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the focal point.  GeoMipTerrain generates high-resolution terrain</span>
 <span class="s0">* around the focal point, and progressively lower and lower resolution</span>
 <span class="s0">* terrain as you get farther away.  If a point is supplied and not a</span>
 <span class="s0">* NodePath, make sure it's relative to the terrain.  Only the x and y</span>
 <span class="s0">* coordinates of the focal point are taken in respect.</span>
 <span class="s0">*/</span>
<span class="s0">377</span>
<span class="s0">inline void GeoMipTerrain::set_focal_point(LPoint2d const &amp;fp);</span>
<span class="s0">inline void GeoMipTerrain::set_focal_point(LPoint2f const &amp;fp);</span>
<span class="s0">inline void GeoMipTerrain::set_focal_point(LPoint3d const &amp;fp);</span>
<span class="s0">inline void GeoMipTerrain::set_focal_point(LPoint3f const &amp;fp);</span>
<span class="s0">inline void GeoMipTerrain::set_focal_point(double x, double y);</span>
<span class="s0">inline void GeoMipTerrain::set_focal_point(NodePath fnp);</span>

<span class="s0">312 15 get_focal_point 0 4 505 30 GeoMipTerrain::get_focal_point 0 1 68 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the focal point, as a NodePath.  If you have set it to be just a</span>
 <span class="s0">* point, it will return an empty node at the focal position.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline NodePath GeoMipTerrain::get_focal_point(void) const;</span>

<span class="s0">313 8 get_root 0 4 505 23 GeoMipTerrain::get_root 0 1 69 258</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the root of the terrain.  This is a single PandaNode to which all</span>
 <span class="s0">* the rest of the terrain is parented.  The generate and update operations</span>
 <span class="s0">* replace the nodes which are parented to this root, but they don't replace</span>
 <span class="s0">* this root itself.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline NodePath GeoMipTerrain::get_root(void) const;</span>

<span class="s0">314 14 set_block_size 0 4 505 29 GeoMipTerrain::set_block_size 0 1 70 98</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the block size.  If it is not a power of two, the closest power of two</span>
 <span class="s0">* is used.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void GeoMipTerrain::set_block_size(unsigned short int newbs);</span>

<span class="s0">315 14 get_block_size 0 4 505 29 GeoMipTerrain::get_block_size 0 1 71 31</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the block size.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline unsigned short int GeoMipTerrain::get_block_size(void);</span>

<span class="s0">316 13 get_max_level 0 4 505 28 GeoMipTerrain::get_max_level 0 1 72 140</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the highest level possible for this block size.  When a block is at</span>
 <span class="s0">* this level, it will be the worst quality possible.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline unsigned short int GeoMipTerrain::get_max_level(void);</span>

<span class="s0">317 13 set_min_level 0 4 505 28 GeoMipTerrain::set_min_level 0 1 73 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the minimum level of detail at which blocks may be generated by</span>
 <span class="s0">* generate() or update(). The default value is 0, which is the highest</span>
 <span class="s0">* quality.  This value is also taken in respect when generating the terrain</span>
 <span class="s0">* bruteforce.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void GeoMipTerrain::set_min_level(unsigned short int minlevel);</span>

<span class="s0">318 13 get_min_level 0 4 505 28 GeoMipTerrain::get_min_level 0 1 74 163</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the minimum level of detail at which blocks may be generated by</span>
 <span class="s0">* generate() or update(). The default value is 0, which is the highest</span>
 <span class="s0">* quality.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline unsigned short int GeoMipTerrain::get_min_level(void);</span>

<span class="s0">319 8 is_dirty 0 4 505 23 GeoMipTerrain::is_dirty 0 1 75 298</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a bool indicating whether the terrain is marked 'dirty', that means</span>
 <span class="s0">* the terrain has to be regenerated on the next update() call, because for</span>
 <span class="s0">* instance the heightfield has changed.  Once the terrain has been</span>
 <span class="s0">* regenerated, the dirty flag automatically gets reset internally.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool GeoMipTerrain::is_dirty(void);</span>

<span class="s0">320 10 set_factor 0 4 505 25 GeoMipTerrain::set_factor 0 1 76 334</span>
<span class="s0">/**</span>
 <span class="s0">* DEPRECATED method.  Use set_near/far instead.  Sets the quality factor at</span>
 <span class="s0">* which blocks must be generated.  The higher this level, the better quality</span>
 <span class="s0">* the terrain will be, but more expensive to render.  A value of 0 makes the</span>
 <span class="s0">* terrain the lowest quality possible, depending on blocksize.  The default</span>
 <span class="s0">* value is 100.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void GeoMipTerrain::set_factor(PN_stdfloat factor);</span>

<span class="s0">321 12 set_near_far 0 4 505 27 GeoMipTerrain::set_near_far 0 1 77 59</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the near and far LOD distances in one call.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void GeoMipTerrain::set_near_far(double input_near, double input_far);</span>

<span class="s0">322 8 set_near 0 4 505 23 GeoMipTerrain::set_near 0 1 78 152</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the near LOD distance, at which the terrain will be rendered at</span>
 <span class="s0">* highest quality.  This distance is in the terrain's coordinate space!</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void GeoMipTerrain::set_near(double input_near);</span>

<span class="s0">323 7 set_far 0 4 505 22 GeoMipTerrain::set_far 0 1 79 150</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the far LOD distance, at which the terrain will be rendered at lowest</span>
 <span class="s0">* quality.  This distance is in the terrain's coordinate space!</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void GeoMipTerrain::set_far(double input_far);</span>

<span class="s0">324 19 get_block_node_path 0 4 505 34 GeoMipTerrain::get_block_node_path 0 1 80 380</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath of the specified block.  If auto-flatten is enabled</span>
 <span class="s0">* and the node is getting removed during the flattening process, it will</span>
 <span class="s0">* still return a NodePath with the appropriate terrain chunk, but it will be</span>
 <span class="s0">* in a temporary scenegraph.  Please note that this returns a const object</span>
 <span class="s0">* and you can not modify the node.  Modify the heightfield instead.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">inline NodePath const GeoMipTerrain::get_block_node_path(unsigned short int mx, unsigned short int my);</span>

<span class="s0">325 18 get_block_from_pos 0 4 505 33 GeoMipTerrain::get_block_from_pos 0 1 81 479</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the coordinates of the block at the specified position.  This position</span>
 <span class="s0">* must be relative to the terrain, not to render.  Returns an array</span>
 <span class="s0">* containing two values: the block x and the block y coords.  If the</span>
 <span class="s0">* positions are out of range, the closest block is taken.  Note that the</span>
 <span class="s0">* VecBase returned does not represent a vector, position, or rotation, but it</span>
 <span class="s0">* contains the block index of the block which you can use in</span>
 <span class="s0">* GeoMipTerrain::get_block_node_path.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline LVecBase2 GeoMipTerrain::get_block_from_pos(double x, double y);</span>

<span class="s0">326 20 set_border_stitching 0 4 505 35 GeoMipTerrain::set_border_stitching 0 1 82 360</span>
<span class="s0">/**</span>
 <span class="s0">* If this value is true, the LOD level at the borders of the terrain will be</span>
 <span class="s0">* 0. This is useful if you have multiple terrains attached and you want to</span>
 <span class="s0">* stitch them together, to fix seams.  This setting also has effect when</span>
 <span class="s0">* bruteforce is enabled, although in that case you are probably better off</span>
 <span class="s0">* with setting the minlevels to the same value.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void GeoMipTerrain::set_border_stitching(bool stitching);</span>

<span class="s0">327 20 get_border_stitching 0 4 505 35 GeoMipTerrain::get_border_stitching 0 1 83 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current stitching setting.  False by default, unless</span>
 <span class="s0">* set_stitching has been set.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool GeoMipTerrain::get_border_stitching(void);</span>

<span class="s0">328 7 get_far 0 4 505 22 GeoMipTerrain::get_far 0 1 84 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the far LOD distance in the terrain coordinate space</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline double GeoMipTerrain::get_far(void);</span>

<span class="s0">329 8 get_near 0 4 505 23 GeoMipTerrain::get_near 0 1 85 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the near LOD distance in the terrain coordinate space</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline double GeoMipTerrain::get_near(void);</span>

<span class="s0">330 16 get_flatten_mode 0 4 505 31 GeoMipTerrain::get_flatten_mode 0 1 86 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the automatic-flatten mode (e.g., off, flatten_light,</span>
 <span class="s0">* flatten_medium, or flatten_strong)</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int GeoMipTerrain::get_flatten_mode(void);</span>

<span class="s0">331 16 make_slope_image 0 4 505 31 GeoMipTerrain::make_slope_image 0 1 87 520</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new grayscale image containing the slope angles.  A white pixel</span>
 <span class="s0">* value means a vertical slope, while a black pixel will mean that the</span>
 <span class="s0">* terrain is entirely flat at that pixel.  You can translate it to degrees by</span>
 <span class="s0">* mapping the greyscale values from 0 to 90 degrees.  The resulting image</span>
 <span class="s0">* will have the same size as the heightfield image.  The scale will be taken</span>
 <span class="s0">* into respect -- meaning, if you change the terrain scale, the slope image</span>
 <span class="s0">* will need to be regenerated in order to be correct.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">PNMImage GeoMipTerrain::make_slope_image(void);</span>

<span class="s0">332 8 generate 0 4 505 23 GeoMipTerrain::generate 0 1 88 191</span>
<span class="s0">/**</span>
 <span class="s0">* (Re)generates the entire terrain, erasing the current.  This call un-</span>
 <span class="s0">* flattens the terrain, so make sure you have set auto-flatten if you want to</span>
 <span class="s0">* keep your terrain flattened.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">void GeoMipTerrain::generate(void);</span>

<span class="s0">333 6 update 0 4 505 21 GeoMipTerrain::update 0 1 89 447</span>
<span class="s0">/**</span>
 <span class="s0">* Loops through all of the terrain blocks, and checks whether they need to be</span>
 <span class="s0">* updated.  If that is indeed the case, it regenerates the mipmap.  Returns a</span>
 <span class="s0">* true when the terrain has changed.  Returns false when the terrain isn't</span>
 <span class="s0">* updated at all.  If there is no terrain yet, it generates the entire</span>
 <span class="s0">* terrain.  This call un-flattens the terrain, so make sure you have set</span>
 <span class="s0">* auto-flatten if you want to keep your terrain flattened.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">bool GeoMipTerrain::update(void);</span>

<span class="s0">334 14 get_class_type 0 4 505 29 GeoMipTerrain::get_class_type 0 1 90 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle GeoMipTerrain::get_class_type(void);</span>

<span class="s0">335 21 HeightfieldTesselator 0 260 508 44 HeightfieldTesselator::HeightfieldTesselator 0 2 91 92 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">180</span>
<span class="s0">inline explicit HeightfieldTesselator::HeightfieldTesselator(std::string const &amp;name);</span>
<span class="s0">inline HeightfieldTesselator::HeightfieldTesselator(HeightfieldTesselator const &amp;) = default;</span>

<span class="s0">336 22 ~HeightfieldTesselator 0 516 508 45 HeightfieldTesselator::~HeightfieldTesselator 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline HeightfieldTesselator::~HeightfieldTesselator(void);</span>

<span class="s0">337 11 heightfield 0 4 508 34 HeightfieldTesselator::heightfield 0 1 93 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a reference to the heightfield (a PNMImage) contained inside the</span>
 <span class="s0">* HeightfieldTesselator.  You can use the reference to alter the heightfield.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline PNMImage &amp;HeightfieldTesselator::heightfield(void);</span>

<span class="s0">338 15 set_heightfield 0 4 508 38 HeightfieldTesselator::set_heightfield 0 1 94 73</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the specified greyscale image file into the heightfield.</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">inline bool HeightfieldTesselator::set_heightfield(Filename const &amp;filename, PNMFileType *type = nullptr);</span>

<span class="s0">339 14 set_poly_count 0 4 508 37 HeightfieldTesselator::set_poly_count 0 1 95 131</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the polygon-count target.  The tesselator usually manages to come</span>
 <span class="s0">* within about 20% of the target, plus or minus.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void HeightfieldTesselator::set_poly_count(int n);</span>

<span class="s0">340 21 set_visibility_radius 0 4 508 44 HeightfieldTesselator::set_visibility_radius 0 1 96 354</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the visibility radius.  Polygons that are completely outside the</span>
 <span class="s0">* radius (relative to the focal point) are cropped away.  The cropping is</span>
 <span class="s0">* imperfect (all approximations are conservative), so this should be used in</span>
 <span class="s0">* conjunction with a far clipping plane, fog, or some other visibility</span>
 <span class="s0">* limiting mechanism.  The units are in pixels.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void HeightfieldTesselator::set_visibility_radius(int r);</span>

<span class="s0">341 15 set_focal_point 0 4 508 38 HeightfieldTesselator::set_focal_point 0 1 97 216</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the focal point.  The tesselator generates high-resolution terrain</span>
 <span class="s0">* around the focal point, and progressively lower and lower resolution</span>
 <span class="s0">* terrain as you get farther away.  The units are in pixels.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void HeightfieldTesselator::set_focal_point(int x, int y);</span>

<span class="s0">342 20 set_horizontal_scale 0 4 508 43 HeightfieldTesselator::set_horizontal_scale 0 1 98 135</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the horizontal scale.  The default scale is 1.0, meaning that each</span>
 <span class="s0">* pixel in the heightfield is 1x1 panda units wide.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void HeightfieldTesselator::set_horizontal_scale(double h);</span>

<span class="s0">343 18 set_vertical_scale 0 4 508 41 HeightfieldTesselator::set_vertical_scale 0 1 99 162</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the vertical scale.  The default scale is 255.0, meaning that each as</span>
 <span class="s0">* the gray value ranges from (0-1), the elevation ranges from (0-255) feet.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void HeightfieldTesselator::set_vertical_scale(double v);</span>

<span class="s0">344 17 set_max_triangles 0 4 508 40 HeightfieldTesselator::set_max_triangles 0 1 100 43</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the max triangles per geom.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void HeightfieldTesselator::set_max_triangles(int n);</span>

<span class="s0">345 13 get_elevation 0 4 508 36 HeightfieldTesselator::get_elevation 0 1 101 239</span>
<span class="s0">/**</span>
 <span class="s0">* Fetches the elevation at (x,y), where the input coordinate is specified in</span>
 <span class="s0">* pixels.  This ignores the current tesselation level and instead provides an</span>
 <span class="s0">* accurate number.  Linear blending is used for non-integral coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">double HeightfieldTesselator::get_elevation(double x, double y);</span>

<span class="s0">346 8 generate 0 4 508 31 HeightfieldTesselator::generate 0 1 102 112</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a tree of nodes that represents the heightfield.  This can be</span>
 <span class="s0">* reparented into the scene.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">NodePath HeightfieldTesselator::generate(void);</span>

<span class="s0">347 8 LineSegs 0 260 509 18 LineSegs::LineSegs 0 2 103 104 352</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a LineSegs object, which can be used to create any number of</span>
 <span class="s0">* disconnected lines or points of various thicknesses and colors through the</span>
 <span class="s0">* visible scene.  After creating the object, call move_to() and draw_to()</span>
 <span class="s0">* repeatedly to describe the path, then call create() to create a GeomNode</span>
 <span class="s0">* which will render the described path.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">explicit LineSegs::LineSegs(std::string const &amp;name = &quot;lines&quot;);</span>
<span class="s0">inline LineSegs::LineSegs(LineSegs const &amp;) = default;</span>

<span class="s0">348 9 ~LineSegs 0 516 509 19 LineSegs::~LineSegs 0 0 8</span>
<span class="s0">/**</span>

 <span class="s0">*/</span>
<span class="s0">26</span>
<span class="s0">LineSegs::~LineSegs(void);</span>

<span class="s0">349 5 reset 0 4 509 15 LineSegs::reset 0 1 105 79</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any lines in progress and resets to the initial empty state.</span>
 <span class="s0">*/</span>
<span class="s0">27</span>
<span class="s0">void LineSegs::reset(void);</span>

<span class="s0">350 9 set_color 0 4 509 19 LineSegs::set_color 0 2 106 107 252</span>
<span class="s0">/**</span>
 <span class="s0">* Establishes the color that will be assigned to all vertices created by</span>
 <span class="s0">* future calls to move_to() and draw_to().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Establishes the color that will be assigned to all vertices created by</span>
 <span class="s0">* future calls to move_to() and draw_to().</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">inline void LineSegs::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0);</span>
<span class="s0">inline void LineSegs::set_color(LColor const &amp;color);</span>

<span class="s0">351 13 set_thickness 0 4 509 23 LineSegs::set_thickness 0 1 108 151</span>
<span class="s0">/**</span>
 <span class="s0">* Establishes the line thickness or point size in pixels that will be</span>
 <span class="s0">* assigned to all lines and points created by future calls to create().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void LineSegs::set_thickness(PN_stdfloat thick);</span>

<span class="s0">352 7 move_to 0 4 509 17 LineSegs::move_to 0 2 109 110 436</span>
<span class="s0">/**</span>
 <span class="s0">* Moves the pen to the given point without drawing a line.  When followed by</span>
 <span class="s0">* draw_to(), this marks the first point of a line segment; when followed by</span>
 <span class="s0">* move_to() or create(), this creates a single point.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Moves the pen to the given point without drawing a line.  When followed by</span>
 <span class="s0">* draw_to(), this marks the first point of a line segment; when followed by</span>
 <span class="s0">* move_to() or create(), this creates a single point.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">inline void LineSegs::move_to(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void LineSegs::move_to(LVecBase3 const &amp;v);</span>

<span class="s0">353 7 draw_to 0 4 509 17 LineSegs::draw_to 0 2 111 112 462</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a line segment from the pen's last position (the last call to move_to</span>
 <span class="s0">* or draw_to) to the indicated point.  move_to() and draw_to() only update</span>
 <span class="s0">* tables; the actual drawing is performed when create() is called.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Draws a line segment from the pen's last position (the last call to move_to</span>
 <span class="s0">* or draw_to) to the indicated point.  move_to() and draw_to() only update</span>
 <span class="s0">* tables; the actual drawing is performed when create() is called.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">inline void LineSegs::draw_to(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void LineSegs::draw_to(LVecBase3 const &amp;v);</span>

<span class="s0">354 20 get_current_position 0 4 509 30 LineSegs::get_current_position 0 1 113 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pen's current position.  The next call to draw_to() will draw a</span>
 <span class="s0">* line segment from this point.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">LVertex const &amp;LineSegs::get_current_position(void);</span>

<span class="s0">355 8 is_empty 0 4 509 18 LineSegs::is_empty 0 1 114 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if move_to() or draw_to() have not been called since the last</span>
 <span class="s0">* reset() or create(), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">bool LineSegs::is_empty(void);</span>

<span class="s0">356 6 create 0 4 509 16 LineSegs::create 0 2 115 116 833</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new GeomNode that will render the series of line segments and</span>
 <span class="s0">* points described via calls to move_to() and draw_to().  The lines and</span>
 <span class="s0">* points are created with the color and thickness established by calls to</span>
 <span class="s0">* set_color() and set_thickness().</span>
 <span class="s0">*</span>
 <span class="s0">* If dynamic is true, the line segments will be created with the dynamic Geom</span>
 <span class="s0">* setting, optimizing them for runtime vertex animation.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Appends to an existing GeomNode a new Geom that will render the series of</span>
 <span class="s0">* line segments and points described via calls to move_to() and draw_to().</span>
 <span class="s0">* The lines and points are created with the color and thickness established</span>
 <span class="s0">* by calls to set_color() and set_thickness().</span>
 <span class="s0">*</span>
 <span class="s0">* If dynamic is true, the line segments will be created with the dynamic Geom</span>
 <span class="s0">* setting, optimizing them for runtime vertex animation.</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">inline GeomNode *LineSegs::create(bool dynamic = false);</span>
<span class="s0">GeomNode *LineSegs::create(GeomNode *previous, bool dynamic = false);</span>

<span class="s0">357 16 get_num_vertices 0 4 509 26 LineSegs::get_num_vertices 0 1 117 423</span>
<span class="s0">// Functions to move the line vertices after they have been created.</span>

<span class="s0">// Functions to move the line vertices after they have been created.</span>

<span class="s0">// Functions to move the line vertices after they have been created.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the total number of line segment and point vertices generated by</span>
 <span class="s0">* the last call to create().  The positions of these vertices may be read and</span>
 <span class="s0">* adjusted through get_vertex() and set_vertex().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int LineSegs::get_num_vertices(void) const;</span>

<span class="s0">358 10 get_vertex 0 4 509 20 LineSegs::get_vertex 0 1 118 248</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth point or vertex of the line segment sequence generated by</span>
 <span class="s0">* the last call to create().  The first move_to() generates vertex 0;</span>
 <span class="s0">* subsequent move_to() and draw_to() calls generate consecutively higher</span>
 <span class="s0">* vertex numbers.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">LVertex LineSegs::get_vertex(int n) const;</span>

<span class="s0">359 10 set_vertex 0 4 509 20 LineSegs::set_vertex 0 2 119 120 488</span>
<span class="s0">/**</span>
 <span class="s0">* Moves the nth point or vertex of the line segment sequence generated by the</span>
 <span class="s0">* last call to create().  The first move_to() generates vertex 0; subsequent</span>
 <span class="s0">* move_to() and draw_to() calls generate consecutively higher vertex numbers.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Moves the nth point or vertex of the line segment sequence generated by the</span>
 <span class="s0">* last call to create().  The first move_to() generates vertex 0; subsequent</span>
 <span class="s0">* move_to() and draw_to() calls generate consecutively higher vertex numbers.</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">void LineSegs::set_vertex(int n, LVertex const &amp;vert);</span>
<span class="s0">inline void LineSegs::set_vertex(int vertex, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">360 16 get_vertex_color 0 4 509 26 LineSegs::get_vertex_color 0 1 121 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color of the nth point or vertex.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">LColor LineSegs::get_vertex_color(int vertex) const;</span>

<span class="s0">361 16 set_vertex_color 0 4 509 26 LineSegs::set_vertex_color 0 2 122 123 166</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the vertex color of the nth point or vertex.  See set_vertex().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes the vertex color of the nth point or vertex.  See set_vertex().</span>
 <span class="s0">*/</span>
<span class="s0">179</span>
<span class="s0">void LineSegs::set_vertex_color(int vertex, LColor const &amp;c);</span>
<span class="s0">inline void LineSegs::set_vertex_color(int vertex, PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0);</span>

<span class="s0">362 10 MeshDrawer 0 260 510 22 MeshDrawer::MeshDrawer 0 1 124 51</span>
<span class="s0">/**</span>
 <span class="s0">* Creates the MeshDrawer low level system.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">inline MeshDrawer::MeshDrawer(void);</span>

<span class="s0">363 10 set_budget 0 4 510 22 MeshDrawer::set_budget 0 1 125 142</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the total triangle budget of the drawer.  This will not be exceeded.</span>
 <span class="s0">* Don't set some thing too large because it will be slow</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void MeshDrawer::set_budget(int budget);</span>

<span class="s0">364 10 get_budget 0 4 510 22 MeshDrawer::get_budget 0 1 126 55</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the total triangle budget of the drawer</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline int MeshDrawer::get_budget(void);</span>

<span class="s0">365 8 get_root 0 4 510 20 MeshDrawer::get_root 0 1 127 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the root NodePath.  You should use this node to reparent mesh</span>
 <span class="s0">* drawer onto the scene might also want to disable depth draw or enable</span>
 <span class="s0">* transparency.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline NodePath MeshDrawer::get_root(void);</span>

<span class="s0">366 5 begin 0 4 510 17 MeshDrawer::begin 0 1 128 131</span>
<span class="s0">/**</span>
 <span class="s0">* Pass the current camera node and the root node.  Passing the camera is</span>
 <span class="s0">* required to generate bill boards that face it.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void MeshDrawer::begin(NodePath camera, NodePath render);</span>

<span class="s0">367 3 tri 0 4 510 15 MeshDrawer::tri 0 1 129 54</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a triangle with the given parameters.</span>
 <span class="s0">*/</span>
<span class="s0">211</span>
<span class="s0">inline void MeshDrawer::tri(LVector3 const &amp;v1, LVector4 const &amp;c1, LVector2 const &amp;uv1, LVector3 const &amp;v2, LVector4 const &amp;c2, LVector2 const &amp;uv2, LVector3 const &amp;v3, LVector4 const &amp;c3, LVector2 const &amp;uv3);</span>

<span class="s0">368 8 particle 0 4 510 20 MeshDrawer::particle 0 1 130 146</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a particle that is sort of like a bill board but has an extra</span>
 <span class="s0">* rotation component.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">void MeshDrawer::particle(LVector3 const &amp;pos, LVector4 const &amp;frame, PN_stdfloat size, LVector4 const &amp;color, PN_stdfloat rotation);</span>

<span class="s0">369 16 blended_particle 0 4 510 28 MeshDrawer::blended_particle 0 1 131 152</span>
<span class="s0">/**</span>
 <span class="s0">* Works just like particle but accepts 2 frames and a blend (from 0 to 1)</span>
 <span class="s0">* component between them Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">185</span>
<span class="s0">void MeshDrawer::blended_particle(LVector3 const &amp;pos, LVector4 const &amp;frame1, LVector4 const &amp;frame2, PN_stdfloat blend, PN_stdfloat size, LVector4 const &amp;color, PN_stdfloat rotation);</span>

<span class="s0">370 9 billboard 0 4 510 21 MeshDrawer::billboard 0 1 132 141</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a billboard - particle with no rotation.  Billboards always face the</span>
 <span class="s0">* camera.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">void MeshDrawer::billboard(LVector3 const &amp;pos, LVector4 const &amp;frame, PN_stdfloat size, LVector4 const &amp;color);</span>

<span class="s0">371 7 segment 0 4 510 19 MeshDrawer::segment 0 1 133 129</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a segment a line with a thickness.  That has billboarding effect.</span>
 <span class="s0">* Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">139</span>
<span class="s0">void MeshDrawer::segment(LVector3 const &amp;start, LVector3 const &amp;stop, LVector4 const &amp;frame, PN_stdfloat thickness, LVector4 const &amp;color);</span>

<span class="s0">372 13 cross_segment 0 4 510 25 MeshDrawer::cross_segment 0 1 134 229</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a segment a line with a thickness.  This segment does not use the</span>
 <span class="s0">* bill boarding behavior and instead draws 2 planes in a cross.  Stars at</span>
 <span class="s0">* start and ends at stop.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">void MeshDrawer::cross_segment(LVector3 const &amp;start, LVector3 const &amp;stop, LVector4 const &amp;frame, PN_stdfloat thickness, LVector4 const &amp;color);</span>

<span class="s0">373 14 uneven_segment 0 4 510 26 MeshDrawer::uneven_segment 0 1 135 167</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a segment a line with different thickness and color on both sides.</span>
 <span class="s0">* Stars at start and ends at stop.  Frame contains u,v,u-size,v-size</span>
 <span class="s0">* quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">214</span>
<span class="s0">void MeshDrawer::uneven_segment(LVector3 const &amp;start, LVector3 const &amp;stop, LVector4 const &amp;frame, PN_stdfloat thickness_start, LVector4 const &amp;color_start, PN_stdfloat thickness_stop, LVector4 const &amp;color_stop);</span>

<span class="s0">374 12 link_segment 0 4 510 24 MeshDrawer::link_segment 0 1 136 156</span>
<span class="s0">/**</span>
 <span class="s0">* Stars or continues linked segment.  Control position, frame, thickness and</span>
 <span class="s0">* color with parameters.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">void MeshDrawer::link_segment(LVector3 const &amp;pos, LVector4 const &amp;frame, PN_stdfloat thickness, LVector4 const &amp;color);</span>

<span class="s0">375 16 link_segment_end 0 4 510 28 MeshDrawer::link_segment_end 0 1 137 172</span>
<span class="s0">/**</span>
 <span class="s0">* Finish drawing linked segments, needs at least two calls to link_segment</span>
 <span class="s0">* before it can end the linked segment.  Frame contains u,v,u-size,v-size</span>
 <span class="s0">* quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">void MeshDrawer::link_segment_end(LVector4 const &amp;frame, LVector4 const &amp;color);</span>

<span class="s0">376 9 explosion 0 4 510 21 MeshDrawer::explosion 0 1 138 110</span>
<span class="s0">/**</span>
 <span class="s0">* Draws number of particles in a sphere like emitter.  Frame contains</span>
 <span class="s0">* u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">void MeshDrawer::explosion(LVector3 const &amp;pos, LVector4 const &amp;frame, PN_stdfloat size, LVector4 const &amp;color, int seed, int number, PN_stdfloat distance);</span>

<span class="s0">377 6 stream 0 4 510 18 MeshDrawer::stream 0 1 139 137</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a number of particles in a big line with a shift dictated by the</span>
 <span class="s0">* offset.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/</span>
<span class="s0">165</span>
<span class="s0">void MeshDrawer::stream(LVector3 const &amp;start, LVector3 const &amp;stop, LVector4 const &amp;frame, PN_stdfloat size, LVector4 const &amp;color, int number, PN_stdfloat offset);</span>

<span class="s0">378 8 geometry 0 4 510 20 MeshDrawer::geometry 0 1 140 272</span>
<span class="s0">/**</span>
 <span class="s0">* Draws the geometry that is inside this node path into the MeshDrawer</span>
 <span class="s0">* object.  This performs a similar functions as RigidBodyCombiner but for</span>
 <span class="s0">* very dynamic situations that share the same texture like physcal chunks of</span>
 <span class="s0">* explosions.  It can be a little slow</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void MeshDrawer::geometry(NodePath node);</span>

<span class="s0">379 3 end 0 4 510 15 MeshDrawer::end 0 1 141 70</span>
<span class="s0">/**</span>
 <span class="s0">* Finish the drawing and clearing off the remaining vertexes.</span>
 <span class="s0">*/</span>
<span class="s0">27</span>
<span class="s0">void MeshDrawer::end(void);</span>

<span class="s0">380 14 get_class_type 0 4 510 26 MeshDrawer::get_class_type 0 1 142 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle MeshDrawer::get_class_type(void);</span>

<span class="s0">381 12 MeshDrawer2D 0 260 511 26 MeshDrawer2D::MeshDrawer2D 0 1 143 53</span>
<span class="s0">/**</span>
 <span class="s0">* Creates the MeshDrawer2D low level system.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline MeshDrawer2D::MeshDrawer2D(void);</span>

<span class="s0">382 10 set_budget 0 4 511 24 MeshDrawer2D::set_budget 0 1 144 56</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the total triangle budget of the drawer.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void MeshDrawer2D::set_budget(int budget);</span>

<span class="s0">383 10 get_budget 0 4 511 24 MeshDrawer2D::get_budget 0 1 145 56</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the total triangle budget of the drawer.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline int MeshDrawer2D::get_budget(void);</span>

<span class="s0">384 8 get_root 0 4 511 22 MeshDrawer2D::get_root 0 1 146 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the root NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline NodePath MeshDrawer2D::get_root(void);</span>

<span class="s0">385 8 quad_raw 0 4 511 22 MeshDrawer2D::quad_raw 0 1 147 65</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a 2D rectangle.  Ignores the clipping rectangle.</span>
 <span class="s0">*/</span>
<span class="s0">279</span>
<span class="s0">inline void MeshDrawer2D::quad_raw(LVector3 const &amp;v1, LVector4 const &amp;c1, LVector2 const &amp;uv1, LVector3 const &amp;v2, LVector4 const &amp;c2, LVector2 const &amp;uv2, LVector3 const &amp;v3, LVector4 const &amp;c3, LVector2 const &amp;uv3, LVector3 const &amp;v4, LVector4 const &amp;c4, LVector2 const &amp;uv4);</span>

<span class="s0">386 13 rectangle_raw 0 4 511 27 MeshDrawer2D::rectangle_raw 0 1 148 0</span>
<span class="s0">185</span>
<span class="s0">inline void MeshDrawer2D::rectangle_raw(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &amp;color);</span>

<span class="s0">387 8 set_clip 0 4 511 22 MeshDrawer2D::set_clip 0 1 149 39</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the clipping rectangle.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline void MeshDrawer2D::set_clip(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h);</span>

<span class="s0">388 9 rectangle 0 4 511 23 MeshDrawer2D::rectangle 0 1 150 53</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a 2D rectangle which can be clipped.</span>
 <span class="s0">*/</span>
<span class="s0">181</span>
<span class="s0">inline void MeshDrawer2D::rectangle(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &amp;color);</span>

<span class="s0">389 16 rectangle_border 0 4 511 30 MeshDrawer2D::rectangle_border 0 1 151 96</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a 2d rectangle, with borders and corders, taken from the surrounding</span>
 <span class="s0">* texture</span>
 <span class="s0">*/</span>
<span class="s0">305</span>
<span class="s0">void MeshDrawer2D::rectangle_border(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat r, PN_stdfloat t, PN_stdfloat l, PN_stdfloat b, PN_stdfloat tr, PN_stdfloat tt, PN_stdfloat tl, PN_stdfloat tb, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &amp;color);</span>

<span class="s0">390 22 rectangle_border_tiled 0 4 511 36 MeshDrawer2D::rectangle_border_tiled 0 1 152 96</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a 2d rectangle, with borders and corders, taken from the surrounding</span>
 <span class="s0">* texture</span>
 <span class="s0">*/</span>
<span class="s0">311</span>
<span class="s0">void MeshDrawer2D::rectangle_border_tiled(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat r, PN_stdfloat t, PN_stdfloat l, PN_stdfloat b, PN_stdfloat tr, PN_stdfloat tt, PN_stdfloat tl, PN_stdfloat tb, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &amp;color);</span>

<span class="s0">391 15 rectangle_tiled 0 4 511 29 MeshDrawer2D::rectangle_tiled 0 1 153 65</span>
<span class="s0">/**</span>
 <span class="s0">* Draws a tiled rectangle, size of tiles is in us and vs</span>
 <span class="s0">*/</span>
<span class="s0">180</span>
<span class="s0">void MeshDrawer2D::rectangle_tiled(PN_stdfloat x, PN_stdfloat y, PN_stdfloat w, PN_stdfloat h, PN_stdfloat u, PN_stdfloat v, PN_stdfloat us, PN_stdfloat vs, LVector4 const &amp;color);</span>

<span class="s0">392 5 begin 0 4 511 19 MeshDrawer2D::begin 0 1 154 82</span>
<span class="s0">/**</span>
 <span class="s0">* Opens up the geom for drawing, don't forget to call MeshDrawer2D::end()</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void MeshDrawer2D::begin(void);</span>

<span class="s0">393 3 end 0 4 511 17 MeshDrawer2D::end 0 1 155 70</span>
<span class="s0">/**</span>
 <span class="s0">* Finish the drawing and clearing off the remaining vertexes.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">void MeshDrawer2D::end(void);</span>

<span class="s0">394 14 get_class_type 0 4 511 28 MeshDrawer2D::get_class_type 0 1 156 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle MeshDrawer2D::get_class_type(void);</span>

<span class="s0">395 12 MovieTexture 0 260 512 26 MovieTexture::MovieTexture 0 2 157 158 159</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a blank movie texture.  Movies must be added using do_read_one or</span>
 <span class="s0">* do_load_one.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a texture playing the specified movie.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">explicit MovieTexture::MovieTexture(std::string const &amp;name);</span>
<span class="s0">explicit MovieTexture::MovieTexture(MovieVideo *video);</span>

<span class="s0">396 16 get_video_length 0 4 512 30 MovieTexture::get_video_length 0 1 159 43</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the length of the video.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline double MovieTexture::get_video_length(void) const;</span>

<span class="s0">397 15 get_video_width 0 4 512 29 MovieTexture::get_video_width 0 1 160 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the width in texels of the source video stream.  This is not</span>
 <span class="s0">* necessarily the width of the actual texture, since the texture may have</span>
 <span class="s0">* been expanded to raise it to a power of 2.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int MovieTexture::get_video_width(void) const;</span>

<span class="s0">398 16 get_video_height 0 4 512 30 MovieTexture::get_video_height 0 1 161 202</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the height in texels of the source video stream.  This is not</span>
 <span class="s0">* necessarily the height of the actual texture, since the texture may have</span>
 <span class="s0">* been expanded to raise it to a power of 2.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int MovieTexture::get_video_height(void) const;</span>

<span class="s0">399 16 get_color_cursor 0 4 512 30 MovieTexture::get_color_cursor 0 1 162 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the MovieVideoCursor that is feeding the color channels for the</span>
 <span class="s0">* indicated page, where 0 &lt;= page &lt; get_num_pages().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline MovieVideoCursor *MovieTexture::get_color_cursor(int page);</span>

<span class="s0">400 16 get_alpha_cursor 0 4 512 30 MovieTexture::get_alpha_cursor 0 1 163 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the MovieVideoCursor that is feeding the alpha channel for the</span>
 <span class="s0">* indicated page, where 0 &lt;= page &lt; get_num_pages().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline MovieVideoCursor *MovieTexture::get_alpha_cursor(int page);</span>

<span class="s0">401 7 restart 0 4 512 21 MovieTexture::restart 0 1 164 159</span>
<span class="s0">/**</span>
 <span class="s0">* Start playing the movie from where it was last paused.  Has no effect if</span>
 <span class="s0">* the movie is not paused, or if the movie's cursor is already at the end.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void MovieTexture::restart(void);</span>

<span class="s0">402 4 stop 0 4 512 18 MovieTexture::stop 0 1 165 145</span>
<span class="s0">/**</span>
 <span class="s0">* Stops a currently playing or looping movie right where it is.  The movie's</span>
 <span class="s0">* cursor remains frozen at the point where it was stopped.</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">void MovieTexture::stop(void);</span>

<span class="s0">403 4 play 0 4 512 18 MovieTexture::play 0 1 166 46</span>
<span class="s0">/**</span>
 <span class="s0">* Plays the movie from the beginning.</span>
 <span class="s0">*/</span>
<span class="s0">30</span>
<span class="s0">void MovieTexture::play(void);</span>

<span class="s0">404 8 set_time 0 4 512 22 MovieTexture::set_time 0 1 167 35</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the movie's cursor.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void MovieTexture::set_time(double t);</span>

<span class="s0">405 8 get_time 0 4 512 22 MovieTexture::get_time 0 1 168 277</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current value of the movie's cursor.  If the movie's loop count</span>
 <span class="s0">* is greater than one, then its length is effectively multiplied for the</span>
 <span class="s0">* purposes of this function.  In other words, the return value will be in the</span>
 <span class="s0">* range 0.0 to (length * loopcount).</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">double MovieTexture::get_time(void) const;</span>

<span class="s0">406 8 set_loop 0 4 512 22 MovieTexture::set_loop 0 1 169 111</span>
<span class="s0">/**</span>
 <span class="s0">* If true, sets the movie's loop count to 1 billion.  If false, sets the</span>
 <span class="s0">* movie's loop count to one.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void MovieTexture::set_loop(bool enable);</span>

<span class="s0">407 8 get_loop 0 4 512 22 MovieTexture::get_loop 0 1 170 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the movie's loop count is not equal to one.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">bool MovieTexture::get_loop(void) const;</span>

<span class="s0">408 14 set_loop_count 0 4 512 28 MovieTexture::set_loop_count 0 1 171 60</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the movie's loop count to the desired value.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void MovieTexture::set_loop_count(int count);</span>

<span class="s0">409 14 get_loop_count 0 4 512 28 MovieTexture::get_loop_count 0 1 172 42</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the movie's loop count.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int MovieTexture::get_loop_count(void) const;</span>

<span class="s0">410 13 set_play_rate 0 4 512 27 MovieTexture::set_play_rate 0 1 173 168</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the movie's play-rate.  This is the speed at which the movie's cursor</span>
 <span class="s0">* advances.  The default is to advance 1.0 movie-seconds per real-time</span>
 <span class="s0">* second.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void MovieTexture::set_play_rate(double play_rate);</span>

<span class="s0">411 13 get_play_rate 0 4 512 27 MovieTexture::get_play_rate 0 1 174 38</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the movie's play-rate.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">double MovieTexture::get_play_rate(void) const;</span>

<span class="s0">412 10 is_playing 0 4 512 24 MovieTexture::is_playing 0 1 175 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the movie's cursor is advancing.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">bool MovieTexture::is_playing(void) const;</span>

<span class="s0">413 14 synchronize_to 0 4 512 28 MovieTexture::synchronize_to 0 1 176 127</span>
<span class="s0">/**</span>
 <span class="s0">* Synchronize this texture to a sound.  Typically, you would load the texture</span>
 <span class="s0">* and the sound from the same AVI file.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void MovieTexture::synchronize_to(AudioSound *sound);</span>

<span class="s0">414 13 unsynchronize 0 4 512 27 MovieTexture::unsynchronize 0 1 177 43</span>
<span class="s0">/**</span>
 <span class="s0">* Stop synchronizing with a sound.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void MovieTexture::unsynchronize(void);</span>

<span class="s0">415 14 get_class_type 0 4 512 28 MovieTexture::get_class_type 0 1 178 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle MovieTexture::get_class_type(void);</span>

<span class="s0">416 15 MultitexReducer 0 260 517 32 MultitexReducer::MultitexReducer 0 2 179 180 0</span>
<span class="s0">115</span>
<span class="s0">MultitexReducer::MultitexReducer(void);</span>
<span class="s0">inline MultitexReducer::MultitexReducer(MultitexReducer const &amp;) = default;</span>

<span class="s0">417 16 ~MultitexReducer 0 516 517 33 MultitexReducer::~MultitexReducer 0 0 0</span>
<span class="s0">40</span>
<span class="s0">MultitexReducer::~MultitexReducer(void);</span>

<span class="s0">418 5 clear 0 4 517 22 MultitexReducer::clear 0 1 181 0</span>
<span class="s0">34</span>
<span class="s0">void MultitexReducer::clear(void);</span>

<span class="s0">419 4 scan 0 4 517 21 MultitexReducer::scan 0 3 182 183 184 1318</span>
<span class="s0">/**</span>
 <span class="s0">* Starts scanning the hierarchy beginning at the indicated node.  Any</span>
 <span class="s0">* GeomNodes discovered in the hierarchy with multitexture will be added to</span>
 <span class="s0">* internal structures in the MultitexReducer so that a future call to</span>
 <span class="s0">* flatten() will operate on all of these at once.</span>
 <span class="s0">*</span>
 <span class="s0">* This version of this method does not accumulate state from the parents of</span>
 <span class="s0">* the indicated node; thus, only multitexture effects that have been applied</span>
 <span class="s0">* at node and below will be considered.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Starts scanning the hierarchy beginning at the indicated node.  Any</span>
 <span class="s0">* GeomNodes discovered in the hierarchy with multitexture will be added to</span>
 <span class="s0">* internal structures in the MultitexReducer so that a future call to</span>
 <span class="s0">* flatten() will operate on all of these at once.</span>
 <span class="s0">*</span>
 <span class="s0">* The second parameter represents the NodePath from which to accumulate the</span>
 <span class="s0">* state that is considered for the multitexture.  Pass an empty NodePath to</span>
 <span class="s0">* accumulate all the state from the root of the graph, or you may specify</span>
 <span class="s0">* some other node here in order to not consider nodes above that as</span>
 <span class="s0">* contributing to the state to be flattened.  This is particularly useful if</span>
 <span class="s0">* you have some texture stage which is applied globally to a scene (for</span>
 <span class="s0">* instance, a caustics effect), which you don't want to be considered for</span>
 <span class="s0">* flattening by the MultitexReducer.</span>
 <span class="s0">*/</span>
<span class="s0">245</span>
<span class="s0">inline void MultitexReducer::scan(NodePath const &amp;node);</span>
<span class="s0">inline void MultitexReducer::scan(NodePath const &amp;node, NodePath const &amp;state_from);</span>
<span class="s0">void MultitexReducer::scan(PandaNode *node, RenderState const *state, TransformState const *transform);</span>

<span class="s0">420 10 set_target 0 4 517 27 MultitexReducer::set_target 0 1 185 0</span>
<span class="s0">54</span>
<span class="s0">void MultitexReducer::set_target(TextureStage *stage);</span>

<span class="s0">421 12 set_use_geom 0 4 517 29 MultitexReducer::set_use_geom 0 1 186 0</span>
<span class="s0">50</span>
<span class="s0">void MultitexReducer::set_use_geom(bool use_geom);</span>

<span class="s0">422 17 set_allow_tex_mat 0 4 517 34 MultitexReducer::set_allow_tex_mat 0 1 187 0</span>
<span class="s0">60</span>
<span class="s0">void MultitexReducer::set_allow_tex_mat(bool allow_tex_mat);</span>

<span class="s0">423 7 flatten 0 4 517 24 MultitexReducer::flatten 0 1 188 0</span>
<span class="s0">54</span>
<span class="s0">void MultitexReducer::flatten(GraphicsOutput *window);</span>

<span class="s0">424 19 NodeVertexTransform 0 260 518 40 NodeVertexTransform::NodeVertexTransform 0 1 189 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">NodeVertexTransform::NodeVertexTransform(PandaNode const *node, VertexTransform const *prev = nullptr);</span>

<span class="s0">425 8 get_node 0 4 518 29 NodeVertexTransform::get_node 0 1 190 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the PandaNode whose transform supplies this object.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline PandaNode const *NodeVertexTransform::get_node(void) const;</span>

<span class="s0">426 8 get_prev 0 4 518 29 NodeVertexTransform::get_prev 0 1 191 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the VertexTransform object whose matrix will be composed with the</span>
 <span class="s0">* result of this node's transform.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline VertexTransform const *NodeVertexTransform::get_prev(void) const;</span>

<span class="s0">427 14 get_class_type 0 4 518 35 NodeVertexTransform::get_class_type 0 1 192 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle NodeVertexTransform::get_class_type(void);</span>

<span class="s0">428 20 ~NodeVertexTransform 0 516 518 41 NodeVertexTransform::~NodeVertexTransform 0 0 0</span>
<span class="s0">48</span>
<span class="s0">NodeVertexTransform::~NodeVertexTransform(void);</span>

<span class="s0">429 17 ShaderTerrainMesh 0 260 525 36 ShaderTerrainMesh::ShaderTerrainMesh 0 1 193 287</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Constructs a new Terrain Mesh</span>
 <span class="s0">* @details This constructs a new terrain mesh. By default, no transform is set</span>
 <span class="s0">*   on the mesh, causing it to range over the unit box from (0, 0, 0) to</span>
 <span class="s0">*   (1, 1, 1). Usually you want to set a custom transform with NodePath::set_scale()</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">ShaderTerrainMesh::ShaderTerrainMesh(void);</span>

<span class="s0">430 15 set_heightfield 0 4 525 34 ShaderTerrainMesh::set_heightfield 0 1 194 339</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the heightfield texture</span>
 <span class="s0">* @details This sets the heightfield texture. It should be 16bit</span>
 <span class="s0">*   single channel, and have a power-of-two resolution greater than 32.</span>
 <span class="s0">*   Common sizes are 2048x2048 or 4096x4096.</span>
 <span class="s0">*</span>
 <span class="s0">*   You should call generate() after setting the heightfield.</span>
 <span class="s0">*</span>
 <span class="s0">* @param filename Heightfield texture</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void ShaderTerrainMesh::set_heightfield(Texture *heightfield);</span>

<span class="s0">431 15 get_heightfield 0 4 525 34 ShaderTerrainMesh::get_heightfield 0 1 195 172</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the heightfield</span>
 <span class="s0">* @details This returns the terrain heightfield, previously set with</span>
 <span class="s0">*   set_heightfield()</span>
 <span class="s0">*</span>
 <span class="s0">* @return Path to the heightfield</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline Texture *ShaderTerrainMesh::get_heightfield(void) const;</span>

<span class="s0">432 14 set_chunk_size 0 4 525 33 ShaderTerrainMesh::set_chunk_size 0 1 196 785</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the chunk size</span>
 <span class="s0">* @details This sets the chunk size of the terrain. A chunk is basically the</span>
 <span class="s0">*   smallest unit in LOD. If the chunk size is too small, the terrain will</span>
 <span class="s0">*   perform bad, since there will be way too many chunks. If the chunk size</span>
 <span class="s0">*   is too big, you will not get proper LOD, and might also get bad performance.</span>
 <span class="s0">*</span>
 <span class="s0">*   For terrains of the size 4096x4096 or 8192x8192, a chunk size of 32 seems</span>
 <span class="s0">*   to produce good results. For smaller resolutions, you should try out a</span>
 <span class="s0">*   size of 16 or even 8 for very small terrains.</span>
 <span class="s0">*</span>
 <span class="s0">*   The amount of chunks generated for the last level equals to</span>
 <span class="s0">*   (heightfield_size / chunk_size) ** 2. The chunk size has to be a power</span>
 <span class="s0">*   of two.</span>
 <span class="s0">*</span>
 <span class="s0">* @param chunk_size Size of the chunks, has to be a power of two</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void ShaderTerrainMesh::set_chunk_size(std::size_t chunk_size);</span>

<span class="s0">433 14 get_chunk_size 0 4 525 33 ShaderTerrainMesh::get_chunk_size 0 1 197 140</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the chunk size</span>
 <span class="s0">* @details This returns the chunk size, previously set with set_chunk_size()</span>
 <span class="s0">* @return Chunk size</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline std::size_t ShaderTerrainMesh::get_chunk_size(void) const;</span>

<span class="s0">434 20 set_generate_patches 0 4 525 39 ShaderTerrainMesh::set_generate_patches 0 1 198 618</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets whether to generate patches</span>
 <span class="s0">* @details If this option is set to true, GeomPatches will be used instead of</span>
 <span class="s0">*   GeomTriangles. This is required when the terrain is used with tesselation</span>
 <span class="s0">*   shaders, since patches are required for tesselation, whereas triangles</span>
 <span class="s0">*   are required for regular rendering.</span>
 <span class="s0">*</span>
 <span class="s0">*   If this option is set to true while not using a tesselation shader, the</span>
 <span class="s0">*   terrain will not get rendered, or even produce errors. The same applies</span>
 <span class="s0">*   when this is option is not set, but the terrain is used with tesselation</span>
 <span class="s0">*   shaders.</span>
 <span class="s0">*</span>
 <span class="s0">* @param generate_patches [description]</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void ShaderTerrainMesh::set_generate_patches(bool generate_patches);</span>

<span class="s0">435 20 get_generate_patches 0 4 525 39 ShaderTerrainMesh::get_generate_patches 0 1 199 199</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns whether to generate patches</span>
 <span class="s0">* @details This returns whether patches are generated, previously set with</span>
 <span class="s0">*   set_generate_patches()</span>
 <span class="s0">*</span>
 <span class="s0">* @return Whether to generate patches</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool ShaderTerrainMesh::get_generate_patches(void) const;</span>

<span class="s0">436 18 set_update_enabled 0 4 525 37 ShaderTerrainMesh::set_update_enabled 0 1 200 336</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets whether to enable terrain updates</span>
 <span class="s0">* @details This flag controls whether the terrain should be updated. If this value</span>
 <span class="s0">*   is set to false, no updating of the terrain will happen. This can be useful</span>
 <span class="s0">*   to debug the culling algorithm used by the terrain.</span>
 <span class="s0">*</span>
 <span class="s0">* @param update_enabled Whether to update the terrain</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void ShaderTerrainMesh::set_update_enabled(bool update_enabled);</span>

<span class="s0">437 18 get_update_enabled 0 4 525 37 ShaderTerrainMesh::get_update_enabled 0 1 201 219</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns whether the terrain is getting updated</span>
 <span class="s0">* @details This returns whether the terrain is getting updates, previously set with</span>
 <span class="s0">*   set_update_enabled()</span>
 <span class="s0">*</span>
 <span class="s0">* @return Whether to update the terrain</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool ShaderTerrainMesh::get_update_enabled(void) const;</span>

<span class="s0">438 25 set_target_triangle_width 0 4 525 44 ShaderTerrainMesh::set_target_triangle_width 0 1 202 469</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Sets the desired triangle width</span>
 <span class="s0">* @details This sets the desired width a triangle should have in pixels.</span>
 <span class="s0">*   A value of 10.0 for example will make the terrain tesselate everything</span>
 <span class="s0">*   in a way that each triangle edge roughly is 10 pixels wide.</span>
 <span class="s0">*   Of course this will not always accurately match, however you can use this</span>
 <span class="s0">*   setting to control the LOD algorithm of the terrain.</span>
 <span class="s0">*</span>
 <span class="s0">* @param target_triangle_width Desired triangle width in pixels</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline void ShaderTerrainMesh::set_target_triangle_width(PN_stdfloat target_triangle_width);</span>

<span class="s0">439 25 get_target_triangle_width 0 4 525 44 ShaderTerrainMesh::get_target_triangle_width 0 1 203 211</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Returns the target triangle width</span>
 <span class="s0">* @details This returns the target triangle width, previously set with</span>
 <span class="s0">*   ShaderTerrainMesh::set_target_triangle_width()</span>
 <span class="s0">*</span>
 <span class="s0">* @return Target triangle width</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline PN_stdfloat ShaderTerrainMesh::get_target_triangle_width(void) const;</span>

<span class="s0">440 11 uv_to_world 0 4 525 30 ShaderTerrainMesh::uv_to_world 0 2 204 205 436</span>
<span class="s0">/**</span>
 <span class="s0">* @see ShaderTerrainMesh::uv_to_world(LTexCoord)</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* @brief Transforms a texture coordinate to world space</span>
 <span class="s0">* @details This transforms a texture coordinatefrom uv-space (0 to 1) to world</span>
 <span class="s0">*   space. This takes the terrains transform into account, and also samples the</span>
 <span class="s0">*   heightmap. This method should be called after generate().</span>
 <span class="s0">*</span>
 <span class="s0">* @param coord Coordinate in uv-space from 0, 0 to 1, 1</span>
 <span class="s0">* @return World-Space point</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">LPoint3 ShaderTerrainMesh::uv_to_world(LTexCoord const &amp;coord) const;</span>
<span class="s0">inline LPoint3 ShaderTerrainMesh::uv_to_world(PN_stdfloat u, PN_stdfloat v) const;</span>

<span class="s0">441 8 generate 0 4 525 27 ShaderTerrainMesh::generate 0 1 206 442</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Generates the terrain mesh</span>
 <span class="s0">* @details This generates the terrain mesh, initializing all chunks of the</span>
 <span class="s0">*   internal used quadtree. At this point, a heightfield and a chunk size should</span>
 <span class="s0">*   have been set, otherwise an error is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">*   If anything goes wrong, like a missing heightfield, then an error is printed</span>
 <span class="s0">*   and false is returned.</span>
 <span class="s0">*</span>
 <span class="s0">* @return true if the terrain was initialized, false if an error occured</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">bool ShaderTerrainMesh::generate(void);</span>

<span class="s0">442 14 get_class_type 0 4 525 33 ShaderTerrainMesh::get_class_type 0 1 207 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle ShaderTerrainMesh::get_class_type(void);</span>

<span class="s0">443 18 ~ShaderTerrainMesh 0 516 525 37 ShaderTerrainMesh::~ShaderTerrainMesh 0 0 0</span>
<span class="s0">44</span>
<span class="s0">ShaderTerrainMesh::~ShaderTerrainMesh(void);</span>

<span class="s0">444 23 SceneGraphAnalyzerMeter 0 260 531 48 SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter 0 2 208 209 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">200</span>
<span class="s0">explicit SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(std::string const &amp;name, PandaNode *node);</span>
<span class="s0">inline SceneGraphAnalyzerMeter::SceneGraphAnalyzerMeter(SceneGraphAnalyzerMeter const &amp;) = default;</span>

<span class="s0">445 12 setup_window 0 4 531 37 SceneGraphAnalyzerMeter::setup_window 0 1 210 112</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the frame rate meter to create a DisplayRegion to render itself</span>
 <span class="s0">* into the indicated window.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void SceneGraphAnalyzerMeter::setup_window(GraphicsOutput *window);</span>

<span class="s0">446 12 clear_window 0 4 531 37 SceneGraphAnalyzerMeter::clear_window 0 1 211 66</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of a previous call to setup_window().</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void SceneGraphAnalyzerMeter::clear_window(void);</span>

<span class="s0">447 10 get_window 0 4 531 35 SceneGraphAnalyzerMeter::get_window 0 1 212 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the GraphicsOutput that was passed to setup_window(), or NULL if</span>
 <span class="s0">* setup_window() has not been called.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline GraphicsOutput *SceneGraphAnalyzerMeter::get_window(void) const;</span>

<span class="s0">448 18 get_display_region 0 4 531 43 SceneGraphAnalyzerMeter::get_display_region 0 1 213 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DisplayRegion that the meter has created to render itself into</span>
 <span class="s0">* the window to setup_window(), or NULL if setup_window() has not been</span>
 <span class="s0">* called.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline DisplayRegion *SceneGraphAnalyzerMeter::get_display_region(void) const;</span>

<span class="s0">449 19 set_update_interval 0 4 531 44 SceneGraphAnalyzerMeter::set_update_interval 0 1 214 244</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of seconds that should elapse between updates to the</span>
 <span class="s0">* meter.  This should be reasonably slow (e.g.  0.5 to 2.0) so that the</span>
 <span class="s0">* calculation of the scene graph analysis does not itself dominate the frame</span>
 <span class="s0">* rate.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline void SceneGraphAnalyzerMeter::set_update_interval(double update_interval);</span>

<span class="s0">450 19 get_update_interval 0 4 531 44 SceneGraphAnalyzerMeter::get_update_interval 0 1 215 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of seconds that will elapse between updates to the frame</span>
 <span class="s0">* rate indication.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline double SceneGraphAnalyzerMeter::get_update_interval(void) const;</span>

<span class="s0">451 8 set_node 0 4 531 33 SceneGraphAnalyzerMeter::set_node 0 1 216 40</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the node to be analyzed.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void SceneGraphAnalyzerMeter::set_node(PandaNode *node);</span>

<span class="s0">452 8 get_node 0 4 531 33 SceneGraphAnalyzerMeter::get_node 0 1 217 43</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node to be analyzed.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline PandaNode *SceneGraphAnalyzerMeter::get_node(void) const;</span>

<span class="s0">453 6 update 0 4 531 31 SceneGraphAnalyzerMeter::update 0 1 218 205</span>
<span class="s0">/**</span>
 <span class="s0">* You can call this to explicitly force the SceneGraphAnalyzerMeter to update</span>
 <span class="s0">* itself with the latest scene graph analysis information.  Normally, it is</span>
 <span class="s0">* not necessary to call this explicitly.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void SceneGraphAnalyzerMeter::update(void);</span>

<span class="s0">454 14 get_class_type 0 4 531 39 SceneGraphAnalyzerMeter::get_class_type 0 1 219 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle SceneGraphAnalyzerMeter::get_class_type(void);</span>

<span class="s0">455 17 RigidBodyCombiner 0 260 532 36 RigidBodyCombiner::RigidBodyCombiner 0 1 220 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">explicit RigidBodyCombiner::RigidBodyCombiner(std::string const &amp;name);</span>

<span class="s0">456 7 collect 0 4 532 26 RigidBodyCombiner::collect 0 1 221 879</span>
<span class="s0">/**</span>
 <span class="s0">* Walks through the entire subgraph of nodes rooted at this node, accumulates</span>
 <span class="s0">* all of the RenderAttribs and Geoms below this node, flattening them into</span>
 <span class="s0">* just one Geom (or as few as possible, if there are multiple different</span>
 <span class="s0">* states).</span>
 <span class="s0">*</span>
 <span class="s0">* Nodes that have transforms on them at the time of collect(), or any</span>
 <span class="s0">* ModelNodes with the preserve_transform flag, will be identified as &quot;moving&quot;</span>
 <span class="s0">* nodes, and their transforms will be monitored as they change in future</span>
 <span class="s0">* frames and each new transform directly applied to the vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* This call must be made after adding any nodes to or removing any nodes from</span>
 <span class="s0">* the subgraph rooted at this node.  It should not be made too often, as it</span>
 <span class="s0">* is a relatively expensive call.  If you need to hide children of this node,</span>
 <span class="s0">* consider scaling them to zero (or very near zero), or moving them behind</span>
 <span class="s0">* the camera, instead.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void RigidBodyCombiner::collect(void);</span>

<span class="s0">457 18 get_internal_scene 0 4 532 37 RigidBodyCombiner::get_internal_scene 0 1 222 319</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a special NodePath that represents the internal node of this</span>
 <span class="s0">* object.  This is the node that is actually sent to the graphics card for</span>
 <span class="s0">* rendering; it contains the collection of the children of this node into as</span>
 <span class="s0">* few Geoms as possible.</span>
 <span class="s0">*</span>
 <span class="s0">* This node is filled up by the last call to collect().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">NodePath RigidBodyCombiner::get_internal_scene(void);</span>

<span class="s0">458 14 get_class_type 0 4 532 33 RigidBodyCombiner::get_class_type 0 1 223 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle RigidBodyCombiner::get_class_type(void);</span>

<span class="s0">459 18 ~RigidBodyCombiner 0 516 532 37 RigidBodyCombiner::~RigidBodyCombiner 0 0 0</span>
<span class="s0">44</span>
<span class="s0">RigidBodyCombiner::~RigidBodyCombiner(void);</span>

<span class="s0">460 23 upcast_to_CullTraverser 0 12 534 51 PipeOcclusionCullTraverser::upcast_to_CullTraverser 0 1 232 55</span>
<span class="s0">upcast from PipeOcclusionCullTraverser to CullTraverser</span>
<span class="s0">73</span>
<span class="s0">CullTraverser *PipeOcclusionCullTraverser::upcast_to_CullTraverser(void);</span>

<span class="s0">461 38 downcast_to_PipeOcclusionCullTraverser 0 12 535 53 CullTraverser::downcast_to_PipeOcclusionCullTraverser 0 0 57</span>
<span class="s0">downcast from CullTraverser to PipeOcclusionCullTraverser</span>
<span class="s0">88</span>
<span class="s0">PipeOcclusionCullTraverser *CullTraverser::downcast_to_PipeOcclusionCullTraverser(void);</span>

<span class="s0">462 21 upcast_to_CullHandler 0 12 534 49 PipeOcclusionCullTraverser::upcast_to_CullHandler 0 1 233 53</span>
<span class="s0">upcast from PipeOcclusionCullTraverser to CullHandler</span>
<span class="s0">69</span>
<span class="s0">CullHandler *PipeOcclusionCullTraverser::upcast_to_CullHandler(void);</span>

<span class="s0">463 38 downcast_to_PipeOcclusionCullTraverser 0 12 536 51 CullHandler::downcast_to_PipeOcclusionCullTraverser 0 0 55</span>
<span class="s0">downcast from CullHandler to PipeOcclusionCullTraverser</span>
<span class="s0">86</span>
<span class="s0">PipeOcclusionCullTraverser *CullHandler::downcast_to_PipeOcclusionCullTraverser(void);</span>

<span class="s0">464 26 PipeOcclusionCullTraverser 0 260 534 54 PipeOcclusionCullTraverser::PipeOcclusionCullTraverser 0 1 224 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">explicit PipeOcclusionCullTraverser::PipeOcclusionCullTraverser(GraphicsOutput *host);</span>

<span class="s0">465 9 set_scene 0 6 534 37 PipeOcclusionCullTraverser::set_scene 0 1 225 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">virtual void PipeOcclusionCullTraverser::set_scene(SceneSetup *scene_setup, GraphicsStateGuardianBase *gsg, bool dr_incomplete_render);</span>

<span class="s0">466 12 end_traverse 0 6 534 40 PipeOcclusionCullTraverser::end_traverse 0 1 226 141</span>
<span class="s0">/**</span>
 <span class="s0">* Should be called when the traverser has finished traversing its scene, this</span>
 <span class="s0">* gives it a chance to do any necessary finalization.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual void PipeOcclusionCullTraverser::end_traverse(void);</span>

<span class="s0">467 10 get_buffer 0 4 534 38 PipeOcclusionCullTraverser::get_buffer 0 1 227 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline GraphicsOutput *PipeOcclusionCullTraverser::get_buffer(void) const;</span>

<span class="s0">468 11 get_texture 0 4 534 39 PipeOcclusionCullTraverser::get_texture 0 1 228 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a Texture that can be used to visualize the efforts of the</span>
 <span class="s0">* occlusion cull.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">Texture *PipeOcclusionCullTraverser::get_texture(void);</span>

<span class="s0">469 18 set_occlusion_mask 0 4 534 46 PipeOcclusionCullTraverser::set_occlusion_mask 0 1 229 245</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the DrawMask that should be set on occlusion polygons for this</span>
 <span class="s0">* scene.  This identifies the polygons that are to be treated as occluders.</span>
 <span class="s0">* Polygons that do not have this draw mask set will not be considered</span>
 <span class="s0">* occluders.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline void PipeOcclusionCullTraverser::set_occlusion_mask(DrawMask const &amp;occlusion_mask);</span>

<span class="s0">470 18 get_occlusion_mask 0 4 534 46 PipeOcclusionCullTraverser::get_occlusion_mask 0 1 230 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DrawMask for occlusion polygons.  See set_occlusion_mask().</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline DrawMask const &amp;PipeOcclusionCullTraverser::get_occlusion_mask(void) const;</span>

<span class="s0">471 14 get_class_type 0 4 534 42 PipeOcclusionCullTraverser::get_class_type 0 1 231 0</span>
<span class="s0">67</span>
<span class="s0">static TypeHandle PipeOcclusionCullTraverser::get_class_type(void);</span>

<span class="s0">472 27 ~PipeOcclusionCullTraverser 0 516 534 55 PipeOcclusionCullTraverser::~PipeOcclusionCullTraverser 0 0 0</span>
<span class="s0">62</span>
<span class="s0">PipeOcclusionCullTraverser::~PipeOcclusionCullTraverser(void);</span>

<span class="s0">473 9 PfmVizzer 0 260 537 20 PfmVizzer::PfmVizzer 0 2 234 235 256</span>
<span class="s0">/**</span>
 <span class="s0">* The PfmVizzer constructor receives a reference to a PfmFile which it will</span>
 <span class="s0">* operate on.  It does not keep ownership of this reference; it is your</span>
 <span class="s0">* responsibility to ensure the PfmFile does not destruct during the lifetime</span>
 <span class="s0">* of the PfmVizzer.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">explicit PfmVizzer::PfmVizzer(PfmFile &amp;pfm);</span>
<span class="s0">inline PfmVizzer::PfmVizzer(PfmVizzer const &amp;) = default;</span>

<span class="s0">474 10 ~PfmVizzer 0 516 537 21 PfmVizzer::~PfmVizzer 0 0 0</span>
<span class="s0">35</span>
<span class="s0">inline PfmVizzer::~PfmVizzer(void);</span>

<span class="s0">475 7 get_pfm 0 4 537 18 PfmVizzer::get_pfm 0 2 236 237 158</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the reference to the PfmFile manipulated by this PfmVizzer.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the reference to the PfmFile manipulated by this PfmVizzer.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline PfmFile &amp;PfmVizzer::get_pfm(void);</span>
<span class="s0">inline PfmFile const &amp;PfmVizzer::get_pfm(void) const;</span>

<span class="s0">476 7 project 0 4 537 18 PfmVizzer::project 0 1 238 335</span>
<span class="s0">/**</span>
 <span class="s0">* Adjusts each (x, y, z) point of the Pfm file by projecting it through the</span>
 <span class="s0">* indicated lens, converting each point to a (u, v, w) texture coordinate.</span>
 <span class="s0">* The resulting file can be generated to a mesh (with set_vis_inverse(true)</span>
 <span class="s0">* and generate_vis_mesh()) that will apply the lens distortion to an</span>
 <span class="s0">* arbitrary texture image.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void PfmVizzer::project(Lens const *lens, PfmFile const *undist_lut = nullptr);</span>

<span class="s0">477 7 extrude 0 4 537 18 PfmVizzer::extrude 0 1 239 397</span>
<span class="s0">/**</span>
 <span class="s0">* Converts each (u, v, depth) point of the Pfm file to an (x, y, z) point, by</span>
 <span class="s0">* reversing project().  If the original file is only a 1-d file, assumes that</span>
 <span class="s0">* it is a depth map with implicit (u, v) coordinates.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is only valid for a linear lens (e.g.  a PerspectiveLens or</span>
 <span class="s0">* OrthographicLens).  Non-linear lenses don't necessarily compute a sensible</span>
 <span class="s0">* depth coordinate.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void PfmVizzer::extrude(Lens const *lens);</span>

<span class="s0">478 15 set_vis_inverse 0 4 537 26 PfmVizzer::set_vis_inverse 0 1 240 435</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the vis_inverse flag.  When this flag is true, vis meshes and point</span>
 <span class="s0">* clouds are generated with the 3-d depth value in the texture coordinates,</span>
 <span class="s0">* and the 2-d index value in the vertex position.  When it is false, meshes</span>
 <span class="s0">* are generated normally, with the 3-d depth value in the vertex position and</span>
 <span class="s0">* the 2-d index value in the texture coordinates.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used in lieu of the lower-level add_vis_column().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void PfmVizzer::set_vis_inverse(bool vis_inverse);</span>

<span class="s0">479 15 get_vis_inverse 0 4 537 26 PfmVizzer::get_vis_inverse 0 1 241 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the vis_inverse flag.  See set_vis_inverse().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool PfmVizzer::get_vis_inverse(void) const;</span>

<span class="s0">480 22 set_flat_texcoord_name 0 4 537 33 PfmVizzer::set_flat_texcoord_name 0 1 242 473</span>
<span class="s0">/**</span>
 <span class="s0">* If the flat_texcoord_name is specified, it is the name of an additional</span>
 <span class="s0">* vertex column that will be created for the &quot;flat&quot; texture coordinates, i.e.</span>
 <span class="s0">* the original 0..1 values that correspond to the 2-D index position of each</span>
 <span class="s0">* point in the original pfm file.</span>
 <span class="s0">*</span>
 <span class="s0">* These are the same values that will be assigned to the default texture</span>
 <span class="s0">* coordinates if the vis_inverse flag is *not* true.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used in lieu of the lower-level add_vis_column().</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline void PfmVizzer::set_flat_texcoord_name(InternalName *flat_texcoord_name);</span>

<span class="s0">481 24 clear_flat_texcoord_name 0 4 537 35 PfmVizzer::clear_flat_texcoord_name 0 1 243 177</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the flat_texcoord_name to empty, so that additional texture</span>
 <span class="s0">* coordinates are not created.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used in lieu of the lower-level add_vis_column().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void PfmVizzer::clear_flat_texcoord_name(void);</span>

<span class="s0">482 22 get_flat_texcoord_name 0 4 537 33 PfmVizzer::get_flat_texcoord_name 0 1 244 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flat_texcoord_name.  See set_flat_texcoord_name().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline InternalName *PfmVizzer::get_flat_texcoord_name(void) const;</span>

<span class="s0">483 10 set_vis_2d 0 4 537 21 PfmVizzer::set_vis_2d 0 1 245 291</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the vis_2d flag.  When this flag is true, only the first two (x, y)</span>
 <span class="s0">* value of each depth point is considered meaningful; the z component is</span>
 <span class="s0">* ignored.  This is only relevant for generating visualizations.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used in lieu of the lower-level add_vis_column().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void PfmVizzer::set_vis_2d(bool vis_2d);</span>

<span class="s0">484 10 get_vis_2d 0 4 537 21 PfmVizzer::get_vis_2d 0 1 246 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the vis_2d flag.  See set_vis_2d().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool PfmVizzer::get_vis_2d(void) const;</span>

<span class="s0">485 20 set_keep_beyond_lens 0 4 537 31 PfmVizzer::set_keep_beyond_lens 0 1 247 234</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the keep_beyond_lens flag.  When this flag is true, points that fall</span>
 <span class="s0">* outside of the normal lens range in project() or in add_vis_column() will</span>
 <span class="s0">* be retained anyway; when it is false, these points will be discarded.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void PfmVizzer::set_keep_beyond_lens(bool keep_beyond_lens);</span>

<span class="s0">486 20 get_keep_beyond_lens 0 4 537 31 PfmVizzer::get_keep_beyond_lens 0 1 248 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the keep_beyond_lens flag.  See set_keep_beyond_lens().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool PfmVizzer::get_keep_beyond_lens(void) const;</span>

<span class="s0">487 13 set_vis_blend 0 4 537 24 PfmVizzer::set_vis_blend 0 1 249 457</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies a blending map--a grayscale image--that will be applied to the</span>
 <span class="s0">* vertex color during generate_vis_mesh() and generate_vis_points().  The</span>
 <span class="s0">* image size must exactly match the mesh size of the PfmVizzer.</span>
 <span class="s0">*</span>
 <span class="s0">* Ownership of the pointer is not kept by the PfmVizzer; it is your</span>
 <span class="s0">* responsibility to ensure it does not destruct during the lifetime of the</span>
 <span class="s0">* PfmVizzer (or at least not before your subsequent call to</span>
 <span class="s0">* generate_vis_mesh()).</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void PfmVizzer::set_vis_blend(PNMImage const *vis_blend);</span>

<span class="s0">488 15 clear_vis_blend 0 4 537 26 PfmVizzer::clear_vis_blend 0 1 250 75</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the blending map set by a prior call to set_vis_blend().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void PfmVizzer::clear_vis_blend(void);</span>

<span class="s0">489 13 get_vis_blend 0 4 537 24 PfmVizzer::get_vis_blend 0 1 251 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the blending map set by the most recent call to set_vis_blend(), or</span>
 <span class="s0">* NULL if there is no blending map in effect.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PNMImage const *PfmVizzer::get_vis_blend(void) const;</span>

<span class="s0">490 11 set_aux_pfm 0 4 537 22 PfmVizzer::set_aux_pfm 0 1 252 429</span>
<span class="s0">/**</span>
 <span class="s0">* Assigns an auxiliary PfmFile to this PfmVizzer.  This file will be queried</span>
 <span class="s0">* by column types CT_aux_vertex1/2/3, but has no other meaning to the vizzer.</span>
 <span class="s0">* This size of this PfmFile should exactly match the base PfmFile.  No</span>
 <span class="s0">* reference count is held and no copy is made; the caller is responsible for</span>
 <span class="s0">* ensuring that the auxiliary PfmFile will persist throughout the lifetime of</span>
 <span class="s0">* the PfmVizzer it is assigned to.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void PfmVizzer::set_aux_pfm(PfmFile const *pfm);</span>

<span class="s0">491 13 clear_aux_pfm 0 4 537 24 PfmVizzer::clear_aux_pfm 0 1 253 61</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the auxiliary PfmFile from this PfmVizzer.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void PfmVizzer::clear_aux_pfm(void);</span>

<span class="s0">492 11 get_aux_pfm 0 4 537 22 PfmVizzer::get_aux_pfm 0 1 254 181</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the reference to the auxiliary PfmFile queried by this PfmVizzer.</span>
 <span class="s0">* This contains the values that will be reflected in CT_aux_vertex3 etc.  See</span>
 <span class="s0">* set_aux_pfm().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PfmFile const *PfmVizzer::get_aux_pfm(void) const;</span>

<span class="s0">493 17 clear_vis_columns 0 4 537 28 PfmVizzer::clear_vis_columns 0 1 255 124</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all of the previously-added vis columns in preparation for building</span>
 <span class="s0">* a new list.  See add_vis_column().</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void PfmVizzer::clear_vis_columns(void);</span>

<span class="s0">494 14 add_vis_column 0 4 537 25 PfmVizzer::add_vis_column 0 1 256 852</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new vis column specification to the list of vertex data columns that</span>
 <span class="s0">* will be generated at the next call to generate_vis_points() or</span>
 <span class="s0">* generate_vis_mesh().  This advanced interface supercedes the higher-level</span>
 <span class="s0">* set_vis_inverse(), set_flat_texcoord_name(), and set_vis_2d().</span>
 <span class="s0">*</span>
 <span class="s0">* If you use this advanced interface, you must specify explicitly the</span>
 <span class="s0">* complete list of data columns to be created in the resulting</span>
 <span class="s0">* GeomVertexData, by calling add_vis_column() each time.  For each column,</span>
 <span class="s0">* you specify the source of the column in the PFMFile, the target column and</span>
 <span class="s0">* name in the GeomVertexData, and an optional transform matrix and/or lens to</span>
 <span class="s0">* transform and project the point before generating it.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* The private implementation of the public add_vis_column(), this adds the</span>
 <span class="s0">* column to the indicated specific vector.</span>
 <span class="s0">*/</span>
<span class="s0">219</span>
<span class="s0">void PfmVizzer::add_vis_column(PfmVizzer::ColumnType source, PfmVizzer::ColumnType target, InternalName *name, TransformState const *transform = nullptr, Lens const *lens = nullptr, PfmFile const *undist_lut = nullptr);</span>

<span class="s0">495 19 generate_vis_points 0 4 537 30 PfmVizzer::generate_vis_points 0 1 257 181</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a point cloud with the points of the pfm as 3-d coordinates in</span>
 <span class="s0">* space, and texture coordinates ranging from 0 .. 1 based on the position</span>
 <span class="s0">* within the pfm grid.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">NodePath PfmVizzer::generate_vis_points(void) const;</span>

<span class="s0">496 17 generate_vis_mesh 0 4 537 28 PfmVizzer::generate_vis_mesh 0 1 258 183</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a triangle mesh with the points of the pfm as 3-d coordinates in</span>
 <span class="s0">* space, and texture coordinates ranging from 0 .. 1 based on the position</span>
 <span class="s0">* within the pfm grid.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">NodePath PfmVizzer::generate_vis_mesh(PfmVizzer::MeshFace face = ::PfmVizzer::MF_front) const;</span>

<span class="s0">497 23 calc_max_u_displacement 0 4 537 34 PfmVizzer::calc_max_u_displacement 0 1 259 206</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the maximum amount of shift, in pixels either left or right, of</span>
 <span class="s0">* any pixel in the distortion map.  This can be passed to</span>
 <span class="s0">* make_displacement(); see that function for more information.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">double PfmVizzer::calc_max_u_displacement(void) const;</span>

<span class="s0">498 23 calc_max_v_displacement 0 4 537 34 PfmVizzer::calc_max_v_displacement 0 1 260 203</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the maximum amount of shift, in pixels either up or down, of any</span>
 <span class="s0">* pixel in the distortion map.  This can be passed to make_displacement();</span>
 <span class="s0">* see that function for more information.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">double PfmVizzer::calc_max_v_displacement(void) const;</span>

<span class="s0">499 17 make_displacement 0 4 537 28 PfmVizzer::make_displacement 0 2 261 262 1889</span>
<span class="s0">/**</span>
 <span class="s0">* Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V</span>
 <span class="s0">* in the first two components and the third component unused, this computes</span>
 <span class="s0">* an AfterEffects-style displacement map that represents the same distortion.</span>
 <span class="s0">* The indicated PNMImage will be filled in with a displacement map image,</span>
 <span class="s0">* with horizontal shift in the red channel and vertical shift in the green</span>
 <span class="s0">* channel, where a fully bright (or fully black) pixel indicates a shift of</span>
 <span class="s0">* max_u or max_v pixels.</span>
 <span class="s0">*</span>
 <span class="s0">* Use calc_max_u_displacement() and calc_max_v_displacement() to compute</span>
 <span class="s0">* suitable values for max_u and max_v.</span>
 <span class="s0">*</span>
 <span class="s0">* This generates an integer 16-bit displacement image.  It is a good idea,</span>
 <span class="s0">* though not necessarily essential, to check &quot;Preserve RGB&quot; in the interpret</span>
 <span class="s0">* footage section for each displacement image.  Set for_32bit true if this is</span>
 <span class="s0">* meant to be used in a 32-bit project file, and false if it is meant to be</span>
 <span class="s0">* used in a 16-bit project file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V</span>
 <span class="s0">* in the first two components and the third component unused, this computes</span>
 <span class="s0">* an AfterEffects-style displacement map that represents the same distortion.</span>
 <span class="s0">* The indicated PNMImage will be filled in with a displacement map image,</span>
 <span class="s0">* with horizontal shift in the red channel and vertical shift in the green</span>
 <span class="s0">* channel, where a fully bright (or fully black) pixel indicates a shift of</span>
 <span class="s0">* max_u or max_v pixels.</span>
 <span class="s0">*</span>
 <span class="s0">* Use calc_max_u_displacement() and calc_max_v_displacement() to compute</span>
 <span class="s0">* suitable values for max_u and max_v.</span>
 <span class="s0">*</span>
 <span class="s0">* This generates a 32-bit floating-point displacement image.  It is essential</span>
 <span class="s0">* to check &quot;Preserve RGB&quot; in the interpret footage section for each</span>
 <span class="s0">* displacement image.  Set for_32bit true if this is meant to be used in a</span>
 <span class="s0">* 32-bit project file, and false if it is meant to be used in a 16-bit</span>
 <span class="s0">* project file.</span>
 <span class="s0">*/</span>
<span class="s0">204</span>
<span class="s0">void PfmVizzer::make_displacement(PNMImage &amp;result, double max_u, double max_v, bool for_32bit) const;</span>
<span class="s0">void PfmVizzer::make_displacement(PfmFile &amp;result, double max_u, double max_v, bool for_32bit) const;</span>

<span class="s0">262</span>
<span class="s0">1 0 0 15 3 542 264 0 0 1 6 param0 0 540  </span>
<span class="s0">2 0 0 7 3 542 264 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 543  </span>
<span class="s0">3 0 0 4 5 544 0 0 63 /**</span>
 <span class="s0">* Resets all the parameters to their initial defaults.</span>
 <span class="s0">*/ 1 4 this 3 542  </span>
<span class="s0">4 0 0 4 6 544 0 0 240 /**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices.  If</span>
 <span class="s0">* set_has_uvs() is true (as it is by default), the vertices will be generated</span>
 <span class="s0">* with the indicated range of UV's, which will be useful if a texture is</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/ 3 4 this 3 542  2 ll 1 545  2 ur 1 545  </span>
<span class="s0">5 0 0 4 6 544 0 0 240 /**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices.  If</span>
 <span class="s0">* set_has_uvs() is true (as it is by default), the vertices will be generated</span>
 <span class="s0">* with the indicated range of UV's, which will be useful if a texture is</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/ 5 4 this 3 542  2 ll 1 545  2 lr 1 545  2 ur 1 545  2 ul 1 545  </span>
<span class="s0">6 0 0 4 6 544 0 0 240 /**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices.  If</span>
 <span class="s0">* set_has_uvs() is true (as it is by default), the vertices will be generated</span>
 <span class="s0">* with the indicated range of UV's, which will be useful if a texture is</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/ 5 4 this 3 542  2 ll 1 550  2 lr 1 550  2 ur 1 550  2 ul 1 550  </span>
<span class="s0">7 0 0 4 6 544 0 0 240 /**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices.  If</span>
 <span class="s0">* set_has_uvs() is true (as it is by default), the vertices will be generated</span>
 <span class="s0">* with the indicated range of UV's, which will be useful if a texture is</span>
 <span class="s0">* applied.</span>
 <span class="s0">*/ 4 4 this 3 542  1 x 1 555  1 y 1 555  1 z 1 555  </span>
<span class="s0">8 0 0 4 6 544 0 0 130 /**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices appropriately</span>
 <span class="s0">* to show the non-pad region of the texture.</span>
 <span class="s0">*/ 2 4 this 3 542  3 tex 1 559  </span>
<span class="s0">9 0 0 4 7 544 0 0 108 /**</span>
 <span class="s0">* Sets the range of UV's that will be applied to the vertices appropriately</span>
 <span class="s0">* for a cube-map face.</span>
 <span class="s0">*/ 2 4 this 3 542  4 face 1 515  </span>
<span class="s0">10 0 0 4 8 544 0 0 91 /**</span>
 <span class="s0">* Sets the flag indicating whether vertices will be generated with UV's or</span>
 <span class="s0">* not.</span>
 <span class="s0">*/ 2 4 this 3 542  4 flag 1 516  </span>
<span class="s0">11 0 0 4 9 544 0 0 211 /**</span>
 <span class="s0">* Sets the flag indicating whether vertices will be generated with</span>
 <span class="s0">* 3-component UVW's (true) or 2-component UV's (the default, false).</span>
 <span class="s0">* Normally, this will be implicitly set by setting the uv_range.</span>
 <span class="s0">*/ 2 4 this 3 542  4 flag 1 516  </span>
<span class="s0">12 0 0 4 10 544 0 0 37 /**</span>
 <span class="s0">* Sets the size of the card.</span>
 <span class="s0">*/ 2 4 this 3 542  5 frame 1 561  </span>
<span class="s0">13 0 0 4 10 544 0 0 37 /**</span>
 <span class="s0">* Sets the size of the card.</span>
 <span class="s0">*/ 5 4 this 3 542  2 ll 1 565  2 lr 1 565  2 ur 1 565  2 ul 1 565  </span>
<span class="s0">14 0 0 4 10 544 0 0 37 /**</span>
 <span class="s0">* Sets the size of the card.</span>
 <span class="s0">*/ 5 4 this 3 542  4 left 1 529  5 right 1 529  6 bottom 1 529  3 top 1 529  </span>
<span class="s0">15 0 0 4 11 544 0 0 134 /**</span>
 <span class="s0">* Sets the card to (-1,1,-1,1), which is appropriate if you plan to parent it</span>
 <span class="s0">* to render2d and use it as a fullscreen quad.</span>
 <span class="s0">*/ 1 4 this 3 542  </span>
<span class="s0">16 0 0 4 12 544 0 0 0 2 4 this 3 542  5 color 1 569  </span>
<span class="s0">17 0 0 4 12 544 0 0 38 /**</span>
 <span class="s0">* Sets the color of the card.</span>
 <span class="s0">*/ 5 4 this 3 542  1 r 1 529  1 g 1 529  1 b 1 529  1 a 1 529  </span>
<span class="s0">18 0 0 4 13 544 0 0 355 /**</span>
 <span class="s0">* Sets the flag indicating whether vertices will be generated with normals or</span>
 <span class="s0">* not.  Normals are required if you intend to enable lighting on the card,</span>
 <span class="s0">* but are just wasted space and bandwidth otherwise, so there is a (slight)</span>
 <span class="s0">* optimization for disabling them.  If enabled, the normals will be generated</span>
 <span class="s0">* perpendicular to the card's face.</span>
 <span class="s0">*/ 2 4 this 3 542  4 flag 1 516  </span>
<span class="s0">19 0 0 4 14 544 0 0 445 /**</span>
 <span class="s0">* Sets a node that will be copied (and scaled and translated) to generate the</span>
 <span class="s0">* frame, instead of generating a new polygon.  The node may contain arbitrary</span>
 <span class="s0">* geometry that describes a flat polygon contained within the indicated left,</span>
 <span class="s0">* right, bottom, top frame.</span>
 <span class="s0">*</span>
 <span class="s0">* When generate() is called, the geometry in this node will be scaled and</span>
 <span class="s0">* translated appropriately to give it the size and aspect ratio specified by</span>
 <span class="s0">* set_frame().</span>
 <span class="s0">*/ 3 4 this 3 542  4 node 1 573  5 frame 1 561  </span>
<span class="s0">20 0 0 4 15 544 0 0 82 /**</span>
 <span class="s0">* Removes the node specified by an earlier call to set_source_geometry().</span>
 <span class="s0">*/ 1 4 this 3 542  </span>
<span class="s0">21 0 0 7 16 573 0 0 68 /**</span>
 <span class="s0">* Generates a GeomNode that renders the specified geometry.</span>
 <span class="s0">*/ 1 4 this 3 542  </span>
<span class="s0">22 0 0 15 18 576 278 0 0 1 6 param0 0 574  </span>
<span class="s0">23 0 0 7 18 576 278 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 543  </span>
<span class="s0">24 0 0 4 20 544 0 0 63 /**</span>
 <span class="s0">* Resets all the parameters to their initial defaults.</span>
 <span class="s0">*/ 1 4 this 3 576  </span>
<span class="s0">25 0 0 4 21 544 0 0 146 /**</span>
 <span class="s0">* Specifies the field of view of the fisheye projection.  A sphere map will</span>
 <span class="s0">* have a 360-degree field of view (and this is the default).</span>
 <span class="s0">*/ 2 4 this 3 576  3 fov 1 529  </span>
<span class="s0">26 0 0 4 22 544 0 0 303 /**</span>
 <span class="s0">* Specifies the approximate number of vertices to be used to generate the</span>
 <span class="s0">* rose.  This is the approximate number of vertices that will be located</span>
 <span class="s0">* within the rose's unit circle, not counting the inscribing square (if any).</span>
 <span class="s0">* The actual number of vertices used may be +/- 25% of this value.</span>
 <span class="s0">*/ 2 4 this 3 576  12 num_vertices 1 515  </span>
<span class="s0">27 0 0 4 23 544 0 0 577 /**</span>
 <span class="s0">* Sets the flag that indicates whether the rose should be inscribed within a</span>
 <span class="s0">* square.  When this is true, an additional square is generated to inscribed</span>
 <span class="s0">* the circular rose, with the indicated &quot;radius&quot; (the sides of the square</span>
 <span class="s0">* will be 2 * square_radius).  The texture coordinates of the square will</span>
 <span class="s0">* uniformly map to the back pole of the cube map.</span>
 <span class="s0">*</span>
 <span class="s0">* This is mainly useful to provide a good uniform background color for a</span>
 <span class="s0">* sphere map so that it does not have a sharp circular edge that might</span>
 <span class="s0">* produce artifacts due to numerical imprecision when mapping.</span>
 <span class="s0">*/ 3 4 this 3 576  16 square_inscribed 1 516  13 square_radius 1 529  </span>
<span class="s0">28 0 0 4 24 544 0 0 327 /**</span>
 <span class="s0">* Sets the flag indicating whether the texture image should be mirrored</span>
 <span class="s0">* (true) or normal (false).  When this is true, the 3-D texture coordinates</span>
 <span class="s0">* will be reversed so that the image is appropriate for a reflection.  This</span>
 <span class="s0">* is the best choice for generating a sphere map from a cube map.  The</span>
 <span class="s0">* default is false.</span>
 <span class="s0">*/ 2 4 this 3 576  10 reflection 1 516  </span>
<span class="s0">29 0 0 7 25 573 0 0 68 /**</span>
 <span class="s0">* Generates a GeomNode that renders the specified geometry.</span>
 <span class="s0">*/ 1 4 this 3 576  </span>
<span class="s0">30 0 0 15 28 579 0 0 0 1 6 param0 0 577  </span>
<span class="s0">31 0 0 7 28 579 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 543  </span>
<span class="s0">32 0 0 4 29 544 0 0 112 /**</span>
 <span class="s0">* Sets up the frame rate meter to create a DisplayRegion to render itself</span>
 <span class="s0">* into the indicated window.</span>
 <span class="s0">*/ 2 4 this 3 579  6 window 1 580  </span>
<span class="s0">33 0 0 4 30 544 0 0 66 /**</span>
 <span class="s0">* Undoes the effect of a previous call to setup_window().</span>
 <span class="s0">*/ 1 4 this 3 579  </span>
<span class="s0">34 0 0 7 31 580 0 0 122 /**</span>
 <span class="s0">* Returns the GraphicsOutput that was passed to setup_window(), or NULL if</span>
 <span class="s0">* setup_window() has not been called.</span>
 <span class="s0">*/ 1 4 this 3 577  </span>
<span class="s0">35 0 0 7 32 583 0 0 168 /**</span>
 <span class="s0">* Returns the DisplayRegion that the meter has created to render itself into</span>
 <span class="s0">* the window to setup_window(), or NULL if setup_window() has not been</span>
 <span class="s0">* called.</span>
 <span class="s0">*/ 1 4 this 3 577  </span>
<span class="s0">36 0 0 4 33 544 0 0 255 /**</span>
 <span class="s0">* Specifies the number of seconds that should elapse between updates to the</span>
 <span class="s0">* frame rate indication.  This should be reasonably slow (e.g.  0.2 to 1.0)</span>
 <span class="s0">* so that the calculation of the frame rate text does not itself dominate the</span>
 <span class="s0">* frame rate.</span>
 <span class="s0">*/ 2 4 this 3 579  15 update_interval 1 514  </span>
<span class="s0">37 0 0 6 34 514 0 0 106 /**</span>
 <span class="s0">* Returns the number of seconds that will elapse between updates to the frame</span>
 <span class="s0">* rate indication.</span>
 <span class="s0">*/ 1 4 this 3 577  </span>
<span class="s0">38 0 0 4 35 544 0 0 176 /**</span>
 <span class="s0">* Sets the sprintf() pattern that is used to format the text.  The string</span>
 <span class="s0">* &quot;%f&quot; or some variant will be replaced with the current frame rate in frames</span>
 <span class="s0">* per second.</span>
 <span class="s0">*/ 2 4 this 3 579  12 text_pattern 1 543  </span>
<span class="s0">39 0 0 6 36 543 0 0 73 /**</span>
 <span class="s0">* Returns the sprintf() pattern that is used to format the text.</span>
 <span class="s0">*/ 1 4 this 3 577  </span>
<span class="s0">40 0 0 4 37 544 0 0 152 /**</span>
 <span class="s0">* Sets the clock that is used to determine the frame rate.  The default is</span>
 <span class="s0">* the application's global clock (ClockObject::get_global_clock()).</span>
 <span class="s0">*/ 2 4 this 3 579  12 clock_object 1 584  </span>
<span class="s0">41 0 0 7 38 584 0 0 70 /**</span>
 <span class="s0">* Returns the clock that is used to determine the frame rate.</span>
 <span class="s0">*/ 1 4 this 3 577  </span>
<span class="s0">42 0 0 4 39 544 0 0 186 /**</span>
 <span class="s0">* You can call this to explicitly force the FrameRateMeter to update itself</span>
 <span class="s0">* with the latest frame rate information.  Normally, it is not necessary to</span>
 <span class="s0">* call this explicitly.</span>
 <span class="s0">*/ 1 4 this 3 579  </span>
<span class="s0">43 0 0 7 40 587 0 0 0 0 </span>
<span class="s0">44 0 0 7 43 588 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 543  </span>
<span class="s0">45 0 0 6 44 589 0 0 150 /**</span>
 <span class="s0">* Returns a reference to the heightfield (a PNMImage) contained inside</span>
 <span class="s0">* GeoMipTerrain.  You can use the reference to alter the heightfield.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">46 0 0 6 45 516 0 0 232 /**</span>
 <span class="s0">* Loads the specified heightmap image file into the heightfield.  Returns</span>
 <span class="s0">* true if succeeded, or false if an error has occured.  If the heightmap is</span>
 <span class="s0">* not a power of two plus one, it is scaled up using a gaussian filter.</span>
 <span class="s0">*/ 3 4 this 3 588  8 filename 1 591  4 type 5 594  </span>
<span class="s0">47 0 0 6 45 516 0 0 232 /**</span>
 <span class="s0">* Loads the specified heightmap image file into the heightfield.  Returns</span>
 <span class="s0">* true if succeeded, or false if an error has occured.  If the heightmap is</span>
 <span class="s0">* not a power of two plus one, it is scaled up using a gaussian filter.</span>
 <span class="s0">*/ 2 4 this 3 588  5 image 1 596  </span>
<span class="s0">48 0 0 6 46 589 0 0 146 /**</span>
 <span class="s0">* Returns a reference to the color map (a PNMImage) contained inside</span>
 <span class="s0">* GeoMipTerrain.  You can use the reference to alter the color map.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">49 0 0 6 47 516 0 0 234 /**</span>
 <span class="s0">* Loads the specified image as color map.  The next time generate() is</span>
 <span class="s0">* called, the terrain is painted with this color map using the vertex color</span>
 <span class="s0">* column.  Returns a boolean indicating whether the operation has succeeded.</span>
 <span class="s0">*/ 3 4 this 3 588  8 filename 1 591  4 type 5 594  </span>
<span class="s0">50 0 0 6 47 516 0 0 0 2 4 this 3 588  5 image 1 596  </span>
<span class="s0">51 0 0 6 47 516 0 0 0 2 4 this 3 588  5 image 1 559  </span>
<span class="s0">52 0 0 6 47 516 0 0 0 2 4 this 3 588  4 path 1 543  </span>
<span class="s0">53 0 0 6 48 516 0 0 52 /**</span>
 <span class="s0">* Returns whether a color map has been set.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">54 0 0 4 49 544 0 0 32 /**</span>
 <span class="s0">* Clears the color map.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">55 0 0 4 50 544 0 0 250 /**</span>
 <span class="s0">* Calculates an approximate for the ambient occlusion and stores it in the</span>
 <span class="s0">* color map, so that it will be written to the vertex colors.  Any existing</span>
 <span class="s0">* color map will be discarded.  You need to call this before generating the</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/ 4 4 this 3 588  6 radius 5 529  8 contrast 5 529  10 brightness 5 529  </span>
<span class="s0">56 0 0 6 51 514 0 0 410 /**</span>
 <span class="s0">* Fetches the elevation at (x, y), where the input coordinate is specified in</span>
 <span class="s0">* pixels.  This ignores the current LOD level and instead provides an</span>
 <span class="s0">* accurate number.  Linear blending is used for non-integral coordinates.</span>
 <span class="s0">* Terrain scale is NOT taken into account!  To get accurate normals, please</span>
 <span class="s0">* multiply this with the terrain Z scale!</span>
 <span class="s0">*</span>
 <span class="s0">* trueElev = terr.get_elevation(x,y) * terr.get_sz();</span>
 <span class="s0">*/ 3 4 this 3 588  1 x 1 514  1 y 1 514  </span>
<span class="s0">57 0 0 7 52 602 0 0 510 /**</span>
 <span class="s0">* Fetches the terrain normal at (x, y), where the input coordinate is</span>
 <span class="s0">* specified in pixels.  This ignores the current LOD level and instead</span>
 <span class="s0">* provides an accurate number.  Terrain scale is NOT taken into account!  To</span>
 <span class="s0">* get accurate normals, please divide it by the terrain scale and normalize</span>
 <span class="s0">* it again, like this:</span>
 <span class="s0">*</span>
 <span class="s0">* LVector3 normal (terr.get_normal(x, y)); normal.set(normal.get_x() /</span>
 <span class="s0">* root.get_sx(), normal.get_y() / root.get_sy(), normal.get_z() /</span>
 <span class="s0">* root.get_sz()); normal.normalize();</span>
 <span class="s0">*/ 3 4 this 3 588  1 x 1 515  1 y 1 515  </span>
<span class="s0">58 0 0 7 52 602 0 0 317 /**</span>
 <span class="s0">* Fetches the terrain normal at (x,y), where the input coordinate is</span>
 <span class="s0">* specified in pixels.  This ignores the current LOD level and instead</span>
 <span class="s0">* provides an accurate number.  Terrain scale is NOT taken into account!  To</span>
 <span class="s0">* get accurate normals, please divide it by the terrain scale and normalize</span>
 <span class="s0">* it again!</span>
 <span class="s0">*/ 5 4 this 3 588  2 mx 1 603  2 my 1 603  1 x 1 515  1 y 1 515  </span>
<span class="s0">59 0 0 4 53 544 0 0 238 /**</span>
 <span class="s0">* Sets a boolean specifying whether the terrain will be rendered bruteforce.</span>
 <span class="s0">* If the terrain is rendered bruteforce, there will be no Level of Detail,</span>
 <span class="s0">* and the update() call will only update the terrain if it is marked dirty.</span>
 <span class="s0">*/ 2 4 this 3 588  2 bf 1 516  </span>
<span class="s0">60 0 0 6 54 516 0 0 124 /**</span>
 <span class="s0">* Returns a boolean whether the terrain is rendered bruteforce or not.  See</span>
 <span class="s0">* set_bruteforce for more information.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">61 0 0 4 56 544 0 0 210 /**</span>
 <span class="s0">* The terrain can be automatically flattened (using flatten_light,</span>
 <span class="s0">* flatten_medium, or flatten_strong) after each update.  This only affects</span>
 <span class="s0">* future updates, it doesn't flatten the current terrain.</span>
 <span class="s0">*/ 2 4 this 3 588  4 mode 1 515  </span>
<span class="s0">62 0 0 4 57 544 0 0 276 // The focal point is the point at which the terrain will have the highest</span>
<span class="s0">// quality (lowest level of detail). Parts farther away from the focal point</span>
<span class="s0">// will have a lower quality (higher level of detail). The focal point is</span>
<span class="s0">// not taken in respect if bruteforce is set true. 2 4 this 3 588  2 fp 1 604  </span>
<span class="s0">63 0 0 4 57 544 0 0 0 2 4 this 3 588  2 fp 1 607  </span>
<span class="s0">64 0 0 4 57 544 0 0 0 2 4 this 3 588  2 fp 1 609  </span>
<span class="s0">65 0 0 4 57 544 0 0 0 2 4 this 3 588  2 fp 1 612  </span>
<span class="s0">66 0 0 4 57 544 0 0 0 2 4 this 3 588  3 fnp 1 614  </span>
<span class="s0">67 0 0 4 57 544 0 0 350 /**</span>
 <span class="s0">* Sets the focal point.  GeoMipTerrain generates high-resolution terrain</span>
 <span class="s0">* around the focal point, and progressively lower and lower resolution</span>
 <span class="s0">* terrain as you get farther away.  If a point is supplied and not a</span>
 <span class="s0">* NodePath, make sure it's relative to the terrain.  Only the x and y</span>
 <span class="s0">* coordinates of the focal point are taken in respect.</span>
 <span class="s0">*/ 3 4 this 3 588  1 x 1 514  1 y 1 514  </span>
<span class="s0">68 0 0 7 58 614 0 0 145 /**</span>
 <span class="s0">* Returns the focal point, as a NodePath.  If you have set it to be just a</span>
 <span class="s0">* point, it will return an empty node at the focal position.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">69 0 0 7 59 614 0 0 258 /**</span>
 <span class="s0">* Returns the root of the terrain.  This is a single PandaNode to which all</span>
 <span class="s0">* the rest of the terrain is parented.  The generate and update operations</span>
 <span class="s0">* replace the nodes which are parented to this root, but they don't replace</span>
 <span class="s0">* this root itself.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">70 0 0 4 60 544 0 0 98 /**</span>
 <span class="s0">* Sets the block size.  If it is not a power of two, the closest power of two</span>
 <span class="s0">* is used.</span>
 <span class="s0">*/ 2 4 this 3 588  5 newbs 1 603  </span>
<span class="s0">71 0 0 6 61 603 0 0 31 /**</span>
 <span class="s0">* Gets the block size.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">72 0 0 6 62 603 0 0 140 /**</span>
 <span class="s0">* Returns the highest level possible for this block size.  When a block is at</span>
 <span class="s0">* this level, it will be the worst quality possible.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">73 0 0 4 63 544 0 0 243 /**</span>
 <span class="s0">* Sets the minimum level of detail at which blocks may be generated by</span>
 <span class="s0">* generate() or update(). The default value is 0, which is the highest</span>
 <span class="s0">* quality.  This value is also taken in respect when generating the terrain</span>
 <span class="s0">* bruteforce.</span>
 <span class="s0">*/ 2 4 this 3 588  8 minlevel 1 603  </span>
<span class="s0">74 0 0 6 64 603 0 0 163 /**</span>
 <span class="s0">* Gets the minimum level of detail at which blocks may be generated by</span>
 <span class="s0">* generate() or update(). The default value is 0, which is the highest</span>
 <span class="s0">* quality.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">75 0 0 6 65 516 0 0 298 /**</span>
 <span class="s0">* Returns a bool indicating whether the terrain is marked 'dirty', that means</span>
 <span class="s0">* the terrain has to be regenerated on the next update() call, because for</span>
 <span class="s0">* instance the heightfield has changed.  Once the terrain has been</span>
 <span class="s0">* regenerated, the dirty flag automatically gets reset internally.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">76 0 0 4 66 544 0 0 334 /**</span>
 <span class="s0">* DEPRECATED method.  Use set_near/far instead.  Sets the quality factor at</span>
 <span class="s0">* which blocks must be generated.  The higher this level, the better quality</span>
 <span class="s0">* the terrain will be, but more expensive to render.  A value of 0 makes the</span>
 <span class="s0">* terrain the lowest quality possible, depending on blocksize.  The default</span>
 <span class="s0">* value is 100.</span>
 <span class="s0">*/ 2 4 this 3 588  6 factor 1 529  </span>
<span class="s0">77 0 0 4 67 544 0 0 59 /**</span>
 <span class="s0">* Sets the near and far LOD distances in one call.</span>
 <span class="s0">*/ 3 4 this 3 588  10 input_near 1 514  9 input_far 1 514  </span>
<span class="s0">78 0 0 4 68 544 0 0 152 /**</span>
 <span class="s0">* Sets the near LOD distance, at which the terrain will be rendered at</span>
 <span class="s0">* highest quality.  This distance is in the terrain's coordinate space!</span>
 <span class="s0">*/ 2 4 this 3 588  10 input_near 1 514  </span>
<span class="s0">79 0 0 4 69 544 0 0 150 /**</span>
 <span class="s0">* Sets the far LOD distance, at which the terrain will be rendered at lowest</span>
 <span class="s0">* quality.  This distance is in the terrain's coordinate space!</span>
 <span class="s0">*/ 2 4 this 3 588  9 input_far 1 514  </span>
<span class="s0">80 0 0 7 70 616 0 0 380 /**</span>
 <span class="s0">* Returns the NodePath of the specified block.  If auto-flatten is enabled</span>
 <span class="s0">* and the node is getting removed during the flattening process, it will</span>
 <span class="s0">* still return a NodePath with the appropriate terrain chunk, but it will be</span>
 <span class="s0">* in a temporary scenegraph.  Please note that this returns a const object</span>
 <span class="s0">* and you can not modify the node.  Modify the heightfield instead.</span>
 <span class="s0">*/ 3 4 this 3 588  2 mx 1 603  2 my 1 603  </span>
<span class="s0">81 0 0 7 71 619 0 0 479 /**</span>
 <span class="s0">* Gets the coordinates of the block at the specified position.  This position</span>
 <span class="s0">* must be relative to the terrain, not to render.  Returns an array</span>
 <span class="s0">* containing two values: the block x and the block y coords.  If the</span>
 <span class="s0">* positions are out of range, the closest block is taken.  Note that the</span>
 <span class="s0">* VecBase returned does not represent a vector, position, or rotation, but it</span>
 <span class="s0">* contains the block index of the block which you can use in</span>
 <span class="s0">* GeoMipTerrain::get_block_node_path.</span>
 <span class="s0">*/ 3 4 this 3 588  1 x 1 514  1 y 1 514  </span>
<span class="s0">82 0 0 4 72 544 0 0 360 /**</span>
 <span class="s0">* If this value is true, the LOD level at the borders of the terrain will be</span>
 <span class="s0">* 0. This is useful if you have multiple terrains attached and you want to</span>
 <span class="s0">* stitch them together, to fix seams.  This setting also has effect when</span>
 <span class="s0">* bruteforce is enabled, although in that case you are probably better off</span>
 <span class="s0">* with setting the minlevels to the same value.</span>
 <span class="s0">*/ 2 4 this 3 588  9 stitching 1 516  </span>
<span class="s0">83 0 0 6 73 516 0 0 106 /**</span>
 <span class="s0">* Returns the current stitching setting.  False by default, unless</span>
 <span class="s0">* set_stitching has been set.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">84 0 0 6 74 514 0 0 71 /**</span>
 <span class="s0">* Returns the far LOD distance in the terrain coordinate space</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">85 0 0 6 75 514 0 0 72 /**</span>
 <span class="s0">* Returns the near LOD distance in the terrain coordinate space</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">86 0 0 6 76 515 0 0 110 /**</span>
 <span class="s0">* Returns the automatic-flatten mode (e.g., off, flatten_light,</span>
 <span class="s0">* flatten_medium, or flatten_strong)</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">87 0 0 7 77 589 0 0 520 /**</span>
 <span class="s0">* Returns a new grayscale image containing the slope angles.  A white pixel</span>
 <span class="s0">* value means a vertical slope, while a black pixel will mean that the</span>
 <span class="s0">* terrain is entirely flat at that pixel.  You can translate it to degrees by</span>
 <span class="s0">* mapping the greyscale values from 0 to 90 degrees.  The resulting image</span>
 <span class="s0">* will have the same size as the heightfield image.  The scale will be taken</span>
 <span class="s0">* into respect -- meaning, if you change the terrain scale, the slope image</span>
 <span class="s0">* will need to be regenerated in order to be correct.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">88 0 0 4 78 544 0 0 191 /**</span>
 <span class="s0">* (Re)generates the entire terrain, erasing the current.  This call un-</span>
 <span class="s0">* flattens the terrain, so make sure you have set auto-flatten if you want to</span>
 <span class="s0">* keep your terrain flattened.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">89 0 0 6 79 516 0 0 447 /**</span>
 <span class="s0">* Loops through all of the terrain blocks, and checks whether they need to be</span>
 <span class="s0">* updated.  If that is indeed the case, it regenerates the mipmap.  Returns a</span>
 <span class="s0">* true when the terrain has changed.  Returns false when the terrain isn't</span>
 <span class="s0">* updated at all.  If there is no terrain yet, it generates the entire</span>
 <span class="s0">* terrain.  This call un-flattens the terrain, so make sure you have set</span>
 <span class="s0">* auto-flatten if you want to keep your terrain flattened.</span>
 <span class="s0">*/ 1 4 this 3 588  </span>
<span class="s0">90 0 0 7 80 587 0 0 0 0 </span>
<span class="s0">91 0 0 15 82 622 336 0 0 1 6 param0 0 620  </span>
<span class="s0">92 0 0 7 82 622 336 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 543  </span>
<span class="s0">93 0 0 6 84 589 0 0 162 /**</span>
 <span class="s0">* Returns a reference to the heightfield (a PNMImage) contained inside the</span>
 <span class="s0">* HeightfieldTesselator.  You can use the reference to alter the heightfield.</span>
 <span class="s0">*/ 1 4 this 3 622  </span>
<span class="s0">94 0 0 6 85 516 0 0 73 /**</span>
 <span class="s0">* Loads the specified greyscale image file into the heightfield.</span>
 <span class="s0">*/ 3 4 this 3 622  8 filename 1 591  4 type 5 594  </span>
<span class="s0">95 0 0 4 86 544 0 0 131 /**</span>
 <span class="s0">* Sets the polygon-count target.  The tesselator usually manages to come</span>
 <span class="s0">* within about 20% of the target, plus or minus.</span>
 <span class="s0">*/ 2 4 this 3 622  1 n 1 515  </span>
<span class="s0">96 0 0 4 87 544 0 0 354 /**</span>
 <span class="s0">* Sets the visibility radius.  Polygons that are completely outside the</span>
 <span class="s0">* radius (relative to the focal point) are cropped away.  The cropping is</span>
 <span class="s0">* imperfect (all approximations are conservative), so this should be used in</span>
 <span class="s0">* conjunction with a far clipping plane, fog, or some other visibility</span>
 <span class="s0">* limiting mechanism.  The units are in pixels.</span>
 <span class="s0">*/ 2 4 this 3 622  1 r 1 515  </span>
<span class="s0">97 0 0 4 88 544 0 0 216 /**</span>
 <span class="s0">* Sets the focal point.  The tesselator generates high-resolution terrain</span>
 <span class="s0">* around the focal point, and progressively lower and lower resolution</span>
 <span class="s0">* terrain as you get farther away.  The units are in pixels.</span>
 <span class="s0">*/ 3 4 this 3 622  1 x 1 515  1 y 1 515  </span>
<span class="s0">98 0 0 4 89 544 0 0 135 /**</span>
 <span class="s0">* Sets the horizontal scale.  The default scale is 1.0, meaning that each</span>
 <span class="s0">* pixel in the heightfield is 1x1 panda units wide.</span>
 <span class="s0">*/ 2 4 this 3 622  1 h 1 514  </span>
<span class="s0">99 0 0 4 90 544 0 0 162 /**</span>
 <span class="s0">* Sets the vertical scale.  The default scale is 255.0, meaning that each as</span>
 <span class="s0">* the gray value ranges from (0-1), the elevation ranges from (0-255) feet.</span>
 <span class="s0">*/ 2 4 this 3 622  1 v 1 514  </span>
<span class="s0">100 0 0 4 91 544 0 0 43 /**</span>
 <span class="s0">* Sets the max triangles per geom.</span>
 <span class="s0">*/ 2 4 this 3 622  1 n 1 515  </span>
<span class="s0">101 0 0 6 92 514 0 0 239 /**</span>
 <span class="s0">* Fetches the elevation at (x,y), where the input coordinate is specified in</span>
 <span class="s0">* pixels.  This ignores the current tesselation level and instead provides an</span>
 <span class="s0">* accurate number.  Linear blending is used for non-integral coordinates.</span>
 <span class="s0">*/ 3 4 this 3 622  1 x 1 514  1 y 1 514  </span>
<span class="s0">102 0 0 7 93 614 0 0 112 /**</span>
 <span class="s0">* Generates a tree of nodes that represents the heightfield.  This can be</span>
 <span class="s0">* reparented into the scene.</span>
 <span class="s0">*/ 1 4 this 3 622  </span>
<span class="s0">103 0 0 15 95 625 348 0 0 1 6 param0 0 623  </span>
<span class="s0">104 0 0 7 95 625 348 0 352 /**</span>
 <span class="s0">* Constructs a LineSegs object, which can be used to create any number of</span>
 <span class="s0">* disconnected lines or points of various thicknesses and colors through the</span>
 <span class="s0">* visible scene.  After creating the object, call move_to() and draw_to()</span>
 <span class="s0">* repeatedly to describe the path, then call create() to create a GeomNode</span>
 <span class="s0">* which will render the described path.</span>
 <span class="s0">*/ 1 4 name 5 543  </span>
<span class="s0">105 0 0 4 97 544 0 0 79 /**</span>
 <span class="s0">* Removes any lines in progress and resets to the initial empty state.</span>
 <span class="s0">*/ 1 4 this 3 625  </span>
<span class="s0">106 0 0 4 98 544 0 0 125 /**</span>
 <span class="s0">* Establishes the color that will be assigned to all vertices created by</span>
 <span class="s0">* future calls to move_to() and draw_to().</span>
 <span class="s0">*/ 2 4 this 3 625  5 color 1 569  </span>
<span class="s0">107 0 0 4 98 544 0 0 125 /**</span>
 <span class="s0">* Establishes the color that will be assigned to all vertices created by</span>
 <span class="s0">* future calls to move_to() and draw_to().</span>
 <span class="s0">*/ 5 4 this 3 625  1 r 1 529  1 g 1 529  1 b 1 529  1 a 5 529  </span>
<span class="s0">108 0 0 4 99 544 0 0 151 /**</span>
 <span class="s0">* Establishes the line thickness or point size in pixels that will be</span>
 <span class="s0">* assigned to all lines and points created by future calls to create().</span>
 <span class="s0">*/ 2 4 this 3 625  5 thick 1 529  </span>
<span class="s0">109 0 0 4 100 544 0 0 217 /**</span>
 <span class="s0">* Moves the pen to the given point without drawing a line.  When followed by</span>
 <span class="s0">* draw_to(), this marks the first point of a line segment; when followed by</span>
 <span class="s0">* move_to() or create(), this creates a single point.</span>
 <span class="s0">*/ 2 4 this 3 625  1 v 1 626  </span>
<span class="s0">110 0 0 4 100 544 0 0 217 /**</span>
 <span class="s0">* Moves the pen to the given point without drawing a line.  When followed by</span>
 <span class="s0">* draw_to(), this marks the first point of a line segment; when followed by</span>
 <span class="s0">* move_to() or create(), this creates a single point.</span>
 <span class="s0">*/ 4 4 this 3 625  1 x 1 529  1 y 1 529  1 z 1 529  </span>
<span class="s0">111 0 0 4 101 544 0 0 230 /**</span>
 <span class="s0">* Draws a line segment from the pen's last position (the last call to move_to</span>
 <span class="s0">* or draw_to) to the indicated point.  move_to() and draw_to() only update</span>
 <span class="s0">* tables; the actual drawing is performed when create() is called.</span>
 <span class="s0">*/ 2 4 this 3 625  1 v 1 626  </span>
<span class="s0">112 0 0 4 101 544 0 0 230 /**</span>
 <span class="s0">* Draws a line segment from the pen's last position (the last call to move_to</span>
 <span class="s0">* or draw_to) to the indicated point.  move_to() and draw_to() only update</span>
 <span class="s0">* tables; the actual drawing is performed when create() is called.</span>
 <span class="s0">*/ 4 4 this 3 625  1 x 1 529  1 y 1 529  1 z 1 529  </span>
<span class="s0">113 0 0 6 102 565 0 0 119 /**</span>
 <span class="s0">* Returns the pen's current position.  The next call to draw_to() will draw a</span>
 <span class="s0">* line segment from this point.</span>
 <span class="s0">*/ 1 4 this 3 625  </span>
<span class="s0">114 0 0 6 103 516 0 0 126 /**</span>
 <span class="s0">* Returns true if move_to() or draw_to() have not been called since the last</span>
 <span class="s0">* reset() or create(), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 625  </span>
<span class="s0">115 0 0 7 104 631 0 0 425 /**</span>
 <span class="s0">* Appends to an existing GeomNode a new Geom that will render the series of</span>
 <span class="s0">* line segments and points described via calls to move_to() and draw_to().</span>
 <span class="s0">* The lines and points are created with the color and thickness established</span>
 <span class="s0">* by calls to set_color() and set_thickness().</span>
 <span class="s0">*</span>
 <span class="s0">* If dynamic is true, the line segments will be created with the dynamic Geom</span>
 <span class="s0">* setting, optimizing them for runtime vertex animation.</span>
 <span class="s0">*/ 3 4 this 3 625  8 previous 1 631  7 dynamic 5 516  </span>
<span class="s0">116 0 0 7 104 631 0 0 406 /**</span>
 <span class="s0">* Creates a new GeomNode that will render the series of line segments and</span>
 <span class="s0">* points described via calls to move_to() and draw_to().  The lines and</span>
 <span class="s0">* points are created with the color and thickness established by calls to</span>
 <span class="s0">* set_color() and set_thickness().</span>
 <span class="s0">*</span>
 <span class="s0">* If dynamic is true, the line segments will be created with the dynamic Geom</span>
 <span class="s0">* setting, optimizing them for runtime vertex animation.</span>
 <span class="s0">*/ 2 4 this 3 625  7 dynamic 5 516  </span>
<span class="s0">117 0 0 6 105 515 0 0 213 /**</span>
 <span class="s0">* Returns the total number of line segment and point vertices generated by</span>
 <span class="s0">* the last call to create().  The positions of these vertices may be read and</span>
 <span class="s0">* adjusted through get_vertex() and set_vertex().</span>
 <span class="s0">*/ 1 4 this 3 623  </span>
<span class="s0">118 0 0 7 106 632 0 0 248 /**</span>
 <span class="s0">* Returns the nth point or vertex of the line segment sequence generated by</span>
 <span class="s0">* the last call to create().  The first move_to() generates vertex 0;</span>
 <span class="s0">* subsequent move_to() and draw_to() calls generate consecutively higher</span>
 <span class="s0">* vertex numbers.</span>
 <span class="s0">*/ 2 4 this 3 623  1 n 1 515  </span>
<span class="s0">119 0 0 4 108 544 0 0 243 /**</span>
 <span class="s0">* Moves the nth point or vertex of the line segment sequence generated by the</span>
 <span class="s0">* last call to create().  The first move_to() generates vertex 0; subsequent</span>
 <span class="s0">* move_to() and draw_to() calls generate consecutively higher vertex numbers.</span>
 <span class="s0">*/ 3 4 this 3 625  1 n 1 515  4 vert 1 565  </span>
<span class="s0">120 0 0 4 108 544 0 0 243 /**</span>
 <span class="s0">* Moves the nth point or vertex of the line segment sequence generated by the</span>
 <span class="s0">* last call to create().  The first move_to() generates vertex 0; subsequent</span>
 <span class="s0">* move_to() and draw_to() calls generate consecutively higher vertex numbers.</span>
 <span class="s0">*/ 5 4 this 3 625  6 vertex 1 515  1 x 1 529  1 y 1 529  1 z 1 529  </span>
<span class="s0">121 0 0 7 109 633 0 0 56 /**</span>
 <span class="s0">* Returns the color of the nth point or vertex.</span>
 <span class="s0">*/ 2 4 this 3 623  6 vertex 1 515  </span>
<span class="s0">122 0 0 4 111 544 0 0 82 /**</span>
 <span class="s0">* Changes the vertex color of the nth point or vertex.  See set_vertex().</span>
 <span class="s0">*/ 3 4 this 3 625  6 vertex 1 515  1 c 1 569  </span>
<span class="s0">123 0 0 4 111 544 0 0 82 /**</span>
 <span class="s0">* Changes the vertex color of the nth point or vertex.  See set_vertex().</span>
 <span class="s0">*/ 6 4 this 3 625  6 vertex 1 515  1 r 1 529  1 g 1 529  1 b 1 529  1 a 5 529  </span>
<span class="s0">124 0 0 7 113 634 0 0 51 /**</span>
 <span class="s0">* Creates the MeshDrawer low level system.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">125 0 0 4 114 544 0 0 142 /**</span>
 <span class="s0">* Sets the total triangle budget of the drawer.  This will not be exceeded.</span>
 <span class="s0">* Don't set some thing too large because it will be slow</span>
 <span class="s0">*/ 2 4 this 3 634  6 budget 1 515  </span>
<span class="s0">126 0 0 6 115 515 0 0 55 /**</span>
 <span class="s0">* Gets the total triangle budget of the drawer</span>
 <span class="s0">*/ 1 4 this 3 634  </span>
<span class="s0">127 0 0 7 116 614 0 0 170 /**</span>
 <span class="s0">* Returns the root NodePath.  You should use this node to reparent mesh</span>
 <span class="s0">* drawer onto the scene might also want to disable depth draw or enable</span>
 <span class="s0">* transparency.</span>
 <span class="s0">*/ 1 4 this 3 634  </span>
<span class="s0">128 0 0 4 117 544 0 0 131 /**</span>
 <span class="s0">* Pass the current camera node and the root node.  Passing the camera is</span>
 <span class="s0">* required to generate bill boards that face it.</span>
 <span class="s0">*/ 3 4 this 3 634  6 camera 1 614  6 render 1 614  </span>
<span class="s0">129 0 0 4 118 544 0 0 54 /**</span>
 <span class="s0">* Draws a triangle with the given parameters.</span>
 <span class="s0">*/ 10 4 this 3 634  2 v1 1 635  2 c1 1 555  3 uv1 1 637  2 v2 1 635  2 c2 1 555  3 uv2 1 637  2 v3 1 635  2 c3 1 555  3 uv3 1 637  </span>
<span class="s0">130 0 0 4 119 544 0 0 146 /**</span>
 <span class="s0">* Draws a particle that is sort of like a bill board but has an extra</span>
 <span class="s0">* rotation component.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/ 6 4 this 3 634  3 pos 1 635  5 frame 1 555  4 size 1 529  5 color 1 555  8 rotation 1 529  </span>
<span class="s0">131 0 0 4 120 544 0 0 152 /**</span>
 <span class="s0">* Works just like particle but accepts 2 frames and a blend (from 0 to 1)</span>
 <span class="s0">* component between them Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/ 8 4 this 3 634  3 pos 1 635  6 frame1 1 555  6 frame2 1 555  5 blend 1 529  4 size 1 529  5 color 1 555  8 rotation 1 529  </span>
<span class="s0">132 0 0 4 121 544 0 0 141 /**</span>
 <span class="s0">* Draws a billboard - particle with no rotation.  Billboards always face the</span>
 <span class="s0">* camera.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/ 5 4 this 3 634  3 pos 1 635  5 frame 1 555  4 size 1 529  5 color 1 555  </span>
<span class="s0">133 0 0 4 122 544 0 0 129 /**</span>
 <span class="s0">* Draws a segment a line with a thickness.  That has billboarding effect.</span>
 <span class="s0">* Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/ 6 4 this 3 634  5 start 1 635  4 stop 1 635  5 frame 1 555  9 thickness 1 529  5 color 1 555  </span>
<span class="s0">134 0 0 4 123 544 0 0 229 /**</span>
 <span class="s0">* Draws a segment a line with a thickness.  This segment does not use the</span>
 <span class="s0">* bill boarding behavior and instead draws 2 planes in a cross.  Stars at</span>
 <span class="s0">* start and ends at stop.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/ 6 4 this 3 634  5 start 1 635  4 stop 1 635  5 frame 1 555  9 thickness 1 529  5 color 1 555  </span>
<span class="s0">135 0 0 4 124 544 0 0 167 /**</span>
 <span class="s0">* Draws a segment a line with different thickness and color on both sides.</span>
 <span class="s0">* Stars at start and ends at stop.  Frame contains u,v,u-size,v-size</span>
 <span class="s0">* quadruple.</span>
 <span class="s0">*/ 8 4 this 3 634  5 start 1 635  4 stop 1 635  5 frame 1 555  15 thickness_start 1 529  11 color_start 1 555  14 thickness_stop 1 529  10 color_stop 1 555  </span>
<span class="s0">136 0 0 4 125 544 0 0 156 /**</span>
 <span class="s0">* Stars or continues linked segment.  Control position, frame, thickness and</span>
 <span class="s0">* color with parameters.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/ 5 4 this 3 634  3 pos 1 635  5 frame 1 555  9 thickness 1 529  5 color 1 555  </span>
<span class="s0">137 0 0 4 126 544 0 0 172 /**</span>
 <span class="s0">* Finish drawing linked segments, needs at least two calls to link_segment</span>
 <span class="s0">* before it can end the linked segment.  Frame contains u,v,u-size,v-size</span>
 <span class="s0">* quadruple.</span>
 <span class="s0">*/ 3 4 this 3 634  5 frame 1 555  5 color 1 555  </span>
<span class="s0">138 0 0 4 127 544 0 0 110 /**</span>
 <span class="s0">* Draws number of particles in a sphere like emitter.  Frame contains</span>
 <span class="s0">* u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/ 8 4 this 3 634  3 pos 1 635  5 frame 1 555  4 size 1 529  5 color 1 555  4 seed 1 515  6 number 1 515  8 distance 1 529  </span>
<span class="s0">139 0 0 4 128 544 0 0 137 /**</span>
 <span class="s0">* Draws a number of particles in a big line with a shift dictated by the</span>
 <span class="s0">* offset.  Frame contains u,v,u-size,v-size quadruple.</span>
 <span class="s0">*/ 8 4 this 3 634  5 start 1 635  4 stop 1 635  5 frame 1 555  4 size 1 529  5 color 1 555  6 number 1 515  6 offset 1 529  </span>
<span class="s0">140 0 0 4 129 544 0 0 272 /**</span>
 <span class="s0">* Draws the geometry that is inside this node path into the MeshDrawer</span>
 <span class="s0">* object.  This performs a similar functions as RigidBodyCombiner but for</span>
 <span class="s0">* very dynamic situations that share the same texture like physcal chunks of</span>
 <span class="s0">* explosions.  It can be a little slow</span>
 <span class="s0">*/ 2 4 this 3 634  4 node 1 614  </span>
<span class="s0">141 0 0 4 130 544 0 0 70 /**</span>
 <span class="s0">* Finish the drawing and clearing off the remaining vertexes.</span>
 <span class="s0">*/ 1 4 this 3 634  </span>
<span class="s0">142 0 0 7 131 587 0 0 0 0 </span>
<span class="s0">143 0 0 7 133 641 0 0 53 /**</span>
 <span class="s0">* Creates the MeshDrawer2D low level system.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">144 0 0 4 134 544 0 0 56 /**</span>
 <span class="s0">* Sets the total triangle budget of the drawer.</span>
 <span class="s0">*/ 2 4 this 3 641  6 budget 1 515  </span>
<span class="s0">145 0 0 6 135 515 0 0 56 /**</span>
 <span class="s0">* Gets the total triangle budget of the drawer.</span>
 <span class="s0">*/ 1 4 this 3 641  </span>
<span class="s0">146 0 0 7 136 614 0 0 37 /**</span>
 <span class="s0">* Returns the root NodePath.</span>
 <span class="s0">*/ 1 4 this 3 641  </span>
<span class="s0">147 0 0 4 137 544 0 0 65 /**</span>
 <span class="s0">* Draws a 2D rectangle.  Ignores the clipping rectangle.</span>
 <span class="s0">*/ 13 4 this 3 641  2 v1 1 635  2 c1 1 555  3 uv1 1 637  2 v2 1 635  2 c2 1 555  3 uv2 1 637  2 v3 1 635  2 c3 1 555  3 uv3 1 637  2 v4 1 635  2 c4 1 555  3 uv4 1 637  </span>
<span class="s0">148 0 0 4 138 544 0 0 0 10 4 this 3 641  1 x 1 529  1 y 1 529  1 w 1 529  1 h 1 529  1 u 1 529  1 v 1 529  2 us 1 529  2 vs 1 529  5 color 1 555  </span>
<span class="s0">149 0 0 4 139 544 0 0 39 /**</span>
 <span class="s0">* Sets the clipping rectangle.</span>
 <span class="s0">*/ 5 4 this 3 641  1 x 1 529  1 y 1 529  1 w 1 529  1 h 1 529  </span>
<span class="s0">150 0 0 4 140 544 0 0 53 /**</span>
 <span class="s0">* Draws a 2D rectangle which can be clipped.</span>
 <span class="s0">*/ 10 4 this 3 641  1 x 1 529  1 y 1 529  1 w 1 529  1 h 1 529  1 u 1 529  1 v 1 529  2 us 1 529  2 vs 1 529  5 color 1 555  </span>
<span class="s0">151 0 0 4 141 544 0 0 96 /**</span>
 <span class="s0">* Draws a 2d rectangle, with borders and corders, taken from the surrounding</span>
 <span class="s0">* texture</span>
 <span class="s0">*/ 18 4 this 3 641  1 x 1 529  1 y 1 529  1 w 1 529  1 h 1 529  1 r 1 529  1 t 1 529  1 l 1 529  1 b 1 529  2 tr 1 529  2 tt 1 529  2 tl 1 529  2 tb 1 529  1 u 1 529  1 v 1 529  2 us 1 529  2 vs 1 529  5 color 1 555  </span>
<span class="s0">152 0 0 4 142 544 0 0 96 /**</span>
 <span class="s0">* Draws a 2d rectangle, with borders and corders, taken from the surrounding</span>
 <span class="s0">* texture</span>
 <span class="s0">*/ 18 4 this 3 641  1 x 1 529  1 y 1 529  1 w 1 529  1 h 1 529  1 r 1 529  1 t 1 529  1 l 1 529  1 b 1 529  2 tr 1 529  2 tt 1 529  2 tl 1 529  2 tb 1 529  1 u 1 529  1 v 1 529  2 us 1 529  2 vs 1 529  5 color 1 555  </span>
<span class="s0">153 0 0 4 143 544 0 0 65 /**</span>
 <span class="s0">* Draws a tiled rectangle, size of tiles is in us and vs</span>
 <span class="s0">*/ 10 4 this 3 641  1 x 1 529  1 y 1 529  1 w 1 529  1 h 1 529  1 u 1 529  1 v 1 529  2 us 1 529  2 vs 1 529  5 color 1 555  </span>
<span class="s0">154 0 0 4 144 544 0 0 82 /**</span>
 <span class="s0">* Opens up the geom for drawing, don't forget to call MeshDrawer2D::end()</span>
 <span class="s0">*/ 1 4 this 3 641  </span>
<span class="s0">155 0 0 4 145 544 0 0 70 /**</span>
 <span class="s0">* Finish the drawing and clearing off the remaining vertexes.</span>
 <span class="s0">*/ 1 4 this 3 641  </span>
<span class="s0">156 0 0 7 146 587 0 0 0 0 </span>
<span class="s0">157 0 0 7 149 644 0 0 57 /**</span>
 <span class="s0">* Creates a texture playing the specified movie.</span>
 <span class="s0">*/ 1 5 video 1 642  </span>
<span class="s0">158 0 0 7 149 644 0 0 100 /**</span>
 <span class="s0">* Creates a blank movie texture.  Movies must be added using do_read_one or</span>
 <span class="s0">* do_load_one.</span>
 <span class="s0">*/ 1 4 name 1 543  </span>
<span class="s0">159 0 0 6 150 514 0 0 43 /**</span>
 <span class="s0">* Returns the length of the video.</span>
 <span class="s0">*/ 1 4 this 3 645  </span>
<span class="s0">160 0 0 6 151 515 0 0 200 /**</span>
 <span class="s0">* Returns the width in texels of the source video stream.  This is not</span>
 <span class="s0">* necessarily the width of the actual texture, since the texture may have</span>
 <span class="s0">* been expanded to raise it to a power of 2.</span>
 <span class="s0">*/ 1 4 this 3 645  </span>
<span class="s0">161 0 0 6 152 515 0 0 202 /**</span>
 <span class="s0">* Returns the height in texels of the source video stream.  This is not</span>
 <span class="s0">* necessarily the height of the actual texture, since the texture may have</span>
 <span class="s0">* been expanded to raise it to a power of 2.</span>
 <span class="s0">*/ 1 4 this 3 645  </span>
<span class="s0">162 0 0 7 153 648 0 0 136 /**</span>
 <span class="s0">* Returns the MovieVideoCursor that is feeding the color channels for the</span>
 <span class="s0">* indicated page, where 0 &lt;= page &lt; get_num_pages().</span>
 <span class="s0">*/ 2 4 this 3 644  4 page 1 515  </span>
<span class="s0">163 0 0 7 154 648 0 0 135 /**</span>
 <span class="s0">* Returns the MovieVideoCursor that is feeding the alpha channel for the</span>
 <span class="s0">* indicated page, where 0 &lt;= page &lt; get_num_pages().</span>
 <span class="s0">*/ 2 4 this 3 644  4 page 1 515  </span>
<span class="s0">164 0 0 4 155 544 0 0 159 /**</span>
 <span class="s0">* Start playing the movie from where it was last paused.  Has no effect if</span>
 <span class="s0">* the movie is not paused, or if the movie's cursor is already at the end.</span>
 <span class="s0">*/ 1 4 this 3 644  </span>
<span class="s0">165 0 0 4 156 544 0 0 145 /**</span>
 <span class="s0">* Stops a currently playing or looping movie right where it is.  The movie's</span>
 <span class="s0">* cursor remains frozen at the point where it was stopped.</span>
 <span class="s0">*/ 1 4 this 3 644  </span>
<span class="s0">166 0 0 4 157 544 0 0 46 /**</span>
 <span class="s0">* Plays the movie from the beginning.</span>
 <span class="s0">*/ 1 4 this 3 644  </span>
<span class="s0">167 0 0 4 158 544 0 0 35 /**</span>
 <span class="s0">* Sets the movie's cursor.</span>
 <span class="s0">*/ 2 4 this 3 644  1 t 1 514  </span>
<span class="s0">168 0 0 6 159 514 0 0 277 /**</span>
 <span class="s0">* Returns the current value of the movie's cursor.  If the movie's loop count</span>
 <span class="s0">* is greater than one, then its length is effectively multiplied for the</span>
 <span class="s0">* purposes of this function.  In other words, the return value will be in the</span>
 <span class="s0">* range 0.0 to (length * loopcount).</span>
 <span class="s0">*/ 1 4 this 3 645  </span>
<span class="s0">169 0 0 4 160 544 0 0 111 /**</span>
 <span class="s0">* If true, sets the movie's loop count to 1 billion.  If false, sets the</span>
 <span class="s0">* movie's loop count to one.</span>
 <span class="s0">*/ 2 4 this 3 644  6 enable 1 516  </span>
<span class="s0">170 0 0 6 161 516 0 0 70 /**</span>
 <span class="s0">* Returns true if the movie's loop count is not equal to one.</span>
 <span class="s0">*/ 1 4 this 3 645  </span>
<span class="s0">171 0 0 4 162 544 0 0 60 /**</span>
 <span class="s0">* Sets the movie's loop count to the desired value.</span>
 <span class="s0">*/ 2 4 this 3 644  5 count 1 515  </span>
<span class="s0">172 0 0 6 163 515 0 0 42 /**</span>
 <span class="s0">* Returns the movie's loop count.</span>
 <span class="s0">*/ 1 4 this 3 645  </span>
<span class="s0">173 0 0 4 164 544 0 0 168 /**</span>
 <span class="s0">* Sets the movie's play-rate.  This is the speed at which the movie's cursor</span>
 <span class="s0">* advances.  The default is to advance 1.0 movie-seconds per real-time</span>
 <span class="s0">* second.</span>
 <span class="s0">*/ 2 4 this 3 644  9 play_rate 1 514  </span>
<span class="s0">174 0 0 6 165 514 0 0 38 /**</span>
 <span class="s0">* Gets the movie's play-rate.</span>
 <span class="s0">*/ 1 4 this 3 645  </span>
<span class="s0">175 0 0 6 166 516 0 0 59 /**</span>
 <span class="s0">* Returns true if the movie's cursor is advancing.</span>
 <span class="s0">*/ 1 4 this 3 645  </span>
<span class="s0">176 0 0 4 167 544 0 0 127 /**</span>
 <span class="s0">* Synchronize this texture to a sound.  Typically, you would load the texture</span>
 <span class="s0">* and the sound from the same AVI file.</span>
 <span class="s0">*/ 2 4 this 3 644  5 sound 1 649  </span>
<span class="s0">177 0 0 4 168 544 0 0 43 /**</span>
 <span class="s0">* Stop synchronizing with a sound.</span>
 <span class="s0">*/ 1 4 this 3 644  </span>
<span class="s0">178 0 0 7 180 587 0 0 0 0 </span>
<span class="s0">179 0 0 7 182 651 417 0 0 0 </span>
<span class="s0">180 0 0 15 182 651 417 0 0 1 6 param0 0 652  </span>
<span class="s0">181 0 0 4 184 544 0 0 0 1 4 this 3 651  </span>
<span class="s0">182 0 0 4 185 544 0 0 475 /**</span>
 <span class="s0">* Starts scanning the hierarchy beginning at the indicated node.  Any</span>
 <span class="s0">* GeomNodes discovered in the hierarchy with multitexture will be added to</span>
 <span class="s0">* internal structures in the MultitexReducer so that a future call to</span>
 <span class="s0">* flatten() will operate on all of these at once.</span>
 <span class="s0">*</span>
 <span class="s0">* This version of this method does not accumulate state from the parents of</span>
 <span class="s0">* the indicated node; thus, only multitexture effects that have been applied</span>
 <span class="s0">* at node and below will be considered.</span>
 <span class="s0">*/ 2 4 this 3 651  4 node 1 616  </span>
<span class="s0">183 0 0 4 185 544 0 0 841 /**</span>
 <span class="s0">* Starts scanning the hierarchy beginning at the indicated node.  Any</span>
 <span class="s0">* GeomNodes discovered in the hierarchy with multitexture will be added to</span>
 <span class="s0">* internal structures in the MultitexReducer so that a future call to</span>
 <span class="s0">* flatten() will operate on all of these at once.</span>
 <span class="s0">*</span>
 <span class="s0">* The second parameter represents the NodePath from which to accumulate the</span>
 <span class="s0">* state that is considered for the multitexture.  Pass an empty NodePath to</span>
 <span class="s0">* accumulate all the state from the root of the graph, or you may specify</span>
 <span class="s0">* some other node here in order to not consider nodes above that as</span>
 <span class="s0">* contributing to the state to be flattened.  This is particularly useful if</span>
 <span class="s0">* you have some texture stage which is applied globally to a scene (for</span>
 <span class="s0">* instance, a caustics effect), which you don't want to be considered for</span>
 <span class="s0">* flattening by the MultitexReducer.</span>
 <span class="s0">*/ 3 4 this 3 651  4 node 1 616  10 state_from 1 616  </span>
<span class="s0">184 0 0 4 185 544 0 0 0 4 4 this 3 651  4 node 1 573  5 state 1 654  9 transform 1 657  </span>
<span class="s0">185 0 0 4 186 544 0 0 0 2 4 this 3 651  5 stage 1 660  </span>
<span class="s0">186 0 0 4 187 544 0 0 0 2 4 this 3 651  8 use_geom 1 516  </span>
<span class="s0">187 0 0 4 188 544 0 0 0 2 4 this 3 651  13 allow_tex_mat 1 516  </span>
<span class="s0">188 0 0 4 189 544 0 0 0 2 4 this 3 651  6 window 1 580  </span>
<span class="s0">189 0 0 23 192 662 428 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 node 1 520  4 prev 5 523  </span>
<span class="s0">190 0 0 7 193 520 0 0 70 /**</span>
 <span class="s0">* Returns the PandaNode whose transform supplies this object.</span>
 <span class="s0">*/ 1 4 this 3 663  </span>
<span class="s0">191 0 0 7 194 523 0 0 120 /**</span>
 <span class="s0">* Returns the VertexTransform object whose matrix will be composed with the</span>
 <span class="s0">* result of this node's transform.</span>
 <span class="s0">*/ 1 4 this 3 663  </span>
<span class="s0">192 0 0 7 202 587 0 0 0 0 </span>
<span class="s0">193 0 0 7 205 665 443 0 287 /**</span>
 <span class="s0">* @brief Constructs a new Terrain Mesh</span>
 <span class="s0">* @details This constructs a new terrain mesh. By default, no transform is set</span>
 <span class="s0">*   on the mesh, causing it to range over the unit box from (0, 0, 0) to</span>
 <span class="s0">*   (1, 1, 1). Usually you want to set a custom transform with NodePath::set_scale()</span>
 <span class="s0">*/ 0 </span>
<span class="s0">194 0 0 4 206 544 0 0 339 /**</span>
 <span class="s0">* @brief Sets the heightfield texture</span>
 <span class="s0">* @details This sets the heightfield texture. It should be 16bit</span>
 <span class="s0">*   single channel, and have a power-of-two resolution greater than 32.</span>
 <span class="s0">*   Common sizes are 2048x2048 or 4096x4096.</span>
 <span class="s0">*</span>
 <span class="s0">*   You should call generate() after setting the heightfield.</span>
 <span class="s0">*</span>
 <span class="s0">* @param filename Heightfield texture</span>
 <span class="s0">*/ 2 4 this 3 665  11 heightfield 1 526  </span>
<span class="s0">195 0 0 7 207 526 0 0 172 /**</span>
 <span class="s0">* @brief Returns the heightfield</span>
 <span class="s0">* @details This returns the terrain heightfield, previously set with</span>
 <span class="s0">*   set_heightfield()</span>
 <span class="s0">*</span>
 <span class="s0">* @return Path to the heightfield</span>
 <span class="s0">*/ 1 4 this 3 666  </span>
<span class="s0">196 0 0 4 210 544 0 0 785 /**</span>
 <span class="s0">* @brief Sets the chunk size</span>
 <span class="s0">* @details This sets the chunk size of the terrain. A chunk is basically the</span>
 <span class="s0">*   smallest unit in LOD. If the chunk size is too small, the terrain will</span>
 <span class="s0">*   perform bad, since there will be way too many chunks. If the chunk size</span>
 <span class="s0">*   is too big, you will not get proper LOD, and might also get bad performance.</span>
 <span class="s0">*</span>
 <span class="s0">*   For terrains of the size 4096x4096 or 8192x8192, a chunk size of 32 seems</span>
 <span class="s0">*   to produce good results. For smaller resolutions, you should try out a</span>
 <span class="s0">*   size of 16 or even 8 for very small terrains.</span>
 <span class="s0">*</span>
 <span class="s0">*   The amount of chunks generated for the last level equals to</span>
 <span class="s0">*   (heightfield_size / chunk_size) ** 2. The chunk size has to be a power</span>
 <span class="s0">*   of two.</span>
 <span class="s0">*</span>
 <span class="s0">* @param chunk_size Size of the chunks, has to be a power of two</span>
 <span class="s0">*/ 2 4 this 3 665  10 chunk_size 1 527  </span>
<span class="s0">197 0 0 6 211 527 0 0 140 /**</span>
 <span class="s0">* @brief Returns the chunk size</span>
 <span class="s0">* @details This returns the chunk size, previously set with set_chunk_size()</span>
 <span class="s0">* @return Chunk size</span>
 <span class="s0">*/ 1 4 this 3 666  </span>
<span class="s0">198 0 0 4 215 544 0 0 618 /**</span>
 <span class="s0">* @brief Sets whether to generate patches</span>
 <span class="s0">* @details If this option is set to true, GeomPatches will be used instead of</span>
 <span class="s0">*   GeomTriangles. This is required when the terrain is used with tesselation</span>
 <span class="s0">*   shaders, since patches are required for tesselation, whereas triangles</span>
 <span class="s0">*   are required for regular rendering.</span>
 <span class="s0">*</span>
 <span class="s0">*   If this option is set to true while not using a tesselation shader, the</span>
 <span class="s0">*   terrain will not get rendered, or even produce errors. The same applies</span>
 <span class="s0">*   when this is option is not set, but the terrain is used with tesselation</span>
 <span class="s0">*   shaders.</span>
 <span class="s0">*</span>
 <span class="s0">* @param generate_patches [description]</span>
 <span class="s0">*/ 2 4 this 3 665  16 generate_patches 1 516  </span>
<span class="s0">199 0 0 6 216 516 0 0 199 /**</span>
 <span class="s0">* @brief Returns whether to generate patches</span>
 <span class="s0">* @details This returns whether patches are generated, previously set with</span>
 <span class="s0">*   set_generate_patches()</span>
 <span class="s0">*</span>
 <span class="s0">* @return Whether to generate patches</span>
 <span class="s0">*/ 1 4 this 3 666  </span>
<span class="s0">200 0 0 4 218 544 0 0 336 /**</span>
 <span class="s0">* @brief Sets whether to enable terrain updates</span>
 <span class="s0">* @details This flag controls whether the terrain should be updated. If this value</span>
 <span class="s0">*   is set to false, no updating of the terrain will happen. This can be useful</span>
 <span class="s0">*   to debug the culling algorithm used by the terrain.</span>
 <span class="s0">*</span>
 <span class="s0">* @param update_enabled Whether to update the terrain</span>
 <span class="s0">*/ 2 4 this 3 665  14 update_enabled 1 516  </span>
<span class="s0">201 0 0 6 219 516 0 0 219 /**</span>
 <span class="s0">* @brief Returns whether the terrain is getting updated</span>
 <span class="s0">* @details This returns whether the terrain is getting updates, previously set with</span>
 <span class="s0">*   set_update_enabled()</span>
 <span class="s0">*</span>
 <span class="s0">* @return Whether to update the terrain</span>
 <span class="s0">*/ 1 4 this 3 666  </span>
<span class="s0">202 0 0 4 221 544 0 0 469 /**</span>
 <span class="s0">* @brief Sets the desired triangle width</span>
 <span class="s0">* @details This sets the desired width a triangle should have in pixels.</span>
 <span class="s0">*   A value of 10.0 for example will make the terrain tesselate everything</span>
 <span class="s0">*   in a way that each triangle edge roughly is 10 pixels wide.</span>
 <span class="s0">*   Of course this will not always accurately match, however you can use this</span>
 <span class="s0">*   setting to control the LOD algorithm of the terrain.</span>
 <span class="s0">*</span>
 <span class="s0">* @param target_triangle_width Desired triangle width in pixels</span>
 <span class="s0">*/ 2 4 this 3 665  21 target_triangle_width 1 529  </span>
<span class="s0">203 0 0 6 222 529 0 0 211 /**</span>
 <span class="s0">* @brief Returns the target triangle width</span>
 <span class="s0">* @details This returns the target triangle width, previously set with</span>
 <span class="s0">*   ShaderTerrainMesh::set_target_triangle_width()</span>
 <span class="s0">*</span>
 <span class="s0">* @return Target triangle width</span>
 <span class="s0">*/ 1 4 this 3 666  </span>
<span class="s0">204 0 0 7 226 669 0 0 377 /**</span>
 <span class="s0">* @brief Transforms a texture coordinate to world space</span>
 <span class="s0">* @details This transforms a texture coordinatefrom uv-space (0 to 1) to world</span>
 <span class="s0">*   space. This takes the terrains transform into account, and also samples the</span>
 <span class="s0">*   heightmap. This method should be called after generate().</span>
 <span class="s0">*</span>
 <span class="s0">* @param coord Coordinate in uv-space from 0, 0 to 1, 1</span>
 <span class="s0">* @return World-Space point</span>
 <span class="s0">*/ 2 4 this 3 666  5 coord 1 545  </span>
<span class="s0">205 0 0 7 226 669 0 0 57 /**</span>
 <span class="s0">* @see ShaderTerrainMesh::uv_to_world(LTexCoord)</span>
 <span class="s0">*/ 3 4 this 3 666  1 u 1 529  1 v 1 529  </span>
<span class="s0">206 0 0 6 227 516 0 0 442 /**</span>
 <span class="s0">* @brief Generates the terrain mesh</span>
 <span class="s0">* @details This generates the terrain mesh, initializing all chunks of the</span>
 <span class="s0">*   internal used quadtree. At this point, a heightfield and a chunk size should</span>
 <span class="s0">*   have been set, otherwise an error is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">*   If anything goes wrong, like a missing heightfield, then an error is printed</span>
 <span class="s0">*   and false is returned.</span>
 <span class="s0">*</span>
 <span class="s0">* @return true if the terrain was initialized, false if an error occured</span>
 <span class="s0">*/ 1 4 this 3 665  </span>
<span class="s0">207 0 0 7 228 587 0 0 0 0 </span>
<span class="s0">208 0 0 15 231 672 0 0 0 1 6 param0 0 670  </span>
<span class="s0">209 0 0 7 231 672 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 name 1 543  4 node 1 573  </span>
<span class="s0">210 0 0 4 232 544 0 0 112 /**</span>
 <span class="s0">* Sets up the frame rate meter to create a DisplayRegion to render itself</span>
 <span class="s0">* into the indicated window.</span>
 <span class="s0">*/ 2 4 this 3 672  6 window 1 580  </span>
<span class="s0">211 0 0 4 233 544 0 0 66 /**</span>
 <span class="s0">* Undoes the effect of a previous call to setup_window().</span>
 <span class="s0">*/ 1 4 this 3 672  </span>
<span class="s0">212 0 0 7 234 580 0 0 122 /**</span>
 <span class="s0">* Returns the GraphicsOutput that was passed to setup_window(), or NULL if</span>
 <span class="s0">* setup_window() has not been called.</span>
 <span class="s0">*/ 1 4 this 3 670  </span>
<span class="s0">213 0 0 7 235 583 0 0 168 /**</span>
 <span class="s0">* Returns the DisplayRegion that the meter has created to render itself into</span>
 <span class="s0">* the window to setup_window(), or NULL if setup_window() has not been</span>
 <span class="s0">* called.</span>
 <span class="s0">*/ 1 4 this 3 670  </span>
<span class="s0">214 0 0 4 236 544 0 0 244 /**</span>
 <span class="s0">* Specifies the number of seconds that should elapse between updates to the</span>
 <span class="s0">* meter.  This should be reasonably slow (e.g.  0.5 to 2.0) so that the</span>
 <span class="s0">* calculation of the scene graph analysis does not itself dominate the frame</span>
 <span class="s0">* rate.</span>
 <span class="s0">*/ 2 4 this 3 672  15 update_interval 1 514  </span>
<span class="s0">215 0 0 6 237 514 0 0 106 /**</span>
 <span class="s0">* Returns the number of seconds that will elapse between updates to the frame</span>
 <span class="s0">* rate indication.</span>
 <span class="s0">*/ 1 4 this 3 670  </span>
<span class="s0">216 0 0 4 238 544 0 0 40 /**</span>
 <span class="s0">* Sets the node to be analyzed.</span>
 <span class="s0">*/ 2 4 this 3 672  4 node 1 573  </span>
<span class="s0">217 0 0 7 239 573 0 0 43 /**</span>
 <span class="s0">* Returns the node to be analyzed.</span>
 <span class="s0">*/ 1 4 this 3 670  </span>
<span class="s0">218 0 0 4 240 544 0 0 205 /**</span>
 <span class="s0">* You can call this to explicitly force the SceneGraphAnalyzerMeter to update</span>
 <span class="s0">* itself with the latest scene graph analysis information.  Normally, it is</span>
 <span class="s0">* not necessary to call this explicitly.</span>
 <span class="s0">*/ 1 4 this 3 672  </span>
<span class="s0">219 0 0 7 241 587 0 0 0 0 </span>
<span class="s0">220 0 0 7 243 673 459 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 543  </span>
<span class="s0">221 0 0 4 244 544 0 0 879 /**</span>
 <span class="s0">* Walks through the entire subgraph of nodes rooted at this node, accumulates</span>
 <span class="s0">* all of the RenderAttribs and Geoms below this node, flattening them into</span>
 <span class="s0">* just one Geom (or as few as possible, if there are multiple different</span>
 <span class="s0">* states).</span>
 <span class="s0">*</span>
 <span class="s0">* Nodes that have transforms on them at the time of collect(), or any</span>
 <span class="s0">* ModelNodes with the preserve_transform flag, will be identified as &quot;moving&quot;</span>
 <span class="s0">* nodes, and their transforms will be monitored as they change in future</span>
 <span class="s0">* frames and each new transform directly applied to the vertices.</span>
 <span class="s0">*</span>
 <span class="s0">* This call must be made after adding any nodes to or removing any nodes from</span>
 <span class="s0">* the subgraph rooted at this node.  It should not be made too often, as it</span>
 <span class="s0">* is a relatively expensive call.  If you need to hide children of this node,</span>
 <span class="s0">* consider scaling them to zero (or very near zero), or moving them behind</span>
 <span class="s0">* the camera, instead.</span>
 <span class="s0">*/ 1 4 this 3 673  </span>
<span class="s0">222 0 0 7 245 614 0 0 319 /**</span>
 <span class="s0">* Returns a special NodePath that represents the internal node of this</span>
 <span class="s0">* object.  This is the node that is actually sent to the graphics card for</span>
 <span class="s0">* rendering; it contains the collection of the children of this node into as</span>
 <span class="s0">* few Geoms as possible.</span>
 <span class="s0">*</span>
 <span class="s0">* This node is filled up by the last call to collect().</span>
 <span class="s0">*/ 1 4 this 3 673  </span>
<span class="s0">223 0 0 7 248 587 0 0 0 0 </span>
<span class="s0">224 0 0 7 257 674 472 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 host 1 580  </span>
<span class="s0">225 0 0 4 258 544 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 674  11 scene_setup 1 675  3 gsg 1 677  20 dr_incomplete_render 1 516  </span>
<span class="s0">226 0 0 4 259 544 0 0 141 /**</span>
 <span class="s0">* Should be called when the traverser has finished traversing its scene, this</span>
 <span class="s0">* gives it a chance to do any necessary finalization.</span>
 <span class="s0">*/ 1 4 this 3 674  </span>
<span class="s0">227 0 0 7 260 580 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 679  </span>
<span class="s0">228 0 0 7 261 526 0 0 96 /**</span>
 <span class="s0">* Returns a Texture that can be used to visualize the efforts of the</span>
 <span class="s0">* occlusion cull.</span>
 <span class="s0">*/ 1 4 this 3 674  </span>
<span class="s0">229 0 0 4 262 544 0 0 245 /**</span>
 <span class="s0">* Specifies the DrawMask that should be set on occlusion polygons for this</span>
 <span class="s0">* scene.  This identifies the polygons that are to be treated as occluders.</span>
 <span class="s0">* Polygons that do not have this draw mask set will not be considered</span>
 <span class="s0">* occluders.</span>
 <span class="s0">*/ 2 4 this 3 674  14 occlusion_mask 1 681  </span>
<span class="s0">230 0 0 6 263 681 0 0 82 /**</span>
 <span class="s0">* Returns the DrawMask for occlusion polygons.  See set_occlusion_mask().</span>
 <span class="s0">*/ 1 4 this 3 679  </span>
<span class="s0">231 0 0 7 264 587 0 0 0 0 </span>
<span class="s0">232 0 0 7 252 686 0 0 0 1 4 this 3 674  </span>
<span class="s0">233 0 0 6 255 687 0 0 0 1 4 this 3 674  </span>
<span class="s0">234 0 0 7 267 690 474 0 256 /**</span>
 <span class="s0">* The PfmVizzer constructor receives a reference to a PfmFile which it will</span>
 <span class="s0">* operate on.  It does not keep ownership of this reference; it is your</span>
 <span class="s0">* responsibility to ensure the PfmFile does not destruct during the lifetime</span>
 <span class="s0">* of the PfmVizzer.</span>
 <span class="s0">*/ 1 3 pfm 1 688  </span>
<span class="s0">235 0 0 15 267 690 474 0 0 1 6 param0 0 691  </span>
<span class="s0">236 0 0 6 269 688 0 0 78 /**</span>
 <span class="s0">* Returns the reference to the PfmFile manipulated by this PfmVizzer.</span>
 <span class="s0">*/ 1 4 this 3 690  </span>
<span class="s0">237 0 0 6 269 693 0 0 78 /**</span>
 <span class="s0">* Returns the reference to the PfmFile manipulated by this PfmVizzer.</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">238 0 0 4 270 544 0 0 335 /**</span>
 <span class="s0">* Adjusts each (x, y, z) point of the Pfm file by projecting it through the</span>
 <span class="s0">* indicated lens, converting each point to a (u, v, w) texture coordinate.</span>
 <span class="s0">* The resulting file can be generated to a mesh (with set_vis_inverse(true)</span>
 <span class="s0">* and generate_vis_mesh()) that will apply the lens distortion to an</span>
 <span class="s0">* arbitrary texture image.</span>
 <span class="s0">*/ 3 4 this 3 690  4 lens 1 695  10 undist_lut 5 693  </span>
<span class="s0">239 0 0 4 271 544 0 0 397 /**</span>
 <span class="s0">* Converts each (u, v, depth) point of the Pfm file to an (x, y, z) point, by</span>
 <span class="s0">* reversing project().  If the original file is only a 1-d file, assumes that</span>
 <span class="s0">* it is a depth map with implicit (u, v) coordinates.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is only valid for a linear lens (e.g.  a PerspectiveLens or</span>
 <span class="s0">* OrthographicLens).  Non-linear lenses don't necessarily compute a sensible</span>
 <span class="s0">* depth coordinate.</span>
 <span class="s0">*/ 2 4 this 3 690  4 lens 1 695  </span>
<span class="s0">240 0 0 4 272 544 0 0 435 /**</span>
 <span class="s0">* Sets the vis_inverse flag.  When this flag is true, vis meshes and point</span>
 <span class="s0">* clouds are generated with the 3-d depth value in the texture coordinates,</span>
 <span class="s0">* and the 2-d index value in the vertex position.  When it is false, meshes</span>
 <span class="s0">* are generated normally, with the 3-d depth value in the vertex position and</span>
 <span class="s0">* the 2-d index value in the texture coordinates.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used in lieu of the lower-level add_vis_column().</span>
 <span class="s0">*/ 2 4 this 3 690  11 vis_inverse 1 516  </span>
<span class="s0">241 0 0 6 273 516 0 0 64 /**</span>
 <span class="s0">* Returns the vis_inverse flag.  See set_vis_inverse().</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">242 0 0 4 274 544 0 0 473 /**</span>
 <span class="s0">* If the flat_texcoord_name is specified, it is the name of an additional</span>
 <span class="s0">* vertex column that will be created for the &quot;flat&quot; texture coordinates, i.e.</span>
 <span class="s0">* the original 0..1 values that correspond to the 2-D index position of each</span>
 <span class="s0">* point in the original pfm file.</span>
 <span class="s0">*</span>
 <span class="s0">* These are the same values that will be assigned to the default texture</span>
 <span class="s0">* coordinates if the vis_inverse flag is *not* true.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used in lieu of the lower-level add_vis_column().</span>
 <span class="s0">*/ 2 4 this 3 690  18 flat_texcoord_name 1 698  </span>
<span class="s0">243 0 0 4 275 544 0 0 177 /**</span>
 <span class="s0">* Resets the flat_texcoord_name to empty, so that additional texture</span>
 <span class="s0">* coordinates are not created.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used in lieu of the lower-level add_vis_column().</span>
 <span class="s0">*/ 1 4 this 3 690  </span>
<span class="s0">244 0 0 7 276 698 0 0 73 /**</span>
 <span class="s0">* Returns the flat_texcoord_name.  See set_flat_texcoord_name().</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">245 0 0 4 277 544 0 0 291 /**</span>
 <span class="s0">* Sets the vis_2d flag.  When this flag is true, only the first two (x, y)</span>
 <span class="s0">* value of each depth point is considered meaningful; the z component is</span>
 <span class="s0">* ignored.  This is only relevant for generating visualizations.</span>
 <span class="s0">*</span>
 <span class="s0">* This may be used in lieu of the lower-level add_vis_column().</span>
 <span class="s0">*/ 2 4 this 3 690  6 vis_2d 1 516  </span>
<span class="s0">246 0 0 6 278 516 0 0 54 /**</span>
 <span class="s0">* Returns the vis_2d flag.  See set_vis_2d().</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">247 0 0 4 279 544 0 0 234 /**</span>
 <span class="s0">* Sets the keep_beyond_lens flag.  When this flag is true, points that fall</span>
 <span class="s0">* outside of the normal lens range in project() or in add_vis_column() will</span>
 <span class="s0">* be retained anyway; when it is false, these points will be discarded.</span>
 <span class="s0">*/ 2 4 this 3 690  16 keep_beyond_lens 1 516  </span>
<span class="s0">248 0 0 6 280 516 0 0 74 /**</span>
 <span class="s0">* Returns the keep_beyond_lens flag.  See set_keep_beyond_lens().</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">249 0 0 4 281 544 0 0 457 /**</span>
 <span class="s0">* Specifies a blending map--a grayscale image--that will be applied to the</span>
 <span class="s0">* vertex color during generate_vis_mesh() and generate_vis_points().  The</span>
 <span class="s0">* image size must exactly match the mesh size of the PfmVizzer.</span>
 <span class="s0">*</span>
 <span class="s0">* Ownership of the pointer is not kept by the PfmVizzer; it is your</span>
 <span class="s0">* responsibility to ensure it does not destruct during the lifetime of the</span>
 <span class="s0">* PfmVizzer (or at least not before your subsequent call to</span>
 <span class="s0">* generate_vis_mesh()).</span>
 <span class="s0">*/ 2 4 this 3 690  9 vis_blend 1 596  </span>
<span class="s0">250 0 0 4 282 544 0 0 75 /**</span>
 <span class="s0">* Removes the blending map set by a prior call to set_vis_blend().</span>
 <span class="s0">*/ 1 4 this 3 690  </span>
<span class="s0">251 0 0 6 283 596 0 0 133 /**</span>
 <span class="s0">* Returns the blending map set by the most recent call to set_vis_blend(), or</span>
 <span class="s0">* NULL if there is no blending map in effect.</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">252 0 0 4 284 544 0 0 429 /**</span>
 <span class="s0">* Assigns an auxiliary PfmFile to this PfmVizzer.  This file will be queried</span>
 <span class="s0">* by column types CT_aux_vertex1/2/3, but has no other meaning to the vizzer.</span>
 <span class="s0">* This size of this PfmFile should exactly match the base PfmFile.  No</span>
 <span class="s0">* reference count is held and no copy is made; the caller is responsible for</span>
 <span class="s0">* ensuring that the auxiliary PfmFile will persist throughout the lifetime of</span>
 <span class="s0">* the PfmVizzer it is assigned to.</span>
 <span class="s0">*/ 2 4 this 3 690  3 pfm 1 693  </span>
<span class="s0">253 0 0 4 285 544 0 0 61 /**</span>
 <span class="s0">* Removes the auxiliary PfmFile from this PfmVizzer.</span>
 <span class="s0">*/ 1 4 this 3 690  </span>
<span class="s0">254 0 0 6 286 693 0 0 181 /**</span>
 <span class="s0">* Returns the reference to the auxiliary PfmFile queried by this PfmVizzer.</span>
 <span class="s0">* This contains the values that will be reflected in CT_aux_vertex3 etc.  See</span>
 <span class="s0">* set_aux_pfm().</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">255 0 0 4 288 544 0 0 124 /**</span>
 <span class="s0">* Removes all of the previously-added vis columns in preparation for building</span>
 <span class="s0">* a new list.  See add_vis_column().</span>
 <span class="s0">*/ 1 4 this 3 690  </span>
<span class="s0">256 0 0 4 289 544 0 0 723 /**</span>
 <span class="s0">* Adds a new vis column specification to the list of vertex data columns that</span>
 <span class="s0">* will be generated at the next call to generate_vis_points() or</span>
 <span class="s0">* generate_vis_mesh().  This advanced interface supercedes the higher-level</span>
 <span class="s0">* set_vis_inverse(), set_flat_texcoord_name(), and set_vis_2d().</span>
 <span class="s0">*</span>
 <span class="s0">* If you use this advanced interface, you must specify explicitly the</span>
 <span class="s0">* complete list of data columns to be created in the resulting</span>
 <span class="s0">* GeomVertexData, by calling add_vis_column() each time.  For each column,</span>
 <span class="s0">* you specify the source of the column in the PFMFile, the target column and</span>
 <span class="s0">* name in the GeomVertexData, and an optional transform matrix and/or lens to</span>
 <span class="s0">* transform and project the point before generating it.</span>
 <span class="s0">*/ 7 4 this 3 690  6 source 1 538  6 target 1 538  4 name 1 698  9 transform 5 657  4 lens 5 695  10 undist_lut 5 693  </span>
<span class="s0">257 0 0 7 290 614 0 0 181 /**</span>
 <span class="s0">* Creates a point cloud with the points of the pfm as 3-d coordinates in</span>
 <span class="s0">* space, and texture coordinates ranging from 0 .. 1 based on the position</span>
 <span class="s0">* within the pfm grid.</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">258 0 0 7 292 614 0 0 183 /**</span>
 <span class="s0">* Creates a triangle mesh with the points of the pfm as 3-d coordinates in</span>
 <span class="s0">* space, and texture coordinates ranging from 0 .. 1 based on the position</span>
 <span class="s0">* within the pfm grid.</span>
 <span class="s0">*/ 2 4 this 3 691  4 face 5 539  </span>
<span class="s0">259 0 0 6 293 514 0 0 206 /**</span>
 <span class="s0">* Computes the maximum amount of shift, in pixels either left or right, of</span>
 <span class="s0">* any pixel in the distortion map.  This can be passed to</span>
 <span class="s0">* make_displacement(); see that function for more information.</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">260 0 0 6 294 514 0 0 203 /**</span>
 <span class="s0">* Computes the maximum amount of shift, in pixels either up or down, of any</span>
 <span class="s0">* pixel in the distortion map.  This can be passed to make_displacement();</span>
 <span class="s0">* see that function for more information.</span>
 <span class="s0">*/ 1 4 this 3 691  </span>
<span class="s0">261 0 0 4 295 544 0 0 959 /**</span>
 <span class="s0">* Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V</span>
 <span class="s0">* in the first two components and the third component unused, this computes</span>
 <span class="s0">* an AfterEffects-style displacement map that represents the same distortion.</span>
 <span class="s0">* The indicated PNMImage will be filled in with a displacement map image,</span>
 <span class="s0">* with horizontal shift in the red channel and vertical shift in the green</span>
 <span class="s0">* channel, where a fully bright (or fully black) pixel indicates a shift of</span>
 <span class="s0">* max_u or max_v pixels.</span>
 <span class="s0">*</span>
 <span class="s0">* Use calc_max_u_displacement() and calc_max_v_displacement() to compute</span>
 <span class="s0">* suitable values for max_u and max_v.</span>
 <span class="s0">*</span>
 <span class="s0">* This generates an integer 16-bit displacement image.  It is a good idea,</span>
 <span class="s0">* though not necessarily essential, to check &quot;Preserve RGB&quot; in the interpret</span>
 <span class="s0">* footage section for each displacement image.  Set for_32bit true if this is</span>
 <span class="s0">* meant to be used in a 32-bit project file, and false if it is meant to be</span>
 <span class="s0">* used in a 16-bit project file.</span>
 <span class="s0">*/ 5 4 this 3 691  6 result 1 589  5 max_u 1 514  5 max_v 1 514  9 for_32bit 1 516  </span>
<span class="s0">262 0 0 4 295 544 0 0 928 /**</span>
 <span class="s0">* Assuming the underlying PfmFile is a 2-d distortion mesh, with the U and V</span>
 <span class="s0">* in the first two components and the third component unused, this computes</span>
 <span class="s0">* an AfterEffects-style displacement map that represents the same distortion.</span>
 <span class="s0">* The indicated PNMImage will be filled in with a displacement map image,</span>
 <span class="s0">* with horizontal shift in the red channel and vertical shift in the green</span>
 <span class="s0">* channel, where a fully bright (or fully black) pixel indicates a shift of</span>
 <span class="s0">* max_u or max_v pixels.</span>
 <span class="s0">*</span>
 <span class="s0">* Use calc_max_u_displacement() and calc_max_v_displacement() to compute</span>
 <span class="s0">* suitable values for max_u and max_v.</span>
 <span class="s0">*</span>
 <span class="s0">* This generates a 32-bit floating-point displacement image.  It is essential</span>
 <span class="s0">* to check &quot;Preserve RGB&quot; in the interpret footage section for each</span>
 <span class="s0">* displacement image.  Set for_32bit true if this is meant to be used in a</span>
 <span class="s0">* 32-bit project file, and false if it is meant to be used in a 16-bit</span>
 <span class="s0">* project file.</span>
 <span class="s0">*/ 5 4 this 3 691  6 result 1 688  5 max_u 1 514  5 max_v 1 514  9 for_32bit 1 516  </span>
<span class="s0">200</span>
<span class="s0">500 9 CardMaker 0 26625 9 CardMaker 9 CardMaker 0 0 0 1 263 264 0 12 265 266 267 268 269 270 271 272 273 274 275 276 0 0 1 0 501 0 0 0 0 149</span>
<span class="s0">/**</span>
 <span class="s0">* This class generates 2-d &quot;cards&quot;, that is, rectangular polygons,</span>
 <span class="s0">* particularly useful for showing textures etc.  in the 2-d scene graph.</span>
 <span class="s0">*/</span>

<span class="s0">501 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">502 12 FisheyeMaker 0 26625 12 FisheyeMaker 12 FisheyeMaker 0 0 0 1 277 278 0 6 279 280 281 282 283 284 0 0 1 0 501 0 0 0 0 448</span>
<span class="s0">/**</span>
 <span class="s0">* This class is similar to CardMaker, but instead of generating ordinary</span>
 <span class="s0">* cards, it generates a circular rose that represents the projection of a 3-D</span>
 <span class="s0">* scene through a fisheye lens.  The texture coordinates of the rose are</span>
 <span class="s0">* defined so that each 2-D vertex has a 3-D UVW that reflects the</span>
 <span class="s0">* corresponding position in 3-D space of that particular vertex.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is particularly suited for converting cube maps to sphere maps.</span>
 <span class="s0">*/</span>

<span class="s0">503 14 FrameRateMeter 0 75777 14 FrameRateMeter 14 FrameRateMeter 0 0 0 1 285 0 0 12 286 287 288 289 290 291 292 293 294 295 296 297 0 0 1 0 504 0 0 0 0 393</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special TextNode that automatically updates itself with the</span>
 <span class="s0">* current frame rate.  It can be placed anywhere in the world where you'd</span>
 <span class="s0">* like to see the frame rate.</span>
 <span class="s0">*</span>
 <span class="s0">* It also has a special mode in which it may be attached directly to a</span>
 <span class="s0">* channel or window.  If this is done, it creates a DisplayRegion for itself</span>
 <span class="s0">* and renders itself in the upper-right-hand corner.</span>
 <span class="s0">*/</span>

<span class="s0">504 8 TextNode 0 2048 8 TextNode 8 TextNode 0 0 0 0 0 0 0 0 0 0 0 0 917</span>
<span class="s0">/**</span>
 <span class="s0">* The primary interface to this module.  This class does basic text assembly;</span>
 <span class="s0">* given a string of text and a TextFont object, it creates a piece of</span>
 <span class="s0">* geometry that may be placed in the 3-d or 2-d world to represent the</span>
 <span class="s0">* indicated text.</span>
 <span class="s0">*</span>
 <span class="s0">* The TextNode may be used in one of two ways.  Naively, it may simply be</span>
 <span class="s0">* parented directly into the scene graph and rendered as if it were a</span>
 <span class="s0">* GeomNode; in this mode, the actual polygon geometry that renders the text</span>
 <span class="s0">* is not directly visible or accessible, but remains hidden within the</span>
 <span class="s0">* TextNode.</span>
 <span class="s0">*</span>
 <span class="s0">* The second way TextNode may be used is as a text generator.  To use it in</span>
 <span class="s0">* this way, do not parent the TextNode to the scene graph; instead, set the</span>
 <span class="s0">* properties of the text and call generate() to return an ordinary node,</span>
 <span class="s0">* containing ordinary geometry, which you may use however you like.  Each</span>
 <span class="s0">* time you call generate() a new node is returned.</span>
 <span class="s0">*/</span>

<span class="s0">505 13 GeoMipTerrain 0 75777 13 GeoMipTerrain 13 GeoMipTerrain 0 0 0 1 298 0 0 36 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 0 0 1 0 506 0 0 0 1 507 421</span>
<span class="s0">/**</span>
 <span class="s0">* GeoMipTerrain, meaning Panda3D GeoMipMapping, can convert a heightfield</span>
 <span class="s0">* image into a 3D terrain, consisting of several GeomNodes.  It uses the</span>
 <span class="s0">* GeoMipMapping algorithm, or Geometrical MipMapping, based on the LOD (Level</span>
 <span class="s0">* of Detail) algorithm.  For more information about the GeoMipMapping</span>
 <span class="s0">* algoritm, see this paper, written by Willem H. de Boer:</span>
 <span class="s0">* https://flipcode.com/articles/article_geomipmaps.pdf</span>
 <span class="s0">*/</span>

<span class="s0">506 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">507 15 AutoFlattenMode 0 794624 30 GeoMipTerrain::AutoFlattenMode 30 GeoMipTerrain::AutoFlattenMode 505 0 0 0 0 0 0 0 0 0 4 7 AFM_off 22 GeoMipTerrain::AFM_off 42</span>
<span class="s0">// FM_off: don't ever flatten the terrain.</span>
<span class="s0">0 9 AFM_light 24 GeoMipTerrain::AFM_light 58</span>
<span class="s0">// FM_light: the terrain is flattened using flatten_light.</span>
<span class="s0">1 10 AFM_medium 25 GeoMipTerrain::AFM_medium 60</span>
<span class="s0">// FM_medium: the terrain is flattened using flatten_medium.</span>
<span class="s0">2 10 AFM_strong 25 GeoMipTerrain::AFM_strong 60</span>
<span class="s0">// FM_strong: the terrain is flattened using flatten_strong.</span>
<span class="s0">3 0 108</span>
<span class="s0">// The flatten mode specifies whether the terrain nodes are flattened</span>
<span class="s0">// together after each terrain update.</span>

<span class="s0">508 21 HeightfieldTesselator 0 26625 21 HeightfieldTesselator 21 HeightfieldTesselator 0 0 0 1 335 336 0 10 337 338 339 340 341 342 343 344 345 346 0 0 1 0 501 0 0 0 0 0</span>

<span class="s0">509 8 LineSegs 0 26625 8 LineSegs 8 LineSegs 0 0 0 1 347 348 0 13 349 350 351 352 353 354 355 356 357 358 359 360 361 2 716 717 0 1 0 501 0 0 0 0 264</span>
<span class="s0">/**</span>
 <span class="s0">* Encapsulates creation of a series of connected or disconnected line</span>
 <span class="s0">* segments or points, for drawing paths or rays.  This class doesn't attempt</span>
 <span class="s0">* to be the smartest it could possibly be; it's intended primarily as a</span>
 <span class="s0">* visualization and editing tool.</span>
 <span class="s0">*/</span>

<span class="s0">510 10 MeshDrawer 0 75777 10 MeshDrawer 10 MeshDrawer 0 0 0 1 362 0 0 18 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 0 0 1 0 506 0 0 0 0 642</span>
<span class="s0">/**</span>
 <span class="s0">* Mesh drawer creates a single geom object that can be shaped with different</span>
 <span class="s0">* draw commands.  This is an efficient way to render bunch of billboards,</span>
 <span class="s0">* particles, fast changing triangles.  Its implemented by recycling same geom</span>
 <span class="s0">* over and over again.  Max budget specifies how many triangles are allowed.</span>
 <span class="s0">* Some uses of this class can be : particle system, radar icons, health bars,</span>
 <span class="s0">* 2d icons, 2d ui, bullets, missile trails.  Any that can be drawn with</span>
 <span class="s0">* triangles can be drawn with this class.  At the low level this uses the</span>
 <span class="s0">* GeomVertexRewriter's.  The internal geom consists of vertex, normal, uv and</span>
 <span class="s0">* color channels.</span>
 <span class="s0">*/</span>

<span class="s0">511 12 MeshDrawer2D 0 75777 12 MeshDrawer2D 12 MeshDrawer2D 0 0 0 1 381 0 0 13 382 383 384 385 386 387 388 389 390 391 392 393 394 0 0 1 0 506 0 0 0 0 160</span>
<span class="s0">/**</span>
 <span class="s0">* This class allows the drawing of 2D objects - mainly based on quads and</span>
 <span class="s0">* rectangles.  It allows clipping and several high level UI theme functions.</span>
 <span class="s0">*/</span>

<span class="s0">512 12 MovieTexture 0 75777 12 MovieTexture 12 MovieTexture 0 0 0 1 395 0 8 700 701 702 703 704 705 706 707 20 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 0 0 1 0 513 0 0 0 0 91</span>
<span class="s0">/**</span>
 <span class="s0">* A texture that fetches video frames from an underlying object of class</span>
 <span class="s0">* Movie.</span>
 <span class="s0">*/</span>

<span class="s0">513 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a texture object, which is typically a single 2-d image but may</span>
 <span class="s0">* also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube</span>
 <span class="s0">* map texture.</span>
 <span class="s0">*</span>
 <span class="s0">* A texture's image data might be stored in system RAM (see get_ram_image())</span>
 <span class="s0">* or its image may be represented in texture memory on one or more</span>
 <span class="s0">* GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern</span>
 <span class="s0">* is that a texture is loaded from an image file on disk, which copies its</span>
 <span class="s0">* image data into system RAM; then the first time the texture is rendered its</span>
 <span class="s0">* image data is copied to texture memory (actually, to the graphics API), and</span>
 <span class="s0">* the system RAM image is automatically freed.</span>
 <span class="s0">*/</span>

<span class="s0">514 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">515 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">516 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">517 15 MultitexReducer 0 26625 15 MultitexReducer 15 MultitexReducer 0 0 0 1 416 417 0 6 418 419 420 421 422 423 0 0 0 0 0 623</span>
<span class="s0">/**</span>
 <span class="s0">* This object presents an interface for generating new texture images that</span>
 <span class="s0">* represent the combined images from one or more individual textures,</span>
 <span class="s0">* reproducing certain kinds of multitexture effects without depending on</span>
 <span class="s0">* multitexture support in the hardware.</span>
 <span class="s0">*</span>
 <span class="s0">* This also flattens out texture matrices and removes extra texture</span>
 <span class="s0">* coordinates from the Geoms.  It is thus not a complete substitute for true</span>
 <span class="s0">* multitexturing, because it does not lend itself well to dynamic animation</span>
 <span class="s0">* of the textures once they have been flattened.  It is, however, useful for</span>
 <span class="s0">* &quot;baking in&quot; a particular multitexture effect.</span>
 <span class="s0">*/</span>

<span class="s0">518 19 NodeVertexTransform 0 141313 19 NodeVertexTransform 19 NodeVertexTransform 0 0 0 1 424 428 2 708 709 3 425 426 427 0 0 1 0 519 0 0 0 0 265</span>
<span class="s0">/**</span>
 <span class="s0">* This VertexTransform gets its matrix from the Transform stored on a node.</span>
 <span class="s0">* It can also compose its node's transform with another VertexTransform,</span>
 <span class="s0">* allowing you to build up a chain of NodeVertexTransforms that represent a</span>
 <span class="s0">* list of composed matrices.</span>
 <span class="s0">*/</span>

<span class="s0">519 15 VertexTransform 0 2048 15 VertexTransform 15 VertexTransform 0 0 0 0 0 0 0 0 0 0 0 0 305</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract base class that holds a pointer to some transform,</span>
 <span class="s0">* computed in some arbitrary way, that is to be applied to vertices during</span>
 <span class="s0">* rendering.  This is used to implement soft-skinned and animated vertices.</span>
 <span class="s0">* Derived classes will define how the transform is actually computed.</span>
 <span class="s0">*/</span>

<span class="s0">520 17 PandaNode const * 0 8576 17 PandaNode const * 17 PandaNode const * 0 0 521 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">521 15 PandaNode const 0 8832 15 PandaNode const 15 PandaNode const 0 0 522 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">522 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A basic node of the scene graph or data graph.  This is the base class of</span>
 <span class="s0">* all specialized nodes, and also serves as a generic node with no special</span>
 <span class="s0">* properties.</span>
 <span class="s0">*/</span>

<span class="s0">523 23 VertexTransform const * 0 8576 23 VertexTransform const * 23 VertexTransform const * 0 0 524 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">524 21 VertexTransform const 0 8832 21 VertexTransform const 21 VertexTransform const 0 0 519 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">525 17 ShaderTerrainMesh 0 141313 17 ShaderTerrainMesh 17 ShaderTerrainMesh 0 0 0 1 429 443 5 710 711 712 713 714 13 430 431 432 433 434 435 436 437 438 439 440 441 442 0 0 1 0 522 0 0 0 0 813</span>
<span class="s0">/**</span>
 <span class="s0">* @brief Terrain Renderer class utilizing the GPU</span>
 <span class="s0">* @details This class provides functionality to render heightfields of large</span>
 <span class="s0">*   sizes utilizing the GPU. Internally a quadtree is used to generate the LODs.</span>
 <span class="s0">*   The final terrain is then rendered using instancing on the GPU. This makes</span>
 <span class="s0">*   it possible to use very large heightfields (8192+) with very reasonable</span>
 <span class="s0">*   performance. The terrain provides options to control the LOD using a</span>
 <span class="s0">*   target triangle width, see ShaderTerrainMesh::set_target_triangle_width().</span>
 <span class="s0">*</span>
 <span class="s0">*   Because the Terrain is rendered entirely on the GPU, it needs a special</span>
 <span class="s0">*   vertex shader. There is a default vertex shader available, which you can</span>
 <span class="s0">*   use in your own shaders. IMPORTANT: If you don't set an appropriate shader</span>
 <span class="s0">*   on the terrain, nothing will be visible.</span>
 <span class="s0">*/</span>

<span class="s0">526 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 513 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">527 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 528 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">528 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">529 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 530 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">530 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">531 23 SceneGraphAnalyzerMeter 0 75777 23 SceneGraphAnalyzerMeter 23 SceneGraphAnalyzerMeter 0 0 0 1 444 0 0 10 445 446 447 448 449 450 451 452 453 454 0 0 1 0 504 0 0 0 0 432</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special TextNode that automatically updates itself with output</span>
 <span class="s0">* from a SceneGraphAnalyzer instance.  It can be placed anywhere in the world</span>
 <span class="s0">* where you'd like to see the output from SceneGraphAnalyzer.</span>
 <span class="s0">*</span>
 <span class="s0">* It also has a special mode in which it may be attached directly to a</span>
 <span class="s0">* channel or window.  If this is done, it creates a DisplayRegion for itself</span>
 <span class="s0">* and renders itself in the upper-right-hand corner.</span>
 <span class="s0">*/</span>

<span class="s0">532 17 RigidBodyCombiner 0 141313 17 RigidBodyCombiner 17 RigidBodyCombiner 0 0 0 1 455 459 1 715 3 456 457 458 0 0 1 0 522 0 0 0 0 887</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special node that combines multiple independently-moving rigid</span>
 <span class="s0">* nodes into one Geom internally (or as few Geoms as possible), for the</span>
 <span class="s0">* purposes of improving rendering performance.</span>
 <span class="s0">*</span>
 <span class="s0">* To use it, parent a number of moving objects to this node and call</span>
 <span class="s0">* collect().  A child node is identified as &quot;moving&quot; if (a) it has a non-</span>
 <span class="s0">* identity transform initially, or (b) it is a ModelNode with the</span>
 <span class="s0">* preserve_transform flag set.  Any other nodes will be considered static,</span>
 <span class="s0">* and later transforms applied to them will not be identified.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call collect() only at startup or if you change the set of</span>
 <span class="s0">* children; it is a relatively expensive call.</span>
 <span class="s0">*</span>
 <span class="s0">* Once you call collect(), you may change the transforms on the child nodes</span>
 <span class="s0">* freely without having to call collect() again.</span>
 <span class="s0">*</span>
 <span class="s0">* RenderEffects such as Billboards are not supported below this node.</span>
 <span class="s0">*/</span>

<span class="s0">533 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">534 26 PipeOcclusionCullTraverser 0 141313 26 PipeOcclusionCullTraverser 26 PipeOcclusionCullTraverser 0 0 0 1 464 472 0 7 465 466 467 468 469 470 471 0 0 2 3 535 460 461 3 536 462 463 0 0 616</span>
<span class="s0">/**</span>
 <span class="s0">* This specialization of CullTraverser uses the graphics pipe itself to</span>
 <span class="s0">* perform occlusion culling.  As such, it's likely to be inefficient (since</span>
 <span class="s0">* it interferes with the pipe's normal mode of rendering), and is mainly</span>
 <span class="s0">* useful to test other, CPU-based occlusion algorithms.</span>
 <span class="s0">*</span>
 <span class="s0">* This cannot be used in a multithreaded pipeline environment where cull and</span>
 <span class="s0">* draw are operating simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* It can't be defined in the cull subdirectory, because it needs access to</span>
 <span class="s0">* GraphicsPipe and DisplayRegion and other classes in display.  So we put it</span>
 <span class="s0">* in grutil instead, for lack of any better ideas.</span>
 <span class="s0">*/</span>

<span class="s0">535 13 CullTraverser 0 2048 13 CullTraverser 13 CullTraverser 0 0 0 0 0 0 0 0 0 0 0 0 279</span>
<span class="s0">/**</span>
 <span class="s0">* This object performs a depth-first traversal of the scene graph, with</span>
 <span class="s0">* optional view-frustum culling, collecting CullState and searching for</span>
 <span class="s0">* GeomNodes.  Each renderable Geom encountered is passed along with its</span>
 <span class="s0">* associated RenderState to the CullHandler object.</span>
 <span class="s0">*/</span>

<span class="s0">536 11 CullHandler 0 2048 11 CullHandler 11 CullHandler 0 0 0 0 0 0 0 0 0 0 0 0 225</span>
<span class="s0">/**</span>
 <span class="s0">* This defines the abstract interface for an object that receives Geoms</span>
 <span class="s0">* identified by the CullTraverser.  By itself, it's not a particularly useful</span>
 <span class="s0">* class; to use it, derive from it and redefine record_object().</span>
 <span class="s0">*/</span>

<span class="s0">537 9 PfmVizzer 0 26625 9 PfmVizzer 9 PfmVizzer 0 0 0 1 473 474 0 25 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 0 0 0 0 2 538 539 84</span>
<span class="s0">/**</span>
 <span class="s0">* This class aids in the visualization and manipulation of PfmFile objects.</span>
 <span class="s0">*/</span>

<span class="s0">538 10 ColumnType 0 794624 21 PfmVizzer::ColumnType 21 PfmVizzer::ColumnType 537 0 0 0 0 0 0 0 0 0 10 12 CT_texcoord2 23 PfmVizzer::CT_texcoord2 0</span>
<span class="s0">0 12 CT_texcoord3 23 PfmVizzer::CT_texcoord3 0</span>
<span class="s0">1 10 CT_vertex1 21 PfmVizzer::CT_vertex1 0</span>
<span class="s0">2 10 CT_vertex2 21 PfmVizzer::CT_vertex2 0</span>
<span class="s0">3 10 CT_vertex3 21 PfmVizzer::CT_vertex3 0</span>
<span class="s0">4 10 CT_normal3 21 PfmVizzer::CT_normal3 0</span>
<span class="s0">5 9 CT_blend1 20 PfmVizzer::CT_blend1 0</span>
<span class="s0">6 14 CT_aux_vertex1 25 PfmVizzer::CT_aux_vertex1 0</span>
<span class="s0">7 14 CT_aux_vertex2 25 PfmVizzer::CT_aux_vertex2 0</span>
<span class="s0">8 14 CT_aux_vertex3 25 PfmVizzer::CT_aux_vertex3 0</span>
<span class="s0">9 0 0</span>

<span class="s0">539 8 MeshFace 0 794624 19 PfmVizzer::MeshFace 19 PfmVizzer::MeshFace 537 0 0 0 0 0 0 0 0 0 3 8 MF_front 19 PfmVizzer::MF_front 0</span>
<span class="s0">1 7 MF_back 18 PfmVizzer::MF_back 0</span>
<span class="s0">2 7 MF_both 18 PfmVizzer::MF_both 0</span>
<span class="s0">3 0 0</span>

<span class="s0">540 17 CardMaker const * 0 8576 17 CardMaker const * 17 CardMaker const * 0 0 541 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">541 15 CardMaker const 0 8832 15 CardMaker const 15 CardMaker const 0 0 500 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">542 11 CardMaker * 0 8576 11 CardMaker * 11 CardMaker * 0 0 500 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">543 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">544 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">545 17 LTexCoord const * 0 8576 17 LTexCoord const * 17 LTexCoord const * 0 0 546 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">546 15 LTexCoord const 0 8832 15 LTexCoord const 15 LTexCoord const 0 0 547 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">547 9 LTexCoord 0 2105344 9 LTexCoord 9 LTexCoord 0 0 548 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">548 10 LTexCoordf 0 2105344 10 LTexCoordf 10 LTexCoordf 0 0 549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">549 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">550 18 LTexCoord3 const * 0 8576 18 LTexCoord3 const * 18 LTexCoord3 const * 0 0 551 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">551 16 LTexCoord3 const 0 8832 16 LTexCoord3 const 16 LTexCoord3 const 0 0 552 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">552 10 LTexCoord3 0 2105344 10 LTexCoord3 10 LTexCoord3 0 0 553 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">553 11 LTexCoord3f 0 2105344 11 LTexCoord3f 11 LTexCoord3f 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">554 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">555 16 LVector4 const * 0 8576 16 LVector4 const * 16 LVector4 const * 0 0 556 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">556 14 LVector4 const 0 8832 14 LVector4 const 14 LVector4 const 0 0 557 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">557 8 LVector4 0 2105344 8 LVector4 8 LVector4 0 0 558 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">558 9 LVector4f 0 2048 9 LVector4f 9 LVector4f 0 0 0 0 0 0 0 0 0 0 0 0 52</span>
<span class="s0">/**</span>
 <span class="s0">* This is a four-component vector distance.</span>
 <span class="s0">*/</span>

<span class="s0">559 15 Texture const * 0 8576 15 Texture const * 15 Texture const * 0 0 560 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">560 13 Texture const 0 8832 13 Texture const 13 Texture const 0 0 513 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">561 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 562 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">562 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 563 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">563 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 564 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">564 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">565 15 LVertex const * 0 8576 15 LVertex const * 15 LVertex const * 0 0 566 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">566 13 LVertex const 0 8832 13 LVertex const 13 LVertex const 0 0 567 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">567 7 LVertex 0 2105344 7 LVertex 7 LVertex 0 0 568 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">568 8 LVertexf 0 2105344 8 LVertexf 8 LVertexf 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">569 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 570 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">570 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 571 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">571 6 LColor 0 2105344 6 LColor 6 LColor 0 0 572 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">572 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 564 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">573 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 522 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">574 20 FisheyeMaker const * 0 8576 20 FisheyeMaker const * 20 FisheyeMaker const * 0 0 575 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">575 18 FisheyeMaker const 0 8832 18 FisheyeMaker const 18 FisheyeMaker const 0 0 502 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">576 14 FisheyeMaker * 0 8576 14 FisheyeMaker * 14 FisheyeMaker * 0 0 502 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">577 22 FrameRateMeter const * 0 8576 22 FrameRateMeter const * 22 FrameRateMeter const * 0 0 578 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">578 20 FrameRateMeter const 0 8832 20 FrameRateMeter const 20 FrameRateMeter const 0 0 503 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">579 16 FrameRateMeter * 0 8576 16 FrameRateMeter * 16 FrameRateMeter * 0 0 503 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">580 16 GraphicsOutput * 0 8576 16 GraphicsOutput * 16 GraphicsOutput * 0 0 581 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">581 14 GraphicsOutput 0 2048 14 GraphicsOutput 14 GraphicsOutput 0 0 0 0 0 0 0 0 0 0 0 0 727</span>
<span class="s0">/**</span>
 <span class="s0">* This is a base class for the various different classes that represent the</span>
 <span class="s0">* result of a frame of rendering.  The most common kind of GraphicsOutput is</span>
 <span class="s0">* a GraphicsWindow, which is a real-time window on the desktop, but another</span>
 <span class="s0">* example is GraphicsBuffer, which is an offscreen buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* The actual rendering, and anything associated with the graphics context</span>
 <span class="s0">* itself, is managed by the associated GraphicsStateGuardian (which might</span>
 <span class="s0">* output to multiple GraphicsOutput objects).</span>
 <span class="s0">*</span>
 <span class="s0">* GraphicsOutputs are not actually writable to bam files, of course, but they</span>
 <span class="s0">* may be passed as event parameters, so they inherit from</span>
 <span class="s0">* TypedWritableReferenceCount instead of TypedReferenceCount for that</span>
 <span class="s0">* convenience.</span>
 <span class="s0">*/</span>

<span class="s0">582 13 DisplayRegion 0 2048 13 DisplayRegion 13 DisplayRegion 0 0 0 0 0 0 0 0 0 0 0 0 399</span>
<span class="s0">/**</span>
 <span class="s0">* A rectangular subregion within a window for rendering into.  Typically,</span>
 <span class="s0">* there is one DisplayRegion that covers the whole window, but you may also</span>
 <span class="s0">* create smaller DisplayRegions for having different regions within the</span>
 <span class="s0">* window that represent different scenes.  You may also stack up</span>
 <span class="s0">* DisplayRegions like panes of glass, usually for layering 2-d interfaces on</span>
 <span class="s0">* top of a 3-d scene.</span>
 <span class="s0">*/</span>

<span class="s0">583 15 DisplayRegion * 0 8576 15 DisplayRegion * 15 DisplayRegion * 0 0 582 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">584 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 585 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">585 11 ClockObject 0 2048 11 ClockObject 11 ClockObject 0 0 0 0 0 0 0 0 0 0 0 0 1000</span>
<span class="s0">/**</span>
 <span class="s0">* A ClockObject keeps track of elapsed real time and discrete time.  In</span>
 <span class="s0">* normal mode, get_frame_time() returns the time as of the last time tick()</span>
 <span class="s0">* was called.  This is the &quot;discrete&quot; time, and is usually used to get the</span>
 <span class="s0">* time as of, for instance, the beginning of the current frame.</span>
 <span class="s0">*</span>
 <span class="s0">* In other modes, as set by set_mode() or the clock-mode config variable,</span>
 <span class="s0">* get_frame_time() may return other values to simulate different timing</span>
 <span class="s0">* effects, for instance to perform non-real-time animation.  See set_mode().</span>
 <span class="s0">*</span>
 <span class="s0">* In all modes, get_real_time() always returns the elapsed real time in</span>
 <span class="s0">* seconds since the ClockObject was constructed, or since it was last reset.</span>
 <span class="s0">*</span>
 <span class="s0">* You can create your own ClockObject whenever you want to have your own</span>
 <span class="s0">* local timer.  There is also a default, global ClockObject intended to</span>
 <span class="s0">* represent global time for the application; this is normally set up to tick</span>
 <span class="s0">* every frame so that its get_frame_time() will return the time for the</span>
 <span class="s0">* current frame.</span>
 <span class="s0">*/</span>

<span class="s0">586 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">587 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 586 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">588 15 GeoMipTerrain * 0 8576 15 GeoMipTerrain * 15 GeoMipTerrain * 0 0 505 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">589 10 PNMImage * 0 8576 10 PNMImage * 10 PNMImage * 0 0 590 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">590 8 PNMImage 0 2048 8 PNMImage 8 PNMImage 0 0 0 0 0 0 0 0 0 0 0 0 1516</span>
<span class="s0">/**</span>
 <span class="s0">* The name of this class derives from the fact that we originally implemented</span>
 <span class="s0">* it as a layer on top of the &quot;pnm library&quot;, based on netpbm, which was built</span>
 <span class="s0">* to implement pbm, pgm, and pbm files, and is the underlying support of a</span>
 <span class="s0">* number of public-domain image file converters.  Nowadays we are no longer</span>
 <span class="s0">* derived directly from the pnm library, mainly to allow support of C++</span>
 <span class="s0">* iostreams instead of the C stdio FILE interface.</span>
 <span class="s0">*</span>
 <span class="s0">* Conceptually, a PNMImage is a two-dimensional array of xels, which are the</span>
 <span class="s0">* PNM-defined generic pixel type.  Each xel may have a red, green, and blue</span>
 <span class="s0">* component, or (if the image is grayscale) a gray component.  The image may</span>
 <span class="s0">* be read in, the individual xels manipulated, and written out again, or a</span>
 <span class="s0">* black image may be constructed from scratch.</span>
 <span class="s0">*</span>
 <span class="s0">* A PNMImage has a color space and a maxval, the combination of which defines</span>
 <span class="s0">* how a floating-point linear color value is encoded as an integer value in</span>
 <span class="s0">* memory.  The functions ending in _val operate on encoded colors, whereas</span>
 <span class="s0">* the regular ones work with linear floating-point values.  All operations</span>
 <span class="s0">* are color space correct unless otherwise specified.</span>
 <span class="s0">*</span>
 <span class="s0">* The image is of size XSize() by YSize() xels, numbered from top to bottom,</span>
 <span class="s0">* left to right, beginning at zero.</span>
 <span class="s0">*</span>
 <span class="s0">* Files can be specified by filename, or by an iostream pointer.  The</span>
 <span class="s0">* filename &quot;-&quot; refers to stdin or stdout.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is not inherently thread-safe; use it from a single thread or</span>
 <span class="s0">* protect access using a mutex.</span>
 <span class="s0">*/</span>

<span class="s0">591 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 592 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">592 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 593 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">593 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">594 13 PNMFileType * 0 8576 13 PNMFileType * 13 PNMFileType * 0 0 595 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">595 11 PNMFileType 0 2048 11 PNMFileType 11 PNMFileType 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">596 16 PNMImage const * 0 8576 16 PNMImage const * 16 PNMImage const * 0 0 597 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">597 14 PNMImage const 0 8832 14 PNMImage const 14 PNMImage const 0 0 590 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">598 21 GeoMipTerrain const * 0 8576 21 GeoMipTerrain const * 21 GeoMipTerrain const * 0 0 599 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">599 19 GeoMipTerrain const 0 8832 19 GeoMipTerrain const 19 GeoMipTerrain const 0 0 505 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">600 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 601 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">601 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">602 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 600 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">603 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">604 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 605 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">605 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">606 8 LPoint2d 0 2048 8 LPoint2d 8 LPoint2d 0 0 0 0 0 0 0 0 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">607 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 608 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">608 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">609 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 610 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">610 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 611 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">611 8 LPoint3d 0 2048 8 LPoint3d 8 LPoint3d 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">612 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 613 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">613 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">614 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 533 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">615 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 533 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">616 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">617 9 LVecBase2 0 2105344 9 LVecBase2 9 LVecBase2 0 0 618 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">618 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">619 11 LVecBase2 * 0 8576 11 LVecBase2 * 11 LVecBase2 * 0 0 617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">620 29 HeightfieldTesselator const * 0 8576 29 HeightfieldTesselator const * 29 HeightfieldTesselator const * 0 0 621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">621 27 HeightfieldTesselator const 0 8832 27 HeightfieldTesselator const 27 HeightfieldTesselator const 0 0 508 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">622 23 HeightfieldTesselator * 0 8576 23 HeightfieldTesselator * 23 HeightfieldTesselator * 0 0 508 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">623 16 LineSegs const * 0 8576 16 LineSegs const * 16 LineSegs const * 0 0 624 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">624 14 LineSegs const 0 8832 14 LineSegs const 14 LineSegs const 0 0 509 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">625 10 LineSegs * 0 8576 10 LineSegs * 10 LineSegs * 0 0 509 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">626 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 627 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">627 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">628 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 629 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">629 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">630 8 GeomNode 0 2048 8 GeomNode 8 GeomNode 0 0 0 0 0 0 0 0 0 0 0 0 208</span>
<span class="s0">/**</span>
 <span class="s0">* A node that holds Geom objects, renderable pieces of geometry.  This is the</span>
 <span class="s0">* primary kind of leaf node in the scene graph; almost all visible objects</span>
 <span class="s0">* will be contained in a GeomNode somewhere.</span>
 <span class="s0">*/</span>

<span class="s0">631 10 GeomNode * 0 8576 10 GeomNode * 10 GeomNode * 0 0 630 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">632 9 LVertex * 0 8576 9 LVertex * 9 LVertex * 0 0 567 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">633 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 571 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">634 12 MeshDrawer * 0 8576 12 MeshDrawer * 12 MeshDrawer * 0 0 510 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">635 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 636 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">636 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 600 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">637 16 LVector2 const * 0 8576 16 LVector2 const * 16 LVector2 const * 0 0 638 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">638 14 LVector2 const 0 8832 14 LVector2 const 14 LVector2 const 0 0 639 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">639 8 LVector2 0 2105344 8 LVector2 8 LVector2 0 0 640 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">640 9 LVector2f 0 2048 9 LVector2f 9 LVector2f 0 0 0 0 0 0 0 0 0 0 0 0 49</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component vector offset.</span>
 <span class="s0">*/</span>

<span class="s0">641 14 MeshDrawer2D * 0 8576 14 MeshDrawer2D * 14 MeshDrawer2D * 0 0 511 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">642 12 MovieVideo * 0 8576 12 MovieVideo * 12 MovieVideo * 0 0 643 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">643 10 MovieVideo 0 2048 10 MovieVideo 10 MovieVideo 0 0 0 0 0 0 0 0 0 0 0 0 400</span>
<span class="s0">/**</span>
 <span class="s0">* A MovieVideo is actually any source that provides a sequence of video</span>
 <span class="s0">* frames.  That could include an AVI file, a digital camera, or an internet</span>
 <span class="s0">* TV station.</span>
 <span class="s0">*</span>
 <span class="s0">* The difference between a MovieVideo and a MovieVideoCursor is like the</span>
 <span class="s0">* difference between a filename and a file handle.  The MovieVideo just</span>
 <span class="s0">* indicates a particular movie.  The MovieVideoCursor is what allows access.</span>
 <span class="s0">*/</span>

<span class="s0">644 14 MovieTexture * 0 8576 14 MovieTexture * 14 MovieTexture * 0 0 512 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">645 20 MovieTexture const * 0 8576 20 MovieTexture const * 20 MovieTexture const * 0 0 646 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">646 18 MovieTexture const 0 8832 18 MovieTexture const 18 MovieTexture const 0 0 512 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">647 16 MovieVideoCursor 0 2048 16 MovieVideoCursor 16 MovieVideoCursor 0 0 0 0 0 0 0 0 0 0 0 0 504</span>
<span class="s0">/**</span>
 <span class="s0">* A MovieVideo is actually any source that provides a sequence of video</span>
 <span class="s0">* frames.  That could include an AVI file, a digital camera, or an internet</span>
 <span class="s0">* TV station.  A MovieVideoCursor is a handle that lets you read data</span>
 <span class="s0">* sequentially from a MovieVideo.</span>
 <span class="s0">*</span>
 <span class="s0">* Thread safety: each individual MovieVideoCursor must be owned and accessed</span>
 <span class="s0">* by a single thread.  It is OK for two different threads to open the same</span>
 <span class="s0">* file at the same time, as long as they use separate MovieVideoCursor</span>
 <span class="s0">* objects.</span>
 <span class="s0">*/</span>

<span class="s0">648 18 MovieVideoCursor * 0 8576 18 MovieVideoCursor * 18 MovieVideoCursor * 0 0 647 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">649 12 AudioSound * 0 8576 12 AudioSound * 12 AudioSound * 0 0 650 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">650 10 AudioSound 0 2048 10 AudioSound 10 AudioSound 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">651 17 MultitexReducer * 0 8576 17 MultitexReducer * 17 MultitexReducer * 0 0 517 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">652 23 MultitexReducer const * 0 8576 23 MultitexReducer const * 23 MultitexReducer const * 0 0 653 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">653 21 MultitexReducer const 0 8832 21 MultitexReducer const 21 MultitexReducer const 0 0 517 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">654 19 RenderState const * 0 8576 19 RenderState const * 19 RenderState const * 0 0 655 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">655 17 RenderState const 0 8832 17 RenderState const 17 RenderState const 0 0 656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">656 11 RenderState 0 2048 11 RenderState 11 RenderState 0 0 0 0 0 0 0 0 0 0 0 0 340</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a unique collection of RenderAttrib objects that correspond</span>
 <span class="s0">* to a particular renderable state.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a RenderState object directly.</span>
 <span class="s0">* Instead, call one of the make() functions to create one for you.  And</span>
 <span class="s0">* instead of modifying a RenderState object, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">657 22 TransformState const * 0 8576 22 TransformState const * 22 TransformState const * 0 0 658 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">658 20 TransformState const 0 8832 20 TransformState const 20 TransformState const 0 0 659 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">659 14 TransformState 0 16779264 14 TransformState 14 TransformState 0 0 0 0 0 0 0 0 0 0 0 0 734</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates a coordinate-system transform on vertices.  TransformStates are</span>
 <span class="s0">* the primary means for storing transformations on the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* Transforms may be specified in one of two ways: componentwise, with a pos-</span>
 <span class="s0">* hpr-scale, or with an arbitrary transform matrix.  If you specify a</span>
 <span class="s0">* transform componentwise, it will remember its original components.</span>
 <span class="s0">*</span>
 <span class="s0">* TransformState objects are managed very much like RenderState objects.</span>
 <span class="s0">* They are immutable and reference-counted automatically.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a TransformState object</span>
 <span class="s0">* directly.  Instead, call one of the make() functions to create one for you.</span>
 <span class="s0">* And instead of modifying a TransformState object, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">660 14 TextureStage * 0 8576 14 TextureStage * 14 TextureStage * 0 0 661 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">661 12 TextureStage 0 2048 12 TextureStage 12 TextureStage 0 0 0 0 0 0 0 0 0 0 0 0 336</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the properties of a named stage of the multitexture pipeline.  The</span>
 <span class="s0">* TextureAttrib will associated a number of these stages with Texture</span>
 <span class="s0">* objects, and the GSG will render geometry by sorting all of the currently</span>
 <span class="s0">* active TextureStages in order and then issuing the appropriate rendering</span>
 <span class="s0">* calls to activate them.</span>
 <span class="s0">*/</span>

<span class="s0">662 21 NodeVertexTransform * 0 8576 21 NodeVertexTransform * 21 NodeVertexTransform * 0 0 518 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">663 27 NodeVertexTransform const * 0 8576 27 NodeVertexTransform const * 27 NodeVertexTransform const * 0 0 664 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">664 25 NodeVertexTransform const 0 8832 25 NodeVertexTransform const 25 NodeVertexTransform const 0 0 518 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">665 19 ShaderTerrainMesh * 0 8576 19 ShaderTerrainMesh * 19 ShaderTerrainMesh * 0 0 525 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">666 25 ShaderTerrainMesh const * 0 8576 25 ShaderTerrainMesh const * 25 ShaderTerrainMesh const * 0 0 667 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">667 23 ShaderTerrainMesh const 0 8832 23 ShaderTerrainMesh const 23 ShaderTerrainMesh const 0 0 525 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">668 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">669 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 668 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">670 31 SceneGraphAnalyzerMeter const * 0 8576 31 SceneGraphAnalyzerMeter const * 31 SceneGraphAnalyzerMeter const * 0 0 671 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">671 29 SceneGraphAnalyzerMeter const 0 8832 29 SceneGraphAnalyzerMeter const 29 SceneGraphAnalyzerMeter const 0 0 531 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">672 25 SceneGraphAnalyzerMeter * 0 8576 25 SceneGraphAnalyzerMeter * 25 SceneGraphAnalyzerMeter * 0 0 531 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">673 19 RigidBodyCombiner * 0 8576 19 RigidBodyCombiner * 19 RigidBodyCombiner * 0 0 532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">674 28 PipeOcclusionCullTraverser * 0 8576 28 PipeOcclusionCullTraverser * 28 PipeOcclusionCullTraverser * 0 0 534 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">675 12 SceneSetup * 0 8576 12 SceneSetup * 12 SceneSetup * 0 0 676 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">676 10 SceneSetup 0 2048 10 SceneSetup 10 SceneSetup 0 0 0 0 0 0 0 0 0 0 0 0 128</span>
<span class="s0">/**</span>
 <span class="s0">* This object holds the camera position, etc., and other general setup</span>
 <span class="s0">* information for rendering a particular scene.</span>
 <span class="s0">*/</span>

<span class="s0">677 27 GraphicsStateGuardianBase * 0 8576 27 GraphicsStateGuardianBase * 27 GraphicsStateGuardianBase * 0 0 678 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">678 25 GraphicsStateGuardianBase 0 2048 25 GraphicsStateGuardianBase 25 GraphicsStateGuardianBase 0 0 0 0 0 0 0 0 0 0 0 0 607</span>
<span class="s0">/**</span>
 <span class="s0">* This is a base class for the GraphicsStateGuardian class, which is itself a</span>
 <span class="s0">* base class for the various GSG's for different platforms.  This class</span>
 <span class="s0">* contains all the function prototypes to support the double-dispatch of GSG</span>
 <span class="s0">* to geoms, transitions, etc.  It lives in a separate class in its own</span>
 <span class="s0">* package so we can avoid circular build dependency problems.</span>
 <span class="s0">*</span>
 <span class="s0">* GraphicsStateGuardians are not actually writable to bam files, of course,</span>
 <span class="s0">* but they may be passed as event parameters, so they inherit from</span>
 <span class="s0">* TypedWritableReferenceCount instead of TypedReferenceCount for that</span>
 <span class="s0">* convenience.</span>
 <span class="s0">*/</span>

<span class="s0">679 34 PipeOcclusionCullTraverser const * 0 8576 34 PipeOcclusionCullTraverser const * 34 PipeOcclusionCullTraverser const * 0 0 680 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">680 32 PipeOcclusionCullTraverser const 0 8832 32 PipeOcclusionCullTraverser const 32 PipeOcclusionCullTraverser const 0 0 534 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">681 16 DrawMask const * 0 8576 16 DrawMask const * 16 DrawMask const * 0 0 682 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">682 14 DrawMask const 0 8832 14 DrawMask const 14 DrawMask const 0 0 683 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">683 8 DrawMask 0 2105344 8 DrawMask 8 DrawMask 0 0 684 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">684 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 685 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">685 23 BitMask&lt; uint32_t, 32 &gt; 0 2048 23 BitMask&lt; uint32_t, 32 &gt; 23 BitMask&lt; uint32_t, 32 &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">686 15 CullTraverser * 0 8576 15 CullTraverser * 15 CullTraverser * 0 0 535 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">687 13 CullHandler * 0 8576 13 CullHandler * 13 CullHandler * 0 0 536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">688 9 PfmFile * 0 8576 9 PfmFile * 9 PfmFile * 0 0 689 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">689 7 PfmFile 0 2048 7 PfmFile 7 PfmFile 0 0 0 0 0 0 0 0 0 0 0 0 155</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a pfm file, a 2-d table of floating-point numbers, either</span>
 <span class="s0">* 3-component or 1-component, or with a special extension, 2- or 4-component.</span>
 <span class="s0">*/</span>

<span class="s0">690 11 PfmVizzer * 0 8576 11 PfmVizzer * 11 PfmVizzer * 0 0 537 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">691 17 PfmVizzer const * 0 8576 17 PfmVizzer const * 17 PfmVizzer const * 0 0 692 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">692 15 PfmVizzer const 0 8832 15 PfmVizzer const 15 PfmVizzer const 0 0 537 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">693 15 PfmFile const * 0 8576 15 PfmFile const * 15 PfmFile const * 0 0 694 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">694 13 PfmFile const 0 8832 13 PfmFile const 13 PfmFile const 0 0 689 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">695 12 Lens const * 0 8576 12 Lens const * 12 Lens const * 0 0 696 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">696 10 Lens const 0 8832 10 Lens const 10 Lens const 0 0 697 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">697 4 Lens 0 2048 4 Lens 4 Lens 0 0 0 0 0 0 0 0 0 0 0 0 398</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for any number of different kinds of lenses, linear and</span>
 <span class="s0">* otherwise.  Presently, this includes perspective and orthographic lenses.</span>
 <span class="s0">*</span>
 <span class="s0">* A Lens object is the main part of a Camera node, which defines the</span>
 <span class="s0">* fundamental interface to point-of-view for rendering.  Lenses are also used</span>
 <span class="s0">* in other contexts, however; for instance, a Spotlight is also defined using</span>
 <span class="s0">* a lens.</span>
 <span class="s0">*/</span>

<span class="s0">698 14 InternalName * 0 8576 14 InternalName * 14 InternalName * 0 0 699 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">699 12 InternalName 0 16779264 12 InternalName 12 InternalName 0 0 0 0 0 0 0 0 0 0 0 0 514</span>
<span class="s0">/**</span>
 <span class="s0">* Encodes a string name in a hash table, mapping it to a pointer.  This is</span>
 <span class="s0">* used to tokenify names so they may be used efficiently in low-level Panda</span>
 <span class="s0">* structures, for instance to differentiate the multiple sets of texture</span>
 <span class="s0">* coordinates that might be stored on a Geom.</span>
 <span class="s0">*</span>
 <span class="s0">* InternalNames are hierarchical, with the '.' used by convention as a</span>
 <span class="s0">* separator character.  You can construct a single InternalName as a</span>
 <span class="s0">* composition of one or more other names, or by giving it a source string</span>
 <span class="s0">* directly.</span>
 <span class="s0">*/</span>

<span class="s0">0</span>
<span class="s0">16</span>
<span class="s0">700 12 video_length 0 2 514 396 0 0 0 0 0 0 0 26 MovieTexture::video_length 0</span>

<span class="s0">701 11 video_width 0 2 515 397 0 0 0 0 0 0 0 25 MovieTexture::video_width 0</span>

<span class="s0">702 12 video_height 0 2 515 398 0 0 0 0 0 0 0 26 MovieTexture::video_height 0</span>

<span class="s0">703 4 time 0 6 514 405 404 0 0 0 0 0 0 18 MovieTexture::time 0</span>

<span class="s0">704 4 loop 0 6 516 407 406 0 0 0 0 0 0 18 MovieTexture::loop 0</span>

<span class="s0">705 10 loop_count 0 6 515 409 408 0 0 0 0 0 0 24 MovieTexture::loop_count 0</span>

<span class="s0">706 9 play_rate 0 6 514 411 410 0 0 0 0 0 0 23 MovieTexture::play_rate 0</span>

<span class="s0">707 7 playing 0 2 516 412 0 0 0 0 0 0 0 21 MovieTexture::playing 0</span>

<span class="s0">708 4 node 0 2 520 425 0 0 0 0 0 0 0 25 NodeVertexTransform::node 0</span>

<span class="s0">709 4 prev 0 2 523 426 0 0 0 0 0 0 0 25 NodeVertexTransform::prev 0</span>

<span class="s0">710 11 heightfield 0 6 526 431 430 0 0 0 0 0 0 30 ShaderTerrainMesh::heightfield 0</span>

<span class="s0">711 10 chunk_size 0 6 527 433 432 0 0 0 0 0 0 29 ShaderTerrainMesh::chunk_size 0</span>

<span class="s0">712 16 generate_patches 0 6 516 435 434 0 0 0 0 0 0 35 ShaderTerrainMesh::generate_patches 0</span>

<span class="s0">713 14 update_enabled 0 6 516 437 436 0 0 0 0 0 0 33 ShaderTerrainMesh::update_enabled 0</span>

<span class="s0">714 21 target_triangle_width 0 6 529 439 438 0 0 0 0 0 0 40 ShaderTerrainMesh::target_triangle_width 0</span>

<span class="s0">715 14 internal_scene 0 2 533 457 0 0 0 0 0 0 0 33 RigidBodyCombiner::internal_scene 0</span>

<span class="s0">2</span>
<span class="s0">716 12 get_vertices 0 357 358 22 LineSegs::get_vertices 0</span>

<span class="s0">717 17 get_vertex_colors 0 357 360 27 LineSegs::get_vertex_colors 0</span>

</pre>
</body>
</html>