<html>
<head>
<title>libp3pgraph.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3pgraph.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">11 libp3pgraph 4 w0Cq 12 panda3d.core </span>
<span class="s0">1687</span>
<span class="s0">1889 11 operator != 0 4 3576 27 TransformState::operator != 0 1 1 0</span>
<span class="s0">75</span>
<span class="s0">inline bool TransformState::operator !=(TransformState const &amp;other) const;</span>

<span class="s0">1890 10 compare_to 0 4 3576 26 TransformState::compare_to 0 2 2 3 847</span>
<span class="s0">/**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique TransformStates, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this returns 0, it doesn't necessarily imply that operator ==</span>
 <span class="s0">* returns true; it uses a very slightly different comparison threshold.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique TransformStates, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this returns 0, it doesn't necessarily imply that operator ==</span>
 <span class="s0">* returns true; it uses a very slightly different comparison threshold.</span>
 <span class="s0">*</span>
 <span class="s0">* If uniquify_matrix is true, then matrix-defined TransformStates are also</span>
 <span class="s0">* uniqified.  If uniquify_matrix is false, then only component-defined</span>
 <span class="s0">* TransformStates are uniquified, which is less expensive.</span>
 <span class="s0">*/</span>
<span class="s0">162</span>
<span class="s0">inline int TransformState::compare_to(TransformState const &amp;other) const;</span>
<span class="s0">int TransformState::compare_to(TransformState const &amp;other, bool uniquify_matrix) const;</span>

<span class="s0">1891 11 operator == 0 4 3576 27 TransformState::operator == 0 1 4 0</span>
<span class="s0">68</span>
<span class="s0">bool TransformState::operator ==(TransformState const &amp;other) const;</span>

<span class="s0">1892 8 get_hash 0 4 3576 24 TransformState::get_hash 0 1 5 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash value for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline std::size_t TransformState::get_hash(void) const;</span>

<span class="s0">1893 13 make_identity 0 4 3576 29 TransformState::make_identity 0 1 6 44</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an identity transform.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static ConstPointerTo&lt; TransformState &gt; TransformState::make_identity(void);</span>

<span class="s0">1894 12 make_invalid 0 4 3576 28 TransformState::make_invalid 0 1 7 103</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an invalid transform; for instance, the result of inverting a</span>
 <span class="s0">* singular matrix.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static ConstPointerTo&lt; TransformState &gt; TransformState::make_invalid(void);</span>

<span class="s0">1895 8 make_pos 0 4 3576 24 TransformState::make_pos 0 1 8 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_pos(LVecBase3 const &amp;pos);</span>

<span class="s0">1896 8 make_hpr 0 4 3576 24 TransformState::make_hpr 0 1 9 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_hpr(LVecBase3 const &amp;hpr);</span>

<span class="s0">1897 9 make_quat 0 4 3576 25 TransformState::make_quat 0 1 10 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_quat(LQuaternion const &amp;quat);</span>

<span class="s0">1898 12 make_pos_hpr 0 4 3576 28 TransformState::make_pos_hpr 0 1 11 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_pos_hpr(LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr);</span>

<span class="s0">1899 10 make_scale 0 4 3576 26 TransformState::make_scale 0 2 12 13 138</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">192</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_scale(PN_stdfloat scale);</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_scale(LVecBase3 const &amp;scale);</span>

<span class="s0">1900 10 make_shear 0 4 3576 26 TransformState::make_shear 0 1 14 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_shear(LVecBase3 const &amp;shear);</span>

<span class="s0">1901 18 make_pos_hpr_scale 0 4 3576 34 TransformState::make_pos_hpr_scale 0 1 15 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">150</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_pos_hpr_scale(LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr, LVecBase3 const &amp;scale);</span>

<span class="s0">1902 19 make_pos_quat_scale 0 4 3576 35 TransformState::make_pos_quat_scale 0 1 16 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">154</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_pos_quat_scale(LVecBase3 const &amp;pos, LQuaternion const &amp;quat, LVecBase3 const &amp;scale);</span>

<span class="s0">1903 24 make_pos_hpr_scale_shear 0 4 3576 40 TransformState::make_pos_hpr_scale_shear 0 1 17 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">173</span>
<span class="s0">static ConstPointerTo&lt; TransformState &gt; TransformState::make_pos_hpr_scale_shear(LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr, LVecBase3 const &amp;scale, LVecBase3 const &amp;shear);</span>

<span class="s0">1904 25 make_pos_quat_scale_shear 0 4 3576 41 TransformState::make_pos_quat_scale_shear 0 1 18 68</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">177</span>
<span class="s0">static ConstPointerTo&lt; TransformState &gt; TransformState::make_pos_quat_scale_shear(LVecBase3 const &amp;pos, LQuaternion const &amp;quat, LVecBase3 const &amp;scale, LVecBase3 const &amp;shear);</span>

<span class="s0">1905 8 make_mat 0 4 3576 24 TransformState::make_mat 0 1 19 79</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new TransformState with the specified transformation matrix.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">static ConstPointerTo&lt; TransformState &gt; TransformState::make_mat(LMatrix4 const &amp;mat);</span>

<span class="s0">1906 10 make_pos2d 0 4 3576 26 TransformState::make_pos2d 0 1 20 72</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_pos2d(LVecBase2 const &amp;pos);</span>

<span class="s0">1907 13 make_rotate2d 0 4 3576 29 TransformState::make_rotate2d 0 1 21 72</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_rotate2d(PN_stdfloat rotate);</span>

<span class="s0">1908 17 make_pos_rotate2d 0 4 3576 33 TransformState::make_pos_rotate2d 0 1 22 72</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_pos_rotate2d(LVecBase2 const &amp;pos, PN_stdfloat rotate);</span>

<span class="s0">1909 12 make_scale2d 0 4 3576 28 TransformState::make_scale2d 0 2 23 24 146</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">196</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_scale2d(PN_stdfloat scale);</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_scale2d(LVecBase2 const &amp;scale);</span>

<span class="s0">1910 12 make_shear2d 0 4 3576 28 TransformState::make_shear2d 0 1 25 72</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_shear2d(PN_stdfloat shear);</span>

<span class="s0">1911 23 make_pos_rotate_scale2d 0 4 3576 39 TransformState::make_pos_rotate_scale2d 0 1 26 72</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">static inline ConstPointerTo&lt; TransformState &gt; TransformState::make_pos_rotate_scale2d(LVecBase2 const &amp;pos, PN_stdfloat rotate, LVecBase2 const &amp;scale);</span>

<span class="s0">1912 29 make_pos_rotate_scale_shear2d 0 4 3576 45 TransformState::make_pos_rotate_scale_shear2d 0 1 27 84</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new two-dimensional TransformState with the specified components.</span>
 <span class="s0">*/</span>
<span class="s0">171</span>
<span class="s0">static ConstPointerTo&lt; TransformState &gt; TransformState::make_pos_rotate_scale_shear2d(LVecBase2 const &amp;pos, PN_stdfloat rotate, LVecBase2 const &amp;scale, PN_stdfloat shear);</span>

<span class="s0">1913 9 make_mat3 0 4 3576 25 TransformState::make_mat3 0 1 28 102</span>
<span class="s0">/**</span>
 <span class="s0">* Makes a new two-dimensional TransformState with the specified 3x3</span>
 <span class="s0">* transformation matrix.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">static ConstPointerTo&lt; TransformState &gt; TransformState::make_mat3(LMatrix3 const &amp;mat);</span>

<span class="s0">1914 11 is_identity 0 4 3576 27 TransformState::is_identity 0 1 29 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform represents the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool TransformState::is_identity(void) const;</span>

<span class="s0">1915 10 is_invalid 0 4 3576 26 TransformState::is_invalid 0 1 30 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform represents an invalid matrix, for instance</span>
 <span class="s0">* the result of inverting a singular matrix, or false if the transform is</span>
 <span class="s0">* valid.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool TransformState::is_invalid(void) const;</span>

<span class="s0">1916 11 is_singular 0 4 3576 27 TransformState::is_singular 0 1 31 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform represents a singular transform (that is, it</span>
 <span class="s0">* has a zero scale, and it cannot be inverted), or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool TransformState::is_singular(void) const;</span>

<span class="s0">1917 5 is_2d 0 4 3576 21 TransformState::is_2d 0 1 32 206</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform has been constructed entirely using the 2-d</span>
 <span class="s0">* transform operations, e.g.  make_pos2d(), and therefore operates strictly</span>
 <span class="s0">* in two-dimensional space on X and Y only.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool TransformState::is_2d(void) const;</span>

<span class="s0">1918 14 has_components 0 4 3576 30 TransformState::has_components 0 1 33 654</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform can be described by separate pos, hpr, and</span>
 <span class="s0">* scale components.  Most transforms we use in everyday life can be so</span>
 <span class="s0">* described, but some kinds of transforms (for instance, those involving a</span>
 <span class="s0">* skew) cannot.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not related to whether the transform was originally described</span>
 <span class="s0">* componentwise.  Even a transform that was constructed with a 4x4 may return</span>
 <span class="s0">* true here if the matrix is a simple affine matrix with no skew.</span>
 <span class="s0">*</span>
 <span class="s0">* If this returns true, you may safely call get_hpr() and get_scale() to</span>
 <span class="s0">* retrieve the components.  (You may always safely call get_pos() whether</span>
 <span class="s0">* this returns true or false.)</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool TransformState::has_components(void) const;</span>

<span class="s0">1919 16 components_given 0 4 3576 32 TransformState::components_given 0 1 34 454</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform was specified componentwise, or false if it</span>
 <span class="s0">* was specified with a general 4x4 matrix.  If this is true, the components</span>
 <span class="s0">* returned by get_pos() and get_scale() will be exactly those that were set;</span>
 <span class="s0">* otherwise, these functions will return computed values.  If this is true,</span>
 <span class="s0">* the rotation may have been set either with a hpr trio or with a quaternion;</span>
 <span class="s0">* hpr_given() or quat_given() can resolve the difference.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool TransformState::components_given(void) const;</span>

<span class="s0">1920 9 hpr_given 0 4 3576 25 TransformState::hpr_given 0 1 35 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the rotation was specified via a trio of Euler angles,</span>
 <span class="s0">* false otherwise.  If this is true, get_hpr() will be exactly as set;</span>
 <span class="s0">* otherwise, it will return a computed value.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool TransformState::hpr_given(void) const;</span>

<span class="s0">1921 10 quat_given 0 4 3576 26 TransformState::quat_given 0 1 36 191</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the rotation was specified via a quaternion, false</span>
 <span class="s0">* otherwise.  If this is true, get_quat() will be exactly as set; otherwise,</span>
 <span class="s0">* it will return a computed value.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool TransformState::quat_given(void) const;</span>

<span class="s0">1922 7 has_pos 0 4 3576 23 TransformState::has_pos 0 1 37 194</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform's pos component can be extracted out</span>
 <span class="s0">* separately.  This is generally always true, unless the transform is invalid</span>
 <span class="s0">* (i.e.  is_invalid() returns true).</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool TransformState::has_pos(void) const;</span>

<span class="s0">1923 7 has_hpr 0 4 3576 23 TransformState::has_hpr 0 1 38 199</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform's rotation component can be extracted out</span>
 <span class="s0">* separately and described as a set of Euler angles.  This is generally true</span>
 <span class="s0">* only when has_components() is true.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool TransformState::has_hpr(void) const;</span>

<span class="s0">1924 8 has_quat 0 4 3576 24 TransformState::has_quat 0 1 39 190</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform's rotation component can be extracted out</span>
 <span class="s0">* separately and described as a quaternion.  This is generally true only when</span>
 <span class="s0">* has_components() is true.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool TransformState::has_quat(void) const;</span>

<span class="s0">1925 9 has_scale 0 4 3576 25 TransformState::has_scale 0 1 40 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform's scale component can be extracted out</span>
 <span class="s0">* separately.  This is generally true only when has_components() is true.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool TransformState::has_scale(void) const;</span>

<span class="s0">1926 18 has_identity_scale 0 4 3576 34 TransformState::has_identity_scale 0 1 41 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the scale is uniform 1.0, or false if the scale has some</span>
 <span class="s0">* real value.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool TransformState::has_identity_scale(void) const;</span>

<span class="s0">1927 17 has_uniform_scale 0 4 3576 33 TransformState::has_uniform_scale 0 1 42 201</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the scale is uniform across all three axes (and therefore</span>
 <span class="s0">* can be expressed as a single number), or false if the transform has a</span>
 <span class="s0">* different scale in different dimensions.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool TransformState::has_uniform_scale(void) const;</span>

<span class="s0">1928 9 has_shear 0 4 3576 25 TransformState::has_shear 0 1 43 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform's shear component can be extracted out</span>
 <span class="s0">* separately.  This is generally true only when has_components() is true.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool TransformState::has_shear(void) const;</span>

<span class="s0">1929 17 has_nonzero_shear 0 4 3576 33 TransformState::has_nonzero_shear 0 1 44 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the shear component is non-zero, false if it is zero or if</span>
 <span class="s0">* the matrix cannot be decomposed.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool TransformState::has_nonzero_shear(void) const;</span>

<span class="s0">1930 7 has_mat 0 4 3576 23 TransformState::has_mat 0 1 45 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the transform can be described as a matrix.  This is</span>
 <span class="s0">* generally always true, unless is_invalid() is true.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool TransformState::has_mat(void) const;</span>

<span class="s0">1931 7 get_pos 0 4 3576 23 TransformState::get_pos 0 1 46 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pos component of the transform.  It is an error to call this if</span>
 <span class="s0">* has_pos() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LPoint3 const &amp;TransformState::get_pos(void) const;</span>

<span class="s0">1932 7 get_hpr 0 4 3576 23 TransformState::get_hpr 0 1 47 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the rotation component of the transform as a trio of Euler angles.</span>
 <span class="s0">* It is an error to call this if has_components() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase3 const &amp;TransformState::get_hpr(void) const;</span>

<span class="s0">1933 8 get_quat 0 4 3576 24 TransformState::get_quat 0 1 48 412</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the rotation component of the transform as a quaternion.  The</span>
 <span class="s0">* return value will be normalized if a normalized quaternion was given to the</span>
 <span class="s0">* constructor (or if the quaternion was computed implicitly); it will be non-</span>
 <span class="s0">* normalized if a non-normalized quaternion was given to the constructor.</span>
 <span class="s0">* See also get_norm_quat().</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error to call this if has_components() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LQuaternion const &amp;TransformState::get_quat(void) const;</span>

<span class="s0">1934 13 get_norm_quat 0 4 3576 29 TransformState::get_norm_quat 0 1 49 247</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the rotation component of the transform as a quaternion.  Unlike</span>
 <span class="s0">* the result of get_quat(), the return value of this method is guaranteed to</span>
 <span class="s0">* be normalized.  It is an error to call this if has_components() returned</span>
 <span class="s0">* false.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LQuaternion const &amp;TransformState::get_norm_quat(void) const;</span>

<span class="s0">1935 9 get_scale 0 4 3576 25 TransformState::get_scale 0 1 50 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scale component of the transform.  It is an error to call this</span>
 <span class="s0">* if has_components() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase3 const &amp;TransformState::get_scale(void) const;</span>

<span class="s0">1936 17 get_uniform_scale 0 4 3576 33 TransformState::get_uniform_scale 0 1 51 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scale component of the transform, as a single number.  It is an</span>
 <span class="s0">* error to call this if has_uniform_scale() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline PN_stdfloat TransformState::get_uniform_scale(void) const;</span>

<span class="s0">1937 9 get_shear 0 4 3576 25 TransformState::get_shear 0 1 52 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the shear component of the transform.  It is an error to call this</span>
 <span class="s0">* if has_components() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LVecBase3 const &amp;TransformState::get_shear(void) const;</span>

<span class="s0">1938 7 get_mat 0 4 3576 23 TransformState::get_mat 0 1 53 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the matrix that describes the transform.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline LMatrix4 const &amp;TransformState::get_mat(void) const;</span>

<span class="s0">1939 9 get_pos2d 0 4 3576 25 TransformState::get_pos2d 0 1 54 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pos component of the 2-d transform.  It is an error to call</span>
 <span class="s0">* this if has_pos() or is_2d() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline LVecBase2 TransformState::get_pos2d(void) const;</span>

<span class="s0">1940 12 get_rotate2d 0 4 3576 28 TransformState::get_rotate2d 0 1 55 195</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the rotation component of the 2-d transform as an angle in degrees</span>
 <span class="s0">* clockwise about the origin.  It is an error to call this if</span>
 <span class="s0">* has_components() or is_2d() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PN_stdfloat TransformState::get_rotate2d(void) const;</span>

<span class="s0">1941 11 get_scale2d 0 4 3576 27 TransformState::get_scale2d 0 1 56 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scale component of the 2-d transform.  It is an error to call</span>
 <span class="s0">* this if has_components() or is_2d() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline LVecBase2 TransformState::get_scale2d(void) const;</span>

<span class="s0">1942 11 get_shear2d 0 4 3576 27 TransformState::get_shear2d 0 1 57 139</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the shear component of the 2-d transform.  It is an error to call</span>
 <span class="s0">* this if has_components() or is_2d() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PN_stdfloat TransformState::get_shear2d(void) const;</span>

<span class="s0">1943 8 get_mat3 0 4 3576 24 TransformState::get_mat3 0 1 58 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 3x3 matrix that describes the 2-d transform.  It is an error to</span>
 <span class="s0">* call this if is_2d() returned false.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline LMatrix3 TransformState::get_mat3(void) const;</span>

<span class="s0">1944 7 set_pos 0 4 3576 23 TransformState::set_pos 0 1 59 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its pos component replaced with the indicated value.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_pos(LVecBase3 const &amp;pos) const;</span>

<span class="s0">1945 7 set_hpr 0 4 3576 23 TransformState::set_hpr 0 1 60 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its rotation component replaced with the indicated</span>
 <span class="s0">* value, if possible.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_hpr(LVecBase3 const &amp;hpr) const;</span>

<span class="s0">1946 8 set_quat 0 4 3576 24 TransformState::set_quat 0 1 61 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its rotation component replaced with the indicated</span>
 <span class="s0">* value, if possible.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_quat(LQuaternion const &amp;quat) const;</span>

<span class="s0">1947 9 set_scale 0 4 3576 25 TransformState::set_scale 0 1 62 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its scale component replaced with the indicated value,</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_scale(LVecBase3 const &amp;scale) const;</span>

<span class="s0">1948 9 set_shear 0 4 3576 25 TransformState::set_shear 0 1 63 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its shear component replaced with the indicated value,</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_shear(LVecBase3 const &amp;shear) const;</span>

<span class="s0">1949 9 set_pos2d 0 4 3576 25 TransformState::set_pos2d 0 1 64 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original 2-d</span>
 <span class="s0">* TransformState with its pos component replaced with the indicated value.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_pos2d(LVecBase2 const &amp;pos) const;</span>

<span class="s0">1950 12 set_rotate2d 0 4 3576 28 TransformState::set_rotate2d 0 1 65 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original 2-d</span>
 <span class="s0">* TransformState with its rotation component replaced with the indicated</span>
 <span class="s0">* value, if possible.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_rotate2d(PN_stdfloat rotate) const;</span>

<span class="s0">1951 11 set_scale2d 0 4 3576 27 TransformState::set_scale2d 0 1 66 173</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original 2-d</span>
 <span class="s0">* TransformState with its scale component replaced with the indicated value,</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_scale2d(LVecBase2 const &amp;scale) const;</span>

<span class="s0">1952 11 set_shear2d 0 4 3576 27 TransformState::set_shear2d 0 1 67 173</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the original 2-d</span>
 <span class="s0">* TransformState with its shear component replaced with the indicated value,</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::set_shear2d(PN_stdfloat shear) const;</span>

<span class="s0">1953 7 compose 0 4 3576 23 TransformState::compose 0 1 68 408</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the composition of this</span>
 <span class="s0">* state with the other state.</span>
 <span class="s0">*</span>
 <span class="s0">* The result of this operation is cached, and will be retained as long as</span>
 <span class="s0">* both this TransformState object and the other TransformState object</span>
 <span class="s0">* continue to exist.  Should one of them destruct, the cached entry will be</span>
 <span class="s0">* removed, and its pointer will be allowed to destruct as well.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::compose(TransformState const *other) const;</span>

<span class="s0">1954 14 invert_compose 0 4 3576 30 TransformState::invert_compose 0 1 69 268</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TransformState object that represents the composition of this</span>
 <span class="s0">* state's inverse with the other state.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to compose(), but is particularly useful for computing the</span>
 <span class="s0">* relative state of a node as viewed from some other node.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TransformState::invert_compose(TransformState const *other) const;</span>

<span class="s0">1955 11 get_inverse 0 4 3576 27 TransformState::get_inverse 0 1 70 199</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the inverse of this transform.  If you are going to immediately</span>
 <span class="s0">* compose this result with another TransformState, it is faster to do it in</span>
 <span class="s0">* one operation with invert_compose().</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline ConstPointerTo&lt; TransformState &gt; TransformState::get_inverse(void) const;</span>

<span class="s0">1956 10 get_unique 0 4 3576 26 TransformState::get_unique 0 1 71 331</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the unique TransformState in the cache that is</span>
 <span class="s0">* equivalent to this one.  This may be the same pointer as this object, or it</span>
 <span class="s0">* may be a different pointer; but it will be an equivalent object, and it</span>
 <span class="s0">* will be a shared pointer.  This may be called from time to time to improve</span>
 <span class="s0">* cache benefits.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline ConstPointerTo&lt; TransformState &gt; TransformState::get_unique(void) const;</span>

<span class="s0">1957 18 get_geom_rendering 0 4 3576 34 TransformState::get_geom_rendering 0 1 72 261</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this TransformState is applied to a geom which includes the indicated</span>
 <span class="s0">* geom_rendering bits.  The RenderState's get_geom_rendering() should already</span>
 <span class="s0">* have been applied.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline int TransformState::get_geom_rendering(int geom_rendering) const;</span>

<span class="s0">1958 9 cache_ref 0 4 3576 25 TransformState::cache_ref 0 1 73 64</span>
<span class="s0">/**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void TransformState::cache_ref(void) const;</span>

<span class="s0">1959 11 cache_unref 0 4 3576 27 TransformState::cache_unref 0 1 74 64</span>
<span class="s0">/**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool TransformState::cache_unref(void) const;</span>

<span class="s0">1960 8 node_ref 0 4 3576 24 TransformState::node_ref 0 1 75 64</span>
<span class="s0">/**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void TransformState::node_ref(void) const;</span>

<span class="s0">1961 10 node_unref 0 4 3576 26 TransformState::node_unref 0 1 76 64</span>
<span class="s0">/**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool TransformState::node_unref(void) const;</span>

<span class="s0">1962 33 get_composition_cache_num_entries 0 4 3576 49 TransformState::get_composition_cache_num_entries 0 1 77 278</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of entries in the composition cache for this</span>
 <span class="s0">* TransformState.  This is the number of other TransformStates whose</span>
 <span class="s0">* composition with this one has been cached.  This number is not useful for</span>
 <span class="s0">* any practical reason other than performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline std::size_t TransformState::get_composition_cache_num_entries(void) const;</span>

<span class="s0">1963 40 get_invert_composition_cache_num_entries 0 4 3576 56 TransformState::get_invert_composition_cache_num_entries 0 1 78 256</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of entries in the invert_composition cache for this</span>
 <span class="s0">* TransformState.  This is similar to the composition cache, but it records</span>
 <span class="s0">* cache entries for the invert_compose() operation.  See</span>
 <span class="s0">* get_composition_cache_num_entries().</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">inline std::size_t TransformState::get_invert_composition_cache_num_entries(void) const;</span>

<span class="s0">1964 26 get_composition_cache_size 0 4 3576 42 TransformState::get_composition_cache_size 0 1 79 337</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of slots in the composition cache for this</span>
 <span class="s0">* TransformState.  You may use this as an upper bound when walking through</span>
 <span class="s0">* all of the composition cache results via get_composition_cache_source() or</span>
 <span class="s0">* result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline std::size_t TransformState::get_composition_cache_size(void) const;</span>

<span class="s0">1965 28 get_composition_cache_source 0 4 3576 44 TransformState::get_composition_cache_source 0 1 80 303</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the source TransformState of the nth element in the composition</span>
 <span class="s0">* cache.  Returns NULL if there doesn't happen to be an entry in the nth</span>
 <span class="s0">* element.  See get_composition_cache_result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline TransformState const *TransformState::get_composition_cache_source(std::size_t n) const;</span>

<span class="s0">1966 28 get_composition_cache_result 0 4 3576 44 TransformState::get_composition_cache_result 0 1 81 373</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the result TransformState of the nth element in the composition</span>
 <span class="s0">* cache.  Returns NULL if there doesn't happen to be an entry in the nth</span>
 <span class="s0">* element.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a-&gt;compose(a-&gt;get_composition_cache_source(n)) ==</span>
 <span class="s0">* a-&gt;get_composition_cache_result(n).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline TransformState const *TransformState::get_composition_cache_result(std::size_t n) const;</span>

<span class="s0">1967 33 get_invert_composition_cache_size 0 4 3576 49 TransformState::get_invert_composition_cache_size 0 1 82 344</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of slots in the composition cache for this</span>
 <span class="s0">* TransformState.  You may use this as an upper bound when walking through</span>
 <span class="s0">* all of the composition cache results via</span>
 <span class="s0">* get_invert_composition_cache_source() or result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline std::size_t TransformState::get_invert_composition_cache_size(void) const;</span>

<span class="s0">1968 35 get_invert_composition_cache_source 0 4 3576 51 TransformState::get_invert_composition_cache_source 0 1 83 317</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the source TransformState of the nth element in the invert</span>
 <span class="s0">* composition cache.  Returns NULL if there doesn't happen to be an entry in</span>
 <span class="s0">* the nth element.  See get_invert_composition_cache_result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline TransformState const *TransformState::get_invert_composition_cache_source(std::size_t n) const;</span>

<span class="s0">1969 35 get_invert_composition_cache_result 0 4 3576 51 TransformState::get_invert_composition_cache_result 0 1 84 401</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the result TransformState of the nth element in the invert</span>
 <span class="s0">* composition cache.  Returns NULL if there doesn't happen to be an entry in</span>
 <span class="s0">* the nth element.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a-&gt;invert_compose(a-&gt;get_invert_composition_cache_source(n)) ==</span>
 <span class="s0">* a-&gt;get_invert_composition_cache_result(n).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline TransformState const *TransformState::get_invert_composition_cache_result(std::size_t n) const;</span>

<span class="s0">1970 26 validate_composition_cache 0 4 3576 42 TransformState::validate_composition_cache 0 1 85 163</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the composition cache and invert composition cache for this</span>
 <span class="s0">* particular TransformState are self-consistent and valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool TransformState::validate_composition_cache(void) const;</span>

<span class="s0">1971 21 get_composition_cache 0 4 3576 37 TransformState::get_composition_cache 0 1 86 0</span>
<span class="s0">60</span>
<span class="s0">PyObject *TransformState::get_composition_cache(void) const;</span>

<span class="s0">1972 28 get_invert_composition_cache 0 4 3576 44 TransformState::get_invert_composition_cache 0 1 87 0</span>
<span class="s0">67</span>
<span class="s0">PyObject *TransformState::get_invert_composition_cache(void) const;</span>

<span class="s0">1973 6 output 0 4 3576 22 TransformState::output 0 1 88 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void TransformState::output(std::ostream &amp;out) const;</span>

<span class="s0">1974 5 write 0 4 3576 21 TransformState::write 0 1 89 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void TransformState::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">1975 23 write_composition_cache 0 4 3576 39 TransformState::write_composition_cache 0 1 90 208</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief description of the composition cache and invert composition</span>
 <span class="s0">* cache to the indicated ostream.  This is not useful except for performance</span>
 <span class="s0">* analysis, to examine the cache structure.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">void TransformState::write_composition_cache(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">1976 14 get_num_states 0 4 3576 30 TransformState::get_num_states 0 1 91 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of unique TransformState objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">static int TransformState::get_num_states(void);</span>

<span class="s0">1977 21 get_num_unused_states 0 4 3576 37 TransformState::get_num_unused_states 0 1 92 612</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of TransformState objects that have been allocated</span>
 <span class="s0">* but have no references outside of the internal TransformState cache.</span>
 <span class="s0">*</span>
 <span class="s0">* A nonzero return value is not necessarily indicative of leaked references;</span>
 <span class="s0">* it is normal for two TransformState objects, both of which have references</span>
 <span class="s0">* held outside the cache, to have the result of their composition stored</span>
 <span class="s0">* within the cache.  This result will be retained within the cache until one</span>
 <span class="s0">* of the base TransformStates is released.</span>
 <span class="s0">*</span>
 <span class="s0">* Use list_cycles() to get an idea of the number of actual &quot;leaked&quot;</span>
 <span class="s0">* TransformState objects.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static int TransformState::get_num_unused_states(void);</span>

<span class="s0">1978 11 clear_cache 0 4 3576 27 TransformState::clear_cache 0 1 93 617</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the cache of composed TransformStates.  This makes every</span>
 <span class="s0">* TransformState forget what results when it is composed with other</span>
 <span class="s0">* TransformStates.</span>
 <span class="s0">*</span>
 <span class="s0">* This will eliminate any TransformState objects that have been allocated but</span>
 <span class="s0">* have no references outside of the internal TransformState map.  It will not</span>
 <span class="s0">* eliminate TransformState objects that are still in use.</span>
 <span class="s0">*</span>
 <span class="s0">* Nowadays, this method should not be necessary, as reference-count cycles in</span>
 <span class="s0">* the composition cache should be automatically detected and broken.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the number of TransformStates freed by this operation.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static int TransformState::clear_cache(void);</span>

<span class="s0">1979 15 garbage_collect 0 4 3576 31 TransformState::garbage_collect 0 1 94 297</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a garbage-collection cycle.  This must be called periodically if</span>
 <span class="s0">* garbage-collect-states is true to ensure that TransformStates get cleaned</span>
 <span class="s0">* up appropriately.  It does no harm to call it even if this variable is not</span>
 <span class="s0">* true, but there is probably no advantage in that case.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static int TransformState::garbage_collect(void);</span>

<span class="s0">1980 11 list_cycles 0 4 3576 27 TransformState::list_cycles 0 1 95 565</span>
<span class="s0">/**</span>
 <span class="s0">* Detects all of the reference-count cycles in the cache and reports them to</span>
 <span class="s0">* standard output.</span>
 <span class="s0">*</span>
 <span class="s0">* These cycles may be inadvertently created when state compositions cycle</span>
 <span class="s0">* back to a starting point.  Nowadays, these cycles should be automatically</span>
 <span class="s0">* detected and broken, so this method should never list any cycles unless</span>
 <span class="s0">* there is a bug in that detection logic.</span>
 <span class="s0">*</span>
 <span class="s0">* The cycles listed here are not leaks in the strictest sense of the word,</span>
 <span class="s0">* since they can be reclaimed by a call to clear_cache(); but they will not</span>
 <span class="s0">* be reclaimed automatically.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">static void TransformState::list_cycles(std::ostream &amp;out);</span>

<span class="s0">1981 11 list_states 0 4 3576 27 TransformState::list_states 0 1 96 172</span>
<span class="s0">/**</span>
 <span class="s0">* Lists all of the TransformStates in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">static void TransformState::list_states(std::ostream &amp;out);</span>

<span class="s0">1982 15 validate_states 0 4 3576 31 TransformState::validate_states 0 1 97 282</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order, and that none of</span>
 <span class="s0">* the cache elements have been inadvertently deleted.  Returns true if so,</span>
 <span class="s0">* false if there is a problem (which implies someone has modified one of the</span>
 <span class="s0">* supposedly-const TransformState objects).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static bool TransformState::validate_states(void);</span>

<span class="s0">1983 10 get_states 0 4 3576 26 TransformState::get_states 0 1 98 0</span>
<span class="s0">50</span>
<span class="s0">static PyObject *TransformState::get_states(void);</span>

<span class="s0">1984 17 get_unused_states 0 4 3576 33 TransformState::get_unused_states 0 1 99 0</span>
<span class="s0">57</span>
<span class="s0">static PyObject *TransformState::get_unused_states(void);</span>

<span class="s0">1985 14 get_class_type 0 4 3576 30 TransformState::get_class_type 0 1 100 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle TransformState::get_class_type(void);</span>

<span class="s0">1986 8 get_slot 0 4 3590 30 RenderAttribRegistry::get_slot 0 1 101 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the slot number assigned to the indicated TypeHandle, or 0 if no</span>
 <span class="s0">* slot number has been assigned.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline int RenderAttribRegistry::get_slot(TypeHandle type_handle) const;</span>

<span class="s0">1987 13 get_max_slots 0 4 3590 35 RenderAttribRegistry::get_max_slots 0 1 102 0</span>
<span class="s0">63</span>
<span class="s0">static constexpr int RenderAttribRegistry::get_max_slots(void);</span>

<span class="s0">1988 13 get_num_slots 0 4 3590 35 RenderAttribRegistry::get_num_slots 0 1 103 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of RenderAttrib slots that have been allocated.  This is</span>
 <span class="s0">* one more than the highest slot number in use.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int RenderAttribRegistry::get_num_slots(void) const;</span>

<span class="s0">1989 13 get_slot_type 0 4 3590 35 RenderAttribRegistry::get_slot_type 0 1 104 57</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the TypeHandle associated with slot n.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline TypeHandle RenderAttribRegistry::get_slot_type(int slot) const;</span>

<span class="s0">1990 13 get_slot_sort 0 4 3590 35 RenderAttribRegistry::get_slot_sort 0 1 105 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sort number associated with slot n.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int RenderAttribRegistry::get_slot_sort(int slot) const;</span>

<span class="s0">1991 13 set_slot_sort 0 4 3590 35 RenderAttribRegistry::set_slot_sort 0 1 106 58</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the sort number associated with slot n.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void RenderAttribRegistry::set_slot_sort(int slot, int sort);</span>

<span class="s0">1992 16 get_slot_default 0 4 3590 38 RenderAttribRegistry::get_slot_default 0 1 107 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default RenderAttrib object associated with slot n.  This is</span>
 <span class="s0">* the attrib that should be applied in the absence of any other attrib of</span>
 <span class="s0">* this type.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline RenderAttrib const *RenderAttribRegistry::get_slot_default(int slot) const;</span>

<span class="s0">1993 20 get_num_sorted_slots 0 4 3590 42 RenderAttribRegistry::get_num_sorted_slots 0 1 108 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of entries in the sorted_slots list.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline int RenderAttribRegistry::get_num_sorted_slots(void) const;</span>

<span class="s0">1994 15 get_sorted_slot 0 4 3590 37 RenderAttribRegistry::get_sorted_slot 0 1 109 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth slot in sorted order.  By traversing this list, you will</span>
 <span class="s0">* retrieve all the slot numbers in order according to their registered sort</span>
 <span class="s0">* value.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int RenderAttribRegistry::get_sorted_slot(int n) const;</span>

<span class="s0">1995 14 get_global_ptr 0 4 3590 36 RenderAttribRegistry::get_global_ptr 0 1 110 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">static inline RenderAttribRegistry *RenderAttribRegistry::get_global_ptr(void);</span>

<span class="s0">1996 7 compose 0 4 3591 21 RenderAttrib::compose 0 1 111 322</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderAttrib object that represents the composition of this</span>
 <span class="s0">* attrib with the other attrib.  In most cases, this is the same as the other</span>
 <span class="s0">* attrib; a compose b produces b.  Some kinds of attributes, like a</span>
 <span class="s0">* TextureTransform, for instance, might produce a new result: a compose b</span>
 <span class="s0">* produces c.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline ConstPointerTo&lt; RenderAttrib &gt; RenderAttrib::compose(RenderAttrib const *other) const;</span>

<span class="s0">1997 14 invert_compose 0 4 3591 28 RenderAttrib::invert_compose 0 1 112 583</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderAttrib object that represents the composition of the</span>
 <span class="s0">* inverse of this attrib with the other attrib.  In most cases, this is the</span>
 <span class="s0">* same as the other attrib; !a compose b produces b.  Some kinds of</span>
 <span class="s0">* attributes, like a TextureTransform, for instance, might produce a new</span>
 <span class="s0">* result: !a compose b produces c.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to compose() except that the source attrib is inverted</span>
 <span class="s0">* first.  This is used to compute the relative attribute for one node as</span>
 <span class="s0">* viewed from some other node, which is especially useful for transform-type</span>
 <span class="s0">* attributes.</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">inline ConstPointerTo&lt; RenderAttrib &gt; RenderAttrib::invert_compose(RenderAttrib const *other) const;</span>

<span class="s0">1998 25 lower_attrib_can_override 0 6 3591 39 RenderAttrib::lower_attrib_can_override 0 1 113 951</span>
<span class="s0">/**</span>
 <span class="s0">* Intended to be overridden by derived RenderAttrib types to specify how two</span>
 <span class="s0">* consecutive RenderAttrib objects of the same type interact.</span>
 <span class="s0">*</span>
 <span class="s0">* This should return false if a RenderAttrib on a higher node will compose</span>
 <span class="s0">* into a RenderAttrib on a lower node that has a higher override value, or</span>
 <span class="s0">* true if the lower RenderAttrib will completely replace the state.</span>
 <span class="s0">*</span>
 <span class="s0">* The default behavior is false: normally, a RenderAttrib in the graph cannot</span>
 <span class="s0">* completely override a RenderAttrib above it, regardless of its override</span>
 <span class="s0">* value--instead, the two attribs are composed.  But for some kinds of</span>
 <span class="s0">* RenderAttribs, it is useful to allow this kind of override.</span>
 <span class="s0">*</span>
 <span class="s0">* This method only handles the one special case of a lower RenderAttrib with</span>
 <span class="s0">* a higher override value.  If the higher RenderAttrib has a higher override</span>
 <span class="s0">* value, it always completely overrides.  And if both RenderAttribs have the</span>
 <span class="s0">* same override value, they are always composed.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">virtual bool RenderAttrib::lower_attrib_can_override(void) const;</span>

<span class="s0">1999 10 compare_to 0 4 3591 24 RenderAttrib::compare_to 0 1 114 368</span>
<span class="s0">/**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique RenderAttribs, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not needed outside of the RenderAttrib class because all</span>
 <span class="s0">* equivalent RenderAttrib objects are guaranteed to share the same pointer;</span>
 <span class="s0">* thus, a pointer comparison is always sufficient.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline int RenderAttrib::compare_to(RenderAttrib const &amp;other) const;</span>

<span class="s0">2000 8 get_hash 0 4 3591 22 RenderAttrib::get_hash 0 1 115 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash value for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline std::size_t RenderAttrib::get_hash(void) const;</span>

<span class="s0">2001 10 get_unique 0 4 3591 24 RenderAttrib::get_unique 0 1 116 329</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the unique RenderAttrib in the cache that is</span>
 <span class="s0">* equivalent to this one.  This may be the same pointer as this object, or it</span>
 <span class="s0">* may be a different pointer; but it will be an equivalent object, and it</span>
 <span class="s0">* will be a shared pointer.  This may be called from time to time to improve</span>
 <span class="s0">* cache benefits.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline ConstPointerTo&lt; RenderAttrib &gt; RenderAttrib::get_unique(void) const;</span>

<span class="s0">2002 6 output 0 6 3591 20 RenderAttrib::output 0 1 117 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual void RenderAttrib::output(std::ostream &amp;out) const;</span>

<span class="s0">2003 5 write 0 6 3591 19 RenderAttrib::write 0 1 118 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">virtual void RenderAttrib::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2004 15 get_num_attribs 0 4 3591 29 RenderAttrib::get_num_attribs 0 1 119 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of unique RenderAttrib objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static int RenderAttrib::get_num_attribs(void);</span>

<span class="s0">2005 12 list_attribs 0 4 3591 26 RenderAttrib::list_attribs 0 1 120 170</span>
<span class="s0">/**</span>
 <span class="s0">* Lists all of the RenderAttribs in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static void RenderAttrib::list_attribs(std::ostream &amp;out);</span>

<span class="s0">2006 15 garbage_collect 0 4 3591 29 RenderAttrib::garbage_collect 0 1 121 155</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a garbage-collection cycle.  This is called automatically from</span>
 <span class="s0">* RenderState::garbage_collect(); see that method for more information.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static int RenderAttrib::garbage_collect(void);</span>

<span class="s0">2007 16 validate_attribs 0 4 3591 30 RenderAttrib::validate_attribs 0 1 122 208</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order.  Returns true if</span>
 <span class="s0">* so, false if there is a problem (which implies someone has modified one of</span>
 <span class="s0">* the supposedly-const RenderAttrib objects).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static bool RenderAttrib::validate_attribs(void);</span>

<span class="s0">2008 8 get_slot 0 6 3591 22 RenderAttrib::get_slot 0 1 123 0</span>
<span class="s0">51</span>
<span class="s0">virtual int RenderAttrib::get_slot(void) const = 0;</span>

<span class="s0">2009 14 get_class_type 0 4 3591 28 RenderAttrib::get_class_type 0 1 124 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle RenderAttrib::get_class_type(void);</span>

<span class="s0">2010 4 make 0 4 3596 22 RenderModeAttrib::make 0 1 125 921</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new RenderModeAttrib object that specifies whether to draw</span>
 <span class="s0">* polygons in the normal, filled mode, or wireframe mode, or in some other</span>
 <span class="s0">* yet-to-be-defined mode.</span>
 <span class="s0">*</span>
 <span class="s0">* The thickness parameter specifies the thickness to be used for wireframe</span>
 <span class="s0">* lines, as well as for ordinary linestrip lines; it also specifies the</span>
 <span class="s0">* diameter of points.  (Thick lines are presently only supported in OpenGL;</span>
 <span class="s0">* but thick points are supported on either platform.)</span>
 <span class="s0">*</span>
 <span class="s0">* If perspective is true, the point thickness represented is actually a width</span>
 <span class="s0">* in 3-d units, and the points should scale according to perspective.  When</span>
 <span class="s0">* it is false, the point thickness is actually a width in pixels, and points</span>
 <span class="s0">* are a uniform screen size regardless of distance from the camera.</span>
 <span class="s0">*</span>
 <span class="s0">* In M_filled_wireframe mode, you should also specify the wireframe_color,</span>
 <span class="s0">* indicating the flat color to assign to the overlayed wireframe.</span>
 <span class="s0">*/</span>
<span class="s0">193</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; RenderModeAttrib::make(RenderModeAttrib::Mode mode, PN_stdfloat thickness = 1.0, bool perspective = false, LColor const &amp;wireframe_color = LColor::zero());</span>

<span class="s0">2011 12 make_default 0 4 3596 30 RenderModeAttrib::make_default 0 1 126 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; RenderModeAttrib::make_default(void);</span>

<span class="s0">2012 8 get_mode 0 4 3596 26 RenderModeAttrib::get_mode 0 1 127 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the render mode.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline RenderModeAttrib::Mode RenderModeAttrib::get_mode(void) const;</span>

<span class="s0">2013 13 get_thickness 0 4 3596 31 RenderModeAttrib::get_thickness 0 1 128 235</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the line width or point thickness.  This is only relevant when</span>
 <span class="s0">* rendering points or lines, such as when the mode is M_wireframe or M_point</span>
 <span class="s0">* (or when rendering actual points or lines primitives in M_polygon mode).</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline PN_stdfloat RenderModeAttrib::get_thickness(void) const;</span>

<span class="s0">2014 15 get_perspective 0 4 3596 33 RenderModeAttrib::get_perspective 0 1 129 364</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the perspective flag.  When this is true, the point thickness</span>
 <span class="s0">* represented by get_thickness() is actually a width in 3-d units, and the</span>
 <span class="s0">* points should scale according to perspective.  When it is false, the</span>
 <span class="s0">* default, the point thickness is actually a width in pixels, and points are</span>
 <span class="s0">* a uniform size regardless of distance from the camera.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool RenderModeAttrib::get_perspective(void) const;</span>

<span class="s0">2015 19 get_wireframe_color 0 4 3596 37 RenderModeAttrib::get_wireframe_color 0 1 130 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color that is used in M_filled_wireframe mode to distinguish</span>
 <span class="s0">* the wireframe from the rest of the geometry.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline LColor const &amp;RenderModeAttrib::get_wireframe_color(void) const;</span>

<span class="s0">2016 18 get_geom_rendering 0 4 3596 36 RenderModeAttrib::get_geom_rendering 0 1 131 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this RenderModeAttrib is applied to a geom which includes the</span>
 <span class="s0">* indicated geom_rendering bits.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline int RenderModeAttrib::get_geom_rendering(int geom_rendering) const;</span>

<span class="s0">2017 14 get_class_slot 0 4 3596 32 RenderModeAttrib::get_class_slot 0 1 132 0</span>
<span class="s0">50</span>
<span class="s0">static int RenderModeAttrib::get_class_slot(void);</span>

<span class="s0">2018 14 get_class_type 0 4 3596 32 RenderModeAttrib::get_class_type 0 1 133 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle RenderModeAttrib::get_class_type(void);</span>

<span class="s0">2019 17 ~RenderModeAttrib 0 516 3596 35 RenderModeAttrib::~RenderModeAttrib 0 0 0</span>
<span class="s0">42</span>
<span class="s0">RenderModeAttrib::~RenderModeAttrib(void);</span>

<span class="s0">2020 4 make 0 4 3605 21 TexMatrixAttrib::make 0 3 134 135 136 391</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a TexMatrixAttrib that applies no stages at all.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a TexMatrixAttrib that applies the indicated matrix to the</span>
 <span class="s0">* default texture stage.  This interface is deprecated.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use the constructor that takes a TextureStage instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a TexMatrixAttrib that applies the indicated transform to the</span>
 <span class="s0">* named texture stage.</span>
 <span class="s0">*/</span>
<span class="s0">263</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TexMatrixAttrib::make(void);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TexMatrixAttrib::make(LMatrix4 const &amp;mat);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TexMatrixAttrib::make(TextureStage *stage, TransformState const *transform);</span>

<span class="s0">2021 12 make_default 0 4 3605 29 TexMatrixAttrib::make_default 0 1 137 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TexMatrixAttrib::make_default(void);</span>

<span class="s0">2022 9 add_stage 0 4 3605 26 TexMatrixAttrib::add_stage 0 1 138 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TexMatrixAttrib just like this one, with the indicated</span>
 <span class="s0">* transform for the given stage.  If this stage already exists, its transform</span>
 <span class="s0">* is replaced.</span>
 <span class="s0">*/</span>
<span class="s0">136</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TexMatrixAttrib::add_stage(TextureStage *stage, TransformState const *transform, int override = 0) const;</span>

<span class="s0">2023 12 remove_stage 0 4 3605 29 TexMatrixAttrib::remove_stage 0 1 139 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TexMatrixAttrib just like this one, with the indicated stage</span>
 <span class="s0">* removed.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TexMatrixAttrib::remove_stage(TextureStage *stage) const;</span>

<span class="s0">2024 8 is_empty 0 4 3605 25 TexMatrixAttrib::is_empty 0 1 140 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if no stages are defined in the TexMatrixAttrib, false if at</span>
 <span class="s0">* least one is.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">bool TexMatrixAttrib::is_empty(void) const;</span>

<span class="s0">2025 9 has_stage 0 4 3605 26 TexMatrixAttrib::has_stage 0 1 141 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a transform associated with the indicated stage,</span>
 <span class="s0">* or false otherwise (in which case get_transform(stage) will return the</span>
 <span class="s0">* identity transform).</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">bool TexMatrixAttrib::has_stage(TextureStage *stage) const;</span>

<span class="s0">2026 14 get_num_stages 0 4 3605 31 TexMatrixAttrib::get_num_stages 0 1 142 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of stages that are represented by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int TexMatrixAttrib::get_num_stages(void) const;</span>

<span class="s0">2027 9 get_stage 0 4 3605 26 TexMatrixAttrib::get_stage 0 1 143 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth stage that is represented by this attrib.  The</span>
 <span class="s0">* TextureStages are in no particular order.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">TextureStage *TexMatrixAttrib::get_stage(int n) const;</span>

<span class="s0">2028 7 get_mat 0 4 3605 24 TexMatrixAttrib::get_mat 0 2 144 145 257</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transformation matrix associated with the default texture</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the transformation matrix associated with the indicated texture</span>
 <span class="s0">* stage, or identity matrix if nothing is associated with the indicated</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">LMatrix4 const &amp;TexMatrixAttrib::get_mat(void) const;</span>
<span class="s0">LMatrix4 const &amp;TexMatrixAttrib::get_mat(TextureStage *stage) const;</span>

<span class="s0">2029 13 get_transform 0 4 3605 30 TexMatrixAttrib::get_transform 0 1 146 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transformation associated with the indicated texture stage, or</span>
 <span class="s0">* identity matrix if nothing is associated with the indicated stage.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; TexMatrixAttrib::get_transform(TextureStage *stage) const;</span>

<span class="s0">2030 12 get_override 0 4 3605 29 TexMatrixAttrib::get_override 0 1 147 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the override value associated with the indicated stage.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline int TexMatrixAttrib::get_override(TextureStage *stage) const;</span>

<span class="s0">2031 18 get_geom_rendering 0 4 3605 35 TexMatrixAttrib::get_geom_rendering 0 1 148 185</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this TexMatrixAttrib is applied to a geom which includes the indicated</span>
 <span class="s0">* geom_rendering bits.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline int TexMatrixAttrib::get_geom_rendering(int geom_rendering) const;</span>

<span class="s0">2032 14 get_class_slot 0 4 3605 31 TexMatrixAttrib::get_class_slot 0 1 149 0</span>
<span class="s0">49</span>
<span class="s0">static int TexMatrixAttrib::get_class_slot(void);</span>

<span class="s0">2033 14 get_class_type 0 4 3605 31 TexMatrixAttrib::get_class_type 0 1 150 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle TexMatrixAttrib::get_class_type(void);</span>

<span class="s0">2034 10 compare_to 0 4 3606 23 RenderState::compare_to 0 1 151 365</span>
<span class="s0">/**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique RenderStates, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not needed outside of the RenderState class because all</span>
 <span class="s0">* equivalent RenderState objects are guaranteed to share the same pointer;</span>
 <span class="s0">* thus, a pointer comparison is always sufficient.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">int RenderState::compare_to(RenderState const &amp;other) const;</span>

<span class="s0">2035 12 compare_sort 0 4 3606 25 RenderState::compare_sort 0 1 152 333</span>
<span class="s0">/**</span>
 <span class="s0">* Returns -1, 0, or 1 according to the relative sorting of these two</span>
 <span class="s0">* RenderStates, with regards to rendering performance, so that &quot;heavier&quot;</span>
 <span class="s0">* RenderAttribs (as defined by RenderAttribRegistry::get_slot_sort()) are</span>
 <span class="s0">* more likely to be grouped together.  This is not related to the sorting</span>
 <span class="s0">* order defined by compare_to.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">int RenderState::compare_sort(RenderState const &amp;other) const;</span>

<span class="s0">2036 12 compare_mask 0 4 3606 25 RenderState::compare_mask 0 1 153 191</span>
<span class="s0">/**</span>
 <span class="s0">* This version of compare_to takes a slot mask that indicates which</span>
 <span class="s0">* attributes to include in the comparison.  Unlike compare_to, this method</span>
 <span class="s0">* compares the attributes by pointer.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">int RenderState::compare_mask(RenderState const &amp;other, RenderState::SlotMask compare_mask) const;</span>

<span class="s0">2037 8 get_hash 0 4 3606 21 RenderState::get_hash 0 1 154 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a suitable hash value for phash_map.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::size_t RenderState::get_hash(void) const;</span>

<span class="s0">2038 8 is_empty 0 4 3606 21 RenderState::is_empty 0 1 155 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the state is empty, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool RenderState::is_empty(void) const;</span>

<span class="s0">2039 17 has_cull_callback 0 4 3606 30 RenderState::has_cull_callback 0 1 156 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any of the RenderAttribs in this state request a</span>
 <span class="s0">* cull_callback(), false if none of them do.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool RenderState::has_cull_callback(void) const;</span>

<span class="s0">2040 13 cull_callback 0 4 3606 26 RenderState::cull_callback 0 1 157 183</span>
<span class="s0">/**</span>
 <span class="s0">* Calls cull_callback() on each attrib.  If any attrib returns false,</span>
 <span class="s0">* interrupts the list and returns false immediately; otherwise, completes the</span>
 <span class="s0">* list and returns true.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">bool RenderState::cull_callback(CullTraverser *trav, CullTraverserData const &amp;data) const;</span>

<span class="s0">2041 10 make_empty 0 4 3606 23 RenderState::make_empty 0 1 158 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderState with no attributes set.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline ConstPointerTo&lt; RenderState &gt; RenderState::make_empty(void);</span>

<span class="s0">2042 4 make 0 4 3606 17 RenderState::make 0 5 159 160 161 162 163 353</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderState with one attribute set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a RenderState with two attributes set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a RenderState with three attributes set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a RenderState with four attributes set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a RenderState with five attributes set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a RenderState with n attributes set.</span>
 <span class="s0">*/</span>
<span class="s0">929</span>
<span class="s0">static ConstPointerTo&lt; RenderState &gt; RenderState::make(RenderAttrib const *attrib, int override = 0);</span>
<span class="s0">static ConstPointerTo&lt; RenderState &gt; RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, int override = 0);</span>
<span class="s0">static ConstPointerTo&lt; RenderState &gt; RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, int override = 0);</span>
<span class="s0">static ConstPointerTo&lt; RenderState &gt; RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, int override = 0);</span>
<span class="s0">static ConstPointerTo&lt; RenderState &gt; RenderState::make(RenderAttrib const *attrib1, RenderAttrib const *attrib2, RenderAttrib const *attrib3, RenderAttrib const *attrib4, RenderAttrib const *attrib5, int override = 0);</span>
<span class="s0">static ConstPointerTo&lt; RenderState &gt; RenderState::make(RenderAttrib const *const *attrib, int num_attribs, int override = 0);</span>

<span class="s0">2043 7 compose 0 4 3606 20 RenderState::compose 0 1 164 399</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderState object that represents the composition of this</span>
 <span class="s0">* state with the other state.</span>
 <span class="s0">*</span>
 <span class="s0">* The result of this operation is cached, and will be retained as long as</span>
 <span class="s0">* both this RenderState object and the other RenderState object continue to</span>
 <span class="s0">* exist.  Should one of them destruct, the cached entry will be removed, and</span>
 <span class="s0">* its pointer will be allowed to destruct as well.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; RenderState::compose(RenderState const *other) const;</span>

<span class="s0">2044 14 invert_compose 0 4 3606 27 RenderState::invert_compose 0 1 165 265</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderState object that represents the composition of this</span>
 <span class="s0">* state's inverse with the other state.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to compose(), but is particularly useful for computing the</span>
 <span class="s0">* relative state of a node as viewed from some other node.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; RenderState::invert_compose(RenderState const *other) const;</span>

<span class="s0">2045 10 add_attrib 0 4 3606 23 RenderState::add_attrib 0 1 166 231</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the new RenderAttrib added.  If there is already a RenderAttrib</span>
 <span class="s0">* with the same type, it is replaced (unless the override is lower).</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; RenderState::add_attrib(RenderAttrib const *attrib, int override = 0) const;</span>

<span class="s0">2046 10 set_attrib 0 4 3606 23 RenderState::set_attrib 0 2 167 168 518</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the new RenderAttrib added.  If there is already a RenderAttrib</span>
 <span class="s0">* with the same type, it is replaced unconditionally.  The override is not</span>
 <span class="s0">* changed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the new RenderAttrib added.  If there is already a RenderAttrib</span>
 <span class="s0">* with the same type, it is replaced unconditionally.  The override is also</span>
 <span class="s0">* replaced unconditionally.</span>
 <span class="s0">*/</span>
<span class="s0">191</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; RenderState::set_attrib(RenderAttrib const *attrib) const;</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; RenderState::set_attrib(RenderAttrib const *attrib, int override) const;</span>

<span class="s0">2047 13 remove_attrib 0 4 3606 26 RenderState::remove_attrib 0 2 169 170 268</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the indicated RenderAttrib removed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the indicated RenderAttrib removed.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">inline ConstPointerTo&lt; RenderState &gt; RenderState::remove_attrib(TypeHandle type) const;</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; RenderState::remove_attrib(int slot) const;</span>

<span class="s0">2048 21 adjust_all_priorities 0 4 3606 34 RenderState::adjust_all_priorities 0 1 171 261</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with all attributes' override values incremented (or decremented, if</span>
 <span class="s0">* negative) by the indicated amount.  If the override would drop below zero,</span>
 <span class="s0">* it is set to zero.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; RenderState::adjust_all_priorities(int adjustment) const;</span>

<span class="s0">2049 10 has_attrib 0 4 3606 23 RenderState::has_attrib 0 2 172 173 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if an attrib of the indicated type is present, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if an attrib of the indicated type is present, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">inline bool RenderState::has_attrib(TypeHandle type) const;</span>
<span class="s0">inline bool RenderState::has_attrib(int slot) const;</span>

<span class="s0">2050 10 get_attrib 0 4 3606 23 RenderState::get_attrib 0 2 174 175 253</span>
<span class="s0">/**</span>
 <span class="s0">* Looks for a RenderAttrib of the indicated type in the state, and returns it</span>
 <span class="s0">* if it is found, or NULL if it is not.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the RenderAttrib with the indicated slot index, or NULL if there is</span>
 <span class="s0">* no such RenderAttrib in the state.</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">inline RenderAttrib const *RenderState::get_attrib(TypeHandle type) const;</span>
<span class="s0">inline RenderAttrib const *RenderState::get_attrib(int slot) const;</span>

<span class="s0">2051 14 get_attrib_def 0 4 3606 27 RenderState::get_attrib_def 0 1 176 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the RenderAttrib with the indicated slot index, or the default</span>
 <span class="s0">* attrib for that slot if there is no such RenderAttrib in the state.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline RenderAttrib const *RenderState::get_attrib_def(int slot) const;</span>

<span class="s0">2052 12 get_override 0 4 3606 25 RenderState::get_override 0 2 177 178 282</span>
<span class="s0">/**</span>
 <span class="s0">* Looks for a RenderAttrib of the indicated type in the state, and returns</span>
 <span class="s0">* its override value if it is found, or 0 if it is not.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Looks for a RenderAttrib of the indicated type in the state, and returns</span>
 <span class="s0">* its override value if it is found, or 0 if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline int RenderState::get_override(TypeHandle type) const;</span>
<span class="s0">inline int RenderState::get_override(int slot) const;</span>

<span class="s0">2053 10 get_unique 0 4 3606 23 RenderState::get_unique 0 1 179 328</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the unique RenderState in the cache that is</span>
 <span class="s0">* equivalent to this one.  This may be the same pointer as this object, or it</span>
 <span class="s0">* may be a different pointer; but it will be an equivalent object, and it</span>
 <span class="s0">* will be a shared pointer.  This may be called from time to time to improve</span>
 <span class="s0">* cache benefits.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline ConstPointerTo&lt; RenderState &gt; RenderState::get_unique(void) const;</span>

<span class="s0">2054 9 cache_ref 0 4 3606 22 RenderState::cache_ref 0 1 180 64</span>
<span class="s0">/**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void RenderState::cache_ref(void) const;</span>

<span class="s0">2055 11 cache_unref 0 4 3606 24 RenderState::cache_unref 0 1 181 64</span>
<span class="s0">/**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool RenderState::cache_unref(void) const;</span>

<span class="s0">2056 8 node_ref 0 4 3606 21 RenderState::node_ref 0 1 182 64</span>
<span class="s0">/**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void RenderState::node_ref(void) const;</span>

<span class="s0">2057 10 node_unref 0 4 3606 23 RenderState::node_unref 0 1 183 64</span>
<span class="s0">/**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool RenderState::node_unref(void) const;</span>

<span class="s0">2058 33 get_composition_cache_num_entries 0 4 3606 46 RenderState::get_composition_cache_num_entries 0 1 184 272</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of entries in the composition cache for this</span>
 <span class="s0">* RenderState.  This is the number of other RenderStates whose composition</span>
 <span class="s0">* with this one has been cached.  This number is not useful for any practical</span>
 <span class="s0">* reason other than performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline std::size_t RenderState::get_composition_cache_num_entries(void) const;</span>

<span class="s0">2059 40 get_invert_composition_cache_num_entries 0 4 3606 53 RenderState::get_invert_composition_cache_num_entries 0 1 185 253</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of entries in the invert_composition cache for this</span>
 <span class="s0">* RenderState.  This is similar to the composition cache, but it records</span>
 <span class="s0">* cache entries for the invert_compose() operation.  See</span>
 <span class="s0">* get_composition_cache_num_entries().</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline std::size_t RenderState::get_invert_composition_cache_num_entries(void) const;</span>

<span class="s0">2060 26 get_composition_cache_size 0 4 3606 39 RenderState::get_composition_cache_size 0 1 186 330</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of slots in the composition cache for this RenderState.</span>
 <span class="s0">* You may use this as an upper bound when walking through all of the</span>
 <span class="s0">* composition cache results via get_composition_cache_source() or result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline std::size_t RenderState::get_composition_cache_size(void) const;</span>

<span class="s0">2061 28 get_composition_cache_source 0 4 3606 41 RenderState::get_composition_cache_source 0 1 187 298</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the source RenderState of the nth element in the composition cache.</span>
 <span class="s0">* Returns NULL if there doesn't happen to be an entry in the nth element.</span>
 <span class="s0">* See get_composition_cache_result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline RenderState const *RenderState::get_composition_cache_source(std::size_t n) const;</span>

<span class="s0">2062 28 get_composition_cache_result 0 4 3606 41 RenderState::get_composition_cache_result 0 1 188 366</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the result RenderState of the nth element in the composition cache.</span>
 <span class="s0">* Returns NULL if there doesn't happen to be an entry in the nth element.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a-&gt;compose(a-&gt;get_composition_cache_source(n)) ==</span>
 <span class="s0">* a-&gt;get_composition_cache_result(n).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline RenderState const *RenderState::get_composition_cache_result(std::size_t n) const;</span>

<span class="s0">2063 33 get_invert_composition_cache_size 0 4 3606 46 RenderState::get_invert_composition_cache_size 0 1 189 340</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of slots in the composition cache for this RenderState.</span>
 <span class="s0">* You may use this as an upper bound when walking through all of the</span>
 <span class="s0">* composition cache results via get_invert_composition_cache_source() or</span>
 <span class="s0">* result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline std::size_t RenderState::get_invert_composition_cache_size(void) const;</span>

<span class="s0">2064 35 get_invert_composition_cache_source 0 4 3606 48 RenderState::get_invert_composition_cache_source 0 1 190 314</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the source RenderState of the nth element in the invert composition</span>
 <span class="s0">* cache.  Returns NULL if there doesn't happen to be an entry in the nth</span>
 <span class="s0">* element.  See get_invert_composition_cache_result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline RenderState const *RenderState::get_invert_composition_cache_source(std::size_t n) const;</span>

<span class="s0">2065 35 get_invert_composition_cache_result 0 4 3606 48 RenderState::get_invert_composition_cache_result 0 1 191 398</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the result RenderState of the nth element in the invert composition</span>
 <span class="s0">* cache.  Returns NULL if there doesn't happen to be an entry in the nth</span>
 <span class="s0">* element.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a-&gt;invert_compose(a-&gt;get_invert_composition_cache_source(n)) ==</span>
 <span class="s0">* a-&gt;get_invert_composition_cache_result(n).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline RenderState const *RenderState::get_invert_composition_cache_result(std::size_t n) const;</span>

<span class="s0">2066 21 get_composition_cache 0 4 3606 34 RenderState::get_composition_cache 0 1 192 0</span>
<span class="s0">57</span>
<span class="s0">PyObject *RenderState::get_composition_cache(void) const;</span>

<span class="s0">2067 28 get_invert_composition_cache 0 4 3606 41 RenderState::get_invert_composition_cache 0 1 193 0</span>
<span class="s0">64</span>
<span class="s0">PyObject *RenderState::get_invert_composition_cache(void) const;</span>

<span class="s0">2068 6 output 0 4 3606 19 RenderState::output 0 1 194 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void RenderState::output(std::ostream &amp;out) const;</span>

<span class="s0">2069 5 write 0 4 3606 18 RenderState::write 0 1 195 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void RenderState::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2070 16 get_max_priority 0 4 3606 29 RenderState::get_max_priority 0 1 196 297</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum priority number (sometimes called override) that may be</span>
 <span class="s0">* set on any node.  This may or may not be enforced, but the scene graph code</span>
 <span class="s0">* assumes that no priority numbers will be larger than this, and some effects</span>
 <span class="s0">* may not work properly if you use a larger number.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static int RenderState::get_max_priority(void);</span>

<span class="s0">2071 14 get_num_states 0 4 3606 27 RenderState::get_num_states 0 1 197 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of unique RenderState objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static int RenderState::get_num_states(void);</span>

<span class="s0">2072 21 get_num_unused_states 0 4 3606 34 RenderState::get_num_unused_states 0 1 198 596</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of RenderState objects that have been allocated</span>
 <span class="s0">* but have no references outside of the internal RenderState cache.</span>
 <span class="s0">*</span>
 <span class="s0">* A nonzero return value is not necessarily indicative of leaked references;</span>
 <span class="s0">* it is normal for two RenderState objects, both of which have references</span>
 <span class="s0">* held outside the cache, to have to result of their composition stored</span>
 <span class="s0">* within the cache.  This result will be retained within the cache until one</span>
 <span class="s0">* of the base RenderStates is released.</span>
 <span class="s0">*</span>
 <span class="s0">* Use list_cycles() to get an idea of the number of actual &quot;leaked&quot;</span>
 <span class="s0">* RenderState objects.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static int RenderState::get_num_unused_states(void);</span>

<span class="s0">2073 11 clear_cache 0 4 3606 24 RenderState::clear_cache 0 1 199 593</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the cache of composed RenderStates.  This makes every RenderState</span>
 <span class="s0">* forget what results when it is composed with other RenderStates.</span>
 <span class="s0">*</span>
 <span class="s0">* This will eliminate any RenderState objects that have been allocated but</span>
 <span class="s0">* have no references outside of the internal RenderState map.  It will not</span>
 <span class="s0">* eliminate RenderState objects that are still in use.</span>
 <span class="s0">*</span>
 <span class="s0">* Nowadays, this method should not be necessary, as reference-count cycles in</span>
 <span class="s0">* the composition cache should be automatically detected and broken.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the number of RenderStates freed by this operation.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">static int RenderState::clear_cache(void);</span>

<span class="s0">2074 18 clear_munger_cache 0 4 3606 31 RenderState::clear_munger_cache 0 1 200 146</span>
<span class="s0">/**</span>
 <span class="s0">* Completely empties the cache of state + gsg -&gt; munger, for all states and</span>
 <span class="s0">* all gsg's.  Normally there is no need to empty this cache.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static void RenderState::clear_munger_cache(void);</span>

<span class="s0">2075 15 garbage_collect 0 4 3606 28 RenderState::garbage_collect 0 1 201 366</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a garbage-collection cycle.  This must be called periodically if</span>
 <span class="s0">* garbage-collect-states is true to ensure that RenderStates get cleaned up</span>
 <span class="s0">* appropriately.  It does no harm to call it even if this variable is not</span>
 <span class="s0">* true, but there is probably no advantage in that case.</span>
 <span class="s0">*</span>
 <span class="s0">* This automatically calls RenderAttrib::garbage_collect() as well.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">static int RenderState::garbage_collect(void);</span>

<span class="s0">2076 11 list_cycles 0 4 3606 24 RenderState::list_cycles 0 1 202 565</span>
<span class="s0">/**</span>
 <span class="s0">* Detects all of the reference-count cycles in the cache and reports them to</span>
 <span class="s0">* standard output.</span>
 <span class="s0">*</span>
 <span class="s0">* These cycles may be inadvertently created when state compositions cycle</span>
 <span class="s0">* back to a starting point.  Nowadays, these cycles should be automatically</span>
 <span class="s0">* detected and broken, so this method should never list any cycles unless</span>
 <span class="s0">* there is a bug in that detection logic.</span>
 <span class="s0">*</span>
 <span class="s0">* The cycles listed here are not leaks in the strictest sense of the word,</span>
 <span class="s0">* since they can be reclaimed by a call to clear_cache(); but they will not</span>
 <span class="s0">* be reclaimed automatically.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static void RenderState::list_cycles(std::ostream &amp;out);</span>

<span class="s0">2077 11 list_states 0 4 3606 24 RenderState::list_states 0 1 203 169</span>
<span class="s0">/**</span>
 <span class="s0">* Lists all of the RenderStates in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static void RenderState::list_states(std::ostream &amp;out);</span>

<span class="s0">2078 15 validate_states 0 4 3606 28 RenderState::validate_states 0 1 204 279</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order, and that none of</span>
 <span class="s0">* the cache elements have been inadvertently deleted.  Returns true if so,</span>
 <span class="s0">* false if there is a problem (which implies someone has modified one of the</span>
 <span class="s0">* supposedly-const RenderState objects).</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static bool RenderState::validate_states(void);</span>

<span class="s0">2079 10 get_states 0 4 3606 23 RenderState::get_states 0 1 205 0</span>
<span class="s0">47</span>
<span class="s0">static PyObject *RenderState::get_states(void);</span>

<span class="s0">2080 17 get_unused_states 0 4 3606 30 RenderState::get_unused_states 0 1 206 0</span>
<span class="s0">54</span>
<span class="s0">static PyObject *RenderState::get_unused_states(void);</span>

<span class="s0">2081 14 get_draw_order 0 4 3606 27 RenderState::get_draw_order 0 1 207 282</span>
<span class="s0">// These methods are intended for use by low-level code, but they're also</span>
<span class="s0">// handy enough to expose to high-level users.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the draw order indicated by the CullBinAttrib, if any, associated</span>
 <span class="s0">* by this state (or 0 if there is no CullBinAttrib).  See get_bin_index().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int RenderState::get_draw_order(void) const;</span>

<span class="s0">2082 13 get_bin_index 0 4 3606 26 RenderState::get_bin_index 0 1 208 246</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bin index indicated by the CullBinAttrib, if any, associated by</span>
 <span class="s0">* this state (or the default bin index if there is no CullBinAttrib).  This</span>
 <span class="s0">* function is provided as an optimization for determining this at render</span>
 <span class="s0">* time.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int RenderState::get_bin_index(void) const;</span>

<span class="s0">2083 18 get_geom_rendering 0 4 3606 31 RenderState::get_geom_rendering 0 1 209 181</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this RenderState is applied to a geom which includes the indicated</span>
 <span class="s0">* geom_rendering bits.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">int RenderState::get_geom_rendering(int geom_rendering) const;</span>

<span class="s0">2084 14 get_class_type 0 4 3606 27 RenderState::get_class_type 0 1 210 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle RenderState::get_class_type(void);</span>

<span class="s0">2085 4 make 0 4 3609 21 AlphaTestAttrib::make 0 1 211 51</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new AlphaTestAttrib object.</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AlphaTestAttrib::make(RenderAttrib::PandaCompareFunc mode, PN_stdfloat reference_alpha);</span>

<span class="s0">2086 12 make_default 0 4 3609 29 AlphaTestAttrib::make_default 0 1 212 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AlphaTestAttrib::make_default(void);</span>

<span class="s0">2087 19 get_reference_alpha 0 4 3609 36 AlphaTestAttrib::get_reference_alpha 0 1 213 45</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alpha reference value.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline PN_stdfloat AlphaTestAttrib::get_reference_alpha(void) const;</span>

<span class="s0">2088 8 get_mode 0 4 3609 25 AlphaTestAttrib::get_mode 0 1 214 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alpha write mode.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline RenderAttrib::PandaCompareFunc AlphaTestAttrib::get_mode(void) const;</span>

<span class="s0">2089 14 get_class_slot 0 4 3609 31 AlphaTestAttrib::get_class_slot 0 1 215 0</span>
<span class="s0">49</span>
<span class="s0">static int AlphaTestAttrib::get_class_slot(void);</span>

<span class="s0">2090 14 get_class_type 0 4 3609 31 AlphaTestAttrib::get_class_type 0 1 216 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle AlphaTestAttrib::get_class_type(void);</span>

<span class="s0">2091 16 ~AlphaTestAttrib 0 516 3609 33 AlphaTestAttrib::~AlphaTestAttrib 0 0 0</span>
<span class="s0">40</span>
<span class="s0">AlphaTestAttrib::~AlphaTestAttrib(void);</span>

<span class="s0">2092 4 make 0 4 3610 21 AntialiasAttrib::make 0 1 217 1313</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new AntialiasAttrib object.</span>
 <span class="s0">*</span>
 <span class="s0">* The mode should be either M_none, M_auto, or a union of any or all of</span>
 <span class="s0">* M_point, M_line, M_polygon, and M_multisample.  Also, in addition to the</span>
 <span class="s0">* above choices, it may include either of M_better of M_faster to specify a</span>
 <span class="s0">* performance/quality tradeoff hint.</span>
 <span class="s0">*</span>
 <span class="s0">* If M_none is specified, no antialiasing is performed.</span>
 <span class="s0">*</span>
 <span class="s0">* If M_multisample is specified, it means to use the special framebuffer</span>
 <span class="s0">* multisample bits for antialiasing, if it is available.  If so, the M_point,</span>
 <span class="s0">* M_line, and M_polygon modes are ignored.  This advanced antialiasing mode</span>
 <span class="s0">* is only available on certain graphics hardware.  If it is not available,</span>
 <span class="s0">* the M_multisample bit is ignored (and the other modes may be used instead,</span>
 <span class="s0">* if specified).</span>
 <span class="s0">*</span>
 <span class="s0">* M_point, M_line, and/or M_polygon specify per-primitive smoothing.  When</span>
 <span class="s0">* enabled, M_point and M_line may force transparency on.  M_polygon requires</span>
 <span class="s0">* a frame buffer that includes an alpha channel, and it works best if the</span>
 <span class="s0">* primitives are sorted front-to-back.</span>
 <span class="s0">*</span>
 <span class="s0">* If M_auto is specified, M_multisample is selected if it is available,</span>
 <span class="s0">* otherwise M_polygon is selected, unless drawing lines or points, in which</span>
 <span class="s0">* case M_line or M_point is selected (these two generally produce better</span>
 <span class="s0">* results than M_multisample)</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AntialiasAttrib::make(unsigned short int mode);</span>

<span class="s0">2093 12 make_default 0 4 3610 29 AntialiasAttrib::make_default 0 1 218 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AntialiasAttrib::make_default(void);</span>

<span class="s0">2094 8 get_mode 0 4 3610 25 AntialiasAttrib::get_mode 0 1 219 48</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the specified antialias mode.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline unsigned short int AntialiasAttrib::get_mode(void) const;</span>

<span class="s0">2095 13 get_mode_type 0 4 3610 30 AntialiasAttrib::get_mode_type 0 1 220 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the specified antialias mode, with the quality bits masked out.</span>
 <span class="s0">* This therefore indicates only the requested type of antialiasing: M_none,</span>
 <span class="s0">* M_auto, or some specific combination.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline unsigned short int AntialiasAttrib::get_mode_type(void) const;</span>

<span class="s0">2096 16 get_mode_quality 0 4 3610 33 AntialiasAttrib::get_mode_quality 0 1 221 211</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the specified antialias mode, with the type bits masked out.  This</span>
 <span class="s0">* therefore indicates only the requested quality settings: one of M_faster,</span>
 <span class="s0">* M_better, M_dont_care, or zero (unspecified).</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline unsigned short int AntialiasAttrib::get_mode_quality(void) const;</span>

<span class="s0">2097 14 get_class_slot 0 4 3610 31 AntialiasAttrib::get_class_slot 0 1 222 0</span>
<span class="s0">49</span>
<span class="s0">static int AntialiasAttrib::get_class_slot(void);</span>

<span class="s0">2098 14 get_class_type 0 4 3610 31 AntialiasAttrib::get_class_type 0 1 223 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle AntialiasAttrib::get_class_type(void);</span>

<span class="s0">2099 16 ~AntialiasAttrib 0 516 3610 33 AntialiasAttrib::~AntialiasAttrib 0 0 0</span>
<span class="s0">40</span>
<span class="s0">AntialiasAttrib::~AntialiasAttrib(void);</span>

<span class="s0">2100 10 compare_to 0 4 3613 24 RenderEffect::compare_to 0 1 224 368</span>
<span class="s0">/**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique RenderEffects, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not needed outside of the RenderEffect class because all</span>
 <span class="s0">* equivalent RenderEffect objects are guaranteed to share the same pointer;</span>
 <span class="s0">* thus, a pointer comparison is always sufficient.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline int RenderEffect::compare_to(RenderEffect const &amp;other) const;</span>

<span class="s0">2101 6 output 0 6 3613 20 RenderEffect::output 0 1 225 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual void RenderEffect::output(std::ostream &amp;out) const;</span>

<span class="s0">2102 5 write 0 6 3613 19 RenderEffect::write 0 1 226 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">virtual void RenderEffect::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2103 15 get_num_effects 0 4 3613 29 RenderEffect::get_num_effects 0 1 227 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of unique RenderEffect objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static int RenderEffect::get_num_effects(void);</span>

<span class="s0">2104 12 list_effects 0 4 3613 26 RenderEffect::list_effects 0 1 228 170</span>
<span class="s0">/**</span>
 <span class="s0">* Lists all of the RenderEffects in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static void RenderEffect::list_effects(std::ostream &amp;out);</span>

<span class="s0">2105 16 validate_effects 0 4 3613 30 RenderEffect::validate_effects 0 1 229 208</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order.  Returns true if</span>
 <span class="s0">* so, false if there is a problem (which implies someone has modified one of</span>
 <span class="s0">* the supposedly-const RenderEffect objects).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static bool RenderEffect::validate_effects(void);</span>

<span class="s0">2106 14 get_class_type 0 4 3613 28 RenderEffect::get_class_type 0 1 230 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle RenderEffect::get_class_type(void);</span>

<span class="s0">2107 10 operator &lt; 0 4 3614 25 RenderEffects::operator &lt; 0 1 231 0</span>
<span class="s0">65</span>
<span class="s0">bool RenderEffects::operator &lt;(RenderEffects const &amp;other) const;</span>

<span class="s0">2108 8 is_empty 0 4 3614 23 RenderEffects::is_empty 0 1 232 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the state is empty, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool RenderEffects::is_empty(void) const;</span>

<span class="s0">2109 15 get_num_effects 0 4 3614 30 RenderEffects::get_num_effects 0 1 233 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of separate effects indicated in the state.</span>
 <span class="s0">* @deprecated in Python, use len(effects) instead, or effects.size() in C++.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t RenderEffects::get_num_effects(void) const;</span>

<span class="s0">2110 10 get_effect 0 4 3614 25 RenderEffects::get_effect 0 2 234 235 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth effect in the state.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Looks for a RenderEffect of the indicated type in the state, and returns it</span>
 <span class="s0">* if it is found, or NULL if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">inline RenderEffect const *RenderEffects::get_effect(std::size_t n) const;</span>
<span class="s0">RenderEffect const *RenderEffects::get_effect(TypeHandle type) const;</span>

<span class="s0">2111 4 size 0 4 3614 19 RenderEffects::size 0 1 236 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of separate effects indicated in the state.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline std::size_t RenderEffects::size(void) const;</span>

<span class="s0">2112 11 operator [] 0 4 3614 26 RenderEffects::operator [] 0 2 237 238 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth effect in the state.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the effect in the state with the given type.</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">inline RenderEffect const *RenderEffects::operator [](std::size_t n) const;</span>
<span class="s0">inline RenderEffect const *RenderEffects::operator [](TypeHandle type) const;</span>

<span class="s0">2113 11 find_effect 0 4 3614 26 RenderEffects::find_effect 0 1 239 132</span>
<span class="s0">/**</span>
 <span class="s0">* Searches for an effect with the indicated type in the state, and returns</span>
 <span class="s0">* its index if it is found, or -1 if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int RenderEffects::find_effect(TypeHandle type) const;</span>

<span class="s0">2114 10 make_empty 0 4 3614 25 RenderEffects::make_empty 0 1 240 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderEffects with no effects set.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static ConstPointerTo&lt; RenderEffects &gt; RenderEffects::make_empty(void);</span>

<span class="s0">2115 4 make 0 4 3614 19 RenderEffects::make 0 4 241 242 243 244 232</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderEffects with one effect set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a RenderEffects with two effects set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a RenderEffects with three effects set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a RenderEffects with four effects set.</span>
 <span class="s0">*/</span>
<span class="s0">528</span>
<span class="s0">static ConstPointerTo&lt; RenderEffects &gt; RenderEffects::make(RenderEffect const *effect);</span>
<span class="s0">static ConstPointerTo&lt; RenderEffects &gt; RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2);</span>
<span class="s0">static ConstPointerTo&lt; RenderEffects &gt; RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2, RenderEffect const *effect3);</span>
<span class="s0">static ConstPointerTo&lt; RenderEffects &gt; RenderEffects::make(RenderEffect const *effect1, RenderEffect const *effect2, RenderEffect const *effect3, RenderEffect const *effect4);</span>

<span class="s0">2116 10 add_effect 0 4 3614 25 RenderEffects::add_effect 0 1 245 202</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderEffects object that represents the same as the source</span>
 <span class="s0">* state, with the new RenderEffect added.  If there is already a RenderEffect</span>
 <span class="s0">* with the same type, it is replaced.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">ConstPointerTo&lt; RenderEffects &gt; RenderEffects::add_effect(RenderEffect const *effect) const;</span>

<span class="s0">2117 13 remove_effect 0 4 3614 28 RenderEffects::remove_effect 0 1 246 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new RenderEffects object that represents the same as the source</span>
 <span class="s0">* state, with the indicated RenderEffect removed.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">ConstPointerTo&lt; RenderEffects &gt; RenderEffects::remove_effect(TypeHandle type) const;</span>

<span class="s0">2118 6 output 0 4 3614 21 RenderEffects::output 0 1 247 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void RenderEffects::output(std::ostream &amp;out) const;</span>

<span class="s0">2119 5 write 0 4 3614 20 RenderEffects::write 0 1 248 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void RenderEffects::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2120 14 get_num_states 0 4 3614 29 RenderEffects::get_num_states 0 1 249 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of unique RenderEffects objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static int RenderEffects::get_num_states(void);</span>

<span class="s0">2121 11 list_states 0 4 3614 26 RenderEffects::list_states 0 1 250 170</span>
<span class="s0">/**</span>
 <span class="s0">* Lists all of the RenderEffects in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">static void RenderEffects::list_states(std::ostream &amp;out);</span>

<span class="s0">2122 15 validate_states 0 4 3614 30 RenderEffects::validate_states 0 1 251 209</span>
<span class="s0">/**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order.  Returns true if</span>
 <span class="s0">* so, false if there is a problem (which implies someone has modified one of</span>
 <span class="s0">* the supposedly-const RenderEffects objects).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static bool RenderEffects::validate_states(void);</span>

<span class="s0">2123 14 get_class_type 0 4 3614 29 RenderEffects::get_class_type 0 1 252 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle RenderEffects::get_class_type(void);</span>

<span class="s0">2124 37 upcast_to_TypedWritableReferenceCount 0 12 3615 48 PandaNode::upcast_to_TypedWritableReferenceCount 0 1 374 52</span>
<span class="s0">upcast from PandaNode to TypedWritableReferenceCount</span>
<span class="s0">84</span>
<span class="s0">TypedWritableReferenceCount *PandaNode::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">2125 21 downcast_to_PandaNode 0 12 3592 50 TypedWritableReferenceCount::downcast_to_PandaNode 0 0 54</span>
<span class="s0">downcast from TypedWritableReferenceCount to PandaNode</span>
<span class="s0">68</span>
<span class="s0">PandaNode *TypedWritableReferenceCount::downcast_to_PandaNode(void);</span>

<span class="s0">2126 17 upcast_to_Namable 0 12 3615 28 PandaNode::upcast_to_Namable 0 1 375 32</span>
<span class="s0">upcast from PandaNode to Namable</span>
<span class="s0">44</span>
<span class="s0">Namable *PandaNode::upcast_to_Namable(void);</span>

<span class="s0">2127 21 downcast_to_PandaNode 0 12 3616 30 Namable::downcast_to_PandaNode 0 0 34</span>
<span class="s0">downcast from Namable to PandaNode</span>
<span class="s0">48</span>
<span class="s0">PandaNode *Namable::downcast_to_PandaNode(void);</span>

<span class="s0">2128 24 upcast_to_LinkedListNode 0 12 3615 35 PandaNode::upcast_to_LinkedListNode 0 1 376 39</span>
<span class="s0">upcast from PandaNode to LinkedListNode</span>
<span class="s0">58</span>
<span class="s0">LinkedListNode *PandaNode::upcast_to_LinkedListNode(void);</span>

<span class="s0">2129 21 downcast_to_PandaNode 0 12 3617 37 LinkedListNode::downcast_to_PandaNode 0 0 41</span>
<span class="s0">downcast from LinkedListNode to PandaNode</span>
<span class="s0">55</span>
<span class="s0">PandaNode *LinkedListNode::downcast_to_PandaNode(void);</span>

<span class="s0">2130 9 PandaNode 0 260 3615 20 PandaNode::PandaNode 0 1 253 138</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Do not call the copy constructor directly; instead, use make_copy() or</span>
 <span class="s0">* copy_subgraph() to make a copy of a node.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">explicit PandaNode::PandaNode(std::string const &amp;name);</span>

<span class="s0">2131 10 ~PandaNode 0 518 3615 21 PandaNode::~PandaNode 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">virtual PandaNode::~PandaNode(void);</span>

<span class="s0">2132 12 combine_with 0 6 3615 23 PandaNode::combine_with 0 1 254 525</span>
<span class="s0">// published so that characters can be combined.</span>

<span class="s0">/**</span>
 <span class="s0">* Collapses this PandaNode with the other PandaNode, if possible, and returns</span>
 <span class="s0">* a pointer to the combined PandaNode, or NULL if the two PandaNodes cannot</span>
 <span class="s0">* safely be combined.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value may be this, other, or a new PandaNode altogether.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is called from GraphReducer::flatten(), and need not deal</span>
 <span class="s0">* with children; its job is just to decide whether to collapse the two</span>
 <span class="s0">* PandaNodes and what the collapsed PandaNode should look like.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual PandaNode *PandaNode::combine_with(PandaNode *other);</span>

<span class="s0">2133 9 make_copy 0 6 3615 20 PandaNode::make_copy 0 1 255 234</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated PandaNode that is a shallow copy of this one.  It</span>
 <span class="s0">* will be a different pointer, but its internal data may or may not be shared</span>
 <span class="s0">* with that of the original PandaNode.  No children will be copied.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">virtual PandaNode *PandaNode::make_copy(void) const;</span>

<span class="s0">2134 13 copy_subgraph 0 4 3615 24 PandaNode::copy_subgraph 0 1 256 264</span>
<span class="s0">/**</span>
 <span class="s0">* Allocates and returns a complete copy of this PandaNode and the entire</span>
 <span class="s0">* scene graph rooted at this PandaNode.  Some data may still be shared from</span>
 <span class="s0">* the original (e.g.  vertex index tables), but nothing that will impede</span>
 <span class="s0">* normal use of the PandaNode.</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">PointerTo&lt; PandaNode &gt; PandaNode::copy_subgraph(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2135 8 __copy__ 0 4 3615 19 PandaNode::__copy__ 0 1 257 0</span>
<span class="s0">55</span>
<span class="s0">PointerTo&lt; PandaNode &gt; PandaNode::__copy__(void) const;</span>

<span class="s0">2136 12 __deepcopy__ 0 4 3615 23 PandaNode::__deepcopy__ 0 1 258 0</span>
<span class="s0">72</span>
<span class="s0">PyObject *PandaNode::__deepcopy__(PyObject *self, PyObject *memo) const;</span>

<span class="s0">2137 15 get_num_parents 0 4 3615 26 PandaNode::get_num_parents 0 1 259 264</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of parent nodes this node has.  If this number is</span>
 <span class="s0">* greater than 1, the node has been multiply instanced.  The order of the</span>
 <span class="s0">* parent nodes is not meaningful and is not related to the order in which the</span>
 <span class="s0">* node was instanced to them.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">inline int PandaNode::get_num_parents(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2138 10 get_parent 0 4 3615 21 PandaNode::get_parent 0 1 260 219</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth parent node of this node.  See get_num_parents().  Also see</span>
 <span class="s0">* get_parents(), if your intention is to iterate through the complete list of</span>
 <span class="s0">* parents; get_parents() is preferable in this case.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">inline PandaNode *PandaNode::get_parent(int n, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2139 11 find_parent 0 4 3615 22 PandaNode::find_parent 0 1 261 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the indicated parent node, if it is a parent, or -1 if</span>
 <span class="s0">* it is not.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">inline int PandaNode::find_parent(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2140 16 get_num_children 0 4 3615 27 PandaNode::get_num_children 0 1 262 228</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of child nodes this node has.  The order of the child</span>
 <span class="s0">* nodes *is* meaningful and is based on the sort number that was passed to</span>
 <span class="s0">* add_child(), and also on the order in which the nodes were added.</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">inline int PandaNode::get_num_children(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2141 9 get_child 0 4 3615 20 PandaNode::get_child 0 1 263 222</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth child node of this node.  See get_num_children().  Also see</span>
 <span class="s0">* get_children(), if your intention is to iterate through the complete list</span>
 <span class="s0">* of children; get_children() is preferable in this case.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline PandaNode *PandaNode::get_child(int n, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2142 14 get_child_sort 0 4 3615 25 PandaNode::get_child_sort 0 1 264 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sort index of the nth child node of this node (that is, the</span>
 <span class="s0">* number that was passed to add_child()).  See get_num_children().</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">inline int PandaNode::get_child_sort(int n, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2143 10 find_child 0 4 3615 21 PandaNode::find_child 0 1 265 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the indicated child node, if it is a child, or -1 if</span>
 <span class="s0">* it is not.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">inline int PandaNode::find_child(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2144 21 count_num_descendants 0 4 3615 32 PandaNode::count_num_descendants 0 1 266 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of nodes at and below this level.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">int PandaNode::count_num_descendants(void) const;</span>

<span class="s0">2145 9 add_child 0 4 3615 20 PandaNode::add_child 0 1 267 285</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new child to the node.  The child is added in the relative position</span>
 <span class="s0">* indicated by sort; if all children have the same sort index, the child is</span>
 <span class="s0">* added at the end.</span>
 <span class="s0">*</span>
 <span class="s0">* If the same child is added to a node more than once, the previous instance</span>
 <span class="s0">* is first removed.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">void PandaNode::add_child(PandaNode *child_node, int sort = 0, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2146 12 remove_child 0 4 3615 23 PandaNode::remove_child 0 2 268 269 267</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the nth child from the node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the indicated child from the node.  Returns true if the child was</span>
 <span class="s0">* removed, false if it was not already a child of the node.  This will also</span>
 <span class="s0">* successfully remove the child if it had been stashed.</span>
 <span class="s0">*/</span>
<span class="s0">209</span>
<span class="s0">void PandaNode::remove_child(int child_index, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">bool PandaNode::remove_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2147 13 replace_child 0 4 3615 24 PandaNode::replace_child 0 1 270 241</span>
<span class="s0">/**</span>
 <span class="s0">* Searches for the orig_child node in the node's list of children, and</span>
 <span class="s0">* replaces it with the new_child instead.  Returns true if the replacement is</span>
 <span class="s0">* made, or false if the node is not a child or if there is some other</span>
 <span class="s0">* problem.</span>
 <span class="s0">*/</span>
<span class="s0">130</span>
<span class="s0">bool PandaNode::replace_child(PandaNode *orig_child, PandaNode *new_child, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2148 11 stash_child 0 4 3615 22 PandaNode::stash_child 0 2 271 272 1018</span>
<span class="s0">/**</span>
 <span class="s0">* Stashes the indicated child node.  This removes the child from the list of</span>
 <span class="s0">* active children and puts it on a special list of stashed children.  This</span>
 <span class="s0">* child node no longer contributes to the bounding volume of the PandaNode,</span>
 <span class="s0">* and is not visited in normal traversals.  It is invisible and uncollidable.</span>
 <span class="s0">* The child may later be restored by calling unstash_child().</span>
 <span class="s0">*</span>
 <span class="s0">* This function returns true if the child node was successfully stashed, or</span>
 <span class="s0">* false if it was not a child of the node in the first place (e.g.  it was</span>
 <span class="s0">* previously stashed).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stashes the indicated child node.  This removes the child from the list of</span>
 <span class="s0">* active children and puts it on a special list of stashed children.  This</span>
 <span class="s0">* child node no longer contributes to the bounding volume of the PandaNode,</span>
 <span class="s0">* and is not visited in normal traversals.  It is invisible and uncollidable.</span>
 <span class="s0">* The child may later be restored by calling unstash_child().</span>
 <span class="s0">*</span>
 <span class="s0">* This can only be called from the top pipeline stage (i.e.  from App).</span>
 <span class="s0">*/</span>
<span class="s0">214</span>
<span class="s0">inline bool PandaNode::stash_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">void PandaNode::stash_child(int child_index, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2149 13 unstash_child 0 4 3615 24 PandaNode::unstash_child 0 2 273 274 946</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the indicated stashed node to normal child status.  This removes</span>
 <span class="s0">* the child from the list of stashed children and puts it on the normal list</span>
 <span class="s0">* of active children.  This child node once again contributes to the bounding</span>
 <span class="s0">* volume of the PandaNode, and will be visited in normal traversals.  It is</span>
 <span class="s0">* visible and collidable.</span>
 <span class="s0">*</span>
 <span class="s0">* This function returns true if the child node was successfully stashed, or</span>
 <span class="s0">* false if it was not a child of the node in the first place (e.g.  it was</span>
 <span class="s0">* previously stashed).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the indicated stashed node to normal child status.  This removes</span>
 <span class="s0">* the child from the list of stashed children and puts it on the normal list</span>
 <span class="s0">* of active children.  This child node once again contributes to the bounding</span>
 <span class="s0">* volume of the PandaNode, and will be visited in normal traversals.  It is</span>
 <span class="s0">* visible and collidable.</span>
 <span class="s0">*</span>
 <span class="s0">* This can only be called from the top pipeline stage (i.e.  from App).</span>
 <span class="s0">*/</span>
<span class="s0">220</span>
<span class="s0">inline bool PandaNode::unstash_child(PandaNode *child_node, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">void PandaNode::unstash_child(int stashed_index, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2150 15 get_num_stashed 0 4 3615 26 PandaNode::get_num_stashed 0 1 275 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of stashed nodes this node has.  These are former</span>
 <span class="s0">* children of the node that have been moved to the special stashed list via</span>
 <span class="s0">* stash_child().</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">inline int PandaNode::get_num_stashed(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2151 11 get_stashed 0 4 3615 22 PandaNode::get_stashed 0 2 276 277 856</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth stashed child of this node.  See get_num_stashed().  Also</span>
 <span class="s0">* see get_stashed(), if your intention is to iterate through the complete</span>
 <span class="s0">* list of stashed children; get_stashed() is preferable in this case.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns an object that can be used to walk through the list of children of</span>
 <span class="s0">* the node.  When you intend to visit multiple children, using this is</span>
 <span class="s0">* slightly faster than calling get_stashed() directly on the PandaNode, since</span>
 <span class="s0">* this object avoids reopening the PipelineCycler each time.</span>
 <span class="s0">*</span>
 <span class="s0">* This object also protects you from self-modifying loops (e.g.  adding or</span>
 <span class="s0">* removing children during traversal), since a virtual copy of the children</span>
 <span class="s0">* is made ahead of time.  The virtual copy is fast--it is a form of copy-on-</span>
 <span class="s0">* write, so the list is not actually copied unless it is modified during the</span>
 <span class="s0">* traversal.</span>
 <span class="s0">*/</span>
<span class="s0">220</span>
<span class="s0">inline PandaNode *PandaNode::get_stashed(int n, Thread *current_thread = Thread::get_current_thread()) const;</span>
<span class="s0">inline PandaNode::Stashed PandaNode::get_stashed(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2152 16 get_stashed_sort 0 4 3615 27 PandaNode::get_stashed_sort 0 1 278 151</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sort index of the nth stashed node of this node (that is, the</span>
 <span class="s0">* number that was passed to add_child()).  See get_num_stashed().</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline int PandaNode::get_stashed_sort(int n, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2153 12 find_stashed 0 4 3615 23 PandaNode::find_stashed 0 1 279 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the indicated stashed node, if it is a stashed child,</span>
 <span class="s0">* or -1 if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">inline int PandaNode::find_stashed(PandaNode *node, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2154 11 add_stashed 0 4 3615 22 PandaNode::add_stashed 0 1 280 361</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new child to the node, directly as a stashed child.  The child is</span>
 <span class="s0">* not added in the normal sense, but will be revealed if unstash_child() is</span>
 <span class="s0">* called on it later.</span>
 <span class="s0">*</span>
 <span class="s0">* If the same child is added to a node more than once, the previous instance</span>
 <span class="s0">* is first removed.</span>
 <span class="s0">*</span>
 <span class="s0">* This can only be called from the top pipeline stage (i.e.  from App).</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">void PandaNode::add_stashed(PandaNode *child_node, int sort = 0, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2155 14 remove_stashed 0 4 3615 25 PandaNode::remove_stashed 0 1 281 55</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the nth stashed child from the node.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">void PandaNode::remove_stashed(int child_index, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2156 19 remove_all_children 0 4 3615 30 PandaNode::remove_all_children 0 1 282 162</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the children from the node at once, including stashed children.</span>
 <span class="s0">*</span>
 <span class="s0">* This can only be called from the top pipeline stage (i.e.  from App).</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">void PandaNode::remove_all_children(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2157 14 steal_children 0 4 3615 25 PandaNode::steal_children 0 1 283 177</span>
<span class="s0">/**</span>
 <span class="s0">* Moves all the children from the other node onto this node.</span>
 <span class="s0">*</span>
 <span class="s0">* Any NodePaths to child nodes of the other node are truncated, rather than</span>
 <span class="s0">* moved to the new parent.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">void PandaNode::steal_children(PandaNode *other, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2158 13 copy_children 0 4 3615 24 PandaNode::copy_children 0 1 284 102</span>
<span class="s0">/**</span>
 <span class="s0">* Makes another instance of all the children of the other node, copying them</span>
 <span class="s0">* to this node.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">void PandaNode::copy_children(PandaNode *other, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2159 10 set_attrib 0 4 3615 21 PandaNode::set_attrib 0 1 285 220</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated render attribute to the scene graph on this node.  This</span>
 <span class="s0">* attribute will now apply to this node and everything below.  If there was</span>
 <span class="s0">* already an attribute of the same type, it is replaced.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">void PandaNode::set_attrib(RenderAttrib const *attrib, int override = 0);</span>

<span class="s0">2160 10 get_attrib 0 4 3615 21 PandaNode::get_attrib 0 2 286 287 542</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the render attribute of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.  This checks only what is set on this</span>
 <span class="s0">* particular node level, and has nothing to do with what render attributes</span>
 <span class="s0">* may be inherited from parent nodes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the render attribute of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.  This checks only what is set on this</span>
 <span class="s0">* particular node level, and has nothing to do with what render attributes</span>
 <span class="s0">* may be inherited from parent nodes.</span>
 <span class="s0">*/</span>
<span class="s0">160</span>
<span class="s0">inline ConstPointerTo&lt; RenderAttrib &gt; PandaNode::get_attrib(TypeHandle type) const;</span>
<span class="s0">inline ConstPointerTo&lt; RenderAttrib &gt; PandaNode::get_attrib(int slot) const;</span>

<span class="s0">2161 10 has_attrib 0 4 3615 21 PandaNode::has_attrib 0 2 288 289 256</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a render attribute of the indicated type defined</span>
 <span class="s0">* on this node, or false if there is not.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a render attribute of the indicated type defined</span>
 <span class="s0">* on this node, or false if there is not.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">inline bool PandaNode::has_attrib(TypeHandle type) const;</span>
<span class="s0">inline bool PandaNode::has_attrib(int slot) const;</span>

<span class="s0">2162 12 clear_attrib 0 4 3615 23 PandaNode::clear_attrib 0 2 290 291 390</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the render attribute of the given type from this node.  This node,</span>
 <span class="s0">* and the subgraph below, will now inherit the indicated render attribute</span>
 <span class="s0">* from the nodes above this one.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the render attribute of the given type from this node.  This node,</span>
 <span class="s0">* and the subgraph below, will now inherit the indicated render attribute</span>
 <span class="s0">* from the nodes above this one.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline void PandaNode::clear_attrib(TypeHandle type);</span>
<span class="s0">void PandaNode::clear_attrib(int slot);</span>

<span class="s0">2163 10 set_effect 0 4 3615 21 PandaNode::set_effect 0 1 292 145</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated render effect to the scene graph on this node.  If there</span>
 <span class="s0">* was already an effect of the same type, it is replaced.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void PandaNode::set_effect(RenderEffect const *effect);</span>

<span class="s0">2164 10 get_effect 0 4 3615 21 PandaNode::get_effect 0 1 293 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the render effect of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline ConstPointerTo&lt; RenderEffect &gt; PandaNode::get_effect(TypeHandle type) const;</span>

<span class="s0">2165 10 has_effect 0 4 3615 21 PandaNode::has_effect 0 1 294 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a render effect of the indicated type defined on</span>
 <span class="s0">* this node, or false if there is not.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool PandaNode::has_effect(TypeHandle type) const;</span>

<span class="s0">2166 12 clear_effect 0 4 3615 23 PandaNode::clear_effect 0 1 295 70</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the render effect of the given type from this node.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void PandaNode::clear_effect(TypeHandle type);</span>

<span class="s0">2167 9 set_state 0 4 3615 20 PandaNode::set_state 0 1 296 337</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the complete RenderState that will be applied to all nodes at this</span>
 <span class="s0">* level and below.  (The actual state that will be applied to lower nodes is</span>
 <span class="s0">* based on the composition of RenderStates from above this node as well).</span>
 <span class="s0">* This completely replaces whatever has been set on this node via repeated</span>
 <span class="s0">* calls to set_attrib().</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">void PandaNode::set_state(RenderState const *state, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2168 9 get_state 0 4 3615 20 PandaNode::get_state 0 1 297 265</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete RenderState that will be applied to all nodes at this</span>
 <span class="s0">* level and below, as set on this node.  This returns only the RenderState</span>
 <span class="s0">* set on this particular node, and has nothing to do with state that might be</span>
 <span class="s0">* inherited from above.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">inline ConstPointerTo&lt; RenderState &gt; PandaNode::get_state(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2169 11 clear_state 0 4 3615 22 PandaNode::clear_state 0 1 298 183</span>
<span class="s0">/**</span>
 <span class="s0">* Resets this node to leave the render state alone.  Nodes at this level and</span>
 <span class="s0">* below will once again inherit their render state unchanged from the nodes</span>
 <span class="s0">* above this level.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">inline void PandaNode::clear_state(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2170 11 set_effects 0 4 3615 22 PandaNode::set_effects 0 1 299 177</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the complete RenderEffects that will be applied this node.  This</span>
 <span class="s0">* completely replaces whatever has been set on this node via repeated calls</span>
 <span class="s0">* to set_attrib().</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">void PandaNode::set_effects(RenderEffects const *effects, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2171 11 get_effects 0 4 3615 22 PandaNode::get_effects 0 1 300 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete RenderEffects that will be applied to this node.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline ConstPointerTo&lt; RenderEffects &gt; PandaNode::get_effects(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2172 13 clear_effects 0 4 3615 24 PandaNode::clear_effects 0 1 301 54</span>
<span class="s0">/**</span>
 <span class="s0">* Resets this node to have no render effects.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline void PandaNode::clear_effects(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2173 13 set_transform 0 4 3615 24 PandaNode::set_transform 0 1 302 158</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the transform that will be applied to this node and below.  This</span>
 <span class="s0">* defines a new coordinate space at this point in the scene graph and below.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">void PandaNode::set_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2174 13 get_transform 0 4 3615 24 PandaNode::get_transform 0 1 303 177</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transform that has been set on this particular node.  This is</span>
 <span class="s0">* not the net transform from the root, but simply the transform on this</span>
 <span class="s0">* particular node.</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">inline ConstPointerTo&lt; TransformState &gt; PandaNode::get_transform(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2175 15 clear_transform 0 4 3615 26 PandaNode::clear_transform 0 1 304 71</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the transform on this node to the identity transform.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline void PandaNode::clear_transform(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2176 18 set_prev_transform 0 4 3615 29 PandaNode::set_prev_transform 0 1 305 173</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the transform that represents this node's &quot;previous&quot; position, one</span>
 <span class="s0">* frame ago, for the purposes of detecting motion for accurate collision</span>
 <span class="s0">* calculations.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">void PandaNode::set_prev_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2177 18 get_prev_transform 0 4 3615 29 PandaNode::get_prev_transform 0 1 306 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transform that has been set as this node's &quot;previous&quot; position.</span>
 <span class="s0">* See set_prev_transform().</span>
 <span class="s0">*/</span>
<span class="s0">131</span>
<span class="s0">inline ConstPointerTo&lt; TransformState &gt; PandaNode::get_prev_transform(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2178 20 reset_prev_transform 0 4 3615 31 PandaNode::reset_prev_transform 0 1 307 179</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the transform that represents this node's &quot;previous&quot; position to the</span>
 <span class="s0">* same as the current transform.  This is not the same thing as clearing it</span>
 <span class="s0">* to identity.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">void PandaNode::reset_prev_transform(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2179 24 has_dirty_prev_transform 0 4 3615 35 PandaNode::has_dirty_prev_transform 0 1 308 250</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this node has the _dirty_prev_transform flag set, which</span>
 <span class="s0">* indicates its _prev_transform is different from its _transform value (in</span>
 <span class="s0">* pipeline stage 0).  In this case, the node will be visited by</span>
 <span class="s0">* reset_prev_transform().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool PandaNode::has_dirty_prev_transform(void) const;</span>

<span class="s0">2180 24 reset_all_prev_transform 0 4 3615 35 PandaNode::reset_all_prev_transform 0 1 309 242</span>
<span class="s0">/**</span>
 <span class="s0">* Visits all nodes in the world with the _dirty_prev_transform flag--that is,</span>
 <span class="s0">* all nodes whose _prev_transform is different from the _transform in</span>
 <span class="s0">* pipeline stage 0--and resets the _prev_transform to be the same as</span>
 <span class="s0">* _transform.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">static void PandaNode::reset_all_prev_transform(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2181 7 set_tag 0 4 3615 18 PandaNode::set_tag 0 1 310 391</span>
<span class="s0">/**</span>
 <span class="s0">* Associates a user-defined value with a user-defined key which is stored on</span>
 <span class="s0">* the node.  This value has no meaning to Panda; but it is stored</span>
 <span class="s0">* indefinitely on the node until it is requested again.</span>
 <span class="s0">*</span>
 <span class="s0">* Each unique key stores a different string value.  There is no effective</span>
 <span class="s0">* limit on the number of different keys that may be stored or on the length</span>
 <span class="s0">* of any one key's value.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">void PandaNode::set_tag(std::string const &amp;key, std::string const &amp;value, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2182 7 get_tag 0 4 3615 18 PandaNode::get_tag 0 1 311 182</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the user-defined value that was previously set on this node for</span>
 <span class="s0">* the particular key, if any.  If no value has been previously set, returns</span>
 <span class="s0">* the empty string.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline std::string PandaNode::get_tag(std::string const &amp;key, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2183 7 has_tag 0 4 3615 18 PandaNode::has_tag 0 1 312 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a value has been defined on this node for the particular</span>
 <span class="s0">* key (even if that value is the empty string), or false if no value has been</span>
 <span class="s0">* set.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline bool PandaNode::has_tag(std::string const &amp;key, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2184 9 clear_tag 0 4 3615 20 PandaNode::clear_tag 0 1 313 158</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the value defined for this key on this particular node.  After a</span>
 <span class="s0">* call to clear_tag(), has_tag() will return false for the indicated key.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">void PandaNode::clear_tag(std::string const &amp;key, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2185 12 get_num_tags 0 4 3615 23 PandaNode::get_num_tags 0 1 377 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of tags applied to this node.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline std::size_t PandaNode::get_num_tags(void) const;</span>

<span class="s0">2186 11 get_tag_key 0 4 3615 22 PandaNode::get_tag_key 0 1 378 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the key of the nth tag applied to this node.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::string PandaNode::get_tag_key(std::size_t i) const;</span>

<span class="s0">2187 12 get_tag_keys 0 4 3615 23 PandaNode::get_tag_keys 0 1 314 231</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the given vector up with the list of tags on this PandaNode.</span>
 <span class="s0">*</span>
 <span class="s0">* It is the user's responsibility to ensure that the keys vector is empty</span>
 <span class="s0">* before making this call; otherwise, the new keys will be appended to it.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">PyObject *PandaNode::get_tag_keys(void) const;</span>

<span class="s0">2188 15 get_python_tags 0 4 3615 26 PandaNode::get_python_tags 0 1 315 0</span>
<span class="s0">43</span>
<span class="s0">PyObject *PandaNode::get_python_tags(void);</span>

<span class="s0">2189 14 set_python_tag 0 4 3615 25 PandaNode::set_python_tag 0 1 316 0</span>
<span class="s0">63</span>
<span class="s0">void PandaNode::set_python_tag(PyObject *key, PyObject *value);</span>

<span class="s0">2190 14 get_python_tag 0 4 3615 25 PandaNode::get_python_tag 0 1 317 0</span>
<span class="s0">57</span>
<span class="s0">PyObject *PandaNode::get_python_tag(PyObject *key) const;</span>

<span class="s0">2191 14 has_python_tag 0 4 3615 25 PandaNode::has_python_tag 0 1 318 0</span>
<span class="s0">52</span>
<span class="s0">bool PandaNode::has_python_tag(PyObject *key) const;</span>

<span class="s0">2192 16 clear_python_tag 0 4 3615 27 PandaNode::clear_python_tag 0 1 319 0</span>
<span class="s0">48</span>
<span class="s0">void PandaNode::clear_python_tag(PyObject *key);</span>

<span class="s0">2193 19 get_python_tag_keys 0 4 3615 30 PandaNode::get_python_tag_keys 0 1 320 0</span>
<span class="s0">53</span>
<span class="s0">PyObject *PandaNode::get_python_tag_keys(void) const;</span>

<span class="s0">2194 12 __traverse__ 0 4 3615 23 PandaNode::__traverse__ 0 1 321 0</span>
<span class="s0">56</span>
<span class="s0">int PandaNode::__traverse__(visitproc visit, void *arg);</span>

<span class="s0">2195 8 has_tags 0 4 3615 19 PandaNode::has_tags 0 1 322 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the node has any tags (or any Python tags) at all, false if</span>
 <span class="s0">* it has none.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool PandaNode::has_tags(void) const;</span>

<span class="s0">2196 9 copy_tags 0 4 3615 20 PandaNode::copy_tags 0 1 323 191</span>
<span class="s0">/**</span>
 <span class="s0">* Copies all of the tags stored on the other node onto this node.  If a</span>
 <span class="s0">* particular tag exists on both nodes, the contents of this node's value is</span>
 <span class="s0">* replaced by that of the other.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void PandaNode::copy_tags(PandaNode *other);</span>

<span class="s0">2197 9 list_tags 0 4 3615 20 PandaNode::list_tags 0 1 324 364</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a list of all the tag keys assigned to the node to the indicated</span>
 <span class="s0">* stream.  Writes one instance of the separator following each key (but does</span>
 <span class="s0">* not write a terminal separator).  The value associated with each key is not</span>
 <span class="s0">* written.</span>
 <span class="s0">*</span>
 <span class="s0">* This is mainly for the benefit of the realtime user, to see the list of all</span>
 <span class="s0">* of the associated tag keys.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">void PandaNode::list_tags(std::ostream &amp;out, std::string const &amp;separator = &quot;\n&quot;) const;</span>

<span class="s0">2198 12 compare_tags 0 4 3615 23 PandaNode::compare_tags 0 1 325 341</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than 0, 0, or greater than 0, to indicate the</span>
 <span class="s0">* similarity of tags between this node and the other one.  If this returns 0,</span>
 <span class="s0">* the tags are identical.  If it returns other than 0, then the tags are</span>
 <span class="s0">* different; and the nodes may be sorted into a consistent (but arbitrary)</span>
 <span class="s0">* ordering based on this number.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">int PandaNode::compare_tags(PandaNode const *other) const;</span>

<span class="s0">2199 19 copy_all_properties 0 4 3615 30 PandaNode::copy_all_properties 0 1 326 264</span>
<span class="s0">/**</span>
 <span class="s0">* Copies the TransformState, RenderState, RenderEffects, tags, Python tags,</span>
 <span class="s0">* and the show/hide state from the other node onto this one.  Typically this</span>
 <span class="s0">* is used to prepare a node to replace another node in the scene graph (also</span>
 <span class="s0">* see replace_node()).</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void PandaNode::copy_all_properties(PandaNode *other);</span>

<span class="s0">2200 12 replace_node 0 4 3615 23 PandaNode::replace_node 0 1 327 602</span>
<span class="s0">/**</span>
 <span class="s0">* Inserts this node into the scene graph in place of the other one, and</span>
 <span class="s0">* removes the other node.  All scene graph attributes (TransformState,</span>
 <span class="s0">* RenderState, etc.) are copied to this node.</span>
 <span class="s0">*</span>
 <span class="s0">* All children are moved to this node, and removed from the old node.  The</span>
 <span class="s0">* new node is left in the same place in the old node's parent's list of</span>
 <span class="s0">* children.</span>
 <span class="s0">*</span>
 <span class="s0">* Even NodePaths that reference the old node are updated in-place to</span>
 <span class="s0">* reference the new node instead.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended to be used to replace a node of a given type in the</span>
 <span class="s0">* scene graph with a node of a different type.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void PandaNode::replace_node(PandaNode *other);</span>

<span class="s0">2201 21 set_unexpected_change 0 4 3615 32 PandaNode::set_unexpected_change 0 1 328 627</span>
<span class="s0">/**</span>
 <span class="s0">* Sets one or more of the PandaNode::UnexpectedChange bits on, indicating</span>
 <span class="s0">* that the corresponding property should not change again on this node.  Once</span>
 <span class="s0">* one of these bits has been set, if the property changes, an assertion</span>
 <span class="s0">* failure will be raised, which is designed to assist the developer in</span>
 <span class="s0">* identifying the troublesome code that modified the property unexpectedly.</span>
 <span class="s0">*</span>
 <span class="s0">* The input parameter is the union of bits that are to be set.  To clear</span>
 <span class="s0">* these bits later, use clear_unexpected_change().</span>
 <span class="s0">*</span>
 <span class="s0">* Since this is a developer debugging tool only, this function does nothing</span>
 <span class="s0">* in a production (NDEBUG) build.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void PandaNode::set_unexpected_change(unsigned int flags);</span>

<span class="s0">2202 21 get_unexpected_change 0 4 3615 32 PandaNode::get_unexpected_change 0 1 329 409</span>
<span class="s0">/**</span>
 <span class="s0">* Returns nonzero if any of the bits in the input parameter are set on this</span>
 <span class="s0">* node, or zero if none of them are set.  More specifically, this returns the</span>
 <span class="s0">* particular set of bits (masked by the input parameter) that have been set</span>
 <span class="s0">* on this node.  See set_unexpected_change().</span>
 <span class="s0">*</span>
 <span class="s0">* Since this is a developer debugging tool only, this function always returns</span>
 <span class="s0">* zero in a production (NDEBUG) build.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">unsigned int PandaNode::get_unexpected_change(unsigned int flags) const;</span>

<span class="s0">2203 23 clear_unexpected_change 0 4 3615 34 PandaNode::clear_unexpected_change 0 1 330 373</span>
<span class="s0">/**</span>
 <span class="s0">* Sets one or more of the PandaNode::UnexpectedChange bits off, indicating</span>
 <span class="s0">* that the corresponding property may once again change on this node.  See</span>
 <span class="s0">* set_unexpected_change().</span>
 <span class="s0">*</span>
 <span class="s0">* The input parameter is the union of bits that are to be cleared.</span>
 <span class="s0">*</span>
 <span class="s0">* Since this is a developer debugging tool only, this function does nothing</span>
 <span class="s0">* in a production (NDEBUG) build.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void PandaNode::clear_unexpected_change(unsigned int flags);</span>

<span class="s0">2204 15 get_overall_bit 0 4 3615 26 PandaNode::get_overall_bit 0 1 331 189</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the special bit that, when specifically cleared in the node's</span>
 <span class="s0">* DrawMask, indicates that the node is hidden to all cameras, regardless of</span>
 <span class="s0">* the remaining DrawMask bits.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static inline DrawMask PandaNode::get_overall_bit(void);</span>

<span class="s0">2205 19 get_all_camera_mask 0 4 3615 30 PandaNode::get_all_camera_mask 0 1 332 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a DrawMask that is appropriate for rendering to all cameras.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">static inline DrawMask PandaNode::get_all_camera_mask(void);</span>

<span class="s0">2206 17 is_overall_hidden 0 4 3615 28 PandaNode::is_overall_hidden 0 1 333 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the node has been hidden to all cameras by clearing its</span>
 <span class="s0">* overall bit.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool PandaNode::is_overall_hidden(void) const;</span>

<span class="s0">2207 18 set_overall_hidden 0 4 3615 29 PandaNode::set_overall_hidden 0 1 334 411</span>
<span class="s0">/**</span>
 <span class="s0">* Sets or clears the hidden flag.  When the hidden flag is true, the node and</span>
 <span class="s0">* all of its children are invisible to all cameras, regardless of the setting</span>
 <span class="s0">* of any draw masks.  Setting the hidden flag to false restores the previous</span>
 <span class="s0">* visibility as established by the draw masks.</span>
 <span class="s0">*</span>
 <span class="s0">* This actually works by twiddling the reserved _overall_bit in the node's</span>
 <span class="s0">* draw mask, which has special meaning.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void PandaNode::set_overall_hidden(bool overall_hidden);</span>

<span class="s0">2208 16 adjust_draw_mask 0 4 3615 27 PandaNode::adjust_draw_mask 0 1 335 1343</span>
<span class="s0">/**</span>
 <span class="s0">* Adjusts the hide/show bits of this particular node.</span>
 <span class="s0">*</span>
 <span class="s0">* These three parameters can be used to adjust the _draw_control_mask and</span>
 <span class="s0">* _draw_show_mask independently, which work together to provide per-camera</span>
 <span class="s0">* visibility for the node and its descendents.</span>
 <span class="s0">*</span>
 <span class="s0">* _draw_control_mask indicates the bits in _draw_show_mask that are</span>
 <span class="s0">* significant.  Each different bit corresponds to a different camera (and</span>
 <span class="s0">* these bits are assigned via Camera::set_camera_mask()).</span>
 <span class="s0">*</span>
 <span class="s0">* Where _draw_control_mask has a 1 bit, a 1 bit in _draw_show_mask indicates</span>
 <span class="s0">* the node is visible to that camera, and a 0 bit indicates the node is</span>
 <span class="s0">* hidden to that camera.  Where _draw_control_mask is 0, the node is hidden</span>
 <span class="s0">* only if a parent node is hidden.</span>
 <span class="s0">*</span>
 <span class="s0">* The meaning of the three parameters is as follows:</span>
 <span class="s0">*</span>
 <span class="s0">* * Wherever show_mask is 1, _draw_show_mask and _draw_control_mask will be</span>
 <span class="s0">* set 1.  Thus, show_mask indicates the set of cameras to which the node</span>
 <span class="s0">* should be shown.</span>
 <span class="s0">*</span>
 <span class="s0">* * Wherever hide_mask is 1, _draw_show_mask will be set 0 and</span>
 <span class="s0">* _draw_control_mask will be set 1.  Thus, hide_mask indicates the set of</span>
 <span class="s0">* cameras from which the node should be hidden.</span>
 <span class="s0">*</span>
 <span class="s0">* * Wherever clear_mask is 1, _draw_control_mask will be set 0.  Thus,</span>
 <span class="s0">* clear_mask indicates the set of cameras from which the hidden state should</span>
 <span class="s0">* be inherited from a parent.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">void PandaNode::adjust_draw_mask(DrawMask show_mask, DrawMask hide_mask, DrawMask clear_mask);</span>

<span class="s0">2209 21 get_draw_control_mask 0 4 3615 32 PandaNode::get_draw_control_mask 0 1 336 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of bits in draw_show_mask that are considered meaningful.</span>
 <span class="s0">* See adjust_draw_mask().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline DrawMask PandaNode::get_draw_control_mask(void) const;</span>

<span class="s0">2210 18 get_draw_show_mask 0 4 3615 29 PandaNode::get_draw_show_mask 0 1 337 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the hide/show bits of this particular node.  See</span>
 <span class="s0">* adjust_draw_mask().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline DrawMask PandaNode::get_draw_show_mask(void) const;</span>

<span class="s0">2211 25 get_net_draw_control_mask 0 4 3615 36 PandaNode::get_net_draw_control_mask 0 1 338 366</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of bits in get_net_draw_show_mask() that have been</span>
 <span class="s0">* explicitly set via adjust_draw_mask(), rather than implicitly inherited.</span>
 <span class="s0">*</span>
 <span class="s0">* A 1 bit in any position of this mask indicates that (a) this node has</span>
 <span class="s0">* renderable children, and (b) some child of this node has made an explicit</span>
 <span class="s0">* hide() or show_through() call for the corresponding bit.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">DrawMask PandaNode::get_net_draw_control_mask(void) const;</span>

<span class="s0">2212 22 get_net_draw_show_mask 0 4 3615 33 PandaNode::get_net_draw_show_mask 0 1 339 576</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of all draw_show_mask values--of renderable nodes only--</span>
 <span class="s0">* at this level and below.  If any bit in this mask is 0, there is no reason</span>
 <span class="s0">* to traverse below this node for a camera with the corresponding</span>
 <span class="s0">* camera_mask.</span>
 <span class="s0">*</span>
 <span class="s0">* The bits in this mask that do not correspond to a 1 bit in the</span>
 <span class="s0">* net_draw_control_mask are meaningless (and will be set to 1).  For bits</span>
 <span class="s0">* that *do* correspond to a 1 bit in the net_draw_control_mask, a 1 bit</span>
 <span class="s0">* indicates that at least one child should be visible, while a 0 bit</span>
 <span class="s0">* indicates that all children are hidden.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">DrawMask PandaNode::get_net_draw_show_mask(void) const;</span>

<span class="s0">2213 21 set_into_collide_mask 0 4 3615 32 PandaNode::set_into_collide_mask 0 1 340 510</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;into&quot; CollideMask.</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the set of bits that must be shared with a CollisionNode's</span>
 <span class="s0">* &quot;from&quot; CollideMask in order for the CollisionNode to detect a collision</span>
 <span class="s0">* with this particular node.</span>
 <span class="s0">*</span>
 <span class="s0">* The actual CollideMask that will be set is masked by the return value from</span>
 <span class="s0">* get_legal_collide_mask(). Thus, the into_collide_mask cannot be set to</span>
 <span class="s0">* anything other than nonzero except for those types of nodes that can be</span>
 <span class="s0">* collided into, such as CollisionNodes and GeomNodes.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void PandaNode::set_into_collide_mask(CollideMask mask);</span>

<span class="s0">2214 21 get_into_collide_mask 0 4 3615 32 PandaNode::get_into_collide_mask 0 1 341 57</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;into&quot; collide mask for this node.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline CollideMask PandaNode::get_into_collide_mask(void) const;</span>

<span class="s0">2215 22 get_legal_collide_mask 0 6 3615 33 PandaNode::get_legal_collide_mask 0 1 342 314</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the subset of CollideMask bits that may be set for this particular</span>
 <span class="s0">* type of PandaNode.  For most nodes, this is 0; it doesn't make sense to set</span>
 <span class="s0">* a CollideMask for most kinds of nodes.</span>
 <span class="s0">*</span>
 <span class="s0">* For nodes that can be collided with, such as GeomNode and CollisionNode,</span>
 <span class="s0">* this returns all bits on.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">virtual CollideMask PandaNode::get_legal_collide_mask(void) const;</span>

<span class="s0">2216 20 get_net_collide_mask 0 4 3615 31 PandaNode::get_net_collide_mask 0 1 343 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of all into_collide_mask() values set at CollisionNodes</span>
 <span class="s0">* at this level and below.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">CollideMask PandaNode::get_net_collide_mask(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2217 19 get_off_clip_planes 0 4 3615 30 PandaNode::get_off_clip_planes 0 1 344 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a ClipPlaneAttrib which represents the union of all of the clip</span>
 <span class="s0">* planes that have been turned *off* at this level and below.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; PandaNode::get_off_clip_planes(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2218 13 prepare_scene 0 4 3615 24 PandaNode::prepare_scene 0 1 345 470</span>
<span class="s0">/**</span>
 <span class="s0">* Walks through the scene graph beginning at this node, and does whatever</span>
 <span class="s0">* initialization is required to render the scene properly with the indicated</span>
 <span class="s0">* GSG.  It is not strictly necessary to call this, since the GSG will</span>
 <span class="s0">* initialize itself when the scene is rendered, but this may take some of the</span>
 <span class="s0">* overhead away from that process.</span>
 <span class="s0">*</span>
 <span class="s0">* In particular, this will ensure that textures and vertex buffers within the</span>
 <span class="s0">* scene are loaded into graphics memory.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">void PandaNode::prepare_scene(GraphicsStateGuardianBase *gsg, RenderState const *node_state);</span>

<span class="s0">2219 13 is_scene_root 0 4 3615 24 PandaNode::is_scene_root 0 1 346 173</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this particular node is known to be the render root of some</span>
 <span class="s0">* active DisplayRegion associated with the global GraphicsEngine, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">bool PandaNode::is_scene_root(void) const;</span>

<span class="s0">2220 19 is_under_scene_root 0 4 3615 30 PandaNode::is_under_scene_root 0 1 347 305</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this particular node is in a live scene graph: that is, it</span>
 <span class="s0">* is a child or descendent of a node that is itself a scene root.  If this is</span>
 <span class="s0">* true, this node may potentially be traversed by the render traverser.</span>
 <span class="s0">* Stashed nodes don't count for this purpose, but hidden nodes do.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool PandaNode::is_under_scene_root(void) const;</span>

<span class="s0">2221 6 output 0 6 3615 17 PandaNode::output 0 1 348 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual void PandaNode::output(std::ostream &amp;out) const;</span>

<span class="s0">2222 5 write 0 6 3615 16 PandaNode::write 0 1 349 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">virtual void PandaNode::write(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2223 2 ls 0 4 3615 13 PandaNode::ls 0 1 350 76</span>
<span class="s0">/**</span>
 <span class="s0">* Lists all the nodes at and below the current path hierarchically.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void PandaNode::ls(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2224 15 set_bounds_type 0 4 3615 26 PandaNode::set_bounds_type 0 1 351 1282</span>
<span class="s0">// We define set_bounds() and get_bounds() functions so that set_bounds()</span>
<span class="s0">// sets the user bounding volume, while get_bounds() returns the external</span>
<span class="s0">// bounding volume.  Although it might seem strange and confusing to do</span>
<span class="s0">// this, this is actually the natural way the user thinks about nodes and</span>
<span class="s0">// bounding volumes.</span>

<span class="s0">// We define set_bounds() and get_bounds() functions so that set_bounds()</span>
<span class="s0">// sets the user bounding volume, while get_bounds() returns the external</span>
<span class="s0">// bounding volume.  Although it might seem strange and confusing to do</span>
<span class="s0">// this, this is actually the natural way the user thinks about nodes and</span>
<span class="s0">// bounding volumes.</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies the desired type of bounding volume that will be created for this</span>
 <span class="s0">* node.  This is normally BoundingVolume::BT_default, which means to set the</span>
 <span class="s0">* type according to the config variable &quot;bounds-type&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is BT_sphere or BT_box, a BoundingSphere or BoundingBox is</span>
 <span class="s0">* explicitly created.  If it is BT_best, the appropriate type to best enclose</span>
 <span class="s0">* the node's children is created.</span>
 <span class="s0">*</span>
 <span class="s0">* This affects the bounding volume returned by get_bounds(), which is not</span>
 <span class="s0">* exactly the same bounding volume modified by set_bounds(), because a new</span>
 <span class="s0">* bounding volume has to be created that includes this node and all of its</span>
 <span class="s0">* children.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void PandaNode::set_bounds_type(BoundingVolume::BoundsType bounds_type);</span>

<span class="s0">2225 15 get_bounds_type 0 4 3615 26 PandaNode::get_bounds_type 0 1 352 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bounding volume type set with set_bounds_type().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">BoundingVolume::BoundsType PandaNode::get_bounds_type(void) const;</span>

<span class="s0">2226 10 set_bounds 0 4 3615 21 PandaNode::set_bounds 0 1 353 478</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the bounding volume so that it is the indicated volume.  When it is</span>
 <span class="s0">* explicitly set, the bounding volume will no longer be automatically</span>
 <span class="s0">* computed according to the contents of the node itself, for nodes like</span>
 <span class="s0">* GeomNodes and TextNodes that contain substance (but the bounding volume</span>
 <span class="s0">* will still be automatically expanded to include its children).</span>
 <span class="s0">*</span>
 <span class="s0">* Call clear_bounds() if you would like to return the bounding volume to its</span>
 <span class="s0">* default behavior later.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void PandaNode::set_bounds(BoundingVolume const *volume);</span>

<span class="s0">2227 9 set_bound 0 4 3615 20 PandaNode::set_bound 0 1 354 48</span>
<span class="s0">/**</span>
 <span class="s0">* @deprecated Use set_bounds() instead.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void PandaNode::set_bound(BoundingVolume const *volume);</span>

<span class="s0">2228 12 clear_bounds 0 4 3615 23 PandaNode::clear_bounds 0 1 355 184</span>
<span class="s0">/**</span>
 <span class="s0">* Reverses the effect of a previous call to set_bounds(), and allows the</span>
 <span class="s0">* node's bounding volume to be automatically computed once more based on the</span>
 <span class="s0">* contents of the node.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void PandaNode::clear_bounds(void);</span>

<span class="s0">2229 10 get_bounds 0 4 3615 21 PandaNode::get_bounds 0 2 356 357 790</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the external bounding volume of this node: a bounding volume that</span>
 <span class="s0">* contains the user bounding volume, the internal bounding volume, and all of</span>
 <span class="s0">* the children's bounding volumes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of get_bounds() return the external bounding volume, and also</span>
 <span class="s0">* fills in seq with the bounding volume's current sequence number.  When this</span>
 <span class="s0">* sequence number changes, it indicates that the bounding volume might have</span>
 <span class="s0">* changed, e.g.  because some nested child's bounding volume has changed.</span>
 <span class="s0">*</span>
 <span class="s0">* Although this might occasionally increment without changing the bounding</span>
 <span class="s0">* volume, the bounding volume will never change without incrementing this</span>
 <span class="s0">* counter, so as long as this counter remains unchanged you can be confident</span>
 <span class="s0">* the bounding volume is also unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">249</span>
<span class="s0">ConstPointerTo&lt; BoundingVolume &gt; PandaNode::get_bounds(Thread *current_thread = Thread::get_current_thread()) const;</span>
<span class="s0">ConstPointerTo&lt; BoundingVolume &gt; PandaNode::get_bounds(UpdateSeq &amp;seq, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2230 19 get_nested_vertices 0 4 3615 30 PandaNode::get_nested_vertices 0 1 358 422</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of vertices that will be rendered by this node and</span>
 <span class="s0">* all of its descendents.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not necessarily an accurate count of vertices that will actually be</span>
 <span class="s0">* rendered, since this will include all vertices of all LOD's, and it will</span>
 <span class="s0">* also include hidden nodes.  It may also omit or only approximate certain</span>
 <span class="s0">* kinds of dynamic geometry.  However, it will not include stashed nodes.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">int PandaNode::get_nested_vertices(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2231 19 get_internal_bounds 0 4 3615 30 PandaNode::get_internal_bounds 0 1 359 361</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node's internal bounding volume.  This is the bounding volume</span>
 <span class="s0">* around the node alone, without including children.  If the user has called</span>
 <span class="s0">* set_bounds(), it will be the specified bounding volume.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the node's internal bounding volume.  This is the bounding volume</span>
 <span class="s0">* around the node alone, without including children.</span>
 <span class="s0">*/</span>
<span class="s0">132</span>
<span class="s0">inline ConstPointerTo&lt; BoundingVolume &gt; PandaNode::get_internal_bounds(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2232 21 get_internal_vertices 0 4 3615 32 PandaNode::get_internal_vertices 0 1 360 412</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of vertices that will be rendered by this</span>
 <span class="s0">* particular node alone, not accounting for its children.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not include all vertices for certain dynamic effects.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the total number of vertices that will be rendered by this</span>
 <span class="s0">* particular node alone, not accounting for its children.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not include all vertices for certain dynamic effects.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">inline int PandaNode::get_internal_vertices(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2233 17 mark_bounds_stale 0 4 3615 28 PandaNode::mark_bounds_stale 0 1 361 786</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the bounding volume, or something that influences the</span>
 <span class="s0">* bounding volume (or any of the other things stored in CData, like</span>
 <span class="s0">* net_collide_mask), may have changed for this node, and that it must be</span>
 <span class="s0">* recomputed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Indicates that the bounding volume, or something that influences the</span>
 <span class="s0">* bounding volume (or any of the other things stored in CData, like</span>
 <span class="s0">* net_collide_mask), may have changed for this node, and that it must be</span>
 <span class="s0">* recomputed.</span>
 <span class="s0">*</span>
 <span class="s0">* With no parameters, this means to iterate through all stages including and</span>
 <span class="s0">* upstream of the current pipeline stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for internal use; usually it is not necessary for a</span>
 <span class="s0">* user to call this directly.  It will be called automatically by derived</span>
 <span class="s0">* classes when appropriate.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">void PandaNode::mark_bounds_stale(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2234 26 mark_internal_bounds_stale 0 4 3615 37 PandaNode::mark_internal_bounds_stale 0 1 362 654</span>
<span class="s0">/**</span>
 <span class="s0">* Should be called by a derived class to mark the internal bounding volume</span>
 <span class="s0">* stale, so that recompute_internal_bounds() will be called when the bounding</span>
 <span class="s0">* volume is next requested.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Should be called by a derived class to mark the internal bounding volume</span>
 <span class="s0">* stale, so that compute_internal_bounds() will be called when the bounding</span>
 <span class="s0">* volume is next requested.</span>
 <span class="s0">*</span>
 <span class="s0">* With no parameters, this means to iterate through all stages including and</span>
 <span class="s0">* upstream of the current pipeline stage.</span>
 <span class="s0">*</span>
 <span class="s0">* It is normally not necessary to call this method directly; each node should</span>
 <span class="s0">* be responsible for calling it when its internals have changed.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">void PandaNode::mark_internal_bounds_stale(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2235 15 is_bounds_stale 0 4 3615 26 PandaNode::is_bounds_stale 0 1 363 194</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the bounding volume of this node is stale and will be</span>
 <span class="s0">* implicitly recomputed at the next call to get_bounds(), or false if it is</span>
 <span class="s0">* fresh and need not be recomputed.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool PandaNode::is_bounds_stale(void) const;</span>

<span class="s0">2236 9 set_final 0 4 3615 20 PandaNode::set_final 0 1 364 623</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;final&quot; flag on this PandaNode.  If this is true, than no bounding</span>
 <span class="s0">* volume need be tested below it; a positive intersection with this node's</span>
 <span class="s0">* bounding volume is deemed to be a positive intersection with all geometry</span>
 <span class="s0">* inside.</span>
 <span class="s0">*</span>
 <span class="s0">* This is useful to quickly force a larger bounding volume around a node when</span>
 <span class="s0">* the GeomNodes themselves are inaccurate for some reason, without forcing a</span>
 <span class="s0">* recompute of every nested bounding volume.  It's also helpful when the</span>
 <span class="s0">* bounding volume is tricked by some special properties, like billboards,</span>
 <span class="s0">* that may move geometry out of its bounding volume otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void PandaNode::set_final(bool flag);</span>

<span class="s0">2237 8 is_final 0 4 3615 19 PandaNode::is_final 0 1 365 177</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current state of the &quot;final&quot; flag.  Initially, this flag is off</span>
 <span class="s0">* (false), but it may be changed by an explicit call to set_final().  See</span>
 <span class="s0">* set_final().</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline bool PandaNode::is_final(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2238 12 is_geom_node 0 6 3615 23 PandaNode::is_geom_node 0 1 366 276</span>
<span class="s0">/**</span>
 <span class="s0">* A simple downcast check.  Returns true if this kind of node happens to</span>
 <span class="s0">* inherit from GeomNode, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is provided as a a faster alternative to calling</span>
 <span class="s0">* is_of_type(GeomNode::get_class_type()), since this test is so important to</span>
 <span class="s0">* rendering.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">virtual bool PandaNode::is_geom_node(void) const;</span>

<span class="s0">2239 11 is_lod_node 0 6 3615 22 PandaNode::is_lod_node 0 1 367 225</span>
<span class="s0">/**</span>
 <span class="s0">* A simple downcast check.  Returns true if this kind of node happens to</span>
 <span class="s0">* inherit from LODNode, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is provided as a a faster alternative to calling</span>
 <span class="s0">* is_of_type(LODNode::get_class_type()).</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">virtual bool PandaNode::is_lod_node(void) const;</span>

<span class="s0">2240 17 is_collision_node 0 6 3615 28 PandaNode::is_collision_node 0 1 368 237</span>
<span class="s0">/**</span>
 <span class="s0">* A simple downcast check.  Returns true if this kind of node happens to</span>
 <span class="s0">* inherit from CollisionNode, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is provided as a a faster alternative to calling</span>
 <span class="s0">* is_of_type(CollisionNode::get_class_type()).</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">virtual bool PandaNode::is_collision_node(void) const;</span>

<span class="s0">2241 8 as_light 0 6 3615 19 PandaNode::as_light 0 1 369 131</span>
<span class="s0">/**</span>
 <span class="s0">* Cross-casts the node to a Light pointer, if it is one of the four kinds of</span>
 <span class="s0">* Light nodes, or returns NULL if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">virtual Light *PandaNode::as_light(void);</span>

<span class="s0">2242 16 is_ambient_light 0 6 3615 27 PandaNode::is_ambient_light 0 1 370 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is an AmbientLight, false if it is not a light, or it</span>
 <span class="s0">* is some other kind of light.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">virtual bool PandaNode::is_ambient_light(void) const;</span>

<span class="s0">2243 14 get_fancy_bits 0 4 3615 25 PandaNode::get_fancy_bits 0 1 371 330</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of all of the enum FancyBits values corresponding to the</span>
 <span class="s0">* various &quot;fancy&quot; attributes that are set on the node.  If this returns 0,</span>
 <span class="s0">* the node has nothing interesting about it.  This is intended to speed</span>
 <span class="s0">* traversal by quickly skipping past nodes that don't particularly affect the</span>
 <span class="s0">* render state.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline int PandaNode::get_fancy_bits(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2244 22 decode_from_bam_stream 0 4 3615 33 PandaNode::decode_from_bam_stream 0 1 372 470</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the bytes created by a previous call to encode_to_bam_stream(), and</span>
 <span class="s0">* extracts and returns the single object on those bytes.  Returns NULL on</span>
 <span class="s0">* error.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended to replace decode_raw_from_bam_stream() when you</span>
 <span class="s0">* know the stream in question returns an object of type PandaNode, allowing</span>
 <span class="s0">* for easier reference count management.  Note that the caller is still</span>
 <span class="s0">* responsible for maintaining the reference count on the return value.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">static PointerTo&lt; PandaNode &gt; PandaNode::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr);</span>

<span class="s0">2245 11 operator [] 0 4 3635 32 PandaNode::Children::operator [] 0 1 379 0</span>
<span class="s0">72</span>
<span class="s0">inline PandaNode *PandaNode::Children::operator [](std::size_t n) const;</span>

<span class="s0">2246 4 size 0 4 3635 25 PandaNode::Children::size 0 1 380 0</span>
<span class="s0">57</span>
<span class="s0">inline std::size_t PandaNode::Children::size(void) const;</span>

<span class="s0">2247 9 ~Children 0 516 3635 30 PandaNode::Children::~Children 0 0 0</span>
<span class="s0">37</span>
<span class="s0">PandaNode::Children::~Children(void);</span>

<span class="s0">2248 11 operator [] 0 4 3636 31 PandaNode::Stashed::operator [] 0 1 381 0</span>
<span class="s0">71</span>
<span class="s0">inline PandaNode *PandaNode::Stashed::operator [](std::size_t n) const;</span>

<span class="s0">2249 4 size 0 4 3636 24 PandaNode::Stashed::size 0 1 382 0</span>
<span class="s0">56</span>
<span class="s0">inline std::size_t PandaNode::Stashed::size(void) const;</span>

<span class="s0">2250 8 ~Stashed 0 516 3636 28 PandaNode::Stashed::~Stashed 0 0 0</span>
<span class="s0">35</span>
<span class="s0">PandaNode::Stashed::~Stashed(void);</span>

<span class="s0">2251 11 operator [] 0 4 3637 31 PandaNode::Parents::operator [] 0 1 383 0</span>
<span class="s0">71</span>
<span class="s0">inline PandaNode *PandaNode::Parents::operator [](std::size_t n) const;</span>

<span class="s0">2252 4 size 0 4 3637 24 PandaNode::Parents::size 0 1 384 0</span>
<span class="s0">56</span>
<span class="s0">inline std::size_t PandaNode::Parents::size(void) const;</span>

<span class="s0">2253 8 ~Parents 0 516 3637 28 PandaNode::Parents::~Parents 0 0 0</span>
<span class="s0">35</span>
<span class="s0">PandaNode::Parents::~Parents(void);</span>

<span class="s0">2254 12 get_children 0 4 3615 23 PandaNode::get_children 0 0 622</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an object that can be used to walk through the list of children of</span>
 <span class="s0">* the node.  When you intend to visit multiple children, using this is</span>
 <span class="s0">* slightly faster than calling get_child() directly on the PandaNode, since</span>
 <span class="s0">* this object avoids reopening the PipelineCycler each time.</span>
 <span class="s0">*</span>
 <span class="s0">* This object also protects you from self-modifying loops (e.g.  adding or</span>
 <span class="s0">* removing children during traversal), since a virtual copy of the children</span>
 <span class="s0">* is made ahead of time.  The virtual copy is fast--it is a form of copy-on-</span>
 <span class="s0">* write, so the list is not actually copied unless it is modified during the</span>
 <span class="s0">* traversal.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">inline PandaNode::Children PandaNode::get_children(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2255 11 get_parents 0 4 3615 22 PandaNode::get_parents 0 0 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an object that can be used to walk through the list of parents of</span>
 <span class="s0">* the node, similar to get_children() and get_stashed().</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">inline PandaNode::Parents PandaNode::get_parents(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2256 14 get_class_type 0 4 3615 25 PandaNode::get_class_type 0 1 373 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle PandaNode::get_class_type(void);</span>

<span class="s0">2257 4 make 0 4 3638 24 TransparencyAttrib::make 0 1 385 54</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new TransparencyAttrib object.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TransparencyAttrib::make(TransparencyAttrib::Mode mode);</span>

<span class="s0">2258 12 make_default 0 4 3638 32 TransparencyAttrib::make_default 0 1 386 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TransparencyAttrib::make_default(void);</span>

<span class="s0">2259 8 get_mode 0 4 3638 28 TransparencyAttrib::get_mode 0 1 387 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transparency mode.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline TransparencyAttrib::Mode TransparencyAttrib::get_mode(void) const;</span>

<span class="s0">2260 14 get_class_slot 0 4 3638 34 TransparencyAttrib::get_class_slot 0 1 388 0</span>
<span class="s0">52</span>
<span class="s0">static int TransparencyAttrib::get_class_slot(void);</span>

<span class="s0">2261 14 get_class_type 0 4 3638 34 TransparencyAttrib::get_class_type 0 1 389 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle TransparencyAttrib::get_class_type(void);</span>

<span class="s0">2262 19 ~TransparencyAttrib 0 516 3638 39 TransparencyAttrib::~TransparencyAttrib 0 0 0</span>
<span class="s0">46</span>
<span class="s0">TransparencyAttrib::~TransparencyAttrib(void);</span>

<span class="s0">2263 8 make_off 0 4 3640 23 LogicOpAttrib::make_off 0 1 390 139</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LogicOpAttrib object that disables special-effect</span>
 <span class="s0">* blending, allowing normal transparency to be used instead.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LogicOpAttrib::make_off(void);</span>

<span class="s0">2264 4 make 0 4 3640 19 LogicOpAttrib::make 0 1 391 80</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LogicOpAttrib object with the given logic operation.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LogicOpAttrib::make(LogicOpAttrib::Operation op);</span>

<span class="s0">2265 12 make_default 0 4 3640 27 LogicOpAttrib::make_default 0 1 392 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LogicOpAttrib::make_default(void);</span>

<span class="s0">2266 13 get_operation 0 4 3640 28 LogicOpAttrib::get_operation 0 1 393 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the logic operation specified by this attribute.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline LogicOpAttrib::Operation LogicOpAttrib::get_operation(void) const;</span>

<span class="s0">2267 14 get_class_slot 0 4 3640 29 LogicOpAttrib::get_class_slot 0 1 394 0</span>
<span class="s0">47</span>
<span class="s0">static int LogicOpAttrib::get_class_slot(void);</span>

<span class="s0">2268 14 get_class_type 0 4 3640 29 LogicOpAttrib::get_class_type 0 1 395 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle LogicOpAttrib::get_class_type(void);</span>

<span class="s0">2269 14 ~LogicOpAttrib 0 516 3640 29 LogicOpAttrib::~LogicOpAttrib 0 0 0</span>
<span class="s0">36</span>
<span class="s0">LogicOpAttrib::~LogicOpAttrib(void);</span>

<span class="s0">2270 9 get_blank 0 4 3642 22 ShaderInput::get_blank 0 1 401 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a static ShaderInput object with name NULL, priority zero, type</span>
 <span class="s0">* INVALID, and all value-fields cleared.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static ShaderInput const &amp;ShaderInput::get_blank(void);</span>

<span class="s0">2271 11 ShaderInput 0 260 3642 24 ShaderInput::ShaderInput 0 5 396 397 398 399 400 430</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">494</span>
<span class="s0">inline explicit ShaderInput::ShaderInput(CPT_InternalName name, int priority = 0);</span>
<span class="s0">explicit ShaderInput::ShaderInput(CPT_InternalName name, PyObject *value, int priority = 0);</span>
<span class="s0">explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, bool read, bool write, int z = -1, int n = 0, int priority = 0);</span>
<span class="s0">explicit ShaderInput::ShaderInput(CPT_InternalName name, Texture *tex, SamplerState const &amp;sampler, int priority = 0);</span>
<span class="s0">inline ShaderInput::ShaderInput(ShaderInput const &amp;) = default;</span>

<span class="s0">2272 22 operator typecast bool 0 132 3642 35 ShaderInput::operator typecast bool 0 1 414 0</span>
<span class="s0">34</span>
<span class="s0">inline operator bool (void) const;</span>

<span class="s0">2273 11 operator == 0 4 3642 24 ShaderInput::operator == 0 1 402 0</span>
<span class="s0">69</span>
<span class="s0">inline bool ShaderInput::operator ==(ShaderInput const &amp;other) const;</span>

<span class="s0">2274 11 operator != 0 4 3642 24 ShaderInput::operator != 0 1 403 0</span>
<span class="s0">69</span>
<span class="s0">inline bool ShaderInput::operator !=(ShaderInput const &amp;other) const;</span>

<span class="s0">2275 10 operator &lt; 0 4 3642 23 ShaderInput::operator &lt; 0 1 404 0</span>
<span class="s0">68</span>
<span class="s0">inline bool ShaderInput::operator &lt;(ShaderInput const &amp;other) const;</span>

<span class="s0">2276 8 add_hash 0 4 3642 21 ShaderInput::add_hash 0 1 405 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">std::size_t ShaderInput::add_hash(std::size_t hash) const;</span>

<span class="s0">2277 8 get_name 0 4 3642 21 ShaderInput::get_name 0 1 406 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline InternalName const *ShaderInput::get_name(void) const;</span>

<span class="s0">2278 14 get_value_type 0 4 3642 27 ShaderInput::get_value_type 0 1 407 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int ShaderInput::get_value_type(void) const;</span>

<span class="s0">2279 12 get_priority 0 4 3642 25 ShaderInput::get_priority 0 1 408 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int ShaderInput::get_priority(void) const;</span>

<span class="s0">2280 10 get_vector 0 4 3642 23 ShaderInput::get_vector 0 1 409 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase4 const &amp;ShaderInput::get_vector(void) const;</span>

<span class="s0">2281 7 get_ptr 0 4 3642 20 ShaderInput::get_ptr 0 1 410 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline Shader::ShaderPtrData const &amp;ShaderInput::get_ptr(void) const;</span>

<span class="s0">2282 12 get_nodepath 0 4 3642 25 ShaderInput::get_nodepath 0 1 411 107</span>
<span class="s0">/**</span>
 <span class="s0">* Warning: no error checking is done.  This *will* crash if get_value_type()</span>
 <span class="s0">* is not M_nodepath.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">NodePath const &amp;ShaderInput::get_nodepath(void) const;</span>

<span class="s0">2283 11 get_texture 0 4 3642 24 ShaderInput::get_texture 0 1 412 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">Texture *ShaderInput::get_texture(void) const;</span>

<span class="s0">2284 11 get_sampler 0 4 3642 24 ShaderInput::get_sampler 0 1 413 46</span>
<span class="s0">/**</span>
 <span class="s0">* Warning: no error checking is done.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">SamplerState const &amp;ShaderInput::get_sampler(void) const;</span>

<span class="s0">2285 12 ~ShaderInput 0 516 3642 25 ShaderInput::~ShaderInput 0 0 0</span>
<span class="s0">32</span>
<span class="s0">ShaderInput::~ShaderInput(void);</span>

<span class="s0">2286 22 InternalNameCollection 0 260 3645 46 InternalNameCollection::InternalNameCollection 0 2 415 416 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">137</span>
<span class="s0">InternalNameCollection::InternalNameCollection(void);</span>
<span class="s0">InternalNameCollection::InternalNameCollection(InternalNameCollection const &amp;copy);</span>

<span class="s0">2287 10 operator = 0 4 3645 34 InternalNameCollection::operator = 0 1 417 0</span>
<span class="s0">76</span>
<span class="s0">void InternalNameCollection::operator =(InternalNameCollection const &amp;copy);</span>

<span class="s0">2288 23 ~InternalNameCollection 0 516 3645 47 InternalNameCollection::~InternalNameCollection 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline InternalNameCollection::~InternalNameCollection(void);</span>

<span class="s0">2289 8 add_name 0 4 3645 32 InternalNameCollection::add_name 0 1 418 53</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new InternalName to the collection.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void InternalNameCollection::add_name(InternalName const *name);</span>

<span class="s0">2290 11 remove_name 0 4 3645 35 InternalNameCollection::remove_name 0 1 419 156</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated InternalName from the collection.  Returns true if</span>
 <span class="s0">* the name was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">bool InternalNameCollection::remove_name(InternalName const *name);</span>

<span class="s0">2291 14 add_names_from 0 4 3645 38 InternalNameCollection::add_names_from 0 1 420 207</span>
<span class="s0">/**</span>
 <span class="s0">* Adds all the InternalNames indicated in the other collection to this name.</span>
 <span class="s0">* The other names are simply appended to the end of the names in this list;</span>
 <span class="s0">* duplicates are not automatically removed.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">void InternalNameCollection::add_names_from(InternalNameCollection const &amp;other);</span>

<span class="s0">2292 17 remove_names_from 0 4 3645 41 InternalNameCollection::remove_names_from 0 1 421 99</span>
<span class="s0">/**</span>
 <span class="s0">* Removes from this collection all of the InternalNames listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">void InternalNameCollection::remove_names_from(InternalNameCollection const &amp;other);</span>

<span class="s0">2293 22 remove_duplicate_names 0 4 3645 46 InternalNameCollection::remove_duplicate_names 0 1 422 204</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any duplicate entries of the same InternalNames on this collection.</span>
 <span class="s0">* If a InternalName appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void InternalNameCollection::remove_duplicate_names(void);</span>

<span class="s0">2294 8 has_name 0 4 3645 32 InternalNameCollection::has_name 0 1 423 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated InternalName appears in this collection,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">bool InternalNameCollection::has_name(InternalName const *name) const;</span>

<span class="s0">2295 5 clear 0 4 3645 29 InternalNameCollection::clear 0 1 424 57</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all InternalNames from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void InternalNameCollection::clear(void);</span>

<span class="s0">2296 13 get_num_names 0 4 3645 37 InternalNameCollection::get_num_names 0 1 425 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of InternalNames in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int InternalNameCollection::get_num_names(void) const;</span>

<span class="s0">2297 8 get_name 0 4 3645 32 InternalNameCollection::get_name 0 1 426 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth InternalName in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">InternalName const *InternalNameCollection::get_name(int index) const;</span>

<span class="s0">2298 11 operator [] 0 4 3645 35 InternalNameCollection::operator [] 0 1 427 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth InternalName in the collection.  This is the same as</span>
 <span class="s0">* get_name(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">InternalName const *InternalNameCollection::operator [](int index) const;</span>

<span class="s0">2299 4 size 0 4 3645 28 InternalNameCollection::size 0 1 428 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of names in the collection.  This is the same thing as</span>
 <span class="s0">* get_num_names().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int InternalNameCollection::size(void) const;</span>

<span class="s0">2300 11 operator += 0 4 3645 35 InternalNameCollection::operator += 0 1 429 0</span>
<span class="s0">85</span>
<span class="s0">inline void InternalNameCollection::operator +=(InternalNameCollection const &amp;other);</span>

<span class="s0">2301 10 operator + 0 4 3645 34 InternalNameCollection::operator + 0 1 430 0</span>
<span class="s0">108</span>
<span class="s0">inline InternalNameCollection InternalNameCollection::operator +(InternalNameCollection const &amp;other) const;</span>

<span class="s0">2302 6 output 0 4 3645 30 InternalNameCollection::output 0 1 431 111</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief one-line description of the InternalNameCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void InternalNameCollection::output(std::ostream &amp;out) const;</span>

<span class="s0">2303 5 write 0 4 3645 29 InternalNameCollection::write 0 1 432 116</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a complete multi-line description of the InternalNameCollection to</span>
 <span class="s0">* the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void InternalNameCollection::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2304 18 MaterialCollection 0 260 3646 38 MaterialCollection::MaterialCollection 0 2 433 434 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">MaterialCollection::MaterialCollection(void);</span>
<span class="s0">MaterialCollection::MaterialCollection(MaterialCollection const &amp;copy);</span>

<span class="s0">2305 10 operator = 0 4 3646 30 MaterialCollection::operator = 0 1 435 0</span>
<span class="s0">68</span>
<span class="s0">void MaterialCollection::operator =(MaterialCollection const &amp;copy);</span>

<span class="s0">2306 19 ~MaterialCollection 0 516 3646 39 MaterialCollection::~MaterialCollection 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline MaterialCollection::~MaterialCollection(void);</span>

<span class="s0">2307 12 add_material 0 4 3646 32 MaterialCollection::add_material 0 1 436 49</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new Material to the collection.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void MaterialCollection::add_material(Material *node_material);</span>

<span class="s0">2308 15 remove_material 0 4 3646 35 MaterialCollection::remove_material 0 1 437 156</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated Material from the collection.  Returns true if the</span>
 <span class="s0">* material was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">bool MaterialCollection::remove_material(Material *node_material);</span>

<span class="s0">2309 18 add_materials_from 0 4 3646 38 MaterialCollection::add_materials_from 0 1 438 215</span>
<span class="s0">/**</span>
 <span class="s0">* Adds all the Materials indicated in the other collection to this material.</span>
 <span class="s0">* The other materials are simply appended to the end of the materials in this</span>
 <span class="s0">* list; duplicates are not automatically removed.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">void MaterialCollection::add_materials_from(MaterialCollection const &amp;other);</span>

<span class="s0">2310 21 remove_materials_from 0 4 3646 41 MaterialCollection::remove_materials_from 0 1 439 95</span>
<span class="s0">/**</span>
 <span class="s0">* Removes from this collection all of the Materials listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">void MaterialCollection::remove_materials_from(MaterialCollection const &amp;other);</span>

<span class="s0">2311 26 remove_duplicate_materials 0 4 3646 46 MaterialCollection::remove_duplicate_materials 0 1 440 197</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any duplicate entries of the same Materials on this collection.  If</span>
 <span class="s0">* a Material appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void MaterialCollection::remove_duplicate_materials(void);</span>

<span class="s0">2312 12 has_material 0 4 3646 32 MaterialCollection::has_material 0 1 441 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated Material appears in this collection, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool MaterialCollection::has_material(Material *material) const;</span>

<span class="s0">2313 5 clear 0 4 3646 25 MaterialCollection::clear 0 1 442 53</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all Materials from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void MaterialCollection::clear(void);</span>

<span class="s0">2314 13 find_material 0 4 3646 33 MaterialCollection::find_material 0 1 443 123</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the material in the collection with the indicated name, if any, or</span>
 <span class="s0">* NULL if no material has that name.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">Material *MaterialCollection::find_material(std::string const &amp;name) const;</span>

<span class="s0">2315 17 get_num_materials 0 4 3646 37 MaterialCollection::get_num_materials 0 1 444 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of Materials in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int MaterialCollection::get_num_materials(void) const;</span>

<span class="s0">2316 12 get_material 0 4 3646 32 MaterialCollection::get_material 0 1 445 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth Material in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">Material *MaterialCollection::get_material(int index) const;</span>

<span class="s0">2317 11 operator [] 0 4 3646 31 MaterialCollection::operator [] 0 1 446 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth Material in the collection.  This is the same as</span>
 <span class="s0">* get_material(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">Material *MaterialCollection::operator [](int index) const;</span>

<span class="s0">2318 4 size 0 4 3646 24 MaterialCollection::size 0 1 447 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of materials in the collection.  This is the same thing</span>
 <span class="s0">* as get_num_materials().</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">int MaterialCollection::size(void) const;</span>

<span class="s0">2319 11 operator += 0 4 3646 31 MaterialCollection::operator += 0 1 448 0</span>
<span class="s0">77</span>
<span class="s0">inline void MaterialCollection::operator +=(MaterialCollection const &amp;other);</span>

<span class="s0">2320 10 operator + 0 4 3646 30 MaterialCollection::operator + 0 1 449 0</span>
<span class="s0">96</span>
<span class="s0">inline MaterialCollection MaterialCollection::operator +(MaterialCollection const &amp;other) const;</span>

<span class="s0">2321 6 output 0 4 3646 26 MaterialCollection::output 0 1 450 107</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief one-line description of the MaterialCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void MaterialCollection::output(std::ostream &amp;out) const;</span>

<span class="s0">2322 5 write 0 4 3646 25 MaterialCollection::write 0 1 451 112</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a complete multi-line description of the MaterialCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void MaterialCollection::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2323 22 TextureStageCollection 0 260 3647 46 TextureStageCollection::TextureStageCollection 0 2 452 453 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">137</span>
<span class="s0">TextureStageCollection::TextureStageCollection(void);</span>
<span class="s0">TextureStageCollection::TextureStageCollection(TextureStageCollection const &amp;copy);</span>

<span class="s0">2324 10 operator = 0 4 3647 34 TextureStageCollection::operator = 0 1 454 0</span>
<span class="s0">76</span>
<span class="s0">void TextureStageCollection::operator =(TextureStageCollection const &amp;copy);</span>

<span class="s0">2325 23 ~TextureStageCollection 0 516 3647 47 TextureStageCollection::~TextureStageCollection 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline TextureStageCollection::~TextureStageCollection(void);</span>

<span class="s0">2326 17 add_texture_stage 0 4 3647 41 TextureStageCollection::add_texture_stage 0 1 455 53</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new TextureStage to the collection.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">void TextureStageCollection::add_texture_stage(TextureStage *node_texture_stage);</span>

<span class="s0">2327 20 remove_texture_stage 0 4 3647 44 TextureStageCollection::remove_texture_stage 0 1 456 168</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated TextureStage from the collection.  Returns true if</span>
 <span class="s0">* the texture_stage was removed, false if it was not a member of the</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">bool TextureStageCollection::remove_texture_stage(TextureStage *node_texture_stage);</span>

<span class="s0">2328 23 add_texture_stages_from 0 4 3647 47 TextureStageCollection::add_texture_stages_from 0 1 457 235</span>
<span class="s0">/**</span>
 <span class="s0">* Adds all the TextureStages indicated in the other collection to this</span>
 <span class="s0">* texture_stage.  The other texture_stages are simply appended to the end of</span>
 <span class="s0">* the texture_stages in this list; duplicates are not automatically removed.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">void TextureStageCollection::add_texture_stages_from(TextureStageCollection const &amp;other);</span>

<span class="s0">2329 26 remove_texture_stages_from 0 4 3647 50 TextureStageCollection::remove_texture_stages_from 0 1 458 99</span>
<span class="s0">/**</span>
 <span class="s0">* Removes from this collection all of the TextureStages listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">void TextureStageCollection::remove_texture_stages_from(TextureStageCollection const &amp;other);</span>

<span class="s0">2330 31 remove_duplicate_texture_stages 0 4 3647 55 TextureStageCollection::remove_duplicate_texture_stages 0 1 459 204</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any duplicate entries of the same TextureStages on this collection.</span>
 <span class="s0">* If a TextureStage appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void TextureStageCollection::remove_duplicate_texture_stages(void);</span>

<span class="s0">2331 17 has_texture_stage 0 4 3647 41 TextureStageCollection::has_texture_stage 0 1 460 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated TextureStage appears in this collection,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">bool TextureStageCollection::has_texture_stage(TextureStage *texture_stage) const;</span>

<span class="s0">2332 5 clear 0 4 3647 29 TextureStageCollection::clear 0 1 461 57</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all TextureStages from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void TextureStageCollection::clear(void);</span>

<span class="s0">2333 18 find_texture_stage 0 4 3647 42 TextureStageCollection::find_texture_stage 0 1 462 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the texture_stage in the collection with the indicated name, if</span>
 <span class="s0">* any, or NULL if no texture_stage has that name.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">TextureStage *TextureStageCollection::find_texture_stage(std::string const &amp;name) const;</span>

<span class="s0">2334 22 get_num_texture_stages 0 4 3647 46 TextureStageCollection::get_num_texture_stages 0 1 463 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of TextureStages in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">int TextureStageCollection::get_num_texture_stages(void) const;</span>

<span class="s0">2335 17 get_texture_stage 0 4 3647 41 TextureStageCollection::get_texture_stage 0 1 464 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth TextureStage in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">TextureStage *TextureStageCollection::get_texture_stage(int index) const;</span>

<span class="s0">2336 11 operator [] 0 4 3647 35 TextureStageCollection::operator [] 0 1 465 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth TextureStage in the collection.  This is the same as</span>
 <span class="s0">* get_texture_stage(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">TextureStage *TextureStageCollection::operator [](int index) const;</span>

<span class="s0">2337 4 size 0 4 3647 28 TextureStageCollection::size 0 1 466 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of texture stages in the collection.  This is the same</span>
 <span class="s0">* thing as get_num_texture_stages().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int TextureStageCollection::size(void) const;</span>

<span class="s0">2338 11 operator += 0 4 3647 35 TextureStageCollection::operator += 0 1 467 0</span>
<span class="s0">85</span>
<span class="s0">inline void TextureStageCollection::operator +=(TextureStageCollection const &amp;other);</span>

<span class="s0">2339 10 operator + 0 4 3647 34 TextureStageCollection::operator + 0 1 468 0</span>
<span class="s0">108</span>
<span class="s0">inline TextureStageCollection TextureStageCollection::operator +(TextureStageCollection const &amp;other) const;</span>

<span class="s0">2340 4 sort 0 4 3647 28 TextureStageCollection::sort 0 1 469 116</span>
<span class="s0">/**</span>
 <span class="s0">* Sorts the TextureStages in this collection into order by</span>
 <span class="s0">* TextureStage::sort(), from lowest to highest.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void TextureStageCollection::sort(void);</span>

<span class="s0">2341 6 output 0 4 3647 30 TextureStageCollection::output 0 1 470 111</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief one-line description of the TextureStageCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void TextureStageCollection::output(std::ostream &amp;out) const;</span>

<span class="s0">2342 5 write 0 4 3647 29 TextureStageCollection::write 0 1 471 116</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a complete multi-line description of the TextureStageCollection to</span>
 <span class="s0">* the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void TextureStageCollection::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2343 8 NodePath 0 260 3648 18 NodePath::NodePath 0 5 472 473 474 475 476 748</span>
<span class="s0">/**</span>
 <span class="s0">* This constructs an empty NodePath with no nodes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This constructs a new NodePath with a single node.  An ordinary, unattached</span>
 <span class="s0">* PandaNode is created with the indicated name.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This constructs a NodePath for the indicated node.  If the node does not</span>
 <span class="s0">* have any parents, this creates a singleton NodePath; otherwise, it</span>
 <span class="s0">* automatically finds the path from the node to the root.  If the node has</span>
 <span class="s0">* multiple paths to the root, one path is chosen arbitrarily and a warning</span>
 <span class="s0">* message is printed (but see also NodePath::any_path(), below).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a NodePath with the indicated parent NodePath and child node;</span>
 <span class="s0">* the child node must be a stashed or unstashed child of the parent.</span>
 <span class="s0">*/</span>
<span class="s0">445</span>
<span class="s0">inline NodePath::NodePath(void);</span>
<span class="s0">inline explicit NodePath::NodePath(std::string const &amp;top_node_name, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline explicit NodePath::NodePath(PandaNode *node, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">explicit NodePath::NodePath(NodePath const &amp;parent, PandaNode *child_node, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline NodePath::NodePath(NodePath const &amp;copy);</span>

<span class="s0">2344 8 any_path 0 4 3648 18 NodePath::any_path 0 1 477 236</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new NodePath that represents any arbitrary path from the root to</span>
 <span class="s0">* the indicated node.  This is the same thing that would be returned by</span>
 <span class="s0">* NodePath(node), except that no warning is issued if the path is ambiguous.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">static inline NodePath NodePath::any_path(PandaNode *node, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2345 10 operator = 0 4 3648 20 NodePath::operator = 0 1 478 0</span>
<span class="s0">55</span>
<span class="s0">inline void NodePath::operator =(NodePath const &amp;copy);</span>

<span class="s0">2346 5 clear 0 4 3648 15 NodePath::clear 0 1 479 93</span>
<span class="s0">/**</span>
 <span class="s0">* Sets this NodePath to the empty NodePath.  It will no longer point to any</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">inline void NodePath::clear(void);</span>

<span class="s0">2347 8 __copy__ 0 4 3648 18 NodePath::__copy__ 0 1 480 0</span>
<span class="s0">40</span>
<span class="s0">NodePath NodePath::__copy__(void) const;</span>

<span class="s0">2348 12 __deepcopy__ 0 4 3648 22 NodePath::__deepcopy__ 0 1 481 0</span>
<span class="s0">71</span>
<span class="s0">PyObject *NodePath::__deepcopy__(PyObject *self, PyObject *memo) const;</span>

<span class="s0">2349 10 __reduce__ 0 4 3648 20 NodePath::__reduce__ 0 1 482 0</span>
<span class="s0">53</span>
<span class="s0">PyObject *NodePath::__reduce__(PyObject *self) const;</span>

<span class="s0">2350 18 __reduce_persist__ 0 4 3648 28 NodePath::__reduce_persist__ 0 1 483 0</span>
<span class="s0">80</span>
<span class="s0">PyObject *NodePath::__reduce_persist__(PyObject *self, PyObject *pickler) const;</span>

<span class="s0">2351 9 not_found 0 4 3648 19 NodePath::not_found 0 1 484 67</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a NodePath with the ET_not_found error type set.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static inline NodePath NodePath::not_found(void);</span>

<span class="s0">2352 7 removed 0 4 3648 17 NodePath::removed 0 1 485 65</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a NodePath with the ET_removed error type set.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">static inline NodePath NodePath::removed(void);</span>

<span class="s0">2353 4 fail 0 4 3648 14 NodePath::fail 0 1 486 62</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a NodePath with the ET_fail error type set.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">static inline NodePath NodePath::fail(void);</span>

<span class="s0">2354 20 set_max_search_depth 0 4 3648 30 NodePath::set_max_search_depth 0 1 487 798</span>
<span class="s0">/**</span>
 <span class="s0">* Certain operations, such as find() or find_all_matches(), require a</span>
 <span class="s0">* traversal of the scene graph to search for the target node or nodes.  This</span>
 <span class="s0">* traversal does not attempt to detect cycles, so an arbitrary cap is set on</span>
 <span class="s0">* the depth of the traversal as a poor man's cycle detection, in the event</span>
 <span class="s0">* that a cycle has inadvertently been introduced into the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* There may be other reasons you'd want to truncate a search before the</span>
 <span class="s0">* bottom of the scene graph has been reached.  In any event, this function</span>
 <span class="s0">* sets the limit on the number of levels that a traversal will continue, and</span>
 <span class="s0">* hence the maximum length of a path that may be returned by a traversal.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a static method, and so changing this parameter affects all of the</span>
 <span class="s0">* NodePaths in the universe.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline void NodePath::set_max_search_depth(int max_search_depth);</span>

<span class="s0">2355 20 get_max_search_depth 0 4 3648 30 NodePath::get_max_search_depth 0 1 488 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the search depth limit.  See</span>
 <span class="s0">* set_max_search_depth.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline int NodePath::get_max_search_depth(void);</span>

<span class="s0">2356 8 is_empty 0 4 3648 18 NodePath::is_empty 0 1 489 102</span>
<span class="s0">// Methods to query a NodePath's contents.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the NodePath contains no nodes.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline bool NodePath::is_empty(void) const;</span>

<span class="s0">2357 22 operator typecast bool 0 132 3648 32 NodePath::operator typecast bool 0 1 994 0</span>
<span class="s0">27</span>
<span class="s0">operator bool (void) const;</span>

<span class="s0">2358 12 is_singleton 0 4 3648 22 NodePath::is_singleton 0 1 490 66</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the NodePath contains exactly one node.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline bool NodePath::is_singleton(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2359 13 get_num_nodes 0 4 3648 23 NodePath::get_num_nodes 0 1 491 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of nodes in the path.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">int NodePath::get_num_nodes(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2360 8 get_node 0 4 3648 18 NodePath::get_node 0 1 492 473</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth node of the path, where 0 is the referenced (bottom) node</span>
 <span class="s0">* and get_num_nodes() - 1 is the top node.  This requires iterating through</span>
 <span class="s0">* the path.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see node(), which is a convenience function to return the same thing</span>
 <span class="s0">* as get_node(0) (since the bottom node is the most important node in the</span>
 <span class="s0">* NodePath, and is the one most frequently referenced).</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this function returns the same thing as</span>
 <span class="s0">* get_ancestor(index).node().</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">PandaNode *NodePath::get_node(int index, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2361 12 get_ancestor 0 4 3648 22 NodePath::get_ancestor 0 1 493 261</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth ancestor of the path, where 0 is the NodePath itself and</span>
 <span class="s0">* get_num_nodes() - 1 is get_top(). This requires iterating through the path.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see get_node(), which returns the same thing as a PandaNode pointer,</span>
 <span class="s0">* not a NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">NodePath NodePath::get_ancestor(int index, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2362 14 get_error_type 0 4 3648 24 NodePath::get_error_type 0 1 494 110</span>
<span class="s0">/**</span>
 <span class="s0">* If is_empty() is true, this returns a code that represents the reason why</span>
 <span class="s0">* the NodePath is empty.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline NodePath::ErrorType NodePath::get_error_type(void) const;</span>

<span class="s0">2363 12 get_top_node 0 4 3648 22 NodePath::get_top_node 0 1 495 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the top node of the path, or NULL if the path is empty.  This</span>
 <span class="s0">* requires iterating through the path.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline PandaNode *NodePath::get_top_node(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2364 7 get_top 0 4 3648 17 NodePath::get_top 0 1 496 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a singleton NodePath that represents the top of the path, or empty</span>
 <span class="s0">* NodePath if this path is empty.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">NodePath NodePath::get_top(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2365 4 node 0 4 3648 14 NodePath::node 0 1 497 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the referenced node of the path.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline PandaNode *NodePath::node(void) const;</span>

<span class="s0">2366 7 get_key 0 4 3648 17 NodePath::get_key 0 1 498 617</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an integer that is guaranteed to be the same for all NodePaths that</span>
 <span class="s0">* represent the same node instance, and different for all NodePaths that</span>
 <span class="s0">* represent a different node instance.</span>
 <span class="s0">*</span>
 <span class="s0">* The same key will be returned for a particular instance as long as at least</span>
 <span class="s0">* one NodePath exists that represents that instance; if all NodePaths for a</span>
 <span class="s0">* particular instance destruct and a new one is later created, it may have a</span>
 <span class="s0">* different index.  However, a given key will never be reused for a different</span>
 <span class="s0">* instance (unless the app has been running long enough that we overflow the</span>
 <span class="s0">* integer key value).</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline int NodePath::get_key(void) const;</span>

<span class="s0">2367 8 add_hash 0 4 3648 18 NodePath::add_hash 0 1 499 528</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the NodePath into the running hash.  This is intended to be used by</span>
 <span class="s0">* lower-level code that computes a hash for each NodePath.  It modifies the</span>
 <span class="s0">* hash value passed in by a unique adjustment for each NodePath, and returns</span>
 <span class="s0">* the modified hash.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to the unique integer returned by get_key(), but it is not</span>
 <span class="s0">* guaranteed to remain unique beyond the lifetime of this particular</span>
 <span class="s0">* NodePath.  Once this NodePath destructs, a different NodePath may be</span>
 <span class="s0">* created which shares the same hash value.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t NodePath::add_hash(std::size_t hash) const;</span>

<span class="s0">2368 13 is_same_graph 0 4 3648 23 NodePath::is_same_graph 0 1 500 255</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the node represented by this NodePath is parented within</span>
 <span class="s0">* the same graph as that of the other NodePath.  This is essentially the same</span>
 <span class="s0">* thing as asking whether get_top() of both NodePaths is the same (e.g., both</span>
 <span class="s0">* &quot;render&quot;).</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">inline bool NodePath::is_same_graph(NodePath const &amp;other, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2369 14 is_ancestor_of 0 4 3648 24 NodePath::is_ancestor_of 0 1 501 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the node represented by this NodePath is a parent or other</span>
 <span class="s0">* ancestor of the other NodePath, or false if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">inline bool NodePath::is_ancestor_of(NodePath const &amp;other, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2370 19 get_common_ancestor 0 4 3648 29 NodePath::get_common_ancestor 0 1 502 205</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the lowest NodePath that both of these two NodePaths have in</span>
 <span class="s0">* common: the first ancestor that both of them share.  If the two NodePaths</span>
 <span class="s0">* are unrelated, returns NodePath::not_found().</span>
 <span class="s0">*/</span>
<span class="s0">130</span>
<span class="s0">inline NodePath NodePath::get_common_ancestor(NodePath const &amp;other, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2371 12 get_children 0 4 3648 22 NodePath::get_children 0 1 503 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of all child nodes of the referenced node.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">NodePathCollection NodePath::get_children(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2372 16 get_num_children 0 4 3648 26 NodePath::get_num_children 0 1 504 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of children of the referenced node.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">inline int NodePath::get_num_children(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2373 9 get_child 0 4 3648 19 NodePath::get_child 0 1 505 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a NodePath representing the nth child of the referenced node.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">inline NodePath NodePath::get_child(int n, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2374 20 get_stashed_children 0 4 3648 30 NodePath::get_stashed_children 0 1 506 210</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of all child nodes of the referenced node that have been</span>
 <span class="s0">* stashed.  These children are not normally visible on the node, and do not</span>
 <span class="s0">* appear in the list returned by get_children().</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">NodePathCollection NodePath::get_stashed_children(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2375 18 NodePathCollection 0 260 3651 38 NodePathCollection::NodePathCollection 0 3 995 996 997 0</span>
<span class="s0">216</span>
<span class="s0">NodePathCollection::NodePathCollection(void) = default;</span>
<span class="s0">NodePathCollection::NodePathCollection(PyObject *self, PyObject *sequence);</span>
<span class="s0">inline NodePathCollection::NodePathCollection(NodePathCollection const &amp;) = default;</span>

<span class="s0">2376 10 __reduce__ 0 4 3651 30 NodePathCollection::__reduce__ 0 1 998 0</span>
<span class="s0">63</span>
<span class="s0">PyObject *NodePathCollection::__reduce__(PyObject *self) const;</span>

<span class="s0">2377 8 add_path 0 4 3651 28 NodePathCollection::add_path 0 1 999 49</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new NodePath to the collection.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void NodePathCollection::add_path(NodePath const &amp;node_path);</span>

<span class="s0">2378 11 remove_path 0 4 3651 31 NodePathCollection::remove_path 0 1 1000 152</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated NodePath from the collection.  Returns true if the</span>
 <span class="s0">* path was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool NodePathCollection::remove_path(NodePath const &amp;node_path);</span>

<span class="s0">2379 14 add_paths_from 0 4 3651 34 NodePathCollection::add_paths_from 0 1 1001 204</span>
<span class="s0">/**</span>
 <span class="s0">* Adds all the NodePaths indicated in the other collection to this path.  The</span>
 <span class="s0">* other paths are simply appended to the end of the paths in this list;</span>
 <span class="s0">* duplicates are not automatically removed.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">void NodePathCollection::add_paths_from(NodePathCollection const &amp;other);</span>

<span class="s0">2380 17 remove_paths_from 0 4 3651 37 NodePathCollection::remove_paths_from 0 1 1002 95</span>
<span class="s0">/**</span>
 <span class="s0">* Removes from this collection all of the NodePaths listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void NodePathCollection::remove_paths_from(NodePathCollection const &amp;other);</span>

<span class="s0">2381 22 remove_duplicate_paths 0 4 3651 42 NodePathCollection::remove_duplicate_paths 0 1 1003 197</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any duplicate entries of the same NodePaths on this collection.  If</span>
 <span class="s0">* a NodePath appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void NodePathCollection::remove_duplicate_paths(void);</span>

<span class="s0">2382 8 has_path 0 4 3651 28 NodePathCollection::has_path 0 1 1004 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated NodePath appears in this collection, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool NodePathCollection::has_path(NodePath const &amp;path) const;</span>

<span class="s0">2383 5 clear 0 4 3651 25 NodePathCollection::clear 0 1 1005 53</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all NodePaths from the collection.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void NodePathCollection::clear(void);</span>

<span class="s0">2384 7 reserve 0 4 3651 27 NodePathCollection::reserve 0 1 1006 157</span>
<span class="s0">/**</span>
 <span class="s0">* This is a hint to Panda to allocate enough memory to hold the given number</span>
 <span class="s0">* of NodePaths, if you know ahead of time how many you will be adding.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void NodePathCollection::reserve(std::size_t num);</span>

<span class="s0">2385 8 is_empty 0 4 3651 28 NodePathCollection::is_empty 0 1 1007 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there are no NodePaths in the collection, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">bool NodePathCollection::is_empty(void) const;</span>

<span class="s0">2386 13 get_num_paths 0 4 3651 33 NodePathCollection::get_num_paths 0 1 1008 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of NodePaths in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int NodePathCollection::get_num_paths(void) const;</span>

<span class="s0">2387 8 get_path 0 4 3651 28 NodePathCollection::get_path 0 1 1009 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth NodePath in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">NodePath NodePathCollection::get_path(int index) const;</span>

<span class="s0">2388 11 operator [] 0 4 3651 31 NodePathCollection::operator [] 0 1 1010 0</span>
<span class="s0">66</span>
<span class="s0">NodePath NodePathCollection::operator [](std::size_t index) const;</span>

<span class="s0">2389 4 size 0 4 3651 24 NodePathCollection::size 0 1 1011 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of paths in the collection.  This is the same thing as</span>
 <span class="s0">* get_num_paths().</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">std::size_t NodePathCollection::size(void) const;</span>

<span class="s0">2390 11 operator += 0 4 3651 31 NodePathCollection::operator += 0 1 1012 0</span>
<span class="s0">77</span>
<span class="s0">inline void NodePathCollection::operator +=(NodePathCollection const &amp;other);</span>

<span class="s0">2391 10 operator + 0 4 3651 30 NodePathCollection::operator + 0 1 1013 0</span>
<span class="s0">96</span>
<span class="s0">inline NodePathCollection NodePathCollection::operator +(NodePathCollection const &amp;other) const;</span>

<span class="s0">2392 6 append 0 4 3651 26 NodePathCollection::append 0 1 1014 203</span>
<span class="s0">// Method names to satisfy Python's conventions.</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new NodePath to the collection.  This method duplicates the</span>
 <span class="s0">* add_path() method; it is provided to satisfy Python's naming convention.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void NodePathCollection::append(NodePath const &amp;node_path);</span>

<span class="s0">2393 6 extend 0 4 3651 26 NodePathCollection::extend 0 1 1015 157</span>
<span class="s0">/**</span>
 <span class="s0">* Appends the other list onto the end of this one.  This method duplicates</span>
 <span class="s0">* the += operator; it is provided to satisfy Python's naming convention.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void NodePathCollection::extend(NodePathCollection const &amp;other);</span>

<span class="s0">2394 2 ls 0 4 3651 22 NodePathCollection::ls 0 2 1016 1017 230</span>
<span class="s0">// Handy operations on many NodePaths at once.</span>

<span class="s0">/**</span>
 <span class="s0">* Lists all the nodes at and below each node in the collection</span>
 <span class="s0">* hierarchically.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Lists all the nodes at and below each node in the collection</span>
 <span class="s0">* hierarchically.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline void NodePathCollection::ls(void) const;</span>
<span class="s0">void NodePathCollection::ls(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2395 16 find_all_matches 0 4 3651 36 NodePathCollection::find_all_matches 0 1 1018 177</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete set of all NodePaths that begin with any NodePath in</span>
 <span class="s0">* this collection and can be extended by path.  The shortest paths will be</span>
 <span class="s0">* listed first.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">NodePathCollection NodePathCollection::find_all_matches(std::string const &amp;path) const;</span>

<span class="s0">2396 11 reparent_to 0 4 3651 31 NodePathCollection::reparent_to 0 1 1019 79</span>
<span class="s0">/**</span>
 <span class="s0">* Reparents all the NodePaths in the collection to the indicated node.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void NodePathCollection::reparent_to(NodePath const &amp;other);</span>

<span class="s0">2397 15 wrt_reparent_to 0 4 3651 35 NodePathCollection::wrt_reparent_to 0 1 1020 147</span>
<span class="s0">/**</span>
 <span class="s0">* Reparents all the NodePaths in the collection to the indicated node,</span>
 <span class="s0">* adjusting each transform so as not to move in world coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void NodePathCollection::wrt_reparent_to(NodePath const &amp;other);</span>

<span class="s0">2398 4 show 0 4 3651 24 NodePathCollection::show 0 1 1021 49</span>
<span class="s0">/**</span>
 <span class="s0">* Shows all NodePaths in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void NodePathCollection::show(void);</span>

<span class="s0">2399 4 hide 0 4 3651 24 NodePathCollection::hide 0 1 1022 49</span>
<span class="s0">/**</span>
 <span class="s0">* Hides all NodePaths in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void NodePathCollection::hide(void);</span>

<span class="s0">2400 5 stash 0 4 3651 25 NodePathCollection::stash 0 1 1023 51</span>
<span class="s0">/**</span>
 <span class="s0">* Stashes all NodePaths in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void NodePathCollection::stash(void);</span>

<span class="s0">2401 7 unstash 0 4 3651 27 NodePathCollection::unstash 0 1 1024 53</span>
<span class="s0">/**</span>
 <span class="s0">* Unstashes all NodePaths in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void NodePathCollection::unstash(void);</span>

<span class="s0">2402 6 detach 0 4 3651 26 NodePathCollection::detach 0 1 1025 52</span>
<span class="s0">/**</span>
 <span class="s0">* Detaches all NodePaths in the collection.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void NodePathCollection::detach(void);</span>

<span class="s0">2403 16 get_collide_mask 0 4 3651 36 NodePathCollection::get_collide_mask 0 1 1026 309</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of all of the into_collide_masks for nodes at this level</span>
 <span class="s0">* and below.  This is the same thing as node()-&gt;get_net_collide_mask().</span>
 <span class="s0">*</span>
 <span class="s0">* If you want to return what the into_collide_mask of this node itself is,</span>
 <span class="s0">* without regard to its children, use node()-&gt;get_into_collide_mask().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">CollideMask NodePathCollection::get_collide_mask(void) const;</span>

<span class="s0">2404 16 set_collide_mask 0 4 3651 36 NodePathCollection::set_collide_mask 0 1 1027 349</span>
<span class="s0">/**</span>
 <span class="s0">* Recursively applies the indicated CollideMask to the into_collide_masks for</span>
 <span class="s0">* all nodes at this level and below.</span>
 <span class="s0">*</span>
 <span class="s0">* The default is to change all bits, but if bits_to_change is not all bits</span>
 <span class="s0">* on, then only the bits that are set in bits_to_change are modified,</span>
 <span class="s0">* allowing this call to change only a subset of the bits in the subgraph.</span>
 <span class="s0">*/</span>
<span class="s0">159</span>
<span class="s0">void NodePathCollection::set_collide_mask(CollideMask new_mask, CollideMask bits_to_change = CollideMask::all_on(), TypeHandle node_type = TypeHandle::none());</span>

<span class="s0">2405 17 calc_tight_bounds 0 4 3651 37 NodePathCollection::calc_tight_bounds 0 1 1028 369</span>
<span class="s0">/**</span>
 <span class="s0">* Calculates the minimum and maximum vertices of all Geoms at these</span>
 <span class="s0">* NodePath's bottom nodes and below This is a tight bounding box; it will</span>
 <span class="s0">* generally be tighter than the bounding volume returned by get_bounds() (but</span>
 <span class="s0">* it is more expensive to compute).</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if any points are within the bounding volume, or</span>
 <span class="s0">* false if none are.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">bool NodePathCollection::calc_tight_bounds(LPoint3 &amp;min_point, LPoint3 &amp;max_point) const;</span>

<span class="s0">2406 16 get_tight_bounds 0 4 3651 36 NodePathCollection::get_tight_bounds 0 1 1029 0</span>
<span class="s0">59</span>
<span class="s0">PyObject *NodePathCollection::get_tight_bounds(void) const;</span>

<span class="s0">2407 11 set_texture 0 4 3651 31 NodePathCollection::set_texture 0 2 1030 1031 738</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the default texture stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the deprecated single-texture variant of this method; it is now</span>
 <span class="s0">* superceded by set_texture() that accepts a stage and texture.  However,</span>
 <span class="s0">* this method may be used in the presence of multitexture if you just want to</span>
 <span class="s0">* adjust the default stage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the indicated multitexture stage.  If there are multiple texture stages</span>
 <span class="s0">* specified (possibly on multiple different nodes at different levels), they</span>
 <span class="s0">* will all be applied to geometry together, according to the stage</span>
 <span class="s0">* specification set up in the TextureStage object.</span>
 <span class="s0">*/</span>
<span class="s0">160</span>
<span class="s0">void NodePathCollection::set_texture(Texture *tex, int priority = 0);</span>
<span class="s0">void NodePathCollection::set_texture(TextureStage *stage, Texture *tex, int priority = 0);</span>

<span class="s0">2408 15 set_texture_off 0 4 3651 35 NodePathCollection::set_texture_off 0 2 1032 1033 602</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no texture, on</span>
 <span class="s0">* any stage.  This is different from not specifying a texture; rather, this</span>
 <span class="s0">* specifically contradicts set_texture() at a higher node level (or, with a</span>
 <span class="s0">* priority, overrides a set_texture() at a lower level).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no texture, on</span>
 <span class="s0">* the indicated stage.  This is different from not specifying a texture;</span>
 <span class="s0">* rather, this specifically contradicts set_texture() at a higher node level</span>
 <span class="s0">* (or, with a priority, overrides a set_texture() at a lower level).</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">void NodePathCollection::set_texture_off(int priority = 0);</span>
<span class="s0">void NodePathCollection::set_texture_off(TextureStage *stage, int priority = 0);</span>

<span class="s0">2409 9 set_color 0 4 3651 29 NodePathCollection::set_color 0 2 1034 1035 100</span>
<span class="s0">/**</span>
 <span class="s0">* Colors all NodePaths in the collection</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Colors all NodePaths in the collection</span>
 <span class="s0">*/</span>
<span class="s0">201</span>
<span class="s0">inline void NodePathCollection::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0);</span>
<span class="s0">void NodePathCollection::set_color(LColor const &amp;color, int priority = 0);</span>

<span class="s0">2410 15 set_color_scale 0 4 3651 35 NodePathCollection::set_color_scale 0 2 1036 1037 220</span>
<span class="s0">/**</span>
 <span class="s0">* Applies color scales to all NodePaths in the collection.  The existing</span>
 <span class="s0">* color scale is replaced.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Applies color scales to all NodePaths in the collection.  The existing</span>
 <span class="s0">* color scale is replaced.</span>
 <span class="s0">*/</span>
<span class="s0">216</span>
<span class="s0">inline void NodePathCollection::set_color_scale(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0);</span>
<span class="s0">void NodePathCollection::set_color_scale(LVecBase4 const &amp;scale, int priority = 0);</span>

<span class="s0">2411 19 compose_color_scale 0 4 3651 39 NodePathCollection::compose_color_scale 0 2 1038 1039 300</span>
<span class="s0">/**</span>
 <span class="s0">* Applies color scales to all NodePaths in the collection.  The existing</span>
 <span class="s0">* color scale, if any, is multiplied by the specified color scale.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Applies color scales to all NodePaths in the collection.  The existing</span>
 <span class="s0">* color scale, if any, is multiplied by the specified color scale.</span>
 <span class="s0">*/</span>
<span class="s0">224</span>
<span class="s0">inline void NodePathCollection::compose_color_scale(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0);</span>
<span class="s0">void NodePathCollection::compose_color_scale(LVecBase4 const &amp;scale, int priority = 0);</span>

<span class="s0">2412 10 set_attrib 0 4 3651 30 NodePathCollection::set_attrib 0 1 1040 223</span>
<span class="s0">/**</span>
 <span class="s0">* Applies the indicated RenderAttrib to all NodePaths in the collection.  An</span>
 <span class="s0">* effort is made to apply the attrib to many NodePaths as quickly as</span>
 <span class="s0">* possible; redundant RenderState compositions are not duplicated.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void NodePathCollection::set_attrib(RenderAttrib const *attrib, int priority = 0);</span>

<span class="s0">2413 6 output 0 4 3651 26 NodePathCollection::output 0 1 1041 107</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a brief one-line description of the NodePathCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void NodePathCollection::output(std::ostream &amp;out) const;</span>

<span class="s0">2414 5 write 0 4 3651 25 NodePathCollection::write 0 1 1042 112</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a complete multi-line description of the NodePathCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void NodePathCollection::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2415 19 ~NodePathCollection 0 516 3651 39 NodePathCollection::~NodePathCollection 0 0 0</span>
<span class="s0">46</span>
<span class="s0">NodePathCollection::~NodePathCollection(void);</span>

<span class="s0">2416 21 count_num_descendants 0 4 3648 31 NodePath::count_num_descendants 0 1 507 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of nodes at and below this level.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int NodePath::count_num_descendants(void) const;</span>

<span class="s0">2417 10 has_parent 0 4 3648 20 NodePath::has_parent 0 1 508 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the referenced node has a parent; i.e.  the NodePath chain</span>
 <span class="s0">* contains at least two nodes.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline bool NodePath::has_parent(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2418 10 get_parent 0 4 3648 20 NodePath::get_parent 0 1 509 195</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath to the parent of the referenced node: that is, this</span>
 <span class="s0">* NodePath, shortened by one node.  The parent of a singleton NodePath is</span>
 <span class="s0">* defined to be the empty NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline NodePath NodePath::get_parent(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2419 8 get_sort 0 4 3648 18 NodePath::get_sort 0 1 510 246</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sort value of the referenced node within its parent; that is,</span>
 <span class="s0">* the sort number passed on the last reparenting operation for this node.</span>
 <span class="s0">* This will control the position of the node within its parent's list of</span>
 <span class="s0">* children.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">int NodePath::get_sort(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2420 4 find 0 4 3648 14 NodePath::find 0 1 511 253</span>
<span class="s0">/**</span>
 <span class="s0">* Searches for a node below the referenced node that matches the indicated</span>
 <span class="s0">* string.  Returns the shortest match found, if any, or an empty NodePath if</span>
 <span class="s0">* no match can be found.</span>
 <span class="s0">*</span>
 <span class="s0">* The referenced node itself is not considered in the search.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">NodePath NodePath::find(std::string const &amp;path) const;</span>

<span class="s0">2421 12 find_path_to 0 4 3648 22 NodePath::find_path_to 0 1 512 115</span>
<span class="s0">/**</span>
 <span class="s0">* Searches for the indicated node below this node and returns the shortest</span>
 <span class="s0">* NodePath that connects them.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">NodePath NodePath::find_path_to(PandaNode *node) const;</span>

<span class="s0">2422 16 find_all_matches 0 4 3648 26 NodePath::find_all_matches 0 1 513 222</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete set of all NodePaths that begin with this NodePath and</span>
 <span class="s0">* can be extended by path.  The shortest paths will be listed first.</span>
 <span class="s0">*</span>
 <span class="s0">* The referenced node itself is not considered in the search.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">NodePathCollection NodePath::find_all_matches(std::string const &amp;path) const;</span>

<span class="s0">2423 17 find_all_paths_to 0 4 3648 27 NodePath::find_all_paths_to 0 1 514 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of all NodePaths that extend from this NodePath down to the</span>
 <span class="s0">* indicated node.  The shortest paths will be listed first.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">NodePathCollection NodePath::find_all_paths_to(PandaNode *node) const;</span>

<span class="s0">2424 11 reparent_to 0 4 3648 21 NodePath::reparent_to 0 1 515 711</span>
<span class="s0">// Methods that actually move nodes around in the scene graph.  The optional</span>
<span class="s0">// &quot;sort&quot; parameter can be used to force a particular ordering between</span>
<span class="s0">// sibling nodes, useful when dealing with LOD's and similar switch nodes.</span>
<span class="s0">// If the sort value is the same, nodes will be arranged in the order they</span>
<span class="s0">// were added.</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the referenced node of the NodePath from its current parent and</span>
 <span class="s0">* attaches it to the referenced node of the indicated NodePath.</span>
 <span class="s0">*</span>
 <span class="s0">* If the destination NodePath is empty, this is the same thing as</span>
 <span class="s0">* detach_node().</span>
 <span class="s0">*</span>
 <span class="s0">* If the referenced node is already a child of the indicated NodePath (via</span>
 <span class="s0">* some other instance), this operation fails and leaves the NodePath</span>
 <span class="s0">* detached.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">void NodePath::reparent_to(NodePath const &amp;other, int sort = 0, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2425 8 stash_to 0 4 3648 18 NodePath::stash_to 0 1 516 189</span>
<span class="s0">/**</span>
 <span class="s0">* Similar to reparent_to(), but the node is added to its new parent's stashed</span>
 <span class="s0">* list, so that the result is equivalent to calling reparent_to() immediately</span>
 <span class="s0">* followed by stash().</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">void NodePath::stash_to(NodePath const &amp;other, int sort = 0, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2426 15 wrt_reparent_to 0 4 3648 25 NodePath::wrt_reparent_to 0 1 517 238</span>
<span class="s0">/**</span>
 <span class="s0">* This functions identically to reparent_to(), except the transform on this</span>
 <span class="s0">* node is also adjusted so that the node remains in the same place in world</span>
 <span class="s0">* coordinates, even if it is reparented into a different coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">void NodePath::wrt_reparent_to(NodePath const &amp;other, int sort = 0, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2427 11 instance_to 0 4 3648 21 NodePath::instance_to 0 1 518 962</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the referenced node of the NodePath as a child of the referenced node</span>
 <span class="s0">* of the indicated other NodePath.  Any other parent-child relations of the</span>
 <span class="s0">* node are unchanged; in particular, the node is not removed from its</span>
 <span class="s0">* existing parent, if any.</span>
 <span class="s0">*</span>
 <span class="s0">* If the node already had an existing parent, this method will create a new</span>
 <span class="s0">* instance of the node within the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not change the NodePath itself, but does return a new NodePath</span>
 <span class="s0">* that reflects the new instance node.</span>
 <span class="s0">*</span>
 <span class="s0">* If the destination NodePath is empty, this creates a new instance which is</span>
 <span class="s0">* not yet parented to any node.  A new instance of this sort cannot easily be</span>
 <span class="s0">* differentiated from other similar instances, but it is nevertheless a</span>
 <span class="s0">* different instance and it will return a different get_id() value.</span>
 <span class="s0">*</span>
 <span class="s0">* If the referenced node is already a child of the indicated NodePath,</span>
 <span class="s0">* returns that already-existing instance, unstashing it first if necessary.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">NodePath NodePath::instance_to(NodePath const &amp;other, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2428 19 instance_under_node 0 4 3648 29 NodePath::instance_under_node 0 1 519 236</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like instance_to(), but implicitly creates a new node to instance</span>
 <span class="s0">* the geometry under, and returns a NodePath to that new node.  This allows</span>
 <span class="s0">* the programmer to set a unique state and/or transform on this instance.</span>
 <span class="s0">*/</span>
<span class="s0">162</span>
<span class="s0">NodePath NodePath::instance_under_node(NodePath const &amp;other, std::string const &amp;name, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2429 7 copy_to 0 4 3648 17 NodePath::copy_to 0 1 520 221</span>
<span class="s0">/**</span>
 <span class="s0">* Functions like instance_to(), except a deep copy is made of the referenced</span>
 <span class="s0">* node and all of its descendents, which is then parented to the indicated</span>
 <span class="s0">* node.  A NodePath to the newly created copy is returned.</span>
 <span class="s0">*/</span>
<span class="s0">125</span>
<span class="s0">NodePath NodePath::copy_to(NodePath const &amp;other, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2430 15 attach_new_node 0 4 3648 25 NodePath::attach_new_node 0 2 521 522 588</span>
<span class="s0">/**</span>
 <span class="s0">* Creates an ordinary PandaNode and attaches it below the current NodePath,</span>
 <span class="s0">* returning a new NodePath that references it.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Attaches a new node, with or without existing parents, to the scene graph</span>
 <span class="s0">* below the referenced node of this NodePath.  This is the preferred way to</span>
 <span class="s0">* add nodes to the graph.</span>
 <span class="s0">*</span>
 <span class="s0">* If the node was already a child of the parent, this returns a NodePath to</span>
 <span class="s0">* the existing child.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* automatically extend the current NodePath to reflect the</span>
 <span class="s0">* attachment; however, a NodePath that does reflect this extension is</span>
 <span class="s0">* returned.</span>
 <span class="s0">*/</span>
<span class="s0">270</span>
<span class="s0">NodePath NodePath::attach_new_node(PandaNode *node, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const;</span>
<span class="s0">inline NodePath NodePath::attach_new_node(std::string const &amp;name, int sort = 0, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2431 11 remove_node 0 4 3648 21 NodePath::remove_node 0 1 523 754</span>
<span class="s0">/**</span>
 <span class="s0">* Disconnects the referenced node from the scene graph.  This will also</span>
 <span class="s0">* delete the node if there are no other pointers to it.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this should be called only when you are really done with the</span>
 <span class="s0">* node.  If you want to remove a node from the scene graph but keep it around</span>
 <span class="s0">* for later, you should probably use detach_node() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, the only difference between remove_node() and detach_node() is</span>
 <span class="s0">* that remove_node() also resets the NodePath to empty, which will cause the</span>
 <span class="s0">* node to be deleted immediately if there are no other references.  On the</span>
 <span class="s0">* other hand, detach_node() leaves the NodePath referencing the node, which</span>
 <span class="s0">* will keep at least one reference to the node for as long as the NodePath</span>
 <span class="s0">* exists.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void NodePath::remove_node(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2432 11 detach_node 0 4 3648 21 NodePath::detach_node 0 1 524 735</span>
<span class="s0">/**</span>
 <span class="s0">* Disconnects the referenced node from its parent, but does not immediately</span>
 <span class="s0">* delete it.  The NodePath retains a pointer to the node, and becomes a</span>
 <span class="s0">* singleton NodePath.</span>
 <span class="s0">*</span>
 <span class="s0">* This should be called to detach a node from the scene graph, with the</span>
 <span class="s0">* option of reattaching it later to the same parent or to a different parent.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, the only difference between remove_node() and detach_node() is</span>
 <span class="s0">* that remove_node() also resets the NodePath to empty, which will cause the</span>
 <span class="s0">* node to be deleted immediately if there are no other references.  On the</span>
 <span class="s0">* other hand, detach_node() leaves the NodePath referencing the node, which</span>
 <span class="s0">* will keep at least one reference to the node for as long as the NodePath</span>
 <span class="s0">* exists.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void NodePath::detach_node(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2433 6 output 0 4 3648 16 NodePath::output 0 1 525 91</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a sensible description of the NodePath to the indicated output</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void NodePath::output(std::ostream &amp;out) const;</span>

<span class="s0">2434 2 ls 0 4 3648 12 NodePath::ls 0 2 526 527 130</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the hierarchy at and below the referenced node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Lists the hierarchy at and below the referenced node.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">inline void NodePath::ls(void) const;</span>
<span class="s0">inline void NodePath::ls(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2435 10 reverse_ls 0 4 3648 20 NodePath::reverse_ls 0 2 528 529 130</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the hierarchy at and above the referenced node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Lists the hierarchy at and above the referenced node.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">inline void NodePath::reverse_ls(void) const;</span>
<span class="s0">int NodePath::reverse_ls(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2436 9 get_state 0 4 3648 19 NodePath::get_state 0 2 530 531 256</span>
<span class="s0">// Aggregate transform and state information.</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the complete state object set on this node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the state changes that must be made to transition to the render</span>
 <span class="s0">* state of this node from the render state of the other node.</span>
 <span class="s0">*/</span>
<span class="s0">235</span>
<span class="s0">RenderState const *NodePath::get_state(Thread *current_thread = Thread::get_current_thread()) const;</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; NodePath::get_state(NodePath const &amp;other, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2437 9 set_state 0 4 3648 19 NodePath::set_state 0 2 532 533 240</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the complete state object on this node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the state object on this node, relative to the other node.  This</span>
 <span class="s0">* computes a new state object that will have the indicated value when seen</span>
 <span class="s0">* from the other node.</span>
 <span class="s0">*/</span>
<span class="s0">243</span>
<span class="s0">inline void NodePath::set_state(RenderState const *state, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">void NodePath::set_state(NodePath const &amp;other, RenderState const *state, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2438 13 get_net_state 0 4 3648 23 NodePath::get_net_state 0 1 534 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the net state on this node from the root.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">inline ConstPointerTo&lt; RenderState &gt; NodePath::get_net_state(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2439 10 set_attrib 0 4 3648 20 NodePath::set_attrib 0 1 535 220</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated render attribute to the scene graph on this node.  This</span>
 <span class="s0">* attribute will now apply to this node and everything below.  If there was</span>
 <span class="s0">* already an attribute of the same type, it is replaced.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline void NodePath::set_attrib(RenderAttrib const *attrib, int priority = 0);</span>

<span class="s0">2440 10 get_attrib 0 4 3648 20 NodePath::get_attrib 0 1 536 270</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the render attribute of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.  This checks only what is set on this</span>
 <span class="s0">* particular node level, and has nothing to do with what render attributes</span>
 <span class="s0">* may be inherited from parent nodes.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline RenderAttrib const *NodePath::get_attrib(TypeHandle type) const;</span>

<span class="s0">2441 10 has_attrib 0 4 3648 20 NodePath::has_attrib 0 1 537 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a render attribute of the indicated type defined</span>
 <span class="s0">* on this node, or false if there is not.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool NodePath::has_attrib(TypeHandle type) const;</span>

<span class="s0">2442 12 clear_attrib 0 4 3648 22 NodePath::clear_attrib 0 1 538 194</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the render attribute of the given type from this node.  This node,</span>
 <span class="s0">* and the subgraph below, will now inherit the indicated render attribute</span>
 <span class="s0">* from the nodes above this one.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void NodePath::clear_attrib(TypeHandle type);</span>

<span class="s0">2443 10 set_effect 0 4 3648 20 NodePath::set_effect 0 1 539 145</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated render effect to the scene graph on this node.  If there</span>
 <span class="s0">* was already an effect of the same type, it is replaced.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void NodePath::set_effect(RenderEffect const *effect);</span>

<span class="s0">2444 10 get_effect 0 4 3648 20 NodePath::get_effect 0 1 540 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the render effect of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline RenderEffect const *NodePath::get_effect(TypeHandle type) const;</span>

<span class="s0">2445 10 has_effect 0 4 3648 20 NodePath::has_effect 0 1 541 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a render effect of the indicated type defined on</span>
 <span class="s0">* this node, or false if there is not.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool NodePath::has_effect(TypeHandle type) const;</span>

<span class="s0">2446 12 clear_effect 0 4 3648 22 NodePath::clear_effect 0 1 542 70</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the render effect of the given type from this node.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void NodePath::clear_effect(TypeHandle type);</span>

<span class="s0">2447 11 set_effects 0 4 3648 21 NodePath::set_effects 0 1 543 177</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the complete RenderEffects that will be applied this node.  This</span>
 <span class="s0">* completely replaces whatever has been set on this node via repeated calls</span>
 <span class="s0">* to set_attrib().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void NodePath::set_effects(RenderEffects const *effects);</span>

<span class="s0">2448 11 get_effects 0 4 3648 21 NodePath::get_effects 0 1 544 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete RenderEffects that will be applied to this node.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline RenderEffects const *NodePath::get_effects(void) const;</span>

<span class="s0">2449 13 clear_effects 0 4 3648 23 NodePath::clear_effects 0 1 545 54</span>
<span class="s0">/**</span>
 <span class="s0">* Resets this node to have no render effects.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void NodePath::clear_effects(void);</span>

<span class="s0">2450 13 get_transform 0 4 3648 23 NodePath::get_transform 0 2 546 547 213</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete transform object set on this node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the relative transform to this node from the other node; i.e.  the</span>
 <span class="s0">* transformation of this node as seen from the other node.</span>
 <span class="s0">*/</span>
<span class="s0">249</span>
<span class="s0">TransformState const *NodePath::get_transform(Thread *current_thread = Thread::get_current_thread()) const;</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; NodePath::get_transform(NodePath const &amp;other, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2451 15 clear_transform 0 4 3648 25 NodePath::clear_transform 0 2 548 549 235</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the transform object on this node to identity.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the transform object on this node to identity, relative to the other</span>
 <span class="s0">* node.  This effectively places this node at the same position as the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">210</span>
<span class="s0">inline void NodePath::clear_transform(Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">inline void NodePath::clear_transform(NodePath const &amp;other, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2452 13 set_transform 0 4 3648 23 NodePath::set_transform 0 2 550 551 252</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the complete transform object on this node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the transform object on this node, relative to the other node.  This</span>
 <span class="s0">* computes a new transform object that will have the indicated value when</span>
 <span class="s0">* seen from the other node.</span>
 <span class="s0">*/</span>
<span class="s0">265</span>
<span class="s0">inline void NodePath::set_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">void NodePath::set_transform(NodePath const &amp;other, TransformState const *transform, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2453 17 get_net_transform 0 4 3648 27 NodePath::get_net_transform 0 1 552 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the net transform on this node from the root.</span>
 <span class="s0">*/</span>
<span class="s0">129</span>
<span class="s0">inline ConstPointerTo&lt; TransformState &gt; NodePath::get_net_transform(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2454 18 get_prev_transform 0 4 3648 28 NodePath::get_prev_transform 0 2 553 554 313</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transform that has been set as this node's &quot;previous&quot; position.</span>
 <span class="s0">* See set_prev_transform().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the relative &quot;previous&quot; transform to this node from the other node;</span>
 <span class="s0">* i.e.  the position of this node in the previous frame, as seen by the other</span>
 <span class="s0">* node in the previous frame.</span>
 <span class="s0">*/</span>
<span class="s0">259</span>
<span class="s0">TransformState const *NodePath::get_prev_transform(Thread *current_thread = Thread::get_current_thread()) const;</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; NodePath::get_prev_transform(NodePath const &amp;other, Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2455 18 set_prev_transform 0 4 3648 28 NodePath::set_prev_transform 0 2 555 556 374</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the transform that represents this node's &quot;previous&quot; position, one</span>
 <span class="s0">* frame ago, for the purposes of detecting motion for accurate collision</span>
 <span class="s0">* calculations.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;previous&quot; transform object on this node, relative to the other</span>
 <span class="s0">* node.  This computes a new transform object that will have the indicated</span>
 <span class="s0">* value when seen from the other node.</span>
 <span class="s0">*/</span>
<span class="s0">275</span>
<span class="s0">inline void NodePath::set_prev_transform(TransformState const *transform, Thread *current_thread = Thread::get_current_thread());</span>
<span class="s0">void NodePath::set_prev_transform(NodePath const &amp;other, TransformState const *transform, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2456 22 get_net_prev_transform 0 4 3648 32 NodePath::get_net_prev_transform 0 1 557 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the net &quot;previous&quot; transform on this node from the root.  See</span>
 <span class="s0">* set_prev_transform().</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">inline ConstPointerTo&lt; TransformState &gt; NodePath::get_net_prev_transform(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2457 7 set_pos 0 4 3648 17 NodePath::set_pos 0 4 558 559 560 561 806</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the translation component of the transform, leaving rotation and scale</span>
 <span class="s0">* untouched.  This also resets the node's &quot;previous&quot; position, so that the</span>
 <span class="s0">* collision system will see the node as having suddenly appeared in the new</span>
 <span class="s0">* position, without passing any points in between.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation component of the transform, relative to the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation component of the transform, leaving rotation and scale</span>
 <span class="s0">* untouched.  This also resets the node's &quot;previous&quot; position, so that the</span>
 <span class="s0">* collision system will see the node as having suddenly appeared in the new</span>
 <span class="s0">* position, without passing any points in between.  See Also:</span>
 <span class="s0">* NodePath::set_fluid_pos</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation component of the transform, relative to the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">289</span>
<span class="s0">inline void NodePath::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void NodePath::set_pos(LVecBase3 const &amp;pos);</span>
<span class="s0">inline void NodePath::set_pos(NodePath const &amp;other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void NodePath::set_pos(NodePath const &amp;other, LVecBase3 const &amp;pos);</span>

<span class="s0">2458 5 set_x 0 4 3648 15 NodePath::set_x 0 2 562 563 115</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the X component of the position transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_pos()</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">void NodePath::set_x(PN_stdfloat x);</span>
<span class="s0">void NodePath::set_x(NodePath const &amp;other, PN_stdfloat x);</span>

<span class="s0">2459 5 set_y 0 4 3648 15 NodePath::set_y 0 2 564 565 115</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the Y component of the position transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_pos()</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">void NodePath::set_y(PN_stdfloat y);</span>
<span class="s0">void NodePath::set_y(NodePath const &amp;other, PN_stdfloat y);</span>

<span class="s0">2460 5 set_z 0 4 3648 15 NodePath::set_z 0 2 566 567 115</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the Z component of the position transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_pos()</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">void NodePath::set_z(PN_stdfloat z);</span>
<span class="s0">void NodePath::set_z(NodePath const &amp;other, PN_stdfloat z);</span>

<span class="s0">2461 13 set_fluid_pos 0 4 3648 23 NodePath::set_fluid_pos 0 4 568 569 570 571 734</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the translation component, without changing the &quot;previous&quot; position,</span>
 <span class="s0">* so that the collision system will see the node as moving fluidly from its</span>
 <span class="s0">* previous position to its new position.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation component, without changing the &quot;previous&quot; position,</span>
 <span class="s0">* so that the collision system will see the node as moving fluidly from its</span>
 <span class="s0">* previous position to its new position.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation component, without changing the &quot;previous&quot; position,</span>
 <span class="s0">* so that the collision system will see the node as moving fluidly from its</span>
 <span class="s0">* previous position to its new position.  See Also: NodePath::set_pos</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation component of the transform, relative to the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">313</span>
<span class="s0">inline void NodePath::set_fluid_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void NodePath::set_fluid_pos(LVecBase3 const &amp;pos);</span>
<span class="s0">inline void NodePath::set_fluid_pos(NodePath const &amp;other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void NodePath::set_fluid_pos(NodePath const &amp;other, LVecBase3 const &amp;pos);</span>

<span class="s0">2462 11 set_fluid_x 0 4 3648 21 NodePath::set_fluid_x 0 2 572 573 0</span>
<span class="s0">108</span>
<span class="s0">void NodePath::set_fluid_x(PN_stdfloat x);</span>
<span class="s0">void NodePath::set_fluid_x(NodePath const &amp;other, PN_stdfloat x);</span>

<span class="s0">2463 11 set_fluid_y 0 4 3648 21 NodePath::set_fluid_y 0 2 574 575 0</span>
<span class="s0">108</span>
<span class="s0">void NodePath::set_fluid_y(PN_stdfloat y);</span>
<span class="s0">void NodePath::set_fluid_y(NodePath const &amp;other, PN_stdfloat y);</span>

<span class="s0">2464 11 set_fluid_z 0 4 3648 21 NodePath::set_fluid_z 0 2 576 577 0</span>
<span class="s0">108</span>
<span class="s0">void NodePath::set_fluid_z(PN_stdfloat z);</span>
<span class="s0">void NodePath::set_fluid_z(NodePath const &amp;other, PN_stdfloat z);</span>

<span class="s0">2465 7 get_pos 0 4 3648 17 NodePath::get_pos 0 2 578 579 161</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the translation component of the transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the relative position of the referenced node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">LPoint3 NodePath::get_pos(void) const;</span>
<span class="s0">LPoint3 NodePath::get_pos(NodePath const &amp;other) const;</span>

<span class="s0">2466 5 get_x 0 4 3648 15 NodePath::get_x 0 2 580 581 0</span>
<span class="s0">112</span>
<span class="s0">inline PN_stdfloat NodePath::get_x(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_x(NodePath const &amp;other) const;</span>

<span class="s0">2467 5 get_y 0 4 3648 15 NodePath::get_y 0 2 582 583 0</span>
<span class="s0">112</span>
<span class="s0">inline PN_stdfloat NodePath::get_y(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_y(NodePath const &amp;other) const;</span>

<span class="s0">2468 5 get_z 0 4 3648 15 NodePath::get_z 0 2 584 585 0</span>
<span class="s0">112</span>
<span class="s0">inline PN_stdfloat NodePath::get_z(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_z(NodePath const &amp;other) const;</span>

<span class="s0">2469 13 get_pos_delta 0 4 3648 23 NodePath::get_pos_delta 0 2 586 587 990</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the delta vector from this node's position in the previous frame</span>
 <span class="s0">* (according to set_prev_transform(), typically set via the use of</span>
 <span class="s0">* set_fluid_pos()) and its position in the current frame.  This is the vector</span>
 <span class="s0">* used to determine collisions.  Generally, if the node was last repositioned</span>
 <span class="s0">* via set_pos(), the delta will be zero; if it was adjusted via</span>
 <span class="s0">* set_fluid_pos(), the delta will represent the change from the previous</span>
 <span class="s0">* frame's position.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the delta vector from this node's position in the previous frame</span>
 <span class="s0">* (according to set_prev_transform(), typically set via the use of</span>
 <span class="s0">* set_fluid_pos()) and its position in the current frame, as seen in the</span>
 <span class="s0">* indicated node's coordinate space.  This is the vector used to determine</span>
 <span class="s0">* collisions.  Generally, if the node was last repositioned via set_pos(),</span>
 <span class="s0">* the delta will be zero; if it was adjusted via set_fluid_pos(), the delta</span>
 <span class="s0">* will represent the change from the previous frame's position.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">LVector3 NodePath::get_pos_delta(void) const;</span>
<span class="s0">LVector3 NodePath::get_pos_delta(NodePath const &amp;other) const;</span>

<span class="s0">2470 7 set_hpr 0 4 3648 17 NodePath::set_hpr 0 4 588 589 590 591 374</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the rotation component of the transform, leaving translation and scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation component of the transform, relative to the other node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation component of the transform, leaving translation and scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation component of the transform, relative to the other node.</span>
 <span class="s0">*/</span>
<span class="s0">289</span>
<span class="s0">inline void NodePath::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>
<span class="s0">void NodePath::set_hpr(LVecBase3 const &amp;hpr);</span>
<span class="s0">inline void NodePath::set_hpr(NodePath const &amp;other, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>
<span class="s0">void NodePath::set_hpr(NodePath const &amp;other, LVecBase3 const &amp;hpr);</span>

<span class="s0">2471 5 set_h 0 4 3648 15 NodePath::set_h 0 2 592 593 0</span>
<span class="s0">96</span>
<span class="s0">void NodePath::set_h(PN_stdfloat h);</span>
<span class="s0">void NodePath::set_h(NodePath const &amp;other, PN_stdfloat h);</span>

<span class="s0">2472 5 set_p 0 4 3648 15 NodePath::set_p 0 2 594 595 0</span>
<span class="s0">96</span>
<span class="s0">void NodePath::set_p(PN_stdfloat p);</span>
<span class="s0">void NodePath::set_p(NodePath const &amp;other, PN_stdfloat p);</span>

<span class="s0">2473 5 set_r 0 4 3648 15 NodePath::set_r 0 2 596 597 0</span>
<span class="s0">96</span>
<span class="s0">void NodePath::set_r(PN_stdfloat r);</span>
<span class="s0">void NodePath::set_r(NodePath const &amp;other, PN_stdfloat r);</span>

<span class="s0">2474 7 get_hpr 0 4 3648 17 NodePath::get_hpr 0 2 598 599 157</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the rotation component of the transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the relative orientation of the bottom node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">LVecBase3 NodePath::get_hpr(void) const;</span>
<span class="s0">LVecBase3 NodePath::get_hpr(NodePath const &amp;other) const;</span>

<span class="s0">2475 5 get_h 0 4 3648 15 NodePath::get_h 0 2 600 601 0</span>
<span class="s0">112</span>
<span class="s0">inline PN_stdfloat NodePath::get_h(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_h(NodePath const &amp;other) const;</span>

<span class="s0">2476 5 get_p 0 4 3648 15 NodePath::get_p 0 2 602 603 0</span>
<span class="s0">112</span>
<span class="s0">inline PN_stdfloat NodePath::get_p(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_p(NodePath const &amp;other) const;</span>

<span class="s0">2477 5 get_r 0 4 3648 15 NodePath::get_r 0 2 604 605 0</span>
<span class="s0">112</span>
<span class="s0">inline PN_stdfloat NodePath::get_r(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_r(NodePath const &amp;other) const;</span>

<span class="s0">2478 8 set_quat 0 4 3648 18 NodePath::set_quat 0 2 606 607 186</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the rotation component of the transform, leaving translation and scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation component of the transform, relative to the other node.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">void NodePath::set_quat(LQuaternion const &amp;quat);</span>
<span class="s0">void NodePath::set_quat(NodePath const &amp;other, LQuaternion const &amp;quat);</span>

<span class="s0">2479 8 get_quat 0 4 3648 18 NodePath::get_quat 0 2 608 609 157</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the rotation component of the transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the relative orientation of the bottom node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">104</span>
<span class="s0">LQuaternion NodePath::get_quat(void) const;</span>
<span class="s0">LQuaternion NodePath::get_quat(NodePath const &amp;other) const;</span>

<span class="s0">2480 9 set_scale 0 4 3648 19 NodePath::set_scale 0 6 610 611 612 613 614 615 451</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the scale component of the transform, leaving translation and rotation</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the scale component of the transform, relative to the other node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the scale component of the transform, relative to the other node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the scale component of the transform, leaving translation and rotation</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the scale component of the transform, relative to the other node.</span>
 <span class="s0">*/</span>
<span class="s0">434</span>
<span class="s0">inline void NodePath::set_scale(PN_stdfloat scale);</span>
<span class="s0">inline void NodePath::set_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz);</span>
<span class="s0">void NodePath::set_scale(LVecBase3 const &amp;scale);</span>
<span class="s0">inline void NodePath::set_scale(NodePath const &amp;other, PN_stdfloat scale);</span>
<span class="s0">inline void NodePath::set_scale(NodePath const &amp;other, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz);</span>
<span class="s0">void NodePath::set_scale(NodePath const &amp;other, LVecBase3 const &amp;scale);</span>

<span class="s0">2481 6 set_sx 0 4 3648 16 NodePath::set_sx 0 2 616 617 114</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the x-scale component of the transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_scale()</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">void NodePath::set_sx(PN_stdfloat sx);</span>
<span class="s0">void NodePath::set_sx(NodePath const &amp;other, PN_stdfloat sx);</span>

<span class="s0">2482 6 set_sy 0 4 3648 16 NodePath::set_sy 0 2 618 619 114</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the y-scale component of the transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_scale()</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">void NodePath::set_sy(PN_stdfloat sy);</span>
<span class="s0">void NodePath::set_sy(NodePath const &amp;other, PN_stdfloat sy);</span>

<span class="s0">2483 6 set_sz 0 4 3648 16 NodePath::set_sz 0 2 620 621 114</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the z-scale component of the transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_scale()</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">void NodePath::set_sz(PN_stdfloat sz);</span>
<span class="s0">void NodePath::set_sz(NodePath const &amp;other, PN_stdfloat sz);</span>

<span class="s0">2484 9 get_scale 0 4 3648 19 NodePath::get_scale 0 2 622 623 145</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the scale component of the transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the relative scale of the bottom node as seen from the other node.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">LVecBase3 NodePath::get_scale(void) const;</span>
<span class="s0">LVecBase3 NodePath::get_scale(NodePath const &amp;other) const;</span>

<span class="s0">2485 6 get_sx 0 4 3648 16 NodePath::get_sx 0 2 624 625 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the relative scale of the referenced node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline PN_stdfloat NodePath::get_sx(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_sx(NodePath const &amp;other) const;</span>

<span class="s0">2486 6 get_sy 0 4 3648 16 NodePath::get_sy 0 2 626 627 0</span>
<span class="s0">114</span>
<span class="s0">inline PN_stdfloat NodePath::get_sy(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_sy(NodePath const &amp;other) const;</span>

<span class="s0">2487 6 get_sz 0 4 3648 16 NodePath::get_sz 0 2 628 629 0</span>
<span class="s0">114</span>
<span class="s0">inline PN_stdfloat NodePath::get_sz(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_sz(NodePath const &amp;other) const;</span>

<span class="s0">2488 9 set_shear 0 4 3648 19 NodePath::set_shear 0 4 630 631 632 633 376</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the shear component of the transform, leaving translation, rotation,</span>
 <span class="s0">* and scale untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the shear component of the transform, relative to the other node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the shear component of the transform, leaving translation and rotation</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the shear component of the transform, relative to the other node.</span>
 <span class="s0">*/</span>
<span class="s0">319</span>
<span class="s0">inline void NodePath::set_shear(PN_stdfloat shxy, PN_stdfloat shxz, PN_stdfloat shyz);</span>
<span class="s0">void NodePath::set_shear(LVecBase3 const &amp;shear);</span>
<span class="s0">inline void NodePath::set_shear(NodePath const &amp;other, PN_stdfloat shxy, PN_stdfloat shxz, PN_stdfloat shyz);</span>
<span class="s0">void NodePath::set_shear(NodePath const &amp;other, LVecBase3 const &amp;shear);</span>

<span class="s0">2489 8 set_shxy 0 4 3648 18 NodePath::set_shxy 0 2 634 635 0</span>
<span class="s0">108</span>
<span class="s0">void NodePath::set_shxy(PN_stdfloat shxy);</span>
<span class="s0">void NodePath::set_shxy(NodePath const &amp;other, PN_stdfloat shxy);</span>

<span class="s0">2490 8 set_shxz 0 4 3648 18 NodePath::set_shxz 0 2 636 637 0</span>
<span class="s0">108</span>
<span class="s0">void NodePath::set_shxz(PN_stdfloat shxz);</span>
<span class="s0">void NodePath::set_shxz(NodePath const &amp;other, PN_stdfloat shxz);</span>

<span class="s0">2491 8 set_shyz 0 4 3648 18 NodePath::set_shyz 0 2 638 639 0</span>
<span class="s0">108</span>
<span class="s0">void NodePath::set_shyz(PN_stdfloat shyz);</span>
<span class="s0">void NodePath::set_shyz(NodePath const &amp;other, PN_stdfloat shyz);</span>

<span class="s0">2492 9 get_shear 0 4 3648 19 NodePath::get_shear 0 2 640 641 145</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the shear component of the transform.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the relative shear of the bottom node as seen from the other node.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">LVecBase3 NodePath::get_shear(void) const;</span>
<span class="s0">LVecBase3 NodePath::get_shear(NodePath const &amp;other) const;</span>

<span class="s0">2493 8 get_shxy 0 4 3648 18 NodePath::get_shxy 0 2 642 643 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the relative shear of the referenced node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">inline PN_stdfloat NodePath::get_shxy(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_shxy(NodePath const &amp;other) const;</span>

<span class="s0">2494 8 get_shxz 0 4 3648 18 NodePath::get_shxz 0 2 644 645 0</span>
<span class="s0">118</span>
<span class="s0">inline PN_stdfloat NodePath::get_shxz(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_shxz(NodePath const &amp;other) const;</span>

<span class="s0">2495 8 get_shyz 0 4 3648 18 NodePath::get_shyz 0 2 646 647 0</span>
<span class="s0">118</span>
<span class="s0">inline PN_stdfloat NodePath::get_shyz(void) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_shyz(NodePath const &amp;other) const;</span>

<span class="s0">2496 11 set_pos_hpr 0 4 3648 21 NodePath::set_pos_hpr 0 4 648 649 650 651 412</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, leaving scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, relative to</span>
 <span class="s0">* the other node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, leaving scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, relative to</span>
 <span class="s0">* the other node.</span>
 <span class="s0">*/</span>
<span class="s0">439</span>
<span class="s0">inline void NodePath::set_pos_hpr(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>
<span class="s0">void NodePath::set_pos_hpr(LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr);</span>
<span class="s0">inline void NodePath::set_pos_hpr(NodePath const &amp;other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>
<span class="s0">void NodePath::set_pos_hpr(NodePath const &amp;other, LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr);</span>

<span class="s0">2497 12 set_pos_quat 0 4 3648 22 NodePath::set_pos_quat 0 2 652 653 205</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, leaving scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, relative to</span>
 <span class="s0">* the other node.</span>
 <span class="s0">*/</span>
<span class="s0">174</span>
<span class="s0">void NodePath::set_pos_quat(LVecBase3 const &amp;pos, LQuaternion const &amp;quat);</span>
<span class="s0">void NodePath::set_pos_quat(NodePath const &amp;other, LVecBase3 const &amp;pos, LQuaternion const &amp;quat);</span>

<span class="s0">2498 13 set_hpr_scale 0 4 3648 23 NodePath::set_hpr_scale 0 4 654 655 656 657 646</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.  This, or set_pos_hpr_scale, is the preferred way to</span>
 <span class="s0">* update a transform when both hpr and scale are to be changed.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.  This, or set_pos_hpr_scale, is the preferred way to</span>
 <span class="s0">* update a transform when both hpr and scale are to be changed.</span>
 <span class="s0">*/</span>
<span class="s0">457</span>
<span class="s0">inline void NodePath::set_hpr_scale(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz);</span>
<span class="s0">void NodePath::set_hpr_scale(LVecBase3 const &amp;hpr, LVecBase3 const &amp;scale);</span>
<span class="s0">inline void NodePath::set_hpr_scale(NodePath const &amp;other, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz);</span>
<span class="s0">void NodePath::set_hpr_scale(NodePath const &amp;other, LVecBase3 const &amp;hpr, LVecBase3 const &amp;scale);</span>

<span class="s0">2499 14 set_quat_scale 0 4 3648 24 NodePath::set_quat_scale 0 2 658 659 324</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.  This, or set_pos_quat_scale, is the preferred way</span>
 <span class="s0">* to update a transform when both quat and scale are to be changed.</span>
 <span class="s0">*/</span>
<span class="s0">182</span>
<span class="s0">void NodePath::set_quat_scale(LQuaternion const &amp;quat, LVecBase3 const &amp;scale);</span>
<span class="s0">void NodePath::set_quat_scale(NodePath const &amp;other, LQuaternion const &amp;quat, LVecBase3 const &amp;scale);</span>

<span class="s0">2500 17 set_pos_hpr_scale 0 4 3648 27 NodePath::set_pos_hpr_scale 0 4 660 661 662 663 498</span>
<span class="s0">/**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, and scale</span>
 <span class="s0">* components.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, and scale</span>
 <span class="s0">* components, relative to the other node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Replaces the translation, rotation, and scale components, implicitly</span>
 <span class="s0">* setting shear to 0.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, and scale</span>
 <span class="s0">* components, relative to the other node, implicitly setting shear to 0.</span>
 <span class="s0">*/</span>
<span class="s0">607</span>
<span class="s0">inline void NodePath::set_pos_hpr_scale(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz);</span>
<span class="s0">void NodePath::set_pos_hpr_scale(LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr, LVecBase3 const &amp;scale);</span>
<span class="s0">inline void NodePath::set_pos_hpr_scale(NodePath const &amp;other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r, PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz);</span>
<span class="s0">void NodePath::set_pos_hpr_scale(NodePath const &amp;other, LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr, LVecBase3 const &amp;scale);</span>

<span class="s0">2501 18 set_pos_quat_scale 0 4 3648 28 NodePath::set_pos_quat_scale 0 2 664 665 264</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the translation, rotation, and scale components, implicitly</span>
 <span class="s0">* setting shear to 0.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, and scale</span>
 <span class="s0">* components, relative to the other node, implicitly setting shear to 0.</span>
 <span class="s0">*/</span>
<span class="s0">234</span>
<span class="s0">void NodePath::set_pos_quat_scale(LVecBase3 const &amp;pos, LQuaternion const &amp;quat, LVecBase3 const &amp;scale);</span>
<span class="s0">void NodePath::set_pos_quat_scale(NodePath const &amp;other, LVecBase3 const &amp;pos, LQuaternion const &amp;quat, LVecBase3 const &amp;scale);</span>

<span class="s0">2502 23 set_pos_hpr_scale_shear 0 4 3648 33 NodePath::set_pos_hpr_scale_shear 0 2 666 667 246</span>
<span class="s0">/**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, scale,</span>
 <span class="s0">* and shear components.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, scale,</span>
 <span class="s0">* and shear components, relative to the other node.</span>
 <span class="s0">*/</span>
<span class="s0">286</span>
<span class="s0">void NodePath::set_pos_hpr_scale_shear(LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr, LVecBase3 const &amp;scale, LVecBase3 const &amp;shear);</span>
<span class="s0">void NodePath::set_pos_hpr_scale_shear(NodePath const &amp;other, LVecBase3 const &amp;pos, LVecBase3 const &amp;hpr, LVecBase3 const &amp;scale, LVecBase3 const &amp;shear);</span>

<span class="s0">2503 24 set_pos_quat_scale_shear 0 4 3648 34 NodePath::set_pos_quat_scale_shear 0 2 668 669 246</span>
<span class="s0">/**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, scale,</span>
 <span class="s0">* and shear components.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, scale,</span>
 <span class="s0">* and shear components, relative to the other node.</span>
 <span class="s0">*/</span>
<span class="s0">294</span>
<span class="s0">void NodePath::set_pos_quat_scale_shear(LVecBase3 const &amp;pos, LQuaternion const &amp;quat, LVecBase3 const &amp;scale, LVecBase3 const &amp;shear);</span>
<span class="s0">void NodePath::set_pos_quat_scale_shear(NodePath const &amp;other, LVecBase3 const &amp;pos, LQuaternion const &amp;quat, LVecBase3 const &amp;scale, LVecBase3 const &amp;shear);</span>

<span class="s0">2504 7 set_mat 0 4 3648 17 NodePath::set_mat 0 2 670 671 197</span>
<span class="s0">/**</span>
 <span class="s0">* Directly sets an arbitrary 4x4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Converts the indicated matrix from the other's coordinate space to the</span>
 <span class="s0">* local coordinate space, and applies it to the node.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">void NodePath::set_mat(LMatrix4 const &amp;mat);</span>
<span class="s0">void NodePath::set_mat(NodePath const &amp;other, LMatrix4 const &amp;mat);</span>

<span class="s0">2505 9 clear_mat 0 4 3648 19 NodePath::clear_mat 0 1 672 69</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any transform from the referenced node.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline void NodePath::clear_mat(void);</span>

<span class="s0">2506 7 has_mat 0 4 3648 17 NodePath::has_mat 0 1 673 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a non-identity transform matrix has been applied to the</span>
 <span class="s0">* referenced node, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool NodePath::has_mat(void) const;</span>

<span class="s0">2507 7 get_mat 0 4 3648 17 NodePath::get_mat 0 2 674 675 293</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transform matrix that has been applied to the referenced node,</span>
 <span class="s0">* or the identity matrix if no matrix has been applied.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the matrix that describes the coordinate space of the bottom node,</span>
 <span class="s0">* relative to the other path's bottom node's coordinate space.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">inline LMatrix4 const &amp;NodePath::get_mat(void) const;</span>
<span class="s0">LMatrix4 NodePath::get_mat(NodePath const &amp;other) const;</span>

<span class="s0">2508 7 look_at 0 4 3648 17 NodePath::look_at 0 4 676 677 678 679 610</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the transform on this NodePath so that it rotates to face the</span>
 <span class="s0">* indicated point in space.  This will overwrite any previously existing</span>
 <span class="s0">* scale on the node, although it will preserve any translation.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the hpr on this NodePath so that it rotates to face the indicated</span>
 <span class="s0">* point in space, which is relative to the other NodePath.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the hpr on this NodePath so that it rotates to face the indicated</span>
 <span class="s0">* point in space.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the transform on this NodePath so that it rotates to face the</span>
 <span class="s0">* indicated point in space, which is relative to the other NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">388</span>
<span class="s0">inline void NodePath::look_at(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void NodePath::look_at(LPoint3 const &amp;point, LVector3 const &amp;up = LVector3::up());</span>
<span class="s0">inline void NodePath::look_at(NodePath const &amp;other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void NodePath::look_at(NodePath const &amp;other, LPoint3 const &amp;point = LPoint3(0.0, 0.0, 0.0), LVector3 const &amp;up = LVector3::up());</span>

<span class="s0">2509 8 heads_up 0 4 3648 18 NodePath::heads_up 0 4 680 681 682 683 538</span>
<span class="s0">/**</span>
 <span class="s0">* Behaves like look_at(), but with a strong preference to keeping the up</span>
 <span class="s0">* vector oriented in the indicated &quot;up&quot; direction.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Behaves like look_at(), but with a strong preference to keeping the up</span>
 <span class="s0">* vector oriented in the indicated &quot;up&quot; direction.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Behaves like look_at(), but with a strong preference to keeping the up</span>
 <span class="s0">* vector oriented in the indicated &quot;up&quot; direction.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Behaves like look_at(), but with a strong preference to keeping the up</span>
 <span class="s0">* vector oriented in the indicated &quot;up&quot; direction.</span>
 <span class="s0">*/</span>
<span class="s0">392</span>
<span class="s0">inline void NodePath::heads_up(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void NodePath::heads_up(LPoint3 const &amp;point, LVector3 const &amp;up = LVector3::up());</span>
<span class="s0">inline void NodePath::heads_up(NodePath const &amp;other, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">void NodePath::heads_up(NodePath const &amp;other, LPoint3 const &amp;point = LPoint3(0.0, 0.0, 0.0), LVector3 const &amp;up = LVector3::up());</span>

<span class="s0">2510 18 get_relative_point 0 4 3648 28 NodePath::get_relative_point 0 1 684 148</span>
<span class="s0">/**</span>
 <span class="s0">* Given that the indicated point is in the coordinate system of the other</span>
 <span class="s0">* node, returns the same point in this node's coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">LPoint3 NodePath::get_relative_point(NodePath const &amp;other, LVecBase3 const &amp;point) const;</span>

<span class="s0">2511 19 get_relative_vector 0 4 3648 29 NodePath::get_relative_vector 0 1 685 150</span>
<span class="s0">/**</span>
 <span class="s0">* Given that the indicated vector is in the coordinate system of the other</span>
 <span class="s0">* node, returns the same vector in this node's coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">LVector3 NodePath::get_relative_vector(NodePath const &amp;other, LVecBase3 const &amp;vec) const;</span>

<span class="s0">2512 12 get_distance 0 4 3648 22 NodePath::get_distance 0 1 686 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the straight-line distance between this referenced node's</span>
 <span class="s0">* coordinate frame's origin, and that of the other node's origin.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline PN_stdfloat NodePath::get_distance(NodePath const &amp;other) const;</span>

<span class="s0">2513 9 set_color 0 4 3648 19 NodePath::set_color 0 2 687 688 380</span>
<span class="s0">/**</span>
 <span class="s0">* Applies a scene-graph color to the referenced node.  This color will apply</span>
 <span class="s0">* to all geometry at this level and below (that does not specify a new color</span>
 <span class="s0">* or a set_color_off()).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Applies a scene-graph color to the referenced node.  This color will apply</span>
 <span class="s0">* to all geometry at this level and below (that does not specify a new color</span>
 <span class="s0">* or a set_color_off()).</span>
 <span class="s0">*/</span>
<span class="s0">174</span>
<span class="s0">void NodePath::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a = 1.0, int priority = 0);</span>
<span class="s0">void NodePath::set_color(LColor const &amp;color, int priority = 0);</span>

<span class="s0">2514 13 set_color_off 0 4 3648 23 NodePath::set_color_off 0 1 689 277</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using the geometry</span>
 <span class="s0">* color.  This is normally the default, but it may be useful to use this to</span>
 <span class="s0">* contradict set_color() at a higher node level (or, with a priority, to</span>
 <span class="s0">* override a set_color() at a lower level).</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void NodePath::set_color_off(int priority = 0);</span>

<span class="s0">2515 11 clear_color 0 4 3648 21 NodePath::clear_color 0 1 690 209</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any color adjustment from the node.  This allows the</span>
 <span class="s0">* natural color of the geometry, or whatever color transitions might be</span>
 <span class="s0">* otherwise affecting the geometry, to show instead.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void NodePath::clear_color(void);</span>

<span class="s0">2516 9 has_color 0 4 3648 19 NodePath::has_color 0 1 691 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a color has been applied to the given node, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">bool NodePath::has_color(void) const;</span>

<span class="s0">2517 9 get_color 0 4 3648 19 NodePath::get_color 0 1 692 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color that has been assigned to the node, or black if no color</span>
 <span class="s0">* has been assigned.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">LColor NodePath::get_color(void) const;</span>

<span class="s0">2518 15 has_color_scale 0 4 3648 25 NodePath::has_color_scale 0 1 693 194</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a color scale has been applied to the referenced node,</span>
 <span class="s0">* false otherwise.  It is still possible that color at this node might have</span>
 <span class="s0">* been scaled by an ancestor node.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">bool NodePath::has_color_scale(void) const;</span>

<span class="s0">2519 17 clear_color_scale 0 4 3648 27 NodePath::clear_color_scale 0 1 694 221</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any color scale from the referenced node.  This is</span>
 <span class="s0">* preferable to simply setting the color scale to identity, as it also</span>
 <span class="s0">* removes the overhead associated with having a color scale at all.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void NodePath::clear_color_scale(void);</span>

<span class="s0">2520 15 set_color_scale 0 4 3648 25 NodePath::set_color_scale 0 2 695 696 166</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color scale component of the transform</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the color scale component of the transform, leaving translation and</span>
 <span class="s0">* rotation untouched.</span>
 <span class="s0">*/</span>
<span class="s0">194</span>
<span class="s0">void NodePath::set_color_scale(LVecBase4 const &amp;scale, int priority = 0);</span>
<span class="s0">inline void NodePath::set_color_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz, PN_stdfloat sa, int priority = 0);</span>

<span class="s0">2521 19 compose_color_scale 0 4 3648 29 NodePath::compose_color_scale 0 2 697 698 198</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color scale component of the transform</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* multiplies the color scale component of the transform, with previous color</span>
 <span class="s0">* scale leaving translation and rotation untouched.</span>
 <span class="s0">*/</span>
<span class="s0">202</span>
<span class="s0">void NodePath::compose_color_scale(LVecBase4 const &amp;scale, int priority = 0);</span>
<span class="s0">inline void NodePath::compose_color_scale(PN_stdfloat sx, PN_stdfloat sy, PN_stdfloat sz, PN_stdfloat sa, int priority = 0);</span>

<span class="s0">2522 19 set_color_scale_off 0 4 3648 29 NodePath::set_color_scale_off 0 1 699 533</span>
<span class="s0">/**</span>
 <span class="s0">* Disables any color scale attribute inherited from above.  This is not the</span>
 <span class="s0">* same thing as clear_color_scale(), which undoes any previous</span>
 <span class="s0">* set_color_scale() operation on this node; rather, this actively disables</span>
 <span class="s0">* any set_color_scale() that might be inherited from a parent node.  This</span>
 <span class="s0">* also disables set_alpha_scale() at the same time.</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal to specify a new color scale on the same node with a subsequent</span>
 <span class="s0">* call to set_color_scale() or set_alpha_scale(); this new scale will apply</span>
 <span class="s0">* to lower geometry.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void NodePath::set_color_scale_off(int priority = 0);</span>

<span class="s0">2523 15 set_alpha_scale 0 4 3648 25 NodePath::set_alpha_scale 0 1 700 176</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the alpha scale component of the transform without (much) affecting</span>
 <span class="s0">* the color scale.  Note that any priority specified will also apply to the</span>
 <span class="s0">* color scale.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void NodePath::set_alpha_scale(PN_stdfloat scale, int priority = 0);</span>

<span class="s0">2524 19 set_all_color_scale 0 4 3648 29 NodePath::set_all_color_scale 0 1 701 206</span>
<span class="s0">/**</span>
 <span class="s0">* Scales all the color components of the object by the same amount, darkening</span>
 <span class="s0">* the object, without (much) affecting alpha.  Note that any priority</span>
 <span class="s0">* specified will also apply to the alpha scale.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void NodePath::set_all_color_scale(PN_stdfloat scale, int priority = 0);</span>

<span class="s0">2525 6 set_sr 0 4 3648 16 NodePath::set_sr 0 1 702 79</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the red component of the color scale.</span>
 <span class="s0">* @see set_color_scale()</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void NodePath::set_sr(PN_stdfloat sr);</span>

<span class="s0">2526 6 set_sg 0 4 3648 16 NodePath::set_sg 0 1 703 81</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the green component of the color scale.</span>
 <span class="s0">* @see set_color_scale()</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void NodePath::set_sg(PN_stdfloat sg);</span>

<span class="s0">2527 6 set_sb 0 4 3648 16 NodePath::set_sb 0 1 704 80</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the blue component of the color scale.</span>
 <span class="s0">* @see set_color_scale()</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void NodePath::set_sb(PN_stdfloat sb);</span>

<span class="s0">2528 6 set_sa 0 4 3648 16 NodePath::set_sa 0 1 705 81</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the alpha component of the color scale.</span>
 <span class="s0">* @see set_color_scale()</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void NodePath::set_sa(PN_stdfloat sa);</span>

<span class="s0">2529 15 get_color_scale 0 4 3648 25 NodePath::get_color_scale 0 1 706 234</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete color scale vector that has been applied to this node</span>
 <span class="s0">* via a previous call to set_color_scale() and/or set_alpha_scale(), or all</span>
 <span class="s0">* 1's (identity) if no scale has been applied to this particular node.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">LVecBase4 const &amp;NodePath::get_color_scale(void) const;</span>

<span class="s0">2530 6 get_sr 0 4 3648 16 NodePath::get_sr 0 1 707 79</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the red component of the color scale.</span>
 <span class="s0">* @see get_color_scale()</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline PN_stdfloat NodePath::get_sr(void) const;</span>

<span class="s0">2531 6 get_sg 0 4 3648 16 NodePath::get_sg 0 1 708 81</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the green component of the color scale.</span>
 <span class="s0">* @see get_color_scale()</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline PN_stdfloat NodePath::get_sg(void) const;</span>

<span class="s0">2532 6 get_sb 0 4 3648 16 NodePath::get_sb 0 1 709 80</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the blue component of the color scale.</span>
 <span class="s0">* @see get_color_scale()</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline PN_stdfloat NodePath::get_sb(void) const;</span>

<span class="s0">2533 6 get_sa 0 4 3648 16 NodePath::get_sa 0 1 710 81</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the alpha component of the color scale.</span>
 <span class="s0">* @see get_color_scale()</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline PN_stdfloat NodePath::get_sa(void) const;</span>

<span class="s0">2534 9 set_light 0 4 3648 19 NodePath::set_light 0 1 711 309</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated Light or PolylightNode to the list of lights that</span>
 <span class="s0">* illuminate geometry at this node and below.  The light itself should be</span>
 <span class="s0">* parented into the scene graph elsewhere, to represent the light's position</span>
 <span class="s0">* in space; but until set_light() is called it will illuminate no geometry.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void NodePath::set_light(NodePath const &amp;light, int priority = 0);</span>

<span class="s0">2535 13 set_light_off 0 4 3648 23 NodePath::set_light_off 0 2 712 713 799</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no lights at all.</span>
 <span class="s0">* This is different from not specifying a light; rather, this specifically</span>
 <span class="s0">* contradicts set_light() at a higher node level (or, with a priority,</span>
 <span class="s0">* overrides a set_light() at a lower level).</span>
 <span class="s0">*</span>
 <span class="s0">* If no lights are in effect on a particular piece of geometry, that geometry</span>
 <span class="s0">* is rendered with lighting disabled.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render without using the</span>
 <span class="s0">* indicated Light.  This is different from not specifying the Light; rather,</span>
 <span class="s0">* this specifically contradicts set_light() at a higher node level (or, with</span>
 <span class="s0">* a priority, overrides a set_light() at a lower level).</span>
 <span class="s0">*</span>
 <span class="s0">* This interface does not support PolylightNodes, which cannot be turned off</span>
 <span class="s0">* at a lower level.</span>
 <span class="s0">*/</span>
<span class="s0">118</span>
<span class="s0">void NodePath::set_light_off(int priority = 0);</span>
<span class="s0">void NodePath::set_light_off(NodePath const &amp;light, int priority = 0);</span>

<span class="s0">2536 11 clear_light 0 4 3648 21 NodePath::clear_light 0 2 714 715 237</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any lighting operations that may have been set via</span>
 <span class="s0">* set_light() or set_light_off() from this particular node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes any reference to the indicated Light or PolylightNode from the</span>
 <span class="s0">* NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">void NodePath::clear_light(void);</span>
<span class="s0">void NodePath::clear_light(NodePath const &amp;light);</span>

<span class="s0">2537 9 has_light 0 4 3648 19 NodePath::has_light 0 1 716 207</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated Light or PolylightNode has been specifically</span>
 <span class="s0">* enabled on this particular node.  This means that someone called</span>
 <span class="s0">* set_light() on this node with the indicated light.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">bool NodePath::has_light(NodePath const &amp;light) const;</span>

<span class="s0">2538 13 has_light_off 0 4 3648 23 NodePath::has_light_off 0 2 717 718 480</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all Lights have been specifically disabled on this</span>
 <span class="s0">* particular node.  This means that someone called set_light_off() on this</span>
 <span class="s0">* node with no parameters.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated Light has been specifically disabled on this</span>
 <span class="s0">* particular node.  This means that someone called set_light_off() on this</span>
 <span class="s0">* node with the indicated light.</span>
 <span class="s0">*</span>
 <span class="s0">* This interface does not support PolylightNodes, which cannot be turned off</span>
 <span class="s0">* at a lower level.</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">bool NodePath::has_light_off(void) const;</span>
<span class="s0">bool NodePath::has_light_off(NodePath const &amp;light) const;</span>

<span class="s0">2539 14 set_clip_plane 0 4 3648 24 NodePath::set_clip_plane 0 1 719 324</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated clipping plane to the list of planes that apply to</span>
 <span class="s0">* geometry at this node and below.  The clipping plane itself, a PlaneNode,</span>
 <span class="s0">* should be parented into the scene graph elsewhere, to represent the plane's</span>
 <span class="s0">* position in space; but until set_clip_plane() is called it will clip no</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void NodePath::set_clip_plane(NodePath const &amp;clip_plane, int priority = 0);</span>

<span class="s0">2540 18 set_clip_plane_off 0 4 3648 28 NodePath::set_clip_plane_off 0 2 720 721 793</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no clip_planes at</span>
 <span class="s0">* all.  This is different from not specifying a clip_plane; rather, this</span>
 <span class="s0">* specifically contradicts set_clip_plane() at a higher node level (or, with</span>
 <span class="s0">* a priority, overrides a set_clip_plane() at a lower level).</span>
 <span class="s0">*</span>
 <span class="s0">* If no clip_planes are in effect on a particular piece of geometry, that</span>
 <span class="s0">* geometry is rendered without being clipped (other than by the viewing</span>
 <span class="s0">* frustum).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render without being clipped</span>
 <span class="s0">* by the indicated PlaneNode.  This is different from not specifying the</span>
 <span class="s0">* PlaneNode; rather, this specifically contradicts set_clip_plane() at a</span>
 <span class="s0">* higher node level (or, with a priority, overrides a set_clip_plane() at a</span>
 <span class="s0">* lower level).</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">void NodePath::set_clip_plane_off(int priority = 0);</span>
<span class="s0">void NodePath::set_clip_plane_off(NodePath const &amp;clip_plane, int priority = 0);</span>

<span class="s0">2541 16 clear_clip_plane 0 4 3648 26 NodePath::clear_clip_plane 0 2 722 723 228</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any clip planes that may have been set via</span>
 <span class="s0">* set_clip_plane() or set_clip_plane_off() from this particular node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes any reference to the indicated clipping plane from the NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">void NodePath::clear_clip_plane(void);</span>
<span class="s0">void NodePath::clear_clip_plane(NodePath const &amp;clip_plane);</span>

<span class="s0">2542 14 has_clip_plane 0 4 3648 24 NodePath::has_clip_plane 0 1 724 209</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated clipping plane has been specifically applied</span>
 <span class="s0">* to this particular node.  This means that someone called set_clip_plane()</span>
 <span class="s0">* on this node with the indicated clip_plane.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool NodePath::has_clip_plane(NodePath const &amp;clip_plane) const;</span>

<span class="s0">2543 18 has_clip_plane_off 0 4 3648 28 NodePath::has_clip_plane_off 0 2 725 726 411</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if all clipping planes have been specifically disabled on this</span>
 <span class="s0">* particular node.  This means that someone called set_clip_plane_off() on</span>
 <span class="s0">* this node with no parameters.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated clipping plane has been specifically disabled</span>
 <span class="s0">* on this particular node.  This means that someone called</span>
 <span class="s0">* set_clip_plane_off() on this node with the indicated clip_plane.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">bool NodePath::has_clip_plane_off(void) const;</span>
<span class="s0">bool NodePath::has_clip_plane_off(NodePath const &amp;clip_plane) const;</span>

<span class="s0">2544 11 set_scissor 0 4 3648 21 NodePath::set_scissor 0 5 727 728 729 730 731 1612</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The four coordinates are understood to define a rectangle in screen space.</span>
 <span class="s0">* These numbers are relative to the current DisplayRegion, where (0,0) is the</span>
 <span class="s0">* lower-left corner of the DisplayRegion, and (1,1) is the upper-right</span>
 <span class="s0">* corner.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The two points are understood to be relative to this node.  When these</span>
 <span class="s0">* points are projected into screen space, they define the diagonally-opposite</span>
 <span class="s0">* points that determine the scissor region.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The four points are understood to be relative to this node.  When these</span>
 <span class="s0">* points are projected into screen space, they define the bounding volume of</span>
 <span class="s0">* the scissor region (the scissor region is the smallest onscreen rectangle</span>
 <span class="s0">* that encloses all four points).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The two points are understood to be relative to the indicated other node.</span>
 <span class="s0">* When these points are projected into screen space, they define the</span>
 <span class="s0">* diagonally-opposite points that determine the scissor region.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The four points are understood to be relative to the indicated other node.</span>
 <span class="s0">* When these points are projected into screen space, they define the bounding</span>
 <span class="s0">* volume of the scissor region (the scissor region is the smallest onscreen</span>
 <span class="s0">* rectangle that encloses all four points).</span>
 <span class="s0">*/</span>
<span class="s0">475</span>
<span class="s0">void NodePath::set_scissor(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);</span>
<span class="s0">void NodePath::set_scissor(LPoint3 const &amp;a, LPoint3 const &amp;b);</span>
<span class="s0">void NodePath::set_scissor(LPoint3 const &amp;a, LPoint3 const &amp;b, LPoint3 const &amp;c, LPoint3 const &amp;d);</span>
<span class="s0">void NodePath::set_scissor(NodePath const &amp;other, LPoint3 const &amp;a, LPoint3 const &amp;b);</span>
<span class="s0">void NodePath::set_scissor(NodePath const &amp;other, LPoint3 const &amp;a, LPoint3 const &amp;b, LPoint3 const &amp;c, LPoint3 const &amp;d);</span>

<span class="s0">2545 13 clear_scissor 0 4 3648 23 NodePath::clear_scissor 0 1 732 113</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the scissor region that was defined at this node level by a</span>
 <span class="s0">* previous call to set_scissor().</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">void NodePath::clear_scissor(void);</span>

<span class="s0">2546 11 has_scissor 0 4 3648 21 NodePath::has_scissor 0 1 733 325</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a scissor region was defined at this node by a previous</span>
 <span class="s0">* call to set_scissor().  This does not check for scissor regions inherited</span>
 <span class="s0">* from a parent class.  It also does not check for the presence of a low-</span>
 <span class="s0">* level ScissorAttrib, which is different from the ScissorEffect added by</span>
 <span class="s0">* set_scissor.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">bool NodePath::has_scissor(void) const;</span>

<span class="s0">2547 12 set_occluder 0 4 3648 22 NodePath::set_occluder 0 1 734 320</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated occluder to the list of occluders that apply to geometry</span>
 <span class="s0">* at this node and below.  The occluder itself, an OccluderNode, should be</span>
 <span class="s0">* parented into the scene graph elsewhere, to represent the occluder's</span>
 <span class="s0">* position in space; but until set_occluder() is called it will clip no</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void NodePath::set_occluder(NodePath const &amp;occluder);</span>

<span class="s0">2548 14 clear_occluder 0 4 3648 24 NodePath::clear_occluder 0 2 735 736 194</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any occluders that may have been set via set_occluder()</span>
 <span class="s0">* from this particular node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes any reference to the indicated occluder from the NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">void NodePath::clear_occluder(void);</span>
<span class="s0">void NodePath::clear_occluder(NodePath const &amp;occluder);</span>

<span class="s0">2549 12 has_occluder 0 4 3648 22 NodePath::has_occluder 0 1 737 199</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated occluder has been specifically applied to</span>
 <span class="s0">* this particular node.  This means that someone called set_occluder() on</span>
 <span class="s0">* this node with the indicated occluder.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool NodePath::has_occluder(NodePath const &amp;occluder) const;</span>

<span class="s0">2550 7 set_bin 0 4 3648 17 NodePath::set_bin 0 1 738 884</span>
<span class="s0">/**</span>
 <span class="s0">* Assigns the geometry at this level and below to the named rendering bin.</span>
 <span class="s0">* It is the user's responsibility to ensure that such a bin already exists,</span>
 <span class="s0">* either via the cull-bin Configrc variable, or by explicitly creating a</span>
 <span class="s0">* GeomBin of the appropriate type at runtime.</span>
 <span class="s0">*</span>
 <span class="s0">* There are two default bins created when Panda is started: &quot;default&quot; and</span>
 <span class="s0">* &quot;fixed&quot;.  Normally, all geometry is assigned to &quot;default&quot; unless specified</span>
 <span class="s0">* otherwise.  This bin renders opaque geometry in state-sorted order,</span>
 <span class="s0">* followed by transparent geometry sorted back-to-front.  If any geometry is</span>
 <span class="s0">* assigned to &quot;fixed&quot;, this will be rendered following all the geometry in</span>
 <span class="s0">* &quot;default&quot;, in the order specified by draw_order for each piece of geometry</span>
 <span class="s0">* so assigned.</span>
 <span class="s0">*</span>
 <span class="s0">* The draw_order parameter is meaningful only for GeomBinFixed type bins,</span>
 <span class="s0">* e.g.  &quot;fixed&quot;.  Other kinds of bins ignore it.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">void NodePath::set_bin(std::string const &amp;bin_name, int draw_order, int priority = 0);</span>

<span class="s0">2551 9 clear_bin 0 4 3648 19 NodePath::clear_bin 0 1 739 115</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any bin adjustment that may have been set via set_bin()</span>
 <span class="s0">* from this particular node.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void NodePath::clear_bin(void);</span>

<span class="s0">2552 7 has_bin 0 4 3648 17 NodePath::has_bin 0 1 740 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the node has been assigned to the a particular rendering</span>
 <span class="s0">* bin via set_bin(), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">bool NodePath::has_bin(void) const;</span>

<span class="s0">2553 12 get_bin_name 0 4 3648 22 NodePath::get_bin_name 0 1 741 175</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the bin that this particular node was assigned to via</span>
 <span class="s0">* set_bin(), or the empty string if no bin was assigned.  See set_bin() and</span>
 <span class="s0">* has_bin().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">std::string NodePath::get_bin_name(void) const;</span>

<span class="s0">2554 18 get_bin_draw_order 0 4 3648 28 NodePath::get_bin_draw_order 0 1 742 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the drawing order associated with the bin that this particular node</span>
 <span class="s0">* was assigned to via set_bin(), or 0 if no bin was assigned.  See set_bin()</span>
 <span class="s0">* and has_bin().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int NodePath::get_bin_draw_order(void) const;</span>

<span class="s0">2555 11 set_texture 0 4 3648 21 NodePath::set_texture 0 4 743 744 745 746 1840</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the default texture stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the convenience single-texture variant of this method; it is now</span>
 <span class="s0">* superceded by set_texture() that accepts a stage and texture.  You may use</span>
 <span class="s0">* this method if you just want to adjust the default stage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the indicated multitexture stage.  If there are multiple texture stages</span>
 <span class="s0">* specified (possibly on multiple different nodes at different levels), they</span>
 <span class="s0">* will all be applied to geometry together, according to the stage</span>
 <span class="s0">* specification set up in the TextureStage object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the default texture stage.</span>
 <span class="s0">*</span>
 <span class="s0">* The given sampler state will override the sampling settings on the texture</span>
 <span class="s0">* itself.  Note that this method makes a copy of the sampler settings that</span>
 <span class="s0">* you give; further changes to this object will not be reflected.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the convenience single-texture variant of this method; it is now</span>
 <span class="s0">* superceded by set_texture() that accepts a stage and texture.  You may use</span>
 <span class="s0">* this method if you just want to adjust the default stage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the indicated multitexture stage.  If there are multiple texture stages</span>
 <span class="s0">* specified (possibly on multiple different nodes at different levels), they</span>
 <span class="s0">* will all be applied to geometry together, according to the stage</span>
 <span class="s0">* specification set up in the TextureStage object.</span>
 <span class="s0">*</span>
 <span class="s0">* The given sampler state will override the sampling settings on the texture</span>
 <span class="s0">* itself.  Note that this method makes a copy of the sampler settings that</span>
 <span class="s0">* you give; further changes to this object will not be reflected.</span>
 <span class="s0">*/</span>
<span class="s0">339</span>
<span class="s0">void NodePath::set_texture(Texture *tex, int priority = 0);</span>
<span class="s0">void NodePath::set_texture(TextureStage *stage, Texture *tex, int priority = 0);</span>
<span class="s0">void NodePath::set_texture(Texture *tex, SamplerState const &amp;sampler, int priority = 0);</span>
<span class="s0">void NodePath::set_texture(TextureStage *stage, Texture *tex, SamplerState const &amp;sampler, int priority = 0);</span>

<span class="s0">2556 15 set_texture_off 0 4 3648 25 NodePath::set_texture_off 0 2 747 748 602</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no texture, on</span>
 <span class="s0">* any stage.  This is different from not specifying a texture; rather, this</span>
 <span class="s0">* specifically contradicts set_texture() at a higher node level (or, with a</span>
 <span class="s0">* priority, overrides a set_texture() at a lower level).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no texture, on</span>
 <span class="s0">* the indicated stage.  This is different from not specifying a texture;</span>
 <span class="s0">* rather, this specifically contradicts set_texture() at a higher node level</span>
 <span class="s0">* (or, with a priority, overrides a set_texture() at a lower level).</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">void NodePath::set_texture_off(int priority = 0);</span>
<span class="s0">void NodePath::set_texture_off(TextureStage *stage, int priority = 0);</span>

<span class="s0">2557 13 clear_texture 0 4 3648 23 NodePath::clear_texture 0 2 749 750 324</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any texture adjustment that may have been set via</span>
 <span class="s0">* set_texture() or set_texture_off() from this particular node.  This allows</span>
 <span class="s0">* whatever textures might be otherwise affecting the geometry to show</span>
 <span class="s0">* instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes any reference to the indicated texture stage from the NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">void NodePath::clear_texture(void);</span>
<span class="s0">void NodePath::clear_texture(TextureStage *stage);</span>

<span class="s0">2558 11 has_texture 0 4 3648 21 NodePath::has_texture 0 2 751 752 601</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a texture has been applied to this particular node via</span>
 <span class="s0">* set_texture(), false otherwise.  This is not the same thing as asking</span>
 <span class="s0">* whether the geometry at this node will be rendered with texturing, as there</span>
 <span class="s0">* may be a texture in effect from a higher or lower level.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if texturing has been specifically enabled on this particular</span>
 <span class="s0">* node for the indicated stage.  This means that someone called set_texture()</span>
 <span class="s0">* on this node with the indicated stage name, or the stage_name is the</span>
 <span class="s0">* default stage_name, and someone called set_texture() on this node.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">bool NodePath::has_texture(void) const;</span>
<span class="s0">bool NodePath::has_texture(TextureStage *stage) const;</span>

<span class="s0">2559 15 has_texture_off 0 4 3648 25 NodePath::has_texture_off 0 2 753 754 604</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if texturing has been specifically disabled on this particular</span>
 <span class="s0">* node via set_texture_off(), false otherwise.  This is not the same thing as</span>
 <span class="s0">* asking whether the geometry at this node will be rendered untextured, as</span>
 <span class="s0">* there may be a texture in effect from a higher or lower level.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if texturing has been specifically disabled on this particular</span>
 <span class="s0">* node for the indicated stage.  This means that someone called</span>
 <span class="s0">* set_texture_off() on this node with the indicated stage name, or that</span>
 <span class="s0">* someone called set_texture_off() on this node to remove all stages.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">bool NodePath::has_texture_off(void) const;</span>
<span class="s0">bool NodePath::has_texture_off(TextureStage *stage) const;</span>

<span class="s0">2560 11 get_texture 0 4 3648 21 NodePath::get_texture 0 2 755 756 471</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the base-level texture that has been set on this particular node,</span>
 <span class="s0">* or NULL if no texture has been set.  This is not necessarily the texture</span>
 <span class="s0">* that will be applied to the geometry at or below this level, as another</span>
 <span class="s0">* texture at a higher or lower level may override.</span>
 <span class="s0">*</span>
 <span class="s0">* See also find_texture().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the texture that has been set on the indicated stage for this</span>
 <span class="s0">* particular node, or NULL if no texture has been set for this stage.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">Texture *NodePath::get_texture(void) const;</span>
<span class="s0">Texture *NodePath::get_texture(TextureStage *stage) const;</span>

<span class="s0">2561 15 replace_texture 0 4 3648 25 NodePath::replace_texture 0 2 757 758 267</span>
<span class="s0">// Let interrogate know this also accepts None</span>

<span class="s0">/**</span>
 <span class="s0">* Recursively searches the scene graph for references to the given texture,</span>
 <span class="s0">* and replaces them with the new texture.</span>
 <span class="s0">*</span>
 <span class="s0">* As of Panda3D 1.10.13, new_tex may be null to remove the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.4</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">void NodePath::replace_texture(Texture *tex, Texture *new_tex);</span>
<span class="s0">void NodePath::replace_texture(Texture *tex, std::nullptr_t new_tex);</span>

<span class="s0">2562 19 get_texture_sampler 0 4 3648 29 NodePath::get_texture_sampler 0 2 759 760 649</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sampler state that has been given for the base-level texture</span>
 <span class="s0">* that has been set on this particular node.  If no sampler state was given,</span>
 <span class="s0">* this returns the texture's default sampler settings.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error to call this if there is no base-level texture applied to</span>
 <span class="s0">* this particular node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the sampler state that has been given for the indicated texture</span>
 <span class="s0">* stage that has been set on this particular node.  If no sampler state was</span>
 <span class="s0">* given, this returns the texture's default sampler settings.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error to call this if there is no texture set for this stage on</span>
 <span class="s0">* this particular node.</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">SamplerState const &amp;NodePath::get_texture_sampler(void) const;</span>
<span class="s0">SamplerState const &amp;NodePath::get_texture_sampler(TextureStage *stage) const;</span>

<span class="s0">2563 10 set_shader 0 4 3648 20 NodePath::set_shader 0 1 761 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void NodePath::set_shader(Shader const *sha, int priority = 0);</span>

<span class="s0">2564 14 set_shader_off 0 4 3648 24 NodePath::set_shader_off 0 1 762 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void NodePath::set_shader_off(int priority = 0);</span>

<span class="s0">2565 15 set_shader_auto 0 4 3648 25 NodePath::set_shader_auto 0 2 763 764 63</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* overloaded for auto shader customization</span>
 <span class="s0">*/</span>
<span class="s0">124</span>
<span class="s0">void NodePath::set_shader_auto(int priority = 0);</span>
<span class="s0">void NodePath::set_shader_auto(BitMask32 shader_switch, int priority = 0);</span>

<span class="s0">2566 12 clear_shader 0 4 3648 22 NodePath::clear_shader 0 1 765 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void NodePath::clear_shader(void);</span>

<span class="s0">2567 16 set_shader_input 0 4 3648 26 NodePath::set_shader_input 0 6 766 767 768 769 770 771 334</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">671</span>
<span class="s0">void NodePath::set_shader_input(ShaderInput const &amp;input);</span>
<span class="s0">inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, SamplerState const &amp;sampler, int priority = 0);</span>
<span class="s0">inline void NodePath::set_shader_input(CPT_InternalName id, Texture *tex, bool read, bool write, int z = -1, int n = 0, int priority = 0);</span>
<span class="s0">inline void NodePath::set_shader_input(CPT_InternalName id, int n1, int n2, int n3 = 0, int n4 = 0, int priority = 0);</span>
<span class="s0">inline void NodePath::set_shader_input(CPT_InternalName id, PN_stdfloat n1, PN_stdfloat n2, PN_stdfloat n3 = 0, PN_stdfloat n4 = 0, int priority = 0);</span>
<span class="s0">void NodePath::set_shader_input(CPT_InternalName , PyObject *, int priority = 0);</span>

<span class="s0">2568 17 set_shader_inputs 0 4 3648 27 NodePath::set_shader_inputs 0 1 772 0</span>
<span class="s0">67</span>
<span class="s0">void NodePath::set_shader_inputs(PyObject *args, PyObject *kwargs);</span>

<span class="s0">2569 18 clear_shader_input 0 4 3648 28 NodePath::clear_shader_input 0 1 773 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void NodePath::clear_shader_input(CPT_InternalName id);</span>

<span class="s0">2570 18 set_instance_count 0 4 3648 28 NodePath::set_instance_count 0 1 774 174</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry instance count, or 0 if geometry instancing should be</span>
 <span class="s0">* disabled.  Do not confuse with instanceTo which only applies to animation</span>
 <span class="s0">* instancing.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void NodePath::set_instance_count(int instance_count);</span>

<span class="s0">2571 10 get_shader 0 4 3648 20 NodePath::get_shader 0 1 775 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">Shader const *NodePath::get_shader(void) const;</span>

<span class="s0">2572 16 get_shader_input 0 4 3648 26 NodePath::get_shader_input 0 1 776 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">ShaderInput NodePath::get_shader_input(CPT_InternalName id) const;</span>

<span class="s0">2573 18 get_instance_count 0 4 3648 28 NodePath::get_instance_count 0 1 777 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the geometry instance count, or 0 if disabled.  See</span>
 <span class="s0">* set_instance_count.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int NodePath::get_instance_count(void) const;</span>

<span class="s0">2574 17 set_tex_transform 0 4 3648 27 NodePath::set_tex_transform 0 2 778 779 212</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the texture matrix on the current node to the indicated transform for</span>
 <span class="s0">* the given stage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the texture matrix on the current node to the indicated transform for</span>
 <span class="s0">* the given stage.</span>
 <span class="s0">*/</span>
<span class="s0">198</span>
<span class="s0">void NodePath::set_tex_transform(TextureStage *stage, TransformState const *transform);</span>
<span class="s0">void NodePath::set_tex_transform(NodePath const &amp;other, TextureStage *stage, TransformState const *transform);</span>

<span class="s0">2575 19 clear_tex_transform 0 4 3648 29 NodePath::clear_tex_transform 0 2 780 781 142</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all texture matrices from the current node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the texture matrix on the current node for the given stage.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">void NodePath::clear_tex_transform(void);</span>
<span class="s0">void NodePath::clear_tex_transform(TextureStage *stage);</span>

<span class="s0">2576 17 has_tex_transform 0 4 3648 27 NodePath::has_tex_transform 0 1 782 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is an explicit texture matrix on the current node for</span>
 <span class="s0">* the given stage.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool NodePath::has_tex_transform(TextureStage *stage) const;</span>

<span class="s0">2577 17 get_tex_transform 0 4 3648 27 NodePath::get_tex_transform 0 2 783 784 276</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the texture matrix on the current node for the given stage, or</span>
 <span class="s0">* identity transform if there is no explicit transform set for the given</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the texture matrix on the current node for the given stage,</span>
 <span class="s0">* relative to the other node.</span>
 <span class="s0">*/</span>
<span class="s0">200</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; NodePath::get_tex_transform(TextureStage *stage) const;</span>
<span class="s0">ConstPointerTo&lt; TransformState &gt; NodePath::get_tex_transform(NodePath const &amp;other, TextureStage *stage) const;</span>

<span class="s0">2578 14 set_tex_offset 0 4 3648 24 NodePath::set_tex_offset 0 4 785 786 787 788 738</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">383</span>
<span class="s0">inline void NodePath::set_tex_offset(TextureStage *stage, PN_stdfloat u, PN_stdfloat v);</span>
<span class="s0">inline void NodePath::set_tex_offset(TextureStage *stage, LVecBase2 const &amp;uv);</span>
<span class="s0">inline void NodePath::set_tex_offset(NodePath const &amp;other, TextureStage *stage, PN_stdfloat u, PN_stdfloat v);</span>
<span class="s0">inline void NodePath::set_tex_offset(NodePath const &amp;other, TextureStage *stage, LVecBase2 const &amp;uv);</span>

<span class="s0">2579 14 set_tex_rotate 0 4 3648 24 NodePath::set_tex_rotate 0 2 789 790 418</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* clockwise in degrees, to UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* clockwise in degrees, to UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">inline void NodePath::set_tex_rotate(TextureStage *stage, PN_stdfloat r);</span>
<span class="s0">inline void NodePath::set_tex_rotate(NodePath const &amp;other, TextureStage *stage, PN_stdfloat r);</span>

<span class="s0">2580 13 set_tex_scale 0 4 3648 23 NodePath::set_tex_scale 0 10 791 792 793 794 795 796 797 798 799 800 1803</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 2-d or 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 2-d or 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">988</span>
<span class="s0">inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat scale);</span>
<span class="s0">inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat su, PN_stdfloat sv);</span>
<span class="s0">inline void NodePath::set_tex_scale(TextureStage *stage, LVecBase2 const &amp;scale);</span>
<span class="s0">inline void NodePath::set_tex_scale(TextureStage *stage, PN_stdfloat su, PN_stdfloat sv, PN_stdfloat sw);</span>
<span class="s0">inline void NodePath::set_tex_scale(TextureStage *stage, LVecBase3 const &amp;scale);</span>
<span class="s0">inline void NodePath::set_tex_scale(NodePath const &amp;other, TextureStage *stage, PN_stdfloat scale);</span>
<span class="s0">inline void NodePath::set_tex_scale(NodePath const &amp;other, TextureStage *stage, PN_stdfloat su, PN_stdfloat sv);</span>
<span class="s0">inline void NodePath::set_tex_scale(NodePath const &amp;other, TextureStage *stage, LVecBase2 const &amp;scale);</span>
<span class="s0">inline void NodePath::set_tex_scale(NodePath const &amp;other, TextureStage *stage, PN_stdfloat su, PN_stdfloat sv, PN_stdfloat sw);</span>
<span class="s0">inline void NodePath::set_tex_scale(NodePath const &amp;other, TextureStage *stage, LVecBase3 const &amp;scale);</span>

<span class="s0">2581 14 get_tex_offset 0 4 3648 24 NodePath::get_tex_offset 0 2 801 802 320</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the offset set for the UV's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the offset set for the UV's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">162</span>
<span class="s0">inline LVecBase2 NodePath::get_tex_offset(TextureStage *stage) const;</span>
<span class="s0">inline LVecBase2 NodePath::get_tex_offset(NodePath const &amp;other, TextureStage *stage) const;</span>

<span class="s0">2582 14 get_tex_rotate 0 4 3648 24 NodePath::get_tex_rotate 0 2 803 804 324</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the rotation set for the UV's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the rotation set for the UV's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">166</span>
<span class="s0">inline PN_stdfloat NodePath::get_tex_rotate(TextureStage *stage) const;</span>
<span class="s0">inline PN_stdfloat NodePath::get_tex_rotate(NodePath const &amp;other, TextureStage *stage) const;</span>

<span class="s0">2583 13 get_tex_scale 0 4 3648 23 NodePath::get_tex_scale 0 2 805 806 312</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scale set for the UV's for the given stage on the current node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the scale set for the UV's for the given stage on the current node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">160</span>
<span class="s0">inline LVecBase2 NodePath::get_tex_scale(TextureStage *stage) const;</span>
<span class="s0">inline LVecBase2 NodePath::get_tex_scale(NodePath const &amp;other, TextureStage *stage) const;</span>

<span class="s0">2584 11 set_tex_pos 0 4 3648 21 NodePath::set_tex_pos 0 4 807 808 809 810 706</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">403</span>
<span class="s0">inline void NodePath::set_tex_pos(TextureStage *stage, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w);</span>
<span class="s0">inline void NodePath::set_tex_pos(TextureStage *stage, LVecBase3 const &amp;uvw);</span>
<span class="s0">inline void NodePath::set_tex_pos(NodePath const &amp;other, TextureStage *stage, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w);</span>
<span class="s0">inline void NodePath::set_tex_pos(NodePath const &amp;other, TextureStage *stage, LVecBase3 const &amp;uvw);</span>

<span class="s0">2585 11 set_tex_hpr 0 4 3648 21 NodePath::set_tex_hpr 0 4 811 812 813 814 774</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* as a 3-D HPR, to UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* as a 3-D HPR, to UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* as a 3-D HPR, to UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* as a 3-D HPR, to UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">403</span>
<span class="s0">inline void NodePath::set_tex_hpr(TextureStage *stage, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>
<span class="s0">inline void NodePath::set_tex_hpr(TextureStage *stage, LVecBase3 const &amp;hpr);</span>
<span class="s0">inline void NodePath::set_tex_hpr(NodePath const &amp;other, TextureStage *stage, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>
<span class="s0">inline void NodePath::set_tex_hpr(NodePath const &amp;other, TextureStage *stage, LVecBase3 const &amp;hpr);</span>

<span class="s0">2586 11 get_tex_pos 0 4 3648 21 NodePath::get_tex_pos 0 2 815 816 304</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the offset set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the offset set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">inline LVecBase3 NodePath::get_tex_pos(TextureStage *stage) const;</span>
<span class="s0">inline LVecBase3 NodePath::get_tex_pos(NodePath const &amp;other, TextureStage *stage) const;</span>

<span class="s0">2587 11 get_tex_hpr 0 4 3648 21 NodePath::get_tex_hpr 0 2 817 818 306</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 3-D HPR set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the 3-D HPR set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">inline LVecBase3 NodePath::get_tex_hpr(TextureStage *stage) const;</span>
<span class="s0">inline LVecBase3 NodePath::get_tex_hpr(NodePath const &amp;other, TextureStage *stage) const;</span>

<span class="s0">2588 16 get_tex_scale_3d 0 4 3648 26 NodePath::get_tex_scale_3d 0 2 819 820 302</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scale set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the scale set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/</span>
<span class="s0">166</span>
<span class="s0">inline LVecBase3 NodePath::get_tex_scale_3d(TextureStage *stage) const;</span>
<span class="s0">inline LVecBase3 NodePath::get_tex_scale_3d(NodePath const &amp;other, TextureStage *stage) const;</span>

<span class="s0">2589 11 set_tex_gen 0 4 3648 21 NodePath::set_tex_gen 0 2 821 822 309</span>
<span class="s0">/**</span>
 <span class="s0">* Enables automatic texture coordinate generation for the indicated texture</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Enables automatic texture coordinate generation for the indicated texture</span>
 <span class="s0">* stage.  This version of this method is useful when setting M_constant,</span>
 <span class="s0">* which requires a constant texture coordinate value.</span>
 <span class="s0">*/</span>
<span class="s0">229</span>
<span class="s0">void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, int priority = 0);</span>
<span class="s0">void NodePath::set_tex_gen(TextureStage *stage, RenderAttrib::TexGenMode mode, LTexCoord3 const &amp;constant_value, int priority = 0);</span>

<span class="s0">2590 13 clear_tex_gen 0 4 3648 23 NodePath::clear_tex_gen 0 2 823 824 195</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the texture coordinate generation mode from all texture stages on</span>
 <span class="s0">* this node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Disables automatic texture coordinate generation for the indicated texture</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">void NodePath::clear_tex_gen(void);</span>
<span class="s0">void NodePath::clear_tex_gen(TextureStage *stage);</span>

<span class="s0">2591 11 has_tex_gen 0 4 3648 21 NodePath::has_tex_gen 0 1 825 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a mode for automatic texture coordinate generation</span>
 <span class="s0">* on the current node for the given stage.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">bool NodePath::has_tex_gen(TextureStage *stage) const;</span>

<span class="s0">2592 11 get_tex_gen 0 4 3648 21 NodePath::get_tex_gen 0 1 826 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the texture coordinate generation mode for the given stage, or</span>
 <span class="s0">* M_off if there is no explicit mode set for the given stage.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">RenderAttrib::TexGenMode NodePath::get_tex_gen(TextureStage *stage) const;</span>

<span class="s0">2593 17 set_tex_projector 0 4 3648 27 NodePath::set_tex_projector 0 1 827 529</span>
<span class="s0">/**</span>
 <span class="s0">* Establishes a TexProjectorEffect on this node, which can be used to</span>
 <span class="s0">* establish projective texturing (but see also the</span>
 <span class="s0">* NodePath::project_texture() convenience function), or it can be used to</span>
 <span class="s0">* bind this node's texture transform to particular node's position in space,</span>
 <span class="s0">* allowing a LerpInterval (for instance) to adjust this node's texture</span>
 <span class="s0">* coordinates.</span>
 <span class="s0">*</span>
 <span class="s0">* If to is a LensNode, then the fourth parameter, lens_index, can be provided</span>
 <span class="s0">* to select a particular lens to apply.  Otherwise lens_index is not used.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">void NodePath::set_tex_projector(TextureStage *stage, NodePath const &amp;from, NodePath const &amp;to, int lens_index = 0);</span>

<span class="s0">2594 19 clear_tex_projector 0 4 3648 29 NodePath::clear_tex_projector 0 2 828 829 155</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the TexProjectorEffect for the indicated stage from this node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the TexProjectorEffect for all stages from this node.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">void NodePath::clear_tex_projector(TextureStage *stage);</span>
<span class="s0">void NodePath::clear_tex_projector(void);</span>

<span class="s0">2595 17 has_tex_projector 0 4 3648 27 NodePath::has_tex_projector 0 1 830 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this node has a TexProjectorEffect for the indicated stage,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool NodePath::has_tex_projector(TextureStage *stage) const;</span>

<span class="s0">2596 22 get_tex_projector_from 0 4 3648 32 NodePath::get_tex_projector_from 0 1 831 227</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;from&quot; node associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  The relative transform between the &quot;from&quot; and the &quot;to&quot;</span>
 <span class="s0">* nodes is automatically applied to the texture transform each frame.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">NodePath NodePath::get_tex_projector_from(TextureStage *stage) const;</span>

<span class="s0">2597 20 get_tex_projector_to 0 4 3648 30 NodePath::get_tex_projector_to 0 1 832 225</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;to&quot; node associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  The relative transform between the &quot;from&quot; and the &quot;to&quot;</span>
 <span class="s0">* nodes is automatically applied to the texture transform each frame.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">NodePath NodePath::get_tex_projector_to(TextureStage *stage) const;</span>

<span class="s0">2598 15 project_texture 0 4 3648 25 NodePath::project_texture 0 1 833 181</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to enable projective texturing at this node level</span>
 <span class="s0">* and below, using the indicated NodePath (which should contain a LensNode)</span>
 <span class="s0">* as the projector.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">void NodePath::project_texture(TextureStage *stage, Texture *tex, NodePath const &amp;projector);</span>

<span class="s0">2599 21 clear_project_texture 0 4 3648 31 NodePath::clear_project_texture 0 1 834 50</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of project_texture().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void NodePath::clear_project_texture(TextureStage *stage);</span>

<span class="s0">2600 12 has_texcoord 0 4 3648 22 NodePath::has_texcoord 0 1 835 211</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there are at least some vertices at this node and below</span>
 <span class="s0">* that use the named texture coordinate set, false otherwise.  Pass the empty</span>
 <span class="s0">* string for the default texture coordinate set.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline bool NodePath::has_texcoord(std::string const &amp;texcoord_name) const;</span>

<span class="s0">2601 17 has_vertex_column 0 4 3648 27 NodePath::has_vertex_column 0 1 836 309</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there are at least some vertices at this node and below</span>
 <span class="s0">* that contain a reference to the indicated vertex data column name, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is particularly useful for testing whether a particular model has a</span>
 <span class="s0">* given texture coordinate set (but see has_texcoord()).</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool NodePath::has_vertex_column(InternalName const *name) const;</span>

<span class="s0">2602 23 find_all_vertex_columns 0 4 3648 33 NodePath::find_all_vertex_columns 0 2 837 838 307</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a list of all vertex array columns stored on some geometry found at</span>
 <span class="s0">* this node level and below.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a list of all vertex array columns stored on some geometry found at</span>
 <span class="s0">* this node level and below that match the indicated name (which may contain</span>
 <span class="s0">* wildcard characters).</span>
 <span class="s0">*/</span>
<span class="s0">158</span>
<span class="s0">InternalNameCollection NodePath::find_all_vertex_columns(void) const;</span>
<span class="s0">InternalNameCollection NodePath::find_all_vertex_columns(std::string const &amp;name) const;</span>

<span class="s0">2603 18 find_all_texcoords 0 4 3648 28 NodePath::find_all_texcoords 0 2 839 840 295</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a list of all texture coordinate sets used by any geometry at this</span>
 <span class="s0">* node level and below.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a list of all texture coordinate sets used by any geometry at this</span>
 <span class="s0">* node level and below that match the indicated name (which may contain</span>
 <span class="s0">* wildcard characters).</span>
 <span class="s0">*/</span>
<span class="s0">148</span>
<span class="s0">InternalNameCollection NodePath::find_all_texcoords(void) const;</span>
<span class="s0">InternalNameCollection NodePath::find_all_texcoords(std::string const &amp;name) const;</span>

<span class="s0">2604 12 find_texture 0 4 3648 22 NodePath::find_texture 0 2 841 842 412</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first texture found applied to geometry at this node or below</span>
 <span class="s0">* that matches the indicated name (which may contain wildcards).  Returns the</span>
 <span class="s0">* texture if it is found, or NULL if it is not.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the first texture found applied to geometry at this node or below</span>
 <span class="s0">* that is assigned to the indicated texture stage.  Returns the texture if it</span>
 <span class="s0">* is found, or NULL if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">Texture *NodePath::find_texture(std::string const &amp;name) const;</span>
<span class="s0">Texture *NodePath::find_texture(TextureStage *stage) const;</span>

<span class="s0">2605 17 find_all_textures 0 4 3648 27 NodePath::find_all_textures 0 3 843 844 845 370</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a list of a textures applied to geometry at this node and below.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a list of a textures applied to geometry at this node and below</span>
 <span class="s0">* that match the indicated name (which may contain wildcard characters).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a list of a textures on geometry at this node and below that are</span>
 <span class="s0">* assigned to the indicated texture stage.</span>
 <span class="s0">*/</span>
<span class="s0">210</span>
<span class="s0">TextureCollection NodePath::find_all_textures(void) const;</span>
<span class="s0">TextureCollection NodePath::find_all_textures(std::string const &amp;name) const;</span>
<span class="s0">TextureCollection NodePath::find_all_textures(TextureStage *stage) const;</span>

<span class="s0">2606 18 find_texture_stage 0 4 3648 28 NodePath::find_texture_stage 0 1 846 221</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first TextureStage found applied to geometry at this node or</span>
 <span class="s0">* below that matches the indicated name (which may contain wildcards).</span>
 <span class="s0">* Returns the TextureStage if it is found, or NULL if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">TextureStage *NodePath::find_texture_stage(std::string const &amp;name) const;</span>

<span class="s0">2607 23 find_all_texture_stages 0 4 3648 33 NodePath::find_all_texture_stages 0 2 847 848 257</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a list of a TextureStages applied to geometry at this node and</span>
 <span class="s0">* below.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a list of a TextureStages applied to geometry at this node and</span>
 <span class="s0">* below that match the indicated name (which may contain wildcard</span>
 <span class="s0">* characters).</span>
 <span class="s0">*/</span>
<span class="s0">158</span>
<span class="s0">TextureStageCollection NodePath::find_all_texture_stages(void) const;</span>
<span class="s0">TextureStageCollection NodePath::find_all_texture_stages(std::string const &amp;name) const;</span>

<span class="s0">2608 20 unify_texture_stages 0 4 3648 30 NodePath::unify_texture_stages 0 1 849 323</span>
<span class="s0">/**</span>
 <span class="s0">* Searches through all TextureStages at this node and below.  Any</span>
 <span class="s0">* TextureStages that share the same name as the indicated TextureStage object</span>
 <span class="s0">* are replaced with this object, thus ensuring that all geometry at this node</span>
 <span class="s0">* and below with a particular TextureStage name is using the same</span>
 <span class="s0">* TextureStage object.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void NodePath::unify_texture_stages(TextureStage *stage);</span>

<span class="s0">2609 13 find_material 0 4 3648 23 NodePath::find_material 0 1 850 214</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first material found applied to geometry at this node or below</span>
 <span class="s0">* that matches the indicated name (which may contain wildcards).  Returns the</span>
 <span class="s0">* material if it is found, or NULL if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">Material *NodePath::find_material(std::string const &amp;name) const;</span>

<span class="s0">2610 18 find_all_materials 0 4 3648 28 NodePath::find_all_materials 0 2 851 852 243</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a list of a materials applied to geometry at this node and below.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a list of a materials applied to geometry at this node and below</span>
 <span class="s0">* that match the indicated name (which may contain wildcard characters).</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">MaterialCollection NodePath::find_all_materials(void) const;</span>
<span class="s0">MaterialCollection NodePath::find_all_materials(std::string const &amp;name) const;</span>

<span class="s0">2611 12 set_material 0 4 3648 22 NodePath::set_material 0 1 853 216</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using the indicated</span>
 <span class="s0">* material.</span>
 <span class="s0">*</span>
 <span class="s0">* Previously, this operation made a copy of the material structure, but</span>
 <span class="s0">* nowadays it assigns the pointer directly.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void NodePath::set_material(Material *tex, int priority = 0);</span>

<span class="s0">2612 16 set_material_off 0 4 3648 26 NodePath::set_material_off 0 1 854 275</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no material.</span>
 <span class="s0">* This is normally the default, but it may be useful to use this to</span>
 <span class="s0">* contradict set_material() at a higher node level (or, with a priority, to</span>
 <span class="s0">* override a set_material() at a lower level).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void NodePath::set_material_off(int priority = 0);</span>

<span class="s0">2613 14 clear_material 0 4 3648 24 NodePath::clear_material 0 1 855 125</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any material adjustment that may have been set via</span>
 <span class="s0">* set_material() from this particular node.</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void NodePath::clear_material(void);</span>

<span class="s0">2614 12 has_material 0 4 3648 22 NodePath::has_material 0 1 856 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a material has been applied to this particular node via</span>
 <span class="s0">* set_material(), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">bool NodePath::has_material(void) const;</span>

<span class="s0">2615 12 get_material 0 4 3648 22 NodePath::get_material 0 1 857 312</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the material that has been set on this particular node, or NULL if</span>
 <span class="s0">* no material has been set.  This is not necessarily the material that will</span>
 <span class="s0">* be applied to the geometry at or below this level, as another material at a</span>
 <span class="s0">* higher or lower level may override.</span>
 <span class="s0">*</span>
 <span class="s0">* See also find_material().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">PointerTo&lt; Material &gt; NodePath::get_material(void) const;</span>

<span class="s0">2616 16 replace_material 0 4 3648 26 NodePath::replace_material 0 2 858 859 270</span>
<span class="s0">// Let interrogate know this also accepts None</span>

<span class="s0">/**</span>
 <span class="s0">* Recursively searches the scene graph for references to the given material,</span>
 <span class="s0">* and replaces them with the new material.</span>
 <span class="s0">*</span>
 <span class="s0">* As of Panda3D 1.10.13, new_mat may be null to remove the material.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">138</span>
<span class="s0">void NodePath::replace_material(Material *mat, Material *new_mat);</span>
<span class="s0">void NodePath::replace_material(Material *mat, std::nullptr_t new_mat);</span>

<span class="s0">2617 7 set_fog 0 4 3648 17 NodePath::set_fog 0 1 860 90</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using the indicated</span>
 <span class="s0">* fog.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void NodePath::set_fog(Fog *fog, int priority = 0);</span>

<span class="s0">2618 11 set_fog_off 0 4 3648 21 NodePath::set_fog_off 0 1 861 261</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no fog.  This is</span>
 <span class="s0">* normally the default, but it may be useful to use this to contradict</span>
 <span class="s0">* set_fog() at a higher node level (or, with a priority, to override a</span>
 <span class="s0">* set_fog() at a lower level).</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void NodePath::set_fog_off(int priority = 0);</span>

<span class="s0">2619 9 clear_fog 0 4 3648 19 NodePath::clear_fog 0 1 862 221</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any fog adjustment that may have been set via set_fog()</span>
 <span class="s0">* or set_fog_off() from this particular node.  This allows whatever fogs</span>
 <span class="s0">* might be otherwise affecting the geometry to show instead.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void NodePath::clear_fog(void);</span>

<span class="s0">2620 7 has_fog 0 4 3648 17 NodePath::has_fog 0 1 863 275</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a fog has been applied to this particular node via</span>
 <span class="s0">* set_fog(), false otherwise.  This is not the same thing as asking whether</span>
 <span class="s0">* the geometry at this node will be rendered with fog, as there may be a fog</span>
 <span class="s0">* in effect from a higher or lower level.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">bool NodePath::has_fog(void) const;</span>

<span class="s0">2621 11 has_fog_off 0 4 3648 21 NodePath::has_fog_off 0 1 864 293</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a fog has been specifically disabled on this particular</span>
 <span class="s0">* node via set_fog_off(), false otherwise.  This is not the same thing as</span>
 <span class="s0">* asking whether the geometry at this node will be rendered unfogged, as</span>
 <span class="s0">* there may be a fog in effect from a higher or lower level.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">bool NodePath::has_fog_off(void) const;</span>

<span class="s0">2622 7 get_fog 0 4 3648 17 NodePath::get_fog 0 1 865 260</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the fog that has been set on this particular node, or NULL if no</span>
 <span class="s0">* fog has been set.  This is not necessarily the fog that will be applied to</span>
 <span class="s0">* the geometry at or below this level, as another fog at a higher or lower</span>
 <span class="s0">* level may override.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">Fog *NodePath::get_fog(void) const;</span>

<span class="s0">2623 25 set_render_mode_wireframe 0 4 3648 35 NodePath::set_render_mode_wireframe 0 1 866 107</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the geometry at this level and below (unless overridden) to render</span>
 <span class="s0">* in wireframe mode.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void NodePath::set_render_mode_wireframe(int priority = 0);</span>

<span class="s0">2624 22 set_render_mode_filled 0 4 3648 32 NodePath::set_render_mode_filled 0 1 867 126</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the geometry at this level and below (unless overridden) to render</span>
 <span class="s0">* in filled (i.e.  not wireframe) mode.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void NodePath::set_render_mode_filled(int priority = 0);</span>

<span class="s0">2625 32 set_render_mode_filled_wireframe 0 4 3648 42 NodePath::set_render_mode_filled_wireframe 0 1 868 197</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the geometry at this level and below (unless overridden) to render</span>
 <span class="s0">* in filled, but overlay the wireframe on top with a fixed color.  This is</span>
 <span class="s0">* useful for debug visualizations.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">void NodePath::set_render_mode_filled_wireframe(LColor const &amp;wireframe_color, int priority = 0);</span>

<span class="s0">2626 25 set_render_mode_thickness 0 4 3648 35 NodePath::set_render_mode_thickness 0 1 869 359</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the point geometry at this level and below to render as thick</span>
 <span class="s0">* points (that is, billboarded quads).  The thickness is in pixels, unless</span>
 <span class="s0">* set_render_mode_perspective is also true, in which case it is in 3-D units.</span>
 <span class="s0">*</span>
 <span class="s0">* If you want the quads to be individually textured, you should also set a</span>
 <span class="s0">* TexGenAttrib::M_point_sprite on the node.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void NodePath::set_render_mode_thickness(PN_stdfloat thickness, int priority = 0);</span>

<span class="s0">2627 27 set_render_mode_perspective 0 4 3648 37 NodePath::set_render_mode_perspective 0 1 870 461</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the point geometry at this level and below to render as perspective</span>
 <span class="s0">* sprites (that is, billboarded quads).  The thickness, as specified with</span>
 <span class="s0">* set_render_mode_thickness(), is the width of each point in 3-D units,</span>
 <span class="s0">* unless it is overridden on a per-vertex basis.  This does not affect</span>
 <span class="s0">* geometry other than points.</span>
 <span class="s0">*</span>
 <span class="s0">* If you want the quads to be individually textured, you should also set a</span>
 <span class="s0">* TexGenAttrib::M_point_sprite on the node.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void NodePath::set_render_mode_perspective(bool perspective, int priority = 0);</span>

<span class="s0">2628 15 set_render_mode 0 4 3648 25 NodePath::set_render_mode 0 1 871 162</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the geometry at this level and below (unless overridden) to render</span>
 <span class="s0">* in the specified mode and with the indicated line and/or point thickness.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">void NodePath::set_render_mode(RenderModeAttrib::Mode mode, PN_stdfloat thickness, int priority = 0);</span>

<span class="s0">2629 17 clear_render_mode 0 4 3648 27 NodePath::clear_render_mode 0 1 872 156</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any render mode adjustment that may have been set on</span>
 <span class="s0">* this node via set_render_mode_wireframe() or set_render_mode_filled().</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void NodePath::clear_render_mode(void);</span>

<span class="s0">2630 15 has_render_mode 0 4 3648 25 NodePath::has_render_mode 0 1 873 195</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a render mode has been explicitly set on this particular</span>
 <span class="s0">* node via set_render_mode() (or set_render_mode_wireframe() or</span>
 <span class="s0">* set_render_mode_filled()), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">bool NodePath::has_render_mode(void) const;</span>

<span class="s0">2631 15 get_render_mode 0 4 3648 25 NodePath::get_render_mode 0 1 874 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the render mode that has been specifically set on this node via</span>
 <span class="s0">* set_render_mode(), or M_unchanged if nothing has been set.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">RenderModeAttrib::Mode NodePath::get_render_mode(void) const;</span>

<span class="s0">2632 25 get_render_mode_thickness 0 4 3648 35 NodePath::get_render_mode_thickness 0 1 875 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the render mode thickness that has been specifically set on this</span>
 <span class="s0">* node via set_render_mode(), or 1.0 if nothing has been set.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">PN_stdfloat NodePath::get_render_mode_thickness(void) const;</span>

<span class="s0">2633 27 get_render_mode_perspective 0 4 3648 37 NodePath::get_render_mode_perspective 0 1 876 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that has been set on this node via</span>
 <span class="s0">* set_render_mode_perspective(), or false if no flag has been set.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool NodePath::get_render_mode_perspective(void) const;</span>

<span class="s0">2634 13 set_two_sided 0 4 3648 23 NodePath::set_two_sided 0 1 877 237</span>
<span class="s0">/**</span>
 <span class="s0">* Specifically sets or disables two-sided rendering mode on this particular</span>
 <span class="s0">* node.  If no other nodes override, this will cause backfacing polygons to</span>
 <span class="s0">* be drawn (in two-sided mode, true) or culled (in one-sided mode, false).</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void NodePath::set_two_sided(bool two_sided, int priority = 0);</span>

<span class="s0">2635 15 clear_two_sided 0 4 3648 25 NodePath::clear_two_sided 0 1 878 336</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any two-sided adjustment that may have been set on this</span>
 <span class="s0">* node via set_two_sided(). The geometry at this level and below will</span>
 <span class="s0">* subsequently be rendered either two-sided or one-sided, according to</span>
 <span class="s0">* whatever other nodes may have had set_two_sided() on it, or according to</span>
 <span class="s0">* the initial state otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void NodePath::clear_two_sided(void);</span>

<span class="s0">2636 13 has_two_sided 0 4 3648 23 NodePath::has_two_sided 0 1 879 215</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a two-sided adjustment has been explicitly set on this</span>
 <span class="s0">* particular node via set_two_sided().  If this returns true, then</span>
 <span class="s0">* get_two_sided() may be called to determine which has been set.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">bool NodePath::has_two_sided(void) const;</span>

<span class="s0">2637 13 get_two_sided 0 4 3648 23 NodePath::get_two_sided 0 1 880 378</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if two-sided rendering has been specifically set on this node</span>
 <span class="s0">* via set_two_sided(), or false if one-sided rendering has been specifically</span>
 <span class="s0">* set, or if nothing has been specifically set.  See also has_two_sided().</span>
 <span class="s0">* This does not necessarily imply that the geometry will or will not be</span>
 <span class="s0">* rendered two-sided, as there may be other nodes that override.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">bool NodePath::get_two_sided(void) const;</span>

<span class="s0">2638 14 set_depth_test 0 4 3648 24 NodePath::set_depth_test 0 1 881 236</span>
<span class="s0">/**</span>
 <span class="s0">* Specifically sets or disables the testing of the depth buffer on this</span>
 <span class="s0">* particular node.  This is normally on in the 3-d scene graph and off in the</span>
 <span class="s0">* 2-d scene graph; it should be on for rendering most 3-d objects properly.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">void NodePath::set_depth_test(bool depth_test, int priority = 0);</span>

<span class="s0">2639 16 clear_depth_test 0 4 3648 26 NodePath::clear_depth_test 0 1 882 116</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any depth-test adjustment that may have been set on this</span>
 <span class="s0">* node via set_depth_test().</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void NodePath::clear_depth_test(void);</span>

<span class="s0">2640 14 has_depth_test 0 4 3648 24 NodePath::has_depth_test 0 1 883 218</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a depth-test adjustment has been explicitly set on this</span>
 <span class="s0">* particular node via set_depth_test().  If this returns true, then</span>
 <span class="s0">* get_depth_test() may be called to determine which has been set.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">bool NodePath::has_depth_test(void) const;</span>

<span class="s0">2641 14 get_depth_test 0 4 3648 24 NodePath::get_depth_test 0 1 884 262</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if depth-test rendering has been specifically set on this node</span>
 <span class="s0">* via set_depth_test(), or false if depth-test rendering has been</span>
 <span class="s0">* specifically disabled.  If nothing has been specifically set, returns true.</span>
 <span class="s0">* See also has_depth_test().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">bool NodePath::get_depth_test(void) const;</span>

<span class="s0">2642 15 set_depth_write 0 4 3648 25 NodePath::set_depth_write 0 1 885 236</span>
<span class="s0">/**</span>
 <span class="s0">* Specifically sets or disables the writing to the depth buffer on this</span>
 <span class="s0">* particular node.  This is normally on in the 3-d scene graph and off in the</span>
 <span class="s0">* 2-d scene graph; it should be on for rendering most 3-d objects properly.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void NodePath::set_depth_write(bool depth_write, int priority = 0);</span>

<span class="s0">2643 17 clear_depth_write 0 4 3648 27 NodePath::clear_depth_write 0 1 886 118</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any depth-write adjustment that may have been set on</span>
 <span class="s0">* this node via set_depth_write().</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void NodePath::clear_depth_write(void);</span>

<span class="s0">2644 15 has_depth_write 0 4 3648 25 NodePath::has_depth_write 0 1 887 221</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a depth-write adjustment has been explicitly set on this</span>
 <span class="s0">* particular node via set_depth_write().  If this returns true, then</span>
 <span class="s0">* get_depth_write() may be called to determine which has been set.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">bool NodePath::has_depth_write(void) const;</span>

<span class="s0">2645 15 get_depth_write 0 4 3648 25 NodePath::get_depth_write 0 1 888 266</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if depth-write rendering has been specifically set on this</span>
 <span class="s0">* node via set_depth_write(), or false if depth-write rendering has been</span>
 <span class="s0">* specifically disabled.  If nothing has been specifically set, returns true.</span>
 <span class="s0">* See also has_depth_write().</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">bool NodePath::get_depth_write(void) const;</span>

<span class="s0">2646 16 set_depth_offset 0 4 3648 26 NodePath::set_depth_offset 0 1 889 542</span>
<span class="s0">/**</span>
 <span class="s0">* This instructs the graphics driver to apply an offset or bias to the</span>
 <span class="s0">* generated depth values for rendered polygons, before they are written to</span>
 <span class="s0">* the depth buffer.  This can be used to shift polygons forward slightly, to</span>
 <span class="s0">* resolve depth conflicts, or self-shadowing artifacts on thin objects.  The</span>
 <span class="s0">* bias is always an integer number, and each integer increment represents the</span>
 <span class="s0">* smallest possible increment in Z that is sufficient to completely resolve</span>
 <span class="s0">* two coplanar polygons.  Positive numbers are closer towards the camera.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void NodePath::set_depth_offset(int bias, int priority = 0);</span>

<span class="s0">2647 18 clear_depth_offset 0 4 3648 28 NodePath::clear_depth_offset 0 1 890 120</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any depth-offset adjustment that may have been set on</span>
 <span class="s0">* this node via set_depth_offset().</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void NodePath::clear_depth_offset(void);</span>

<span class="s0">2648 16 has_depth_offset 0 4 3648 26 NodePath::has_depth_offset 0 1 891 224</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a depth-offset adjustment has been explicitly set on this</span>
 <span class="s0">* particular node via set_depth_offset().  If this returns true, then</span>
 <span class="s0">* get_depth_offset() may be called to determine which has been set.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">bool NodePath::has_depth_offset(void) const;</span>

<span class="s0">2649 16 get_depth_offset 0 4 3648 26 NodePath::get_depth_offset 0 1 892 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the depth offset value if it has been specified using</span>
 <span class="s0">* set_depth_offset, or 0 if not.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">int NodePath::get_depth_offset(void) const;</span>

<span class="s0">2650 17 do_billboard_axis 0 4 3648 27 NodePath::do_billboard_axis 0 1 893 170</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a billboard-type rotate to the indicated camera node, one time</span>
 <span class="s0">* only, and leaves the object rotated.  This is similar in principle to</span>
 <span class="s0">* heads_up().</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">void NodePath::do_billboard_axis(NodePath const &amp;camera, PN_stdfloat offset);</span>

<span class="s0">2651 22 do_billboard_point_eye 0 4 3648 32 NodePath::do_billboard_point_eye 0 1 894 266</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a billboard-type rotate to the indicated camera node, one time</span>
 <span class="s0">* only, and leaves the object rotated.  This is similar in principle to</span>
 <span class="s0">* look_at(), although the point_eye billboard effect cannot be achieved using</span>
 <span class="s0">* the ordinary look_at() call.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void NodePath::do_billboard_point_eye(NodePath const &amp;camera, PN_stdfloat offset);</span>

<span class="s0">2652 24 do_billboard_point_world 0 4 3648 34 NodePath::do_billboard_point_world 0 1 895 169</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a billboard-type rotate to the indicated camera node, one time</span>
 <span class="s0">* only, and leaves the object rotated.  This is similar in principle to</span>
 <span class="s0">* look_at().</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">void NodePath::do_billboard_point_world(NodePath const &amp;camera, PN_stdfloat offset);</span>

<span class="s0">2653 18 set_billboard_axis 0 4 3648 28 NodePath::set_billboard_axis 0 2 896 897 300</span>
<span class="s0">/**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in two</span>
 <span class="s0">* dimensions around the up axis.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in two</span>
 <span class="s0">* dimensions around the up axis, towards a specified &quot;camera&quot; instead of to</span>
 <span class="s0">* the viewing camera.</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">inline void NodePath::set_billboard_axis(PN_stdfloat offset = 0.0);</span>
<span class="s0">void NodePath::set_billboard_axis(NodePath const &amp;camera, PN_stdfloat offset);</span>

<span class="s0">2654 23 set_billboard_point_eye 0 4 3648 33 NodePath::set_billboard_point_eye 0 2 898 899 417</span>
<span class="s0">/**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in three</span>
 <span class="s0">* dimensions about the origin, keeping its up vector oriented to the top of</span>
 <span class="s0">* the camera.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in three</span>
 <span class="s0">* dimensions about the origin, keeping its up vector oriented to the top of</span>
 <span class="s0">* the camera, towards a specified &quot;camera&quot; instead of to the viewing camera.</span>
 <span class="s0">*/</span>
<span class="s0">208</span>
<span class="s0">inline void NodePath::set_billboard_point_eye(PN_stdfloat offset = 0.0, bool fixed_depth = false);</span>
<span class="s0">void NodePath::set_billboard_point_eye(NodePath const &amp;camera, PN_stdfloat offset, bool fixed_depth = false);</span>

<span class="s0">2655 25 set_billboard_point_world 0 4 3648 35 NodePath::set_billboard_point_world 0 2 900 901 386</span>
<span class="s0">/**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in three</span>
 <span class="s0">* dimensions about the origin, keeping its up vector oriented to the sky.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in three</span>
 <span class="s0">* dimensions about the origin, keeping its up vector oriented to the sky,</span>
 <span class="s0">* towards a specified &quot;camera&quot; instead of to the viewing camera.</span>
 <span class="s0">*/</span>
<span class="s0">160</span>
<span class="s0">inline void NodePath::set_billboard_point_world(PN_stdfloat offset = 0.0);</span>
<span class="s0">void NodePath::set_billboard_point_world(NodePath const &amp;camera, PN_stdfloat offset);</span>

<span class="s0">2656 15 clear_billboard 0 4 3648 25 NodePath::clear_billboard 0 1 902 54</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any billboard effect from the node.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void NodePath::clear_billboard(void);</span>

<span class="s0">2657 13 has_billboard 0 4 3648 23 NodePath::has_billboard 0 1 903 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is any billboard effect on the node.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">bool NodePath::has_billboard(void) const;</span>

<span class="s0">2658 11 set_compass 0 4 3648 21 NodePath::set_compass 0 1 904 204</span>
<span class="s0">/**</span>
 <span class="s0">* Puts a compass effect on the node, so that it will retain a fixed rotation</span>
 <span class="s0">* relative to the reference node (or render if the reference node is empty)</span>
 <span class="s0">* regardless of the transforms above it.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void NodePath::set_compass(NodePath const &amp;reference = NodePath());</span>

<span class="s0">2659 13 clear_compass 0 4 3648 23 NodePath::clear_compass 0 1 905 52</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any compass effect from the node.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">void NodePath::clear_compass(void);</span>

<span class="s0">2660 11 has_compass 0 4 3648 21 NodePath::has_compass 0 1 906 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is any compass effect on the node.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">bool NodePath::has_compass(void) const;</span>

<span class="s0">2661 16 set_transparency 0 4 3648 26 NodePath::set_transparency 0 1 907 222</span>
<span class="s0">/**</span>
 <span class="s0">* Specifically sets or disables transparent rendering mode on this particular</span>
 <span class="s0">* node.  If no other nodes override, this will cause items with a non-1 value</span>
 <span class="s0">* for alpha color to be rendered partially transparent.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">void NodePath::set_transparency(TransparencyAttrib::Mode mode, int priority = 0);</span>

<span class="s0">2662 18 clear_transparency 0 4 3648 28 NodePath::clear_transparency 0 1 908 285</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any transparency adjustment that may have been set on</span>
 <span class="s0">* this node via set_transparency(). The geometry at this level and below will</span>
 <span class="s0">* subsequently be rendered either transparent or not, to whatever other nodes</span>
 <span class="s0">* may have had set_transparency() on them.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void NodePath::clear_transparency(void);</span>

<span class="s0">2663 16 has_transparency 0 4 3648 26 NodePath::has_transparency 0 1 909 303</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a transparent-rendering adjustment has been explicitly set</span>
 <span class="s0">* on this particular node via set_transparency().  If this returns true, then</span>
 <span class="s0">* get_transparency() may be called to determine whether transparency has been</span>
 <span class="s0">* explicitly enabled or explicitly disabled for this node.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">bool NodePath::has_transparency(void) const;</span>

<span class="s0">2664 16 get_transparency 0 4 3648 26 NodePath::get_transparency 0 1 910 399</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transparent rendering that has been specifically set on this</span>
 <span class="s0">* node via set_transparency(), or M_none if nontransparent rendering has been</span>
 <span class="s0">* specifically set, or if nothing has been specifically set.  See also</span>
 <span class="s0">* has_transparency().  This does not necessarily imply that the geometry will</span>
 <span class="s0">* or will not be rendered transparent, as there may be other nodes that</span>
 <span class="s0">* override.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">TransparencyAttrib::Mode NodePath::get_transparency(void) const;</span>

<span class="s0">2665 12 set_logic_op 0 4 3648 22 NodePath::set_logic_op 0 1 911 248</span>
<span class="s0">/**</span>
 <span class="s0">* Specifically sets or disables a logical operation on this particular node.</span>
 <span class="s0">* If no other nodes override, this will cause geometry to be rendered without</span>
 <span class="s0">* color blending but instead using the given logical operator.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void NodePath::set_logic_op(LogicOpAttrib::Operation op, int priority = 0);</span>

<span class="s0">2666 14 clear_logic_op 0 4 3648 24 NodePath::clear_logic_op 0 1 912 231</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any logical operation that may have been set on this</span>
 <span class="s0">* node via set_logic_op(). The geometry at this level and below will</span>
 <span class="s0">* subsequently be rendered using standard color blending.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void NodePath::clear_logic_op(void);</span>

<span class="s0">2667 12 has_logic_op 0 4 3648 22 NodePath::has_logic_op 0 1 913 316</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a logical operation has been explicitly set on this</span>
 <span class="s0">* particular node via set_logic_op().  If this returns true, then</span>
 <span class="s0">* get_logic_op() may be called to determine whether a logical operation has</span>
 <span class="s0">* been explicitly disabled for this node or set to particular operation.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">bool NodePath::has_logic_op(void) const;</span>

<span class="s0">2668 12 get_logic_op 0 4 3648 22 NodePath::get_logic_op 0 1 914 427</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the logical operation that has been specifically set on this node</span>
 <span class="s0">* via set_logic_op(), or O_none if standard color blending has been</span>
 <span class="s0">* specifically set, or if nothing has been specifically set.  See also</span>
 <span class="s0">* has_logic_op().  This does not necessarily imply that the geometry will</span>
 <span class="s0">* or will not be rendered with the given logical operation, as there may be</span>
 <span class="s0">* other nodes that override.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">LogicOpAttrib::Operation NodePath::get_logic_op(void) const;</span>

<span class="s0">2669 13 set_antialias 0 4 3648 23 NodePath::set_antialias 0 1 915 114</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the antialiasing type that should be applied at this node and</span>
 <span class="s0">* below.  See AntialiasAttrib.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void NodePath::set_antialias(unsigned short int mode, int priority = 0);</span>

<span class="s0">2670 15 clear_antialias 0 4 3648 25 NodePath::clear_antialias 0 1 916 111</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any antialias setting that may have been set on this</span>
 <span class="s0">* node via set_antialias().</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void NodePath::clear_antialias(void);</span>

<span class="s0">2671 13 has_antialias 0 4 3648 23 NodePath::has_antialias 0 1 917 216</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if an antialias setting has been explicitly mode on this</span>
 <span class="s0">* particular node via set_antialias().  If this returns true, then</span>
 <span class="s0">* get_antialias() may be called to determine what the setting was.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">bool NodePath::has_antialias(void) const;</span>

<span class="s0">2672 13 get_antialias 0 4 3648 23 NodePath::get_antialias 0 1 918 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the antialias setting that has been specifically set on this node</span>
 <span class="s0">* via set_antialias(), or M_none if no setting has been made.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">unsigned short int NodePath::get_antialias(void) const;</span>

<span class="s0">2673 16 has_audio_volume 0 4 3648 26 NodePath::has_audio_volume 0 1 919 197</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if an audio volume has been applied to the referenced node,</span>
 <span class="s0">* false otherwise.  It is still possible that volume at this node might have</span>
 <span class="s0">* been scaled by an ancestor node.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">bool NodePath::has_audio_volume(void) const;</span>

<span class="s0">2674 18 clear_audio_volume 0 4 3648 28 NodePath::clear_audio_volume 0 1 920 225</span>
<span class="s0">/**</span>
 <span class="s0">* Completely removes any audio volume from the referenced node.  This is</span>
 <span class="s0">* preferable to simply setting the audio volume to identity, as it also</span>
 <span class="s0">* removes the overhead associated with having an audio volume at all.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void NodePath::clear_audio_volume(void);</span>

<span class="s0">2675 16 set_audio_volume 0 4 3648 26 NodePath::set_audio_volume 0 1 921 59</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the audio volume component of the transform</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void NodePath::set_audio_volume(PN_stdfloat volume, int priority = 0);</span>

<span class="s0">2676 20 set_audio_volume_off 0 4 3648 30 NodePath::set_audio_volume_off 0 1 922 447</span>
<span class="s0">/**</span>
 <span class="s0">* Disables any audio volume attribute inherited from above.  This is not the</span>
 <span class="s0">* same thing as clear_audio_volume(), which undoes any previous</span>
 <span class="s0">* set_audio_volume() operation on this node; rather, this actively disables</span>
 <span class="s0">* any set_audio_volume() that might be inherited from a parent node.</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal to specify a new volume on the same node with a subsequent call</span>
 <span class="s0">* to set_audio_volume(); this new scale will apply to lower nodes.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void NodePath::set_audio_volume_off(int priority = 0);</span>

<span class="s0">2677 16 get_audio_volume 0 4 3648 26 NodePath::get_audio_volume 0 1 923 200</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete audio volume that has been applied to this node via a</span>
 <span class="s0">* previous call to set_audio_volume(), or 1. (identity) if no volume has been</span>
 <span class="s0">* applied to this particular node.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">PN_stdfloat NodePath::get_audio_volume(void) const;</span>

<span class="s0">2678 20 get_net_audio_volume 0 4 3648 30 NodePath::get_net_audio_volume 0 1 924 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the complete audio volume for this node taking highers nodes in the</span>
 <span class="s0">* graph into account.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">PN_stdfloat NodePath::get_net_audio_volume(void) const;</span>

<span class="s0">2679 21 adjust_all_priorities 0 4 3648 31 NodePath::adjust_all_priorities 0 1 925 339</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated adjustment amount (which may be negative) to the</span>
 <span class="s0">* priority for all transitions on the referenced node, and for all nodes in</span>
 <span class="s0">* the subgraph below.  This can be used to force these nodes not to be</span>
 <span class="s0">* overridden by a high-level state change above.  If the priority would drop</span>
 <span class="s0">* below zero, it is set to zero.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void NodePath::adjust_all_priorities(int adjustment);</span>

<span class="s0">2680 4 show 0 4 3648 14 NodePath::show 0 2 926 927 524</span>
<span class="s0">// Variants on show and hide</span>

<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of a previous hide() on this node: makes the referenced</span>
 <span class="s0">* node (and the entire subgraph below this node) visible to all cameras.</span>
 <span class="s0">*</span>
 <span class="s0">* This will not reveal the node if a parent node has been hidden.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Makes the referenced node visible just to the cameras whose camera_mask</span>
 <span class="s0">* shares the indicated bits.</span>
 <span class="s0">*</span>
 <span class="s0">* This undoes the effect of a previous hide() call.  It will not reveal the</span>
 <span class="s0">* node if a parent node has been hidden.  However, see show_through().</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void NodePath::show(void);</span>
<span class="s0">inline void NodePath::show(DrawMask camera_mask);</span>

<span class="s0">2681 12 show_through 0 4 3648 22 NodePath::show_through 0 2 928 929 635</span>
<span class="s0">/**</span>
 <span class="s0">* Makes the referenced node visible just to the cameras whose camera_mask</span>
 <span class="s0">* shares the indicated bits.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike show(), this will reveal the node even if a parent node has been</span>
 <span class="s0">* hidden, thus &quot;showing through&quot; a parent's hide().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Makes the referenced node visible just to the cameras whose camera_mask</span>
 <span class="s0">* shares the indicated bits.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike show(), this will reveal the node even if a parent node has been</span>
 <span class="s0">* hidden via the one-parameter hide() method, thus &quot;showing through&quot; a</span>
 <span class="s0">* parent's hide().  (However, it will not show through a parent's hide() call</span>
 <span class="s0">* if the no-parameter form of hide() was used.)</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">inline void NodePath::show_through(void);</span>
<span class="s0">inline void NodePath::show_through(DrawMask camera_mask);</span>

<span class="s0">2682 4 hide 0 4 3648 14 NodePath::hide 0 2 930 931 634</span>
<span class="s0">/**</span>
 <span class="s0">* Makes the referenced node (and the entire subgraph below this node)</span>
 <span class="s0">* invisible to all cameras.  It remains part of the scene graph, its bounding</span>
 <span class="s0">* volume still contributes to its parent's bounding volume, and it will still</span>
 <span class="s0">* be involved in collision tests.</span>
 <span class="s0">*</span>
 <span class="s0">* To undo this, call show().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Makes the referenced node invisible just to the cameras whose camera_mask</span>
 <span class="s0">* shares the indicated bits.</span>
 <span class="s0">*</span>
 <span class="s0">* This will also hide any nodes below this node in the scene graph, including</span>
 <span class="s0">* those nodes for which show() has been called, but it will not hide</span>
 <span class="s0">* descendent nodes for which show_through() has been called.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void NodePath::hide(void);</span>
<span class="s0">inline void NodePath::hide(DrawMask camera_mask);</span>

<span class="s0">2683 9 is_hidden 0 4 3648 19 NodePath::is_hidden 0 1 932 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the referenced node is hidden from the indicated camera(s)</span>
 <span class="s0">* either directly, or because some ancestor is hidden.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline bool NodePath::is_hidden(DrawMask camera_mask = PandaNode::get_overall_bit()) const;</span>

<span class="s0">2684 19 get_hidden_ancestor 0 4 3648 29 NodePath::get_hidden_ancestor 0 1 933 215</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath at or above the referenced node that is hidden to the</span>
 <span class="s0">* indicated camera(s), or an empty NodePath if no ancestor of the referenced</span>
 <span class="s0">* node is hidden (and the node should be visible).</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">NodePath NodePath::get_hidden_ancestor(DrawMask camera_mask = PandaNode::get_overall_bit(), Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2685 5 stash 0 4 3648 15 NodePath::stash 0 1 934 480</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the referenced node (and the entire subgraph below this node) from</span>
 <span class="s0">* the scene graph in any normal sense.  The node will no longer be visible</span>
 <span class="s0">* and is not tested for collisions; furthermore, no normal scene graph</span>
 <span class="s0">* traversal will visit the node.  The node's bounding volume no longer</span>
 <span class="s0">* contributes to its parent's bounding volume.</span>
 <span class="s0">*</span>
 <span class="s0">* A stashed node cannot be located by a normal find() operation (although a</span>
 <span class="s0">* special find string can still retrieve it).</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">void NodePath::stash(int sort = 0, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2686 7 unstash 0 4 3648 17 NodePath::unstash 0 1 935 174</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of a previous stash() on this node: makes the referenced</span>
 <span class="s0">* node (and the entire subgraph below this node) once again part of the scene</span>
 <span class="s0">* graph.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">void NodePath::unstash(int sort = 0, Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2687 11 unstash_all 0 4 3648 21 NodePath::unstash_all 0 1 936 59</span>
<span class="s0">/**</span>
 <span class="s0">* Unstashes this node and all stashed child nodes.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void NodePath::unstash_all(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2688 10 is_stashed 0 4 3648 20 NodePath::is_stashed 0 1 937 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the referenced node is stashed either directly, or because</span>
 <span class="s0">* some ancestor is stashed.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool NodePath::is_stashed(void) const;</span>

<span class="s0">2689 20 get_stashed_ancestor 0 4 3648 30 NodePath::get_stashed_ancestor 0 1 938 190</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath at or above the referenced node that is stashed, or an</span>
 <span class="s0">* empty NodePath if no ancestor of the referenced node is stashed (and the</span>
 <span class="s0">* node should be visible).</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">NodePath NodePath::get_stashed_ancestor(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2690 16 get_collide_mask 0 4 3648 26 NodePath::get_collide_mask 0 1 939 309</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of all of the into_collide_masks for nodes at this level</span>
 <span class="s0">* and below.  This is the same thing as node()-&gt;get_net_collide_mask().</span>
 <span class="s0">*</span>
 <span class="s0">* If you want to return what the into_collide_mask of this node itself is,</span>
 <span class="s0">* without regard to its children, use node()-&gt;get_into_collide_mask().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline CollideMask NodePath::get_collide_mask(void) const;</span>

<span class="s0">2691 16 set_collide_mask 0 4 3648 26 NodePath::set_collide_mask 0 1 940 489</span>
<span class="s0">/**</span>
 <span class="s0">* Recursively applies the indicated CollideMask to the into_collide_masks for</span>
 <span class="s0">* all nodes at this level and below.  If node_type is not TypeHandle::none(),</span>
 <span class="s0">* then only nodes matching (or inheriting from) the indicated PandaNode</span>
 <span class="s0">* subclass are modified.</span>
 <span class="s0">*</span>
 <span class="s0">* The default is to change all bits, but if bits_to_change is not all bits</span>
 <span class="s0">* on, then only the bits that are set in bits_to_change are modified,</span>
 <span class="s0">* allowing this call to change only a subset of the bits in the subgraph.</span>
 <span class="s0">*/</span>
<span class="s0">156</span>
<span class="s0">inline void NodePath::set_collide_mask(CollideMask new_mask, CollideMask bits_to_change = CollideMask::all_on(), TypeHandle node_type = TypeHandle::none());</span>

<span class="s0">2692 11 operator == 0 4 3648 21 NodePath::operator == 0 2 941 942 21</span>
<span class="s0">// Comparison methods</span>
<span class="s0">124</span>
<span class="s0">inline bool NodePath::operator ==(NodePath const &amp;other) const;</span>
<span class="s0">bool NodePath::operator ==(WeakNodePath const &amp;other) const;</span>

<span class="s0">2693 11 operator != 0 4 3648 21 NodePath::operator != 0 2 943 944 0</span>
<span class="s0">124</span>
<span class="s0">inline bool NodePath::operator !=(NodePath const &amp;other) const;</span>
<span class="s0">bool NodePath::operator !=(WeakNodePath const &amp;other) const;</span>

<span class="s0">2694 10 operator &lt; 0 4 3648 20 NodePath::operator &lt; 0 2 945 946 0</span>
<span class="s0">122</span>
<span class="s0">inline bool NodePath::operator &lt;(NodePath const &amp;other) const;</span>
<span class="s0">bool NodePath::operator &lt;(WeakNodePath const &amp;other) const;</span>

<span class="s0">2695 10 compare_to 0 4 3648 20 NodePath::compare_to 0 2 947 948 974</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this NodePath sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two NodePaths are considered equivalent if they consist of exactly the same</span>
 <span class="s0">* list of nodes in the same order.  Otherwise, they are different; different</span>
 <span class="s0">* NodePaths will be ranked in a consistent but undefined ordering; the</span>
 <span class="s0">* ordering is useful only for placing the NodePaths in a sorted container</span>
 <span class="s0">* like an STL set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this NodePath sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two NodePaths are considered equivalent if they consist of exactly the same</span>
 <span class="s0">* list of nodes in the same order.  Otherwise, they are different; different</span>
 <span class="s0">* NodePaths will be ranked in a consistent but undefined ordering; the</span>
 <span class="s0">* ordering is useful only for placing the NodePaths in a sorted container</span>
 <span class="s0">* like an STL set.</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">inline int NodePath::compare_to(NodePath const &amp;other) const;</span>
<span class="s0">int NodePath::compare_to(WeakNodePath const &amp;other) const;</span>

<span class="s0">2696 15 verify_complete 0 4 3648 25 NodePath::verify_complete 0 1 949 125</span>
<span class="s0">// Miscellaneous</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if all of the nodes described in the NodePath are connected,</span>
 <span class="s0">* or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">bool NodePath::verify_complete(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2697 14 premunge_scene 0 4 3648 24 NodePath::premunge_scene 0 1 950 414</span>
<span class="s0">/**</span>
 <span class="s0">* Walks through the scene graph beginning at the bottom node, and internally</span>
 <span class="s0">* adjusts any GeomVertexFormats for optimal rendering on the indicated GSG.</span>
 <span class="s0">* If this step is not done prior to rendering, the formats will be optimized</span>
 <span class="s0">* at render time instead, for a small cost.</span>
 <span class="s0">*</span>
 <span class="s0">* It is not normally necessary to do this on a model loaded directly from</span>
 <span class="s0">* disk, since the loader will do this by default.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void NodePath::premunge_scene(GraphicsStateGuardianBase *gsg = nullptr);</span>

<span class="s0">2698 13 prepare_scene 0 4 3648 23 NodePath::prepare_scene 0 1 951 476</span>
<span class="s0">/**</span>
 <span class="s0">* Walks through the scene graph beginning at the bottom node, and does</span>
 <span class="s0">* whatever initialization is required to render the scene properly with the</span>
 <span class="s0">* indicated GSG.  It is not strictly necessary to call this, since the GSG</span>
 <span class="s0">* will initialize itself when the scene is rendered, but this may take some</span>
 <span class="s0">* of the overhead away from that process.</span>
 <span class="s0">*</span>
 <span class="s0">* In particular, this will ensure that textures and vertex buffers within the</span>
 <span class="s0">* scene are loaded into graphics memory.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void NodePath::prepare_scene(GraphicsStateGuardianBase *gsg);</span>

<span class="s0">2699 11 show_bounds 0 4 3648 21 NodePath::show_bounds 0 1 952 273</span>
<span class="s0">/**</span>
 <span class="s0">* Causes the bounding volume of the bottom node and all of its descendants</span>
 <span class="s0">* (that is, the bounding volume associated with the the bottom arc) to be</span>
 <span class="s0">* rendered, if possible.  The rendering method is less than optimal; this is</span>
 <span class="s0">* intended primarily for debugging.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void NodePath::show_bounds(void);</span>

<span class="s0">2700 17 show_tight_bounds 0 4 3648 27 NodePath::show_tight_bounds 0 1 953 288</span>
<span class="s0">/**</span>
 <span class="s0">* Similar to show_bounds(), this draws a bounding box representing the</span>
 <span class="s0">* &quot;tight&quot; bounds of this node and all of its descendants.  The bounding box</span>
 <span class="s0">* is recomputed every frame by reexamining all of the vertices; this is far</span>
 <span class="s0">* from efficient, but this is intended for debugging.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void NodePath::show_tight_bounds(void);</span>

<span class="s0">2701 11 hide_bounds 0 4 3648 21 NodePath::hide_bounds 0 1 954 79</span>
<span class="s0">/**</span>
 <span class="s0">* Stops the rendering of the bounding volume begun with show_bounds().</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void NodePath::hide_bounds(void);</span>

<span class="s0">2702 10 get_bounds 0 4 3648 20 NodePath::get_bounds 0 1 955 214</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated bounding volume containing the bottom node and</span>
 <span class="s0">* all of its descendants.  This is the bounding volume on the bottom arc,</span>
 <span class="s0">* converted to the local coordinate space of the node.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">PointerTo&lt; BoundingVolume &gt; NodePath::get_bounds(Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2703 22 force_recompute_bounds 0 4 3648 32 NodePath::force_recompute_bounds 0 1 956 520</span>
<span class="s0">/**</span>
 <span class="s0">* Forces the recomputing of all the bounding volumes at every node in the</span>
 <span class="s0">* subgraph beginning at this node and below.</span>
 <span class="s0">*</span>
 <span class="s0">* This should not normally need to be called, since the bounding volumes are</span>
 <span class="s0">* supposed to be recomputed automatically when necessary.  It may be useful</span>
 <span class="s0">* when debugging, to verify that the bounding volumes have not become</span>
 <span class="s0">* inadvertently stale; it may also be useful to force animated characters to</span>
 <span class="s0">* update their bounding volumes (which does not presently happen</span>
 <span class="s0">* automatically).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void NodePath::force_recompute_bounds(void);</span>

<span class="s0">2704 12 write_bounds 0 4 3648 22 NodePath::write_bounds 0 1 957 143</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a description of the bounding volume containing the bottom node and</span>
 <span class="s0">* all of its descendants to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void NodePath::write_bounds(std::ostream &amp;out) const;</span>

<span class="s0">2705 17 calc_tight_bounds 0 4 3648 27 NodePath::calc_tight_bounds 0 1 958 725</span>
<span class="s0">/**</span>
 <span class="s0">* Calculates the minimum and maximum vertices of all Geoms at this NodePath's</span>
 <span class="s0">* bottom node and below.  This is a tight bounding box; it will generally be</span>
 <span class="s0">* tighter than the bounding volume returned by get_bounds() (but it is more</span>
 <span class="s0">* expensive to compute).</span>
 <span class="s0">*</span>
 <span class="s0">* The bounding box is computed relative to the parent node's coordinate</span>
 <span class="s0">* system by default.  You can optionally specify a different NodePath to</span>
 <span class="s0">* compute the bounds relative to.  Note that the box is always axis-aligned</span>
 <span class="s0">* against the given NodePath's coordinate system, so you might get a</span>
 <span class="s0">* differently sized box depending on which node you pass.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if any points are within the bounding volume, or</span>
 <span class="s0">* false if none are.</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">bool NodePath::calc_tight_bounds(LPoint3 &amp;min_point, LPoint3 &amp;max_point, NodePath const &amp;other = NodePath(), Thread *current_thread = Thread::get_current_thread()) const;</span>

<span class="s0">2706 16 get_tight_bounds 0 4 3648 26 NodePath::get_tight_bounds 0 1 959 0</span>
<span class="s0">79</span>
<span class="s0">PyObject *NodePath::get_tight_bounds(NodePath const &amp;other = NodePath()) const;</span>

<span class="s0">2707 13 flatten_light 0 4 3648 23 NodePath::flatten_light 0 1 960 811</span>
<span class="s0">/**</span>
 <span class="s0">* Lightly flattens out the hierarchy below this node by applying transforms,</span>
 <span class="s0">* colors, and texture matrices from the nodes onto the vertices, but does not</span>
 <span class="s0">* remove any nodes.</span>
 <span class="s0">*</span>
 <span class="s0">* This can result in improved rendering performance because there will be</span>
 <span class="s0">* fewer transforms in the resulting scene graph, but the number of nodes will</span>
 <span class="s0">* remain the same.</span>
 <span class="s0">*</span>
 <span class="s0">* In particular, any NodePaths that reference nodes within this hierarchy</span>
 <span class="s0">* will not be damaged.  However, since this operation will remove transforms</span>
 <span class="s0">* from the scene graph, it may be dangerous to apply to nodes where you</span>
 <span class="s0">* expect to dynamically modify the transform, or where you expect the</span>
 <span class="s0">* geometry to remain in a particular local coordinate system.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is always 0, since flatten_light does not remove any</span>
 <span class="s0">* nodes.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">int NodePath::flatten_light(void);</span>

<span class="s0">2708 14 flatten_medium 0 4 3648 24 NodePath::flatten_medium 0 1 961 488</span>
<span class="s0">/**</span>
 <span class="s0">* A more thorough flattening than flatten_light(), this first applies all the</span>
 <span class="s0">* transforms, colors, and texture matrices from the nodes onto the vertices,</span>
 <span class="s0">* and then removes unneeded grouping nodes--nodes that have exactly one</span>
 <span class="s0">* child, for instance, but have no special properties in themselves.</span>
 <span class="s0">*</span>
 <span class="s0">* This results in improved performance over flatten_light() because the</span>
 <span class="s0">* number of nodes in the scene graph is reduced.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the number of nodes removed.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">int NodePath::flatten_medium(void);</span>

<span class="s0">2709 14 flatten_strong 0 4 3648 24 NodePath::flatten_strong 0 1 962 630</span>
<span class="s0">/**</span>
 <span class="s0">* The strongest possible flattening.  This first applies all of the</span>
 <span class="s0">* transforms to the vertices, as in flatten_medium(), but then it will</span>
 <span class="s0">* combine sibling nodes together when possible, in addition to removing</span>
 <span class="s0">* unnecessary parent-child nodes.  This can result in substantially fewer</span>
 <span class="s0">* nodes, but any nicely-grouped hierachical bounding volumes may be lost.</span>
 <span class="s0">*</span>
 <span class="s0">* It is generally a good idea to apply this kind of flattening only to nodes</span>
 <span class="s0">* that will be culled largely as a single unit, like a car.  Applying this to</span>
 <span class="s0">* an entire scene may result in overall poorer performance because of less-</span>
 <span class="s0">* effective culling.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">int NodePath::flatten_strong(void);</span>

<span class="s0">2710 20 apply_texture_colors 0 4 3648 30 NodePath::apply_texture_colors 0 1 963 692</span>
<span class="s0">/**</span>
 <span class="s0">* Removes textures from Geoms at this node and below by applying the texture</span>
 <span class="s0">* colors to the vertices.  This is primarily useful to simplify a low-LOD</span>
 <span class="s0">* model.  The texture colors are replaced by flat colors that approximate the</span>
 <span class="s0">* original textures.</span>
 <span class="s0">*</span>
 <span class="s0">* Only the bottommost texture on each Geom is used (if there is more than</span>
 <span class="s0">* one), and it is applied as if it were M_modulate, and WM_repeat, regardless</span>
 <span class="s0">* of its actual settings.  If the texture has a simple_ram_image, this may be</span>
 <span class="s0">* used if the main image isn't resident.</span>
 <span class="s0">*</span>
 <span class="s0">* After this call, there will be no texturing specified at this level and</span>
 <span class="s0">* below.  Of course, there might still be texturing inherited from above.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void NodePath::apply_texture_colors(void);</span>

<span class="s0">2711 17 clear_model_nodes 0 4 3648 27 NodePath::clear_model_nodes 0 1 964 315</span>
<span class="s0">/**</span>
 <span class="s0">* Recursively walks through the scene graph at this level and below, looking</span>
 <span class="s0">* for ModelNodes, and calls model_node-&gt;set_preserve_transform(PT_drop_node)</span>
 <span class="s0">* on each one.  This allows a subsequent call to flatten_strong() to</span>
 <span class="s0">* eliminate all of the ModelNodes.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the number of ModelNodes found.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline int NodePath::clear_model_nodes(void);</span>

<span class="s0">2712 7 set_tag 0 4 3648 17 NodePath::set_tag 0 1 965 391</span>
<span class="s0">/**</span>
 <span class="s0">* Associates a user-defined value with a user-defined key which is stored on</span>
 <span class="s0">* the node.  This value has no meaning to Panda; but it is stored</span>
 <span class="s0">* indefinitely on the node until it is requested again.</span>
 <span class="s0">*</span>
 <span class="s0">* Each unique key stores a different string value.  There is no effective</span>
 <span class="s0">* limit on the number of different keys that may be stored or on the length</span>
 <span class="s0">* of any one key's value.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline void NodePath::set_tag(std::string const &amp;key, std::string const &amp;value);</span>

<span class="s0">2713 7 get_tag 0 4 3648 17 NodePath::get_tag 0 1 966 207</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the user-defined value that was previously set on this node for</span>
 <span class="s0">* the particular key, if any.  If no value has been previously set, returns</span>
 <span class="s0">* the empty string.  See also get_net_tag().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline std::string NodePath::get_tag(std::string const &amp;key) const;</span>

<span class="s0">2714 12 get_tag_keys 0 4 3648 22 NodePath::get_tag_keys 0 2 967 968 232</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the given vector up with the list of tags on this PandaNode.</span>
 <span class="s0">*</span>
 <span class="s0">* It is the user's responsibility to ensure that the keys vector is empty</span>
 <span class="s0">* before making this call; otherwise, the new files will be appended to it.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">inline void NodePath::get_tag_keys(vector_string &amp;keys) const;</span>
<span class="s0">inline PyObject *NodePath::get_tag_keys(void) const;</span>

<span class="s0">2715 7 has_tag 0 4 3648 17 NodePath::has_tag 0 1 969 195</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a value has been defined on this node for the particular</span>
 <span class="s0">* key (even if that value is the empty string), or false if no value has been</span>
 <span class="s0">* set.  See also has_net_tag().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool NodePath::has_tag(std::string const &amp;key) const;</span>

<span class="s0">2716 9 clear_tag 0 4 3648 19 NodePath::clear_tag 0 1 970 158</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the value defined for this key on this particular node.  After a</span>
 <span class="s0">* call to clear_tag(), has_tag() will return false for the indicated key.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void NodePath::clear_tag(std::string const &amp;key);</span>

<span class="s0">2717 11 get_net_tag 0 4 3648 21 NodePath::get_net_tag 0 1 971 251</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the tag value that has been defined on this node, or the nearest</span>
 <span class="s0">* ancestor node, for the indicated key.  If no value has been defined for the</span>
 <span class="s0">* indicated key on any ancestor node, returns the empty string.  See also</span>
 <span class="s0">* get_tag().</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline std::string NodePath::get_net_tag(std::string const &amp;key) const;</span>

<span class="s0">2718 11 has_net_tag 0 4 3648 21 NodePath::has_net_tag 0 1 972 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated tag value has been defined on this node or on</span>
 <span class="s0">* any ancestor node, or false otherwise.  See also has_tag().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool NodePath::has_net_tag(std::string const &amp;key) const;</span>

<span class="s0">2719 12 find_net_tag 0 4 3648 22 NodePath::find_net_tag 0 1 973 215</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the lowest ancestor of this node that contains a tag definition</span>
 <span class="s0">* with the indicated key, if any, or an empty NodePath if no ancestor of this</span>
 <span class="s0">* node contains this tag definition.  See set_tag().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">NodePath NodePath::find_net_tag(std::string const &amp;key) const;</span>

<span class="s0">2720 8 get_tags 0 4 3648 18 NodePath::get_tags 0 1 974 0</span>
<span class="s0">48</span>
<span class="s0">inline PyObject *NodePath::get_tags(void) const;</span>

<span class="s0">2721 15 get_python_tags 0 4 3648 25 NodePath::get_python_tags 0 1 975 0</span>
<span class="s0">42</span>
<span class="s0">PyObject *NodePath::get_python_tags(void);</span>

<span class="s0">2722 14 set_python_tag 0 4 3648 24 NodePath::set_python_tag 0 1 976 0</span>
<span class="s0">70</span>
<span class="s0">inline void NodePath::set_python_tag(PyObject *keys, PyObject *value);</span>

<span class="s0">2723 14 get_python_tag 0 4 3648 24 NodePath::get_python_tag 0 1 977 0</span>
<span class="s0">64</span>
<span class="s0">inline PyObject *NodePath::get_python_tag(PyObject *keys) const;</span>

<span class="s0">2724 19 get_python_tag_keys 0 4 3648 29 NodePath::get_python_tag_keys 0 1 978 0</span>
<span class="s0">59</span>
<span class="s0">inline PyObject *NodePath::get_python_tag_keys(void) const;</span>

<span class="s0">2725 14 has_python_tag 0 4 3648 24 NodePath::has_python_tag 0 1 979 0</span>
<span class="s0">59</span>
<span class="s0">inline bool NodePath::has_python_tag(PyObject *keys) const;</span>

<span class="s0">2726 16 clear_python_tag 0 4 3648 26 NodePath::clear_python_tag 0 1 980 0</span>
<span class="s0">55</span>
<span class="s0">inline void NodePath::clear_python_tag(PyObject *keys);</span>

<span class="s0">2727 18 get_net_python_tag 0 4 3648 28 NodePath::get_net_python_tag 0 1 981 0</span>
<span class="s0">68</span>
<span class="s0">inline PyObject *NodePath::get_net_python_tag(PyObject *keys) const;</span>

<span class="s0">2728 18 has_net_python_tag 0 4 3648 28 NodePath::has_net_python_tag 0 1 982 0</span>
<span class="s0">63</span>
<span class="s0">inline bool NodePath::has_net_python_tag(PyObject *keys) const;</span>

<span class="s0">2729 19 find_net_python_tag 0 4 3648 29 NodePath::find_net_python_tag 0 1 983 0</span>
<span class="s0">61</span>
<span class="s0">NodePath NodePath::find_net_python_tag(PyObject *keys) const;</span>

<span class="s0">2730 12 __traverse__ 0 4 3648 22 NodePath::__traverse__ 0 1 984 0</span>
<span class="s0">55</span>
<span class="s0">int NodePath::__traverse__(visitproc visit, void *arg);</span>

<span class="s0">2731 9 list_tags 0 4 3648 19 NodePath::list_tags 0 1 985 153</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the tags to the nout stream, one per line.  See</span>
 <span class="s0">* PandaNode::list_tags() for a variant that allows you to specify the output</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void NodePath::list_tags(void) const;</span>

<span class="s0">2732 8 set_name 0 4 3648 18 NodePath::set_name 0 1 986 51</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the name of the referenced node.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void NodePath::set_name(std::string const &amp;name);</span>

<span class="s0">2733 8 get_name 0 4 3648 18 NodePath::get_name 0 1 987 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the referenced node.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline std::string NodePath::get_name(void) const;</span>

<span class="s0">2734 14 write_bam_file 0 4 3648 24 NodePath::write_bam_file 0 1 988 230</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the contents of this node and below out to a bam file with the</span>
 <span class="s0">* indicated filename.  This file may then be read in again, as is, at some</span>
 <span class="s0">* later point.  Returns true if successful, false on some kind of error.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool NodePath::write_bam_file(Filename const &amp;filename) const;</span>

<span class="s0">2735 16 write_bam_stream 0 4 3648 26 NodePath::write_bam_stream 0 1 989 82</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the contents of this node and below out to the indicated stream.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">bool NodePath::write_bam_stream(std::ostream &amp;out) const;</span>

<span class="s0">2736 20 encode_to_bam_stream 0 4 3648 30 NodePath::encode_to_bam_stream 0 2 990 991 1372</span>
<span class="s0">/**</span>
 <span class="s0">* Converts the NodePath object into a single stream of data using a</span>
 <span class="s0">* BamWriter, and returns that data as a string string.  Returns empty string</span>
 <span class="s0">* on failure.  This is similar to write_bam_stream().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is used by __reduce__ to handle streaming of NodePaths to a</span>
 <span class="s0">* pickle file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Converts the NodePath object into a single stream of data using a</span>
 <span class="s0">* BamWriter, and stores that data in the indicated string.  Returns true on</span>
 <span class="s0">* success, false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* If the BamWriter is NULL, this behaves the same way as</span>
 <span class="s0">* NodePath::write_bam_stream() and PandaNode::encode_to_bam_stream(), in the</span>
 <span class="s0">* sense that it only writes this node and all nodes below it.</span>
 <span class="s0">*</span>
 <span class="s0">* However, if the BamWriter is not NULL, it behaves very differently.  In</span>
 <span class="s0">* this case, it encodes the *entire graph* of all nodes connected to the</span>
 <span class="s0">* NodePath, including all parent nodes and siblings.  This is necessary for</span>
 <span class="s0">* correct streaming of related NodePaths and restoration of instances, etc.,</span>
 <span class="s0">* but it does mean you must detach() a node before writing it if you want to</span>
 <span class="s0">* limit the nodes that get written.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is used by __reduce__ to handle streaming of NodePaths to a</span>
 <span class="s0">* pickle file.  The BamWriter case is used by the direct.stdpy.pickle module,</span>
 <span class="s0">* while the saner, non-BamWriter case is used when the standard pickle module</span>
 <span class="s0">* calls this function.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">inline vector_uchar NodePath::encode_to_bam_stream(void) const;</span>
<span class="s0">bool NodePath::encode_to_bam_stream(vector_uchar &amp;data, BamWriter *writer = nullptr) const;</span>

<span class="s0">2737 22 decode_from_bam_stream 0 4 3648 32 NodePath::decode_from_bam_stream 0 1 992 162</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the string created by a previous call to encode_to_bam_stream(), and</span>
 <span class="s0">* extracts and returns the NodePath on that string.  Returns NULL on error.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">static NodePath NodePath::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr);</span>

<span class="s0">2738 14 get_class_type 0 4 3648 24 NodePath::get_class_type 0 1 993 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle NodePath::get_class_type(void);</span>

<span class="s0">2739 9 ~NodePath 0 516 3648 19 NodePath::~NodePath 0 0 0</span>
<span class="s0">26</span>
<span class="s0">NodePath::~NodePath(void);</span>

<span class="s0">2740 8 add_node 0 4 3652 28 AttribNodeRegistry::add_node 0 1 1043 556</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated NodePath to the registry.  The name and type of the node</span>
 <span class="s0">* are noted at the time of this call; if the name changes later, it will not</span>
 <span class="s0">* update the registry index.</span>
 <span class="s0">*</span>
 <span class="s0">* The NodePath must reference some kind of an attribute node, such as a</span>
 <span class="s0">* LightNode or a PlaneNode.  When bam files that reference an attribute node</span>
 <span class="s0">* of the same type and the same name are loaded, they will quietly be</span>
 <span class="s0">* redirected to reference this NodePath.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is already a node matching the indicated name and type, it will be</span>
 <span class="s0">* replaced.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">void AttribNodeRegistry::add_node(NodePath const &amp;attrib_node);</span>

<span class="s0">2741 11 remove_node 0 4 3652 31 AttribNodeRegistry::remove_node 0 2 1044 1045 372</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated NodePath from the registry.  The name of the node</span>
 <span class="s0">* must not have changed since the matching call to add_node(), or it will not</span>
 <span class="s0">* be successfully removed.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the NodePath is found and removed, false if it is not found</span>
 <span class="s0">* (for instance, because the name has changed).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the nth node from the registry.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">bool AttribNodeRegistry::remove_node(NodePath const &amp;attrib_node);</span>
<span class="s0">void AttribNodeRegistry::remove_node(int n);</span>

<span class="s0">2742 11 lookup_node 0 4 3652 31 AttribNodeRegistry::lookup_node 0 1 1046 215</span>
<span class="s0">/**</span>
 <span class="s0">* Looks up the indicated NodePath in the registry.  If there is a node</span>
 <span class="s0">* already in the registry with the matching name and type, returns that</span>
 <span class="s0">* NodePath instead; otherwise, returns the original NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">NodePath AttribNodeRegistry::lookup_node(NodePath const &amp;orig_node) const;</span>

<span class="s0">2743 13 get_num_nodes 0 4 3652 33 AttribNodeRegistry::get_num_nodes 0 1 1047 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of nodes in the registry.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int AttribNodeRegistry::get_num_nodes(void) const;</span>

<span class="s0">2744 8 get_node 0 4 3652 28 AttribNodeRegistry::get_node 0 1 1048 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth NodePath recorded in the registry.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">NodePath AttribNodeRegistry::get_node(int n) const;</span>

<span class="s0">2745 13 get_node_type 0 4 3652 33 AttribNodeRegistry::get_node_type 0 1 1049 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of the nth node, as recorded in the registry.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">TypeHandle AttribNodeRegistry::get_node_type(int n) const;</span>

<span class="s0">2746 13 get_node_name 0 4 3652 33 AttribNodeRegistry::get_node_name 0 1 1050 236</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the nth node, as recorded in the registry.  This will</span>
 <span class="s0">* be the node name as it was at the time the node was recorded; if the node</span>
 <span class="s0">* has changed names since then, this will still return the original name.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">std::string AttribNodeRegistry::get_node_name(int n) const;</span>

<span class="s0">2747 9 find_node 0 4 3652 29 AttribNodeRegistry::find_node 0 2 1051 1052 394</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number of the indicated NodePath in the registry</span>
 <span class="s0">* (assuming its name hasn't changed since it was recorded in the registry),</span>
 <span class="s0">* or -1 if the NodePath cannot be found (for instance, because its name has</span>
 <span class="s0">* changed).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the index number of the node with the indicated type and name in</span>
 <span class="s0">* the registry, or -1 if there is no such node in the registry.</span>
 <span class="s0">*/</span>
<span class="s0">152</span>
<span class="s0">int AttribNodeRegistry::find_node(NodePath const &amp;attrib_node) const;</span>
<span class="s0">int AttribNodeRegistry::find_node(TypeHandle type, std::string const &amp;name) const;</span>

<span class="s0">2748 5 clear 0 4 3652 25 AttribNodeRegistry::clear 0 1 1053 47</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all nodes from the registry.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void AttribNodeRegistry::clear(void);</span>

<span class="s0">2749 6 output 0 4 3652 26 AttribNodeRegistry::output 0 1 1054 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void AttribNodeRegistry::output(std::ostream &amp;out) const;</span>

<span class="s0">2750 5 write 0 4 3652 25 AttribNodeRegistry::write 0 1 1055 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void AttribNodeRegistry::write(std::ostream &amp;out) const;</span>

<span class="s0">2751 14 get_global_ptr 0 4 3652 34 AttribNodeRegistry::get_global_ptr 0 1 1056 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static inline AttribNodeRegistry *AttribNodeRegistry::get_global_ptr(void);</span>

<span class="s0">2752 19 ~AttribNodeRegistry 0 516 3652 39 AttribNodeRegistry::~AttribNodeRegistry 0 0 0</span>
<span class="s0">46</span>
<span class="s0">AttribNodeRegistry::~AttribNodeRegistry(void);</span>

<span class="s0">2753 13 make_identity 0 4 3653 32 AudioVolumeAttrib::make_identity 0 1 1057 54</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an identity audio volume attrib.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AudioVolumeAttrib::make_identity(void);</span>

<span class="s0">2754 4 make 0 4 3653 23 AudioVolumeAttrib::make 0 1 1058 125</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new AudioVolumeAttrib object that indicates audio volume</span>
 <span class="s0">* should be scaled by the indicated factor.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AudioVolumeAttrib::make(PN_stdfloat volume);</span>

<span class="s0">2755 8 make_off 0 4 3653 27 AudioVolumeAttrib::make_off 0 1 1059 213</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new AudioVolumeAttrib object that ignores any</span>
 <span class="s0">* AudioVolumeAttrib inherited from above.  You may also specify an additional</span>
 <span class="s0">* volume scale to apply to geometry below (using set_volume()).</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AudioVolumeAttrib::make_off(void);</span>

<span class="s0">2756 12 make_default 0 4 3653 31 AudioVolumeAttrib::make_default 0 1 1060 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AudioVolumeAttrib::make_default(void);</span>

<span class="s0">2757 6 is_off 0 4 3653 25 AudioVolumeAttrib::is_off 0 1 1061 257</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the AudioVolumeAttrib will ignore any color scales</span>
 <span class="s0">* inherited from above, false otherwise.  This is not the same thing as</span>
 <span class="s0">* !has_scale(); a AudioVolumeAttrib may have the &quot;off&quot; flag set and also have</span>
 <span class="s0">* another scale specified.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool AudioVolumeAttrib::is_off(void) const;</span>

<span class="s0">2758 10 has_volume 0 4 3653 29 AudioVolumeAttrib::has_volume 0 1 1062 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the AudioVolumeAttrib has a non-identity volume, false</span>
 <span class="s0">* otherwise (in which case it might be an off attrib or an identity attrib).</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool AudioVolumeAttrib::has_volume(void) const;</span>

<span class="s0">2759 10 get_volume 0 4 3653 29 AudioVolumeAttrib::get_volume 0 1 1063 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the volume to be applied to sounds.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline PN_stdfloat AudioVolumeAttrib::get_volume(void) const;</span>

<span class="s0">2760 10 set_volume 0 4 3653 29 AudioVolumeAttrib::set_volume 0 1 1064 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new AudioVolumeAttrib, just like this one, but with the volume</span>
 <span class="s0">* changed to the indicated value.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; AudioVolumeAttrib::set_volume(PN_stdfloat volume) const;</span>

<span class="s0">2761 14 get_class_slot 0 4 3653 33 AudioVolumeAttrib::get_class_slot 0 1 1065 0</span>
<span class="s0">51</span>
<span class="s0">static int AudioVolumeAttrib::get_class_slot(void);</span>

<span class="s0">2762 14 get_class_type 0 4 3653 33 AudioVolumeAttrib::get_class_type 0 1 1066 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle AudioVolumeAttrib::get_class_type(void);</span>

<span class="s0">2763 18 ~AudioVolumeAttrib 0 516 3653 37 AudioVolumeAttrib::~AudioVolumeAttrib 0 0 0</span>
<span class="s0">44</span>
<span class="s0">AudioVolumeAttrib::~AudioVolumeAttrib(void);</span>

<span class="s0">2764 4 make 0 4 3654 23 AuxBitplaneAttrib::make 0 2 1067 1068 118</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a default AuxBitplaneAttrib object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a specified AuxBitplaneAttrib object.</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AuxBitplaneAttrib::make(void);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AuxBitplaneAttrib::make(int outputs);</span>

<span class="s0">2765 12 make_default 0 4 3654 31 AuxBitplaneAttrib::make_default 0 1 1069 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; AuxBitplaneAttrib::make_default(void);</span>

<span class="s0">2766 11 get_outputs 0 4 3654 30 AuxBitplaneAttrib::get_outputs 0 1 1070 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the AuxBitplaneAttrib output bits.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int AuxBitplaneAttrib::get_outputs(void) const;</span>

<span class="s0">2767 14 get_class_slot 0 4 3654 33 AuxBitplaneAttrib::get_class_slot 0 1 1071 0</span>
<span class="s0">51</span>
<span class="s0">static int AuxBitplaneAttrib::get_class_slot(void);</span>

<span class="s0">2768 14 get_class_type 0 4 3654 33 AuxBitplaneAttrib::get_class_type 0 1 1072 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle AuxBitplaneAttrib::get_class_type(void);</span>

<span class="s0">2769 18 ~AuxBitplaneAttrib 0 516 3654 37 AuxBitplaneAttrib::~AuxBitplaneAttrib 0 0 0</span>
<span class="s0">44</span>
<span class="s0">AuxBitplaneAttrib::~AuxBitplaneAttrib(void);</span>

<span class="s0">2770 12 set_duration 0 4 3656 26 AuxSceneData::set_duration 0 1 1074 159</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the minimum length in time, in seconds, to keep this AuxSceneData</span>
 <span class="s0">* object around in the scene graph after the last time it was rendered.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void AuxSceneData::set_duration(double duration);</span>

<span class="s0">2771 12 get_duration 0 4 3656 26 AuxSceneData::get_duration 0 1 1075 157</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minimum length in time, in seconds, to keep this AuxSceneData</span>
 <span class="s0">* object around in the scene graph after the last time it was rendered.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double AuxSceneData::get_duration(void) const;</span>

<span class="s0">2772 20 set_last_render_time 0 4 3656 34 AuxSceneData::set_last_render_time 0 1 1076 111</span>
<span class="s0">/**</span>
 <span class="s0">* Should be called with the current frame_time each time the AuxSceneData is</span>
 <span class="s0">* used during traversal.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void AuxSceneData::set_last_render_time(double render_time);</span>

<span class="s0">2773 20 get_last_render_time 0 4 3656 34 AuxSceneData::get_last_render_time 0 1 1077 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the last time this object was used during traversal (according to</span>
 <span class="s0">* set_last_render_time()).</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline double AuxSceneData::get_last_render_time(void) const;</span>

<span class="s0">2774 19 get_expiration_time 0 4 3656 33 AuxSceneData::get_expiration_time 0 1 1078 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the frame_time at which this AuxSceneData object is currently</span>
 <span class="s0">* scheduled to be removed from the scene graph.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline double AuxSceneData::get_expiration_time(void) const;</span>

<span class="s0">2775 6 output 0 6 3656 20 AuxSceneData::output 0 1 1079 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual void AuxSceneData::output(std::ostream &amp;out) const;</span>

<span class="s0">2776 5 write 0 6 3656 19 AuxSceneData::write 0 1 1080 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">virtual void AuxSceneData::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">2777 14 get_class_type 0 4 3656 28 AuxSceneData::get_class_type 0 1 1081 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle AuxSceneData::get_class_type(void);</span>

<span class="s0">2778 12 AuxSceneData 0 260 3656 26 AuxSceneData::AuxSceneData 0 1 1073 193</span>
<span class="s0">/**</span>
 <span class="s0">* This is protected, since you normally don't want to create a plain</span>
 <span class="s0">* AuxSceneData object; instead, create an instance of a derived class that</span>
 <span class="s0">* actually has some useful data in it.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline AuxSceneData::AuxSceneData(AuxSceneData const &amp;) = default;</span>

<span class="s0">2779 13 ~AuxSceneData 0 516 3656 27 AuxSceneData::~AuxSceneData 0 0 0</span>
<span class="s0">34</span>
<span class="s0">AuxSceneData::~AuxSceneData(void);</span>

<span class="s0">2780 7 BamFile 0 260 3658 16 BamFile::BamFile 0 1 1082 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">23</span>
<span class="s0">BamFile::BamFile(void);</span>

<span class="s0">2781 8 ~BamFile 0 516 3658 17 BamFile::~BamFile 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">24</span>
<span class="s0">BamFile::~BamFile(void);</span>

<span class="s0">2782 9 open_read 0 4 3658 18 BamFile::open_read 0 2 1083 1084 275</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to open the indicated filename for reading.  Returns true if</span>
 <span class="s0">* successful, false on error.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Attempts to open the indicated stream for reading.  The filename is just</span>
 <span class="s0">* for information purposes only.  Returns true if successful, false on error.</span>
 <span class="s0">*/</span>
<span class="s0">195</span>
<span class="s0">bool BamFile::open_read(Filename const &amp;bam_filename, bool report_errors = true);</span>
<span class="s0">bool BamFile::open_read(std::istream &amp;in, std::string const &amp;bam_filename = &quot;stream&quot;, bool report_errors = true);</span>

<span class="s0">2783 11 read_object 0 4 3658 20 BamFile::read_object 0 1 1085 313</span>
<span class="s0">/**</span>
 <span class="s0">* Reads and returns the next object from the Bam file, or NULL if the end of</span>
 <span class="s0">* the file has been reached, or if there is an error condition.  Use is_eof()</span>
 <span class="s0">* to differentiate these two cases.</span>
 <span class="s0">*</span>
 <span class="s0">* The pointers returned by this method will not be valid for use until</span>
 <span class="s0">* resolve() is subsequently called.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">TypedWritable *BamFile::read_object(void);</span>

<span class="s0">2784 6 is_eof 0 4 3658 15 BamFile::is_eof 0 1 1086 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the reader has reached end-of-file, false otherwise.  This</span>
 <span class="s0">* call is only valid after a call to read_object().</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">bool BamFile::is_eof(void) const;</span>

<span class="s0">2785 7 resolve 0 4 3658 16 BamFile::resolve 0 1 1087 358</span>
<span class="s0">/**</span>
 <span class="s0">* This must be called after one or more objects have been read via calls to</span>
 <span class="s0">* read_object() in order to resolve all internal pointer references in the</span>
 <span class="s0">* objects read and make all the pointers valid.  It returns true if all</span>
 <span class="s0">* objects are successfully resolved, or false if some have not been (in which</span>
 <span class="s0">* case you must call resolve() again later).</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">bool BamFile::resolve(void);</span>

<span class="s0">2786 9 read_node 0 4 3658 18 BamFile::read_node 0 1 1088 758</span>
<span class="s0">/**</span>
 <span class="s0">* Although the bam file format is general enough to store a list of objects</span>
 <span class="s0">* of arbitrary type, bam files on disk usually contain just one object, a</span>
 <span class="s0">* PandaNode that is the root of a scene graph.  (Bam files that store other</span>
 <span class="s0">* kinds of things are usually given the extension &quot;boo&quot;, for &quot;binary other</span>
 <span class="s0">* objects&quot;, to differentiate them from the normal scene graph type file.)</span>
 <span class="s0">*</span>
 <span class="s0">* This is a convenience method for when you believe you are reading a scene</span>
 <span class="s0">* graph bam file.  It reads the one PandaNode and returns it.  It also calls</span>
 <span class="s0">* resolve() to fully resolve the object, since we expect this will be the</span>
 <span class="s0">* only object in the file.</span>
 <span class="s0">*</span>
 <span class="s0">* If the bam file contains something other than a PandaNode, an error is</span>
 <span class="s0">* printed and NULL is returned.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">PointerTo&lt; PandaNode &gt; BamFile::read_node(bool report_errors = true);</span>

<span class="s0">2787 10 open_write 0 4 3658 19 BamFile::open_write 0 2 1089 1090 354</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to open the indicated file for writing.  If another file by the</span>
 <span class="s0">* same name already exists, it will be silently removed.  Returns true if</span>
 <span class="s0">* successful, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Attempts to open the indicated stream for writing.  The filename is just</span>
 <span class="s0">* for information purposes only.  Returns true if successful, false on error.</span>
 <span class="s0">*/</span>
<span class="s0">198</span>
<span class="s0">bool BamFile::open_write(Filename const &amp;bam_filename, bool report_errors = true);</span>
<span class="s0">bool BamFile::open_write(std::ostream &amp;out, std::string const &amp;bam_filename = &quot;stream&quot;, bool report_errors = true);</span>

<span class="s0">2788 12 write_object 0 4 3658 21 BamFile::write_object 0 1 1091 103</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the indicated object to the Bam file.  Returns true if successful,</span>
 <span class="s0">* false on error.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">bool BamFile::write_object(TypedWritable const *object);</span>

<span class="s0">2789 5 close 0 4 3658 14 BamFile::close 0 1 1092 45</span>
<span class="s0">/**</span>
 <span class="s0">* Closes the input or output stream.</span>
 <span class="s0">*/</span>
<span class="s0">26</span>
<span class="s0">void BamFile::close(void);</span>

<span class="s0">2790 13 is_valid_read 0 4 3658 22 BamFile::is_valid_read 0 1 1093 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Bam file is open and ready for reading with no errors</span>
 <span class="s0">* so far detected, or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool BamFile::is_valid_read(void) const;</span>

<span class="s0">2791 14 is_valid_write 0 4 3658 23 BamFile::is_valid_write 0 1 1094 124</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Bam file is open and ready for writing with no errors</span>
 <span class="s0">* so far detected, or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool BamFile::is_valid_write(void) const;</span>

<span class="s0">2792 18 get_file_major_ver 0 4 3658 27 BamFile::get_file_major_ver 0 1 1095 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the major version number of the file currently being read, or the</span>
 <span class="s0">* system current major version number if no file is currently open for</span>
 <span class="s0">* reading.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">int BamFile::get_file_major_ver(void);</span>

<span class="s0">2793 18 get_file_minor_ver 0 4 3658 27 BamFile::get_file_minor_ver 0 1 1096 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minor version number of the file currently being read, or the</span>
 <span class="s0">* system current minor version number if no file is currently open for</span>
 <span class="s0">* reading.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">int BamFile::get_file_minor_ver(void);</span>

<span class="s0">2794 15 get_file_endian 0 4 3658 24 BamFile::get_file_endian 0 1 1097 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the endian preference indicated by the Bam file currently being</span>
 <span class="s0">* read or written.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">BamEnums::BamEndian BamFile::get_file_endian(void) const;</span>

<span class="s0">2795 24 get_file_stdfloat_double 0 4 3658 33 BamFile::get_file_stdfloat_double 0 1 1098 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the file stores all &quot;standard&quot; floats as 64-bit doubles, or</span>
 <span class="s0">* false if they are 32-bit floats.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">bool BamFile::get_file_stdfloat_double(void) const;</span>

<span class="s0">2796 21 get_current_major_ver 0 4 3658 30 BamFile::get_current_major_ver 0 1 1099 140</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the system current major version number.  This is the version</span>
 <span class="s0">* number that will be assigned to any generated Bam files.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">int BamFile::get_current_major_ver(void);</span>

<span class="s0">2797 21 get_current_minor_ver 0 4 3658 30 BamFile::get_current_minor_ver 0 1 1100 140</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the system current minor version number.  This is the version</span>
 <span class="s0">* number that will be assigned to any generated Bam files.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">int BamFile::get_current_minor_ver(void);</span>

<span class="s0">2798 10 get_reader 0 4 3658 19 BamFile::get_reader 0 1 1101 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the BamReader in charge of performing the read operations.  This</span>
 <span class="s0">* will return NULL unless open_read() was called.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">BamReader *BamFile::get_reader(void);</span>

<span class="s0">2799 10 get_writer 0 4 3658 19 BamFile::get_writer 0 1 1102 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the BamWriter in charge of performing the write operations.  This</span>
 <span class="s0">* will return NULL unless open_write() was called.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">BamWriter *BamFile::get_writer(void);</span>

<span class="s0">2800 4 make 0 4 3665 21 BillboardEffect::make 0 1 1103 81</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new BillboardEffect object with the indicated properties.</span>
 <span class="s0">*/</span>
<span class="s0">226</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; BillboardEffect::make(LVector3 const &amp;up_vector, bool eye_relative, bool axial_rotate, PN_stdfloat offset, NodePath const &amp;look_at, LPoint3 const &amp;look_at_point, bool fixed_depth = false);</span>

<span class="s0">2801 9 make_axis 0 4 3665 26 BillboardEffect::make_axis 0 1 1104 76</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to make a typical axis-rotating billboard.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">static inline ConstPointerTo&lt; RenderEffect &gt; BillboardEffect::make_axis(void);</span>

<span class="s0">2802 14 make_point_eye 0 4 3665 31 BillboardEffect::make_point_eye 0 1 1105 93</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to make a typical eye-relative point-rotating</span>
 <span class="s0">* billboard.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">static inline ConstPointerTo&lt; RenderEffect &gt; BillboardEffect::make_point_eye(void);</span>

<span class="s0">2803 16 make_point_world 0 4 3665 33 BillboardEffect::make_point_world 0 1 1106 95</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to make a typical world-relative point-rotating</span>
 <span class="s0">* billboard.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">static inline ConstPointerTo&lt; RenderEffect &gt; BillboardEffect::make_point_world(void);</span>

<span class="s0">2804 6 is_off 0 4 3665 23 BillboardEffect::is_off 0 1 1107 323</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the BillboardEffect is an 'off' BillboardEffect, indicating</span>
 <span class="s0">* that it does not enable billboarding.  This kind of BillboardEffect isn't</span>
 <span class="s0">* particularly useful and isn't normally created or stored in the graph; it</span>
 <span class="s0">* might be implicitly discovered as the result of a</span>
 <span class="s0">* NodePath::get_rel_state().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool BillboardEffect::is_off(void) const;</span>

<span class="s0">2805 13 get_up_vector 0 4 3665 30 BillboardEffect::get_up_vector 0 1 1108 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the up vector in effect for this billboard.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVector3 const &amp;BillboardEffect::get_up_vector(void) const;</span>

<span class="s0">2806 16 get_eye_relative 0 4 3665 33 BillboardEffect::get_eye_relative 0 1 1109 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this billboard interprets the up vector relative to the</span>
 <span class="s0">* camera, or false if it is relative to the world.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool BillboardEffect::get_eye_relative(void) const;</span>

<span class="s0">2807 16 get_axial_rotate 0 4 3665 33 BillboardEffect::get_axial_rotate 0 1 1110 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this billboard rotates only around the axis of the up</span>
 <span class="s0">* vector, or false if it rotates freely in three dimensions.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool BillboardEffect::get_axial_rotate(void) const;</span>

<span class="s0">2808 15 get_fixed_depth 0 4 3665 32 BillboardEffect::get_fixed_depth 0 1 1111 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this billboard always appears at a fixed distance from the</span>
 <span class="s0">* camera.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool BillboardEffect::get_fixed_depth(void) const;</span>

<span class="s0">2809 10 get_offset 0 4 3665 27 BillboardEffect::get_offset 0 1 1112 204</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the distance toward the camera (or the look_at_point) the billboard</span>
 <span class="s0">* is moved towards, after rotating.  This can be used to ensure the billboard</span>
 <span class="s0">* is not obscured by nearby geometry.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PN_stdfloat BillboardEffect::get_offset(void) const;</span>

<span class="s0">2810 11 get_look_at 0 4 3665 28 BillboardEffect::get_look_at 0 1 1113 188</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node this billboard will rotate to look towards.  If this is</span>
 <span class="s0">* empty, it means the billboard will rotate towards the current camera node,</span>
 <span class="s0">* wherever that might be.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline NodePath const &amp;BillboardEffect::get_look_at(void) const;</span>

<span class="s0">2811 17 get_look_at_point 0 4 3665 34 BillboardEffect::get_look_at_point 0 1 1114 132</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point, relative to the look_at node, towards which the</span>
 <span class="s0">* billboard will rotate.  Normally this is (0, 0, 0).</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline LPoint3 const &amp;BillboardEffect::get_look_at_point(void) const;</span>

<span class="s0">2812 14 get_class_type 0 4 3665 31 BillboardEffect::get_class_type 0 1 1115 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle BillboardEffect::get_class_type(void);</span>

<span class="s0">2813 16 ~BillboardEffect 0 516 3665 33 BillboardEffect::~BillboardEffect 0 0 0</span>
<span class="s0">40</span>
<span class="s0">BillboardEffect::~BillboardEffect(void);</span>

<span class="s0">2814 8 LensNode 0 260 3666 18 LensNode::LensNode 0 1 1116 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">explicit LensNode::LensNode(std::string const &amp;name, Lens *lens = nullptr);</span>

<span class="s0">2815 9 copy_lens 0 4 3666 19 LensNode::copy_lens 0 2 1117 1118 211</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the LensNode using a copy of the indicated Lens.  If the original</span>
 <span class="s0">* Lens is changed or destroyed, this LensNode is not affected.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Copies the indicated lens into the specified slot.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">inline void LensNode::copy_lens(Lens const &amp;lens);</span>
<span class="s0">inline void LensNode::copy_lens(int index, Lens const &amp;lens);</span>

<span class="s0">2816 8 set_lens 0 4 3666 18 LensNode::set_lens 0 2 1119 1120 472</span>
<span class="s0">/**</span>
 <span class="s0">* Sets up the LensNode using this particular Lens pointer.  If the lens is</span>
 <span class="s0">* subsequently modified, the LensNode properties immediately reflect the</span>
 <span class="s0">* change.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the indicated lens.  Although a LensNode normally holds only one lens,</span>
 <span class="s0">* it may optionally include multiple lenses, each with a different index</span>
 <span class="s0">* number.  The different lenses may be referenced by index number on the</span>
 <span class="s0">* DisplayRegion.  Adding a new lens automatically makes it active.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline void LensNode::set_lens(Lens *lens);</span>
<span class="s0">void LensNode::set_lens(int index, Lens *lens);</span>

<span class="s0">2817 8 get_lens 0 4 3666 18 LensNode::get_lens 0 1 1121 191</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the particular Lens associated with this LensNode, or</span>
 <span class="s0">* NULL if there is not yet a Lens associated.  If an index number is</span>
 <span class="s0">* specified, returns the nth lens.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline Lens *LensNode::get_lens(int index = 0) const;</span>

<span class="s0">2818 15 set_lens_active 0 4 3666 25 LensNode::set_lens_active 0 1 1122 263</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the active flag for the nth lens.  When a lens is inactive, it is not</span>
 <span class="s0">* used for rendering, and any DisplayRegions associated with it are</span>
 <span class="s0">* implicitly inactive as well.  Returns true if the flag is changed, false if</span>
 <span class="s0">* it already had this value.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool LensNode::set_lens_active(int index, bool active);</span>

<span class="s0">2819 15 get_lens_active 0 4 3666 25 LensNode::get_lens_active 0 1 1123 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the active flag for the nth lens.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool LensNode::get_lens_active(int index) const;</span>

<span class="s0">2820 13 activate_lens 0 4 3666 23 LensNode::activate_lens 0 1 1124 65</span>
<span class="s0">/**</span>
 <span class="s0">* An alternate way to call set_lens_active(index, true).</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool LensNode::activate_lens(int index);</span>

<span class="s0">2821 15 deactivate_lens 0 4 3666 25 LensNode::deactivate_lens 0 1 1125 66</span>
<span class="s0">/**</span>
 <span class="s0">* An alternate way to call set_lens_active(index, false).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool LensNode::deactivate_lens(int index);</span>

<span class="s0">2822 10 is_in_view 0 4 3666 20 LensNode::is_in_view 0 2 1126 1127 272</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the given point is within the bounds of the lens of the</span>
 <span class="s0">* LensNode (i.e.  if the camera can see the point).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the given point is within the bounds of the lens of the</span>
 <span class="s0">* LensNode (i.e.  if the camera can see the point).</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">inline bool LensNode::is_in_view(LPoint3 const &amp;pos);</span>
<span class="s0">bool LensNode::is_in_view(int index, LPoint3 const &amp;pos);</span>

<span class="s0">2823 12 show_frustum 0 4 3666 22 LensNode::show_frustum 0 1 1128 149</span>
<span class="s0">/**</span>
 <span class="s0">* Enables the drawing of the lens's frustum to aid in visualization.  This</span>
 <span class="s0">* actually creates a GeomNode which is parented to the LensNode.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void LensNode::show_frustum(void);</span>

<span class="s0">2824 12 hide_frustum 0 4 3666 22 LensNode::hide_frustum 0 1 1129 78</span>
<span class="s0">/**</span>
 <span class="s0">* Disables the drawing of the lens's frustum to aid in visualization.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void LensNode::hide_frustum(void);</span>

<span class="s0">2825 14 get_class_type 0 4 3666 24 LensNode::get_class_type 0 1 1130 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle LensNode::get_class_type(void);</span>

<span class="s0">2826 9 ~LensNode 0 516 3666 19 LensNode::~LensNode 0 0 0</span>
<span class="s0">26</span>
<span class="s0">LensNode::~LensNode(void);</span>

<span class="s0">2827 12 WeakNodePath 0 260 3667 26 WeakNodePath::WeakNodePath 0 2 1131 1132 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">inline WeakNodePath::WeakNodePath(NodePath const &amp;node_path);</span>
<span class="s0">inline WeakNodePath::WeakNodePath(WeakNodePath const &amp;copy);</span>

<span class="s0">2828 13 ~WeakNodePath 0 516 3667 27 WeakNodePath::~WeakNodePath 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline WeakNodePath::~WeakNodePath(void);</span>

<span class="s0">2829 10 operator = 0 4 3667 24 WeakNodePath::operator = 0 2 1133 1134 0</span>
<span class="s0">128</span>
<span class="s0">inline void WeakNodePath::operator =(NodePath const &amp;node_path);</span>
<span class="s0">inline void WeakNodePath::operator =(WeakNodePath const &amp;copy);</span>

<span class="s0">2830 5 clear 0 4 3667 19 WeakNodePath::clear 0 1 1135 93</span>
<span class="s0">/**</span>
 <span class="s0">* Sets this NodePath to the empty NodePath.  It will no longer point to any</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline void WeakNodePath::clear(void);</span>

<span class="s0">2831 22 operator typecast bool 0 132 3667 36 WeakNodePath::operator typecast bool 0 1 1150 0</span>
<span class="s0">34</span>
<span class="s0">inline operator bool (void) const;</span>

<span class="s0">2832 8 is_empty 0 4 3667 22 WeakNodePath::is_empty 0 1 1136 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the NodePath contains no nodes, or if it has been deleted.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool WeakNodePath::is_empty(void) const;</span>

<span class="s0">2833 11 was_deleted 0 4 3667 25 WeakNodePath::was_deleted 0 1 1137 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the NodePath we were referencing has been quietly deleted</span>
 <span class="s0">* outside of the WeakNodePath.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool WeakNodePath::was_deleted(void) const;</span>

<span class="s0">2834 13 get_node_path 0 4 3667 27 WeakNodePath::get_node_path 0 1 1138 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath held within this object, or an empty NodePath with the</span>
 <span class="s0">* error flag set if the object was deleted.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline NodePath WeakNodePath::get_node_path(void) const;</span>

<span class="s0">2835 4 node 0 4 3667 18 WeakNodePath::node 0 1 1139 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the PandaNode held within this object, or nullptr if the object was</span>
 <span class="s0">* deleted.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline PointerTo&lt; PandaNode &gt; WeakNodePath::node(void) const;</span>

<span class="s0">2836 11 operator == 0 4 3667 25 WeakNodePath::operator == 0 2 1140 1141 0</span>
<span class="s0">139</span>
<span class="s0">inline bool WeakNodePath::operator ==(NodePath const &amp;other) const;</span>
<span class="s0">inline bool WeakNodePath::operator ==(WeakNodePath const &amp;other) const;</span>

<span class="s0">2837 11 operator != 0 4 3667 25 WeakNodePath::operator != 0 2 1142 1143 0</span>
<span class="s0">139</span>
<span class="s0">inline bool WeakNodePath::operator !=(NodePath const &amp;other) const;</span>
<span class="s0">inline bool WeakNodePath::operator !=(WeakNodePath const &amp;other) const;</span>

<span class="s0">2838 10 operator &lt; 0 4 3667 24 WeakNodePath::operator &lt; 0 2 1144 1145 0</span>
<span class="s0">137</span>
<span class="s0">inline bool WeakNodePath::operator &lt;(NodePath const &amp;other) const;</span>
<span class="s0">inline bool WeakNodePath::operator &lt;(WeakNodePath const &amp;other) const;</span>

<span class="s0">2839 10 compare_to 0 4 3667 24 WeakNodePath::compare_to 0 2 1146 1147 990</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this NodePath sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two NodePaths are considered equivalent if they consist of exactly the same</span>
 <span class="s0">* list of nodes in the same order.  Otherwise, they are different; different</span>
 <span class="s0">* NodePaths will be ranked in a consistent but undefined ordering; the</span>
 <span class="s0">* ordering is useful only for placing the NodePaths in a sorted container</span>
 <span class="s0">* like an STL set.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this WeakNodePath sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two WeakNodePaths are considered equivalent if they consist of exactly the</span>
 <span class="s0">* same list of nodes in the same order.  Otherwise, they are different;</span>
 <span class="s0">* different WeakNodePaths will be ranked in a consistent but undefined</span>
 <span class="s0">* ordering; the ordering is useful only for placing the WeakNodePaths in a</span>
 <span class="s0">* sorted container like an STL set.</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">inline int WeakNodePath::compare_to(NodePath const &amp;other) const;</span>
<span class="s0">inline int WeakNodePath::compare_to(WeakNodePath const &amp;other) const;</span>

<span class="s0">2840 7 get_key 0 4 3667 21 WeakNodePath::get_key 0 1 1148 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the same values as NodePath::get_key().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline int WeakNodePath::get_key(void) const;</span>

<span class="s0">2841 6 output 0 4 3667 20 WeakNodePath::output 0 1 1149 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void WeakNodePath::output(std::ostream &amp;out) const;</span>

<span class="s0">2842 6 Camera 0 260 3668 14 Camera::Camera 0 2 1151 1152 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">explicit Camera::Camera(std::string const &amp;name, Lens *lens = (new PerspectiveLens()));</span>
<span class="s0">Camera::Camera(Camera const &amp;copy);</span>

<span class="s0">2843 10 set_active 0 4 3668 18 Camera::set_active 0 1 1153 107</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the active flag on the camera.  When the camera is not active, nothing</span>
 <span class="s0">* will be rendered.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void Camera::set_active(bool active);</span>

<span class="s0">2844 9 is_active 0 4 3668 17 Camera::is_active 0 1 1154 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the active flag on the camera.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool Camera::is_active(void) const;</span>

<span class="s0">2845 9 set_scene 0 4 3668 17 Camera::set_scene 0 1 1155 479</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the scene that will be rendered by the camera.  This is normally the</span>
 <span class="s0">* root node of a scene graph, typically a node called 'render', although it</span>
 <span class="s0">* could represent the root of any subgraph.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the use of this method is now deprecated.  In the absence of an</span>
 <span class="s0">* explicit scene set on the camera, the camera will render whatever scene it</span>
 <span class="s0">* is parented into.  This is the preferred way to specify the scene, since it</span>
 <span class="s0">* is the more intuitive mechanism.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void Camera::set_scene(NodePath const &amp;scene);</span>

<span class="s0">2846 9 get_scene 0 4 3668 17 Camera::get_scene 0 1 1156 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scene that will be rendered by the camera.  See set_scene().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline NodePath const &amp;Camera::get_scene(void) const;</span>

<span class="s0">2847 23 get_num_display_regions 0 4 3668 31 Camera::get_num_display_regions 0 1 1157 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of display regions associated with the camera.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::size_t Camera::get_num_display_regions(void) const;</span>

<span class="s0">2848 18 get_display_region 0 4 3668 26 Camera::get_display_region 0 1 1158 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth display region associated with the camera.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline DisplayRegion *Camera::get_display_region(std::size_t n) const;</span>

<span class="s0">2849 15 set_camera_mask 0 4 3668 23 Camera::set_camera_mask 0 1 1159 401</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the set of bits that represent the subset of the scene graph the</span>
 <span class="s0">* camera will render.</span>
 <span class="s0">*</span>
 <span class="s0">* During the cull traversal, a node is not visited if none of its draw mask</span>
 <span class="s0">* bits intersect with the camera's camera mask bits.  These masks can be used</span>
 <span class="s0">* to selectively hide and show different parts of the scene graph from</span>
 <span class="s0">* different cameras that are otherwise viewing the same scene.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void Camera::set_camera_mask(DrawMask mask);</span>

<span class="s0">2850 15 get_camera_mask 0 4 3668 23 Camera::get_camera_mask 0 1 1160 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of bits that represent the subset of the scene graph the</span>
 <span class="s0">* camera will render.  See set_camera_mask().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline DrawMask Camera::get_camera_mask(void) const;</span>

<span class="s0">2851 15 set_cull_center 0 4 3668 23 Camera::set_cull_center 0 1 1161 320</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the point from which the culling operations are performed.</span>
 <span class="s0">* Normally, this is the same as the camera, and that is the default if this</span>
 <span class="s0">* is not specified; but it may sometimes be useful to perform the culling</span>
 <span class="s0">* from some other viewpoint, particularly when you are debugging the culling</span>
 <span class="s0">* itself.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void Camera::set_cull_center(NodePath const &amp;cull_center);</span>

<span class="s0">2852 15 get_cull_center 0 4 3668 23 Camera::get_cull_center 0 1 1162 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point from which the culling operations will be performed, if</span>
 <span class="s0">* it was set by set_cull_center(), or the empty NodePath otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline NodePath const &amp;Camera::get_cull_center(void) const;</span>

<span class="s0">2853 15 set_cull_bounds 0 4 3668 23 Camera::set_cull_bounds 0 1 1163 379</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the bounding volume that should be used to perform culling from</span>
 <span class="s0">* this camera.  Normally, this is the bounding volume returned from the</span>
 <span class="s0">* active lens' make_bounds() call, but you may override this to specify a</span>
 <span class="s0">* custom volume if you require.  The specified bounding volume will be</span>
 <span class="s0">* understood to be in the coordinate space of the get_cull_center() node.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void Camera::set_cull_bounds(BoundingVolume *cull_bounds);</span>

<span class="s0">2854 15 get_cull_bounds 0 4 3668 23 Camera::get_cull_bounds 0 1 1164 129</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the custom cull volume that was set by set_cull_bounds(), if any,</span>
 <span class="s0">* or NULL if no custom cull volume was set.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline BoundingVolume *Camera::get_cull_bounds(void) const;</span>

<span class="s0">2855 14 set_lod_center 0 4 3668 22 Camera::set_lod_center 0 1 1165 379</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the point from which the LOD distances are measured.  Normally,</span>
 <span class="s0">* this is the same as the camera, and that is the default if this is not</span>
 <span class="s0">* specified; but it may sometimes be useful to perform the distance test from</span>
 <span class="s0">* some other viewpoint.  This may be used, for instance, to reduce LOD</span>
 <span class="s0">* popping when the camera rotates in a small circle about an avatar.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void Camera::set_lod_center(NodePath const &amp;lod_center);</span>

<span class="s0">2856 14 get_lod_center 0 4 3668 22 Camera::get_lod_center 0 1 1166 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point from which the LOD distances will be measured, if it was</span>
 <span class="s0">* set by set_lod_center(), or the empty NodePath otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline NodePath const &amp;Camera::get_lod_center(void) const;</span>

<span class="s0">2857 17 set_initial_state 0 4 3668 25 Camera::set_initial_state 0 1 1167 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the initial state which is applied to all nodes in the scene, as if it</span>
 <span class="s0">* were set at the top of the scene graph.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void Camera::set_initial_state(RenderState const *state);</span>

<span class="s0">2858 17 get_initial_state 0 4 3668 25 Camera::get_initial_state 0 1 1168 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the initial state as set by a previous call to set_initial_state().</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline ConstPointerTo&lt; RenderState &gt; Camera::get_initial_state(void) const;</span>

<span class="s0">2859 17 set_tag_state_key 0 4 3668 25 Camera::set_tag_state_key 0 1 1169 218</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the tag key which, when encountered as a tag on nodes in the scene</span>
 <span class="s0">* graph, causes this Camera to apply an arbitrary state transition based on</span>
 <span class="s0">* the value of the tag (as specified to set_tag_state()).</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void Camera::set_tag_state_key(std::string const &amp;tag_state_key);</span>

<span class="s0">2860 17 get_tag_state_key 0 4 3668 25 Camera::get_tag_state_key 0 1 1170 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the tag key as set by a previous call to set_tag_state_key().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::string const &amp;Camera::get_tag_state_key(void) const;</span>

<span class="s0">2861 13 set_lod_scale 0 4 3668 21 Camera::set_lod_scale 0 1 1171 114</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the multiplier for LOD distances.  This value is multiplied with the</span>
 <span class="s0">* LOD scale set on LodNodes.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void Camera::set_lod_scale(PN_stdfloat value);</span>

<span class="s0">2862 13 get_lod_scale 0 4 3668 21 Camera::get_lod_scale 0 1 1172 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the multiplier for LOD distances.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat Camera::get_lod_scale(void) const;</span>

<span class="s0">2863 13 set_tag_state 0 4 3668 21 Camera::set_tag_state 0 1 1173 585</span>
<span class="s0">/**</span>
 <span class="s0">* Associates a particular state transition with the indicated tag value.</span>
 <span class="s0">* When a node is encountered during traversal with the tag key specified by</span>
 <span class="s0">* set_tag_state_key(), if the value of that tag matches tag_state, then the</span>
 <span class="s0">* indicated state is applied to this node--but only when it is rendered by</span>
 <span class="s0">* this camera.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to apply special effects to nodes when they are rendered</span>
 <span class="s0">* by certain cameras.  It is particularly useful for multipass rendering, in</span>
 <span class="s0">* which specialty cameras might be needed to render the scene with a</span>
 <span class="s0">* particular set of effects.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">void Camera::set_tag_state(std::string const &amp;tag_state, RenderState const *state);</span>

<span class="s0">2864 15 clear_tag_state 0 4 3668 23 Camera::clear_tag_state 0 1 1174 85</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the association established by a previous call to set_tag_state().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void Camera::clear_tag_state(std::string const &amp;tag_state);</span>

<span class="s0">2865 16 clear_tag_states 0 4 3668 24 Camera::clear_tag_states 0 1 1175 85</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all associations established by previous calls to set_tag_state().</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">void Camera::clear_tag_states(void);</span>

<span class="s0">2866 13 has_tag_state 0 4 3668 21 Camera::has_tag_state 0 1 1176 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if set_tag_state() has previously been called with the</span>
 <span class="s0">* indicated tag state, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">bool Camera::has_tag_state(std::string const &amp;tag_state) const;</span>

<span class="s0">2867 13 get_tag_state 0 4 3668 21 Camera::get_tag_state 0 1 1177 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the state associated with the indicated tag state by a previous</span>
 <span class="s0">* call to set_tag_state(), or the empty state if nothing has been associated.</span>
 <span class="s0">*/</span>
<span class="s0">88</span>
<span class="s0">ConstPointerTo&lt; RenderState &gt; Camera::get_tag_state(std::string const &amp;tag_state) const;</span>

<span class="s0">2868 18 set_aux_scene_data 0 4 3668 26 Camera::set_aux_scene_data 0 1 1178 157</span>
<span class="s0">/**</span>
 <span class="s0">* Associates the indicated AuxSceneData object with the given NodePath,</span>
 <span class="s0">* possibly replacing a previous data defined for the same NodePath, if any.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void Camera::set_aux_scene_data(NodePath const &amp;node_path, AuxSceneData *data);</span>

<span class="s0">2869 20 clear_aux_scene_data 0 4 3668 28 Camera::clear_aux_scene_data 0 1 1179 153</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the AuxSceneData associated with the indicated NodePath.  Returns</span>
 <span class="s0">* true if it is removed successfully, false if it was already gone.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">bool Camera::clear_aux_scene_data(NodePath const &amp;node_path);</span>

<span class="s0">2870 18 get_aux_scene_data 0 4 3668 26 Camera::get_aux_scene_data 0 1 1180 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the AuxSceneData associated with the indicated NodePath, or NULL if</span>
 <span class="s0">* nothing is associated.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">AuxSceneData *Camera::get_aux_scene_data(NodePath const &amp;node_path) const;</span>

<span class="s0">2871 19 list_aux_scene_data 0 4 3668 27 Camera::list_aux_scene_data 0 1 1181 65</span>
<span class="s0">/**</span>
 <span class="s0">* Outputs all of the NodePaths and AuxSceneDatas in use.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void Camera::list_aux_scene_data(std::ostream &amp;out) const;</span>

<span class="s0">2872 22 cleanup_aux_scene_data 0 4 3668 30 Camera::cleanup_aux_scene_data 0 1 1182 179</span>
<span class="s0">/**</span>
 <span class="s0">* Walks through the list of currently-assigned AuxSceneData objects and</span>
 <span class="s0">* releases any that are past their expiration times.  Returns the number of</span>
 <span class="s0">* elements released.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">int Camera::cleanup_aux_scene_data(Thread *current_thread = Thread::get_current_thread());</span>

<span class="s0">2873 14 get_class_type 0 4 3668 22 Camera::get_class_type 0 1 1183 0</span>
<span class="s0">47</span>
<span class="s0">static TypeHandle Camera::get_class_type(void);</span>

<span class="s0">2874 9 PlaneNode 0 260 3675 20 PlaneNode::PlaneNode 0 1 1184 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">explicit PlaneNode::PlaneNode(std::string const &amp;name, LPlane const &amp;plane = LPlane());</span>

<span class="s0">2875 9 set_plane 0 4 3675 20 PlaneNode::set_plane 0 1 1185 66</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the particular plane represented by the PlaneNode.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void PlaneNode::set_plane(LPlane const &amp;plane);</span>

<span class="s0">2876 9 get_plane 0 4 3675 20 PlaneNode::get_plane 0 1 1186 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the plane represented by the PlaneNode.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LPlane const &amp;PlaneNode::get_plane(void) const;</span>

<span class="s0">2877 13 set_viz_scale 0 4 3675 24 PlaneNode::set_viz_scale 0 1 1187 115</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the size of the visual representation of the plane that is drawn</span>
 <span class="s0">* if the PlaneNode is shown.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PlaneNode::set_viz_scale(PN_stdfloat viz_scale);</span>

<span class="s0">2878 13 get_viz_scale 0 4 3675 24 PlaneNode::get_viz_scale 0 1 1188 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of the visual representation of the plane that is drawn if</span>
 <span class="s0">* the PlaneNode is shown.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline PN_stdfloat PlaneNode::get_viz_scale(void) const;</span>

<span class="s0">2879 12 set_priority 0 4 3675 23 PlaneNode::set_priority 0 1 1189 454</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the relative importance of this PlaneNode (when it is used as a</span>
 <span class="s0">* clip plane) relative to the other clip planes that are applied</span>
 <span class="s0">* simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The priority number is used to decide which of the requested clip planes</span>
 <span class="s0">* are to be activated when more clip planes are requested than the hardware</span>
 <span class="s0">* will support.  The highest-priority n planes are selected for rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to TextureStage::set_priority().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void PlaneNode::set_priority(int priority);</span>

<span class="s0">2880 12 get_priority 0 4 3675 23 PlaneNode::get_priority 0 1 1190 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the priority associated with this clip plane.  See set_priority().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int PlaneNode::get_priority(void) const;</span>

<span class="s0">2881 15 set_clip_effect 0 4 3675 26 PlaneNode::set_clip_effect 0 1 1191 436</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the sort of things this plane will actually clip (when it is used</span>
 <span class="s0">* as a clip plane).  This is a bitmask union of ClipEffect values.  If it</span>
 <span class="s0">* includes CE_visible, then it will clip visible geometry; if it includes</span>
 <span class="s0">* CE_collision, then it will clip collision polygons.  If it includes neither</span>
 <span class="s0">* bit, it will still affect culling, but objects will either be wholly behind</span>
 <span class="s0">* the clipping plane, or wholly present.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void PlaneNode::set_clip_effect(int clip_effect);</span>

<span class="s0">2882 15 get_clip_effect 0 4 3675 26 PlaneNode::get_clip_effect 0 1 1192 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the clip_effect bits for this clip plane.  See set_clip_effect().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int PlaneNode::get_clip_effect(void) const;</span>

<span class="s0">2883 14 get_class_type 0 4 3675 25 PlaneNode::get_class_type 0 1 1193 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle PlaneNode::get_class_type(void);</span>

<span class="s0">2884 10 ~PlaneNode 0 516 3675 21 PlaneNode::~PlaneNode 0 0 0</span>
<span class="s0">28</span>
<span class="s0">PlaneNode::~PlaneNode(void);</span>

<span class="s0">2885 4 make 0 4 3680 21 ClipPlaneAttrib::make 0 5 1194 1195 1196 1197 1198 883</span>
<span class="s0">// The following is the new, more general interface to the ClipPlaneAttrib.</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that enables (or disables,</span>
 <span class="s0">* according to op) the indicated plane(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that turns on (or off, according to</span>
 <span class="s0">* op) the indicate plane(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that turns on (or off, according to</span>
 <span class="s0">* op) the indicate plane(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that turns on (or off, according to</span>
 <span class="s0">* op) the indicate plane(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that does nothing.</span>
 <span class="s0">*/</span>
<span class="s0">623</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2, PlaneNode *plane3);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::make(ClipPlaneAttrib::Operation op, PlaneNode *plane1, PlaneNode *plane2, PlaneNode *plane3, PlaneNode *plane4);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::make(void);</span>

<span class="s0">2886 12 make_default 0 4 3680 29 ClipPlaneAttrib::make_default 0 1 1199 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::make_default(void);</span>

<span class="s0">2887 13 get_operation 0 4 3680 30 ClipPlaneAttrib::get_operation 0 1 1200 512</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the basic operation type of the ClipPlaneAttrib.  If this is O_set,</span>
 <span class="s0">* the planes listed here completely replace any planes that were already on.</span>
 <span class="s0">* If this is O_add, the planes here are added to the set of planes that</span>
 <span class="s0">* were already on, and if O_remove, the planes here are removed from the set</span>
 <span class="s0">* of planes that were on.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and</span>
 <span class="s0">* off_planes, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">ClipPlaneAttrib::Operation ClipPlaneAttrib::get_operation(void) const;</span>

<span class="s0">2888 14 get_num_planes 0 4 3680 31 ClipPlaneAttrib::get_num_planes 0 1 1201 234</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of planes listed in the attribute.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and</span>
 <span class="s0">* off_planes, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">int ClipPlaneAttrib::get_num_planes(void) const;</span>

<span class="s0">2889 9 get_plane 0 4 3680 26 ClipPlaneAttrib::get_plane 0 1 1202 227</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth plane listed in the attribute.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and</span>
 <span class="s0">* off_planes, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">PlaneNode *ClipPlaneAttrib::get_plane(int n) const;</span>

<span class="s0">2890 9 has_plane 0 4 3680 26 ClipPlaneAttrib::has_plane 0 1 1203 261</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated plane is listed in the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and</span>
 <span class="s0">* off_planes, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">bool ClipPlaneAttrib::has_plane(PlaneNode *plane) const;</span>

<span class="s0">2891 9 add_plane 0 4 3680 26 ClipPlaneAttrib::add_plane 0 1 1204 187</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane added to the list of planes.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::add_plane(PlaneNode *plane) const;</span>

<span class="s0">2892 12 remove_plane 0 4 3680 29 ClipPlaneAttrib::remove_plane 0 1 1205 197</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane removed from the list of planes.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use remove_on_plane() or remove_off_plane() instead.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::remove_plane(PlaneNode *plane) const;</span>

<span class="s0">2893 12 make_all_off 0 4 3680 29 ClipPlaneAttrib::make_all_off 0 1 1206 109</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that disables all planes (and hence</span>
 <span class="s0">* disables clipping).</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::make_all_off(void);</span>

<span class="s0">2894 17 get_num_on_planes 0 4 3680 34 ClipPlaneAttrib::get_num_on_planes 0 1 1207 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of planes that are enabled by the attribute.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int ClipPlaneAttrib::get_num_on_planes(void) const;</span>

<span class="s0">2895 12 get_on_plane 0 4 3680 29 ClipPlaneAttrib::get_on_plane 0 1 1208 82</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth plane enabled by the attribute, sorted in render order.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline NodePath ClipPlaneAttrib::get_on_plane(int n) const;</span>

<span class="s0">2896 12 has_on_plane 0 4 3680 29 ClipPlaneAttrib::has_on_plane 0 1 1209 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated plane is enabled by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline bool ClipPlaneAttrib::has_on_plane(NodePath const &amp;plane) const;</span>

<span class="s0">2897 18 get_num_off_planes 0 4 3680 35 ClipPlaneAttrib::get_num_off_planes 0 1 1210 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of planes that are disabled by the attribute.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int ClipPlaneAttrib::get_num_off_planes(void) const;</span>

<span class="s0">2898 13 get_off_plane 0 4 3680 30 ClipPlaneAttrib::get_off_plane 0 1 1211 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth plane disabled by the attribute, sorted in arbitrary</span>
 <span class="s0">* (pointer) order.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline NodePath ClipPlaneAttrib::get_off_plane(int n) const;</span>

<span class="s0">2899 13 has_off_plane 0 4 3680 30 ClipPlaneAttrib::has_off_plane 0 1 1212 93</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated plane is disabled by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline bool ClipPlaneAttrib::has_off_plane(NodePath const &amp;plane) const;</span>

<span class="s0">2900 11 has_all_off 0 4 3680 28 ClipPlaneAttrib::has_all_off 0 1 1213 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this attrib disables all planes (although it may also</span>
 <span class="s0">* enable some).</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool ClipPlaneAttrib::has_all_off(void) const;</span>

<span class="s0">2901 11 is_identity 0 4 3680 28 ClipPlaneAttrib::is_identity 0 1 1214 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is an identity attrib: it does not change the set of</span>
 <span class="s0">* planes in use.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool ClipPlaneAttrib::is_identity(void) const;</span>

<span class="s0">2902 12 add_on_plane 0 4 3680 29 ClipPlaneAttrib::add_on_plane 0 1 1215 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane added to the list of planes enabled by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::add_on_plane(NodePath const &amp;plane) const;</span>

<span class="s0">2903 15 remove_on_plane 0 4 3680 32 ClipPlaneAttrib::remove_on_plane 0 1 1216 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane removed from the list of planes enabled by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::remove_on_plane(NodePath const &amp;plane) const;</span>

<span class="s0">2904 13 add_off_plane 0 4 3680 30 ClipPlaneAttrib::add_off_plane 0 1 1217 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane added to the list of planes disabled by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::add_off_plane(NodePath const &amp;plane) const;</span>

<span class="s0">2905 16 remove_off_plane 0 4 3680 33 ClipPlaneAttrib::remove_off_plane 0 1 1218 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane removed from the list of planes disabled by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ClipPlaneAttrib::remove_off_plane(NodePath const &amp;plane) const;</span>

<span class="s0">2906 13 filter_to_max 0 4 3680 30 ClipPlaneAttrib::filter_to_max 0 1 1219 216</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, very much like this one, but with the number</span>
 <span class="s0">* of on_planes reduced to be no more than max_clip_planes.  The number of</span>
 <span class="s0">* off_planes in the new ClipPlaneAttrib is undefined.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">ConstPointerTo&lt; ClipPlaneAttrib &gt; ClipPlaneAttrib::filter_to_max(int max_clip_planes) const;</span>

<span class="s0">2907 14 get_class_slot 0 4 3680 31 ClipPlaneAttrib::get_class_slot 0 1 1220 0</span>
<span class="s0">49</span>
<span class="s0">static int ClipPlaneAttrib::get_class_slot(void);</span>

<span class="s0">2908 14 get_class_type 0 4 3680 31 ClipPlaneAttrib::get_class_type 0 1 1221 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle ClipPlaneAttrib::get_class_type(void);</span>

<span class="s0">2909 16 ~ClipPlaneAttrib 0 516 3680 33 ClipPlaneAttrib::~ClipPlaneAttrib 0 0 0</span>
<span class="s0">40</span>
<span class="s0">ClipPlaneAttrib::~ClipPlaneAttrib(void);</span>

<span class="s0">2910 11 make_vertex 0 4 3682 24 ColorAttrib::make_vertex 0 1 1222 127</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorAttrib object that indicates geometry should be</span>
 <span class="s0">* rendered according to its own vertex color.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorAttrib::make_vertex(void);</span>

<span class="s0">2911 9 make_flat 0 4 3682 22 ColorAttrib::make_flat 0 1 1223 116</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorAttrib object that indicates geometry should be</span>
 <span class="s0">* rendered in the indicated color.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorAttrib::make_flat(LColor const &amp;color);</span>

<span class="s0">2912 8 make_off 0 4 3682 21 ColorAttrib::make_off 0 1 1224 102</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorAttrib object that indicates geometry should be</span>
 <span class="s0">* rendered in white.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorAttrib::make_off(void);</span>

<span class="s0">2913 12 make_default 0 4 3682 25 ColorAttrib::make_default 0 1 1225 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorAttrib::make_default(void);</span>

<span class="s0">2914 14 get_color_type 0 4 3682 27 ColorAttrib::get_color_type 0 1 1226 313</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of color specified by this ColorAttrib.  The options are:</span>
 <span class="s0">*</span>
 <span class="s0">* T_vertex - use the vertex color specified in the geometry itself.</span>
 <span class="s0">*</span>
 <span class="s0">* T_flat - use the color specified in this ColorAttrib for all geometry.  You</span>
 <span class="s0">* can get this color via get_color().</span>
 <span class="s0">*</span>
 <span class="s0">* T_off - use the color white.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline ColorAttrib::Type ColorAttrib::get_color_type(void) const;</span>

<span class="s0">2915 9 get_color 0 4 3682 22 ColorAttrib::get_color 0 1 1227 149</span>
<span class="s0">/**</span>
 <span class="s0">* If the type is T_flat or T_off, this returns the color that will be applied</span>
 <span class="s0">* to geometry.  If the type is T_vertex, this is meaningless.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LColor const &amp;ColorAttrib::get_color(void) const;</span>

<span class="s0">2916 14 get_class_slot 0 4 3682 27 ColorAttrib::get_class_slot 0 1 1228 0</span>
<span class="s0">45</span>
<span class="s0">static int ColorAttrib::get_class_slot(void);</span>

<span class="s0">2917 14 get_class_type 0 4 3682 27 ColorAttrib::get_class_type 0 1 1229 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle ColorAttrib::get_class_type(void);</span>

<span class="s0">2918 12 ~ColorAttrib 0 516 3682 25 ColorAttrib::~ColorAttrib 0 0 0</span>
<span class="s0">32</span>
<span class="s0">ColorAttrib::~ColorAttrib(void);</span>

<span class="s0">2919 8 make_off 0 4 3684 26 ColorBlendAttrib::make_off 0 1 1230 142</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorBlendAttrib object that disables special-effect</span>
 <span class="s0">* blending, allowing normal transparency to be used instead.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorBlendAttrib::make_off(void);</span>

<span class="s0">2920 4 make 0 4 3684 22 ColorBlendAttrib::make 0 3 1231 1232 1233 546</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorBlendAttrib object.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use the three- or four-parameter constructor instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorBlendAttrib object that enables special-effect</span>
 <span class="s0">* blending.  This supercedes transparency.  The given mode and operands are</span>
 <span class="s0">* used for both the RGB and alpha channels.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorBlendAttrib object that enables special-effect</span>
 <span class="s0">* blending.  This supercedes transparency.  This form is used to specify</span>
 <span class="s0">* separate blending parameters for the RGB and alpha channels.</span>
 <span class="s0">*/</span>
<span class="s0">581</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorBlendAttrib::make(ColorBlendAttrib::Mode mode);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorBlendAttrib::make(ColorBlendAttrib::Mode mode, ColorBlendAttrib::Operand a, ColorBlendAttrib::Operand b, LColor const &amp;color = LColor::zero());</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorBlendAttrib::make(ColorBlendAttrib::Mode rgb_mode, ColorBlendAttrib::Operand rgb_a, ColorBlendAttrib::Operand rgb_b, ColorBlendAttrib::Mode alpha_mode, ColorBlendAttrib::Operand alpha_a, ColorBlendAttrib::Operand alpha_b, LColor const &amp;color = LColor::zero());</span>

<span class="s0">2921 12 make_default 0 4 3684 30 ColorBlendAttrib::make_default 0 1 1234 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorBlendAttrib::make_default(void);</span>

<span class="s0">2922 8 get_mode 0 4 3684 26 ColorBlendAttrib::get_mode 0 1 1235 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the blending mode for the RGB channels.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline ColorBlendAttrib::Mode ColorBlendAttrib::get_mode(void) const;</span>

<span class="s0">2923 13 get_operand_a 0 4 3684 31 ColorBlendAttrib::get_operand_a 0 1 1236 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the RGB multiplier for the first component.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline ColorBlendAttrib::Operand ColorBlendAttrib::get_operand_a(void) const;</span>

<span class="s0">2924 13 get_operand_b 0 4 3684 31 ColorBlendAttrib::get_operand_b 0 1 1237 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the RGB multiplier for the second component.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline ColorBlendAttrib::Operand ColorBlendAttrib::get_operand_b(void) const;</span>

<span class="s0">2925 14 get_alpha_mode 0 4 3684 32 ColorBlendAttrib::get_alpha_mode 0 1 1238 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the blending mode for the alpha channel.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline ColorBlendAttrib::Mode ColorBlendAttrib::get_alpha_mode(void) const;</span>

<span class="s0">2926 19 get_alpha_operand_a 0 4 3684 37 ColorBlendAttrib::get_alpha_operand_a 0 1 1239 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alpha multiplier for the first component.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline ColorBlendAttrib::Operand ColorBlendAttrib::get_alpha_operand_a(void) const;</span>

<span class="s0">2927 19 get_alpha_operand_b 0 4 3684 37 ColorBlendAttrib::get_alpha_operand_b 0 1 1240 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the alpha multiplier for the second component.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline ColorBlendAttrib::Operand ColorBlendAttrib::get_alpha_operand_b(void) const;</span>

<span class="s0">2928 9 get_color 0 4 3684 27 ColorBlendAttrib::get_color 0 1 1241 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the constant color associated with the attrib.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LColor ColorBlendAttrib::get_color(void) const;</span>

<span class="s0">2929 23 involves_constant_color 0 4 3684 41 ColorBlendAttrib::involves_constant_color 0 2 1242 1243 179</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the this attrib uses the constant color, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated operand uses the constant color, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">163</span>
<span class="s0">inline bool ColorBlendAttrib::involves_constant_color(void) const;</span>
<span class="s0">static inline bool ColorBlendAttrib::involves_constant_color(ColorBlendAttrib::Operand operand);</span>

<span class="s0">2930 20 involves_color_scale 0 4 3684 38 ColorBlendAttrib::involves_color_scale 0 2 1244 1245 190</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the this attrib uses the color scale attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated operand uses the color scale attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">inline bool ColorBlendAttrib::involves_color_scale(void) const;</span>
<span class="s0">static inline bool ColorBlendAttrib::involves_color_scale(ColorBlendAttrib::Operand operand);</span>

<span class="s0">2931 14 get_class_slot 0 4 3684 32 ColorBlendAttrib::get_class_slot 0 1 1246 0</span>
<span class="s0">50</span>
<span class="s0">static int ColorBlendAttrib::get_class_slot(void);</span>

<span class="s0">2932 14 get_class_type 0 4 3684 32 ColorBlendAttrib::get_class_type 0 1 1247 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle ColorBlendAttrib::get_class_type(void);</span>

<span class="s0">2933 17 ~ColorBlendAttrib 0 516 3684 35 ColorBlendAttrib::~ColorBlendAttrib 0 0 0</span>
<span class="s0">42</span>
<span class="s0">ColorBlendAttrib::~ColorBlendAttrib(void);</span>

<span class="s0">2934 13 make_identity 0 4 3687 31 ColorScaleAttrib::make_identity 0 1 1248 47</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs an identity scale attrib.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorScaleAttrib::make_identity(void);</span>

<span class="s0">2935 4 make 0 4 3687 22 ColorScaleAttrib::make 0 1 1249 120</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorScaleAttrib object that indicates geometry should be</span>
 <span class="s0">* scaled by the indicated factor.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorScaleAttrib::make(LVecBase4 const &amp;scale);</span>

<span class="s0">2936 8 make_off 0 4 3687 26 ColorScaleAttrib::make_off 0 1 1250 209</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorScaleAttrib object that ignores any ColorScaleAttrib</span>
 <span class="s0">* inherited from above.  You may also specify an additional color scale to</span>
 <span class="s0">* apply to geometry below (using set_scale()).</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorScaleAttrib::make_off(void);</span>

<span class="s0">2937 12 make_default 0 4 3687 30 ColorScaleAttrib::make_default 0 1 1251 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorScaleAttrib::make_default(void);</span>

<span class="s0">2938 6 is_off 0 4 3687 24 ColorScaleAttrib::is_off 0 1 1252 255</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib will ignore any color scales inherited</span>
 <span class="s0">* from above, false otherwise.  This is not the same thing as !has_scale(); a</span>
 <span class="s0">* ColorScaleAttrib may have the &quot;off&quot; flag set and also have another scale</span>
 <span class="s0">* specified.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool ColorScaleAttrib::is_off(void) const;</span>

<span class="s0">2939 11 is_identity 0 4 3687 29 ColorScaleAttrib::is_identity 0 1 1253 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib is an identity attrib, false if it is</span>
 <span class="s0">* either an off attrib or it has a scale.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool ColorScaleAttrib::is_identity(void) const;</span>

<span class="s0">2940 9 has_scale 0 4 3687 27 ColorScaleAttrib::has_scale 0 1 1254 157</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib has a non-identity scale, false</span>
 <span class="s0">* otherwise (in which case it might be an off attrib or an identity attrib).</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool ColorScaleAttrib::has_scale(void) const;</span>

<span class="s0">2941 13 has_rgb_scale 0 4 3687 31 ColorScaleAttrib::has_rgb_scale 0 1 1255 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib has a non-identity scale in the RGB</span>
 <span class="s0">* components (ignoring alpha), or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool ColorScaleAttrib::has_rgb_scale(void) const;</span>

<span class="s0">2942 15 has_alpha_scale 0 4 3687 33 ColorScaleAttrib::has_alpha_scale 0 1 1256 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib has a non-identity scale in the alpha</span>
 <span class="s0">* component (ignoring RGB), or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool ColorScaleAttrib::has_alpha_scale(void) const;</span>

<span class="s0">2943 9 get_scale 0 4 3687 27 ColorScaleAttrib::get_scale 0 1 1257 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scale to be applied to colors.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline LVecBase4 const &amp;ColorScaleAttrib::get_scale(void) const;</span>

<span class="s0">2944 9 set_scale 0 4 3687 27 ColorScaleAttrib::set_scale 0 1 1258 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ColorScaleAttrib, just like this one, but with the scale</span>
 <span class="s0">* changed to the indicated value.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ColorScaleAttrib::set_scale(LVecBase4 const &amp;scale) const;</span>

<span class="s0">2945 14 get_class_slot 0 4 3687 32 ColorScaleAttrib::get_class_slot 0 1 1259 0</span>
<span class="s0">50</span>
<span class="s0">static int ColorScaleAttrib::get_class_slot(void);</span>

<span class="s0">2946 14 get_class_type 0 4 3687 32 ColorScaleAttrib::get_class_type 0 1 1260 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle ColorScaleAttrib::get_class_type(void);</span>

<span class="s0">2947 17 ~ColorScaleAttrib 0 516 3687 35 ColorScaleAttrib::~ColorScaleAttrib 0 0 0</span>
<span class="s0">42</span>
<span class="s0">ColorScaleAttrib::~ColorScaleAttrib(void);</span>

<span class="s0">2948 4 make 0 4 3690 22 ColorWriteAttrib::make 0 1 1261 52</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ColorWriteAttrib object.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorWriteAttrib::make(unsigned int channels);</span>

<span class="s0">2949 12 make_default 0 4 3690 30 ColorWriteAttrib::make_default 0 1 1262 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ColorWriteAttrib::make_default(void);</span>

<span class="s0">2950 12 get_channels 0 4 3690 30 ColorWriteAttrib::get_channels 0 1 1263 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the mask of color channels that are enabled by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline unsigned int ColorWriteAttrib::get_channels(void) const;</span>

<span class="s0">2951 14 get_class_slot 0 4 3690 32 ColorWriteAttrib::get_class_slot 0 1 1264 0</span>
<span class="s0">50</span>
<span class="s0">static int ColorWriteAttrib::get_class_slot(void);</span>

<span class="s0">2952 14 get_class_type 0 4 3690 32 ColorWriteAttrib::get_class_type 0 1 1265 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle ColorWriteAttrib::get_class_type(void);</span>

<span class="s0">2953 17 ~ColorWriteAttrib 0 516 3690 35 ColorWriteAttrib::~ColorWriteAttrib 0 0 0</span>
<span class="s0">42</span>
<span class="s0">ColorWriteAttrib::~ColorWriteAttrib(void);</span>

<span class="s0">2954 4 make 0 4 3693 19 CompassEffect::make 0 1 1266 354</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new CompassEffect object.  If the reference is an empty</span>
 <span class="s0">* NodePath, it means the CompassEffect is relative to the root of the scene</span>
 <span class="s0">* graph; otherwise, it's relative to the indicated node.  The properties</span>
 <span class="s0">* bitmask specifies the set of properties that the compass node inherits from</span>
 <span class="s0">* the reference instead of from its parent.</span>
 <span class="s0">*/</span>
<span class="s0">126</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; CompassEffect::make(NodePath const &amp;reference, int properties = ::CompassEffect::P_rot);</span>

<span class="s0">2955 13 get_reference 0 4 3693 28 CompassEffect::get_reference 0 1 1267 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the reference node from which the CompassEffect inherits its</span>
 <span class="s0">* transform.  If this is empty, it means the root of the scene graph.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline NodePath const &amp;CompassEffect::get_reference(void) const;</span>

<span class="s0">2956 14 get_properties 0 4 3693 29 CompassEffect::get_properties 0 1 1268 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bitmask of properties that this CompassEffect object inherits</span>
 <span class="s0">* from its reference node (or from the root).</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int CompassEffect::get_properties(void) const;</span>

<span class="s0">2957 14 get_class_type 0 4 3693 29 CompassEffect::get_class_type 0 1 1269 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle CompassEffect::get_class_type(void);</span>

<span class="s0">2958 14 ~CompassEffect 0 516 3693 29 CompassEffect::~CompassEffect 0 0 0</span>
<span class="s0">36</span>
<span class="s0">CompassEffect::~CompassEffect(void);</span>

<span class="s0">2959 12 CullBinEnums 0 260 3695 26 CullBinEnums::CullBinEnums 0 2 1270 1271 0</span>
<span class="s0">117</span>
<span class="s0">inline CullBinEnums::CullBinEnums(void) = default;</span>
<span class="s0">inline CullBinEnums::CullBinEnums(CullBinEnums const &amp;) = default;</span>

<span class="s0">2960 13 ~CullBinEnums 0 516 3695 27 CullBinEnums::~CullBinEnums 0 0 0</span>
<span class="s0">34</span>
<span class="s0">CullBinEnums::~CullBinEnums(void);</span>

<span class="s0">2961 8 GeomNode 0 260 3697 18 GeomNode::GeomNode 0 1 1272 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">explicit GeomNode::GeomNode(std::string const &amp;name);</span>

<span class="s0">2962 13 set_preserved 0 4 3697 23 GeomNode::set_preserved 0 1 1273 123</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;preserved&quot; flag.  When this is true, the GeomNode will be left</span>
 <span class="s0">* untouched by any flatten operations.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void GeomNode::set_preserved(bool value);</span>

<span class="s0">2963 13 get_preserved 0 4 3697 23 GeomNode::get_preserved 0 1 1274 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;preserved&quot; flag.  When this is true, the GeomNode will be left</span>
 <span class="s0">* untouched by any flatten operations.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool GeomNode::get_preserved(void) const;</span>

<span class="s0">2964 13 get_num_geoms 0 4 3697 23 GeomNode::get_num_geoms 0 1 1275 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of geoms in the node.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int GeomNode::get_num_geoms(void) const;</span>

<span class="s0">2965 8 get_geom 0 4 3697 18 GeomNode::get_geom 0 1 1276 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth geom of the node.  This object should not be modified,</span>
 <span class="s0">* since the same object might be shared between multiple different GeomNodes,</span>
 <span class="s0">* but see modify_geom().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline ConstPointerTo&lt; Geom &gt; GeomNode::get_geom(int n) const;</span>

<span class="s0">2966 11 modify_geom 0 4 3697 21 GeomNode::modify_geom 0 1 1277 641</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth geom of the node, suitable for modifying it.  If the nth</span>
 <span class="s0">* Geom has multiple reference counts to it, reassigns it to an identical copy</span>
 <span class="s0">* first, and returns the new copy--this provides a &quot;copy on write&quot; that</span>
 <span class="s0">* ensures that the Geom that is returned is unique to this GeomNode and is</span>
 <span class="s0">* not shared with any other GeomNodes.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this method is called in a downstream stage (for instance,</span>
 <span class="s0">* during cull or draw), then it will propagate the new list of Geoms upstream</span>
 <span class="s0">* all the way to pipeline stage 0, which may step on changes that were made</span>
 <span class="s0">* independently in pipeline stage 0. Use with caution.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PointerTo&lt; Geom &gt; GeomNode::modify_geom(int n);</span>

<span class="s0">2967 14 get_geom_state 0 4 3697 24 GeomNode::get_geom_state 0 1 1278 296</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the RenderState associated with the nth geom of the node.  This is</span>
 <span class="s0">* just the RenderState directly associated with the Geom; the actual state in</span>
 <span class="s0">* which the Geom is rendered will also be affected by RenderStates that</span>
 <span class="s0">* appear on the scene graph in nodes above this GeomNode.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline RenderState const *GeomNode::get_geom_state(int n) const;</span>

<span class="s0">2968 14 set_geom_state 0 4 3697 24 GeomNode::set_geom_state 0 1 1279 586</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the RenderState associated with the nth geom of the node.  This is</span>
 <span class="s0">* just the RenderState directly associated with the Geom; the actual state in</span>
 <span class="s0">* which the Geom is rendered will also be affected by RenderStates that</span>
 <span class="s0">* appear on the scene graph in nodes above this GeomNode.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this method is called in a downstream stage (for instance,</span>
 <span class="s0">* during cull or draw), then it will propagate the new list of Geoms upstream</span>
 <span class="s0">* all the way to pipeline stage 0, which may step on changes that were made</span>
 <span class="s0">* independently in pipeline stage 0. Use with caution.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void GeomNode::set_geom_state(int n, RenderState const *state);</span>

<span class="s0">2969 8 add_geom 0 4 3697 18 GeomNode::add_geom 0 1 1280 180</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new Geom to the node.  The geom is given the indicated state (which</span>
 <span class="s0">* may be RenderState::make_empty(), to completely inherit its state from the</span>
 <span class="s0">* scene graph).</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">void GeomNode::add_geom(Geom *geom, RenderState const *state = RenderState::make_empty());</span>

<span class="s0">2970 14 add_geoms_from 0 4 3697 24 GeomNode::add_geoms_from 0 1 1281 109</span>
<span class="s0">/**</span>
 <span class="s0">* Copies the Geoms (and their associated RenderStates) from the indicated</span>
 <span class="s0">* GeomNode into this one.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void GeomNode::add_geoms_from(GeomNode const *other);</span>

<span class="s0">2971 8 set_geom 0 4 3697 18 GeomNode::set_geom 0 1 1282 401</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the nth Geom of the node with a new pointer.  There must already</span>
 <span class="s0">* be a Geom in this slot.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this method is called in a downstream stage (for instance,</span>
 <span class="s0">* during cull or draw), then it will propagate the new list of Geoms upstream</span>
 <span class="s0">* all the way to pipeline stage 0, which may step on changes that were made</span>
 <span class="s0">* independently in pipeline stage 0. Use with caution.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void GeomNode::set_geom(int n, Geom *geom);</span>

<span class="s0">2972 11 remove_geom 0 4 3697 21 GeomNode::remove_geom 0 1 1283 46</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the nth geom from the node.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void GeomNode::remove_geom(int n);</span>

<span class="s0">2973 16 remove_all_geoms 0 4 3697 26 GeomNode::remove_all_geoms 0 1 1284 55</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the geoms from the node at once.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void GeomNode::remove_all_geoms(void);</span>

<span class="s0">2974 11 check_valid 0 4 3697 21 GeomNode::check_valid 0 1 1285 198</span>
<span class="s0">/**</span>
 <span class="s0">* Verifies that the each Geom within the GeomNode reference vertices that</span>
 <span class="s0">* actually exist within its GeomVertexData.  Returns true if the GeomNode</span>
 <span class="s0">* appears to be valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">bool GeomNode::check_valid(void) const;</span>

<span class="s0">2975 9 decompose 0 4 3697 19 GeomNode::decompose 0 1 1286 431</span>
<span class="s0">/**</span>
 <span class="s0">* Calls decompose() on each Geom with the GeomNode.  This decomposes higher-</span>
 <span class="s0">* order primitive types, like triangle strips, into lower-order types like</span>
 <span class="s0">* indexed triangles.  Normally there is no reason to do this, but it can be</span>
 <span class="s0">* useful as an early preprocessing step, to allow a later call to unify() to</span>
 <span class="s0">* proceed more quickly.</span>
 <span class="s0">*</span>
 <span class="s0">* See also SceneGraphReducer::decompose(), which is the normal way this is</span>
 <span class="s0">* called.</span>
 <span class="s0">*/</span>
<span class="s0">31</span>
<span class="s0">void GeomNode::decompose(void);</span>

<span class="s0">2976 5 unify 0 4 3697 15 GeomNode::unify 0 1 1287 901</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to unify all of the Geoms contained within this node into a single</span>
 <span class="s0">* Geom, or at least as few Geoms as possible.  In turn, the individual</span>
 <span class="s0">* GeomPrimitives contained within each resulting Geom are also unified.  The</span>
 <span class="s0">* goal is to reduce the number of GeomPrimitives within the node as far as</span>
 <span class="s0">* possible.  This may result in composite primitives, such as triangle strips</span>
 <span class="s0">* and triangle fans, being decomposed into triangles.  See also</span>
 <span class="s0">* Geom::unify().</span>
 <span class="s0">*</span>
 <span class="s0">* max_indices represents the maximum number of indices that will be put in</span>
 <span class="s0">* any one GeomPrimitive.  If preserve_order is true, then the primitives will</span>
 <span class="s0">* not be reordered during the operation, even if this results in a suboptimal</span>
 <span class="s0">* result.</span>
 <span class="s0">*</span>
 <span class="s0">* In order for this to be successful, the primitives must reference the same</span>
 <span class="s0">* GeomVertexData, have the same fundamental primitive type, and have</span>
 <span class="s0">* compatible shade models.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void GeomNode::unify(int max_indices, bool preserve_order);</span>

<span class="s0">2977 11 write_geoms 0 4 3697 21 GeomNode::write_geoms 0 1 1288 67</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a short description of all the Geoms in the node.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void GeomNode::write_geoms(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2978 13 write_verbose 0 4 3697 23 GeomNode::write_verbose 0 1 1289 70</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a detailed description of all the Geoms in the node.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void GeomNode::write_verbose(std::ostream &amp;out, int indent_level) const;</span>

<span class="s0">2979 24 get_default_collide_mask 0 4 3697 34 GeomNode::get_default_collide_mask 0 1 1290 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default into_collide_mask assigned to new GeomNodes.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">static inline CollideMask GeomNode::get_default_collide_mask(void);</span>

<span class="s0">2980 14 get_class_type 0 4 3697 24 GeomNode::get_class_type 0 1 1291 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle GeomNode::get_class_type(void);</span>

<span class="s0">2981 4 make 0 4 3698 19 CullBinAttrib::make 0 1 1292 297</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new CullBinAttrib assigning geometry into the named bin.  If</span>
 <span class="s0">* the bin name is the empty string, the default bin is used.</span>
 <span class="s0">*</span>
 <span class="s0">* The draw_order specifies further ordering information which is relevant</span>
 <span class="s0">* only to certain kinds of bins (in particular CullBinFixed type bins).</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; CullBinAttrib::make(std::string const &amp;bin_name, int draw_order);</span>

<span class="s0">2982 12 make_default 0 4 3698 27 CullBinAttrib::make_default 0 1 1293 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; CullBinAttrib::make_default(void);</span>

<span class="s0">2983 12 get_bin_name 0 4 3698 27 CullBinAttrib::get_bin_name 0 1 1294 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the bin this attribute specifies.  If this is the empty</span>
 <span class="s0">* string, it refers to the default bin.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline std::string const &amp;CullBinAttrib::get_bin_name(void) const;</span>

<span class="s0">2984 14 get_draw_order 0 4 3698 29 CullBinAttrib::get_draw_order 0 1 1295 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the draw order this attribute specifies.  Some bins (in particular,</span>
 <span class="s0">* CullBinFixed bins) use this to further specify the order in which objects</span>
 <span class="s0">* should be rendered.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int CullBinAttrib::get_draw_order(void) const;</span>

<span class="s0">2985 14 get_class_slot 0 4 3698 29 CullBinAttrib::get_class_slot 0 1 1296 0</span>
<span class="s0">47</span>
<span class="s0">static int CullBinAttrib::get_class_slot(void);</span>

<span class="s0">2986 14 get_class_type 0 4 3698 29 CullBinAttrib::get_class_type 0 1 1297 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle CullBinAttrib::get_class_type(void);</span>

<span class="s0">2987 14 ~CullBinAttrib 0 516 3698 29 CullBinAttrib::~CullBinAttrib 0 0 0</span>
<span class="s0">36</span>
<span class="s0">CullBinAttrib::~CullBinAttrib(void);</span>

<span class="s0">2988 7 add_bin 0 4 3699 23 CullBinManager::add_bin 0 1 1298 232</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a new bin with the indicated name, and returns the new bin_index.</span>
 <span class="s0">* If there is already a bin with the same name returns its bin_index if it</span>
 <span class="s0">* had the same properties; otherwise, reports an error and returns -1.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">int CullBinManager::add_bin(std::string const &amp;name, CullBinManager::BinType type, int sort);</span>

<span class="s0">2989 10 remove_bin 0 4 3699 26 CullBinManager::remove_bin 0 1 1299 357</span>
<span class="s0">/**</span>
 <span class="s0">* Permanently removes the indicated bin.  This operation is not protected</span>
 <span class="s0">* from the pipeline and will disturb whatever is currently rendering in draw.</span>
 <span class="s0">* You should not call this during the normal course of rendering a frame; it</span>
 <span class="s0">* is intended only as an aid to development, to allow the developer to</span>
 <span class="s0">* interactively fiddle with the set of bins.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void CullBinManager::remove_bin(int bin_index);</span>

<span class="s0">2990 12 get_num_bins 0 4 3699 28 CullBinManager::get_num_bins 0 1 1300 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bins in the world.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int CullBinManager::get_num_bins(void) const;</span>

<span class="s0">2991 7 get_bin 0 4 3699 23 CullBinManager::get_bin 0 1 1301 240</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bin_index of the nth bin in the set, where n is a number</span>
 <span class="s0">* between 0 and get_num_bins(). This returns the list of bin_index numbers,</span>
 <span class="s0">* in sorted order (that is, in the order in which the bins should be</span>
 <span class="s0">* rendered).</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int CullBinManager::get_bin(int n) const;</span>

<span class="s0">2992 8 find_bin 0 4 3699 24 CullBinManager::find_bin 0 1 1302 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bin_index associated with the bin of the given name, or -1 if</span>
 <span class="s0">* no bin has that name.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">int CullBinManager::find_bin(std::string const &amp;name) const;</span>

<span class="s0">2993 12 get_bin_name 0 4 3699 28 CullBinManager::get_bin_name 0 1 1303 196</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the bin with the indicated bin_index (where bin_index</span>
 <span class="s0">* was retrieved by get_bin() or find_bin()).  The bin's name may not be</span>
 <span class="s0">* changed during the life of the bin.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline std::string CullBinManager::get_bin_name(int bin_index) const;</span>

<span class="s0">2994 12 get_bin_type 0 4 3699 28 CullBinManager::get_bin_type 0 2 1304 1305 195</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of the bin with the indicated bin_index (where bin_index</span>
 <span class="s0">* was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the type of the bin with the indicated name.</span>
 <span class="s0">*/</span>
<span class="s0">173</span>
<span class="s0">inline CullBinManager::BinType CullBinManager::get_bin_type(int bin_index) const;</span>
<span class="s0">inline CullBinManager::BinType CullBinManager::get_bin_type(std::string const &amp;name) const;</span>

<span class="s0">2995 12 set_bin_type 0 4 3699 28 CullBinManager::set_bin_type 0 2 1306 1307 423</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the type of the bin with the indicated bin_index (where bin_index</span>
 <span class="s0">* was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* The change might be effective immediately, or it might take place next</span>
 <span class="s0">* frame, depending on the bin type.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes the type of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* The change might be effective immediately, or it might take place next</span>
 <span class="s0">* frame, depending on the bin type.</span>
 <span class="s0">*/</span>
<span class="s0">183</span>
<span class="s0">inline void CullBinManager::set_bin_type(int bin_index, CullBinManager::BinType type);</span>
<span class="s0">inline void CullBinManager::set_bin_type(std::string const &amp;name, CullBinManager::BinType type);</span>

<span class="s0">2996 12 get_bin_sort 0 4 3699 28 CullBinManager::get_bin_sort 0 2 1308 1309 483</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sort order of the bin with the indicated bin_index (where</span>
 <span class="s0">* bin_index was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* The bins are rendered in increasing order by their sort order; this number</span>
 <span class="s0">* may be changed from time to time to reorder the bins.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the sort order of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* The bins are rendered in increasing order by their sort order; this number</span>
 <span class="s0">* may be changed from time to time to reorder the bins.</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">inline int CullBinManager::get_bin_sort(int bin_index) const;</span>
<span class="s0">inline int CullBinManager::get_bin_sort(std::string const &amp;name) const;</span>

<span class="s0">2997 12 set_bin_sort 0 4 3699 28 CullBinManager::set_bin_sort 0 2 1310 1311 483</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the sort order of the bin with the indicated bin_index (where</span>
 <span class="s0">* bin_index was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* The bins are rendered in increasing order by their sort order; this number</span>
 <span class="s0">* may be changed from time to time to reorder the bins.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes the sort order of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* The bins are rendered in increasing order by their sort order; this number</span>
 <span class="s0">* may be changed from time to time to reorder the bins.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">inline void CullBinManager::set_bin_sort(int bin_index, int sort);</span>
<span class="s0">inline void CullBinManager::set_bin_sort(std::string const &amp;name, int sort);</span>

<span class="s0">2998 14 get_bin_active 0 4 3699 30 CullBinManager::get_bin_active 0 2 1312 1313 373</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the active flag of the bin with the indicated bin_index (where</span>
 <span class="s0">* bin_index was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* When a bin is marked inactive, all geometry assigned to it is not rendered.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the active flag of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* When a bin is marked inactive, all geometry assigned to it is not rendered.</span>
 <span class="s0">*/</span>
<span class="s0">139</span>
<span class="s0">inline bool CullBinManager::get_bin_active(int bin_index) const;</span>
<span class="s0">inline bool CullBinManager::get_bin_active(std::string const &amp;name) const;</span>

<span class="s0">2999 14 set_bin_active 0 4 3699 30 CullBinManager::set_bin_active 0 2 1314 1315 373</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the active flag of the bin with the indicated bin_index (where</span>
 <span class="s0">* bin_index was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* When a bin is marked inactive, all geometry assigned to it is not rendered.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Changes the active flag of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* When a bin is marked inactive, all geometry assigned to it is not rendered.</span>
 <span class="s0">*/</span>
<span class="s0">153</span>
<span class="s0">inline void CullBinManager::set_bin_active(int bin_index, bool active);</span>
<span class="s0">inline void CullBinManager::set_bin_active(std::string const &amp;name, bool active);</span>

<span class="s0">3000 20 get_bin_flash_active 0 4 3699 36 CullBinManager::get_bin_flash_active 0 1 1316 227</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the bin with the given bin_index is configured to flash at</span>
 <span class="s0">* a predetermined color (where bin_index was retrieved by get_bin() or</span>
 <span class="s0">* find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not available in release builds.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline bool CullBinManager::get_bin_flash_active(int bin_index) const;</span>

<span class="s0">3001 19 get_bin_flash_color 0 4 3699 35 CullBinManager::get_bin_flash_color 0 1 1317 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color that this bin has been configured to flash to, if</span>
 <span class="s0">* configured.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not available in release builds.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline LColor const &amp;CullBinManager::get_bin_flash_color(int bin_index) const;</span>

<span class="s0">3002 20 set_bin_flash_active 0 4 3699 36 CullBinManager::set_bin_flash_active 0 1 1318 216</span>
<span class="s0">/**</span>
 <span class="s0">* When set to true, the given bin_index is configured to flash at a</span>
 <span class="s0">* predetermined color (where bin_index was retrieved by get_bin() or</span>
 <span class="s0">* find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not available in release builds.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void CullBinManager::set_bin_flash_active(int bin_index, bool active);</span>

<span class="s0">3003 19 set_bin_flash_color 0 4 3699 35 CullBinManager::set_bin_flash_color 0 1 1319 113</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the flash color for the given bin index.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not available in release builds.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline void CullBinManager::set_bin_flash_color(int bin_index, LColor const &amp;color);</span>

<span class="s0">3004 5 write 0 4 3699 21 CullBinManager::write 0 1 1320 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void CullBinManager::write(std::ostream &amp;out) const;</span>

<span class="s0">3005 14 get_global_ptr 0 4 3699 30 CullBinManager::get_global_ptr 0 1 1321 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer to the global CullBinManager object.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">static inline CullBinManager *CullBinManager::get_global_ptr(void);</span>

<span class="s0">3006 4 make 0 4 3700 20 CullFaceAttrib::make 0 1 1322 400</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new CullFaceAttrib object that specifies how to cull geometry.</span>
 <span class="s0">* By Panda convention, vertices are ordered counterclockwise when seen from</span>
 <span class="s0">* the front, so the M_cull_clockwise will cull backfacing polygons.</span>
 <span class="s0">*</span>
 <span class="s0">* M_cull_unchanged is an identity attrib; if this is applied to vertices</span>
 <span class="s0">* without any other intervening attrib, it is the same as applying the</span>
 <span class="s0">* default attrib.</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; CullFaceAttrib::make(CullFaceAttrib::Mode mode = ::CullFaceAttrib::M_cull_clockwise);</span>

<span class="s0">3007 12 make_reverse 0 4 3700 28 CullFaceAttrib::make_reverse 0 1 1323 246</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new CullFaceAttrib object that reverses the effects of any</span>
 <span class="s0">* other CullFaceAttrib objects in the scene graph.  M_cull_clockwise will be</span>
 <span class="s0">* treated as M_cull_counter_clockwise, and vice-versa.  M_cull_none is</span>
 <span class="s0">* unchanged.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; CullFaceAttrib::make_reverse(void);</span>

<span class="s0">3008 12 make_default 0 4 3700 28 CullFaceAttrib::make_default 0 1 1324 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; CullFaceAttrib::make_default(void);</span>

<span class="s0">3009 15 get_actual_mode 0 4 3700 31 CullFaceAttrib::get_actual_mode 0 1 1325 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the actual culling mode, without considering the effects of the</span>
 <span class="s0">* reverse flag.  See also get_effective_mode().</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline CullFaceAttrib::Mode CullFaceAttrib::get_actual_mode(void) const;</span>

<span class="s0">3010 11 get_reverse 0 4 3700 27 CullFaceAttrib::get_reverse 0 1 1326 299</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the 'reverse' flag.  If this is true, the actual cull direction</span>
 <span class="s0">* (clockwise vs.  counterclockwise) is the reverse of what is specified here.</span>
 <span class="s0">* This allows support for make_reverse(), which defines a CullFaceAttrib that</span>
 <span class="s0">* reverses whatever the sense of culling would have been.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool CullFaceAttrib::get_reverse(void) const;</span>

<span class="s0">3011 18 get_effective_mode 0 4 3700 34 CullFaceAttrib::get_effective_mode 0 1 1327 220</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the effective culling mode.  This is the same as the actual culling</span>
 <span class="s0">* mode, unless the reverse flag is set, which swaps CW for CCW and vice-</span>
 <span class="s0">* versa.  Also, M_cull_unchanged is mapped to M_cull_none.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">CullFaceAttrib::Mode CullFaceAttrib::get_effective_mode(void) const;</span>

<span class="s0">3012 14 get_class_slot 0 4 3700 30 CullFaceAttrib::get_class_slot 0 1 1328 0</span>
<span class="s0">48</span>
<span class="s0">static int CullFaceAttrib::get_class_slot(void);</span>

<span class="s0">3013 14 get_class_type 0 4 3700 30 CullFaceAttrib::get_class_type 0 1 1329 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle CullFaceAttrib::get_class_type(void);</span>

<span class="s0">3014 15 ~CullFaceAttrib 0 516 3700 31 CullFaceAttrib::~CullFaceAttrib 0 0 0</span>
<span class="s0">38</span>
<span class="s0">CullFaceAttrib::~CullFaceAttrib(void);</span>

<span class="s0">3015 16 ~WorkingNodePath 0 516 3702 33 WorkingNodePath::~WorkingNodePath 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline WorkingNodePath::~WorkingNodePath(void);</span>

<span class="s0">3016 8 is_valid 0 4 3702 25 WorkingNodePath::is_valid 0 0 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the WorkingNodePath object appears to be a valid NodePath</span>
 <span class="s0">* reference, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">bool WorkingNodePath::is_valid(void) const;</span>

<span class="s0">3017 13 get_node_path 0 4 3702 30 WorkingNodePath::get_node_path 0 0 109</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs and returns an actual NodePath that represents the same path we</span>
 <span class="s0">* have just traversed.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline NodePath WorkingNodePath::get_node_path(void) const;</span>

<span class="s0">3018 4 node 0 4 3703 23 CullTraverserData::node 0 1 1331 48</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node traversed to so far.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PandaNode *CullTraverserData::node(void) const;</span>

<span class="s0">3019 23 get_modelview_transform 0 4 3703 42 CullTraverserData::get_modelview_transform 0 1 1332 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the modelview transform: the relative transform from the camera to</span>
 <span class="s0">* the model.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">inline ConstPointerTo&lt; TransformState &gt; CullTraverserData::get_modelview_transform(CullTraverser const *trav) const;</span>

<span class="s0">3020 22 get_internal_transform 0 4 3703 41 CullTraverserData::get_internal_transform 0 1 1333 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the internal transform: the modelview transform in the GSG's</span>
 <span class="s0">* internal coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">inline ConstPointerTo&lt; TransformState &gt; CullTraverserData::get_internal_transform(CullTraverser const *trav) const;</span>

<span class="s0">3021 17 get_net_transform 0 4 3703 36 CullTraverserData::get_net_transform 0 1 1334 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the net transform: the relative transform from root of the scene</span>
 <span class="s0">* graph to the current node.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">inline TransformState const *CullTraverserData::get_net_transform(CullTraverser const *trav) const;</span>

<span class="s0">3022 10 is_in_view 0 4 3703 29 CullTraverserData::is_in_view 0 1 1335 252</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the current node is within the view frustum, false</span>
 <span class="s0">* otherwise.  If the node's bounding volume falls completely within the view</span>
 <span class="s0">* frustum, this will also reset the view frustum pointer, saving some work</span>
 <span class="s0">* for future nodes.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline bool CullTraverserData::is_in_view(DrawMask const &amp;camera_mask);</span>

<span class="s0">3023 19 is_this_node_hidden 0 4 3703 38 CullTraverserData::is_this_node_hidden 0 1 1336 234</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this particular node is hidden, even though we might be</span>
 <span class="s0">* traversing past this node to find a child node that has had show_through()</span>
 <span class="s0">* called for it.  If this returns true, the node should not be rendered.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline bool CullTraverserData::is_this_node_hidden(DrawMask const &amp;camera_mask) const;</span>

<span class="s0">3024 25 apply_transform_and_state 0 4 3703 44 CullTraverserData::apply_transform_and_state 0 1 1337 128</span>
<span class="s0">/**</span>
 <span class="s0">* Applies the transform and state from the current node onto the current</span>
 <span class="s0">* data.  This also evaluates billboards, etc.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">void CullTraverserData::apply_transform_and_state(CullTraverser *trav);</span>

<span class="s0">3025 15 apply_transform 0 4 3703 34 CullTraverserData::apply_transform 0 1 1338 73</span>
<span class="s0">/**</span>
 <span class="s0">* Applies the indicated transform changes onto the current data.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void CullTraverserData::apply_transform(TransformState const *node_transform);</span>

<span class="s0">3026 13 get_node_path 0 4 3703 32 CullTraverserData::get_node_path 0 0 109</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs and returns an actual NodePath that represents the same path we</span>
 <span class="s0">* have just traversed.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline NodePath CullTraverserData::get_node_path(void) const;</span>

<span class="s0">3027 17 CullTraverserData 0 260 3703 36 CullTraverserData::CullTraverserData 0 1 1330 128</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This constructor creates a CullTraverserData object that reflects the next</span>
 <span class="s0">* node down in the traversal.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline CullTraverserData::CullTraverserData(CullTraverserData const &amp;) = default;</span>

<span class="s0">3028 18 ~CullTraverserData 0 516 3703 37 CullTraverserData::~CullTraverserData 0 0 0</span>
<span class="s0">44</span>
<span class="s0">CullTraverserData::~CullTraverserData(void);</span>

<span class="s0">3029 18 set_display_region 0 4 3704 30 SceneSetup::set_display_region 0 1 1340 54</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the display region for the scene.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void SceneSetup::set_display_region(DisplayRegion *display_region);</span>

<span class="s0">3030 18 get_display_region 0 4 3704 30 SceneSetup::get_display_region 0 1 1341 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the display region for the scene.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline DisplayRegion *SceneSetup::get_display_region(void) const;</span>

<span class="s0">3031 17 set_viewport_size 0 4 3704 29 SceneSetup::set_viewport_size 0 1 1342 74</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the size of the viewport (display region), in pixels.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void SceneSetup::set_viewport_size(int width, int height);</span>

<span class="s0">3032 18 get_viewport_width 0 4 3704 30 SceneSetup::get_viewport_width 0 1 1343 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the width of the viewport (display region) in pixels.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int SceneSetup::get_viewport_width(void) const;</span>

<span class="s0">3033 19 get_viewport_height 0 4 3704 31 SceneSetup::get_viewport_height 0 1 1344 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the height of the viewport (display region) in pixels.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int SceneSetup::get_viewport_height(void) const;</span>

<span class="s0">3034 14 set_scene_root 0 4 3704 26 SceneSetup::set_scene_root 0 1 1345 48</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the root node of the scene.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void SceneSetup::set_scene_root(NodePath const &amp;scene_root);</span>

<span class="s0">3035 14 get_scene_root 0 4 3704 26 SceneSetup::get_scene_root 0 1 1346 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the root node of the scene.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline NodePath const &amp;SceneSetup::get_scene_root(void) const;</span>

<span class="s0">3036 15 set_camera_path 0 4 3704 27 SceneSetup::set_camera_path 0 1 1347 48</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the NodePath to the camera.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void SceneSetup::set_camera_path(NodePath const &amp;camera_path);</span>

<span class="s0">3037 15 get_camera_path 0 4 3704 27 SceneSetup::get_camera_path 0 1 1348 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath to the camera.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline NodePath const &amp;SceneSetup::get_camera_path(void) const;</span>

<span class="s0">3038 15 set_camera_node 0 4 3704 27 SceneSetup::set_camera_node 0 1 1349 57</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the camera used to render the scene.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void SceneSetup::set_camera_node(Camera *camera_node);</span>

<span class="s0">3039 15 get_camera_node 0 4 3704 27 SceneSetup::get_camera_node 0 1 1350 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the camera used to render the scene.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline Camera *SceneSetup::get_camera_node(void) const;</span>

<span class="s0">3040 8 set_lens 0 4 3704 20 SceneSetup::set_lens 0 1 1351 60</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the particular Lens used for rendering.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void SceneSetup::set_lens(Lens const *lens);</span>

<span class="s0">3041 8 get_lens 0 4 3704 20 SceneSetup::get_lens 0 1 1352 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the particular Lens used for rendering.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline Lens const *SceneSetup::get_lens(void) const;</span>

<span class="s0">3042 12 set_inverted 0 4 3704 24 SceneSetup::set_inverted 0 1 1353 220</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the current setting of the inverted flag.  When this is true, the</span>
 <span class="s0">* scene is rendered into the window upside-down and backwards, that is,</span>
 <span class="s0">* inverted as if viewed through a mirror placed on the floor.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void SceneSetup::set_inverted(bool inverted);</span>

<span class="s0">3043 12 get_inverted 0 4 3704 24 SceneSetup::get_inverted 0 1 1354 177</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the inverted flag.  When this is true, the</span>
 <span class="s0">* scene is rendered into the window upside-down, flipped like a mirror along</span>
 <span class="s0">* the X axis.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool SceneSetup::get_inverted(void) const;</span>

<span class="s0">3044 15 get_cull_center 0 4 3704 27 SceneSetup::get_cull_center 0 1 1355 207</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point from which the culling operations will be performed.</span>
 <span class="s0">* This is normally the camera, but if camera-&gt;set_cull_center() has been</span>
 <span class="s0">* specified, it will be that special node instead.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline NodePath const &amp;SceneSetup::get_cull_center(void) const;</span>

<span class="s0">3045 15 get_cull_bounds 0 4 3704 27 SceneSetup::get_cull_bounds 0 1 1356 246</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bounding volume that should be used to perform view-frustum</span>
 <span class="s0">* culling (in the space of get_cull_center()).  This is normally the current</span>
 <span class="s0">* lens' bounding volume, but it may be overridden with</span>
 <span class="s0">* Camera::set_cull_bounds().</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline PointerTo&lt; BoundingVolume &gt; SceneSetup::get_cull_bounds(void) const;</span>

<span class="s0">3046 17 set_initial_state 0 4 3704 29 SceneSetup::set_initial_state 0 1 1357 129</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the initial state which is applied to all nodes in the scene, as if it</span>
 <span class="s0">* were set at the top of the scene graph.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void SceneSetup::set_initial_state(RenderState const *initial_state);</span>

<span class="s0">3047 17 get_initial_state 0 4 3704 29 SceneSetup::get_initial_state 0 1 1358 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the initial state as set by a previous call to set_initial_state().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline RenderState const *SceneSetup::get_initial_state(void) const;</span>

<span class="s0">3048 20 set_camera_transform 0 4 3704 32 SceneSetup::set_camera_transform 0 1 1359 78</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the position of the camera relative to the starting node.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">inline void SceneSetup::set_camera_transform(TransformState const *camera_transform);</span>

<span class="s0">3049 20 get_camera_transform 0 4 3704 32 SceneSetup::get_camera_transform 0 1 1360 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the camera relative to the starting node.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline TransformState const *SceneSetup::get_camera_transform(void) const;</span>

<span class="s0">3050 19 set_world_transform 0 4 3704 31 SceneSetup::set_world_transform 0 1 1361 127</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the position of the starting node relative to the camera.  This</span>
 <span class="s0">* is the inverse of the camera transform.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void SceneSetup::set_world_transform(TransformState const *world_transform);</span>

<span class="s0">3051 19 get_world_transform 0 4 3704 31 SceneSetup::get_world_transform 0 1 1362 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the starting node relative to the camera.  This is</span>
 <span class="s0">* the inverse of the camera transform.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline TransformState const *SceneSetup::get_world_transform(void) const;</span>

<span class="s0">3052 16 set_cs_transform 0 4 3704 28 SceneSetup::set_cs_transform 0 1 1363 114</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the transform from the camera's coordinate system to the GSG's</span>
 <span class="s0">* internal coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void SceneSetup::set_cs_transform(TransformState const *cs_transform);</span>

<span class="s0">3053 16 get_cs_transform 0 4 3704 28 SceneSetup::get_cs_transform 0 1 1364 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the transform from the camera's coordinate system to the GSG's</span>
 <span class="s0">* internal coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline TransformState const *SceneSetup::get_cs_transform(void) const;</span>

<span class="s0">3054 22 set_cs_world_transform 0 4 3704 34 SceneSetup::set_cs_world_transform 0 1 1365 124</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the position from the starting node relative to the camera, in</span>
 <span class="s0">* the GSG's internal coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline void SceneSetup::set_cs_world_transform(TransformState const *cs_world_transform);</span>

<span class="s0">3055 22 get_cs_world_transform 0 4 3704 34 SceneSetup::get_cs_world_transform 0 1 1366 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position from the starting node relative to the camera, in the</span>
 <span class="s0">* GSG's internal coordinate system.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline TransformState const *SceneSetup::get_cs_world_transform(void) const;</span>

<span class="s0">3056 14 get_class_type 0 4 3704 26 SceneSetup::get_class_type 0 1 1367 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle SceneSetup::get_class_type(void);</span>

<span class="s0">3057 10 SceneSetup 0 260 3704 22 SceneSetup::SceneSetup 0 1 1339 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline SceneSetup::SceneSetup(SceneSetup const &amp;) = default;</span>

<span class="s0">3058 11 ~SceneSetup 0 516 3704 23 SceneSetup::~SceneSetup 0 0 0</span>
<span class="s0">30</span>
<span class="s0">SceneSetup::~SceneSetup(void);</span>

<span class="s0">3059 3 Fog 0 260 3705 8 Fog::Fog 0 1 1368 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">explicit Fog::Fog(std::string const &amp;name);</span>

<span class="s0">3060 8 get_mode 0 4 3705 13 Fog::get_mode 0 1 1369 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline Fog::Mode Fog::get_mode(void) const;</span>

<span class="s0">3061 8 set_mode 0 4 3705 13 Fog::set_mode 0 1 1370 586</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the computation that is used to determine the fog effect.  If</span>
 <span class="s0">* this is M_linear, then the fog will range from linearly from the onset</span>
 <span class="s0">* point to the opaque point (or for the distances specified in</span>
 <span class="s0">* set_linear_range), and the fog object should be parented into the scene</span>
 <span class="s0">* graph, or to the camera.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is anything else, the onset point and opaque point are not used,</span>
 <span class="s0">* and the fog effect is based on the value specified to set_exp_density(),</span>
 <span class="s0">* and it doesn't matter to which node the fog object is parented, or if it is</span>
 <span class="s0">* parented anywhere at all.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void Fog::set_mode(Fog::Mode mode);</span>

<span class="s0">3062 9 get_color 0 4 3705 14 Fog::get_color 0 1 1371 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color of the fog.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline LColor const &amp;Fog::get_color(void) const;</span>

<span class="s0">3063 9 set_color 0 4 3705 14 Fog::set_color 0 2 1372 1373 110</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color of the fog.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the color of the fog.  The alpha component is not used.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">inline void Fog::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b);</span>
<span class="s0">inline void Fog::set_color(LColor const &amp;color);</span>

<span class="s0">3064 16 set_linear_range 0 4 3705 21 Fog::set_linear_range 0 1 1374 400</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the effects of the fog in linear distance units.  This is only</span>
 <span class="s0">* used if the mode is M_linear.</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies a fog that begins at distance onset units from the origin,</span>
 <span class="s0">* and becomes totally opaque at distance opaque units from the origin, along</span>
 <span class="s0">* the forward axis (usually Y).</span>
 <span class="s0">*</span>
 <span class="s0">* This function also implicitly sets the mode the M_linear, if it is not</span>
 <span class="s0">* already set.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void Fog::set_linear_range(PN_stdfloat onset, PN_stdfloat opaque);</span>

<span class="s0">3065 22 get_linear_onset_point 0 4 3705 27 Fog::get_linear_onset_point 0 1 1375 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point in space at which the fog begins.  This is only used if</span>
 <span class="s0">* the mode is M_linear.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LPoint3 const &amp;Fog::get_linear_onset_point(void) const;</span>

<span class="s0">3066 22 set_linear_onset_point 0 4 3705 27 Fog::set_linear_onset_point 0 2 1376 1377 224</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the point in space at which the fog begins.  This is only used if</span>
 <span class="s0">* the mode is M_linear.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies the point in space at which the fog begins.  This is only used if</span>
 <span class="s0">* the mode is M_linear.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">inline void Fog::set_linear_onset_point(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>
<span class="s0">inline void Fog::set_linear_onset_point(LPoint3 const &amp;linear_onset_point);</span>

<span class="s0">3067 23 get_linear_opaque_point 0 4 3705 28 Fog::get_linear_opaque_point 0 1 1378 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point in space at which the fog completely obscures geometry.</span>
 <span class="s0">* This is only used if the mode is M_linear.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline LPoint3 const &amp;Fog::get_linear_opaque_point(void) const;</span>

<span class="s0">3068 23 set_linear_opaque_point 0 4 3705 28 Fog::set_linear_opaque_point 0 2 1379 1380 266</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the point in space at which the fog completely obscures geometry.</span>
 <span class="s0">* This is only used if the mode is M_linear.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Specifies the point in space at which the fog completely obscures geometry.</span>
 <span class="s0">* This is only used if the mode is M_linear.</span>
 <span class="s0">*/</span>
<span class="s0">164</span>
<span class="s0">inline void Fog::set_linear_opaque_point(LPoint3 const &amp;linear_opaque_point);</span>
<span class="s0">inline void Fog::set_linear_opaque_point(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">3069 19 set_linear_fallback 0 4 3705 24 Fog::set_linear_fallback 0 1 1381 1553</span>
<span class="s0">/**</span>
 <span class="s0">* Fog effects are traditionally defined in camera-relative space, but the</span>
 <span class="s0">* Panda Fog node has a special mode in which it can define a linear fog</span>
 <span class="s0">* effect in an arbitrary coordinate space.</span>
 <span class="s0">*</span>
 <span class="s0">* This is done by specifying 3-d onset and opaque points, and parenting the</span>
 <span class="s0">* Fog object somewhere within the scene graph.  In this mode, the fog will be</span>
 <span class="s0">* rendered as if it extended along the vector from the onset point to the</span>
 <span class="s0">* opaque point, in 3-d space.</span>
 <span class="s0">*</span>
 <span class="s0">* However, the underlying fog effect supported by hardware is generally only</span>
 <span class="s0">* one-dimensional, and must be rendered based on linear distance from the</span>
 <span class="s0">* camera plane.  Thus, this in-the-world effect is most effective when the</span>
 <span class="s0">* fog vector from onset point to opaque point is most nearly parallel to the</span>
 <span class="s0">* camera's eye vector.</span>
 <span class="s0">*</span>
 <span class="s0">* As the angle between the fog vector and the eye vector increases, the</span>
 <span class="s0">* accuracy of the effect diminishes, up to a complete breakdown of the effect</span>
 <span class="s0">* at a 90 degree angle.</span>
 <span class="s0">*</span>
 <span class="s0">* This function exists to define the workaround to this problem.  The linear</span>
 <span class="s0">* fallback parameters given here specify how the fog should be rendered when</span>
 <span class="s0">* the parameters are exceeded in this way.</span>
 <span class="s0">*</span>
 <span class="s0">* The angle parameter is the minimum angle, in degrees, of the fog vector to</span>
 <span class="s0">* the eye vector, at which the fallback effect should be employed.  The onset</span>
 <span class="s0">* and opaque parameters specify the camera-relative onset and opaque</span>
 <span class="s0">* distances to pass to the rendering hardware when employing the fallback</span>
 <span class="s0">* effect.  This supercedes the 3-d onset point and opaque points.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline void Fog::set_linear_fallback(PN_stdfloat angle, PN_stdfloat onset, PN_stdfloat opaque);</span>

<span class="s0">3070 15 get_exp_density 0 4 3705 20 Fog::get_exp_density 0 1 1382 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the density of the fog for exponential calculations.  This is only</span>
 <span class="s0">* used if the mode is not M_linear.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline PN_stdfloat Fog::get_exp_density(void) const;</span>

<span class="s0">3071 15 set_exp_density 0 4 3705 20 Fog::set_exp_density 0 1 1383 221</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the density of the fog for exponential calculations.  This is only</span>
 <span class="s0">* used if the mode is not M_linear.</span>
 <span class="s0">*</span>
 <span class="s0">* If the mode is currently set to M_linear, this function implicitly sets it</span>
 <span class="s0">* to M_exponential.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void Fog::set_exp_density(PN_stdfloat exp_density);</span>

<span class="s0">3072 14 get_class_type 0 4 3705 19 Fog::get_class_type 0 1 1384 0</span>
<span class="s0">44</span>
<span class="s0">static TypeHandle Fog::get_class_type(void);</span>

<span class="s0">3073 4 make 0 4 3707 15 FogAttrib::make 0 1 1385 103</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new FogAttrib object suitable for rendering the indicated fog</span>
 <span class="s0">* onto geometry.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; FogAttrib::make(Fog *fog);</span>

<span class="s0">3074 8 make_off 0 4 3707 19 FogAttrib::make_off 0 1 1386 84</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new FogAttrib object suitable for rendering unfogd geometry.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; FogAttrib::make_off(void);</span>

<span class="s0">3075 12 make_default 0 4 3707 23 FogAttrib::make_default 0 1 1387 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; FogAttrib::make_default(void);</span>

<span class="s0">3076 6 is_off 0 4 3707 17 FogAttrib::is_off 0 1 1388 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the FogAttrib is an 'off' FogAttrib, indicating that it</span>
 <span class="s0">* should disable fog.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool FogAttrib::is_off(void) const;</span>

<span class="s0">3077 7 get_fog 0 4 3707 18 FogAttrib::get_fog 0 1 1389 118</span>
<span class="s0">/**</span>
 <span class="s0">* If the FogAttrib is not an 'off' FogAttrib, returns the fog that is</span>
 <span class="s0">* associated.  Otherwise, return NULL.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline Fog *FogAttrib::get_fog(void) const;</span>

<span class="s0">3078 14 get_class_slot 0 4 3707 25 FogAttrib::get_class_slot 0 1 1390 0</span>
<span class="s0">43</span>
<span class="s0">static int FogAttrib::get_class_slot(void);</span>

<span class="s0">3079 14 get_class_type 0 4 3707 25 FogAttrib::get_class_type 0 1 1391 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle FogAttrib::get_class_type(void);</span>

<span class="s0">3080 10 ~FogAttrib 0 516 3707 21 FogAttrib::~FogAttrib 0 0 0</span>
<span class="s0">28</span>
<span class="s0">FogAttrib::~FogAttrib(void);</span>

<span class="s0">3081 13 CullTraverser 0 260 3709 28 CullTraverser::CullTraverser 0 2 1392 1393 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">CullTraverser::CullTraverser(void);</span>
<span class="s0">CullTraverser::CullTraverser(CullTraverser const &amp;copy);</span>

<span class="s0">3082 7 get_gsg 0 4 3709 22 CullTraverser::get_gsg 0 1 1394 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the GraphicsStateGuardian in effect.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline GraphicsStateGuardianBase *CullTraverser::get_gsg(void) const;</span>

<span class="s0">3083 18 get_current_thread 0 4 3709 33 CullTraverser::get_current_thread 0 1 1395 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the currently-executing thread object, as passed to the</span>
 <span class="s0">* CullTraverser constructor.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline Thread *CullTraverser::get_current_thread(void) const;</span>

<span class="s0">3084 9 set_scene 0 6 3709 24 CullTraverser::set_scene 0 1 1396 134</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the SceneSetup object that indicates the initial camera position, etc.</span>
 <span class="s0">* This must be called before traversal begins.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">virtual void CullTraverser::set_scene(SceneSetup *scene_setup, GraphicsStateGuardianBase *gsg, bool dr_incomplete_render);</span>

<span class="s0">3085 9 get_scene 0 4 3709 24 CullTraverser::get_scene 0 1 1397 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the SceneSetup object.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline SceneSetup *CullTraverser::get_scene(void) const;</span>

<span class="s0">3086 17 has_tag_state_key 0 4 3709 32 CullTraverser::has_tag_state_key 0 1 1398 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a nonempty tag state key has been specified for the scene's</span>
 <span class="s0">* camera, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool CullTraverser::has_tag_state_key(void) const;</span>

<span class="s0">3087 17 get_tag_state_key 0 4 3709 32 CullTraverser::get_tag_state_key 0 1 1399 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the tag state key that has been specified for the scene's camera,</span>
 <span class="s0">* if any.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline std::string const &amp;CullTraverser::get_tag_state_key(void) const;</span>

<span class="s0">3088 15 set_camera_mask 0 4 3709 30 CullTraverser::set_camera_mask 0 1 1400 276</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the visibility mask for the camera viewing the scene.  This is</span>
 <span class="s0">* normally set automatically at the time setup_scene() is called; you should</span>
 <span class="s0">* change this only if you want to render some set of objects different from</span>
 <span class="s0">* what the camera normally would draw.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void CullTraverser::set_camera_mask(DrawMask const &amp;camera_mask);</span>

<span class="s0">3089 15 get_camera_mask 0 4 3709 30 CullTraverser::get_camera_mask 0 1 1401 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the visibility mask from the camera viewing the scene.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline DrawMask const &amp;CullTraverser::get_camera_mask(void) const;</span>

<span class="s0">3090 20 get_camera_transform 0 4 3709 35 CullTraverser::get_camera_transform 0 1 1402 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the camera relative to the starting node.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline TransformState const *CullTraverser::get_camera_transform(void) const;</span>

<span class="s0">3091 19 get_world_transform 0 4 3709 34 CullTraverser::get_world_transform 0 1 1403 362</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the starting node relative to the camera.  This is</span>
 <span class="s0">* the inverse of the camera transform.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this value is always the position of the starting node, not the</span>
 <span class="s0">* current node, even if it is sampled during a traversal.  To get the</span>
 <span class="s0">* transform of the current node use</span>
 <span class="s0">* CullTraverserData::get_modelview_transform().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline TransformState const *CullTraverser::get_world_transform(void) const;</span>

<span class="s0">3092 17 get_initial_state 0 4 3709 32 CullTraverser::get_initial_state 0 1 1404 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the initial RenderState at the top of the scene graph we are</span>
 <span class="s0">* traversing, or the empty state if the initial state was never set.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline RenderState const *CullTraverser::get_initial_state(void) const;</span>

<span class="s0">3093 23 get_depth_offset_decals 0 4 3709 38 CullTraverser::get_depth_offset_decals 0 1 1405 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true, as depth offsets are the only way that we implement decals</span>
 <span class="s0">* nowadays.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline bool CullTraverser::get_depth_offset_decals(void) const;</span>

<span class="s0">3094 16 set_view_frustum 0 4 3709 31 CullTraverser::set_view_frustum 0 1 1406 154</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the bounding volume that corresponds to the view frustum.  Any</span>
 <span class="s0">* primitives that fall entirely outside of this volume are not drawn.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void CullTraverser::set_view_frustum(GeometricBoundingVolume *view_frustum);</span>

<span class="s0">3095 16 get_view_frustum 0 4 3709 31 CullTraverser::get_view_frustum 0 1 1407 423</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the bounding volume that corresponds to the view frustum, or NULL</span>
 <span class="s0">* if the view frustum is not in use or has not been set.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the view frustum returned here is always in the coordinate space</span>
 <span class="s0">* of the starting node, not the current node, even if it is sampled during a</span>
 <span class="s0">* traversal.  To get the view frustum in the current node's coordinate space,</span>
 <span class="s0">* check in the current CullTraverserData.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline GeometricBoundingVolume *CullTraverser::get_view_frustum(void) const;</span>

<span class="s0">3096 16 set_cull_handler 0 4 3709 31 CullTraverser::set_cull_handler 0 1 1408 115</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the object that will receive the culled Geoms.  This must be set</span>
 <span class="s0">* before calling traverse().</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void CullTraverser::set_cull_handler(CullHandler *cull_handler);</span>

<span class="s0">3097 16 get_cull_handler 0 4 3709 31 CullTraverser::get_cull_handler 0 1 1409 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the object that will receive the culled Geoms.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline CullHandler *CullTraverser::get_cull_handler(void) const;</span>

<span class="s0">3098 18 set_portal_clipper 0 4 3709 33 CullTraverser::set_portal_clipper 0 1 1410 108</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies _portal_clipper object pointer that subsequent traverse() or</span>
 <span class="s0">* traverse_below may use.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void CullTraverser::set_portal_clipper(PortalClipper *portal_clipper);</span>

<span class="s0">3099 18 get_portal_clipper 0 4 3709 33 CullTraverser::get_portal_clipper 0 1 1411 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the _portal_clipper pointer</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline PortalClipper *CullTraverser::get_portal_clipper(void) const;</span>

<span class="s0">3100 31 get_effective_incomplete_render 0 4 3709 46 CullTraverser::get_effective_incomplete_render 0 1 1412 341</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the cull traversal is effectively in incomplete_render</span>
 <span class="s0">* state, considering both the GSG's incomplete_render and the current</span>
 <span class="s0">* DisplayRegion's incomplete_render flags.  This returns the flag during the</span>
 <span class="s0">* cull traversal; see GSG::get_effective_incomplete_render() for this same</span>
 <span class="s0">* flag during the draw traversal.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline bool CullTraverser::get_effective_incomplete_render(void) const;</span>

<span class="s0">3101 8 traverse 0 4 3709 23 CullTraverser::traverse 0 2 1413 1414 219</span>
<span class="s0">/**</span>
 <span class="s0">* Begins the traversal from the indicated node.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Traverses from the next node with the given data, which has been</span>
 <span class="s0">* constructed with the node but has not yet been converted into the node's</span>
 <span class="s0">* space.</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">void CullTraverser::traverse(NodePath const &amp;root);</span>
<span class="s0">void CullTraverser::traverse(CullTraverserData &amp;data);</span>

<span class="s0">3102 14 traverse_below 0 6 3709 29 CullTraverser::traverse_below 0 1 1415 132</span>
<span class="s0">/**</span>
 <span class="s0">* Traverses all the children of the indicated node, with the given data,</span>
 <span class="s0">* which has been converted into the node's space.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">virtual void CullTraverser::traverse_below(CullTraverserData &amp;data);</span>

<span class="s0">3103 12 end_traverse 0 6 3709 27 CullTraverser::end_traverse 0 1 1416 141</span>
<span class="s0">/**</span>
 <span class="s0">* Should be called when the traverser has finished traversing its scene, this</span>
 <span class="s0">* gives it a chance to do any necessary finalization.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">virtual void CullTraverser::end_traverse(void);</span>

<span class="s0">3104 11 flush_level 0 4 3709 26 CullTraverser::flush_level 0 1 1417 61</span>
<span class="s0">/**</span>
 <span class="s0">* Flushes the PStatCollectors used during traversal.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static inline void CullTraverser::flush_level(void);</span>

<span class="s0">3105 20 draw_bounding_volume 0 4 3709 35 CullTraverser::draw_bounding_volume 0 1 1418 79</span>
<span class="s0">/**</span>
 <span class="s0">* Draws an appropriate visualization of the indicated bounding volume.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">void CullTraverser::draw_bounding_volume(BoundingVolume const *vol, TransformState const *internal_transform) const;</span>

<span class="s0">3106 14 get_class_type 0 4 3709 29 CullTraverser::get_class_type 0 1 1419 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle CullTraverser::get_class_type(void);</span>

<span class="s0">3107 14 ~CullTraverser 0 516 3709 29 CullTraverser::~CullTraverser 0 0 0</span>
<span class="s0">36</span>
<span class="s0">CullTraverser::~CullTraverser(void);</span>

<span class="s0">3108 10 get_object 0 4 3710 32 GeomDrawCallbackData::get_object 0 1 1420 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the particular object that is being drawn.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline CullableObject *GeomDrawCallbackData::get_object(void) const;</span>

<span class="s0">3109 7 get_gsg 0 4 3710 29 GeomDrawCallbackData::get_gsg 0 1 1421 48</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the current GSG.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline GraphicsStateGuardianBase *GeomDrawCallbackData::get_gsg(void) const;</span>

<span class="s0">3110 9 get_force 0 4 3710 31 GeomDrawCallbackData::get_force 0 1 1422 246</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any required data should be forced into memory if necessary</span>
 <span class="s0">* to render the object, or false if the object should be omitted if some of</span>
 <span class="s0">* the data is not available (at least until the data becomes available</span>
 <span class="s0">* later).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool GeomDrawCallbackData::get_force(void) const;</span>

<span class="s0">3111 14 set_lost_state 0 4 3710 36 GeomDrawCallbackData::set_lost_state 0 1 1423 461</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the lost_state flag.  If this is true, the callback does not have to</span>
 <span class="s0">* be quite so careful to clean up after itself; Panda will assume that the</span>
 <span class="s0">* graphics state is in an unknown state after the callback has finished, and</span>
 <span class="s0">* will issue all the necessary calls to restore it.  If this is false, Panda</span>
 <span class="s0">* will assume the callback will leave the graphics state exactly as it came</span>
 <span class="s0">* in, and won't bother to try to restore it.  The default is true.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void GeomDrawCallbackData::set_lost_state(bool lost_state);</span>

<span class="s0">3112 14 get_lost_state 0 4 3710 36 GeomDrawCallbackData::get_lost_state 0 1 1424 62</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the lost_state flag.  See set_lost_state().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool GeomDrawCallbackData::get_lost_state(void) const;</span>

<span class="s0">3113 14 get_class_type 0 4 3710 36 GeomDrawCallbackData::get_class_type 0 1 1425 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle GeomDrawCallbackData::get_class_type(void);</span>

<span class="s0">3114 21 ~GeomDrawCallbackData 0 516 3710 43 GeomDrawCallbackData::~GeomDrawCallbackData 0 0 0</span>
<span class="s0">50</span>
<span class="s0">GeomDrawCallbackData::~GeomDrawCallbackData(void);</span>

<span class="s0">3115 4 make 0 4 3712 25 RescaleNormalAttrib::make 0 1 1426 169</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new RescaleNormalAttrib object that specifies whether to</span>
 <span class="s0">* rescale normals to compensate for transform scales or incorrectly defined</span>
 <span class="s0">* normals.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; RescaleNormalAttrib::make(RescaleNormalAttrib::Mode mode);</span>

<span class="s0">3116 12 make_default 0 4 3712 33 RescaleNormalAttrib::make_default 0 1 1427 209</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a RescaleNormalAttrib object that's suitable for putting at the</span>
 <span class="s0">* top of a scene graph.  This will contain whatever attrib was suggested by</span>
 <span class="s0">* the user's rescale-normals Config variable.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">static inline ConstPointerTo&lt; RenderAttrib &gt; RescaleNormalAttrib::make_default(void);</span>

<span class="s0">3117 8 get_mode 0 4 3712 29 RescaleNormalAttrib::get_mode 0 1 1428 35</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the render mode.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline RescaleNormalAttrib::Mode RescaleNormalAttrib::get_mode(void) const;</span>

<span class="s0">3118 14 get_class_slot 0 4 3712 35 RescaleNormalAttrib::get_class_slot 0 1 1429 0</span>
<span class="s0">53</span>
<span class="s0">static int RescaleNormalAttrib::get_class_slot(void);</span>

<span class="s0">3119 14 get_class_type 0 4 3712 35 RescaleNormalAttrib::get_class_type 0 1 1430 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle RescaleNormalAttrib::get_class_type(void);</span>

<span class="s0">3120 20 ~RescaleNormalAttrib 0 516 3712 41 RescaleNormalAttrib::~RescaleNormalAttrib 0 0 0</span>
<span class="s0">48</span>
<span class="s0">RescaleNormalAttrib::~RescaleNormalAttrib(void);</span>

<span class="s0">3121 9 make_next 0 4 3714 21 CullResult::make_next 0 1 1432 185</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a newly-allocated CullResult object that contains a copy of just</span>
 <span class="s0">* the subset of the data from this CullResult object that is worth keeping</span>
 <span class="s0">* around for next frame.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">PointerTo&lt; CullResult &gt; CullResult::make_next(void) const;</span>

<span class="s0">3122 7 get_bin 0 4 3714 19 CullResult::get_bin 0 1 1433 238</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CullBin associated with the indicated bin_index, or NULL if the</span>
 <span class="s0">* bin_index is invalid.  If there is the first time this bin_index has been</span>
 <span class="s0">* requested for this CullResult, creates a new CullBin object on the fly.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline CullBin *CullResult::get_bin(int bin_index);</span>

<span class="s0">3123 10 add_object 0 4 3714 22 CullResult::add_object 0 1 1434 152</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated CullableObject to the appropriate bin.  The bin becomes</span>
 <span class="s0">* the owner of the object pointer, and will eventually delete it.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">void CullResult::add_object(CullableObject *object, CullTraverser const *traverser);</span>

<span class="s0">3124 11 finish_cull 0 4 3714 23 CullResult::finish_cull 0 1 1435 219</span>
<span class="s0">/**</span>
 <span class="s0">* Called after all the geoms have been added, this indicates that the cull</span>
 <span class="s0">* process is finished for this frame and gives the bins a chance to do any</span>
 <span class="s0">* post-processing (like sorting) before moving on to draw.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void CullResult::finish_cull(SceneSetup *scene_setup, Thread *current_thread);</span>

<span class="s0">3125 4 draw 0 4 3714 16 CullResult::draw 0 1 1436 69</span>
<span class="s0">/**</span>
 <span class="s0">* Asks all the bins to draw themselves in the correct order.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void CullResult::draw(Thread *current_thread);</span>

<span class="s0">3126 17 make_result_graph 0 4 3714 29 CullResult::make_result_graph 0 1 1437 496</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a special scene graph constructed to represent the results of the</span>
 <span class="s0">* cull.  This will be a hierarchy of nodes, one node for each bin, each of</span>
 <span class="s0">* which will in term be a parent of a number of GeomNodes, representing the</span>
 <span class="s0">* geometry drawn in each bin.</span>
 <span class="s0">*</span>
 <span class="s0">* This is useful mainly for high-level debugging and abstraction tools; it</span>
 <span class="s0">* should not be mistaken for the low-level cull result itself.  For the low-</span>
 <span class="s0">* level cull result, use draw() to efficiently draw the culled scene.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">PointerTo&lt; PandaNode &gt; CullResult::make_result_graph(void);</span>

<span class="s0">3127 14 get_class_type 0 4 3714 26 CullResult::get_class_type 0 1 1438 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle CullResult::get_class_type(void);</span>

<span class="s0">3128 10 CullResult 0 260 3714 22 CullResult::CullResult 0 1 1431 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline CullResult::CullResult(CullResult const &amp;) = default;</span>

<span class="s0">3129 4 make 0 4 3716 17 DecalEffect::make 0 1 1439 47</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new DecalEffect object.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; DecalEffect::make(void);</span>

<span class="s0">3130 14 get_class_type 0 4 3716 27 DecalEffect::get_class_type 0 1 1440 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle DecalEffect::get_class_type(void);</span>

<span class="s0">3131 12 ~DecalEffect 0 516 3716 25 DecalEffect::~DecalEffect 0 0 0</span>
<span class="s0">32</span>
<span class="s0">DecalEffect::~DecalEffect(void);</span>

<span class="s0">3132 4 make 0 4 3717 23 DepthOffsetAttrib::make 0 2 1441 1442 503</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new DepthOffsetAttrib object that indicates the relative</span>
 <span class="s0">* amount of bias to write to the depth buffer for subsequent geometry.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new DepthOffsetAttrib object that indicates the bias, and also</span>
 <span class="s0">* specifies a minimum and maximum (or, more precisely, nearest and farthest)</span>
 <span class="s0">* values to write to the depth buffer, in the range 0 .. 1.  This range is 0,</span>
 <span class="s0">* 1 by default; setting it to some other range can be used to create</span>
 <span class="s0">* additional depth buffer effects.</span>
 <span class="s0">*/</span>
<span class="s0">199</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; DepthOffsetAttrib::make(int offset = 1);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; DepthOffsetAttrib::make(int offset, PN_stdfloat min_value, PN_stdfloat max_value);</span>

<span class="s0">3133 12 make_default 0 4 3717 31 DepthOffsetAttrib::make_default 0 1 1443 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; DepthOffsetAttrib::make_default(void);</span>

<span class="s0">3134 10 get_offset 0 4 3717 29 DepthOffsetAttrib::get_offset 0 1 1444 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the depth offset represented by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int DepthOffsetAttrib::get_offset(void) const;</span>

<span class="s0">3135 13 get_min_value 0 4 3717 32 DepthOffsetAttrib::get_min_value 0 1 1445 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value for the minimum (closest) depth value to be stored in the</span>
 <span class="s0">* buffer, in the range 0 .. 1.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline PN_stdfloat DepthOffsetAttrib::get_min_value(void) const;</span>

<span class="s0">3136 13 get_max_value 0 4 3717 32 DepthOffsetAttrib::get_max_value 0 1 1446 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value for the maximum (farthest) depth value to be stored in</span>
 <span class="s0">* the buffer, in the range 0 .. 1.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline PN_stdfloat DepthOffsetAttrib::get_max_value(void) const;</span>

<span class="s0">3137 14 get_class_slot 0 4 3717 33 DepthOffsetAttrib::get_class_slot 0 1 1447 0</span>
<span class="s0">51</span>
<span class="s0">static int DepthOffsetAttrib::get_class_slot(void);</span>

<span class="s0">3138 14 get_class_type 0 4 3717 33 DepthOffsetAttrib::get_class_type 0 1 1448 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle DepthOffsetAttrib::get_class_type(void);</span>

<span class="s0">3139 18 ~DepthOffsetAttrib 0 516 3717 37 DepthOffsetAttrib::~DepthOffsetAttrib 0 0 0</span>
<span class="s0">44</span>
<span class="s0">DepthOffsetAttrib::~DepthOffsetAttrib(void);</span>

<span class="s0">3140 4 make 0 4 3718 21 DepthTestAttrib::make 0 1 1449 51</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new DepthTestAttrib object.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; DepthTestAttrib::make(RenderAttrib::PandaCompareFunc mode);</span>

<span class="s0">3141 12 make_default 0 4 3718 29 DepthTestAttrib::make_default 0 1 1450 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; DepthTestAttrib::make_default(void);</span>

<span class="s0">3142 8 get_mode 0 4 3718 25 DepthTestAttrib::get_mode 0 1 1451 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the depth write mode.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline RenderAttrib::PandaCompareFunc DepthTestAttrib::get_mode(void) const;</span>

<span class="s0">3143 14 get_class_slot 0 4 3718 31 DepthTestAttrib::get_class_slot 0 1 1452 0</span>
<span class="s0">49</span>
<span class="s0">static int DepthTestAttrib::get_class_slot(void);</span>

<span class="s0">3144 14 get_class_type 0 4 3718 31 DepthTestAttrib::get_class_type 0 1 1453 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle DepthTestAttrib::get_class_type(void);</span>

<span class="s0">3145 16 ~DepthTestAttrib 0 516 3718 33 DepthTestAttrib::~DepthTestAttrib 0 0 0</span>
<span class="s0">40</span>
<span class="s0">DepthTestAttrib::~DepthTestAttrib(void);</span>

<span class="s0">3146 4 make 0 4 3719 22 DepthWriteAttrib::make 0 1 1454 52</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new DepthWriteAttrib object.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; DepthWriteAttrib::make(DepthWriteAttrib::Mode mode);</span>

<span class="s0">3147 12 make_default 0 4 3719 30 DepthWriteAttrib::make_default 0 1 1455 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; DepthWriteAttrib::make_default(void);</span>

<span class="s0">3148 8 get_mode 0 4 3719 26 DepthWriteAttrib::get_mode 0 1 1456 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the depth write mode.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline DepthWriteAttrib::Mode DepthWriteAttrib::get_mode(void) const;</span>

<span class="s0">3149 14 get_class_slot 0 4 3719 32 DepthWriteAttrib::get_class_slot 0 1 1457 0</span>
<span class="s0">50</span>
<span class="s0">static int DepthWriteAttrib::get_class_slot(void);</span>

<span class="s0">3150 14 get_class_type 0 4 3719 32 DepthWriteAttrib::get_class_type 0 1 1458 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle DepthWriteAttrib::get_class_type(void);</span>

<span class="s0">3151 17 ~DepthWriteAttrib 0 516 3719 35 DepthWriteAttrib::~DepthWriteAttrib 0 0 0</span>
<span class="s0">42</span>
<span class="s0">DepthWriteAttrib::~DepthWriteAttrib(void);</span>

<span class="s0">3152 6 ~Light 0 518 3721 13 Light::~Light 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">virtual Light::~Light(void);</span>

<span class="s0">3153 7 as_node 0 6 3721 14 Light::as_node 0 1 1459 0</span>
<span class="s0">44</span>
<span class="s0">virtual PandaNode *Light::as_node(void) = 0;</span>

<span class="s0">3154 16 is_ambient_light 0 6 3721 23 Light::is_ambient_light 0 1 1460 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is an AmbientLight, false if it is some other kind of</span>
 <span class="s0">* light.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">virtual bool Light::is_ambient_light(void) const;</span>

<span class="s0">3155 9 get_color 0 4 3721 16 Light::get_color 0 1 1461 48</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the basic color of the light.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline LColor const &amp;Light::get_color(void) const;</span>

<span class="s0">3156 9 set_color 0 4 3721 16 Light::set_color 0 1 1462 45</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the basic color of the light.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void Light::set_color(LColor const &amp;color);</span>

<span class="s0">3157 21 has_color_temperature 0 4 3721 28 Light::has_color_temperature 0 1 1463 140</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the color was specified as a temperature in kelvins, and</span>
 <span class="s0">* get_color_temperature is defined.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool Light::has_color_temperature(void) const;</span>

<span class="s0">3158 21 get_color_temperature 0 4 3721 28 Light::get_color_temperature 0 1 1464 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the basic color temperature of the light, assuming</span>
 <span class="s0">* has_color_temperature() returns true.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PN_stdfloat Light::get_color_temperature(void) const;</span>

<span class="s0">3159 21 set_color_temperature 0 4 3721 28 Light::set_color_temperature 0 1 1465 234</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color temperature of the light in kelvins.  This will recalculate</span>
 <span class="s0">* the light's color.</span>
 <span class="s0">*</span>
 <span class="s0">* The default value is 6500 K, corresponding to a perfectly white light</span>
 <span class="s0">* assuming a D65 white point.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void Light::set_color_temperature(PN_stdfloat temperature);</span>

<span class="s0">3160 12 get_exponent 0 6 3721 19 Light::get_exponent 0 1 1466 168</span>
<span class="s0">/**</span>
 <span class="s0">* For spotlights, returns the exponent that controls the amount of light</span>
 <span class="s0">* falloff from the center of the spotlight.  For other kinds of lights,</span>
 <span class="s0">* returns 0.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">virtual PN_stdfloat Light::get_exponent(void) const;</span>

<span class="s0">3161 18 get_specular_color 0 6 3721 25 Light::get_specular_color 0 1 1467 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color of specular highlights generated by the light.  This</span>
 <span class="s0">* value is meaningless for ambient lights.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual LColor const &amp;Light::get_specular_color(void) const;</span>

<span class="s0">3162 15 get_attenuation 0 6 3721 22 Light::get_attenuation 0 1 1468 193</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the terms of the attenuation equation for the light.  These are, in</span>
 <span class="s0">* order, the constant, linear, and quadratic terms based on the distance from</span>
 <span class="s0">* the point to the vertex.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual LVecBase3 const &amp;Light::get_attenuation(void) const;</span>

<span class="s0">3163 12 set_priority 0 4 3721 19 Light::set_priority 0 1 1469 411</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the relative importance of this light relative to the other lights</span>
 <span class="s0">* that are applied simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The priority number is used to decide which of the requested lights are to</span>
 <span class="s0">* be selected for rendering when more lights are requested than the hardware</span>
 <span class="s0">* will support.  The highest-priority n lights are selected for rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to TextureStage::set_priority().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void Light::set_priority(int priority);</span>

<span class="s0">3164 12 get_priority 0 4 3721 19 Light::get_priority 0 1 1470 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the priority associated with this light.  See set_priority().</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int Light::get_priority(void) const;</span>

<span class="s0">3165 18 get_class_priority 0 6 3721 25 Light::get_class_priority 0 1 1471 0</span>
<span class="s0">54</span>
<span class="s0">virtual int Light::get_class_priority(void) const = 0;</span>

<span class="s0">3166 14 get_class_type 0 4 3721 21 Light::get_class_type 0 1 1472 0</span>
<span class="s0">46</span>
<span class="s0">static TypeHandle Light::get_class_type(void);</span>

<span class="s0">3167 4 make 0 4 3722 17 LightAttrib::make 0 5 1473 1474 1475 1476 1477 855</span>
<span class="s0">// The following is the new, more general interface to the LightAttrib.</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns on (or off, according to op)</span>
 <span class="s0">* the indicated light(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns on (or off, according to op)</span>
 <span class="s0">* the indicate light(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns on (or off, according to op)</span>
 <span class="s0">* the indicate light(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns on (or off, according to op)</span>
 <span class="s0">* the indicate light(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightAttrib object that does nothing.</span>
 <span class="s0">*/</span>
<span class="s0">547</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::make(LightAttrib::Operation op, Light *light);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2, Light *light3);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::make(LightAttrib::Operation op, Light *light1, Light *light2, Light *light3, Light *light4);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::make(void);</span>

<span class="s0">3168 12 make_default 0 4 3722 25 LightAttrib::make_default 0 1 1478 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::make_default(void);</span>

<span class="s0">3169 13 get_operation 0 4 3722 26 LightAttrib::get_operation 0 1 1479 505</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the basic operation type of the LightAttrib.  If this is O_set, the</span>
 <span class="s0">* lights listed here completely replace any lights that were already on.  If</span>
 <span class="s0">* this is O_add, the lights here are added to the set of lights that were</span>
 <span class="s0">* already on, and if O_remove, the lights here are removed from the set of</span>
 <span class="s0">* lights that were on.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated LightAttribs nowadays have a separate list of on_lights and</span>
 <span class="s0">* off_lights, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">LightAttrib::Operation LightAttrib::get_operation(void) const;</span>

<span class="s0">3170 14 get_num_lights 0 4 3722 27 LightAttrib::get_num_lights 0 1 1480 230</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of lights listed in the attribute.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated LightAttribs nowadays have a separate list of on_lights and</span>
 <span class="s0">* off_lights, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">int LightAttrib::get_num_lights(void) const;</span>

<span class="s0">3171 9 get_light 0 4 3722 22 LightAttrib::get_light 0 1 1481 223</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth light listed in the attribute.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated LightAttribs nowadays have a separate list of on_lights and</span>
 <span class="s0">* off_lights, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">Light *LightAttrib::get_light(int n) const;</span>

<span class="s0">3172 9 has_light 0 4 3722 22 LightAttrib::has_light 0 1 1482 257</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated light is listed in the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated LightAttribs nowadays have a separate list of on_lights and</span>
 <span class="s0">* off_lights, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool LightAttrib::has_light(Light *light) const;</span>

<span class="s0">3173 9 add_light 0 4 3722 22 LightAttrib::add_light 0 1 1483 183</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* added to the list of lights.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::add_light(Light *light) const;</span>

<span class="s0">3174 12 remove_light 0 4 3722 25 LightAttrib::remove_light 0 1 1484 193</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* removed from the list of lights.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use remove_on_light() or remove_off_light() instead.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::remove_light(Light *light) const;</span>

<span class="s0">3175 12 make_all_off 0 4 3722 25 LightAttrib::make_all_off 0 1 1485 106</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns off all lights (and hence</span>
 <span class="s0">* disables lighting).</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::make_all_off(void);</span>

<span class="s0">3176 17 get_num_on_lights 0 4 3722 30 LightAttrib::get_num_on_lights 0 1 1486 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of lights that are turned on by the attribute.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t LightAttrib::get_num_on_lights(void) const;</span>

<span class="s0">3177 26 get_num_non_ambient_lights 0 4 3722 39 LightAttrib::get_num_non_ambient_lights 0 1 1487 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of non-ambient lights that are turned on by this</span>
 <span class="s0">* attribute.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline std::size_t LightAttrib::get_num_non_ambient_lights(void) const;</span>

<span class="s0">3178 12 get_on_light 0 4 3722 25 LightAttrib::get_on_light 0 1 1488 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth light turned on by the attribute, sorted in render order.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline NodePath LightAttrib::get_on_light(std::size_t n) const;</span>

<span class="s0">3179 12 has_on_light 0 4 3722 25 LightAttrib::has_on_light 0 1 1489 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated light is turned on by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline bool LightAttrib::has_on_light(NodePath const &amp;light) const;</span>

<span class="s0">3180 16 has_any_on_light 0 4 3722 29 LightAttrib::has_any_on_light 0 1 1490 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any light is turned on by the attrib, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool LightAttrib::has_any_on_light(void) const;</span>

<span class="s0">3181 18 get_num_off_lights 0 4 3722 31 LightAttrib::get_num_off_lights 0 1 1491 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of lights that are turned off by the attribute.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::size_t LightAttrib::get_num_off_lights(void) const;</span>

<span class="s0">3182 13 get_off_light 0 4 3722 26 LightAttrib::get_off_light 0 1 1492 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth light turned off by the attribute, sorted in arbitrary</span>
 <span class="s0">* (pointer) order.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline NodePath LightAttrib::get_off_light(std::size_t n) const;</span>

<span class="s0">3183 13 has_off_light 0 4 3722 26 LightAttrib::has_off_light 0 1 1493 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated light is turned off by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool LightAttrib::has_off_light(NodePath const &amp;light) const;</span>

<span class="s0">3184 11 has_all_off 0 4 3722 24 LightAttrib::has_all_off 0 1 1494 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this attrib turns off all lights (although it may also turn</span>
 <span class="s0">* some on).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool LightAttrib::has_all_off(void) const;</span>

<span class="s0">3185 11 is_identity 0 4 3722 24 LightAttrib::is_identity 0 1 1495 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is an identity attrib: it does not change the set of</span>
 <span class="s0">* lights in use.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool LightAttrib::is_identity(void) const;</span>

<span class="s0">3186 12 add_on_light 0 4 3722 25 LightAttrib::add_on_light 0 1 1496 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* added to the list of lights turned on by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::add_on_light(NodePath const &amp;light) const;</span>

<span class="s0">3187 15 remove_on_light 0 4 3722 28 LightAttrib::remove_on_light 0 1 1497 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* removed from the list of lights turned on by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::remove_on_light(NodePath const &amp;light) const;</span>

<span class="s0">3188 16 replace_on_light 0 4 3722 29 LightAttrib::replace_on_light 0 1 1498 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* replaced with the given other light.</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::replace_on_light(NodePath const &amp;source, NodePath const &amp;dest) const;</span>

<span class="s0">3189 13 add_off_light 0 4 3722 26 LightAttrib::add_off_light 0 1 1499 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* added to the list of lights turned off by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::add_off_light(NodePath const &amp;light) const;</span>

<span class="s0">3190 16 remove_off_light 0 4 3722 29 LightAttrib::remove_off_light 0 1 1500 148</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* removed from the list of lights turned off by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::remove_off_light(NodePath const &amp;light) const;</span>

<span class="s0">3191 17 replace_off_light 0 4 3722 30 LightAttrib::replace_off_light 0 1 1501 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* replaced with the given other light.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; LightAttrib::replace_off_light(NodePath const &amp;source, NodePath const &amp;dest) const;</span>

<span class="s0">3192 24 get_most_important_light 0 4 3722 37 LightAttrib::get_most_important_light 0 1 1502 209</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the most important light (that is, the light with the highest</span>
 <span class="s0">* priority) in the LightAttrib, excluding any ambient lights.  Returns an</span>
 <span class="s0">* empty NodePath if no non-ambient lights are found.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">NodePath LightAttrib::get_most_important_light(void) const;</span>

<span class="s0">3193 24 get_ambient_contribution 0 4 3722 37 LightAttrib::get_ambient_contribution 0 1 1503 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total contribution of all the ambient lights.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">LColor LightAttrib::get_ambient_contribution(void) const;</span>

<span class="s0">3194 14 get_class_slot 0 4 3722 27 LightAttrib::get_class_slot 0 1 1504 0</span>
<span class="s0">45</span>
<span class="s0">static int LightAttrib::get_class_slot(void);</span>

<span class="s0">3195 14 get_class_type 0 4 3722 27 LightAttrib::get_class_type 0 1 1505 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle LightAttrib::get_class_type(void);</span>

<span class="s0">3196 12 make_default 0 4 3724 29 LightRampAttrib::make_default 0 1 1506 151</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This is the standard OpenGL</span>
 <span class="s0">* lighting ramp, which clamps the final light total to the 0-1 range.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightRampAttrib::make_default(void);</span>

<span class="s0">3197 13 make_identity 0 4 3724 30 LightRampAttrib::make_identity 0 1 1507 169</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This differs from the usual</span>
 <span class="s0">* OpenGL lighting model in that it does not clamp the final lighting total to</span>
 <span class="s0">* (0,1).</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightRampAttrib::make_identity(void);</span>

<span class="s0">3198 21 make_single_threshold 0 4 3724 38 LightRampAttrib::make_single_threshold 0 1 1508 290</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes the luminance of the</span>
 <span class="s0">* diffuse lighting contribution to be quantized using a single threshold:</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* if (original_luminance &gt; threshold0) {</span>
 <span class="s0">*   luminance = level0;</span>
 <span class="s0">* } else {</span>
 <span class="s0">*   luminance = 0.0;</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightRampAttrib::make_single_threshold(PN_stdfloat thresh0, PN_stdfloat lev0);</span>

<span class="s0">3199 21 make_double_threshold 0 4 3724 38 LightRampAttrib::make_double_threshold 0 1 1509 360</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes the luminance of the</span>
 <span class="s0">* diffuse lighting contribution to be quantized using two thresholds:</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* if (original_luminance &gt; threshold1) {</span>
 <span class="s0">*   luminance = level1;</span>
 <span class="s0">* } else if (original_luminance &gt; threshold0) {</span>
 <span class="s0">*   luminance = level0;</span>
 <span class="s0">* } else {</span>
 <span class="s0">*   luminance = 0.0;</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightRampAttrib::make_double_threshold(PN_stdfloat thresh0, PN_stdfloat lev0, PN_stdfloat thresh1, PN_stdfloat lev1);</span>

<span class="s0">3200 9 make_hdr0 0 4 3724 26 LightRampAttrib::make_hdr0 0 1 1510 814</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes an HDR tone mapping</span>
 <span class="s0">* operation to be applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, brightness values greater than 1 cannot be distinguished from</span>
 <span class="s0">* each other, causing very brightly lit objects to wash out white and all</span>
 <span class="s0">* detail to be erased.  HDR tone mapping remaps brightness values in the</span>
 <span class="s0">* range 0-infinity into the range (0,1), making it possible to distinguish</span>
 <span class="s0">* detail in scenes whose brightness exceeds 1.</span>
 <span class="s0">*</span>
 <span class="s0">* However, the monitor has finite contrast.  Normally, all of that contrast</span>
 <span class="s0">* is used to represent brightnesses in the range 0-1.  The HDR0 tone mapping</span>
 <span class="s0">* operator 'steals' one quarter of that contrast to represent brightnesses in</span>
 <span class="s0">* the range 1-infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* FINAL_RGB = (RGB^3 + RGB^2 + RGB) / (RGB^3 + RGB^2 + RGB + 1)</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightRampAttrib::make_hdr0(void);</span>

<span class="s0">3201 9 make_hdr1 0 4 3724 26 LightRampAttrib::make_hdr1 0 1 1511 796</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes an HDR tone mapping</span>
 <span class="s0">* operation to be applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, brightness values greater than 1 cannot be distinguished from</span>
 <span class="s0">* each other, causing very brightly lit objects to wash out white and all</span>
 <span class="s0">* detail to be erased.  HDR tone mapping remaps brightness values in the</span>
 <span class="s0">* range 0-infinity into the range (0,1), making it possible to distinguish</span>
 <span class="s0">* detail in scenes whose brightness exceeds 1.</span>
 <span class="s0">*</span>
 <span class="s0">* However, the monitor has finite contrast.  Normally, all of that contrast</span>
 <span class="s0">* is used to represent brightnesses in the range 0-1.  The HDR1 tone mapping</span>
 <span class="s0">* operator 'steals' one third of that contrast to represent brightnesses in</span>
 <span class="s0">* the range 1-infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* FINAL_RGB = (RGB^2 + RGB) / (RGB^2 + RGB + 1)</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightRampAttrib::make_hdr1(void);</span>

<span class="s0">3202 9 make_hdr2 0 4 3724 26 LightRampAttrib::make_hdr2 0 1 1512 779</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes an HDR tone mapping</span>
 <span class="s0">* operation to be applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, brightness values greater than 1 cannot be distinguished from</span>
 <span class="s0">* each other, causing very brightly lit objects to wash out white and all</span>
 <span class="s0">* detail to be erased.  HDR tone mapping remaps brightness values in the</span>
 <span class="s0">* range 0-infinity into the range (0,1), making it possible to distinguish</span>
 <span class="s0">* detail in scenes whose brightness exceeds 1.</span>
 <span class="s0">*</span>
 <span class="s0">* However, the monitor has finite contrast.  Normally, all of that contrast</span>
 <span class="s0">* is used to represent brightnesses in the range 0-1.  The HDR2 tone mapping</span>
 <span class="s0">* operator 'steals' one half of that contrast to represent brightnesses in</span>
 <span class="s0">* the range 1-infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* FINAL_RGB = (RGB) / (RGB + 1)</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; LightRampAttrib::make_hdr2(void);</span>

<span class="s0">3203 8 get_mode 0 4 3724 25 LightRampAttrib::get_mode 0 1 1513 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the LightRampAttrib mode.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline LightRampAttrib::LightRampMode LightRampAttrib::get_mode(void) const;</span>

<span class="s0">3204 9 get_level 0 4 3724 26 LightRampAttrib::get_level 0 1 1514 42</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth lighting level.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PN_stdfloat LightRampAttrib::get_level(int n) const;</span>

<span class="s0">3205 13 get_threshold 0 4 3724 30 LightRampAttrib::get_threshold 0 1 1515 43</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth threshold level.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline PN_stdfloat LightRampAttrib::get_threshold(int n) const;</span>

<span class="s0">3206 14 get_class_slot 0 4 3724 31 LightRampAttrib::get_class_slot 0 1 1516 0</span>
<span class="s0">49</span>
<span class="s0">static int LightRampAttrib::get_class_slot(void);</span>

<span class="s0">3207 14 get_class_type 0 4 3724 31 LightRampAttrib::get_class_type 0 1 1517 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle LightRampAttrib::get_class_type(void);</span>

<span class="s0">3208 16 ~LightRampAttrib 0 516 3724 33 LightRampAttrib::~LightRampAttrib 0 0 0</span>
<span class="s0">40</span>
<span class="s0">LightRampAttrib::~LightRampAttrib(void);</span>

<span class="s0">3209 29 upcast_to_TypedReferenceCount 0 12 3726 37 Loader::upcast_to_TypedReferenceCount 0 1 1536 41</span>
<span class="s0">upcast from Loader to TypedReferenceCount</span>
<span class="s0">65</span>
<span class="s0">TypedReferenceCount *Loader::upcast_to_TypedReferenceCount(void);</span>

<span class="s0">3210 18 downcast_to_Loader 0 12 3657 39 TypedReferenceCount::downcast_to_Loader 0 0 43</span>
<span class="s0">downcast from TypedReferenceCount to Loader</span>
<span class="s0">54</span>
<span class="s0">Loader *TypedReferenceCount::downcast_to_Loader(void);</span>

<span class="s0">3211 17 upcast_to_Namable 0 12 3726 25 Loader::upcast_to_Namable 0 1 1537 29</span>
<span class="s0">upcast from Loader to Namable</span>
<span class="s0">41</span>
<span class="s0">Namable *Loader::upcast_to_Namable(void);</span>

<span class="s0">3212 18 downcast_to_Loader 0 12 3616 27 Namable::downcast_to_Loader 0 0 31</span>
<span class="s0">downcast from Namable to Loader</span>
<span class="s0">42</span>
<span class="s0">Loader *Namable::downcast_to_Loader(void);</span>

<span class="s0">3213 7 Results 0 260 3727 24 Loader::Results::Results 0 2 1538 1539 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">100</span>
<span class="s0">inline Loader::Results::Results(void);</span>
<span class="s0">inline Loader::Results::Results(Loader::Results const &amp;copy);</span>

<span class="s0">3214 10 operator = 0 4 3727 27 Loader::Results::operator = 0 1 1540 0</span>
<span class="s0">69</span>
<span class="s0">inline void Loader::Results::operator =(Loader::Results const &amp;copy);</span>

<span class="s0">3215 8 ~Results 0 516 3727 25 Loader::Results::~Results 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline Loader::Results::~Results(void);</span>

<span class="s0">3216 5 clear 0 4 3727 22 Loader::Results::clear 0 1 1541 47</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the files from the list.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void Loader::Results::clear(void);</span>

<span class="s0">3217 13 get_num_files 0 4 3727 30 Loader::Results::get_num_files 0 1 1542 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of files on the result list.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int Loader::Results::get_num_files(void) const;</span>

<span class="s0">3218 8 get_file 0 4 3727 25 Loader::Results::get_file 0 1 1543 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth file on the result list.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline Filename const &amp;Loader::Results::get_file(int n) const;</span>

<span class="s0">3219 13 get_file_type 0 4 3727 30 Loader::Results::get_file_type 0 1 1544 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the file type of the nth file on the result list.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline LoaderFileType *Loader::Results::get_file_type(int n) const;</span>

<span class="s0">3220 6 Loader 0 260 3726 14 Loader::Loader 0 2 1518 1519 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">explicit Loader::Loader(std::string const &amp;name = &quot;loader&quot;);</span>
<span class="s0">inline Loader::Loader(Loader const &amp;) = default;</span>

<span class="s0">3221 16 set_task_manager 0 4 3726 24 Loader::set_task_manager 0 1 1520 118</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the task manager that is used for asynchronous loads.  The</span>
 <span class="s0">* default is the global task manager.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void Loader::set_task_manager(AsyncTaskManager *task_manager);</span>

<span class="s0">3222 16 get_task_manager 0 4 3726 24 Loader::get_task_manager 0 1 1521 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the task manager that is used for asynchronous loads.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline AsyncTaskManager *Loader::get_task_manager(void) const;</span>

<span class="s0">3223 14 set_task_chain 0 4 3726 22 Loader::set_task_chain 0 1 1522 130</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the task chain that is used for asynchronous loads.  The default</span>
 <span class="s0">* is the initial name of the Loader object.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void Loader::set_task_chain(std::string const &amp;task_chain);</span>

<span class="s0">3224 14 get_task_chain 0 4 3726 22 Loader::get_task_chain 0 1 1523 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the task chain that is used for asynchronous loads.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline std::string const &amp;Loader::get_task_chain(void) const;</span>

<span class="s0">3225 12 stop_threads 0 4 3726 20 Loader::stop_threads 0 1 1524 56</span>
<span class="s0">/**</span>
 <span class="s0">* Stop any threads used for asynchronous loads.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">inline void Loader::stop_threads(void);</span>

<span class="s0">3226 6 remove 0 4 3726 14 Loader::remove 0 1 1525 168</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a pending asynchronous load request.  Returns true if successful,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">* @deprecated use task.cancel() to cancel the request instead.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool Loader::remove(AsyncTask *task);</span>

<span class="s0">3227 9 load_sync 0 4 3726 17 Loader::load_sync 0 1 1526 187</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the file immediately, waiting for it to complete.</span>
 <span class="s0">*</span>
 <span class="s0">* If search is true, the file is searched for along the model path;</span>
 <span class="s0">* otherwise, only the exact filename is loaded.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">inline PointerTo&lt; PandaNode &gt; Loader::load_sync(Filename const &amp;filename, LoaderOptions const &amp;options = LoaderOptions()) const;</span>

<span class="s0">3228 18 make_async_request 0 4 3726 26 Loader::make_async_request 0 1 1527 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new AsyncTask object suitable for adding to load_async() to start</span>
 <span class="s0">* an asynchronous model load.</span>
 <span class="s0">*/</span>
<span class="s0">124</span>
<span class="s0">PointerTo&lt; AsyncTask &gt; Loader::make_async_request(Filename const &amp;filename, LoaderOptions const &amp;options = LoaderOptions());</span>

<span class="s0">3229 10 load_async 0 4 3726 18 Loader::load_async 0 1 1528 591</span>
<span class="s0">/**</span>
 <span class="s0">* Begins an asynchronous load request.  To use this call, first call</span>
 <span class="s0">* make_async_request() to create a new ModelLoadRequest object with the</span>
 <span class="s0">* filename you wish to load, and then add that object to the Loader with</span>
 <span class="s0">* load_async.  This function will return immediately, and the model will be</span>
 <span class="s0">* loaded in the background.</span>
 <span class="s0">*</span>
 <span class="s0">* To determine when the model has completely loaded, you may poll</span>
 <span class="s0">* request-&gt;is_ready() from time to time, or set the done_event on the request</span>
 <span class="s0">* object and listen for that event.  When the model is ready, you may</span>
 <span class="s0">* retrieve it via request-&gt;get_model().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void Loader::load_async(AsyncTask *request);</span>

<span class="s0">3230 9 save_sync 0 4 3726 17 Loader::save_sync 0 1 1529 66</span>
<span class="s0">/**</span>
 <span class="s0">* Saves the file immediately, waiting for it to complete.</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">inline bool Loader::save_sync(Filename const &amp;filename, LoaderOptions const &amp;options, PandaNode *node) const;</span>

<span class="s0">3231 23 make_async_save_request 0 4 3726 31 Loader::make_async_save_request 0 1 1530 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new AsyncTask object suitable for adding to save_async() to start</span>
 <span class="s0">* an asynchronous model save.</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">PointerTo&lt; AsyncTask &gt; Loader::make_async_save_request(Filename const &amp;filename, LoaderOptions const &amp;options, PandaNode *node);</span>

<span class="s0">3232 10 save_async 0 4 3726 18 Loader::save_async 0 1 1531 620</span>
<span class="s0">/**</span>
 <span class="s0">* Begins an asynchronous save request.  To use this call, first call</span>
 <span class="s0">* make_async_save_request() to create a new ModelSaveRequest object with the</span>
 <span class="s0">* filename you wish to load, and then add that object to the Loader with</span>
 <span class="s0">* save_async.  This function will return immediately, and the model will be</span>
 <span class="s0">* loaded in the background.</span>
 <span class="s0">*</span>
 <span class="s0">* To determine when the model has completely loaded, you may poll</span>
 <span class="s0">* request-&gt;is_ready() from time to time, or set the done_event on the request</span>
 <span class="s0">* object and listen for that event.  When the request is ready, you may</span>
 <span class="s0">* retrieve the success or failure via request-&gt;get_success().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void Loader::save_async(AsyncTask *request);</span>

<span class="s0">3233 15 load_bam_stream 0 4 3726 23 Loader::load_bam_stream 0 1 1532 109</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to read a bam file from the indicated stream and return the scene</span>
 <span class="s0">* graph defined there.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">PointerTo&lt; PandaNode &gt; Loader::load_bam_stream(std::istream &amp;in);</span>

<span class="s0">3234 6 output 0 6 3726 14 Loader::output 0 1 1533 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">virtual void Loader::output(std::ostream &amp;out) const;</span>

<span class="s0">3235 14 get_global_ptr 0 4 3726 22 Loader::get_global_ptr 0 1 1534 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global Loader.  This is the Loader that most code</span>
 <span class="s0">* should use for loading models.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline Loader *Loader::get_global_ptr(void);</span>

<span class="s0">3236 14 get_class_type 0 4 3726 22 Loader::get_class_type 0 1 1535 0</span>
<span class="s0">47</span>
<span class="s0">static TypeHandle Loader::get_class_type(void);</span>

<span class="s0">3237 7 ~Loader 0 516 3726 15 Loader::~Loader 0 0 0</span>
<span class="s0">22</span>
<span class="s0">Loader::~Loader(void);</span>

<span class="s0">3238 8 get_name 0 6 3728 24 LoaderFileType::get_name 0 1 1545 0</span>
<span class="s0">61</span>
<span class="s0">virtual std::string LoaderFileType::get_name(void) const = 0;</span>

<span class="s0">3239 13 get_extension 0 6 3728 29 LoaderFileType::get_extension 0 1 1546 0</span>
<span class="s0">66</span>
<span class="s0">virtual std::string LoaderFileType::get_extension(void) const = 0;</span>

<span class="s0">3240 25 get_additional_extensions 0 6 3728 41 LoaderFileType::get_additional_extensions 0 1 1547 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a space-separated list of extension, in addition to the one</span>
 <span class="s0">* returned by get_extension(), that are recognized by this loader.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">virtual std::string LoaderFileType::get_additional_extensions(void) const;</span>

<span class="s0">3241 19 supports_compressed 0 6 3728 35 LoaderFileType::supports_compressed 0 1 1548 132</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this file type can transparently load compressed files</span>
 <span class="s0">* (with a .pz or .gz extension), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual bool LoaderFileType::supports_compressed(void) const;</span>

<span class="s0">3242 20 get_allow_disk_cache 0 6 3728 36 LoaderFileType::get_allow_disk_cache 0 1 1549 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the loader flags allow retrieving the model from the on-</span>
 <span class="s0">* disk bam cache (if it is enabled), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">virtual bool LoaderFileType::get_allow_disk_cache(LoaderOptions const &amp;options) const;</span>

<span class="s0">3243 19 get_allow_ram_cache 0 6 3728 35 LoaderFileType::get_allow_ram_cache 0 1 1550 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the loader flags allow retrieving the model from the in-</span>
 <span class="s0">* memory ModelPool cache, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">virtual bool LoaderFileType::get_allow_ram_cache(LoaderOptions const &amp;options) const;</span>

<span class="s0">3244 13 supports_load 0 6 3728 29 LoaderFileType::supports_load 0 1 1551 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the file type can be used to load files, and load_file() is</span>
 <span class="s0">* supported.  Returns false if load_file() is unimplemented and will always</span>
 <span class="s0">* fail.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">virtual bool LoaderFileType::supports_load(void) const;</span>

<span class="s0">3245 13 supports_save 0 6 3728 29 LoaderFileType::supports_save 0 1 1552 172</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the file type can be used to save files, and save_file() is</span>
 <span class="s0">* supported.  Returns false if save_file() is unimplemented and will always</span>
 <span class="s0">* fail.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">virtual bool LoaderFileType::supports_save(void) const;</span>

<span class="s0">3246 14 get_class_type 0 4 3728 30 LoaderFileType::get_class_type 0 1 1553 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle LoaderFileType::get_class_type(void);</span>

<span class="s0">3247 23 ~LoaderFileTypeRegistry 0 516 3730 47 LoaderFileTypeRegistry::~LoaderFileTypeRegistry 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">LoaderFileTypeRegistry::~LoaderFileTypeRegistry(void);</span>

<span class="s0">3248 13 register_type 0 4 3730 37 LoaderFileTypeRegistry::register_type 0 1 1555 56</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a new LoaderFileType in the universe.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void LoaderFileTypeRegistry::register_type(PyObject *type);</span>

<span class="s0">3249 22 register_deferred_type 0 4 3730 46 LoaderFileTypeRegistry::register_deferred_type 0 1 1556 305</span>
<span class="s0">/**</span>
 <span class="s0">* Records a type associated with a particular extension to be loaded in the</span>
 <span class="s0">* future.  The named library will be dynamically loaded the first time files</span>
 <span class="s0">* of this extension are loaded; presumably this library will call</span>
 <span class="s0">* register_type() when it initializes, thus making the extension loadable.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">void LoaderFileTypeRegistry::register_deferred_type(PyObject *entry_point);</span>

<span class="s0">3250 15 unregister_type 0 4 3730 39 LoaderFileTypeRegistry::unregister_type 0 1 1557 68</span>
<span class="s0">/**</span>
 <span class="s0">* Removes a type previously registered using register_type.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void LoaderFileTypeRegistry::unregister_type(PyObject *type);</span>

<span class="s0">3251 13 get_num_types 0 4 3730 37 LoaderFileTypeRegistry::get_num_types 0 1 1558 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of types registered.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">int LoaderFileTypeRegistry::get_num_types(void) const;</span>

<span class="s0">3252 8 get_type 0 4 3730 32 LoaderFileTypeRegistry::get_type 0 1 1559 43</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth type registered.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">LoaderFileType *LoaderFileTypeRegistry::get_type(int n) const;</span>

<span class="s0">3253 23 get_type_from_extension 0 4 3730 47 LoaderFileTypeRegistry::get_type_from_extension 0 1 1560 163</span>
<span class="s0">/**</span>
 <span class="s0">* Determines the type of the file based on the indicated extension (without a</span>
 <span class="s0">* leading dot).  Returns NULL if the extension matches no known file types.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">LoaderFileType *LoaderFileTypeRegistry::get_type_from_extension(std::string const &amp;extension);</span>

<span class="s0">3254 5 write 0 4 3730 29 LoaderFileTypeRegistry::write 0 1 1561 97</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a list of supported file types to the indicated output stream, one</span>
 <span class="s0">* per line.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void LoaderFileTypeRegistry::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">3255 14 get_global_ptr 0 4 3730 38 LoaderFileTypeRegistry::get_global_ptr 0 1 1562 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global LoaderFileTypeRegistry object.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static LoaderFileTypeRegistry *LoaderFileTypeRegistry::get_global_ptr(void);</span>

<span class="s0">3256 10 __reduce__ 0 4 3730 34 LoaderFileTypeRegistry::__reduce__ 0 1 1563 0</span>
<span class="s0">57</span>
<span class="s0">PyObject *LoaderFileTypeRegistry::__reduce__(void) const;</span>

<span class="s0">3257 22 LoaderFileTypeRegistry 0 260 3730 46 LoaderFileTypeRegistry::LoaderFileTypeRegistry 0 1 1554 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline LoaderFileTypeRegistry::LoaderFileTypeRegistry(LoaderFileTypeRegistry const &amp;) = default;</span>

<span class="s0">3258 4 make 0 4 3732 20 MaterialAttrib::make 0 1 1564 113</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new MaterialAttrib object suitable for rendering the indicated</span>
 <span class="s0">* material onto geometry.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; MaterialAttrib::make(Material *material);</span>

<span class="s0">3259 8 make_off 0 4 3732 24 MaterialAttrib::make_off 0 1 1565 97</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new MaterialAttrib object suitable for rendering unmateriald</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; MaterialAttrib::make_off(void);</span>

<span class="s0">3260 12 make_default 0 4 3732 28 MaterialAttrib::make_default 0 1 1566 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; MaterialAttrib::make_default(void);</span>

<span class="s0">3261 6 is_off 0 4 3732 22 MaterialAttrib::is_off 0 1 1567 132</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the MaterialAttrib is an 'off' MaterialAttrib, indicating</span>
 <span class="s0">* that it should disable the use of materials.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool MaterialAttrib::is_off(void) const;</span>

<span class="s0">3262 12 get_material 0 4 3732 28 MaterialAttrib::get_material 0 1 1568 133</span>
<span class="s0">/**</span>
 <span class="s0">* If the MaterialAttrib is not an 'off' MaterialAttrib, returns the material</span>
 <span class="s0">* that is associated.  Otherwise, return NULL.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline Material *MaterialAttrib::get_material(void) const;</span>

<span class="s0">3263 14 get_class_slot 0 4 3732 30 MaterialAttrib::get_class_slot 0 1 1569 0</span>
<span class="s0">48</span>
<span class="s0">static int MaterialAttrib::get_class_slot(void);</span>

<span class="s0">3264 14 get_class_type 0 4 3732 30 MaterialAttrib::get_class_type 0 1 1570 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle MaterialAttrib::get_class_type(void);</span>

<span class="s0">3265 15 ~MaterialAttrib 0 516 3732 31 MaterialAttrib::~MaterialAttrib 0 0 0</span>
<span class="s0">38</span>
<span class="s0">MaterialAttrib::~MaterialAttrib(void);</span>

<span class="s0">3266 19 ModelFlattenRequest 0 260 3735 40 ModelFlattenRequest::ModelFlattenRequest 0 2 1571 1572 121</span>
<span class="s0">/**</span>
 <span class="s0">* Create a new ModelFlattenRequest, and add it to the loader via</span>
 <span class="s0">* load_async(), to begin an asynchronous load.</span>
 <span class="s0">*/</span>
<span class="s0">162</span>
<span class="s0">inline explicit ModelFlattenRequest::ModelFlattenRequest(PandaNode *orig);</span>
<span class="s0">inline ModelFlattenRequest::ModelFlattenRequest(ModelFlattenRequest const &amp;) = default;</span>

<span class="s0">3267 8 get_orig 0 4 3735 29 ModelFlattenRequest::get_orig 0 1 1573 50</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the original, unflattened node.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PandaNode *ModelFlattenRequest::get_orig(void) const;</span>

<span class="s0">3268 8 is_ready 0 4 3735 29 ModelFlattenRequest::is_ready 0 1 1574 239</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending.</span>
 <span class="s0">* When this returns true, you may retrieve the model loaded by calling</span>
 <span class="s0">* result().</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool ModelFlattenRequest::is_ready(void) const;</span>

<span class="s0">3269 9 get_model 0 4 3735 30 ModelFlattenRequest::get_model 0 1 1575 148</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flattened copy of the model.  It is an error to call this</span>
 <span class="s0">* unless done() returns true.</span>
 <span class="s0">* @deprecated Use result() instead.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline PandaNode *ModelFlattenRequest::get_model(void) const;</span>

<span class="s0">3270 14 get_class_type 0 4 3735 35 ModelFlattenRequest::get_class_type 0 1 1576 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle ModelFlattenRequest::get_class_type(void);</span>

<span class="s0">3271 20 ~ModelFlattenRequest 0 516 3735 41 ModelFlattenRequest::~ModelFlattenRequest 0 0 0</span>
<span class="s0">48</span>
<span class="s0">ModelFlattenRequest::~ModelFlattenRequest(void);</span>

<span class="s0">3272 16 ModelLoadRequest 0 260 3737 34 ModelLoadRequest::ModelLoadRequest 0 2 1577 1578 118</span>
<span class="s0">/**</span>
 <span class="s0">* Create a new ModelLoadRequest, and add it to the loader via load_async(),</span>
 <span class="s0">* to begin an asynchronous load.</span>
 <span class="s0">*/</span>
<span class="s0">220</span>
<span class="s0">explicit ModelLoadRequest::ModelLoadRequest(std::string const &amp;name, Filename const &amp;filename, LoaderOptions const &amp;options, Loader *loader);</span>
<span class="s0">inline ModelLoadRequest::ModelLoadRequest(ModelLoadRequest const &amp;) = default;</span>

<span class="s0">3273 12 get_filename 0 4 3737 30 ModelLoadRequest::get_filename 0 1 1579 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename associated with this asynchronous ModelLoadRequest.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline Filename const &amp;ModelLoadRequest::get_filename(void) const;</span>

<span class="s0">3274 11 get_options 0 4 3737 29 ModelLoadRequest::get_options 0 1 1580 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the LoaderOptions associated with this asynchronous</span>
 <span class="s0">* ModelLoadRequest.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline LoaderOptions const &amp;ModelLoadRequest::get_options(void) const;</span>

<span class="s0">3275 10 get_loader 0 4 3737 28 ModelLoadRequest::get_loader 0 1 1581 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Loader object associated with this asynchronous</span>
 <span class="s0">* ModelLoadRequest.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline Loader *ModelLoadRequest::get_loader(void) const;</span>

<span class="s0">3276 8 is_ready 0 4 3737 26 ModelLoadRequest::is_ready 0 1 1582 271</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending or</span>
 <span class="s0">* if it has been cancelled.  When this returns true, you may retrieve the</span>
 <span class="s0">* model loaded by calling get_model().</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool ModelLoadRequest::is_ready(void) const;</span>

<span class="s0">3277 9 get_model 0 4 3737 27 ModelLoadRequest::get_model 0 1 1583 196</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the model that was loaded asynchronously, if any, or null if there</span>
 <span class="s0">* was an error.  It is an error to call this unless done() returns true.</span>
 <span class="s0">* @deprecated Use result() instead.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline PandaNode *ModelLoadRequest::get_model(void) const;</span>

<span class="s0">3278 14 get_class_type 0 4 3737 32 ModelLoadRequest::get_class_type 0 1 1584 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle ModelLoadRequest::get_class_type(void);</span>

<span class="s0">3279 17 ~ModelLoadRequest 0 516 3737 35 ModelLoadRequest::~ModelLoadRequest 0 0 0</span>
<span class="s0">42</span>
<span class="s0">ModelLoadRequest::~ModelLoadRequest(void);</span>

<span class="s0">3280 9 ModelNode 0 260 3743 20 ModelNode::ModelNode 0 1 1585 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline explicit ModelNode::ModelNode(std::string const &amp;name);</span>

<span class="s0">3281 22 set_preserve_transform 0 4 3743 33 ModelNode::set_preserve_transform 0 1 1586 1183</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the preserve_transform flag.  This restricts the ability of a flatten</span>
 <span class="s0">* operation to affect the transform stored on this node, and/or the node</span>
 <span class="s0">* itself.  In the order from weakest to strongest restrictions, the possible</span>
 <span class="s0">* flags are:</span>
 <span class="s0">*</span>
 <span class="s0">* PT_drop_node - This node should be removed at the next flatten call.</span>
 <span class="s0">*</span>
 <span class="s0">* PT_none - The transform may be adjusted at will.  The node itself will not</span>
 <span class="s0">* be removed.  This is the default.</span>
 <span class="s0">*</span>
 <span class="s0">* PT_net - Preserve the net transform from the root, but it's acceptable to</span>
 <span class="s0">* modify the local transform stored on this particular node if necessary, so</span>
 <span class="s0">* long as the net transform is not changed.  This eliminates the need to drop</span>
 <span class="s0">* an extra transform on the node above.</span>
 <span class="s0">*</span>
 <span class="s0">* PT_local - The local (and net) transform should not be changed in any way.</span>
 <span class="s0">* If necessary, an extra transform will be left on the node above to</span>
 <span class="s0">* guarantee this.  This is a stronger restriction than PT_net.</span>
 <span class="s0">*</span>
 <span class="s0">* PT_no_touch - The local transform will not be changed, the node will not be</span>
 <span class="s0">* removed, and furthermore any flatten operation will not continue below this</span>
 <span class="s0">* node--this node and all descendents are protected from the effects of</span>
 <span class="s0">* flatten.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline void ModelNode::set_preserve_transform(ModelNode::PreserveTransform preserve_transform);</span>

<span class="s0">3282 22 get_preserve_transform 0 4 3743 33 ModelNode::get_preserve_transform 0 1 1587 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the preserve_transform flag.  See</span>
 <span class="s0">* set_preserve_transform().</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline ModelNode::PreserveTransform ModelNode::get_preserve_transform(void) const;</span>

<span class="s0">3283 23 set_preserve_attributes 0 4 3743 34 ModelNode::set_preserve_attributes 0 1 1588 295</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the preserve_attributes flag.  This restricts the ability of a flatten</span>
 <span class="s0">* operation to affect the render attributes stored on this node.</span>
 <span class="s0">*</span>
 <span class="s0">* The value should be the union of bits from SceneGraphReducer::AttribTypes</span>
 <span class="s0">* that represent the attributes that should *not* be changed.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void ModelNode::set_preserve_attributes(int attrib_mask);</span>

<span class="s0">3284 23 get_preserve_attributes 0 4 3743 34 ModelNode::get_preserve_attributes 0 1 1589 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the preserve_attributes flag.  See</span>
 <span class="s0">* set_preserve_attributes().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int ModelNode::get_preserve_attributes(void) const;</span>

<span class="s0">3285 19 set_transform_limit 0 4 3743 30 ModelNode::set_transform_limit 0 1 1590 0</span>
<span class="s0">55</span>
<span class="s0">void ModelNode::set_transform_limit(PN_stdfloat limit);</span>

<span class="s0">3286 14 get_class_type 0 4 3743 25 ModelNode::get_class_type 0 1 1591 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle ModelNode::get_class_type(void);</span>

<span class="s0">3287 10 ~ModelNode 0 516 3743 21 ModelNode::~ModelNode 0 0 0</span>
<span class="s0">28</span>
<span class="s0">ModelNode::~ModelNode(void);</span>

<span class="s0">3288 9 ModelRoot 0 260 3745 20 ModelRoot::ModelRoot 0 2 1592 1593 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">inline explicit ModelRoot::ModelRoot(std::string const &amp;name);</span>
<span class="s0">inline explicit ModelRoot::ModelRoot(Filename const &amp;fullpath, time_t timestamp);</span>

<span class="s0">3289 19 get_model_ref_count 0 4 3745 30 ModelRoot::get_model_ref_count 0 1 1594 344</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of copies that exist of this particular ModelRoot node.</span>
 <span class="s0">* Each time ModelRoot::copy_subgraph() or make_copy() is called (or some</span>
 <span class="s0">* other copying mechanism, such as NodePath.copy_to(), is used), this count</span>
 <span class="s0">* will increment by one in all copies; when one of the copies is destructed,</span>
 <span class="s0">* this count will decrement.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline int ModelRoot::get_model_ref_count(void) const;</span>

<span class="s0">3290 12 get_fullpath 0 4 3745 23 ModelRoot::get_fullpath 0 1 1595 206</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the full pathname of the model represented by this node, as found</span>
 <span class="s0">* on disk.  This is mainly useful for reference purposes, but is also used to</span>
 <span class="s0">* index the ModelRoot into the ModelPool.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline Filename const &amp;ModelRoot::get_fullpath(void) const;</span>

<span class="s0">3291 12 set_fullpath 0 4 3745 23 ModelRoot::set_fullpath 0 1 1596 399</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the full pathname of the model represented by this node, as found on</span>
 <span class="s0">* disk.  This is mainly useful for reference purposes, but is also used to</span>
 <span class="s0">* index the ModelRoot into the ModelPool.</span>
 <span class="s0">*</span>
 <span class="s0">* This is normally set automatically when a model is loaded, and should not</span>
 <span class="s0">* be set directly by the user.  If you change this on a loaded model, then</span>
 <span class="s0">* ModelPool::release_model() may fail.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void ModelRoot::set_fullpath(Filename const &amp;fullpath);</span>

<span class="s0">3292 13 get_timestamp 0 4 3745 24 ModelRoot::get_timestamp 0 1 1597 324</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the timestamp of the file on disk that was read for this model, at</span>
 <span class="s0">* the time it was read, if it is known.  Returns 0 if the timestamp is not</span>
 <span class="s0">* known or could not be provided.  This can be used as a quick (but fallible)</span>
 <span class="s0">* check to verify whether the file might have changed since the model was</span>
 <span class="s0">* read.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline time_t ModelRoot::get_timestamp(void) const;</span>

<span class="s0">3293 13 set_timestamp 0 4 3745 24 ModelRoot::set_timestamp 0 1 1598 189</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the timestamp of the file on disk that was read for this model.  This</span>
 <span class="s0">* is normally set automatically when a model is loaded, and should not be set</span>
 <span class="s0">* directly by the user.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void ModelRoot::set_timestamp(time_t timestamp);</span>

<span class="s0">3294 14 ModelReference 0 260 3748 41 ModelRoot::ModelReference::ModelReference 0 2 1602 1603 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">150</span>
<span class="s0">inline ModelRoot::ModelReference::ModelReference(void);</span>
<span class="s0">inline ModelRoot::ModelReference::ModelReference(ModelRoot::ModelReference const &amp;) = default;</span>

<span class="s0">3295 15 ~ModelReference 0 516 3748 42 ModelRoot::ModelReference::~ModelReference 0 0 0</span>
<span class="s0">49</span>
<span class="s0">ModelRoot::ModelReference::~ModelReference(void);</span>

<span class="s0">3296 13 get_reference 0 4 3745 24 ModelRoot::get_reference 0 1 1599 315</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the pointer that represents the object shared between all copies of</span>
 <span class="s0">* this ModelRoot.  Since there's not much associated with this object other</span>
 <span class="s0">* than a reference count, normally there's not much reason to get the pointer</span>
 <span class="s0">* (though it may be compared pointerwise with other ModelRoot objects).</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline ModelRoot::ModelReference *ModelRoot::get_reference(void) const;</span>

<span class="s0">3297 13 set_reference 0 4 3745 24 ModelRoot::set_reference 0 1 1600 212</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the pointer that represents the object shared between all copies of</span>
 <span class="s0">* this ModelRoot.  This will disassociate this ModelRoot from all of its</span>
 <span class="s0">* copies.  Normally, there's no reason to do this.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void ModelRoot::set_reference(ModelRoot::ModelReference *ref);</span>

<span class="s0">3298 14 get_class_type 0 4 3745 25 ModelRoot::get_class_type 0 1 1601 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle ModelRoot::get_class_type(void);</span>

<span class="s0">3299 10 ~ModelRoot 0 516 3745 21 ModelRoot::~ModelRoot 0 0 0</span>
<span class="s0">28</span>
<span class="s0">ModelRoot::~ModelRoot(void);</span>

<span class="s0">3300 9 has_model 0 4 3750 20 ModelPool::has_model 0 1 1604 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the model has ever been loaded, false otherwise.  Note that</span>
 <span class="s0">* this does not guarantee that the model is still up-to-date.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline bool ModelPool::has_model(Filename const &amp;filename);</span>

<span class="s0">3301 12 verify_model 0 4 3750 23 ModelPool::verify_model 0 1 1605 549</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the given filename up as a model, if it has not already been loaded,</span>
 <span class="s0">* and returns true to indicate success, or false to indicate failure.  If</span>
 <span class="s0">* this returns true, it is probable that a subsequent call to load_model()</span>
 <span class="s0">* with the same model name will return a valid PandaNode.</span>
 <span class="s0">*</span>
 <span class="s0">* However, even if this returns true, it is still possible for a subsequent</span>
 <span class="s0">* call to load_model() to fail.  This can happen if cache-check-timestamps is</span>
 <span class="s0">* true, and the on-disk file is subsequently modified to replace it with an</span>
 <span class="s0">* invalid model.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static inline bool ModelPool::verify_model(Filename const &amp;filename);</span>

<span class="s0">3302 9 get_model 0 4 3750 20 ModelPool::get_model 0 1 1606 244</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the model that has already been previously loaded, or NULL</span>
 <span class="s0">* otherwise.  If verify is true, it will check if the file is still up-to-</span>
 <span class="s0">* date (and hasn't been modified in the meantime), and if not, will still</span>
 <span class="s0">* return NULL.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">static inline ModelRoot *ModelPool::get_model(Filename const &amp;filename, bool verify);</span>

<span class="s0">3303 10 load_model 0 4 3750 21 ModelPool::load_model 0 1 1607 369</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the given filename up as a model, if it has not already been loaded,</span>
 <span class="s0">* and returns the new model.  If a model with the same filename was</span>
 <span class="s0">* previously loaded, returns that one instead (unless cache-check-timestamps</span>
 <span class="s0">* is true and the file has recently changed).  If the model file cannot be</span>
 <span class="s0">* found, or cannot be loaded for some reason, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">static inline ModelRoot *ModelPool::load_model(Filename const &amp;filename, LoaderOptions const &amp;options = LoaderOptions());</span>

<span class="s0">3304 9 add_model 0 4 3750 20 ModelPool::add_model 0 2 1608 1609 384</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated already-loaded model to the pool.  The model will</span>
 <span class="s0">* replace any previously-loaded model in the pool that had the same filename.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use the one-parameter add_model(model) instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the indicated already-loaded model to the pool.  The model will</span>
 <span class="s0">* replace any previously-loaded model in the pool that had the same filename.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">static inline void ModelPool::add_model(Filename const &amp;filename, ModelRoot *model);</span>
<span class="s0">static inline void ModelPool::add_model(ModelRoot *model);</span>

<span class="s0">3305 13 release_model 0 4 3750 24 ModelPool::release_model 0 2 1610 1611 754</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated model from the pool, indicating it will never be</span>
 <span class="s0">* loaded again; the model may then be freed.  If this function is never</span>
 <span class="s0">* called, a reference count will be maintained on every model every loaded,</span>
 <span class="s0">* and models will never be freed.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use release_model(model) instead.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the indicated model from the pool, indicating it will never be</span>
 <span class="s0">* loaded again; the model may then be freed.  If this function (and</span>
 <span class="s0">* garbage_collect()) is never called, a reference count will be maintained on</span>
 <span class="s0">* every model every loaded, and models will never be freed.</span>
 <span class="s0">*</span>
 <span class="s0">* The model's get_fullpath() value should not have been changed during its</span>
 <span class="s0">* lifetime, or this function may fail to locate it in the pool.</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">static inline void ModelPool::release_model(Filename const &amp;filename);</span>
<span class="s0">static inline void ModelPool::release_model(ModelRoot *model);</span>

<span class="s0">3306 18 release_all_models 0 4 3750 29 ModelPool::release_all_models 0 1 1612 84</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all models in the pool and restores the pool to the empty state.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline void ModelPool::release_all_models(void);</span>

<span class="s0">3307 15 garbage_collect 0 4 3750 26 ModelPool::garbage_collect 0 1 1613 206</span>
<span class="s0">/**</span>
 <span class="s0">* Releases only those models in the pool that have a reference count of</span>
 <span class="s0">* exactly 1; i.e.  only those models that are not being used outside of the</span>
 <span class="s0">* pool.  Returns the number of models released.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline int ModelPool::garbage_collect(void);</span>

<span class="s0">3308 13 list_contents 0 4 3750 24 ModelPool::list_contents 0 2 1614 1615 137</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the model pool to the indicated output stream.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the model pool to cout.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">static inline void ModelPool::list_contents(std::ostream &amp;out);</span>
<span class="s0">static inline void ModelPool::list_contents(void);</span>

<span class="s0">3309 5 write 0 4 3750 16 ModelPool::write 0 1 1616 105</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the model pool to the indicated output stream.  Helps</span>
 <span class="s0">* with debugging.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">static void ModelPool::write(std::ostream &amp;out);</span>

<span class="s0">3310 10 ~ModelPool 0 516 3750 21 ModelPool::~ModelPool 0 0 0</span>
<span class="s0">28</span>
<span class="s0">ModelPool::~ModelPool(void);</span>

<span class="s0">3311 16 ModelSaveRequest 0 260 3751 34 ModelSaveRequest::ModelSaveRequest 0 2 1617 1618 118</span>
<span class="s0">/**</span>
 <span class="s0">* Create a new ModelSaveRequest, and add it to the loader via save_async(),</span>
 <span class="s0">* to begin an asynchronous save.</span>
 <span class="s0">*/</span>
<span class="s0">237</span>
<span class="s0">explicit ModelSaveRequest::ModelSaveRequest(std::string const &amp;name, Filename const &amp;filename, LoaderOptions const &amp;options, PandaNode *node, Loader *loader);</span>
<span class="s0">inline ModelSaveRequest::ModelSaveRequest(ModelSaveRequest const &amp;) = default;</span>

<span class="s0">3312 12 get_filename 0 4 3751 30 ModelSaveRequest::get_filename 0 1 1619 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename associated with this asynchronous ModelSaveRequest.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline Filename const &amp;ModelSaveRequest::get_filename(void) const;</span>

<span class="s0">3313 11 get_options 0 4 3751 29 ModelSaveRequest::get_options 0 1 1620 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the LoaderOptions associated with this asynchronous</span>
 <span class="s0">* ModelSaveRequest.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline LoaderOptions const &amp;ModelSaveRequest::get_options(void) const;</span>

<span class="s0">3314 8 get_node 0 4 3751 26 ModelSaveRequest::get_node 0 1 1621 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node that was passed to the constructor.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PandaNode *ModelSaveRequest::get_node(void) const;</span>

<span class="s0">3315 10 get_loader 0 4 3751 28 ModelSaveRequest::get_loader 0 1 1622 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Loader object associated with this asynchronous</span>
 <span class="s0">* ModelSaveRequest.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline Loader *ModelSaveRequest::get_loader(void) const;</span>

<span class="s0">3316 8 is_ready 0 4 3751 26 ModelSaveRequest::is_ready 0 1 1623 238</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending.</span>
 <span class="s0">* When this returns true, you may retrieve the success flag with</span>
 <span class="s0">* get_success().</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool ModelSaveRequest::is_ready(void) const;</span>

<span class="s0">3317 11 get_success 0 4 3751 29 ModelSaveRequest::get_success 0 1 1624 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the true if the model was saved successfully, false otherwise.  It</span>
 <span class="s0">* is an error to call this unless done() returns true.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool ModelSaveRequest::get_success(void) const;</span>

<span class="s0">3318 14 get_class_type 0 4 3751 32 ModelSaveRequest::get_class_type 0 1 1625 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle ModelSaveRequest::get_class_type(void);</span>

<span class="s0">3319 17 ~ModelSaveRequest 0 516 3751 35 ModelSaveRequest::~ModelSaveRequest 0 0 0</span>
<span class="s0">42</span>
<span class="s0">ModelSaveRequest::~ModelSaveRequest(void);</span>

<span class="s0">3320 4 make 0 4 3752 19 TextureAttrib::make 0 2 1626 1627 609</span>
<span class="s0">// These methods are used to create a simple, single-textured layer.  For</span>
<span class="s0">// multitexture, use the multitexture interfaces, further below.</span>

<span class="s0">// The following methods define the new multitexture mode for TextureAttrib.</span>
<span class="s0">// Each TextureAttrib can add or remove individual texture stages from the</span>
<span class="s0">// complete set of textures that are to be applied; this is similar to the</span>
<span class="s0">// mechanism of LightAttrib.</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new TextureAttrib object suitable for rendering the indicated</span>
 <span class="s0">* texture onto geometry, using the default TextureStage.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new TextureAttrib object that does nothing.</span>
 <span class="s0">*/</span>
<span class="s0">137</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::make(Texture *tex);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::make(void);</span>

<span class="s0">3321 8 make_off 0 4 3752 23 TextureAttrib::make_off 0 1 1628 95</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new TextureAttrib object suitable for rendering untextured</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::make_off(void);</span>

<span class="s0">3322 12 make_default 0 4 3752 27 TextureAttrib::make_default 0 1 1629 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::make_default(void);</span>

<span class="s0">3323 6 is_off 0 4 3752 21 TextureAttrib::is_off 0 1 1630 365</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the TextureAttrib is an 'off' TextureAttrib, indicating</span>
 <span class="s0">* that it should disable texturing.</span>
 <span class="s0">*</span>
 <span class="s0">* If multitexture is in effect, a TextureAttrib may not be strictly &quot;on&quot; or</span>
 <span class="s0">* &quot;off&quot;; therefore, to get a more precise answer to this question, you should</span>
 <span class="s0">* consider using has_all_off() or get_num_off_stages() or has_off_stage()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool TextureAttrib::is_off(void) const;</span>

<span class="s0">3324 11 get_texture 0 4 3752 26 TextureAttrib::get_texture 0 1 1631 141</span>
<span class="s0">/**</span>
 <span class="s0">* If the TextureAttrib is not an 'off' TextureAttrib, returns the base-level</span>
 <span class="s0">* texture that is associated.  Otherwise, return NULL.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline Texture *TextureAttrib::get_texture(void) const;</span>

<span class="s0">3325 12 make_all_off 0 4 3752 27 TextureAttrib::make_all_off 0 1 1632 109</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new TextureAttrib object that turns off all stages (and hence</span>
 <span class="s0">* disables texturing).</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::make_all_off(void);</span>

<span class="s0">3326 17 get_num_on_stages 0 4 3752 32 TextureAttrib::get_num_on_stages 0 1 1633 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of stages that are turned on by the attribute.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int TextureAttrib::get_num_on_stages(void) const;</span>

<span class="s0">3327 12 get_on_stage 0 4 3752 27 TextureAttrib::get_on_stage 0 1 1634 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth stage turned on by the attribute, sorted in render order.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline TextureStage *TextureAttrib::get_on_stage(int n) const;</span>

<span class="s0">3328 20 get_num_on_ff_stages 0 4 3752 35 TextureAttrib::get_num_on_ff_stages 0 1 1635 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of on-stages that are relevant to the classic fixed</span>
 <span class="s0">* function pipeline.  This excludes texture stages such as normal maps.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int TextureAttrib::get_num_on_ff_stages(void) const;</span>

<span class="s0">3329 15 get_on_ff_stage 0 4 3752 30 TextureAttrib::get_on_ff_stage 0 1 1636 211</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth stage turned on by the attribute, sorted in render order,</span>
 <span class="s0">* including only those relevant to the classic fixed function pipeline.  This</span>
 <span class="s0">* excludes texture stages such as normal maps.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline TextureStage *TextureAttrib::get_on_ff_stage(int n) const;</span>

<span class="s0">3330 15 get_ff_tc_index 0 4 3752 30 TextureAttrib::get_ff_tc_index 0 1 1637 315</span>
<span class="s0">/**</span>
 <span class="s0">* For each TextureStage listed in get_on_ff_stage(), this returns a unique</span>
 <span class="s0">* index number for the texture coordinate name used by that TextureStage.  It</span>
 <span class="s0">* is guaranteed to remain the same index number for each texcoord name (for a</span>
 <span class="s0">* given set of TextureStages), even if the texture render order changes.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int TextureAttrib::get_ff_tc_index(int n) const;</span>

<span class="s0">3331 12 has_on_stage 0 4 3752 27 TextureAttrib::has_on_stage 0 1 1638 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated stage is turned on by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline bool TextureAttrib::has_on_stage(TextureStage *stage) const;</span>

<span class="s0">3332 14 get_on_texture 0 4 3752 29 TextureAttrib::get_on_texture 0 1 1639 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the texture associated with the indicated stage, or NULL if no</span>
 <span class="s0">* texture is associated.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline Texture *TextureAttrib::get_on_texture(TextureStage *stage) const;</span>

<span class="s0">3333 14 get_on_sampler 0 4 3752 29 TextureAttrib::get_on_sampler 0 1 1640 209</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sampler associated with the indicated stage, or the one</span>
 <span class="s0">* associated with its texture if no custom stage has been specified.  It is</span>
 <span class="s0">* an error to call this if the stage does not exist.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline SamplerState const &amp;TextureAttrib::get_on_sampler(TextureStage *stage) const;</span>

<span class="s0">3334 21 get_on_stage_override 0 4 3752 36 TextureAttrib::get_on_stage_override 0 1 1641 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the override value associated with the indicated stage.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline int TextureAttrib::get_on_stage_override(TextureStage *stage) const;</span>

<span class="s0">3335 13 find_on_stage 0 4 3752 28 TextureAttrib::find_on_stage 0 1 1642 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number of the indicated TextureStage within the list of</span>
 <span class="s0">* on_stages, or -1 if the indicated stage is not listed.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">int TextureAttrib::find_on_stage(TextureStage const *stage) const;</span>

<span class="s0">3336 18 get_num_off_stages 0 4 3752 33 TextureAttrib::get_num_off_stages 0 1 1643 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of stages that are turned off by the attribute.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int TextureAttrib::get_num_off_stages(void) const;</span>

<span class="s0">3337 13 get_off_stage 0 4 3752 28 TextureAttrib::get_off_stage 0 1 1644 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth stage turned off by the attribute, sorted in arbitrary</span>
 <span class="s0">* (pointer) order.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline TextureStage *TextureAttrib::get_off_stage(int n) const;</span>

<span class="s0">3338 13 has_off_stage 0 4 3752 28 TextureAttrib::has_off_stage 0 1 1645 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated stage is turned off by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool TextureAttrib::has_off_stage(TextureStage *stage) const;</span>

<span class="s0">3339 11 has_all_off 0 4 3752 26 TextureAttrib::has_all_off 0 1 1646 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this attrib turns off all stages (although it may also turn</span>
 <span class="s0">* some on).</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool TextureAttrib::has_all_off(void) const;</span>

<span class="s0">3340 11 is_identity 0 4 3752 26 TextureAttrib::is_identity 0 1 1647 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is an identity attrib: it does not change the set of</span>
 <span class="s0">* stages in use.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool TextureAttrib::is_identity(void) const;</span>

<span class="s0">3341 12 add_on_stage 0 4 3752 27 TextureAttrib::add_on_stage 0 2 1648 1649 292</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage added to the list of stages turned on by this attrib.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage added to the list of stages turned on by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">266</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, int override = 0) const;</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::add_on_stage(TextureStage *stage, Texture *tex, SamplerState const &amp;sampler, int override = 0) const;</span>

<span class="s0">3342 15 remove_on_stage 0 4 3752 30 TextureAttrib::remove_on_stage 0 1 1650 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage removed from the list of stages turned on by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::remove_on_stage(TextureStage *stage) const;</span>

<span class="s0">3343 13 add_off_stage 0 4 3752 28 TextureAttrib::add_off_stage 0 1 1651 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage added to the list of stages turned off by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::add_off_stage(TextureStage *stage, int override = 0) const;</span>

<span class="s0">3344 16 remove_off_stage 0 4 3752 31 TextureAttrib::remove_off_stage 0 1 1652 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage removed from the list of stages turned off by this attrib.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::remove_off_stage(TextureStage *stage) const;</span>

<span class="s0">3345 20 unify_texture_stages 0 4 3752 35 TextureAttrib::unify_texture_stages 0 1 1653 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with any included</span>
 <span class="s0">* TextureAttribs that happen to have the same name as the given object</span>
 <span class="s0">* replaced with the object.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::unify_texture_stages(TextureStage *stage) const;</span>

<span class="s0">3346 15 replace_texture 0 4 3752 30 TextureAttrib::replace_texture 0 2 1654 1655 278</span>
<span class="s0">// Let interrogate know this also accepts None</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with all references to</span>
 <span class="s0">* the given texture replaced with the new texture.</span>
 <span class="s0">*</span>
 <span class="s0">* As of Panda3D 1.10.13, new_tex may be null to remove the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.4</span>
 <span class="s0">*/</span>
<span class="s0">207</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::replace_texture(Texture *tex, Texture *new_tex) const;</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TextureAttrib::replace_texture(Texture *tex, std::nullptr_t new_tex) const;</span>

<span class="s0">3347 14 get_class_slot 0 4 3752 29 TextureAttrib::get_class_slot 0 1 1656 0</span>
<span class="s0">47</span>
<span class="s0">static int TextureAttrib::get_class_slot(void);</span>

<span class="s0">3348 14 get_class_type 0 4 3752 29 TextureAttrib::get_class_type 0 1 1657 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle TextureAttrib::get_class_type(void);</span>

<span class="s0">3349 14 ~TextureAttrib 0 516 3752 29 TextureAttrib::~TextureAttrib 0 0 0</span>
<span class="s0">36</span>
<span class="s0">TextureAttrib::~TextureAttrib(void);</span>

<span class="s0">3350 4 make 0 4 3759 18 TexGenAttrib::make 0 2 1658 1659 148</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a TexGenAttrib that generates no stages at all.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a TexGenAttrib that generates just the indicated stage.</span>
 <span class="s0">*/</span>
<span class="s0">167</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TexGenAttrib::make(void);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TexGenAttrib::make(TextureStage *stage, TexGenAttrib::Mode mode);</span>

<span class="s0">3351 12 make_default 0 4 3759 26 TexGenAttrib::make_default 0 1 1660 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; TexGenAttrib::make_default(void);</span>

<span class="s0">3352 9 add_stage 0 4 3759 23 TexGenAttrib::add_stage 0 2 1661 1662 445</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TexGenAttrib just like this one, with the indicated</span>
 <span class="s0">* generation mode for the given stage.  If this stage already exists, its</span>
 <span class="s0">* mode is replaced.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new TexGenAttrib just like this one, with the indicated</span>
 <span class="s0">* generation mode for the given stage.  If this stage already exists, its</span>
 <span class="s0">* mode is replaced.</span>
 <span class="s0">*</span>
 <span class="s0">* This variant also accepts constant_value, which is only meaningful if mode</span>
 <span class="s0">* is M_constant.</span>
 <span class="s0">*/</span>
<span class="s0">249</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TexGenAttrib::add_stage(TextureStage *stage, TexGenAttrib::Mode mode) const;</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TexGenAttrib::add_stage(TextureStage *stage, TexGenAttrib::Mode mode, LTexCoord3 const &amp;constant_value) const;</span>

<span class="s0">3353 12 remove_stage 0 4 3759 26 TexGenAttrib::remove_stage 0 1 1663 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TexGenAttrib just like this one, with the indicated stage</span>
 <span class="s0">* removed.</span>
 <span class="s0">*/</span>
<span class="s0">85</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; TexGenAttrib::remove_stage(TextureStage *stage) const;</span>

<span class="s0">3354 8 is_empty 0 4 3759 22 TexGenAttrib::is_empty 0 1 1664 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if no stages are defined in the TexGenAttrib, false if at</span>
 <span class="s0">* least one is.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">bool TexGenAttrib::is_empty(void) const;</span>

<span class="s0">3355 9 has_stage 0 4 3759 23 TexGenAttrib::has_stage 0 1 1665 157</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a mode associated with the indicated stage, or</span>
 <span class="s0">* false otherwise (in which case get_transform(stage) will return M_off).</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">bool TexGenAttrib::has_stage(TextureStage *stage) const;</span>

<span class="s0">3356 8 get_mode 0 4 3759 22 TexGenAttrib::get_mode 0 1 1666 142</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the generation mode associated with the named texture stage, or</span>
 <span class="s0">* M_off if nothing is associated with the indicated stage.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">TexGenAttrib::Mode TexGenAttrib::get_mode(TextureStage *stage) const;</span>

<span class="s0">3357 22 has_gen_texcoord_stage 0 4 3759 36 TexGenAttrib::has_gen_texcoord_stage 0 1 1667 207</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated TextureStage will have texture coordinates</span>
 <span class="s0">* generated for it automatically (and thus there is no need to upload the</span>
 <span class="s0">* texture coordinates encoded in the vertices).</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool TexGenAttrib::has_gen_texcoord_stage(TextureStage *stage) const;</span>

<span class="s0">3358 18 get_constant_value 0 4 3759 32 TexGenAttrib::get_constant_value 0 1 1668 133</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the constant value associated with the named texture stage.  This</span>
 <span class="s0">* is only meaningful if the mode is M_constant.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">LTexCoord3 const &amp;TexGenAttrib::get_constant_value(TextureStage *stage) const;</span>

<span class="s0">3359 18 get_geom_rendering 0 4 3759 32 TexGenAttrib::get_geom_rendering 0 1 1669 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this TexGenAttrib is applied to a geom which includes the indicated</span>
 <span class="s0">* geom_rendering bits.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline int TexGenAttrib::get_geom_rendering(int geom_rendering) const;</span>

<span class="s0">3360 14 get_class_slot 0 4 3759 28 TexGenAttrib::get_class_slot 0 1 1670 0</span>
<span class="s0">46</span>
<span class="s0">static int TexGenAttrib::get_class_slot(void);</span>

<span class="s0">3361 14 get_class_type 0 4 3759 28 TexGenAttrib::get_class_type 0 1 1671 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle TexGenAttrib::get_class_type(void);</span>

<span class="s0">3362 12 OccluderNode 0 260 3760 26 OccluderNode::OccluderNode 0 1 1672 281</span>
<span class="s0">/**</span>
 <span class="s0">* The default constructor creates a default occlusion polygon in the XZ plane</span>
 <span class="s0">* (or XY plane in a y-up coordinate system).  Use the normal Panda set_pos(),</span>
 <span class="s0">* set_hpr(), set_scale() to position it appropriately, or replace the</span>
 <span class="s0">* vertices with set_vertices().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">explicit OccluderNode::OccluderNode(std::string const &amp;name);</span>

<span class="s0">3363 16 set_double_sided 0 4 3760 30 OccluderNode::set_double_sided 0 1 1673 62</span>
<span class="s0">/**</span>
 <span class="s0">* If true, the back-face will also be used to occlude</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void OccluderNode::set_double_sided(bool value);</span>

<span class="s0">3364 15 is_double_sided 0 4 3760 29 OccluderNode::is_double_sided 0 1 1674 40</span>
<span class="s0">/**</span>
 <span class="s0">* Is this occluder double-sided</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool OccluderNode::is_double_sided(void);</span>

<span class="s0">3365 16 set_min_coverage 0 4 3760 30 OccluderNode::set_min_coverage 0 1 1675 202</span>
<span class="s0">/**</span>
 <span class="s0">* Minimum screen coverage needed before occluder used.  Range should be 0 to</span>
 <span class="s0">* 1. For example, setting to 0.2 would mean that the occluder needs to cover</span>
 <span class="s0">* 20% of the screen to be considered.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void OccluderNode::set_min_coverage(PN_stdfloat value);</span>

<span class="s0">3366 16 get_min_coverage 0 4 3760 30 OccluderNode::get_min_coverage 0 1 1676 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the minimum screen coverage.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline PN_stdfloat OccluderNode::get_min_coverage(void);</span>

<span class="s0">3367 12 set_vertices 0 4 3760 26 OccluderNode::set_vertices 0 1 1677 176</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the four vertices of the occluder polygon.  The vertices should be</span>
 <span class="s0">* defined in a counterclockwise orientation when looking at the face of the</span>
 <span class="s0">* occluder.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">inline void OccluderNode::set_vertices(LPoint3 const &amp;v0, LPoint3 const &amp;v1, LPoint3 const &amp;v2, LPoint3 const &amp;v3);</span>

<span class="s0">3368 16 get_num_vertices 0 4 3760 30 OccluderNode::get_num_vertices 0 1 1678 99</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertices in the occluder polygon.  This should always</span>
 <span class="s0">* return 4.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t OccluderNode::get_num_vertices(void) const;</span>

<span class="s0">3369 10 get_vertex 0 4 3760 24 OccluderNode::get_vertex 0 1 1679 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth vertex of the occluder polygon.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LPoint3 const &amp;OccluderNode::get_vertex(std::size_t n) const;</span>

<span class="s0">3370 10 set_vertex 0 4 3760 24 OccluderNode::set_vertex 0 1 1680 55</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the nth vertex of the occluder polygon.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void OccluderNode::set_vertex(std::size_t n, LPoint3 const &amp;v);</span>

<span class="s0">3371 14 get_class_type 0 4 3760 28 OccluderNode::get_class_type 0 1 1681 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle OccluderNode::get_class_type(void);</span>

<span class="s0">3372 4 make 0 4 3761 20 OccluderEffect::make 0 1 1682 68</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new OccluderEffect object that does nothing.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; OccluderEffect::make(void);</span>

<span class="s0">3373 20 get_num_on_occluders 0 4 3761 36 OccluderEffect::get_num_on_occluders 0 1 1683 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of occluders that are enabled by the effectute.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int OccluderEffect::get_num_on_occluders(void) const;</span>

<span class="s0">3374 15 get_on_occluder 0 4 3761 31 OccluderEffect::get_on_occluder 0 1 1684 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth occluder enabled by the effectute, sorted in render order.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline NodePath OccluderEffect::get_on_occluder(int n) const;</span>

<span class="s0">3375 15 has_on_occluder 0 4 3761 31 OccluderEffect::has_on_occluder 0 1 1685 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated occluder is enabled by the effect, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline bool OccluderEffect::has_on_occluder(NodePath const &amp;occluder) const;</span>

<span class="s0">3376 11 is_identity 0 4 3761 27 OccluderEffect::is_identity 0 1 1686 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this is an identity effect: it does not change the set of</span>
 <span class="s0">* occluders in use.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool OccluderEffect::is_identity(void) const;</span>

<span class="s0">3377 15 add_on_occluder 0 4 3761 31 OccluderEffect::add_on_occluder 0 1 1687 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new OccluderEffect, just like this one, but with the indicated</span>
 <span class="s0">* occluder added to the list of occluders enabled by this effect.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; OccluderEffect::add_on_occluder(NodePath const &amp;occluder) const;</span>

<span class="s0">3378 18 remove_on_occluder 0 4 3761 34 OccluderEffect::remove_on_occluder 0 1 1688 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new OccluderEffect, just like this one, but with the indicated</span>
 <span class="s0">* occluder removed from the list of occluders enabled by this effect.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; OccluderEffect::remove_on_occluder(NodePath const &amp;occluder) const;</span>

<span class="s0">3379 14 get_class_type 0 4 3761 30 OccluderEffect::get_class_type 0 1 1689 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle OccluderEffect::get_class_type(void);</span>

<span class="s0">3380 15 ~OccluderEffect 0 516 3761 31 OccluderEffect::~OccluderEffect 0 0 0</span>
<span class="s0">38</span>
<span class="s0">OccluderEffect::~OccluderEffect(void);</span>

<span class="s0">3381 13 PolylightNode 0 260 3762 28 PolylightNode::PolylightNode 0 2 1690 1691 71</span>
<span class="s0">/**</span>
 <span class="s0">* Use PolylightNode() to construct a new PolylightNode object.</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">explicit PolylightNode::PolylightNode(std::string const &amp;name);</span>
<span class="s0">inline PolylightNode::PolylightNode(PolylightNode const &amp;) = default;</span>

<span class="s0">3382 6 enable 0 4 3762 21 PolylightNode::enable 0 1 1692 28</span>
<span class="s0">/**</span>
 <span class="s0">* Enable this light</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline void PolylightNode::enable(void);</span>

<span class="s0">3383 7 disable 0 4 3762 22 PolylightNode::disable 0 1 1693 29</span>
<span class="s0">/**</span>
 <span class="s0">* Disable this light</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline void PolylightNode::disable(void);</span>

<span class="s0">3384 7 set_pos 0 4 3762 22 PolylightNode::set_pos 0 2 1694 1695 74</span>
<span class="s0">/**</span>
 <span class="s0">* Set this light's position</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Set this light's position</span>
 <span class="s0">*/</span>
<span class="s0">141</span>
<span class="s0">inline void PolylightNode::set_pos(LPoint3 const &amp;position);</span>
<span class="s0">inline void PolylightNode::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">3385 7 get_pos 0 4 3762 22 PolylightNode::get_pos 0 1 1696 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns position as a LPoint3</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline LPoint3 PolylightNode::get_pos(void) const;</span>

<span class="s0">3386 9 set_color 0 4 3762 24 PolylightNode::set_color 0 2 1697 1698 97</span>
<span class="s0">/**</span>
 <span class="s0">* Set the light's color...</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Set the light's color... 3 floats between 0 and 1</span>
 <span class="s0">*/</span>
<span class="s0">141</span>
<span class="s0">inline void PolylightNode::set_color(LColor const &amp;color);</span>
<span class="s0">inline void PolylightNode::set_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b);</span>

<span class="s0">3387 9 get_color 0 4 3762 24 PolylightNode::get_color 0 1 1699 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the light's color as LColor</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline LColor PolylightNode::get_color(void) const;</span>

<span class="s0">3388 20 get_color_scenegraph 0 4 3762 35 PolylightNode::get_color_scenegraph 0 1 1700 173</span>
<span class="s0">/**</span>
 <span class="s0">* This differs from get_color in that when applying the light color we need</span>
 <span class="s0">* to make sure that a color flattening external to the PolylightNode is not</span>
 <span class="s0">* ignored.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LColor PolylightNode::get_color_scenegraph(void) const;</span>

<span class="s0">3389 10 set_radius 0 4 3762 25 PolylightNode::set_radius 0 1 1701 51</span>
<span class="s0">/**</span>
 <span class="s0">* Set radius of the spherical light volume</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void PolylightNode::set_radius(PN_stdfloat r);</span>

<span class="s0">3390 10 get_radius 0 4 3762 25 PolylightNode::get_radius 0 1 1702 51</span>
<span class="s0">/**</span>
 <span class="s0">* Get radius of the spherical light volume</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat PolylightNode::get_radius(void) const;</span>

<span class="s0">3391 15 set_attenuation 0 4 3762 30 PolylightNode::set_attenuation 0 1 1703 48</span>
<span class="s0">/**</span>
 <span class="s0">* Set ALINEAR or AQUADRATIC attenuation</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline bool PolylightNode::set_attenuation(PolylightNode::Attenuation_Type type);</span>

<span class="s0">3392 15 get_attenuation 0 4 3762 30 PolylightNode::get_attenuation 0 1 1704 55</span>
<span class="s0">/**</span>
 <span class="s0">* Get &quot;linear&quot; or &quot;quadratic&quot; attenuation type</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline PolylightNode::Attenuation_Type PolylightNode::get_attenuation(void) const;</span>

<span class="s0">3393 6 set_a0 0 4 3762 21 PolylightNode::set_a0 0 1 1705 105</span>
<span class="s0">/**</span>
 <span class="s0">* Set the quadratic attenuation factor a0 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void PolylightNode::set_a0(PN_stdfloat a0);</span>

<span class="s0">3394 6 set_a1 0 4 3762 21 PolylightNode::set_a1 0 1 1706 105</span>
<span class="s0">/**</span>
 <span class="s0">* Set the quadratic attenuation factor a1 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void PolylightNode::set_a1(PN_stdfloat a1);</span>

<span class="s0">3395 6 set_a2 0 4 3762 21 PolylightNode::set_a2 0 1 1707 105</span>
<span class="s0">/**</span>
 <span class="s0">* Set the quadratic attenuation factor a2 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void PolylightNode::set_a2(PN_stdfloat a2);</span>

<span class="s0">3396 6 get_a0 0 4 3762 21 PolylightNode::get_a0 0 1 1708 105</span>
<span class="s0">/**</span>
 <span class="s0">* Get the quadratic attenuation factor a0 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat PolylightNode::get_a0(void) const;</span>

<span class="s0">3397 6 get_a1 0 4 3762 21 PolylightNode::get_a1 0 1 1709 105</span>
<span class="s0">/**</span>
 <span class="s0">* Get the quadratic attenuation factor a1 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat PolylightNode::get_a1(void) const;</span>

<span class="s0">3398 6 get_a2 0 4 3762 21 PolylightNode::get_a2 0 1 1710 105</span>
<span class="s0">/**</span>
 <span class="s0">* Get the quadratic attenuation factor a2 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat PolylightNode::get_a2(void) const;</span>

<span class="s0">3399 10 flicker_on 0 4 3762 25 PolylightNode::flicker_on 0 1 1711 104</span>
<span class="s0">/**</span>
 <span class="s0">* Set flickering to true so at every loop this light's color is varied based</span>
 <span class="s0">* on flicker_type</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void PolylightNode::flicker_on(void);</span>

<span class="s0">3400 11 flicker_off 0 4 3762 26 PolylightNode::flicker_off 0 1 1712 30</span>
<span class="s0">/**</span>
 <span class="s0">* Turn flickering off</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void PolylightNode::flicker_off(void);</span>

<span class="s0">3401 13 is_flickering 0 4 3762 28 PolylightNode::is_flickering 0 1 1713 44</span>
<span class="s0">/**</span>
 <span class="s0">* Check is this light is flickering</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool PolylightNode::is_flickering(void) const;</span>

<span class="s0">3402 16 set_flicker_type 0 4 3762 31 PolylightNode::set_flicker_type 0 1 1714 181</span>
<span class="s0">/**</span>
 <span class="s0">* Flicker type can be FRANDOM or FSIN At a later point there might be a</span>
 <span class="s0">* FCUSTOM Custom flicker will be a set of fix points recorded by animating</span>
 <span class="s0">* the light's intensity</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline bool PolylightNode::set_flicker_type(PolylightNode::Flicker_Type type);</span>

<span class="s0">3403 16 get_flicker_type 0 4 3762 31 PolylightNode::get_flicker_type 0 1 1715 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns FRANDOM or FSIN</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline PolylightNode::Flicker_Type PolylightNode::get_flicker_type(void) const;</span>

<span class="s0">3404 10 set_offset 0 4 3762 25 PolylightNode::set_offset 0 1 1716 142</span>
<span class="s0">/**</span>
 <span class="s0">* Set the offset value for the random and sin flicker variations... used to</span>
 <span class="s0">* tweak the flicker This value is added to the variation</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void PolylightNode::set_offset(PN_stdfloat offset);</span>

<span class="s0">3405 10 get_offset 0 4 3762 25 PolylightNode::get_offset 0 1 1717 73</span>
<span class="s0">/**</span>
 <span class="s0">* Get the offset value for the random and sin flicker variations</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat PolylightNode::get_offset(void) const;</span>

<span class="s0">3406 9 set_scale 0 4 3762 24 PolylightNode::set_scale 0 1 1718 148</span>
<span class="s0">/**</span>
 <span class="s0">* Set the scale value for the random and sin flicker variations... used to</span>
 <span class="s0">* tweak the flicker This value is multiplied with the variation</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void PolylightNode::set_scale(PN_stdfloat scale);</span>

<span class="s0">3407 9 get_scale 0 4 3762 24 PolylightNode::get_scale 0 1 1719 72</span>
<span class="s0">/**</span>
 <span class="s0">* Get the scale value for the random and sin flicker variations</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline PN_stdfloat PolylightNode::get_scale(void) const;</span>

<span class="s0">3408 13 set_step_size 0 4 3762 28 PolylightNode::set_step_size 0 1 1720 133</span>
<span class="s0">/**</span>
 <span class="s0">* Set the step size for the sin function in flicker This is the increment</span>
 <span class="s0">* size for the value supplied to the sin function</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void PolylightNode::set_step_size(PN_stdfloat step);</span>

<span class="s0">3409 13 get_step_size 0 4 3762 28 PolylightNode::get_step_size 0 1 1721 133</span>
<span class="s0">/**</span>
 <span class="s0">* Get the step size for the sin function in flicker This is the increment</span>
 <span class="s0">* size for the value supplied to the sin function</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PN_stdfloat PolylightNode::get_step_size(void) const;</span>

<span class="s0">3410 8 set_freq 0 4 3762 23 PolylightNode::set_freq 0 1 1722 39</span>
<span class="s0">/**</span>
 <span class="s0">* Set frequency of sin flicker</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void PolylightNode::set_freq(PN_stdfloat f);</span>

<span class="s0">3411 8 get_freq 0 4 3762 23 PolylightNode::get_freq 0 1 1723 39</span>
<span class="s0">/**</span>
 <span class="s0">* Get frequency of sin flicker</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PN_stdfloat PolylightNode::get_freq(void) const;</span>

<span class="s0">3412 11 operator == 0 4 3762 26 PolylightNode::operator == 0 1 1724 21</span>
<span class="s0">// Comparison methods</span>
<span class="s0">73</span>
<span class="s0">inline bool PolylightNode::operator ==(PolylightNode const &amp;other) const;</span>

<span class="s0">3413 11 operator != 0 4 3762 26 PolylightNode::operator != 0 1 1725 0</span>
<span class="s0">73</span>
<span class="s0">inline bool PolylightNode::operator !=(PolylightNode const &amp;other) const;</span>

<span class="s0">3414 10 operator &lt; 0 4 3762 25 PolylightNode::operator &lt; 0 1 1726 0</span>
<span class="s0">72</span>
<span class="s0">inline bool PolylightNode::operator &lt;(PolylightNode const &amp;other) const;</span>

<span class="s0">3415 10 compare_to 0 4 3762 25 PolylightNode::compare_to 0 1 1727 486</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a number less than zero if this PolylightNode sorts before the</span>
 <span class="s0">* other one, greater than zero if it sorts after, or zero if they are</span>
 <span class="s0">* equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two PolylightNodes are considered equivalent if they consist of exactly the</span>
 <span class="s0">* same properties Otherwise, they are different; different PolylightNodes</span>
 <span class="s0">* will be ranked in a consistent but undefined ordering; the ordering is</span>
 <span class="s0">* useful only for placing the PolylightNodes in a sorted container like an</span>
 <span class="s0">* STL set.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">int PolylightNode::compare_to(PolylightNode const &amp;other) const;</span>

<span class="s0">3416 10 is_enabled 0 4 3762 25 PolylightNode::is_enabled 0 1 1728 45</span>
<span class="s0">/**</span>
 <span class="s0">* Is this light is enabled/disabled?</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool PolylightNode::is_enabled(void) const;</span>

<span class="s0">3417 14 get_class_type 0 4 3762 29 PolylightNode::get_class_type 0 1 1729 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle PolylightNode::get_class_type(void);</span>

<span class="s0">3418 14 ~PolylightNode 0 516 3762 29 PolylightNode::~PolylightNode 0 0 0</span>
<span class="s0">36</span>
<span class="s0">PolylightNode::~PolylightNode(void);</span>

<span class="s0">3419 4 make 0 4 3765 21 PolylightEffect::make 0 3 1730 1731 1732 157</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new PolylightEffect object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new PolylightEffect object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new PolylightEffect object.</span>
 <span class="s0">*/</span>
<span class="s0">407</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; PolylightEffect::make(void);</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; PolylightEffect::make(PN_stdfloat weight, PolylightEffect::ContribType contrib, LPoint3 const &amp;effect_center);</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; PolylightEffect::make(PN_stdfloat weight, PolylightEffect::ContribType contrib, LPoint3 const &amp;effect_center, PolylightEffect::LightGroup const &amp;lights);</span>

<span class="s0">3420 9 add_light 0 4 3765 26 PolylightEffect::add_light 0 1 1733 76</span>
<span class="s0">/**</span>
 <span class="s0">* Add a PolylightNode object to this effect and return a new effect</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; PolylightEffect::add_light(NodePath const &amp;newlight) const;</span>

<span class="s0">3421 12 remove_light 0 4 3765 29 PolylightEffect::remove_light 0 1 1734 74</span>
<span class="s0">/**</span>
 <span class="s0">* Remove a light from this effect.  Return the new updated effect</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; PolylightEffect::remove_light(NodePath const &amp;newlight) const;</span>

<span class="s0">3422 10 set_weight 0 4 3765 27 PolylightEffect::set_weight 0 1 1735 241</span>
<span class="s0">/**</span>
 <span class="s0">* Set weight and return a new effect... the reason this couldnt be done</span>
 <span class="s0">* through make was because that would return a new effect without the</span>
 <span class="s0">* lightgroup which is static and cant be accessed Here, we just pass that to</span>
 <span class="s0">* the make</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; PolylightEffect::set_weight(PN_stdfloat w) const;</span>

<span class="s0">3423 11 set_contrib 0 4 3765 28 PolylightEffect::set_contrib 0 1 1736 247</span>
<span class="s0">/**</span>
 <span class="s0">* Set Contrib Type and return a new effect... the reason this couldnt be done</span>
 <span class="s0">* through make was because that would return a new effect without the</span>
 <span class="s0">* lightgroup which is static and cant be accessed Here, we just pass that to</span>
 <span class="s0">* the make</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; PolylightEffect::set_contrib(PolylightEffect::ContribType c) const;</span>

<span class="s0">3424 17 set_effect_center 0 4 3765 34 PolylightEffect::set_effect_center 0 1 1737 241</span>
<span class="s0">/**</span>
 <span class="s0">* Set weight and return a new effect... the reason this couldnt be done</span>
 <span class="s0">* through make was because that would return a new effect without the</span>
 <span class="s0">* lightgroup which is static and cant be accessed Here, we just pass that to</span>
 <span class="s0">* the make</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; PolylightEffect::set_effect_center(LPoint3 const &amp;ec) const;</span>

<span class="s0">3425 10 get_weight 0 4 3765 27 PolylightEffect::get_weight 0 1 1738 31</span>
<span class="s0">/**</span>
 <span class="s0">* Get the weight value</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PN_stdfloat PolylightEffect::get_weight(void) const;</span>

<span class="s0">3426 11 get_contrib 0 4 3765 28 PolylightEffect::get_contrib 0 1 1739 40</span>
<span class="s0">/**</span>
 <span class="s0">* Returns CT_all or CT_proximal</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline PolylightEffect::ContribType PolylightEffect::get_contrib(void) const;</span>

<span class="s0">3427 17 get_effect_center 0 4 3765 34 PolylightEffect::get_effect_center 0 1 1740 49</span>
<span class="s0">/**</span>
 <span class="s0">* Return the value of the _effect_center</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LPoint3 PolylightEffect::get_effect_center(void) const;</span>

<span class="s0">3428 9 has_light 0 4 3765 26 PolylightEffect::has_light 0 1 1741 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated light is listed in the PolylightEffect, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">bool PolylightEffect::has_light(NodePath const &amp;light) const;</span>

<span class="s0">3429 14 get_class_type 0 4 3765 31 PolylightEffect::get_class_type 0 1 1742 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle PolylightEffect::get_class_type(void);</span>

<span class="s0">3430 16 ~PolylightEffect 0 516 3765 33 PolylightEffect::~PolylightEffect 0 0 0</span>
<span class="s0">40</span>
<span class="s0">PolylightEffect::~PolylightEffect(void);</span>

<span class="s0">3431 4 make 0 4 3769 18 ShaderAttrib::make 0 1 1743 65</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ShaderAttrib object with nothing set.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::make(Shader const *shader = nullptr, int priority = 0);</span>

<span class="s0">3432 8 make_off 0 4 3769 22 ShaderAttrib::make_off 0 1 1744 133</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ShaderAttrib object that disables the use of shaders (it</span>
 <span class="s0">* does not clear out all shader data, however.)</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::make_off(void);</span>

<span class="s0">3433 12 make_default 0 4 3769 26 ShaderAttrib::make_default 0 1 1745 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::make_default(void);</span>

<span class="s0">3434 10 has_shader 0 4 3769 24 ShaderAttrib::has_shader 0 1 1746 109</span>
<span class="s0">/**</span>
 <span class="s0">* If true, the shader field of this attribute overrides the shader field of</span>
 <span class="s0">* the parent attribute.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool ShaderAttrib::has_shader(void) const;</span>

<span class="s0">3435 11 auto_shader 0 4 3769 25 ShaderAttrib::auto_shader 0 1 1747 142</span>
<span class="s0">/**</span>
 <span class="s0">* If true, then this ShaderAttrib does not contain an explicit shader -</span>
 <span class="s0">* instead, it requests the automatic generation of a shader.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool ShaderAttrib::auto_shader(void) const;</span>

<span class="s0">3436 19 get_shader_priority 0 4 3769 33 ShaderAttrib::get_shader_priority 0 1 1748 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int ShaderAttrib::get_shader_priority(void) const;</span>

<span class="s0">3437 18 get_instance_count 0 4 3769 32 ShaderAttrib::get_instance_count 0 1 1749 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of geometry instances.  A value of 0 means not to use</span>
 <span class="s0">* instancing at all.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int ShaderAttrib::get_instance_count(void) const;</span>

<span class="s0">3438 14 auto_normal_on 0 4 3769 28 ShaderAttrib::auto_normal_on 0 1 1750 0</span>
<span class="s0">53</span>
<span class="s0">inline bool ShaderAttrib::auto_normal_on(void) const;</span>

<span class="s0">3439 12 auto_glow_on 0 4 3769 26 ShaderAttrib::auto_glow_on 0 1 1751 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool ShaderAttrib::auto_glow_on(void) const;</span>

<span class="s0">3440 13 auto_gloss_on 0 4 3769 27 ShaderAttrib::auto_gloss_on 0 1 1752 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool ShaderAttrib::auto_gloss_on(void) const;</span>

<span class="s0">3441 12 auto_ramp_on 0 4 3769 26 ShaderAttrib::auto_ramp_on 0 1 1753 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool ShaderAttrib::auto_ramp_on(void) const;</span>

<span class="s0">3442 14 auto_shadow_on 0 4 3769 28 ShaderAttrib::auto_shadow_on 0 1 1754 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool ShaderAttrib::auto_shadow_on(void) const;</span>

<span class="s0">3443 10 set_shader 0 4 3769 24 ShaderAttrib::set_shader 0 1 1755 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_shader(Shader const *s, int priority = 0) const;</span>

<span class="s0">3444 14 set_shader_off 0 4 3769 28 ShaderAttrib::set_shader_off 0 1 1756 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_shader_off(int priority = 0) const;</span>

<span class="s0">3445 15 set_shader_auto 0 4 3769 29 ShaderAttrib::set_shader_auto 0 2 1757 1758 116</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Set auto shader with bitmask to customize use, e.g., to keep normal, glow,</span>
 <span class="s0">* etc., on or off</span>
 <span class="s0">*/</span>
<span class="s0">196</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_shader_auto(int priority = 0) const;</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_shader_auto(BitMask32 shader_switch, int priority = 0) const;</span>

<span class="s0">3446 12 clear_shader 0 4 3769 26 ShaderAttrib::clear_shader 0 1 1759 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::clear_shader(void) const;</span>

<span class="s0">3447 16 set_shader_input 0 4 3769 30 ShaderAttrib::set_shader_input 0 2 1760 1761 220</span>
<span class="s0">// Shader Inputs</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">212</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_shader_input(ShaderInput const &amp;input) const;</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_shader_input(CPT_InternalName , PyObject *, int priority = 0) const;</span>

<span class="s0">3448 17 set_shader_inputs 0 4 3769 31 ShaderAttrib::set_shader_inputs 0 1 1762 0</span>
<span class="s0">103</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_shader_inputs(PyObject *args, PyObject *kwargs) const;</span>

<span class="s0">3449 18 set_instance_count 0 4 3769 32 ShaderAttrib::set_instance_count 0 1 1763 211</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the geometry instance count.  Do not confuse this with instanceTo,</span>
 <span class="s0">* which is used for animation instancing, and has nothing to do with this.  A</span>
 <span class="s0">* value of 0 means not to use instancing at all.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_instance_count(int instance_count) const;</span>

<span class="s0">3450 8 set_flag 0 4 3769 22 ShaderAttrib::set_flag 0 1 1764 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::set_flag(int flag, bool value) const;</span>

<span class="s0">3451 10 clear_flag 0 4 3769 24 ShaderAttrib::clear_flag 0 1 1765 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::clear_flag(int flag) const;</span>

<span class="s0">3452 18 clear_shader_input 0 4 3769 32 ShaderAttrib::clear_shader_input 0 2 1766 1767 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">188</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::clear_shader_input(InternalName const *id) const;</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::clear_shader_input(std::string const &amp;id) const;</span>

<span class="s0">3453 23 clear_all_shader_inputs 0 4 3769 37 ShaderAttrib::clear_all_shader_inputs 0 1 1768 54</span>
<span class="s0">/**</span>
 <span class="s0">* Clears all the shader inputs on the attrib.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">ConstPointerTo&lt; RenderAttrib &gt; ShaderAttrib::clear_all_shader_inputs(void) const;</span>

<span class="s0">3454 8 get_flag 0 4 3769 22 ShaderAttrib::get_flag 0 1 1769 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool ShaderAttrib::get_flag(int flag) const;</span>

<span class="s0">3455 16 has_shader_input 0 4 3769 30 ShaderAttrib::has_shader_input 0 1 1770 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a ShaderInput of the given name.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline bool ShaderAttrib::has_shader_input(CPT_InternalName id) const;</span>

<span class="s0">3456 10 get_shader 0 4 3769 24 ShaderAttrib::get_shader 0 1 1771 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the shader object associated with the node.  If get_override</span>
 <span class="s0">* returns true, but get_shader returns NULL, that means that this attribute</span>
 <span class="s0">* should disable the shader.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">Shader const *ShaderAttrib::get_shader(void) const;</span>

<span class="s0">3457 16 get_shader_input 0 4 3769 30 ShaderAttrib::get_shader_input 0 2 1772 1773 318</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ShaderInput of the given name.  If no such name is found, this</span>
 <span class="s0">* function does not return NULL --- it returns the &quot;blank&quot; ShaderInput.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the ShaderInput of the given name.  If no such name is found, this</span>
 <span class="s0">* function does not return NULL --- it returns the &quot;blank&quot; ShaderInput.</span>
 <span class="s0">*/</span>
<span class="s0">160</span>
<span class="s0">ShaderInput const &amp;ShaderAttrib::get_shader_input(InternalName const *id) const;</span>
<span class="s0">ShaderInput const &amp;ShaderAttrib::get_shader_input(std::string const &amp;id) const;</span>

<span class="s0">3458 25 get_shader_input_nodepath 0 4 3769 39 ShaderAttrib::get_shader_input_nodepath 0 1 1774 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ShaderInput as a nodepath.  Assertion fails if there is none,</span>
 <span class="s0">* or if it is not a nodepath.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">NodePath const &amp;ShaderAttrib::get_shader_input_nodepath(InternalName const *id) const;</span>

<span class="s0">3459 23 get_shader_input_vector 0 4 3769 37 ShaderAttrib::get_shader_input_vector 0 1 1775 111</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ShaderInput as a vector.  Assertion fails if there is none, or</span>
 <span class="s0">* if it is not a vector.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">LVecBase4 ShaderAttrib::get_shader_input_vector(InternalName *id) const;</span>

<span class="s0">3460 24 get_shader_input_texture 0 4 3769 38 ShaderAttrib::get_shader_input_texture 0 1 1776 207</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ShaderInput as a texture.  Assertion fails if there is none, or</span>
 <span class="s0">* if it is not a texture.</span>
 <span class="s0">*</span>
 <span class="s0">* If sampler is not NULL, the sampler state to use for this texture is</span>
 <span class="s0">* assigned to it.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">Texture *ShaderAttrib::get_shader_input_texture(InternalName const *id, SamplerState *sampler = nullptr) const;</span>

<span class="s0">3461 20 get_shader_input_ptr 0 4 3769 34 ShaderAttrib::get_shader_input_ptr 0 1 1777 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ShaderInput as a ShaderPtrData struct.  Assertion fails if</span>
 <span class="s0">* there is none.  or if it is not a PTA(double/float)</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">Shader::ShaderPtrData const *ShaderAttrib::get_shader_input_ptr(InternalName const *id) const;</span>

<span class="s0">3462 23 get_shader_input_matrix 0 4 3769 37 ShaderAttrib::get_shader_input_matrix 0 1 1778 123</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ShaderInput as a matrix.  Assertion fails if there is none, or</span>
 <span class="s0">* if it is not a matrix or NodePath.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">LMatrix4 const &amp;ShaderAttrib::get_shader_input_matrix(InternalName const *id, LMatrix4 &amp;matrix) const;</span>

<span class="s0">3463 23 get_shader_input_buffer 0 4 3769 37 ShaderAttrib::get_shader_input_buffer 0 1 1779 123</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ShaderInput as a ShaderBuffer.  Assertion fails if there is</span>
 <span class="s0">* none, or if it is not a ShaderBuffer.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">ShaderBuffer *ShaderAttrib::get_shader_input_buffer(InternalName const *id) const;</span>

<span class="s0">3464 26 register_with_read_factory 0 4 3769 40 ShaderAttrib::register_with_read_factory 0 1 1780 53</span>
<span class="s0">/**</span>
 <span class="s0">* Factory method to generate a Shader object</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">static void ShaderAttrib::register_with_read_factory(void);</span>

<span class="s0">3465 14 get_class_slot 0 4 3769 28 ShaderAttrib::get_class_slot 0 1 1781 0</span>
<span class="s0">46</span>
<span class="s0">static int ShaderAttrib::get_class_slot(void);</span>

<span class="s0">3466 14 get_class_type 0 4 3769 28 ShaderAttrib::get_class_type 0 1 1782 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle ShaderAttrib::get_class_type(void);</span>

<span class="s0">3467 13 ~ShaderAttrib 0 516 3769 27 ShaderAttrib::~ShaderAttrib 0 0 0</span>
<span class="s0">34</span>
<span class="s0">ShaderAttrib::~ShaderAttrib(void);</span>

<span class="s0">3468 4 make 0 4 3774 22 ShowBoundsEffect::make 0 1 1783 52</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ShowBoundsEffect object.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; ShowBoundsEffect::make(bool tight = false);</span>

<span class="s0">3469 9 get_tight 0 4 3774 27 ShowBoundsEffect::get_tight 0 1 1784 157</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the &quot;tight&quot; flag was set, meaning the effect should compute</span>
 <span class="s0">* and draw the tight bounding-box of the node's vertices every frame.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool ShowBoundsEffect::get_tight(void) const;</span>

<span class="s0">3470 14 get_class_type 0 4 3774 32 ShowBoundsEffect::get_class_type 0 1 1785 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle ShowBoundsEffect::get_class_type(void);</span>

<span class="s0">3471 17 ~ShowBoundsEffect 0 516 3774 35 ShowBoundsEffect::~ShowBoundsEffect 0 0 0</span>
<span class="s0">42</span>
<span class="s0">ShowBoundsEffect::~ShowBoundsEffect(void);</span>

<span class="s0">3472 4 make 0 4 3775 24 TexProjectorEffect::make 0 1 1786 74</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a TexProjectorEffect that modifies no stages at all.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; TexProjectorEffect::make(void);</span>

<span class="s0">3473 9 add_stage 0 4 3775 29 TexProjectorEffect::add_stage 0 1 1787 536</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TexProjectorEffect just like this one, with the indicated</span>
 <span class="s0">* projection for the given stage.  If this stage already exists, its</span>
 <span class="s0">* projection definition is replaced.</span>
 <span class="s0">*</span>
 <span class="s0">* The relative transform between the &quot;from&quot; and the &quot;to&quot; nodes is</span>
 <span class="s0">* automatically applied to the texture transform each frame.</span>
 <span class="s0">*</span>
 <span class="s0">* Furthermore, if the &quot;to&quot; node is a LensNode, its projection matrix is also</span>
 <span class="s0">* applied to the texture transform.  In this case, the lens_index may be used</span>
 <span class="s0">* to select the particular lens that should be used.</span>
 <span class="s0">*/</span>
<span class="s0">150</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; TexProjectorEffect::add_stage(TextureStage *stage, NodePath const &amp;from, NodePath const &amp;to, int lens_index = 0) const;</span>

<span class="s0">3474 12 remove_stage 0 4 3775 32 TexProjectorEffect::remove_stage 0 1 1788 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new TexProjectorEffect just like this one, with the indicated</span>
 <span class="s0">* stage removed.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; TexProjectorEffect::remove_stage(TextureStage *stage) const;</span>

<span class="s0">3475 8 is_empty 0 4 3775 28 TexProjectorEffect::is_empty 0 1 1789 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if no stages are defined in the TexProjectorEffect, false if</span>
 <span class="s0">* at least one is.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">bool TexProjectorEffect::is_empty(void) const;</span>

<span class="s0">3476 9 has_stage 0 4 3775 29 TexProjectorEffect::has_stage 0 1 1790 182</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if there is a transform associated with the indicated stage,</span>
 <span class="s0">* or false otherwise (in which case get_transform(stage) will return the</span>
 <span class="s0">* identity transform).</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool TexProjectorEffect::has_stage(TextureStage *stage) const;</span>

<span class="s0">3477 8 get_from 0 4 3775 28 TexProjectorEffect::get_from 0 1 1791 227</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;from&quot; node associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  The relative transform between the &quot;from&quot; and the &quot;to&quot;</span>
 <span class="s0">* nodes is automatically applied to the texture transform each frame.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">NodePath TexProjectorEffect::get_from(TextureStage *stage) const;</span>

<span class="s0">3478 6 get_to 0 4 3775 26 TexProjectorEffect::get_to 0 1 1792 343</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;to&quot; node associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  The relative transform between the &quot;from&quot; and the &quot;to&quot;</span>
 <span class="s0">* nodes is automatically applied to the texture transform each frame.</span>
 <span class="s0">*</span>
 <span class="s0">* Furthermore, if the &quot;to&quot; node is a LensNode, its projection matrix is also</span>
 <span class="s0">* applied to the texture transform.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">NodePath TexProjectorEffect::get_to(TextureStage *stage) const;</span>

<span class="s0">3479 14 get_lens_index 0 4 3775 34 TexProjectorEffect::get_lens_index 0 1 1793 221</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the lens_index associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  This is only used if the &quot;to&quot; node is a LensNode, in</span>
 <span class="s0">* which case it specifies the particular lens that should be used.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">int TexProjectorEffect::get_lens_index(TextureStage *stage) const;</span>

<span class="s0">3480 14 get_class_type 0 4 3775 34 TexProjectorEffect::get_class_type 0 1 1794 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle TexProjectorEffect::get_class_type(void);</span>

<span class="s0">3481 11 make_screen 0 4 3776 26 ScissorEffect::make_screen 0 1 1795 169</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new screen-relative ScissorEffect.  The frame defines a left,</span>
 <span class="s0">* right, bottom, top region, relative to the DisplayRegion.  See</span>
 <span class="s0">* ScissorAttrib.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; ScissorEffect::make_screen(LVecBase4 const &amp;frame, bool clip = true);</span>

<span class="s0">3482 9 make_node 0 4 3776 24 ScissorEffect::make_node 0 3 1796 1797 1798 699</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new node-relative ScissorEffect, with no points.  This empty</span>
 <span class="s0">* ScissorEffect does nothing.  You must then call add_point a number of times</span>
 <span class="s0">* to add the points you require.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new node-relative ScissorEffect.  The two points are</span>
 <span class="s0">* understood to be relative to the indicated node, or the current node if the</span>
 <span class="s0">* NodePath is empty, and determine the diagonally opposite corners of the</span>
 <span class="s0">* scissor region.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a new node-relative ScissorEffect.  The four points are</span>
 <span class="s0">* understood to be relative to the indicated node, or the current node if the</span>
 <span class="s0">* indicated NodePath is empty, and determine four points surrounding the</span>
 <span class="s0">* scissor region.</span>
 <span class="s0">*/</span>
<span class="s0">387</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; ScissorEffect::make_node(bool clip = true);</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; ScissorEffect::make_node(LPoint3 const &amp;a, LPoint3 const &amp;b, NodePath const &amp;node = NodePath());</span>
<span class="s0">static ConstPointerTo&lt; RenderEffect &gt; ScissorEffect::make_node(LPoint3 const &amp;a, LPoint3 const &amp;b, LPoint3 const &amp;c, LPoint3 const &amp;d, NodePath const &amp;node = NodePath());</span>

<span class="s0">3483 9 add_point 0 4 3776 24 ScissorEffect::add_point 0 1 1799 325</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a new ScissorEffect with the indicated point added.  It is only</span>
 <span class="s0">* valid to call this on a &quot;node&quot; type ScissorEffect.  The full set of points,</span>
 <span class="s0">* projected into screen space, defines the bounding volume of the rectangular</span>
 <span class="s0">* scissor region.</span>
 <span class="s0">*</span>
 <span class="s0">* Each point may be relative to a different node, if desired.</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">ConstPointerTo&lt; RenderEffect &gt; ScissorEffect::add_point(LPoint3 const &amp;point, NodePath const &amp;node = NodePath()) const;</span>

<span class="s0">3484 9 is_screen 0 4 3776 24 ScissorEffect::is_screen 0 1 1800 149</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ScissorEffect is a screen-based effect, meaning</span>
 <span class="s0">* get_frame() has a meaningful value, but get_a() and get_b() do not.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool ScissorEffect::is_screen(void) const;</span>

<span class="s0">3485 9 get_frame 0 4 3776 24 ScissorEffect::get_frame 0 1 1801 253</span>
<span class="s0">/**</span>
 <span class="s0">* If is_screen() returns true, this method may be called to query the screen-</span>
 <span class="s0">* based scissor frame.  This is a series of left, right, bottom, top,</span>
 <span class="s0">* representing the scissor frame relative to the current DisplayRegion.  See</span>
 <span class="s0">* ScissorAttrib.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline LVecBase4 const &amp;ScissorEffect::get_frame(void) const;</span>

<span class="s0">3486 14 get_num_points 0 4 3776 29 ScissorEffect::get_num_points 0 1 1802 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of node-based scissor points.  See get_point().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int ScissorEffect::get_num_points(void) const;</span>

<span class="s0">3487 9 get_point 0 4 3776 24 ScissorEffect::get_point 0 1 1803 293</span>
<span class="s0">/**</span>
 <span class="s0">* If is_screen() returns false, then get_num_points() and get_point() may be</span>
 <span class="s0">* called to query the node-based scissor frame.  These return n points (at</span>
 <span class="s0">* least two), which are understood to be in the space of this node, and which</span>
 <span class="s0">* define any opposite corners of the scissor frame.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LPoint3 const &amp;ScissorEffect::get_point(int n) const;</span>

<span class="s0">3488 8 get_node 0 4 3776 23 ScissorEffect::get_node 0 1 1804 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node to which the nth point is relative, or empty NodePath to</span>
 <span class="s0">* indicate the current node.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline NodePath ScissorEffect::get_node(int n) const;</span>

<span class="s0">3489 8 get_clip 0 4 3776 23 ScissorEffect::get_clip 0 1 1805 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this ScissorEffect actually enables scissoring, or false if</span>
 <span class="s0">* it culls only.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool ScissorEffect::get_clip(void) const;</span>

<span class="s0">3490 14 get_class_type 0 4 3776 29 ScissorEffect::get_class_type 0 1 1806 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle ScissorEffect::get_class_type(void);</span>

<span class="s0">3491 14 ~ScissorEffect 0 516 3776 29 ScissorEffect::~ScissorEffect 0 0 0</span>
<span class="s0">36</span>
<span class="s0">ScissorEffect::~ScissorEffect(void);</span>

<span class="s0">3492 17 SceneGraphReducer 0 260 3777 36 SceneGraphReducer::SceneGraphReducer 0 2 1807 1808 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">177</span>
<span class="s0">inline explicit SceneGraphReducer::SceneGraphReducer(GraphicsStateGuardianBase *gsg = nullptr);</span>
<span class="s0">inline SceneGraphReducer::SceneGraphReducer(SceneGraphReducer const &amp;) = default;</span>

<span class="s0">3493 18 ~SceneGraphReducer 0 516 3777 37 SceneGraphReducer::~SceneGraphReducer 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline SceneGraphReducer::~SceneGraphReducer(void);</span>

<span class="s0">3494 7 set_gsg 0 4 3777 26 SceneGraphReducer::set_gsg 0 1 1809 360</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the particular GraphicsStateGuardian that this object will</span>
 <span class="s0">* attempt to optimize to.  The GSG may specify parameters such as maximum</span>
 <span class="s0">* number of vertices per vertex data, max number of vertices per primitive,</span>
 <span class="s0">* and whether triangle strips are preferred.  It also affects the types of</span>
 <span class="s0">* vertex column data that is created by premunge().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void SceneGraphReducer::set_gsg(GraphicsStateGuardianBase *gsg);</span>

<span class="s0">3495 9 clear_gsg 0 4 3777 28 SceneGraphReducer::clear_gsg 0 1 1810 218</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies that no particular GraphicsStateGuardian will be used to guide</span>
 <span class="s0">* the optimization.  The SceneGraphReducer will instead use config variables</span>
 <span class="s0">* such as max-collect-vertices and max-collect-indices.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void SceneGraphReducer::clear_gsg(void);</span>

<span class="s0">3496 7 get_gsg 0 4 3777 26 SceneGraphReducer::get_gsg 0 1 1811 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the particular GraphicsStateGuardian that this object will attempt</span>
 <span class="s0">* to optimize to.  See set_gsg().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline GraphicsStateGuardianBase *SceneGraphReducer::get_gsg(void) const;</span>

<span class="s0">3497 18 set_combine_radius 0 4 3777 37 SceneGraphReducer::set_combine_radius 0 1 1812 413</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the radius that is used in conjunction with CS_within_radius to</span>
 <span class="s0">* decide whether a subgraph's siblings should be combined into a single node</span>
 <span class="s0">* or not.</span>
 <span class="s0">*</span>
 <span class="s0">* If the CS_within_radius bit is included in the combine_siblings_bits</span>
 <span class="s0">* parameter passed to flatten, than any nodes whose bounding volume is</span>
 <span class="s0">* smaller than the indicated radius will be combined together (as if CS_other</span>
 <span class="s0">* were set).</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline void SceneGraphReducer::set_combine_radius(PN_stdfloat combine_radius);</span>

<span class="s0">3498 18 get_combine_radius 0 4 3777 37 SceneGraphReducer::get_combine_radius 0 1 1813 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the radius that is used in conjunction with CS_within_radius.  See</span>
 <span class="s0">* set_combine_radius().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline PN_stdfloat SceneGraphReducer::get_combine_radius(void) const;</span>

<span class="s0">3499 13 apply_attribs 0 4 3777 32 SceneGraphReducer::apply_attribs 0 2 1814 1815 756</span>
<span class="s0">/**</span>
 <span class="s0">* Walks the scene graph, accumulating attribs of the indicated types,</span>
 <span class="s0">* applying them to the vertices, and removing them from the scene graph.</span>
 <span class="s0">* This has a performance optimization benefit in itself, but is especially</span>
 <span class="s0">* useful to pave the way for a call to flatten() and greatly improve the</span>
 <span class="s0">* effectiveness of the flattening operation.</span>
 <span class="s0">*</span>
 <span class="s0">* Multiply instanced geometry is duplicated before the attribs are applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Of course, this operation does make certain dynamic operations impossible.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of apply_attribs() can be called recursively from within</span>
 <span class="s0">* another flatten process (e.g.  from</span>
 <span class="s0">* PandaNode::apply_attribs_to_vertices()). The parameters were presumably</span>
 <span class="s0">* received from a parent SceneGraphReducer object.</span>
 <span class="s0">*/</span>
<span class="s0">353</span>
<span class="s0">inline void SceneGraphReducer::apply_attribs(PandaNode *node, int attrib_types = (~ ((::SceneGraphReducer::TT_clip_plane | ::SceneGraphReducer::TT_cull_face) | ::SceneGraphReducer::TT_apply_texture_color)));</span>
<span class="s0">inline void SceneGraphReducer::apply_attribs(PandaNode *node, AccumulatedAttribs const &amp;attribs, int attrib_types, GeomTransformer &amp;transformer);</span>

<span class="s0">3500 7 flatten 0 4 3777 26 SceneGraphReducer::flatten 0 1 1816 559</span>
<span class="s0">/**</span>
 <span class="s0">* Simplifies the graph by removing unnecessary nodes and nodes.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a node (and its parent node) is a candidate for removal if the</span>
 <span class="s0">* node has no siblings and the node has no special properties.</span>
 <span class="s0">*</span>
 <span class="s0">* If combine_siblings_bits is nonzero, some sibling nodes (according to the</span>
 <span class="s0">* bits set in combine_siblings_bits) may also be collapsed into a single</span>
 <span class="s0">* node.  This will further reduce scene graph complexity, sometimes</span>
 <span class="s0">* substantially, at the cost of reduced spatial separation.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the number of nodes removed from the graph.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">int SceneGraphReducer::flatten(PandaNode *root, int combine_siblings_bits);</span>

<span class="s0">3501 13 remove_column 0 4 3777 32 SceneGraphReducer::remove_column 0 1 1817 154</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated data column from any GeomVertexDatas found at the</span>
 <span class="s0">* indicated root and below.  Returns the number of GeomNodes modified.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">int SceneGraphReducer::remove_column(PandaNode *root, InternalName const *column);</span>

<span class="s0">3502 21 make_compatible_state 0 4 3777 40 SceneGraphReducer::make_compatible_state 0 1 1818 254</span>
<span class="s0">/**</span>
 <span class="s0">* Searches for GeomNodes that contain multiple Geoms that differ only in</span>
 <span class="s0">* their ColorAttribs.  If such a GeomNode is found, then all the colors are</span>
 <span class="s0">* pushed down into the vertices.  This makes it feasible for the geoms to be</span>
 <span class="s0">* unified later.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">int SceneGraphReducer::make_compatible_state(PandaNode *root);</span>

<span class="s0">3503 22 make_compatible_format 0 4 3777 41 SceneGraphReducer::make_compatible_format 0 1 1819 715</span>
<span class="s0">/**</span>
 <span class="s0">* Walks through the tree at this node and below and unifies the</span>
 <span class="s0">* GeomVertexFormat for any GeomVertexData objects that are found, so that all</span>
 <span class="s0">* eligible vdatas (according to collect_bits; see collect_vertex_data) will</span>
 <span class="s0">* share the same vertex format.</span>
 <span class="s0">*</span>
 <span class="s0">* This will add unused columns where necessary to match formats.  It can</span>
 <span class="s0">* result in suboptimal performance if used needlessly.</span>
 <span class="s0">*</span>
 <span class="s0">* There is usually no reason to call this explicitly, since</span>
 <span class="s0">* collect_vertex_data() will do this anyway if it has not been done already.</span>
 <span class="s0">* However, calling it ahead of time can make that future call to</span>
 <span class="s0">* collect_vertex_data() run a little bit faster.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the number of vertex datas modified.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline int SceneGraphReducer::make_compatible_format(PandaNode *root, int collect_bits = (~ 0));</span>

<span class="s0">3504 9 decompose 0 4 3777 28 SceneGraphReducer::decompose 0 1 1820 396</span>
<span class="s0">/**</span>
 <span class="s0">* Calls decompose() on every GeomNode at this level and below.</span>
 <span class="s0">*</span>
 <span class="s0">* There is usually no reason to call this explicitly, since unify() will do</span>
 <span class="s0">* this anyway if it needs to be done.  However, calling it ahead of time can</span>
 <span class="s0">* make that future call to unify() run a little bit faster.</span>
 <span class="s0">*</span>
 <span class="s0">* This operation has no effect if the config variable preserve-triangle-</span>
 <span class="s0">* strips has been set true.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void SceneGraphReducer::decompose(PandaNode *root);</span>

<span class="s0">3505 19 collect_vertex_data 0 4 3777 38 SceneGraphReducer::collect_vertex_data 0 1 1821 579</span>
<span class="s0">/**</span>
 <span class="s0">* Collects all different GeomVertexData blocks that have compatible formats</span>
 <span class="s0">* at this node and below into a single, unified block (or at least multiple</span>
 <span class="s0">* larger blocks).  This is intended to reduce rendering overhead incurred by</span>
 <span class="s0">* switching vertex buffers.  It can also make a subsequent call to unify()</span>
 <span class="s0">* much more effective than it would have been otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* The set of bits passed in collect_bits indicates which properties are used</span>
 <span class="s0">* to differentiate GeomVertexData blocks.  If it is 0, then more blocks will</span>
 <span class="s0">* be combined together than if it is nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">inline int SceneGraphReducer::collect_vertex_data(PandaNode *root, int collect_bits = (~ 0));</span>

<span class="s0">3506 15 make_nonindexed 0 4 3777 34 SceneGraphReducer::make_nonindexed 0 1 1822 308</span>
<span class="s0">/**</span>
 <span class="s0">* Converts indexed geometry to nonindexed geometry at the indicated node and</span>
 <span class="s0">* below, by duplicating vertices where necessary.  The parameter</span>
 <span class="s0">* nonindexed_bits is a union of bits defined in</span>
 <span class="s0">* SceneGraphReducer::MakeNonindexed, which specifes which types of geometry</span>
 <span class="s0">* to avoid making nonindexed.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline int SceneGraphReducer::make_nonindexed(PandaNode *root, int nonindexed_bits = (~ 0));</span>

<span class="s0">3507 5 unify 0 4 3777 24 SceneGraphReducer::unify 0 1 1823 224</span>
<span class="s0">/**</span>
 <span class="s0">* Calls unify() on every GeomNode at this level and below.  This attempts to</span>
 <span class="s0">* reduce the total number of individual Geoms and GeomPrimitives by combining</span>
 <span class="s0">* these objects wherever possible.  See GeomNode::unify().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void SceneGraphReducer::unify(PandaNode *root, bool preserve_order);</span>

<span class="s0">3508 22 remove_unused_vertices 0 4 3777 41 SceneGraphReducer::remove_unused_vertices 0 1 1824 273</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any vertices in GeomVertexDatas that are no longer used at this</span>
 <span class="s0">* level and below.  This requires remapping vertex indices in all of the</span>
 <span class="s0">* GeomPrimitives, to remove holes in the GeomVertexDatas.  It is normally not</span>
 <span class="s0">* necessary to call this explicitly.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void SceneGraphReducer::remove_unused_vertices(PandaNode *root);</span>

<span class="s0">3509 8 premunge 0 4 3777 27 SceneGraphReducer::premunge 0 1 1825 320</span>
<span class="s0">/**</span>
 <span class="s0">* Walks the scene graph rooted at this node and below, and uses the indicated</span>
 <span class="s0">* GSG to premunge every Geom found to optimize it for eventual rendering on</span>
 <span class="s0">* the indicated GSG.  If there is no GSG indicated for the SceneGraphReducer,</span>
 <span class="s0">* this is a no-op.</span>
 <span class="s0">*</span>
 <span class="s0">* This operation will also apply to stashed children.</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline void SceneGraphReducer::premunge(PandaNode *root, RenderState const *initial_state);</span>

<span class="s0">3510 18 check_live_flatten 0 4 3777 37 SceneGraphReducer::check_live_flatten 0 1 1826 359</span>
<span class="s0">/**</span>
 <span class="s0">* In a non-release build, returns false if the node is correctly not in a</span>
 <span class="s0">* live scene graph.  (Calling flatten on a node that is part of a live scene</span>
 <span class="s0">* graph, for instance, a node somewhere under render, can cause problems in a</span>
 <span class="s0">* multithreaded environment.)</span>
 <span class="s0">*</span>
 <span class="s0">* If allow_live_flatten is true, or in a release build, this always returns</span>
 <span class="s0">* true.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">bool SceneGraphReducer::check_live_flatten(PandaNode *node);</span>

<span class="s0">3511 34 py_decode_NodePath_from_bam_stream 0 1 0 34 py_decode_NodePath_from_bam_stream 0 1 1887 0</span>
<span class="s0">63</span>
<span class="s0">NodePath py_decode_NodePath_from_bam_stream(vector_uchar data);</span>

<span class="s0">3512 42 py_decode_NodePath_from_bam_stream_persist 0 1 0 42 py_decode_NodePath_from_bam_stream_persist 0 1 1888 0</span>
<span class="s0">92</span>
<span class="s0">NodePath py_decode_NodePath_from_bam_stream_persist(PyObject *unpickler, vector_uchar data);</span>

<span class="s0">3513 13 ParamNodePath 0 260 3782 28 ParamNodePath::ParamNodePath 0 1 1827 150</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new ParamNodePath storing the given node path object.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a new ParamNodePath storing the given node path object.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline ParamNodePath::ParamNodePath(NodePath const &amp;node_path);</span>

<span class="s0">3514 9 get_value 0 4 3782 24 ParamNodePath::get_value 0 1 1828 58</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the NodePath stored in the parameter.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline NodePath const &amp;ParamNodePath::get_value(void) const;</span>

<span class="s0">3515 14 get_class_type 0 4 3782 29 ParamNodePath::get_class_type 0 1 1829 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle ParamNodePath::get_class_type(void);</span>

<span class="s0">3516 14 ~ParamNodePath 0 516 3782 29 ParamNodePath::~ParamNodePath 0 0 0</span>
<span class="s0">36</span>
<span class="s0">ParamNodePath::~ParamNodePath(void);</span>

<span class="s0">3517 10 PortalNode 0 260 3784 22 PortalNode::PortalNode 0 2 1830 1831 349</span>
<span class="s0">/**</span>
 <span class="s0">* Default constructor, just an empty node, no geo This is used to read portal</span>
 <span class="s0">* from model.  You can also use this from python to create an empty portal.</span>
 <span class="s0">* Then you can set the vertices yourself, with addVertex.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Create a default rectangle as portal.  Use this to create an arbitrary</span>
 <span class="s0">* portal and setup from Python</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">154</span>
<span class="s0">explicit PortalNode::PortalNode(std::string const &amp;name);</span>
<span class="s0">explicit PortalNode::PortalNode(std::string const &amp;name, LPoint3 pos, PN_stdfloat scale = 10.0);</span>

<span class="s0">3518 15 set_portal_mask 0 4 3784 27 PortalNode::set_portal_mask 0 1 1832 97</span>
<span class="s0">/**</span>
 <span class="s0">* Simultaneously sets both the &quot;from&quot; and &quot;into&quot; PortalMask values to the</span>
 <span class="s0">* same thing.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void PortalNode::set_portal_mask(PortalMask mask);</span>

<span class="s0">3519 20 set_from_portal_mask 0 4 3784 32 PortalNode::set_from_portal_mask 0 1 1833 218</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;from&quot; PortalMask.  In order for a portal to be detected from this</span>
 <span class="s0">* object into another object, the intersection of this object's &quot;from&quot; mask</span>
 <span class="s0">* and the other object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void PortalNode::set_from_portal_mask(PortalMask mask);</span>

<span class="s0">3520 20 set_into_portal_mask 0 4 3784 32 PortalNode::set_into_portal_mask 0 1 1834 218</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the &quot;into&quot; PortalMask.  In order for a portal to be detected from</span>
 <span class="s0">* another object into this object, the intersection of the other object's</span>
 <span class="s0">* &quot;from&quot; mask and this object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void PortalNode::set_into_portal_mask(PortalMask mask);</span>

<span class="s0">3521 20 get_from_portal_mask 0 4 3784 32 PortalNode::get_from_portal_mask 0 1 1835 229</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current &quot;from&quot; PortalMask.  In order for a portal to be</span>
 <span class="s0">* detected from this object into another object, the intersection of this</span>
 <span class="s0">* object's &quot;from&quot; mask and the other object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline PortalMask PortalNode::get_from_portal_mask(void) const;</span>

<span class="s0">3522 20 get_into_portal_mask 0 4 3784 32 PortalNode::get_into_portal_mask 0 1 1836 229</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current &quot;into&quot; PortalMask.  In order for a portal to be</span>
 <span class="s0">* detected from another object into this object, the intersection of the</span>
 <span class="s0">* other object's &quot;from&quot; mask and this object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline PortalMask PortalNode::get_into_portal_mask(void) const;</span>

<span class="s0">3523 15 set_portal_geom 0 4 3784 27 PortalNode::set_portal_geom 0 1 1837 496</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the state of the &quot;portal geom&quot; flag for this PortalNode.  Normally,</span>
 <span class="s0">* this is false; when this is set true, the PortalSolids in this node will</span>
 <span class="s0">* test for portals with actual renderable geometry, in addition to whatever</span>
 <span class="s0">* PortalSolids may be indicated by the from_portal_mask.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this to true causes this to test *all* GeomNodes for portals.  It</span>
 <span class="s0">* is an all-or-none thing; there is no way to portal with only some</span>
 <span class="s0">* GeomNodes, as GeomNodes have no into_portal_mask.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void PortalNode::set_portal_geom(bool flag);</span>

<span class="s0">3524 15 get_portal_geom 0 4 3784 27 PortalNode::get_portal_geom 0 1 1838 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current state of the portal_geom flag.  See set_portal_geom().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool PortalNode::get_portal_geom(void) const;</span>

<span class="s0">3525 14 clear_vertices 0 4 3784 26 PortalNode::clear_vertices 0 1 1839 63</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the vertices of the portal to the empty list.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void PortalNode::clear_vertices(void);</span>

<span class="s0">3526 10 add_vertex 0 4 3784 22 PortalNode::add_vertex 0 1 1840 153</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new vertex to the portal polygon.  The vertices should be defined in</span>
 <span class="s0">* a counterclockwise orientation when viewing through the portal.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void PortalNode::add_vertex(LPoint3 const &amp;vertex);</span>

<span class="s0">3527 16 get_num_vertices 0 4 3784 28 PortalNode::get_num_vertices 0 1 1841 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of vertices in the portal polygon.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int PortalNode::get_num_vertices(void) const;</span>

<span class="s0">3528 10 get_vertex 0 4 3784 22 PortalNode::get_vertex 0 1 1842 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth vertex of the portal polygon.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LPoint3 const &amp;PortalNode::get_vertex(int n) const;</span>

<span class="s0">3529 11 set_cell_in 0 4 3784 23 PortalNode::set_cell_in 0 1 1843 52</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the cell that this portal belongs to</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void PortalNode::set_cell_in(NodePath const &amp;cell);</span>

<span class="s0">3530 11 get_cell_in 0 4 3784 23 PortalNode::get_cell_in 0 1 1844 52</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the cell that this portal belongs to</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline NodePath PortalNode::get_cell_in(void) const;</span>

<span class="s0">3531 12 set_cell_out 0 4 3784 24 PortalNode::set_cell_out 0 1 1845 54</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the cell that this portal leads out to</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void PortalNode::set_cell_out(NodePath const &amp;cell);</span>

<span class="s0">3532 12 get_cell_out 0 4 3784 24 PortalNode::get_cell_out 0 1 1846 54</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the cell that this portal leads out to</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline NodePath PortalNode::get_cell_out(void) const;</span>

<span class="s0">3533 14 set_clip_plane 0 4 3784 26 PortalNode::set_clip_plane 0 1 1847 80</span>
<span class="s0">/**</span>
 <span class="s0">* this is set if the portal will clip against its left and right planes</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void PortalNode::set_clip_plane(bool value);</span>

<span class="s0">3534 13 is_clip_plane 0 4 3784 25 PortalNode::is_clip_plane 0 1 1848 64</span>
<span class="s0">/**</span>
 <span class="s0">* Is this portal clipping against its left-right planes</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool PortalNode::is_clip_plane(void);</span>

<span class="s0">3535 11 set_visible 0 4 3784 23 PortalNode::set_visible 0 1 1849 53</span>
<span class="s0">/**</span>
 <span class="s0">* this is set if the portal is facing camera</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void PortalNode::set_visible(bool value);</span>

<span class="s0">3536 10 is_visible 0 4 3784 22 PortalNode::is_visible 0 1 1850 43</span>
<span class="s0">/**</span>
 <span class="s0">* Is this portal facing the camera</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline bool PortalNode::is_visible(void);</span>

<span class="s0">3537 13 set_max_depth 0 4 3784 25 PortalNode::set_max_depth 0 1 1851 63</span>
<span class="s0">/**</span>
 <span class="s0">* Set the maximum depth this portal will be visible at</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void PortalNode::set_max_depth(int value);</span>

<span class="s0">3538 13 get_max_depth 0 4 3784 25 PortalNode::get_max_depth 0 1 1852 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum depth this portal will be visible at</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int PortalNode::get_max_depth(void);</span>

<span class="s0">3539 8 set_open 0 4 3784 20 PortalNode::set_open 0 1 1853 55</span>
<span class="s0">/**</span>
 <span class="s0">* Python sets this based on curent camera zone</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void PortalNode::set_open(bool value);</span>

<span class="s0">3540 7 is_open 0 4 3784 19 PortalNode::is_open 0 1 1854 55</span>
<span class="s0">/**</span>
 <span class="s0">* Is this portal open from current camera zone</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline bool PortalNode::is_open(void);</span>

<span class="s0">3541 14 get_class_type 0 4 3784 26 PortalNode::get_class_type 0 1 1855 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle PortalNode::get_class_type(void);</span>

<span class="s0">3542 8 make_off 0 4 3786 23 ScissorAttrib::make_off 0 1 1856 112</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ScissorAttrib object that removes the scissor region and</span>
 <span class="s0">* fills the DisplayRegion.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ScissorAttrib::make_off(void);</span>

<span class="s0">3543 4 make 0 4 3786 19 ScissorAttrib::make 0 2 1857 1858 434</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a ScissorAttrib that restricts rendering to the indicated frame</span>
 <span class="s0">* within the current DisplayRegion.  (0,0) is the lower-left corner of the</span>
 <span class="s0">* DisplayRegion, and (1,1) is the upper-right corner.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a ScissorAttrib that restricts rendering to the indicated frame</span>
 <span class="s0">* within the current DisplayRegion.  (0,0) is the lower-left corner of the</span>
 <span class="s0">* DisplayRegion, and (1,1) is the upper-right corner.</span>
 <span class="s0">*/</span>
<span class="s0">222</span>
<span class="s0">static inline ConstPointerTo&lt; RenderAttrib &gt; ScissorAttrib::make(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ScissorAttrib::make(LVecBase4 const &amp;frame);</span>

<span class="s0">3544 12 make_default 0 4 3786 27 ScissorAttrib::make_default 0 1 1859 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ScissorAttrib::make_default(void);</span>

<span class="s0">3545 6 is_off 0 4 3786 21 ScissorAttrib::is_off 0 1 1860 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the ScissorAttrib is an 'off' ScissorAttrib, indicating</span>
 <span class="s0">* that scissor testing is disabled.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool ScissorAttrib::is_off(void) const;</span>

<span class="s0">3546 9 get_frame 0 4 3786 24 ScissorAttrib::get_frame 0 1 1861 234</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the left, right, bottom, top coordinates of the scissor frame.</span>
 <span class="s0">* This defines a frame within the current DisplayRegion, where 0,0 is the</span>
 <span class="s0">* lower-left corner of the DisplayRegion, and 1,1 is the upper-right corner.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline LVecBase4 const &amp;ScissorAttrib::get_frame(void) const;</span>

<span class="s0">3547 14 get_class_slot 0 4 3786 29 ScissorAttrib::get_class_slot 0 1 1862 0</span>
<span class="s0">47</span>
<span class="s0">static int ScissorAttrib::get_class_slot(void);</span>

<span class="s0">3548 14 get_class_type 0 4 3786 29 ScissorAttrib::get_class_type 0 1 1863 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle ScissorAttrib::get_class_type(void);</span>

<span class="s0">3549 14 ~ScissorAttrib 0 516 3786 29 ScissorAttrib::~ScissorAttrib 0 0 0</span>
<span class="s0">36</span>
<span class="s0">ScissorAttrib::~ScissorAttrib(void);</span>

<span class="s0">3550 4 make 0 4 3787 22 ShadeModelAttrib::make 0 1 1864 149</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a new ShadeModelAttrib object that specifies whether to draw</span>
 <span class="s0">* polygons with flat shading or with per-vertex (smooth) shading.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ShadeModelAttrib::make(ShadeModelAttrib::Mode mode);</span>

<span class="s0">3551 12 make_default 0 4 3787 30 ShadeModelAttrib::make_default 0 1 1865 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; ShadeModelAttrib::make_default(void);</span>

<span class="s0">3552 8 get_mode 0 4 3787 26 ShadeModelAttrib::get_mode 0 1 1866 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the shade mode.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline ShadeModelAttrib::Mode ShadeModelAttrib::get_mode(void) const;</span>

<span class="s0">3553 14 get_class_slot 0 4 3787 32 ShadeModelAttrib::get_class_slot 0 1 1867 0</span>
<span class="s0">50</span>
<span class="s0">static int ShadeModelAttrib::get_class_slot(void);</span>

<span class="s0">3554 14 get_class_type 0 4 3787 32 ShadeModelAttrib::get_class_type 0 1 1868 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle ShadeModelAttrib::get_class_type(void);</span>

<span class="s0">3555 17 ~ShadeModelAttrib 0 516 3787 35 ShadeModelAttrib::~ShadeModelAttrib 0 0 0</span>
<span class="s0">42</span>
<span class="s0">ShadeModelAttrib::~ShadeModelAttrib(void);</span>

<span class="s0">3556 8 make_off 0 4 3789 23 StencilAttrib::make_off 0 1 1869 69</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a StencilAttrib that has stenciling turned off.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; StencilAttrib::make_off(void);</span>

<span class="s0">3557 12 make_default 0 4 3789 27 StencilAttrib::make_default 0 1 1870 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; StencilAttrib::make_default(void);</span>

<span class="s0">3558 4 make 0 4 3789 19 StencilAttrib::make 0 1 1871 49</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a front face StencilAttrib.</span>
 <span class="s0">*/</span>
<span class="s0">420</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; StencilAttrib::make(bool front_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask = (~ (unsigned int)(0)));</span>

<span class="s0">3559 12 make_2_sided 0 4 3789 27 StencilAttrib::make_2_sided 0 1 1872 48</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a two-sided StencilAttrib.</span>
 <span class="s0">*/</span>
<span class="s0">676</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; StencilAttrib::make_2_sided(bool front_enable, bool back_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, RenderAttrib::PandaCompareFunc back_comparison_function, StencilAttrib::StencilOperation back_stencil_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_pass_operation);</span>

<span class="s0">3560 15 make_with_clear 0 4 3789 30 StencilAttrib::make_with_clear 0 1 1873 49</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a front face StencilAttrib.</span>
 <span class="s0">*/</span>
<span class="s0">445</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; StencilAttrib::make_with_clear(bool front_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, bool clear, unsigned int clear_value);</span>

<span class="s0">3561 23 make_2_sided_with_clear 0 4 3789 38 StencilAttrib::make_2_sided_with_clear 0 1 1874 48</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a two-sided StencilAttrib.</span>
 <span class="s0">*/</span>
<span class="s0">725</span>
<span class="s0">static ConstPointerTo&lt; RenderAttrib &gt; StencilAttrib::make_2_sided_with_clear(bool front_enable, bool back_enable, RenderAttrib::PandaCompareFunc front_comparison_function, StencilAttrib::StencilOperation stencil_fail_operation, StencilAttrib::StencilOperation stencil_pass_z_fail_operation, StencilAttrib::StencilOperation front_stencil_pass_z_pass_operation, unsigned int reference, unsigned int read_mask, unsigned int write_mask, RenderAttrib::PandaCompareFunc back_comparison_function, StencilAttrib::StencilOperation back_stencil_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_fail_operation, StencilAttrib::StencilOperation back_stencil_pass_z_pass_operation, bool clear, unsigned int clear_value);</span>

<span class="s0">3562 16 get_render_state 0 4 3789 31 StencilAttrib::get_render_state 0 1 1875 32</span>
<span class="s0">/**</span>
 <span class="s0">* Returns render state.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">inline unsigned int StencilAttrib::get_render_state(StencilAttrib::StencilRenderState render_state_identifier) const;</span>

<span class="s0">3563 14 get_class_slot 0 4 3789 29 StencilAttrib::get_class_slot 0 1 1876 0</span>
<span class="s0">47</span>
<span class="s0">static int StencilAttrib::get_class_slot(void);</span>

<span class="s0">3564 14 get_class_type 0 4 3789 29 StencilAttrib::get_class_type 0 1 1877 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle StencilAttrib::get_class_type(void);</span>

<span class="s0">3565 14 ~StencilAttrib 0 516 3789 29 StencilAttrib::~StencilAttrib 0 0 0</span>
<span class="s0">36</span>
<span class="s0">StencilAttrib::~StencilAttrib(void);</span>

<span class="s0">3566 10 has_shader 0 4 3793 22 ShaderPool::has_shader 0 1 1878 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the shader has ever been loaded, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">static inline bool ShaderPool::has_shader(Filename const &amp;filename);</span>

<span class="s0">3567 13 verify_shader 0 4 3793 25 ShaderPool::verify_shader 0 1 1879 306</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the given filename up into a shader, if it has not already been</span>
 <span class="s0">* loaded, and returns true to indicate success, or false to indicate failure.</span>
 <span class="s0">* If this returns true, it is guaranteed that a subsequent call to</span>
 <span class="s0">* load_shader() with the same shader name will return a valid Shader pointer.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline bool ShaderPool::verify_shader(Filename const &amp;filename);</span>

<span class="s0">3568 11 load_shader 0 4 3793 23 ShaderPool::load_shader 0 1 1880 261</span>
<span class="s0">/**</span>
 <span class="s0">* Loads the given filename up into a shader, if it has not already been</span>
 <span class="s0">* loaded, and returns the new shader.  If a shader with the same filename was</span>
 <span class="s0">* previously loaded, returns that one instead.  If the shader file cannot be</span>
 <span class="s0">* found, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">static inline ConstPointerTo&lt; Shader &gt; ShaderPool::load_shader(Filename const &amp;filename);</span>

<span class="s0">3569 10 add_shader 0 4 3793 22 ShaderPool::add_shader 0 1 1881 171</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated already-loaded shader to the pool.  The shader will</span>
 <span class="s0">* always replace any previously-loaded shader in the pool that had the same</span>
 <span class="s0">* filename.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">static inline void ShaderPool::add_shader(Filename const &amp;filename, Shader *shader);</span>

<span class="s0">3570 14 release_shader 0 4 3793 26 ShaderPool::release_shader 0 1 1882 270</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated shader from the pool, indicating it will never be</span>
 <span class="s0">* loaded again; the shader may then be freed.  If this function is never</span>
 <span class="s0">* called, a reference count will be maintained on every shader every loaded,</span>
 <span class="s0">* and shaders will never be freed.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline void ShaderPool::release_shader(Filename const &amp;filename);</span>

<span class="s0">3571 19 release_all_shaders 0 4 3793 31 ShaderPool::release_all_shaders 0 1 1883 85</span>
<span class="s0">/**</span>
 <span class="s0">* Releases all shaders in the pool and restores the pool to the empty state.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline void ShaderPool::release_all_shaders(void);</span>

<span class="s0">3572 15 garbage_collect 0 4 3793 27 ShaderPool::garbage_collect 0 1 1884 209</span>
<span class="s0">/**</span>
 <span class="s0">* Releases only those shaders in the pool that have a reference count of</span>
 <span class="s0">* exactly 1; i.e.  only those shaders that are not being used outside of the</span>
 <span class="s0">* pool.  Returns the number of shaders released.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">static inline int ShaderPool::garbage_collect(void);</span>

<span class="s0">3573 13 list_contents 0 4 3793 25 ShaderPool::list_contents 0 1 1885 80</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the shader pool to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">static inline void ShaderPool::list_contents(std::ostream &amp;out);</span>

<span class="s0">3574 5 write 0 4 3793 17 ShaderPool::write 0 1 1886 80</span>
<span class="s0">/**</span>
 <span class="s0">* Lists the contents of the shader pool to the indicated output stream.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static void ShaderPool::write(std::ostream &amp;out);</span>

<span class="s0">3575 11 ~ShaderPool 0 516 3793 23 ShaderPool::~ShaderPool 0 0 0</span>
<span class="s0">30</span>
<span class="s0">ShaderPool::~ShaderPool(void);</span>

<span class="s0">1888</span>
<span class="s0">1 0 0 6 3 3600 0 0 0 2 4 this 3 3794  5 other 1 3794  </span>
<span class="s0">2 0 0 6 4 3593 0 0 317 /**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique TransformStates, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this returns 0, it doesn't necessarily imply that operator ==</span>
 <span class="s0">* returns true; it uses a very slightly different comparison threshold.</span>
 <span class="s0">*/ 2 4 this 3 3794  5 other 1 3794  </span>
<span class="s0">3 0 0 6 4 3593 0 0 528 /**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique TransformStates, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this returns 0, it doesn't necessarily imply that operator ==</span>
 <span class="s0">* returns true; it uses a very slightly different comparison threshold.</span>
 <span class="s0">*</span>
 <span class="s0">* If uniquify_matrix is true, then matrix-defined TransformStates are also</span>
 <span class="s0">* uniqified.  If uniquify_matrix is false, then only component-defined</span>
 <span class="s0">* TransformStates are uniquified, which is less expensive.</span>
 <span class="s0">*/ 3 4 this 3 3794  5 other 1 3794  15 uniquify_matrix 1 3600  </span>
<span class="s0">4 0 0 6 5 3600 0 0 0 2 4 this 3 3794  5 other 1 3794  </span>
<span class="s0">5 0 0 6 6 3796 0 0 55 /**</span>
 <span class="s0">* Returns a suitable hash value for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">6 0 0 7 7 3794 0 0 44 /**</span>
 <span class="s0">* Constructs an identity transform.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">7 0 0 7 8 3794 0 0 103 /**</span>
 <span class="s0">* Constructs an invalid transform; for instance, the result of inverting a</span>
 <span class="s0">* singular matrix.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">8 0 0 7 9 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 1 3 pos 1 3798  </span>
<span class="s0">9 0 0 7 10 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 1 3 hpr 1 3798  </span>
<span class="s0">10 0 0 7 11 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 1 4 quat 1 3799  </span>
<span class="s0">11 0 0 7 12 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 2 3 pos 1 3798  3 hpr 1 3798  </span>
<span class="s0">12 0 0 7 13 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 1 5 scale 1 3798  </span>
<span class="s0">13 0 0 7 13 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 1 5 scale 1 3598  </span>
<span class="s0">14 0 0 7 14 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 1 5 shear 1 3798  </span>
<span class="s0">15 0 0 7 15 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 3 3 pos 1 3798  3 hpr 1 3798  5 scale 1 3798  </span>
<span class="s0">16 0 0 7 16 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 3 3 pos 1 3798  4 quat 1 3799  5 scale 1 3798  </span>
<span class="s0">17 0 0 7 17 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 4 3 pos 1 3798  3 hpr 1 3798  5 scale 1 3798  5 shear 1 3798  </span>
<span class="s0">18 0 0 7 18 3794 0 0 68 /**</span>
 <span class="s0">* Makes a new TransformState with the specified components.</span>
 <span class="s0">*/ 4 3 pos 1 3798  4 quat 1 3799  5 scale 1 3798  5 shear 1 3798  </span>
<span class="s0">19 0 0 7 19 3794 0 0 79 /**</span>
 <span class="s0">* Makes a new TransformState with the specified transformation matrix.</span>
 <span class="s0">*/ 1 3 mat 1 3800  </span>
<span class="s0">20 0 0 7 20 3794 0 0 72 /**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/ 1 3 pos 1 3801  </span>
<span class="s0">21 0 0 7 21 3794 0 0 72 /**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/ 1 6 rotate 1 3598  </span>
<span class="s0">22 0 0 7 22 3794 0 0 72 /**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/ 2 3 pos 1 3801  6 rotate 1 3598  </span>
<span class="s0">23 0 0 7 23 3794 0 0 72 /**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/ 1 5 scale 1 3801  </span>
<span class="s0">24 0 0 7 23 3794 0 0 72 /**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/ 1 5 scale 1 3598  </span>
<span class="s0">25 0 0 7 24 3794 0 0 72 /**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/ 1 5 shear 1 3598  </span>
<span class="s0">26 0 0 7 25 3794 0 0 72 /**</span>
 <span class="s0">* Makes a new 2-d TransformState with the specified components.</span>
 <span class="s0">*/ 3 3 pos 1 3801  6 rotate 1 3598  5 scale 1 3801  </span>
<span class="s0">27 0 0 7 26 3794 0 0 84 /**</span>
 <span class="s0">* Makes a new two-dimensional TransformState with the specified components.</span>
 <span class="s0">*/ 4 3 pos 1 3801  6 rotate 1 3598  5 scale 1 3801  5 shear 1 3598  </span>
<span class="s0">28 0 0 7 27 3794 0 0 102 /**</span>
 <span class="s0">* Makes a new two-dimensional TransformState with the specified 3x3</span>
 <span class="s0">* transformation matrix.</span>
 <span class="s0">*/ 1 3 mat 1 3805  </span>
<span class="s0">29 0 0 6 28 3600 0 0 92 /**</span>
 <span class="s0">* Returns true if the transform represents the identity matrix, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">30 0 0 6 29 3600 0 0 168 /**</span>
 <span class="s0">* Returns true if the transform represents an invalid matrix, for instance</span>
 <span class="s0">* the result of inverting a singular matrix, or false if the transform is</span>
 <span class="s0">* valid.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">31 0 0 6 30 3600 0 0 154 /**</span>
 <span class="s0">* Returns true if the transform represents a singular transform (that is, it</span>
 <span class="s0">* has a zero scale, and it cannot be inverted), or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">32 0 0 6 31 3600 0 0 206 /**</span>
 <span class="s0">* Returns true if the transform has been constructed entirely using the 2-d</span>
 <span class="s0">* transform operations, e.g.  make_pos2d(), and therefore operates strictly</span>
 <span class="s0">* in two-dimensional space on X and Y only.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">33 0 0 6 32 3600 0 0 654 /**</span>
 <span class="s0">* Returns true if the transform can be described by separate pos, hpr, and</span>
 <span class="s0">* scale components.  Most transforms we use in everyday life can be so</span>
 <span class="s0">* described, but some kinds of transforms (for instance, those involving a</span>
 <span class="s0">* skew) cannot.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not related to whether the transform was originally described</span>
 <span class="s0">* componentwise.  Even a transform that was constructed with a 4x4 may return</span>
 <span class="s0">* true here if the matrix is a simple affine matrix with no skew.</span>
 <span class="s0">*</span>
 <span class="s0">* If this returns true, you may safely call get_hpr() and get_scale() to</span>
 <span class="s0">* retrieve the components.  (You may always safely call get_pos() whether</span>
 <span class="s0">* this returns true or false.)</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">34 0 0 6 33 3600 0 0 454 /**</span>
 <span class="s0">* Returns true if the transform was specified componentwise, or false if it</span>
 <span class="s0">* was specified with a general 4x4 matrix.  If this is true, the components</span>
 <span class="s0">* returned by get_pos() and get_scale() will be exactly those that were set;</span>
 <span class="s0">* otherwise, these functions will return computed values.  If this is true,</span>
 <span class="s0">* the rotation may have been set either with a hpr trio or with a quaternion;</span>
 <span class="s0">* hpr_given() or quat_given() can resolve the difference.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">35 0 0 6 34 3600 0 0 200 /**</span>
 <span class="s0">* Returns true if the rotation was specified via a trio of Euler angles,</span>
 <span class="s0">* false otherwise.  If this is true, get_hpr() will be exactly as set;</span>
 <span class="s0">* otherwise, it will return a computed value.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">36 0 0 6 35 3600 0 0 191 /**</span>
 <span class="s0">* Returns true if the rotation was specified via a quaternion, false</span>
 <span class="s0">* otherwise.  If this is true, get_quat() will be exactly as set; otherwise,</span>
 <span class="s0">* it will return a computed value.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">37 0 0 6 36 3600 0 0 194 /**</span>
 <span class="s0">* Returns true if the transform's pos component can be extracted out</span>
 <span class="s0">* separately.  This is generally always true, unless the transform is invalid</span>
 <span class="s0">* (i.e.  is_invalid() returns true).</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">38 0 0 6 37 3600 0 0 199 /**</span>
 <span class="s0">* Returns true if the transform's rotation component can be extracted out</span>
 <span class="s0">* separately and described as a set of Euler angles.  This is generally true</span>
 <span class="s0">* only when has_components() is true.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">39 0 0 6 38 3600 0 0 190 /**</span>
 <span class="s0">* Returns true if the transform's rotation component can be extracted out</span>
 <span class="s0">* separately and described as a quaternion.  This is generally true only when</span>
 <span class="s0">* has_components() is true.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">40 0 0 6 39 3600 0 0 154 /**</span>
 <span class="s0">* Returns true if the transform's scale component can be extracted out</span>
 <span class="s0">* separately.  This is generally true only when has_components() is true.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">41 0 0 6 40 3600 0 0 98 /**</span>
 <span class="s0">* Returns true if the scale is uniform 1.0, or false if the scale has some</span>
 <span class="s0">* real value.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">42 0 0 6 41 3600 0 0 201 /**</span>
 <span class="s0">* Returns true if the scale is uniform across all three axes (and therefore</span>
 <span class="s0">* can be expressed as a single number), or false if the transform has a</span>
 <span class="s0">* different scale in different dimensions.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">43 0 0 6 42 3600 0 0 154 /**</span>
 <span class="s0">* Returns true if the transform's shear component can be extracted out</span>
 <span class="s0">* separately.  This is generally true only when has_components() is true.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">44 0 0 6 43 3600 0 0 121 /**</span>
 <span class="s0">* Returns true if the shear component is non-zero, false if it is zero or if</span>
 <span class="s0">* the matrix cannot be decomposed.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">45 0 0 6 44 3600 0 0 134 /**</span>
 <span class="s0">* Returns true if the transform can be described as a matrix.  This is</span>
 <span class="s0">* generally always true, unless is_invalid() is true.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">46 0 0 6 45 3809 0 0 115 /**</span>
 <span class="s0">* Returns the pos component of the transform.  It is an error to call this if</span>
 <span class="s0">* has_pos() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">47 0 0 6 46 3798 0 0 152 /**</span>
 <span class="s0">* Returns the rotation component of the transform as a trio of Euler angles.</span>
 <span class="s0">* It is an error to call this if has_components() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">48 0 0 6 47 3799 0 0 412 /**</span>
 <span class="s0">* Returns the rotation component of the transform as a quaternion.  The</span>
 <span class="s0">* return value will be normalized if a normalized quaternion was given to the</span>
 <span class="s0">* constructor (or if the quaternion was computed implicitly); it will be non-</span>
 <span class="s0">* normalized if a non-normalized quaternion was given to the constructor.</span>
 <span class="s0">* See also get_norm_quat().</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error to call this if has_components() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">49 0 0 6 48 3799 0 0 247 /**</span>
 <span class="s0">* Returns the rotation component of the transform as a quaternion.  Unlike</span>
 <span class="s0">* the result of get_quat(), the return value of this method is guaranteed to</span>
 <span class="s0">* be normalized.  It is an error to call this if has_components() returned</span>
 <span class="s0">* false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">50 0 0 6 49 3798 0 0 124 /**</span>
 <span class="s0">* Returns the scale component of the transform.  It is an error to call this</span>
 <span class="s0">* if has_components() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">51 0 0 6 50 3598 0 0 147 /**</span>
 <span class="s0">* Returns the scale component of the transform, as a single number.  It is an</span>
 <span class="s0">* error to call this if has_uniform_scale() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">52 0 0 6 51 3798 0 0 124 /**</span>
 <span class="s0">* Returns the shear component of the transform.  It is an error to call this</span>
 <span class="s0">* if has_components() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">53 0 0 6 52 3800 0 0 59 /**</span>
 <span class="s0">* Returns the matrix that describes the transform.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">54 0 0 7 53 3810 0 0 130 /**</span>
 <span class="s0">* Returns the pos component of the 2-d transform.  It is an error to call</span>
 <span class="s0">* this if has_pos() or is_2d() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">55 0 0 6 54 3598 0 0 195 /**</span>
 <span class="s0">* Returns the rotation component of the 2-d transform as an angle in degrees</span>
 <span class="s0">* clockwise about the origin.  It is an error to call this if</span>
 <span class="s0">* has_components() or is_2d() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">56 0 0 7 55 3810 0 0 139 /**</span>
 <span class="s0">* Returns the scale component of the 2-d transform.  It is an error to call</span>
 <span class="s0">* this if has_components() or is_2d() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">57 0 0 6 56 3598 0 0 139 /**</span>
 <span class="s0">* Returns the shear component of the 2-d transform.  It is an error to call</span>
 <span class="s0">* this if has_components() or is_2d() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">58 0 0 7 57 3811 0 0 126 /**</span>
 <span class="s0">* Returns the 3x3 matrix that describes the 2-d transform.  It is an error to</span>
 <span class="s0">* call this if is_2d() returned false.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">59 0 0 7 77 3794 0 0 151 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its pos component replaced with the indicated value.</span>
 <span class="s0">*/ 2 4 this 3 3794  3 pos 1 3798  </span>
<span class="s0">60 0 0 7 78 3794 0 0 172 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its rotation component replaced with the indicated</span>
 <span class="s0">* value, if possible.</span>
 <span class="s0">*/ 2 4 this 3 3794  3 hpr 1 3798  </span>
<span class="s0">61 0 0 7 79 3794 0 0 172 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its rotation component replaced with the indicated</span>
 <span class="s0">* value, if possible.</span>
 <span class="s0">*/ 2 4 this 3 3794  4 quat 1 3799  </span>
<span class="s0">62 0 0 7 80 3794 0 0 169 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its scale component replaced with the indicated value,</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*/ 2 4 this 3 3794  5 scale 1 3798  </span>
<span class="s0">63 0 0 7 81 3794 0 0 169 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original</span>
 <span class="s0">* TransformState with its shear component replaced with the indicated value,</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*/ 2 4 this 3 3794  5 shear 1 3798  </span>
<span class="s0">64 0 0 7 82 3794 0 0 155 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original 2-d</span>
 <span class="s0">* TransformState with its pos component replaced with the indicated value.</span>
 <span class="s0">*/ 2 4 this 3 3794  3 pos 1 3801  </span>
<span class="s0">65 0 0 7 83 3794 0 0 176 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original 2-d</span>
 <span class="s0">* TransformState with its rotation component replaced with the indicated</span>
 <span class="s0">* value, if possible.</span>
 <span class="s0">*/ 2 4 this 3 3794  6 rotate 1 3598  </span>
<span class="s0">66 0 0 7 84 3794 0 0 173 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original 2-d</span>
 <span class="s0">* TransformState with its scale component replaced with the indicated value,</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*/ 2 4 this 3 3794  5 scale 1 3801  </span>
<span class="s0">67 0 0 7 85 3794 0 0 173 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the original 2-d</span>
 <span class="s0">* TransformState with its shear component replaced with the indicated value,</span>
 <span class="s0">* if possible.</span>
 <span class="s0">*/ 2 4 this 3 3794  5 shear 1 3598  </span>
<span class="s0">68 0 0 7 86 3794 0 0 408 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the composition of this</span>
 <span class="s0">* state with the other state.</span>
 <span class="s0">*</span>
 <span class="s0">* The result of this operation is cached, and will be retained as long as</span>
 <span class="s0">* both this TransformState object and the other TransformState object</span>
 <span class="s0">* continue to exist.  Should one of them destruct, the cached entry will be</span>
 <span class="s0">* removed, and its pointer will be allowed to destruct as well.</span>
 <span class="s0">*/ 2 4 this 3 3794  5 other 1 3794  </span>
<span class="s0">69 0 0 7 87 3794 0 0 268 /**</span>
 <span class="s0">* Returns a new TransformState object that represents the composition of this</span>
 <span class="s0">* state's inverse with the other state.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to compose(), but is particularly useful for computing the</span>
 <span class="s0">* relative state of a node as viewed from some other node.</span>
 <span class="s0">*/ 2 4 this 3 3794  5 other 1 3794  </span>
<span class="s0">70 0 0 7 88 3794 0 0 199 /**</span>
 <span class="s0">* Returns the inverse of this transform.  If you are going to immediately</span>
 <span class="s0">* compose this result with another TransformState, it is faster to do it in</span>
 <span class="s0">* one operation with invert_compose().</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">71 0 0 7 89 3794 0 0 331 /**</span>
 <span class="s0">* Returns the pointer to the unique TransformState in the cache that is</span>
 <span class="s0">* equivalent to this one.  This may be the same pointer as this object, or it</span>
 <span class="s0">* may be a different pointer; but it will be an equivalent object, and it</span>
 <span class="s0">* will be a shared pointer.  This may be called from time to time to improve</span>
 <span class="s0">* cache benefits.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">72 0 0 6 90 3593 0 0 261 /**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this TransformState is applied to a geom which includes the indicated</span>
 <span class="s0">* geom_rendering bits.  The RenderState's get_geom_rendering() should already</span>
 <span class="s0">* have been applied.</span>
 <span class="s0">*/ 2 4 this 3 3794  14 geom_rendering 1 3593  </span>
<span class="s0">73 0 0 4 91 3812 0 0 64 /**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">74 0 0 6 92 3600 0 0 64 /**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">75 0 0 4 93 3812 0 0 64 /**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">76 0 0 6 94 3600 0 0 64 /**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">77 0 0 6 95 3796 0 0 278 /**</span>
 <span class="s0">* Returns the number of entries in the composition cache for this</span>
 <span class="s0">* TransformState.  This is the number of other TransformStates whose</span>
 <span class="s0">* composition with this one has been cached.  This number is not useful for</span>
 <span class="s0">* any practical reason other than performance analysis.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">78 0 0 6 96 3796 0 0 256 /**</span>
 <span class="s0">* Returns the number of entries in the invert_composition cache for this</span>
 <span class="s0">* TransformState.  This is similar to the composition cache, but it records</span>
 <span class="s0">* cache entries for the invert_compose() operation.  See</span>
 <span class="s0">* get_composition_cache_num_entries().</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">79 0 0 6 97 3796 0 0 337 /**</span>
 <span class="s0">* Returns the number of slots in the composition cache for this</span>
 <span class="s0">* TransformState.  You may use this as an upper bound when walking through</span>
 <span class="s0">* all of the composition cache results via get_composition_cache_source() or</span>
 <span class="s0">* result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">80 0 0 7 98 3794 0 0 303 /**</span>
 <span class="s0">* Returns the source TransformState of the nth element in the composition</span>
 <span class="s0">* cache.  Returns NULL if there doesn't happen to be an entry in the nth</span>
 <span class="s0">* element.  See get_composition_cache_result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 2 4 this 3 3794  1 n 1 3796  </span>
<span class="s0">81 0 0 7 99 3794 0 0 373 /**</span>
 <span class="s0">* Returns the result TransformState of the nth element in the composition</span>
 <span class="s0">* cache.  Returns NULL if there doesn't happen to be an entry in the nth</span>
 <span class="s0">* element.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a-&gt;compose(a-&gt;get_composition_cache_source(n)) ==</span>
 <span class="s0">* a-&gt;get_composition_cache_result(n).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 2 4 this 3 3794  1 n 1 3796  </span>
<span class="s0">82 0 0 6 100 3796 0 0 344 /**</span>
 <span class="s0">* Returns the number of slots in the composition cache for this</span>
 <span class="s0">* TransformState.  You may use this as an upper bound when walking through</span>
 <span class="s0">* all of the composition cache results via</span>
 <span class="s0">* get_invert_composition_cache_source() or result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">83 0 0 7 101 3794 0 0 317 /**</span>
 <span class="s0">* Returns the source TransformState of the nth element in the invert</span>
 <span class="s0">* composition cache.  Returns NULL if there doesn't happen to be an entry in</span>
 <span class="s0">* the nth element.  See get_invert_composition_cache_result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 2 4 this 3 3794  1 n 1 3796  </span>
<span class="s0">84 0 0 7 102 3794 0 0 401 /**</span>
 <span class="s0">* Returns the result TransformState of the nth element in the invert</span>
 <span class="s0">* composition cache.  Returns NULL if there doesn't happen to be an entry in</span>
 <span class="s0">* the nth element.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a-&gt;invert_compose(a-&gt;get_invert_composition_cache_source(n)) ==</span>
 <span class="s0">* a-&gt;get_invert_composition_cache_result(n).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 2 4 this 3 3794  1 n 1 3796  </span>
<span class="s0">85 0 0 6 103 3600 0 0 163 /**</span>
 <span class="s0">* Returns true if the composition cache and invert composition cache for this</span>
 <span class="s0">* particular TransformState are self-consistent and valid, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3794  </span>
<span class="s0">86 0 0 38 104 3623 0 0 0 1 4 this 3 3794  </span>
<span class="s0">87 0 0 38 105 3623 0 0 0 1 4 this 3 3794  </span>
<span class="s0">88 0 0 4 106 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3794  3 out 1 3813  </span>
<span class="s0">89 0 0 4 107 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3794  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">90 0 0 4 108 3812 0 0 208 /**</span>
 <span class="s0">* Writes a brief description of the composition cache and invert composition</span>
 <span class="s0">* cache to the indicated ostream.  This is not useful except for performance</span>
 <span class="s0">* analysis, to examine the cache structure.</span>
 <span class="s0">*/ 3 4 this 3 3794  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">91 0 0 6 109 3593 0 0 147 /**</span>
 <span class="s0">* Returns the total number of unique TransformState objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">92 0 0 6 110 3593 0 0 612 /**</span>
 <span class="s0">* Returns the total number of TransformState objects that have been allocated</span>
 <span class="s0">* but have no references outside of the internal TransformState cache.</span>
 <span class="s0">*</span>
 <span class="s0">* A nonzero return value is not necessarily indicative of leaked references;</span>
 <span class="s0">* it is normal for two TransformState objects, both of which have references</span>
 <span class="s0">* held outside the cache, to have the result of their composition stored</span>
 <span class="s0">* within the cache.  This result will be retained within the cache until one</span>
 <span class="s0">* of the base TransformStates is released.</span>
 <span class="s0">*</span>
 <span class="s0">* Use list_cycles() to get an idea of the number of actual &quot;leaked&quot;</span>
 <span class="s0">* TransformState objects.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">93 0 0 6 111 3593 0 0 617 /**</span>
 <span class="s0">* Empties the cache of composed TransformStates.  This makes every</span>
 <span class="s0">* TransformState forget what results when it is composed with other</span>
 <span class="s0">* TransformStates.</span>
 <span class="s0">*</span>
 <span class="s0">* This will eliminate any TransformState objects that have been allocated but</span>
 <span class="s0">* have no references outside of the internal TransformState map.  It will not</span>
 <span class="s0">* eliminate TransformState objects that are still in use.</span>
 <span class="s0">*</span>
 <span class="s0">* Nowadays, this method should not be necessary, as reference-count cycles in</span>
 <span class="s0">* the composition cache should be automatically detected and broken.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the number of TransformStates freed by this operation.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">94 0 0 6 112 3593 0 0 297 /**</span>
 <span class="s0">* Performs a garbage-collection cycle.  This must be called periodically if</span>
 <span class="s0">* garbage-collect-states is true to ensure that TransformStates get cleaned</span>
 <span class="s0">* up appropriately.  It does no harm to call it even if this variable is not</span>
 <span class="s0">* true, but there is probably no advantage in that case.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">95 0 0 4 113 3812 0 0 565 /**</span>
 <span class="s0">* Detects all of the reference-count cycles in the cache and reports them to</span>
 <span class="s0">* standard output.</span>
 <span class="s0">*</span>
 <span class="s0">* These cycles may be inadvertently created when state compositions cycle</span>
 <span class="s0">* back to a starting point.  Nowadays, these cycles should be automatically</span>
 <span class="s0">* detected and broken, so this method should never list any cycles unless</span>
 <span class="s0">* there is a bug in that detection logic.</span>
 <span class="s0">*</span>
 <span class="s0">* The cycles listed here are not leaks in the strictest sense of the word,</span>
 <span class="s0">* since they can be reclaimed by a call to clear_cache(); but they will not</span>
 <span class="s0">* be reclaimed automatically.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">96 0 0 4 114 3812 0 0 172 /**</span>
 <span class="s0">* Lists all of the TransformStates in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">97 0 0 6 115 3600 0 0 282 /**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order, and that none of</span>
 <span class="s0">* the cache elements have been inadvertently deleted.  Returns true if so,</span>
 <span class="s0">* false if there is a problem (which implies someone has modified one of the</span>
 <span class="s0">* supposedly-const TransformState objects).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">98 0 0 38 116 3623 0 0 0 0 </span>
<span class="s0">99 0 0 38 117 3623 0 0 0 0 </span>
<span class="s0">100 0 0 7 118 3816 0 0 0 0 </span>
<span class="s0">101 0 0 6 120 3593 0 0 117 /**</span>
 <span class="s0">* Returns the slot number assigned to the indicated TypeHandle, or 0 if no</span>
 <span class="s0">* slot number has been assigned.</span>
 <span class="s0">*/ 2 4 this 3 3817  11 type_handle 1 3816  </span>
<span class="s0">102 0 0 6 121 3593 0 0 0 0 </span>
<span class="s0">103 0 0 6 122 3593 0 0 135 /**</span>
 <span class="s0">* Returns the number of RenderAttrib slots that have been allocated.  This is</span>
 <span class="s0">* one more than the highest slot number in use.</span>
 <span class="s0">*/ 1 4 this 3 3817  </span>
<span class="s0">104 0 0 7 123 3816 0 0 57 /**</span>
 <span class="s0">* Returns the TypeHandle associated with slot n.</span>
 <span class="s0">*/ 2 4 this 3 3817  4 slot 1 3593  </span>
<span class="s0">105 0 0 6 124 3593 0 0 58 /**</span>
 <span class="s0">* Returns the sort number associated with slot n.</span>
 <span class="s0">*/ 2 4 this 3 3817  4 slot 1 3593  </span>
<span class="s0">106 0 0 4 125 3812 0 0 58 /**</span>
 <span class="s0">* Changes the sort number associated with slot n.</span>
 <span class="s0">*/ 3 4 this 3 3819  4 slot 1 3593  4 sort 1 3593  </span>
<span class="s0">107 0 0 7 126 3607 0 0 172 /**</span>
 <span class="s0">* Returns the default RenderAttrib object associated with slot n.  This is</span>
 <span class="s0">* the attrib that should be applied in the absence of any other attrib of</span>
 <span class="s0">* this type.</span>
 <span class="s0">*/ 2 4 this 3 3817  4 slot 1 3593  </span>
<span class="s0">108 0 0 6 127 3593 0 0 66 /**</span>
 <span class="s0">* Returns the number of entries in the sorted_slots list.</span>
 <span class="s0">*/ 1 4 this 3 3817  </span>
<span class="s0">109 0 0 6 128 3593 0 0 170 /**</span>
 <span class="s0">* Returns the nth slot in sorted order.  By traversing this list, you will</span>
 <span class="s0">* retrieve all the slot numbers in order according to their registered sort</span>
 <span class="s0">* value.</span>
 <span class="s0">*/ 2 4 this 3 3817  1 n 1 3593  </span>
<span class="s0">110 0 0 6 129 3819 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">111 0 0 7 132 3607 0 0 322 /**</span>
 <span class="s0">* Returns a new RenderAttrib object that represents the composition of this</span>
 <span class="s0">* attrib with the other attrib.  In most cases, this is the same as the other</span>
 <span class="s0">* attrib; a compose b produces b.  Some kinds of attributes, like a</span>
 <span class="s0">* TextureTransform, for instance, might produce a new result: a compose b</span>
 <span class="s0">* produces c.</span>
 <span class="s0">*/ 2 4 this 3 3607  5 other 1 3607  </span>
<span class="s0">112 0 0 7 133 3607 0 0 583 /**</span>
 <span class="s0">* Returns a new RenderAttrib object that represents the composition of the</span>
 <span class="s0">* inverse of this attrib with the other attrib.  In most cases, this is the</span>
 <span class="s0">* same as the other attrib; !a compose b produces b.  Some kinds of</span>
 <span class="s0">* attributes, like a TextureTransform, for instance, might produce a new</span>
 <span class="s0">* result: !a compose b produces c.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to compose() except that the source attrib is inverted</span>
 <span class="s0">* first.  This is used to compute the relative attribute for one node as</span>
 <span class="s0">* viewed from some other node, which is especially useful for transform-type</span>
 <span class="s0">* attributes.</span>
 <span class="s0">*/ 2 4 this 3 3607  5 other 1 3607  </span>
<span class="s0">113 0 0 6 134 3600 0 0 951 /**</span>
 <span class="s0">* Intended to be overridden by derived RenderAttrib types to specify how two</span>
 <span class="s0">* consecutive RenderAttrib objects of the same type interact.</span>
 <span class="s0">*</span>
 <span class="s0">* This should return false if a RenderAttrib on a higher node will compose</span>
 <span class="s0">* into a RenderAttrib on a lower node that has a higher override value, or</span>
 <span class="s0">* true if the lower RenderAttrib will completely replace the state.</span>
 <span class="s0">*</span>
 <span class="s0">* The default behavior is false: normally, a RenderAttrib in the graph cannot</span>
 <span class="s0">* completely override a RenderAttrib above it, regardless of its override</span>
 <span class="s0">* value--instead, the two attribs are composed.  But for some kinds of</span>
 <span class="s0">* RenderAttribs, it is useful to allow this kind of override.</span>
 <span class="s0">*</span>
 <span class="s0">* This method only handles the one special case of a lower RenderAttrib with</span>
 <span class="s0">* a higher override value.  If the higher RenderAttrib has a higher override</span>
 <span class="s0">* value, it always completely overrides.  And if both RenderAttribs have the</span>
 <span class="s0">* same override value, they are always composed.</span>
 <span class="s0">*/ 1 4 this 3 3607  </span>
<span class="s0">114 0 0 6 135 3593 0 0 368 /**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique RenderAttribs, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not needed outside of the RenderAttrib class because all</span>
 <span class="s0">* equivalent RenderAttrib objects are guaranteed to share the same pointer;</span>
 <span class="s0">* thus, a pointer comparison is always sufficient.</span>
 <span class="s0">*/ 2 4 this 3 3607  5 other 1 3607  </span>
<span class="s0">115 0 0 6 136 3796 0 0 55 /**</span>
 <span class="s0">* Returns a suitable hash value for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3607  </span>
<span class="s0">116 0 0 7 137 3607 0 0 329 /**</span>
 <span class="s0">* Returns the pointer to the unique RenderAttrib in the cache that is</span>
 <span class="s0">* equivalent to this one.  This may be the same pointer as this object, or it</span>
 <span class="s0">* may be a different pointer; but it will be an equivalent object, and it</span>
 <span class="s0">* will be a shared pointer.  This may be called from time to time to improve</span>
 <span class="s0">* cache benefits.</span>
 <span class="s0">*/ 1 4 this 3 3607  </span>
<span class="s0">117 0 0 4 138 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3607  3 out 1 3813  </span>
<span class="s0">118 0 0 4 139 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3607  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">119 0 0 6 140 3593 0 0 145 /**</span>
 <span class="s0">* Returns the total number of unique RenderAttrib objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">120 0 0 4 141 3812 0 0 170 /**</span>
 <span class="s0">* Lists all of the RenderAttribs in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">121 0 0 6 142 3593 0 0 155 /**</span>
 <span class="s0">* Performs a garbage-collection cycle.  This is called automatically from</span>
 <span class="s0">* RenderState::garbage_collect(); see that method for more information.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">122 0 0 6 143 3600 0 0 208 /**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order.  Returns true if</span>
 <span class="s0">* so, false if there is a problem (which implies someone has modified one of</span>
 <span class="s0">* the supposedly-const RenderAttrib objects).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">123 0 0 6 144 3593 0 0 0 1 4 this 3 3607  </span>
<span class="s0">124 0 0 7 149 3816 0 0 0 0 </span>
<span class="s0">125 0 0 23 152 3607 0 0 921 /**</span>
 <span class="s0">* Constructs a new RenderModeAttrib object that specifies whether to draw</span>
 <span class="s0">* polygons in the normal, filled mode, or wireframe mode, or in some other</span>
 <span class="s0">* yet-to-be-defined mode.</span>
 <span class="s0">*</span>
 <span class="s0">* The thickness parameter specifies the thickness to be used for wireframe</span>
 <span class="s0">* lines, as well as for ordinary linestrip lines; it also specifies the</span>
 <span class="s0">* diameter of points.  (Thick lines are presently only supported in OpenGL;</span>
 <span class="s0">* but thick points are supported on either platform.)</span>
 <span class="s0">*</span>
 <span class="s0">* If perspective is true, the point thickness represented is actually a width</span>
 <span class="s0">* in 3-d units, and the points should scale according to perspective.  When</span>
 <span class="s0">* it is false, the point thickness is actually a width in pixels, and points</span>
 <span class="s0">* are a uniform screen size regardless of distance from the camera.</span>
 <span class="s0">*</span>
 <span class="s0">* In M_filled_wireframe mode, you should also specify the wireframe_color,</span>
 <span class="s0">* indicating the flat color to assign to the overlayed wireframe.</span>
 <span class="s0">*/ 4 4 mode 1 3597  9 thickness 5 3598  11 perspective 5 3600  15 wireframe_color 5 3820  </span>
<span class="s0">126 0 0 7 153 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">127 0 0 6 154 3597 0 0 35 /**</span>
 <span class="s0">* Returns the render mode.</span>
 <span class="s0">*/ 1 4 this 3 3821  </span>
<span class="s0">128 0 0 6 155 3598 0 0 235 /**</span>
 <span class="s0">* Returns the line width or point thickness.  This is only relevant when</span>
 <span class="s0">* rendering points or lines, such as when the mode is M_wireframe or M_point</span>
 <span class="s0">* (or when rendering actual points or lines primitives in M_polygon mode).</span>
 <span class="s0">*/ 1 4 this 3 3821  </span>
<span class="s0">129 0 0 6 156 3600 0 0 364 /**</span>
 <span class="s0">* Returns the perspective flag.  When this is true, the point thickness</span>
 <span class="s0">* represented by get_thickness() is actually a width in 3-d units, and the</span>
 <span class="s0">* points should scale according to perspective.  When it is false, the</span>
 <span class="s0">* default, the point thickness is actually a width in pixels, and points are</span>
 <span class="s0">* a uniform size regardless of distance from the camera.</span>
 <span class="s0">*/ 1 4 this 3 3821  </span>
<span class="s0">130 0 0 6 157 3820 0 0 131 /**</span>
 <span class="s0">* Returns the color that is used in M_filled_wireframe mode to distinguish</span>
 <span class="s0">* the wireframe from the rest of the geometry.</span>
 <span class="s0">*/ 1 4 this 3 3821  </span>
<span class="s0">131 0 0 6 158 3593 0 0 186 /**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this RenderModeAttrib is applied to a geom which includes the</span>
 <span class="s0">* indicated geom_rendering bits.</span>
 <span class="s0">*/ 2 4 this 3 3821  14 geom_rendering 1 3593  </span>
<span class="s0">132 0 0 6 170 3593 0 0 0 0 </span>
<span class="s0">133 0 0 7 172 3816 0 0 0 0 </span>
<span class="s0">134 0 0 7 175 3607 0 0 70 /**</span>
 <span class="s0">* Constructs a TexMatrixAttrib that applies no stages at all.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">135 0 0 23 175 3607 0 0 210 /**</span>
 <span class="s0">* Constructs a TexMatrixAttrib that applies the indicated matrix to the</span>
 <span class="s0">* default texture stage.  This interface is deprecated.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use the constructor that takes a TextureStage instead.</span>
 <span class="s0">*/ 1 3 mat 1 3800  </span>
<span class="s0">136 0 0 23 175 3607 0 0 107 /**</span>
 <span class="s0">* Constructs a TexMatrixAttrib that applies the indicated transform to the</span>
 <span class="s0">* named texture stage.</span>
 <span class="s0">*/ 2 5 stage 1 3753  9 transform 1 3794  </span>
<span class="s0">137 0 0 7 176 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">138 0 0 7 177 3607 0 0 174 /**</span>
 <span class="s0">* Returns a new TexMatrixAttrib just like this one, with the indicated</span>
 <span class="s0">* transform for the given stage.  If this stage already exists, its transform</span>
 <span class="s0">* is replaced.</span>
 <span class="s0">*/ 4 4 this 3 3823  5 stage 1 3753  9 transform 1 3794  8 override 5 3593  </span>
<span class="s0">139 0 0 7 178 3607 0 0 97 /**</span>
 <span class="s0">* Returns a new TexMatrixAttrib just like this one, with the indicated stage</span>
 <span class="s0">* removed.</span>
 <span class="s0">*/ 2 4 this 3 3823  5 stage 1 3753  </span>
<span class="s0">140 0 0 6 179 3600 0 0 101 /**</span>
 <span class="s0">* Returns true if no stages are defined in the TexMatrixAttrib, false if at</span>
 <span class="s0">* least one is.</span>
 <span class="s0">*/ 1 4 this 3 3823  </span>
<span class="s0">141 0 0 6 180 3600 0 0 182 /**</span>
 <span class="s0">* Returns true if there is a transform associated with the indicated stage,</span>
 <span class="s0">* or false otherwise (in which case get_transform(stage) will return the</span>
 <span class="s0">* identity transform).</span>
 <span class="s0">*/ 2 4 this 3 3823  5 stage 1 3753  </span>
<span class="s0">142 0 0 6 181 3593 0 0 76 /**</span>
 <span class="s0">* Returns the number of stages that are represented by this attrib.</span>
 <span class="s0">*/ 1 4 this 3 3823  </span>
<span class="s0">143 0 0 7 182 3753 0 0 118 /**</span>
 <span class="s0">* Returns the nth stage that is represented by this attrib.  The</span>
 <span class="s0">* TextureStages are in no particular order.</span>
 <span class="s0">*/ 2 4 this 3 3823  1 n 1 3593  </span>
<span class="s0">144 0 0 6 184 3800 0 0 90 /**</span>
 <span class="s0">* Returns the transformation matrix associated with the default texture</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/ 1 4 this 3 3823  </span>
<span class="s0">145 0 0 6 184 3800 0 0 165 /**</span>
 <span class="s0">* Returns the transformation matrix associated with the indicated texture</span>
 <span class="s0">* stage, or identity matrix if nothing is associated with the indicated</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/ 2 4 this 3 3823  5 stage 1 3753  </span>
<span class="s0">146 0 0 7 185 3794 0 0 155 /**</span>
 <span class="s0">* Returns the transformation associated with the indicated texture stage, or</span>
 <span class="s0">* identity matrix if nothing is associated with the indicated stage.</span>
 <span class="s0">*/ 2 4 this 3 3823  5 stage 1 3753  </span>
<span class="s0">147 0 0 6 186 3593 0 0 74 /**</span>
 <span class="s0">* Returns the override value associated with the indicated stage.</span>
 <span class="s0">*/ 2 4 this 3 3823  5 stage 1 3753  </span>
<span class="s0">148 0 0 6 187 3593 0 0 185 /**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this TexMatrixAttrib is applied to a geom which includes the indicated</span>
 <span class="s0">* geom_rendering bits.</span>
 <span class="s0">*/ 2 4 this 3 3823  14 geom_rendering 1 3593  </span>
<span class="s0">149 0 0 6 188 3593 0 0 0 0 </span>
<span class="s0">150 0 0 7 190 3816 0 0 0 0 </span>
<span class="s0">151 0 0 6 192 3593 0 0 365 /**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique RenderStates, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not needed outside of the RenderState class because all</span>
 <span class="s0">* equivalent RenderState objects are guaranteed to share the same pointer;</span>
 <span class="s0">* thus, a pointer comparison is always sufficient.</span>
 <span class="s0">*/ 2 4 this 3 3825  5 other 1 3825  </span>
<span class="s0">152 0 0 6 193 3593 0 0 333 /**</span>
 <span class="s0">* Returns -1, 0, or 1 according to the relative sorting of these two</span>
 <span class="s0">* RenderStates, with regards to rendering performance, so that &quot;heavier&quot;</span>
 <span class="s0">* RenderAttribs (as defined by RenderAttribRegistry::get_slot_sort()) are</span>
 <span class="s0">* more likely to be grouped together.  This is not related to the sorting</span>
 <span class="s0">* order defined by compare_to.</span>
 <span class="s0">*/ 2 4 this 3 3825  5 other 1 3825  </span>
<span class="s0">153 0 0 6 194 3593 0 0 191 /**</span>
 <span class="s0">* This version of compare_to takes a slot mask that indicates which</span>
 <span class="s0">* attributes to include in the comparison.  Unlike compare_to, this method</span>
 <span class="s0">* compares the attributes by pointer.</span>
 <span class="s0">*/ 3 4 this 3 3825  5 other 1 3825  12 compare_mask 1 3827  </span>
<span class="s0">154 0 0 6 195 3796 0 0 55 /**</span>
 <span class="s0">* Returns a suitable hash value for phash_map.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">155 0 0 6 196 3600 0 0 63 /**</span>
 <span class="s0">* Returns true if the state is empty, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">156 0 0 6 197 3600 0 0 121 /**</span>
 <span class="s0">* Returns true if any of the RenderAttribs in this state request a</span>
 <span class="s0">* cull_callback(), false if none of them do.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">157 0 0 6 198 3600 0 0 183 /**</span>
 <span class="s0">* Calls cull_callback() on each attrib.  If any attrib returns false,</span>
 <span class="s0">* interrupts the list and returns false immediately; otherwise, completes the</span>
 <span class="s0">* list and returns true.</span>
 <span class="s0">*/ 3 4 this 3 3825  4 trav 1 3830  4 data 1 3831  </span>
<span class="s0">158 0 0 7 199 3825 0 0 56 /**</span>
 <span class="s0">* Returns a RenderState with no attributes set.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">159 0 0 23 200 3825 0 0 58 /**</span>
 <span class="s0">* Returns a RenderState with five attributes set.</span>
 <span class="s0">*/ 6 7 attrib1 1 3607  7 attrib2 1 3607  7 attrib3 1 3607  7 attrib4 1 3607  7 attrib5 1 3607  8 override 5 3593  </span>
<span class="s0">160 0 0 23 200 3825 0 0 58 /**</span>
 <span class="s0">* Returns a RenderState with four attributes set.</span>
 <span class="s0">*/ 5 7 attrib1 1 3607  7 attrib2 1 3607  7 attrib3 1 3607  7 attrib4 1 3607  8 override 5 3593  </span>
<span class="s0">161 0 0 23 200 3825 0 0 59 /**</span>
 <span class="s0">* Returns a RenderState with three attributes set.</span>
 <span class="s0">*/ 4 7 attrib1 1 3607  7 attrib2 1 3607  7 attrib3 1 3607  8 override 5 3593  </span>
<span class="s0">162 0 0 23 200 3825 0 0 57 /**</span>
 <span class="s0">* Returns a RenderState with two attributes set.</span>
 <span class="s0">*/ 3 7 attrib1 1 3607  7 attrib2 1 3607  8 override 5 3593  </span>
<span class="s0">163 0 0 23 200 3825 0 0 56 /**</span>
 <span class="s0">* Returns a RenderState with one attribute set.</span>
 <span class="s0">*/ 2 6 attrib 1 3607  8 override 5 3593  </span>
<span class="s0">164 0 0 7 201 3825 0 0 399 /**</span>
 <span class="s0">* Returns a new RenderState object that represents the composition of this</span>
 <span class="s0">* state with the other state.</span>
 <span class="s0">*</span>
 <span class="s0">* The result of this operation is cached, and will be retained as long as</span>
 <span class="s0">* both this RenderState object and the other RenderState object continue to</span>
 <span class="s0">* exist.  Should one of them destruct, the cached entry will be removed, and</span>
 <span class="s0">* its pointer will be allowed to destruct as well.</span>
 <span class="s0">*/ 2 4 this 3 3825  5 other 1 3825  </span>
<span class="s0">165 0 0 7 202 3825 0 0 265 /**</span>
 <span class="s0">* Returns a new RenderState object that represents the composition of this</span>
 <span class="s0">* state's inverse with the other state.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to compose(), but is particularly useful for computing the</span>
 <span class="s0">* relative state of a node as viewed from some other node.</span>
 <span class="s0">*/ 2 4 this 3 3825  5 other 1 3825  </span>
<span class="s0">166 0 0 7 203 3825 0 0 231 /**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the new RenderAttrib added.  If there is already a RenderAttrib</span>
 <span class="s0">* with the same type, it is replaced (unless the override is lower).</span>
 <span class="s0">*/ 3 4 this 3 3825  6 attrib 1 3607  8 override 5 3593  </span>
<span class="s0">167 0 0 7 204 3825 0 0 249 /**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the new RenderAttrib added.  If there is already a RenderAttrib</span>
 <span class="s0">* with the same type, it is replaced unconditionally.  The override is not</span>
 <span class="s0">* changed.</span>
 <span class="s0">*/ 2 4 this 3 3825  6 attrib 1 3607  </span>
<span class="s0">168 0 0 7 204 3825 0 0 267 /**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the new RenderAttrib added.  If there is already a RenderAttrib</span>
 <span class="s0">* with the same type, it is replaced unconditionally.  The override is also</span>
 <span class="s0">* replaced unconditionally.</span>
 <span class="s0">*/ 3 4 this 3 3825  6 attrib 1 3607  8 override 1 3593  </span>
<span class="s0">169 0 0 7 205 3825 0 0 133 /**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the indicated RenderAttrib removed.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 type 1 3816  </span>
<span class="s0">170 0 0 7 205 3825 0 0 133 /**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with the indicated RenderAttrib removed.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 slot 1 3593  </span>
<span class="s0">171 0 0 7 206 3825 0 0 261 /**</span>
 <span class="s0">* Returns a new RenderState object that represents the same as the source</span>
 <span class="s0">* state, with all attributes' override values incremented (or decremented, if</span>
 <span class="s0">* negative) by the indicated amount.  If the override would drop below zero,</span>
 <span class="s0">* it is set to zero.</span>
 <span class="s0">*/ 2 4 this 3 3825  10 adjustment 1 3593  </span>
<span class="s0">172 0 0 6 207 3600 0 0 90 /**</span>
 <span class="s0">* Returns true if an attrib of the indicated type is present, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 type 1 3816  </span>
<span class="s0">173 0 0 6 207 3600 0 0 90 /**</span>
 <span class="s0">* Returns true if an attrib of the indicated type is present, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 slot 1 3593  </span>
<span class="s0">174 0 0 7 208 3607 0 0 127 /**</span>
 <span class="s0">* Looks for a RenderAttrib of the indicated type in the state, and returns it</span>
 <span class="s0">* if it is found, or NULL if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 type 1 3816  </span>
<span class="s0">175 0 0 7 208 3607 0 0 124 /**</span>
 <span class="s0">* Returns the RenderAttrib with the indicated slot index, or NULL if there is</span>
 <span class="s0">* no such RenderAttrib in the state.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 slot 1 3593  </span>
<span class="s0">176 0 0 7 209 3607 0 0 152 /**</span>
 <span class="s0">* Returns the RenderAttrib with the indicated slot index, or the default</span>
 <span class="s0">* attrib for that slot if there is no such RenderAttrib in the state.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 slot 1 3593  </span>
<span class="s0">177 0 0 6 210 3593 0 0 140 /**</span>
 <span class="s0">* Looks for a RenderAttrib of the indicated type in the state, and returns</span>
 <span class="s0">* its override value if it is found, or 0 if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 type 1 3816  </span>
<span class="s0">178 0 0 6 210 3593 0 0 140 /**</span>
 <span class="s0">* Looks for a RenderAttrib of the indicated type in the state, and returns</span>
 <span class="s0">* its override value if it is found, or 0 if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3825  4 slot 1 3593  </span>
<span class="s0">179 0 0 7 214 3825 0 0 328 /**</span>
 <span class="s0">* Returns the pointer to the unique RenderState in the cache that is</span>
 <span class="s0">* equivalent to this one.  This may be the same pointer as this object, or it</span>
 <span class="s0">* may be a different pointer; but it will be an equivalent object, and it</span>
 <span class="s0">* will be a shared pointer.  This may be called from time to time to improve</span>
 <span class="s0">* cache benefits.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">180 0 0 4 215 3812 0 0 64 /**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">181 0 0 6 216 3600 0 0 64 /**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">182 0 0 4 217 3812 0 0 64 /**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">183 0 0 6 218 3600 0 0 64 /**</span>
 <span class="s0">* Overrides this method to update PStats appropriately.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">184 0 0 6 219 3796 0 0 272 /**</span>
 <span class="s0">* Returns the number of entries in the composition cache for this</span>
 <span class="s0">* RenderState.  This is the number of other RenderStates whose composition</span>
 <span class="s0">* with this one has been cached.  This number is not useful for any practical</span>
 <span class="s0">* reason other than performance analysis.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">185 0 0 6 220 3796 0 0 253 /**</span>
 <span class="s0">* Returns the number of entries in the invert_composition cache for this</span>
 <span class="s0">* RenderState.  This is similar to the composition cache, but it records</span>
 <span class="s0">* cache entries for the invert_compose() operation.  See</span>
 <span class="s0">* get_composition_cache_num_entries().</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">186 0 0 6 221 3796 0 0 330 /**</span>
 <span class="s0">* Returns the number of slots in the composition cache for this RenderState.</span>
 <span class="s0">* You may use this as an upper bound when walking through all of the</span>
 <span class="s0">* composition cache results via get_composition_cache_source() or result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">187 0 0 7 222 3825 0 0 298 /**</span>
 <span class="s0">* Returns the source RenderState of the nth element in the composition cache.</span>
 <span class="s0">* Returns NULL if there doesn't happen to be an entry in the nth element.</span>
 <span class="s0">* See get_composition_cache_result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 2 4 this 3 3825  1 n 1 3796  </span>
<span class="s0">188 0 0 7 223 3825 0 0 366 /**</span>
 <span class="s0">* Returns the result RenderState of the nth element in the composition cache.</span>
 <span class="s0">* Returns NULL if there doesn't happen to be an entry in the nth element.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a-&gt;compose(a-&gt;get_composition_cache_source(n)) ==</span>
 <span class="s0">* a-&gt;get_composition_cache_result(n).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 2 4 this 3 3825  1 n 1 3796  </span>
<span class="s0">189 0 0 6 224 3796 0 0 340 /**</span>
 <span class="s0">* Returns the number of slots in the composition cache for this RenderState.</span>
 <span class="s0">* You may use this as an upper bound when walking through all of the</span>
 <span class="s0">* composition cache results via get_invert_composition_cache_source() or</span>
 <span class="s0">* result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">190 0 0 7 225 3825 0 0 314 /**</span>
 <span class="s0">* Returns the source RenderState of the nth element in the invert composition</span>
 <span class="s0">* cache.  Returns NULL if there doesn't happen to be an entry in the nth</span>
 <span class="s0">* element.  See get_invert_composition_cache_result().</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 2 4 this 3 3825  1 n 1 3796  </span>
<span class="s0">191 0 0 7 226 3825 0 0 398 /**</span>
 <span class="s0">* Returns the result RenderState of the nth element in the invert composition</span>
 <span class="s0">* cache.  Returns NULL if there doesn't happen to be an entry in the nth</span>
 <span class="s0">* element.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a-&gt;invert_compose(a-&gt;get_invert_composition_cache_source(n)) ==</span>
 <span class="s0">* a-&gt;get_invert_composition_cache_result(n).</span>
 <span class="s0">*</span>
 <span class="s0">* This has no practical value other than for examining the cache for</span>
 <span class="s0">* performance analysis.</span>
 <span class="s0">*/ 2 4 this 3 3825  1 n 1 3796  </span>
<span class="s0">192 0 0 38 227 3623 0 0 0 1 4 this 3 3825  </span>
<span class="s0">193 0 0 38 228 3623 0 0 0 1 4 this 3 3825  </span>
<span class="s0">194 0 0 4 229 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3825  3 out 1 3813  </span>
<span class="s0">195 0 0 4 230 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3825  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">196 0 0 6 231 3593 0 0 297 /**</span>
 <span class="s0">* Returns the maximum priority number (sometimes called override) that may be</span>
 <span class="s0">* set on any node.  This may or may not be enforced, but the scene graph code</span>
 <span class="s0">* assumes that no priority numbers will be larger than this, and some effects</span>
 <span class="s0">* may not work properly if you use a larger number.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">197 0 0 6 232 3593 0 0 144 /**</span>
 <span class="s0">* Returns the total number of unique RenderState objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">198 0 0 6 233 3593 0 0 596 /**</span>
 <span class="s0">* Returns the total number of RenderState objects that have been allocated</span>
 <span class="s0">* but have no references outside of the internal RenderState cache.</span>
 <span class="s0">*</span>
 <span class="s0">* A nonzero return value is not necessarily indicative of leaked references;</span>
 <span class="s0">* it is normal for two RenderState objects, both of which have references</span>
 <span class="s0">* held outside the cache, to have to result of their composition stored</span>
 <span class="s0">* within the cache.  This result will be retained within the cache until one</span>
 <span class="s0">* of the base RenderStates is released.</span>
 <span class="s0">*</span>
 <span class="s0">* Use list_cycles() to get an idea of the number of actual &quot;leaked&quot;</span>
 <span class="s0">* RenderState objects.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">199 0 0 6 234 3593 0 0 593 /**</span>
 <span class="s0">* Empties the cache of composed RenderStates.  This makes every RenderState</span>
 <span class="s0">* forget what results when it is composed with other RenderStates.</span>
 <span class="s0">*</span>
 <span class="s0">* This will eliminate any RenderState objects that have been allocated but</span>
 <span class="s0">* have no references outside of the internal RenderState map.  It will not</span>
 <span class="s0">* eliminate RenderState objects that are still in use.</span>
 <span class="s0">*</span>
 <span class="s0">* Nowadays, this method should not be necessary, as reference-count cycles in</span>
 <span class="s0">* the composition cache should be automatically detected and broken.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the number of RenderStates freed by this operation.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">200 0 0 4 235 3812 0 0 146 /**</span>
 <span class="s0">* Completely empties the cache of state + gsg -&gt; munger, for all states and</span>
 <span class="s0">* all gsg's.  Normally there is no need to empty this cache.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">201 0 0 6 236 3593 0 0 366 /**</span>
 <span class="s0">* Performs a garbage-collection cycle.  This must be called periodically if</span>
 <span class="s0">* garbage-collect-states is true to ensure that RenderStates get cleaned up</span>
 <span class="s0">* appropriately.  It does no harm to call it even if this variable is not</span>
 <span class="s0">* true, but there is probably no advantage in that case.</span>
 <span class="s0">*</span>
 <span class="s0">* This automatically calls RenderAttrib::garbage_collect() as well.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">202 0 0 4 237 3812 0 0 565 /**</span>
 <span class="s0">* Detects all of the reference-count cycles in the cache and reports them to</span>
 <span class="s0">* standard output.</span>
 <span class="s0">*</span>
 <span class="s0">* These cycles may be inadvertently created when state compositions cycle</span>
 <span class="s0">* back to a starting point.  Nowadays, these cycles should be automatically</span>
 <span class="s0">* detected and broken, so this method should never list any cycles unless</span>
 <span class="s0">* there is a bug in that detection logic.</span>
 <span class="s0">*</span>
 <span class="s0">* The cycles listed here are not leaks in the strictest sense of the word,</span>
 <span class="s0">* since they can be reclaimed by a call to clear_cache(); but they will not</span>
 <span class="s0">* be reclaimed automatically.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">203 0 0 4 238 3812 0 0 169 /**</span>
 <span class="s0">* Lists all of the RenderStates in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">204 0 0 6 239 3600 0 0 279 /**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order, and that none of</span>
 <span class="s0">* the cache elements have been inadvertently deleted.  Returns true if so,</span>
 <span class="s0">* false if there is a problem (which implies someone has modified one of the</span>
 <span class="s0">* supposedly-const RenderState objects).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">205 0 0 38 240 3623 0 0 0 0 </span>
<span class="s0">206 0 0 38 241 3623 0 0 0 0 </span>
<span class="s0">207 0 0 6 242 3593 0 0 160 /**</span>
 <span class="s0">* Returns the draw order indicated by the CullBinAttrib, if any, associated</span>
 <span class="s0">* by this state (or 0 if there is no CullBinAttrib).  See get_bin_index().</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">208 0 0 6 243 3593 0 0 246 /**</span>
 <span class="s0">* Returns the bin index indicated by the CullBinAttrib, if any, associated by</span>
 <span class="s0">* this state (or the default bin index if there is no CullBinAttrib).  This</span>
 <span class="s0">* function is provided as an optimization for determining this at render</span>
 <span class="s0">* time.</span>
 <span class="s0">*/ 1 4 this 3 3825  </span>
<span class="s0">209 0 0 6 244 3593 0 0 181 /**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this RenderState is applied to a geom which includes the indicated</span>
 <span class="s0">* geom_rendering bits.</span>
 <span class="s0">*/ 2 4 this 3 3825  14 geom_rendering 1 3593  </span>
<span class="s0">210 0 0 7 245 3816 0 0 0 0 </span>
<span class="s0">211 0 0 23 247 3607 0 0 51 /**</span>
 <span class="s0">* Constructs a new AlphaTestAttrib object.</span>
 <span class="s0">*/ 2 4 mode 1 3594  15 reference_alpha 1 3598  </span>
<span class="s0">212 0 0 7 248 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">213 0 0 6 249 3598 0 0 45 /**</span>
 <span class="s0">* Returns the alpha reference value.</span>
 <span class="s0">*/ 1 4 this 3 3833  </span>
<span class="s0">214 0 0 6 250 3594 0 0 40 /**</span>
 <span class="s0">* Returns the alpha write mode.</span>
 <span class="s0">*/ 1 4 this 3 3833  </span>
<span class="s0">215 0 0 6 253 3593 0 0 0 0 </span>
<span class="s0">216 0 0 7 255 3816 0 0 0 0 </span>
<span class="s0">217 0 0 23 259 3607 0 0 1313 /**</span>
 <span class="s0">* Constructs a new AntialiasAttrib object.</span>
 <span class="s0">*</span>
 <span class="s0">* The mode should be either M_none, M_auto, or a union of any or all of</span>
 <span class="s0">* M_point, M_line, M_polygon, and M_multisample.  Also, in addition to the</span>
 <span class="s0">* above choices, it may include either of M_better of M_faster to specify a</span>
 <span class="s0">* performance/quality tradeoff hint.</span>
 <span class="s0">*</span>
 <span class="s0">* If M_none is specified, no antialiasing is performed.</span>
 <span class="s0">*</span>
 <span class="s0">* If M_multisample is specified, it means to use the special framebuffer</span>
 <span class="s0">* multisample bits for antialiasing, if it is available.  If so, the M_point,</span>
 <span class="s0">* M_line, and M_polygon modes are ignored.  This advanced antialiasing mode</span>
 <span class="s0">* is only available on certain graphics hardware.  If it is not available,</span>
 <span class="s0">* the M_multisample bit is ignored (and the other modes may be used instead,</span>
 <span class="s0">* if specified).</span>
 <span class="s0">*</span>
 <span class="s0">* M_point, M_line, and/or M_polygon specify per-primitive smoothing.  When</span>
 <span class="s0">* enabled, M_point and M_line may force transparency on.  M_polygon requires</span>
 <span class="s0">* a frame buffer that includes an alpha channel, and it works best if the</span>
 <span class="s0">* primitives are sorted front-to-back.</span>
 <span class="s0">*</span>
 <span class="s0">* If M_auto is specified, M_multisample is selected if it is available,</span>
 <span class="s0">* otherwise M_polygon is selected, unless drawing lines or points, in which</span>
 <span class="s0">* case M_line or M_point is selected (these two generally produce better</span>
 <span class="s0">* results than M_multisample)</span>
 <span class="s0">*/ 1 4 mode 1 3612  </span>
<span class="s0">218 0 0 7 260 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">219 0 0 6 261 3612 0 0 48 /**</span>
 <span class="s0">* Returns the specified antialias mode.</span>
 <span class="s0">*/ 1 4 this 3 3835  </span>
<span class="s0">220 0 0 6 262 3612 0 0 200 /**</span>
 <span class="s0">* Returns the specified antialias mode, with the quality bits masked out.</span>
 <span class="s0">* This therefore indicates only the requested type of antialiasing: M_none,</span>
 <span class="s0">* M_auto, or some specific combination.</span>
 <span class="s0">*/ 1 4 this 3 3835  </span>
<span class="s0">221 0 0 6 263 3612 0 0 211 /**</span>
 <span class="s0">* Returns the specified antialias mode, with the type bits masked out.  This</span>
 <span class="s0">* therefore indicates only the requested quality settings: one of M_faster,</span>
 <span class="s0">* M_better, M_dont_care, or zero (unspecified).</span>
 <span class="s0">*/ 1 4 this 3 3835  </span>
<span class="s0">222 0 0 6 268 3593 0 0 0 0 </span>
<span class="s0">223 0 0 7 270 3816 0 0 0 0 </span>
<span class="s0">224 0 0 6 273 3593 0 0 368 /**</span>
 <span class="s0">* Provides an arbitrary ordering among all unique RenderEffects, so we can</span>
 <span class="s0">* store the essentially different ones in a big set and throw away the rest.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not needed outside of the RenderEffect class because all</span>
 <span class="s0">* equivalent RenderEffect objects are guaranteed to share the same pointer;</span>
 <span class="s0">* thus, a pointer comparison is always sufficient.</span>
 <span class="s0">*/ 2 4 this 3 3837  5 other 1 3837  </span>
<span class="s0">225 0 0 4 274 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3837  3 out 1 3813  </span>
<span class="s0">226 0 0 4 275 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3837  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">227 0 0 6 276 3593 0 0 145 /**</span>
 <span class="s0">* Returns the total number of unique RenderEffect objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">228 0 0 4 277 3812 0 0 170 /**</span>
 <span class="s0">* Lists all of the RenderEffects in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">229 0 0 6 278 3600 0 0 208 /**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order.  Returns true if</span>
 <span class="s0">* so, false if there is a problem (which implies someone has modified one of</span>
 <span class="s0">* the supposedly-const RenderEffect objects).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">230 0 0 7 279 3816 0 0 0 0 </span>
<span class="s0">231 0 0 6 281 3600 0 0 0 2 4 this 3 3839  5 other 1 3839  </span>
<span class="s0">232 0 0 6 282 3600 0 0 63 /**</span>
 <span class="s0">* Returns true if the state is empty, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3839  </span>
<span class="s0">233 0 0 6 283 3796 0 0 151 /**</span>
 <span class="s0">* Returns the number of separate effects indicated in the state.</span>
 <span class="s0">* @deprecated in Python, use len(effects) instead, or effects.size() in C++.</span>
 <span class="s0">*/ 1 4 this 3 3839  </span>
<span class="s0">234 0 0 7 284 3837 0 0 127 /**</span>
 <span class="s0">* Looks for a RenderEffect of the indicated type in the state, and returns it</span>
 <span class="s0">* if it is found, or NULL if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3839  4 type 1 3816  </span>
<span class="s0">235 0 0 7 284 3837 0 0 47 /**</span>
 <span class="s0">* Returns the nth effect in the state.</span>
 <span class="s0">*/ 2 4 this 3 3839  1 n 1 3796  </span>
<span class="s0">236 0 0 6 285 3796 0 0 73 /**</span>
 <span class="s0">* Returns the number of separate effects indicated in the state.</span>
 <span class="s0">*/ 1 4 this 3 3839  </span>
<span class="s0">237 0 0 7 286 3837 0 0 63 /**</span>
 <span class="s0">* Returns the effect in the state with the given type.</span>
 <span class="s0">*/ 2 4 this 3 3839  4 type 1 3816  </span>
<span class="s0">238 0 0 7 286 3837 0 0 47 /**</span>
 <span class="s0">* Returns the nth effect in the state.</span>
 <span class="s0">*/ 2 4 this 3 3839  1 n 1 3796  </span>
<span class="s0">239 0 0 6 287 3593 0 0 132 /**</span>
 <span class="s0">* Searches for an effect with the indicated type in the state, and returns</span>
 <span class="s0">* its index if it is found, or -1 if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3839  4 type 1 3816  </span>
<span class="s0">240 0 0 7 288 3839 0 0 55 /**</span>
 <span class="s0">* Returns a RenderEffects with no effects set.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">241 0 0 23 289 3839 0 0 55 /**</span>
 <span class="s0">* Returns a RenderEffects with one effect set.</span>
 <span class="s0">*/ 1 6 effect 1 3837  </span>
<span class="s0">242 0 0 23 289 3839 0 0 56 /**</span>
 <span class="s0">* Returns a RenderEffects with two effects set.</span>
 <span class="s0">*/ 2 7 effect1 1 3837  7 effect2 1 3837  </span>
<span class="s0">243 0 0 23 289 3839 0 0 58 /**</span>
 <span class="s0">* Returns a RenderEffects with three effects set.</span>
 <span class="s0">*/ 3 7 effect1 1 3837  7 effect2 1 3837  7 effect3 1 3837  </span>
<span class="s0">244 0 0 23 289 3839 0 0 57 /**</span>
 <span class="s0">* Returns a RenderEffects with four effects set.</span>
 <span class="s0">*/ 4 7 effect1 1 3837  7 effect2 1 3837  7 effect3 1 3837  7 effect4 1 3837  </span>
<span class="s0">245 0 0 7 290 3839 0 0 202 /**</span>
 <span class="s0">* Returns a new RenderEffects object that represents the same as the source</span>
 <span class="s0">* state, with the new RenderEffect added.  If there is already a RenderEffect</span>
 <span class="s0">* with the same type, it is replaced.</span>
 <span class="s0">*/ 2 4 this 3 3839  6 effect 1 3837  </span>
<span class="s0">246 0 0 7 291 3839 0 0 135 /**</span>
 <span class="s0">* Returns a new RenderEffects object that represents the same as the source</span>
 <span class="s0">* state, with the indicated RenderEffect removed.</span>
 <span class="s0">*/ 2 4 this 3 3839  4 type 1 3816  </span>
<span class="s0">247 0 0 4 292 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3839  3 out 1 3813  </span>
<span class="s0">248 0 0 4 293 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3839  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">249 0 0 6 294 3593 0 0 146 /**</span>
 <span class="s0">* Returns the total number of unique RenderEffects objects allocated in the</span>
 <span class="s0">* world.  This will go up and down during normal operations.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">250 0 0 4 295 3812 0 0 170 /**</span>
 <span class="s0">* Lists all of the RenderEffects in the cache to the output stream, one per</span>
 <span class="s0">* line.  This can be quite a lot of output if the cache is large, so be</span>
 <span class="s0">* prepared.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">251 0 0 6 296 3600 0 0 209 /**</span>
 <span class="s0">* Ensures that the cache is still stored in sorted order.  Returns true if</span>
 <span class="s0">* so, false if there is a problem (which implies someone has modified one of</span>
 <span class="s0">* the supposedly-const RenderEffects objects).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">252 0 0 7 297 3816 0 0 0 0 </span>
<span class="s0">253 0 0 7 307 3650 2131 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3841  </span>
<span class="s0">254 0 0 7 309 3650 2131 0 475 /**</span>
 <span class="s0">* Collapses this PandaNode with the other PandaNode, if possible, and returns</span>
 <span class="s0">* a pointer to the combined PandaNode, or NULL if the two PandaNodes cannot</span>
 <span class="s0">* safely be combined.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value may be this, other, or a new PandaNode altogether.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is called from GraphReducer::flatten(), and need not deal</span>
 <span class="s0">* with children; its job is just to decide whether to collapse the two</span>
 <span class="s0">* PandaNodes and what the collapsed PandaNode should look like.</span>
 <span class="s0">*/ 2 4 this 3 3650  5 other 1 3650  </span>
<span class="s0">255 0 0 7 310 3650 2131 0 234 /**</span>
 <span class="s0">* Returns a newly-allocated PandaNode that is a shallow copy of this one.  It</span>
 <span class="s0">* will be a different pointer, but its internal data may or may not be shared</span>
 <span class="s0">* with that of the original PandaNode.  No children will be copied.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">256 0 0 7 311 3650 2131 0 264 /**</span>
 <span class="s0">* Allocates and returns a complete copy of this PandaNode and the entire</span>
 <span class="s0">* scene graph rooted at this PandaNode.  Some data may still be shared from</span>
 <span class="s0">* the original (e.g.  vertex index tables), but nothing that will impede</span>
 <span class="s0">* normal use of the PandaNode.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">257 0 0 39 312 3650 2131 0 0 1 4 this 3 3842  </span>
<span class="s0">258 0 0 38 313 3623 0 0 0 2 4 this 3 3842  4 memo 1 3623  </span>
<span class="s0">259 0 0 6 314 3593 0 0 264 /**</span>
 <span class="s0">* Returns the number of parent nodes this node has.  If this number is</span>
 <span class="s0">* greater than 1, the node has been multiply instanced.  The order of the</span>
 <span class="s0">* parent nodes is not meaningful and is not related to the order in which the</span>
 <span class="s0">* node was instanced to them.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">260 0 0 7 315 3650 2131 0 219 /**</span>
 <span class="s0">* Returns the nth parent node of this node.  See get_num_parents().  Also see</span>
 <span class="s0">* get_parents(), if your intention is to iterate through the complete list of</span>
 <span class="s0">* parents; get_parents() is preferable in this case.</span>
 <span class="s0">*/ 3 4 this 3 3842  1 n 1 3593  14 current_thread 5 3844  </span>
<span class="s0">261 0 0 6 316 3593 0 0 100 /**</span>
 <span class="s0">* Returns the index of the indicated parent node, if it is a parent, or -1 if</span>
 <span class="s0">* it is not.</span>
 <span class="s0">*/ 3 4 this 3 3842  4 node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">262 0 0 6 318 3593 0 0 228 /**</span>
 <span class="s0">* Returns the number of child nodes this node has.  The order of the child</span>
 <span class="s0">* nodes *is* meaningful and is based on the sort number that was passed to</span>
 <span class="s0">* add_child(), and also on the order in which the nodes were added.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">263 0 0 7 319 3650 2131 0 222 /**</span>
 <span class="s0">* Returns the nth child node of this node.  See get_num_children().  Also see</span>
 <span class="s0">* get_children(), if your intention is to iterate through the complete list</span>
 <span class="s0">* of children; get_children() is preferable in this case.</span>
 <span class="s0">*/ 3 4 this 3 3842  1 n 1 3593  14 current_thread 5 3844  </span>
<span class="s0">264 0 0 6 320 3593 0 0 150 /**</span>
 <span class="s0">* Returns the sort index of the nth child node of this node (that is, the</span>
 <span class="s0">* number that was passed to add_child()).  See get_num_children().</span>
 <span class="s0">*/ 3 4 this 3 3842  1 n 1 3593  14 current_thread 5 3844  </span>
<span class="s0">265 0 0 6 321 3593 0 0 98 /**</span>
 <span class="s0">* Returns the index of the indicated child node, if it is a child, or -1 if</span>
 <span class="s0">* it is not.</span>
 <span class="s0">*/ 3 4 this 3 3842  4 node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">266 0 0 6 323 3593 0 0 63 /**</span>
 <span class="s0">* Returns the number of nodes at and below this level.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">267 0 0 4 324 3812 0 0 285 /**</span>
 <span class="s0">* Adds a new child to the node.  The child is added in the relative position</span>
 <span class="s0">* indicated by sort; if all children have the same sort index, the child is</span>
 <span class="s0">* added at the end.</span>
 <span class="s0">*</span>
 <span class="s0">* If the same child is added to a node more than once, the previous instance</span>
 <span class="s0">* is first removed.</span>
 <span class="s0">*/ 4 4 this 3 3650  10 child_node 1 3650  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">268 0 0 6 325 3600 0 0 218 /**</span>
 <span class="s0">* Removes the indicated child from the node.  Returns true if the child was</span>
 <span class="s0">* removed, false if it was not already a child of the node.  This will also</span>
 <span class="s0">* successfully remove the child if it had been stashed.</span>
 <span class="s0">*/ 3 4 this 3 3650  10 child_node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">269 0 0 4 325 3812 0 0 47 /**</span>
 <span class="s0">* Removes the nth child from the node.</span>
 <span class="s0">*/ 3 4 this 3 3650  11 child_index 1 3593  14 current_thread 5 3844  </span>
<span class="s0">270 0 0 6 326 3600 0 0 241 /**</span>
 <span class="s0">* Searches for the orig_child node in the node's list of children, and</span>
 <span class="s0">* replaces it with the new_child instead.  Returns true if the replacement is</span>
 <span class="s0">* made, or false if the node is not a child or if there is some other</span>
 <span class="s0">* problem.</span>
 <span class="s0">*/ 4 4 this 3 3650  10 orig_child 1 3650  9 new_child 1 3650  14 current_thread 5 3844  </span>
<span class="s0">271 0 0 6 327 3600 0 0 560 /**</span>
 <span class="s0">* Stashes the indicated child node.  This removes the child from the list of</span>
 <span class="s0">* active children and puts it on a special list of stashed children.  This</span>
 <span class="s0">* child node no longer contributes to the bounding volume of the PandaNode,</span>
 <span class="s0">* and is not visited in normal traversals.  It is invisible and uncollidable.</span>
 <span class="s0">* The child may later be restored by calling unstash_child().</span>
 <span class="s0">*</span>
 <span class="s0">* This function returns true if the child node was successfully stashed, or</span>
 <span class="s0">* false if it was not a child of the node in the first place (e.g.  it was</span>
 <span class="s0">* previously stashed).</span>
 <span class="s0">*/ 3 4 this 3 3650  10 child_node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">272 0 0 4 327 3812 0 0 456 /**</span>
 <span class="s0">* Stashes the indicated child node.  This removes the child from the list of</span>
 <span class="s0">* active children and puts it on a special list of stashed children.  This</span>
 <span class="s0">* child node no longer contributes to the bounding volume of the PandaNode,</span>
 <span class="s0">* and is not visited in normal traversals.  It is invisible and uncollidable.</span>
 <span class="s0">* The child may later be restored by calling unstash_child().</span>
 <span class="s0">*</span>
 <span class="s0">* This can only be called from the top pipeline stage (i.e.  from App).</span>
 <span class="s0">*/ 3 4 this 3 3650  11 child_index 1 3593  14 current_thread 5 3844  </span>
<span class="s0">273 0 0 6 328 3600 0 0 524 /**</span>
 <span class="s0">* Returns the indicated stashed node to normal child status.  This removes</span>
 <span class="s0">* the child from the list of stashed children and puts it on the normal list</span>
 <span class="s0">* of active children.  This child node once again contributes to the bounding</span>
 <span class="s0">* volume of the PandaNode, and will be visited in normal traversals.  It is</span>
 <span class="s0">* visible and collidable.</span>
 <span class="s0">*</span>
 <span class="s0">* This function returns true if the child node was successfully stashed, or</span>
 <span class="s0">* false if it was not a child of the node in the first place (e.g.  it was</span>
 <span class="s0">* previously stashed).</span>
 <span class="s0">*/ 3 4 this 3 3650  10 child_node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">274 0 0 4 328 3812 0 0 420 /**</span>
 <span class="s0">* Returns the indicated stashed node to normal child status.  This removes</span>
 <span class="s0">* the child from the list of stashed children and puts it on the normal list</span>
 <span class="s0">* of active children.  This child node once again contributes to the bounding</span>
 <span class="s0">* volume of the PandaNode, and will be visited in normal traversals.  It is</span>
 <span class="s0">* visible and collidable.</span>
 <span class="s0">*</span>
 <span class="s0">* This can only be called from the top pipeline stage (i.e.  from App).</span>
 <span class="s0">*/ 3 4 this 3 3650  13 stashed_index 1 3593  14 current_thread 5 3844  </span>
<span class="s0">275 0 0 6 329 3593 0 0 174 /**</span>
 <span class="s0">* Returns the number of stashed nodes this node has.  These are former</span>
 <span class="s0">* children of the node that have been moved to the special stashed list via</span>
 <span class="s0">* stash_child().</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">276 0 0 7 330 3846 2250 0 624 /**</span>
 <span class="s0">* Returns an object that can be used to walk through the list of children of</span>
 <span class="s0">* the node.  When you intend to visit multiple children, using this is</span>
 <span class="s0">* slightly faster than calling get_stashed() directly on the PandaNode, since</span>
 <span class="s0">* this object avoids reopening the PipelineCycler each time.</span>
 <span class="s0">*</span>
 <span class="s0">* This object also protects you from self-modifying loops (e.g.  adding or</span>
 <span class="s0">* removing children during traversal), since a virtual copy of the children</span>
 <span class="s0">* is made ahead of time.  The virtual copy is fast--it is a form of copy-on-</span>
 <span class="s0">* write, so the list is not actually copied unless it is modified during the</span>
 <span class="s0">* traversal.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">277 0 0 7 330 3650 2131 0 230 /**</span>
 <span class="s0">* Returns the nth stashed child of this node.  See get_num_stashed().  Also</span>
 <span class="s0">* see get_stashed(), if your intention is to iterate through the complete</span>
 <span class="s0">* list of stashed children; get_stashed() is preferable in this case.</span>
 <span class="s0">*/ 3 4 this 3 3842  1 n 1 3593  14 current_thread 5 3844  </span>
<span class="s0">278 0 0 6 331 3593 0 0 151 /**</span>
 <span class="s0">* Returns the sort index of the nth stashed node of this node (that is, the</span>
 <span class="s0">* number that was passed to add_child()).  See get_num_stashed().</span>
 <span class="s0">*/ 3 4 this 3 3842  1 n 1 3593  14 current_thread 5 3844  </span>
<span class="s0">279 0 0 6 332 3593 0 0 108 /**</span>
 <span class="s0">* Returns the index of the indicated stashed node, if it is a stashed child,</span>
 <span class="s0">* or -1 if it is not.</span>
 <span class="s0">*/ 3 4 this 3 3842  4 node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">280 0 0 4 334 3812 0 0 361 /**</span>
 <span class="s0">* Adds a new child to the node, directly as a stashed child.  The child is</span>
 <span class="s0">* not added in the normal sense, but will be revealed if unstash_child() is</span>
 <span class="s0">* called on it later.</span>
 <span class="s0">*</span>
 <span class="s0">* If the same child is added to a node more than once, the previous instance</span>
 <span class="s0">* is first removed.</span>
 <span class="s0">*</span>
 <span class="s0">* This can only be called from the top pipeline stage (i.e.  from App).</span>
 <span class="s0">*/ 4 4 this 3 3650  10 child_node 1 3650  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">281 0 0 4 335 3812 0 0 55 /**</span>
 <span class="s0">* Removes the nth stashed child from the node.</span>
 <span class="s0">*/ 3 4 this 3 3650  11 child_index 1 3593  14 current_thread 5 3844  </span>
<span class="s0">282 0 0 4 336 3812 0 0 162 /**</span>
 <span class="s0">* Removes all the children from the node at once, including stashed children.</span>
 <span class="s0">*</span>
 <span class="s0">* This can only be called from the top pipeline stage (i.e.  from App).</span>
 <span class="s0">*/ 2 4 this 3 3650  14 current_thread 5 3844  </span>
<span class="s0">283 0 0 4 337 3812 0 0 177 /**</span>
 <span class="s0">* Moves all the children from the other node onto this node.</span>
 <span class="s0">*</span>
 <span class="s0">* Any NodePaths to child nodes of the other node are truncated, rather than</span>
 <span class="s0">* moved to the new parent.</span>
 <span class="s0">*/ 3 4 this 3 3650  5 other 1 3650  14 current_thread 5 3844  </span>
<span class="s0">284 0 0 4 338 3812 0 0 102 /**</span>
 <span class="s0">* Makes another instance of all the children of the other node, copying them</span>
 <span class="s0">* to this node.</span>
 <span class="s0">*/ 3 4 this 3 3650  5 other 1 3650  14 current_thread 5 3844  </span>
<span class="s0">285 0 0 4 339 3812 0 0 220 /**</span>
 <span class="s0">* Adds the indicated render attribute to the scene graph on this node.  This</span>
 <span class="s0">* attribute will now apply to this node and everything below.  If there was</span>
 <span class="s0">* already an attribute of the same type, it is replaced.</span>
 <span class="s0">*/ 3 4 this 3 3650  6 attrib 1 3607  8 override 5 3593  </span>
<span class="s0">286 0 0 7 340 3607 0 0 270 /**</span>
 <span class="s0">* Returns the render attribute of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.  This checks only what is set on this</span>
 <span class="s0">* particular node level, and has nothing to do with what render attributes</span>
 <span class="s0">* may be inherited from parent nodes.</span>
 <span class="s0">*/ 2 4 this 3 3842  4 type 1 3816  </span>
<span class="s0">287 0 0 7 340 3607 0 0 270 /**</span>
 <span class="s0">* Returns the render attribute of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.  This checks only what is set on this</span>
 <span class="s0">* particular node level, and has nothing to do with what render attributes</span>
 <span class="s0">* may be inherited from parent nodes.</span>
 <span class="s0">*/ 2 4 this 3 3842  4 slot 1 3593  </span>
<span class="s0">288 0 0 6 341 3600 0 0 127 /**</span>
 <span class="s0">* Returns true if there is a render attribute of the indicated type defined</span>
 <span class="s0">* on this node, or false if there is not.</span>
 <span class="s0">*/ 2 4 this 3 3842  4 type 1 3816  </span>
<span class="s0">289 0 0 6 341 3600 0 0 127 /**</span>
 <span class="s0">* Returns true if there is a render attribute of the indicated type defined</span>
 <span class="s0">* on this node, or false if there is not.</span>
 <span class="s0">*/ 2 4 this 3 3842  4 slot 1 3593  </span>
<span class="s0">290 0 0 4 342 3812 0 0 194 /**</span>
 <span class="s0">* Removes the render attribute of the given type from this node.  This node,</span>
 <span class="s0">* and the subgraph below, will now inherit the indicated render attribute</span>
 <span class="s0">* from the nodes above this one.</span>
 <span class="s0">*/ 2 4 this 3 3650  4 type 1 3816  </span>
<span class="s0">291 0 0 4 342 3812 0 0 194 /**</span>
 <span class="s0">* Removes the render attribute of the given type from this node.  This node,</span>
 <span class="s0">* and the subgraph below, will now inherit the indicated render attribute</span>
 <span class="s0">* from the nodes above this one.</span>
 <span class="s0">*/ 2 4 this 3 3650  4 slot 1 3593  </span>
<span class="s0">292 0 0 4 343 3812 0 0 145 /**</span>
 <span class="s0">* Adds the indicated render effect to the scene graph on this node.  If there</span>
 <span class="s0">* was already an effect of the same type, it is replaced.</span>
 <span class="s0">*/ 2 4 this 3 3650  6 effect 1 3837  </span>
<span class="s0">293 0 0 7 344 3837 0 0 114 /**</span>
 <span class="s0">* Returns the render effect of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3842  4 type 1 3816  </span>
<span class="s0">294 0 0 6 345 3600 0 0 124 /**</span>
 <span class="s0">* Returns true if there is a render effect of the indicated type defined on</span>
 <span class="s0">* this node, or false if there is not.</span>
 <span class="s0">*/ 2 4 this 3 3842  4 type 1 3816  </span>
<span class="s0">295 0 0 4 346 3812 0 0 70 /**</span>
 <span class="s0">* Removes the render effect of the given type from this node.</span>
 <span class="s0">*/ 2 4 this 3 3650  4 type 1 3816  </span>
<span class="s0">296 0 0 4 347 3812 0 0 337 /**</span>
 <span class="s0">* Sets the complete RenderState that will be applied to all nodes at this</span>
 <span class="s0">* level and below.  (The actual state that will be applied to lower nodes is</span>
 <span class="s0">* based on the composition of RenderStates from above this node as well).</span>
 <span class="s0">* This completely replaces whatever has been set on this node via repeated</span>
 <span class="s0">* calls to set_attrib().</span>
 <span class="s0">*/ 3 4 this 3 3650  5 state 1 3825  14 current_thread 5 3844  </span>
<span class="s0">297 0 0 7 348 3825 0 0 265 /**</span>
 <span class="s0">* Returns the complete RenderState that will be applied to all nodes at this</span>
 <span class="s0">* level and below, as set on this node.  This returns only the RenderState</span>
 <span class="s0">* set on this particular node, and has nothing to do with state that might be</span>
 <span class="s0">* inherited from above.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">298 0 0 4 349 3812 0 0 183 /**</span>
 <span class="s0">* Resets this node to leave the render state alone.  Nodes at this level and</span>
 <span class="s0">* below will once again inherit their render state unchanged from the nodes</span>
 <span class="s0">* above this level.</span>
 <span class="s0">*/ 2 4 this 3 3650  14 current_thread 5 3844  </span>
<span class="s0">299 0 0 4 352 3812 0 0 177 /**</span>
 <span class="s0">* Sets the complete RenderEffects that will be applied this node.  This</span>
 <span class="s0">* completely replaces whatever has been set on this node via repeated calls</span>
 <span class="s0">* to set_attrib().</span>
 <span class="s0">*/ 3 4 this 3 3650  7 effects 1 3839  14 current_thread 5 3844  </span>
<span class="s0">300 0 0 7 353 3839 0 0 80 /**</span>
 <span class="s0">* Returns the complete RenderEffects that will be applied to this node.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">301 0 0 4 354 3812 0 0 54 /**</span>
 <span class="s0">* Resets this node to have no render effects.</span>
 <span class="s0">*/ 2 4 this 3 3650  14 current_thread 5 3844  </span>
<span class="s0">302 0 0 4 357 3812 0 0 158 /**</span>
 <span class="s0">* Sets the transform that will be applied to this node and below.  This</span>
 <span class="s0">* defines a new coordinate space at this point in the scene graph and below.</span>
 <span class="s0">*/ 3 4 this 3 3650  9 transform 1 3794  14 current_thread 5 3844  </span>
<span class="s0">303 0 0 7 358 3794 0 0 177 /**</span>
 <span class="s0">* Returns the transform that has been set on this particular node.  This is</span>
 <span class="s0">* not the net transform from the root, but simply the transform on this</span>
 <span class="s0">* particular node.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">304 0 0 4 359 3812 0 0 71 /**</span>
 <span class="s0">* Resets the transform on this node to the identity transform.</span>
 <span class="s0">*/ 2 4 this 3 3650  14 current_thread 5 3844  </span>
<span class="s0">305 0 0 4 362 3812 0 0 173 /**</span>
 <span class="s0">* Sets the transform that represents this node's &quot;previous&quot; position, one</span>
 <span class="s0">* frame ago, for the purposes of detecting motion for accurate collision</span>
 <span class="s0">* calculations.</span>
 <span class="s0">*/ 3 4 this 3 3650  9 transform 1 3794  14 current_thread 5 3844  </span>
<span class="s0">306 0 0 7 363 3794 0 0 115 /**</span>
 <span class="s0">* Returns the transform that has been set as this node's &quot;previous&quot; position.</span>
 <span class="s0">* See set_prev_transform().</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">307 0 0 4 364 3812 0 0 179 /**</span>
 <span class="s0">* Resets the transform that represents this node's &quot;previous&quot; position to the</span>
 <span class="s0">* same as the current transform.  This is not the same thing as clearing it</span>
 <span class="s0">* to identity.</span>
 <span class="s0">*/ 2 4 this 3 3650  14 current_thread 5 3844  </span>
<span class="s0">308 0 0 6 365 3600 0 0 250 /**</span>
 <span class="s0">* Returns true if this node has the _dirty_prev_transform flag set, which</span>
 <span class="s0">* indicates its _prev_transform is different from its _transform value (in</span>
 <span class="s0">* pipeline stage 0).  In this case, the node will be visited by</span>
 <span class="s0">* reset_prev_transform().</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">309 0 0 4 366 3812 0 0 242 /**</span>
 <span class="s0">* Visits all nodes in the world with the _dirty_prev_transform flag--that is,</span>
 <span class="s0">* all nodes whose _prev_transform is different from the _transform in</span>
 <span class="s0">* pipeline stage 0--and resets the _prev_transform to be the same as</span>
 <span class="s0">* _transform.</span>
 <span class="s0">*/ 1 14 current_thread 5 3844  </span>
<span class="s0">310 0 0 4 368 3812 0 0 391 /**</span>
 <span class="s0">* Associates a user-defined value with a user-defined key which is stored on</span>
 <span class="s0">* the node.  This value has no meaning to Panda; but it is stored</span>
 <span class="s0">* indefinitely on the node until it is requested again.</span>
 <span class="s0">*</span>
 <span class="s0">* Each unique key stores a different string value.  There is no effective</span>
 <span class="s0">* limit on the number of different keys that may be stored or on the length</span>
 <span class="s0">* of any one key's value.</span>
 <span class="s0">*/ 4 4 this 3 3650  3 key 1 3841  5 value 1 3841  14 current_thread 5 3844  </span>
<span class="s0">311 0 0 6 369 3841 0 0 182 /**</span>
 <span class="s0">* Retrieves the user-defined value that was previously set on this node for</span>
 <span class="s0">* the particular key, if any.  If no value has been previously set, returns</span>
 <span class="s0">* the empty string.</span>
 <span class="s0">*/ 3 4 this 3 3842  3 key 1 3841  14 current_thread 5 3844  </span>
<span class="s0">312 0 0 6 370 3600 0 0 170 /**</span>
 <span class="s0">* Returns true if a value has been defined on this node for the particular</span>
 <span class="s0">* key (even if that value is the empty string), or false if no value has been</span>
 <span class="s0">* set.</span>
 <span class="s0">*/ 3 4 this 3 3842  3 key 1 3841  14 current_thread 5 3844  </span>
<span class="s0">313 0 0 4 371 3812 0 0 158 /**</span>
 <span class="s0">* Removes the value defined for this key on this particular node.  After a</span>
 <span class="s0">* call to clear_tag(), has_tag() will return false for the indicated key.</span>
 <span class="s0">*/ 3 4 this 3 3650  3 key 1 3841  14 current_thread 5 3844  </span>
<span class="s0">314 0 0 38 377 3623 0 0 0 1 4 this 3 3842  </span>
<span class="s0">315 0 0 38 378 3623 0 0 0 1 4 this 3 3650  </span>
<span class="s0">316 0 0 36 379 3812 0 0 0 3 4 this 3 3650  3 key 1 3623  5 value 1 3623  </span>
<span class="s0">317 0 0 38 380 3623 0 0 0 2 4 this 3 3842  3 key 1 3623  </span>
<span class="s0">318 0 0 38 381 3600 0 0 0 2 4 this 3 3842  3 key 1 3623  </span>
<span class="s0">319 0 0 36 382 3812 0 0 0 2 4 this 3 3650  3 key 1 3623  </span>
<span class="s0">320 0 0 38 383 3623 0 0 0 1 4 this 3 3842  </span>
<span class="s0">321 0 0 38 388 3593 0 0 0 3 4 this 3 3650  5 visit 1 3847  3 arg 1 3848  </span>
<span class="s0">322 0 0 6 389 3600 0 0 102 /**</span>
 <span class="s0">* Returns true if the node has any tags (or any Python tags) at all, false if</span>
 <span class="s0">* it has none.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">323 0 0 4 390 3812 0 0 191 /**</span>
 <span class="s0">* Copies all of the tags stored on the other node onto this node.  If a</span>
 <span class="s0">* particular tag exists on both nodes, the contents of this node's value is</span>
 <span class="s0">* replaced by that of the other.</span>
 <span class="s0">*/ 2 4 this 3 3650  5 other 1 3650  </span>
<span class="s0">324 0 0 4 391 3812 0 0 364 /**</span>
 <span class="s0">* Writes a list of all the tag keys assigned to the node to the indicated</span>
 <span class="s0">* stream.  Writes one instance of the separator following each key (but does</span>
 <span class="s0">* not write a terminal separator).  The value associated with each key is not</span>
 <span class="s0">* written.</span>
 <span class="s0">*</span>
 <span class="s0">* This is mainly for the benefit of the realtime user, to see the list of all</span>
 <span class="s0">* of the associated tag keys.</span>
 <span class="s0">*/ 3 4 this 3 3842  3 out 1 3813  9 separator 5 3841  </span>
<span class="s0">325 0 0 6 392 3593 0 0 341 /**</span>
 <span class="s0">* Returns a number less than 0, 0, or greater than 0, to indicate the</span>
 <span class="s0">* similarity of tags between this node and the other one.  If this returns 0,</span>
 <span class="s0">* the tags are identical.  If it returns other than 0, then the tags are</span>
 <span class="s0">* different; and the nodes may be sorted into a consistent (but arbitrary)</span>
 <span class="s0">* ordering based on this number.</span>
 <span class="s0">*/ 2 4 this 3 3842  5 other 1 3842  </span>
<span class="s0">326 0 0 4 393 3812 0 0 264 /**</span>
 <span class="s0">* Copies the TransformState, RenderState, RenderEffects, tags, Python tags,</span>
 <span class="s0">* and the show/hide state from the other node onto this one.  Typically this</span>
 <span class="s0">* is used to prepare a node to replace another node in the scene graph (also</span>
 <span class="s0">* see replace_node()).</span>
 <span class="s0">*/ 2 4 this 3 3650  5 other 1 3650  </span>
<span class="s0">327 0 0 4 394 3812 0 0 602 /**</span>
 <span class="s0">* Inserts this node into the scene graph in place of the other one, and</span>
 <span class="s0">* removes the other node.  All scene graph attributes (TransformState,</span>
 <span class="s0">* RenderState, etc.) are copied to this node.</span>
 <span class="s0">*</span>
 <span class="s0">* All children are moved to this node, and removed from the old node.  The</span>
 <span class="s0">* new node is left in the same place in the old node's parent's list of</span>
 <span class="s0">* children.</span>
 <span class="s0">*</span>
 <span class="s0">* Even NodePaths that reference the old node are updated in-place to</span>
 <span class="s0">* reference the new node instead.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended to be used to replace a node of a given type in the</span>
 <span class="s0">* scene graph with a node of a different type.</span>
 <span class="s0">*/ 2 4 this 3 3650  5 other 1 3650  </span>
<span class="s0">328 0 0 4 396 3812 0 0 627 /**</span>
 <span class="s0">* Sets one or more of the PandaNode::UnexpectedChange bits on, indicating</span>
 <span class="s0">* that the corresponding property should not change again on this node.  Once</span>
 <span class="s0">* one of these bits has been set, if the property changes, an assertion</span>
 <span class="s0">* failure will be raised, which is designed to assist the developer in</span>
 <span class="s0">* identifying the troublesome code that modified the property unexpectedly.</span>
 <span class="s0">*</span>
 <span class="s0">* The input parameter is the union of bits that are to be set.  To clear</span>
 <span class="s0">* these bits later, use clear_unexpected_change().</span>
 <span class="s0">*</span>
 <span class="s0">* Since this is a developer debugging tool only, this function does nothing</span>
 <span class="s0">* in a production (NDEBUG) build.</span>
 <span class="s0">*/ 2 4 this 3 3650  5 flags 1 3692  </span>
<span class="s0">329 0 0 6 397 3692 0 0 409 /**</span>
 <span class="s0">* Returns nonzero if any of the bits in the input parameter are set on this</span>
 <span class="s0">* node, or zero if none of them are set.  More specifically, this returns the</span>
 <span class="s0">* particular set of bits (masked by the input parameter) that have been set</span>
 <span class="s0">* on this node.  See set_unexpected_change().</span>
 <span class="s0">*</span>
 <span class="s0">* Since this is a developer debugging tool only, this function always returns</span>
 <span class="s0">* zero in a production (NDEBUG) build.</span>
 <span class="s0">*/ 2 4 this 3 3842  5 flags 1 3692  </span>
<span class="s0">330 0 0 4 398 3812 0 0 373 /**</span>
 <span class="s0">* Sets one or more of the PandaNode::UnexpectedChange bits off, indicating</span>
 <span class="s0">* that the corresponding property may once again change on this node.  See</span>
 <span class="s0">* set_unexpected_change().</span>
 <span class="s0">*</span>
 <span class="s0">* The input parameter is the union of bits that are to be cleared.</span>
 <span class="s0">*</span>
 <span class="s0">* Since this is a developer debugging tool only, this function does nothing</span>
 <span class="s0">* in a production (NDEBUG) build.</span>
 <span class="s0">*/ 2 4 this 3 3650  5 flags 1 3692  </span>
<span class="s0">331 0 0 7 399 3849 0 0 189 /**</span>
 <span class="s0">* Returns the special bit that, when specifically cleared in the node's</span>
 <span class="s0">* DrawMask, indicates that the node is hidden to all cameras, regardless of</span>
 <span class="s0">* the remaining DrawMask bits.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">332 0 0 7 400 3849 0 0 79 /**</span>
 <span class="s0">* Returns a DrawMask that is appropriate for rendering to all cameras.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">333 0 0 6 401 3600 0 0 98 /**</span>
 <span class="s0">* Returns true if the node has been hidden to all cameras by clearing its</span>
 <span class="s0">* overall bit.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">334 0 0 4 402 3812 0 0 411 /**</span>
 <span class="s0">* Sets or clears the hidden flag.  When the hidden flag is true, the node and</span>
 <span class="s0">* all of its children are invisible to all cameras, regardless of the setting</span>
 <span class="s0">* of any draw masks.  Setting the hidden flag to false restores the previous</span>
 <span class="s0">* visibility as established by the draw masks.</span>
 <span class="s0">*</span>
 <span class="s0">* This actually works by twiddling the reserved _overall_bit in the node's</span>
 <span class="s0">* draw mask, which has special meaning.</span>
 <span class="s0">*/ 2 4 this 3 3650  14 overall_hidden 1 3600  </span>
<span class="s0">335 0 0 4 409 3812 0 0 1343 /**</span>
 <span class="s0">* Adjusts the hide/show bits of this particular node.</span>
 <span class="s0">*</span>
 <span class="s0">* These three parameters can be used to adjust the _draw_control_mask and</span>
 <span class="s0">* _draw_show_mask independently, which work together to provide per-camera</span>
 <span class="s0">* visibility for the node and its descendents.</span>
 <span class="s0">*</span>
 <span class="s0">* _draw_control_mask indicates the bits in _draw_show_mask that are</span>
 <span class="s0">* significant.  Each different bit corresponds to a different camera (and</span>
 <span class="s0">* these bits are assigned via Camera::set_camera_mask()).</span>
 <span class="s0">*</span>
 <span class="s0">* Where _draw_control_mask has a 1 bit, a 1 bit in _draw_show_mask indicates</span>
 <span class="s0">* the node is visible to that camera, and a 0 bit indicates the node is</span>
 <span class="s0">* hidden to that camera.  Where _draw_control_mask is 0, the node is hidden</span>
 <span class="s0">* only if a parent node is hidden.</span>
 <span class="s0">*</span>
 <span class="s0">* The meaning of the three parameters is as follows:</span>
 <span class="s0">*</span>
 <span class="s0">* * Wherever show_mask is 1, _draw_show_mask and _draw_control_mask will be</span>
 <span class="s0">* set 1.  Thus, show_mask indicates the set of cameras to which the node</span>
 <span class="s0">* should be shown.</span>
 <span class="s0">*</span>
 <span class="s0">* * Wherever hide_mask is 1, _draw_show_mask will be set 0 and</span>
 <span class="s0">* _draw_control_mask will be set 1.  Thus, hide_mask indicates the set of</span>
 <span class="s0">* cameras from which the node should be hidden.</span>
 <span class="s0">*</span>
 <span class="s0">* * Wherever clear_mask is 1, _draw_control_mask will be set 0.  Thus,</span>
 <span class="s0">* clear_mask indicates the set of cameras from which the hidden state should</span>
 <span class="s0">* be inherited from a parent.</span>
 <span class="s0">*/ 4 4 this 3 3650  9 show_mask 1 3849  9 hide_mask 1 3849  10 clear_mask 1 3849  </span>
<span class="s0">336 0 0 7 410 3849 0 0 111 /**</span>
 <span class="s0">* Returns the set of bits in draw_show_mask that are considered meaningful.</span>
 <span class="s0">* See adjust_draw_mask().</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">337 0 0 7 411 3849 0 0 90 /**</span>
 <span class="s0">* Returns the hide/show bits of this particular node.  See</span>
 <span class="s0">* adjust_draw_mask().</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">338 0 0 7 414 3849 0 0 366 /**</span>
 <span class="s0">* Returns the set of bits in get_net_draw_show_mask() that have been</span>
 <span class="s0">* explicitly set via adjust_draw_mask(), rather than implicitly inherited.</span>
 <span class="s0">*</span>
 <span class="s0">* A 1 bit in any position of this mask indicates that (a) this node has</span>
 <span class="s0">* renderable children, and (b) some child of this node has made an explicit</span>
 <span class="s0">* hide() or show_through() call for the corresponding bit.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">339 0 0 7 415 3849 0 0 576 /**</span>
 <span class="s0">* Returns the union of all draw_show_mask values--of renderable nodes only--</span>
 <span class="s0">* at this level and below.  If any bit in this mask is 0, there is no reason</span>
 <span class="s0">* to traverse below this node for a camera with the corresponding</span>
 <span class="s0">* camera_mask.</span>
 <span class="s0">*</span>
 <span class="s0">* The bits in this mask that do not correspond to a 1 bit in the</span>
 <span class="s0">* net_draw_control_mask are meaningless (and will be set to 1).  For bits</span>
 <span class="s0">* that *do* correspond to a 1 bit in the net_draw_control_mask, a 1 bit</span>
 <span class="s0">* indicates that at least one child should be visible, while a 0 bit</span>
 <span class="s0">* indicates that all children are hidden.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">340 0 0 4 416 3812 0 0 510 /**</span>
 <span class="s0">* Sets the &quot;into&quot; CollideMask.</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies the set of bits that must be shared with a CollisionNode's</span>
 <span class="s0">* &quot;from&quot; CollideMask in order for the CollisionNode to detect a collision</span>
 <span class="s0">* with this particular node.</span>
 <span class="s0">*</span>
 <span class="s0">* The actual CollideMask that will be set is masked by the return value from</span>
 <span class="s0">* get_legal_collide_mask(). Thus, the into_collide_mask cannot be set to</span>
 <span class="s0">* anything other than nonzero except for those types of nodes that can be</span>
 <span class="s0">* collided into, such as CollisionNodes and GeomNodes.</span>
 <span class="s0">*/ 2 4 this 3 3650  4 mask 1 3850  </span>
<span class="s0">341 0 0 7 417 3850 0 0 57 /**</span>
 <span class="s0">* Returns the &quot;into&quot; collide mask for this node.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">342 0 0 7 418 3850 0 0 314 /**</span>
 <span class="s0">* Returns the subset of CollideMask bits that may be set for this particular</span>
 <span class="s0">* type of PandaNode.  For most nodes, this is 0; it doesn't make sense to set</span>
 <span class="s0">* a CollideMask for most kinds of nodes.</span>
 <span class="s0">*</span>
 <span class="s0">* For nodes that can be collided with, such as GeomNode and CollisionNode,</span>
 <span class="s0">* this returns all bits on.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">343 0 0 7 422 3850 0 0 112 /**</span>
 <span class="s0">* Returns the union of all into_collide_mask() values set at CollisionNodes</span>
 <span class="s0">* at this level and below.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">344 0 0 7 423 3607 0 0 145 /**</span>
 <span class="s0">* Returns a ClipPlaneAttrib which represents the union of all of the clip</span>
 <span class="s0">* planes that have been turned *off* at this level and below.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">345 0 0 4 424 3812 0 0 470 /**</span>
 <span class="s0">* Walks through the scene graph beginning at this node, and does whatever</span>
 <span class="s0">* initialization is required to render the scene properly with the indicated</span>
 <span class="s0">* GSG.  It is not strictly necessary to call this, since the GSG will</span>
 <span class="s0">* initialize itself when the scene is rendered, but this may take some of the</span>
 <span class="s0">* overhead away from that process.</span>
 <span class="s0">*</span>
 <span class="s0">* In particular, this will ensure that textures and vertex buffers within the</span>
 <span class="s0">* scene are loaded into graphics memory.</span>
 <span class="s0">*/ 3 4 this 3 3650  3 gsg 1 3851  10 node_state 1 3825  </span>
<span class="s0">346 0 0 6 425 3600 0 0 173 /**</span>
 <span class="s0">* Returns true if this particular node is known to be the render root of some</span>
 <span class="s0">* active DisplayRegion associated with the global GraphicsEngine, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">347 0 0 6 426 3600 0 0 305 /**</span>
 <span class="s0">* Returns true if this particular node is in a live scene graph: that is, it</span>
 <span class="s0">* is a child or descendent of a node that is itself a scene root.  If this is</span>
 <span class="s0">* true, this node may potentially be traversed by the render traverser.</span>
 <span class="s0">* Stashed nodes don't count for this purpose, but hidden nodes do.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">348 0 0 4 427 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3842  3 out 1 3813  </span>
<span class="s0">349 0 0 4 428 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3842  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">350 0 0 4 429 3812 0 0 76 /**</span>
 <span class="s0">* Lists all the nodes at and below the current path hierarchically.</span>
 <span class="s0">*/ 3 4 this 3 3842  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">351 0 0 4 430 3812 0 0 650 /**</span>
 <span class="s0">* Specifies the desired type of bounding volume that will be created for this</span>
 <span class="s0">* node.  This is normally BoundingVolume::BT_default, which means to set the</span>
 <span class="s0">* type according to the config variable &quot;bounds-type&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is BT_sphere or BT_box, a BoundingSphere or BoundingBox is</span>
 <span class="s0">* explicitly created.  If it is BT_best, the appropriate type to best enclose</span>
 <span class="s0">* the node's children is created.</span>
 <span class="s0">*</span>
 <span class="s0">* This affects the bounding volume returned by get_bounds(), which is not</span>
 <span class="s0">* exactly the same bounding volume modified by set_bounds(), because a new</span>
 <span class="s0">* bounding volume has to be created that includes this node and all of its</span>
 <span class="s0">* children.</span>
 <span class="s0">*/ 2 4 this 3 3650  11 bounds_type 1 3631  </span>
<span class="s0">352 0 0 6 431 3631 0 0 71 /**</span>
 <span class="s0">* Returns the bounding volume type set with set_bounds_type().</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">353 0 0 4 435 3812 0 0 478 /**</span>
 <span class="s0">* Resets the bounding volume so that it is the indicated volume.  When it is</span>
 <span class="s0">* explicitly set, the bounding volume will no longer be automatically</span>
 <span class="s0">* computed according to the contents of the node itself, for nodes like</span>
 <span class="s0">* GeomNodes and TextNodes that contain substance (but the bounding volume</span>
 <span class="s0">* will still be automatically expanded to include its children).</span>
 <span class="s0">*</span>
 <span class="s0">* Call clear_bounds() if you would like to return the bounding volume to its</span>
 <span class="s0">* default behavior later.</span>
 <span class="s0">*/ 2 4 this 3 3650  6 volume 1 3853  </span>
<span class="s0">354 0 0 4 436 3812 0 0 48 /**</span>
 <span class="s0">* @deprecated Use set_bounds() instead.</span>
 <span class="s0">*/ 2 4 this 3 3650  6 volume 1 3853  </span>
<span class="s0">355 0 0 4 437 3812 0 0 184 /**</span>
 <span class="s0">* Reverses the effect of a previous call to set_bounds(), and allows the</span>
 <span class="s0">* node's bounding volume to be automatically computed once more based on the</span>
 <span class="s0">* contents of the node.</span>
 <span class="s0">*/ 1 4 this 3 3650  </span>
<span class="s0">356 0 0 7 438 3853 0 0 199 /**</span>
 <span class="s0">* Returns the external bounding volume of this node: a bounding volume that</span>
 <span class="s0">* contains the user bounding volume, the internal bounding volume, and all of</span>
 <span class="s0">* the children's bounding volumes.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">357 0 0 7 438 3853 0 0 589 /**</span>
 <span class="s0">* This flavor of get_bounds() return the external bounding volume, and also</span>
 <span class="s0">* fills in seq with the bounding volume's current sequence number.  When this</span>
 <span class="s0">* sequence number changes, it indicates that the bounding volume might have</span>
 <span class="s0">* changed, e.g.  because some nested child's bounding volume has changed.</span>
 <span class="s0">*</span>
 <span class="s0">* Although this might occasionally increment without changing the bounding</span>
 <span class="s0">* volume, the bounding volume will never change without incrementing this</span>
 <span class="s0">* counter, so as long as this counter remains unchanged you can be confident</span>
 <span class="s0">* the bounding volume is also unchanged.</span>
 <span class="s0">*/ 3 4 this 3 3842  3 seq 1 3855  14 current_thread 5 3844  </span>
<span class="s0">358 0 0 6 439 3593 0 0 422 /**</span>
 <span class="s0">* Returns the total number of vertices that will be rendered by this node and</span>
 <span class="s0">* all of its descendents.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not necessarily an accurate count of vertices that will actually be</span>
 <span class="s0">* rendered, since this will include all vertices of all LOD's, and it will</span>
 <span class="s0">* also include hidden nodes.  It may also omit or only approximate certain</span>
 <span class="s0">* kinds of dynamic geometry.  However, it will not include stashed nodes.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">359 0 0 7 440 3853 0 0 221 /**</span>
 <span class="s0">* Returns the node's internal bounding volume.  This is the bounding volume</span>
 <span class="s0">* around the node alone, without including children.  If the user has called</span>
 <span class="s0">* set_bounds(), it will be the specified bounding volume.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">360 0 0 6 441 3593 0 0 205 /**</span>
 <span class="s0">* Returns the total number of vertices that will be rendered by this</span>
 <span class="s0">* particular node alone, not accounting for its children.</span>
 <span class="s0">*</span>
 <span class="s0">* This may not include all vertices for certain dynamic effects.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">361 0 0 4 446 3812 0 0 547 /**</span>
 <span class="s0">* Indicates that the bounding volume, or something that influences the</span>
 <span class="s0">* bounding volume (or any of the other things stored in CData, like</span>
 <span class="s0">* net_collide_mask), may have changed for this node, and that it must be</span>
 <span class="s0">* recomputed.</span>
 <span class="s0">*</span>
 <span class="s0">* With no parameters, this means to iterate through all stages including and</span>
 <span class="s0">* upstream of the current pipeline stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended for internal use; usually it is not necessary for a</span>
 <span class="s0">* user to call this directly.  It will be called automatically by derived</span>
 <span class="s0">* classes when appropriate.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">362 0 0 4 447 3812 0 0 461 /**</span>
 <span class="s0">* Should be called by a derived class to mark the internal bounding volume</span>
 <span class="s0">* stale, so that compute_internal_bounds() will be called when the bounding</span>
 <span class="s0">* volume is next requested.</span>
 <span class="s0">*</span>
 <span class="s0">* With no parameters, this means to iterate through all stages including and</span>
 <span class="s0">* upstream of the current pipeline stage.</span>
 <span class="s0">*</span>
 <span class="s0">* It is normally not necessary to call this method directly; each node should</span>
 <span class="s0">* be responsible for calling it when its internals have changed.</span>
 <span class="s0">*/ 2 4 this 3 3650  14 current_thread 5 3844  </span>
<span class="s0">363 0 0 6 448 3600 0 0 194 /**</span>
 <span class="s0">* Returns true if the bounding volume of this node is stale and will be</span>
 <span class="s0">* implicitly recomputed at the next call to get_bounds(), or false if it is</span>
 <span class="s0">* fresh and need not be recomputed.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">364 0 0 4 450 3812 0 0 623 /**</span>
 <span class="s0">* Sets the &quot;final&quot; flag on this PandaNode.  If this is true, than no bounding</span>
 <span class="s0">* volume need be tested below it; a positive intersection with this node's</span>
 <span class="s0">* bounding volume is deemed to be a positive intersection with all geometry</span>
 <span class="s0">* inside.</span>
 <span class="s0">*</span>
 <span class="s0">* This is useful to quickly force a larger bounding volume around a node when</span>
 <span class="s0">* the GeomNodes themselves are inaccurate for some reason, without forcing a</span>
 <span class="s0">* recompute of every nested bounding volume.  It's also helpful when the</span>
 <span class="s0">* bounding volume is tricked by some special properties, like billboards,</span>
 <span class="s0">* that may move geometry out of its bounding volume otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3650  4 flag 1 3600  </span>
<span class="s0">365 0 0 6 451 3600 0 0 177 /**</span>
 <span class="s0">* Returns the current state of the &quot;final&quot; flag.  Initially, this flag is off</span>
 <span class="s0">* (false), but it may be changed by an explicit call to set_final().  See</span>
 <span class="s0">* set_final().</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">366 0 0 6 453 3600 0 0 276 /**</span>
 <span class="s0">* A simple downcast check.  Returns true if this kind of node happens to</span>
 <span class="s0">* inherit from GeomNode, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is provided as a a faster alternative to calling</span>
 <span class="s0">* is_of_type(GeomNode::get_class_type()), since this test is so important to</span>
 <span class="s0">* rendering.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">367 0 0 6 454 3600 0 0 225 /**</span>
 <span class="s0">* A simple downcast check.  Returns true if this kind of node happens to</span>
 <span class="s0">* inherit from LODNode, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is provided as a a faster alternative to calling</span>
 <span class="s0">* is_of_type(LODNode::get_class_type()).</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">368 0 0 6 455 3600 0 0 237 /**</span>
 <span class="s0">* A simple downcast check.  Returns true if this kind of node happens to</span>
 <span class="s0">* inherit from CollisionNode, false otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is provided as a a faster alternative to calling</span>
 <span class="s0">* is_of_type(CollisionNode::get_class_type()).</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">369 0 0 6 456 3857 0 0 131 /**</span>
 <span class="s0">* Cross-casts the node to a Light pointer, if it is one of the four kinds of</span>
 <span class="s0">* Light nodes, or returns NULL if it is not.</span>
 <span class="s0">*/ 1 4 this 3 3650  </span>
<span class="s0">370 0 0 6 457 3600 0 0 117 /**</span>
 <span class="s0">* Returns true if this is an AmbientLight, false if it is not a light, or it</span>
 <span class="s0">* is some other kind of light.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">371 0 0 6 459 3593 0 0 330 /**</span>
 <span class="s0">* Returns the union of all of the enum FancyBits values corresponding to the</span>
 <span class="s0">* various &quot;fancy&quot; attributes that are set on the node.  If this returns 0,</span>
 <span class="s0">* the node has nothing interesting about it.  This is intended to speed</span>
 <span class="s0">* traversal by quickly skipping past nodes that don't particularly affect the</span>
 <span class="s0">* render state.</span>
 <span class="s0">*/ 2 4 this 3 3842  14 current_thread 5 3844  </span>
<span class="s0">372 0 0 7 460 3650 2131 0 470 /**</span>
 <span class="s0">* Reads the bytes created by a previous call to encode_to_bam_stream(), and</span>
 <span class="s0">* extracts and returns the single object on those bytes.  Returns NULL on</span>
 <span class="s0">* error.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is intended to replace decode_raw_from_bam_stream() when you</span>
 <span class="s0">* know the stream in question returns an object of type PandaNode, allowing</span>
 <span class="s0">* for easier reference count management.  Note that the caller is still</span>
 <span class="s0">* responsible for maintaining the reference count on the return value.</span>
 <span class="s0">*/ 2 4 data 1 3858  6 reader 5 3661  </span>
<span class="s0">373 0 0 7 478 3816 0 0 0 0 </span>
<span class="s0">374 0 0 7 299 3860 0 0 0 1 4 this 3 3650  </span>
<span class="s0">375 0 0 6 302 3861 0 0 0 1 4 this 3 3650  </span>
<span class="s0">376 0 0 6 305 3862 0 0 0 1 4 this 3 3650  </span>
<span class="s0">377 0 0 6 372 3796 0 0 59 /**</span>
 <span class="s0">* Returns the number of tags applied to this node.</span>
 <span class="s0">*/ 1 4 this 3 3842  </span>
<span class="s0">378 0 0 6 376 3841 0 0 63 /**</span>
 <span class="s0">* Returns the key of the nth tag applied to this node.</span>
 <span class="s0">*/ 2 4 this 3 3842  1 i 1 3796  </span>
<span class="s0">379 0 0 7 462 3650 2131 0 0 2 4 this 3 3863  1 n 1 3796  </span>
<span class="s0">380 0 0 6 463 3796 0 0 0 1 4 this 3 3863  </span>
<span class="s0">381 0 0 7 466 3650 2131 0 0 2 4 this 3 3865  1 n 1 3796  </span>
<span class="s0">382 0 0 6 467 3796 0 0 0 1 4 this 3 3865  </span>
<span class="s0">383 0 0 7 470 3650 2131 0 0 2 4 this 3 3867  1 n 1 3796  </span>
<span class="s0">384 0 0 6 471 3796 0 0 0 1 4 this 3 3867  </span>
<span class="s0">385 0 0 23 481 3607 0 0 54 /**</span>
 <span class="s0">* Constructs a new TransparencyAttrib object.</span>
 <span class="s0">*/ 1 4 mode 1 3639  </span>
<span class="s0">386 0 0 7 482 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">387 0 0 6 483 3639 0 0 41 /**</span>
 <span class="s0">* Returns the transparency mode.</span>
 <span class="s0">*/ 1 4 this 3 3869  </span>
<span class="s0">388 0 0 6 485 3593 0 0 0 0 </span>
<span class="s0">389 0 0 7 487 3816 0 0 0 0 </span>
<span class="s0">390 0 0 7 491 3607 0 0 139 /**</span>
 <span class="s0">* Constructs a new LogicOpAttrib object that disables special-effect</span>
 <span class="s0">* blending, allowing normal transparency to be used instead.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">391 0 0 23 492 3607 0 0 80 /**</span>
 <span class="s0">* Constructs a new LogicOpAttrib object with the given logic operation.</span>
 <span class="s0">*/ 1 2 op 1 3641  </span>
<span class="s0">392 0 0 7 493 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">393 0 0 6 494 3641 0 0 67 /**</span>
 <span class="s0">* Returns the logic operation specified by this attribute.</span>
 <span class="s0">*/ 1 4 this 3 3871  </span>
<span class="s0">394 0 0 6 496 3593 0 0 0 0 </span>
<span class="s0">395 0 0 7 498 3816 0 0 0 0 </span>
<span class="s0">396 0 0 39 503 3876 2285 0 0 3 4 name 1 3873  5 value 1 3623  8 priority 5 3593  </span>
<span class="s0">397 0 0 7 503 3876 2285 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 name 1 3873  3 tex 1 3755  7 sampler 1 3877  8 priority 5 3593  </span>
<span class="s0">398 0 0 7 503 3876 2285 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 7 4 name 1 3873  3 tex 1 3755  4 read 1 3600  5 write 1 3600  1 z 5 3593  1 n 5 3593  8 priority 5 3593  </span>
<span class="s0">399 0 0 7 503 3876 2285 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 name 1 3873  8 priority 5 3593  </span>
<span class="s0">400 0 0 15 503 3876 2285 0 0 1 6 param0 0 3878  </span>
<span class="s0">401 0 0 6 502 3878 0 0 124 /**</span>
 <span class="s0">* Returns a static ShaderInput object with name NULL, priority zero, type</span>
 <span class="s0">* INVALID, and all value-fields cleared.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">402 0 0 6 506 3600 0 0 0 2 4 this 3 3878  5 other 1 3878  </span>
<span class="s0">403 0 0 6 507 3600 0 0 0 2 4 this 3 3878  5 other 1 3878  </span>
<span class="s0">404 0 0 6 508 3600 0 0 0 2 4 this 3 3878  5 other 1 3878  </span>
<span class="s0">405 0 0 6 509 3796 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3878  4 hash 1 3796  </span>
<span class="s0">406 0 0 7 510 3873 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3878  </span>
<span class="s0">407 0 0 6 511 3593 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3878  </span>
<span class="s0">408 0 0 6 512 3593 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3878  </span>
<span class="s0">409 0 0 6 513 3880 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3878  </span>
<span class="s0">410 0 0 6 514 3881 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3878  </span>
<span class="s0">411 0 0 6 515 3884 0 0 107 /**</span>
 <span class="s0">* Warning: no error checking is done.  This *will* crash if get_value_type()</span>
 <span class="s0">* is not M_nodepath.</span>
 <span class="s0">*/ 1 4 this 3 3878  </span>
<span class="s0">412 0 0 7 516 3755 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3878  </span>
<span class="s0">413 0 0 6 517 3877 0 0 46 /**</span>
 <span class="s0">* Warning: no error checking is done.</span>
 <span class="s0">*/ 1 4 this 3 3878  </span>
<span class="s0">414 0 0 6 505 3600 0 0 0 1 4 this 3 3878  </span>
<span class="s0">415 0 0 7 520 3885 2288 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">416 0 0 15 520 3885 2288 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3886  </span>
<span class="s0">417 0 0 6 521 3885 0 0 0 2 4 this 3 3885  4 copy 1 3886  </span>
<span class="s0">418 0 0 4 523 3812 0 0 53 /**</span>
 <span class="s0">* Adds a new InternalName to the collection.</span>
 <span class="s0">*/ 2 4 this 3 3885  4 name 1 3873  </span>
<span class="s0">419 0 0 6 524 3600 0 0 156 /**</span>
 <span class="s0">* Removes the indicated InternalName from the collection.  Returns true if</span>
 <span class="s0">* the name was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/ 2 4 this 3 3885  4 name 1 3873  </span>
<span class="s0">420 0 0 4 525 3812 0 0 207 /**</span>
 <span class="s0">* Adds all the InternalNames indicated in the other collection to this name.</span>
 <span class="s0">* The other names are simply appended to the end of the names in this list;</span>
 <span class="s0">* duplicates are not automatically removed.</span>
 <span class="s0">*/ 2 4 this 3 3885  5 other 1 3886  </span>
<span class="s0">421 0 0 4 526 3812 0 0 99 /**</span>
 <span class="s0">* Removes from this collection all of the InternalNames listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/ 2 4 this 3 3885  5 other 1 3886  </span>
<span class="s0">422 0 0 4 527 3812 0 0 204 /**</span>
 <span class="s0">* Removes any duplicate entries of the same InternalNames on this collection.</span>
 <span class="s0">* If a InternalName appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/ 1 4 this 3 3885  </span>
<span class="s0">423 0 0 6 528 3600 0 0 101 /**</span>
 <span class="s0">* Returns true if the indicated InternalName appears in this collection,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3886  4 name 1 3873  </span>
<span class="s0">424 0 0 4 529 3812 0 0 57 /**</span>
 <span class="s0">* Removes all InternalNames from the collection.</span>
 <span class="s0">*/ 1 4 this 3 3885  </span>
<span class="s0">425 0 0 6 530 3593 0 0 65 /**</span>
 <span class="s0">* Returns the number of InternalNames in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3886  </span>
<span class="s0">426 0 0 7 531 3873 0 0 58 /**</span>
 <span class="s0">* Returns the nth InternalName in the collection.</span>
 <span class="s0">*/ 2 4 this 3 3886  5 index 1 3593  </span>
<span class="s0">427 0 0 7 533 3873 0 0 144 /**</span>
 <span class="s0">* Returns the nth InternalName in the collection.  This is the same as</span>
 <span class="s0">* get_name(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/ 2 4 this 3 3886  5 index 1 3593  </span>
<span class="s0">428 0 0 6 534 3593 0 0 104 /**</span>
 <span class="s0">* Returns the number of names in the collection.  This is the same thing as</span>
 <span class="s0">* get_num_names().</span>
 <span class="s0">*/ 1 4 this 3 3886  </span>
<span class="s0">429 0 0 6 535 3885 0 0 0 2 4 this 3 3885  5 other 1 3886  </span>
<span class="s0">430 0 0 7 536 3885 2288 0 0 2 4 this 3 3886  5 other 1 3886  </span>
<span class="s0">431 0 0 4 537 3812 0 0 111 /**</span>
 <span class="s0">* Writes a brief one-line description of the InternalNameCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 3886  3 out 1 3813  </span>
<span class="s0">432 0 0 4 538 3812 0 0 116 /**</span>
 <span class="s0">* Writes a complete multi-line description of the InternalNameCollection to</span>
 <span class="s0">* the indicated output stream.</span>
 <span class="s0">*/ 3 4 this 3 3886  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">433 0 0 7 540 3888 2306 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">434 0 0 15 540 3888 2306 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3889  </span>
<span class="s0">435 0 0 6 541 3888 0 0 0 2 4 this 3 3888  4 copy 1 3889  </span>
<span class="s0">436 0 0 4 543 3812 0 0 49 /**</span>
 <span class="s0">* Adds a new Material to the collection.</span>
 <span class="s0">*/ 2 4 this 3 3888  13 node_material 1 3733  </span>
<span class="s0">437 0 0 6 544 3600 0 0 156 /**</span>
 <span class="s0">* Removes the indicated Material from the collection.  Returns true if the</span>
 <span class="s0">* material was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/ 2 4 this 3 3888  13 node_material 1 3733  </span>
<span class="s0">438 0 0 4 545 3812 0 0 215 /**</span>
 <span class="s0">* Adds all the Materials indicated in the other collection to this material.</span>
 <span class="s0">* The other materials are simply appended to the end of the materials in this</span>
 <span class="s0">* list; duplicates are not automatically removed.</span>
 <span class="s0">*/ 2 4 this 3 3888  5 other 1 3889  </span>
<span class="s0">439 0 0 4 546 3812 0 0 95 /**</span>
 <span class="s0">* Removes from this collection all of the Materials listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/ 2 4 this 3 3888  5 other 1 3889  </span>
<span class="s0">440 0 0 4 547 3812 0 0 197 /**</span>
 <span class="s0">* Removes any duplicate entries of the same Materials on this collection.  If</span>
 <span class="s0">* a Material appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/ 1 4 this 3 3888  </span>
<span class="s0">441 0 0 6 548 3600 0 0 97 /**</span>
 <span class="s0">* Returns true if the indicated Material appears in this collection, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3889  8 material 1 3733  </span>
<span class="s0">442 0 0 4 549 3812 0 0 53 /**</span>
 <span class="s0">* Removes all Materials from the collection.</span>
 <span class="s0">*/ 1 4 this 3 3888  </span>
<span class="s0">443 0 0 7 550 3733 0 0 123 /**</span>
 <span class="s0">* Returns the material in the collection with the indicated name, if any, or</span>
 <span class="s0">* NULL if no material has that name.</span>
 <span class="s0">*/ 2 4 this 3 3889  4 name 1 3841  </span>
<span class="s0">444 0 0 6 551 3593 0 0 61 /**</span>
 <span class="s0">* Returns the number of Materials in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3889  </span>
<span class="s0">445 0 0 7 552 3733 0 0 54 /**</span>
 <span class="s0">* Returns the nth Material in the collection.</span>
 <span class="s0">*/ 2 4 this 3 3889  5 index 1 3593  </span>
<span class="s0">446 0 0 7 553 3733 0 0 144 /**</span>
 <span class="s0">* Returns the nth Material in the collection.  This is the same as</span>
 <span class="s0">* get_material(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/ 2 4 this 3 3889  5 index 1 3593  </span>
<span class="s0">447 0 0 6 554 3593 0 0 112 /**</span>
 <span class="s0">* Returns the number of materials in the collection.  This is the same thing</span>
 <span class="s0">* as get_num_materials().</span>
 <span class="s0">*/ 1 4 this 3 3889  </span>
<span class="s0">448 0 0 6 555 3888 0 0 0 2 4 this 3 3888  5 other 1 3889  </span>
<span class="s0">449 0 0 7 556 3888 2306 0 0 2 4 this 3 3889  5 other 1 3889  </span>
<span class="s0">450 0 0 4 557 3812 0 0 107 /**</span>
 <span class="s0">* Writes a brief one-line description of the MaterialCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 3889  3 out 1 3813  </span>
<span class="s0">451 0 0 4 558 3812 0 0 112 /**</span>
 <span class="s0">* Writes a complete multi-line description of the MaterialCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 3 4 this 3 3889  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">452 0 0 7 560 3891 2325 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">453 0 0 15 560 3891 2325 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3892  </span>
<span class="s0">454 0 0 6 561 3891 0 0 0 2 4 this 3 3891  4 copy 1 3892  </span>
<span class="s0">455 0 0 4 563 3812 0 0 53 /**</span>
 <span class="s0">* Adds a new TextureStage to the collection.</span>
 <span class="s0">*/ 2 4 this 3 3891  18 node_texture_stage 1 3753  </span>
<span class="s0">456 0 0 6 564 3600 0 0 168 /**</span>
 <span class="s0">* Removes the indicated TextureStage from the collection.  Returns true if</span>
 <span class="s0">* the texture_stage was removed, false if it was not a member of the</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/ 2 4 this 3 3891  18 node_texture_stage 1 3753  </span>
<span class="s0">457 0 0 4 565 3812 0 0 235 /**</span>
 <span class="s0">* Adds all the TextureStages indicated in the other collection to this</span>
 <span class="s0">* texture_stage.  The other texture_stages are simply appended to the end of</span>
 <span class="s0">* the texture_stages in this list; duplicates are not automatically removed.</span>
 <span class="s0">*/ 2 4 this 3 3891  5 other 1 3892  </span>
<span class="s0">458 0 0 4 566 3812 0 0 99 /**</span>
 <span class="s0">* Removes from this collection all of the TextureStages listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/ 2 4 this 3 3891  5 other 1 3892  </span>
<span class="s0">459 0 0 4 567 3812 0 0 204 /**</span>
 <span class="s0">* Removes any duplicate entries of the same TextureStages on this collection.</span>
 <span class="s0">* If a TextureStage appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/ 1 4 this 3 3891  </span>
<span class="s0">460 0 0 6 568 3600 0 0 101 /**</span>
 <span class="s0">* Returns true if the indicated TextureStage appears in this collection,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3892  13 texture_stage 1 3753  </span>
<span class="s0">461 0 0 4 569 3812 0 0 57 /**</span>
 <span class="s0">* Removes all TextureStages from the collection.</span>
 <span class="s0">*/ 1 4 this 3 3891  </span>
<span class="s0">462 0 0 7 570 3753 0 0 133 /**</span>
 <span class="s0">* Returns the texture_stage in the collection with the indicated name, if</span>
 <span class="s0">* any, or NULL if no texture_stage has that name.</span>
 <span class="s0">*/ 2 4 this 3 3892  4 name 1 3841  </span>
<span class="s0">463 0 0 6 571 3593 0 0 65 /**</span>
 <span class="s0">* Returns the number of TextureStages in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3892  </span>
<span class="s0">464 0 0 7 572 3753 0 0 58 /**</span>
 <span class="s0">* Returns the nth TextureStage in the collection.</span>
 <span class="s0">*/ 2 4 this 3 3892  5 index 1 3593  </span>
<span class="s0">465 0 0 7 574 3753 0 0 153 /**</span>
 <span class="s0">* Returns the nth TextureStage in the collection.  This is the same as</span>
 <span class="s0">* get_texture_stage(), but it may be a more convenient way to access it.</span>
 <span class="s0">*/ 2 4 this 3 3892  5 index 1 3593  </span>
<span class="s0">466 0 0 6 575 3593 0 0 122 /**</span>
 <span class="s0">* Returns the number of texture stages in the collection.  This is the same</span>
 <span class="s0">* thing as get_num_texture_stages().</span>
 <span class="s0">*/ 1 4 this 3 3892  </span>
<span class="s0">467 0 0 6 576 3891 0 0 0 2 4 this 3 3891  5 other 1 3892  </span>
<span class="s0">468 0 0 7 577 3891 2325 0 0 2 4 this 3 3892  5 other 1 3892  </span>
<span class="s0">469 0 0 4 578 3812 0 0 116 /**</span>
 <span class="s0">* Sorts the TextureStages in this collection into order by</span>
 <span class="s0">* TextureStage::sort(), from lowest to highest.</span>
 <span class="s0">*/ 1 4 this 3 3891  </span>
<span class="s0">470 0 0 4 579 3812 0 0 111 /**</span>
 <span class="s0">* Writes a brief one-line description of the TextureStageCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 3892  3 out 1 3813  </span>
<span class="s0">471 0 0 4 580 3812 0 0 116 /**</span>
 <span class="s0">* Writes a complete multi-line description of the TextureStageCollection to</span>
 <span class="s0">* the indicated output stream.</span>
 <span class="s0">*/ 3 4 this 3 3892  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">472 0 0 7 583 3894 2739 0 59 /**</span>
 <span class="s0">* This constructs an empty NodePath with no nodes.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">473 0 0 15 583 3894 2739 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3884  </span>
<span class="s0">474 0 0 7 583 3894 2739 0 153 /**</span>
 <span class="s0">* Constructs a NodePath with the indicated parent NodePath and child node;</span>
 <span class="s0">* the child node must be a stashed or unstashed child of the parent.</span>
 <span class="s0">*/ 3 6 parent 1 3884  10 child_node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">475 0 0 7 583 3894 2739 0 371 /**</span>
 <span class="s0">* This constructs a NodePath for the indicated node.  If the node does not</span>
 <span class="s0">* have any parents, this creates a singleton NodePath; otherwise, it</span>
 <span class="s0">* automatically finds the path from the node to the root.  If the node has</span>
 <span class="s0">* multiple paths to the root, one path is chosen arbitrarily and a warning</span>
 <span class="s0">* message is printed (but see also NodePath::any_path(), below).</span>
 <span class="s0">*/ 2 4 node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">476 0 0 7 583 3894 2739 0 135 /**</span>
 <span class="s0">* This constructs a new NodePath with a single node.  An ordinary, unattached</span>
 <span class="s0">* PandaNode is created with the indicated name.</span>
 <span class="s0">*/ 2 13 top_node_name 1 3841  14 current_thread 5 3844  </span>
<span class="s0">477 0 0 7 584 3894 2739 0 236 /**</span>
 <span class="s0">* Returns a new NodePath that represents any arbitrary path from the root to</span>
 <span class="s0">* the indicated node.  This is the same thing that would be returned by</span>
 <span class="s0">* NodePath(node), except that no warning is issued if the path is ambiguous.</span>
 <span class="s0">*/ 2 4 node 1 3650  14 current_thread 5 3844  </span>
<span class="s0">478 0 0 6 585 3894 0 0 0 2 4 this 3 3894  4 copy 1 3884  </span>
<span class="s0">479 0 0 4 586 3812 0 0 93 /**</span>
 <span class="s0">* Sets this NodePath to the empty NodePath.  It will no longer point to any</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">480 0 0 39 587 3894 2739 0 0 1 4 this 3 3884  </span>
<span class="s0">481 0 0 38 588 3623 0 0 0 2 4 this 3 3884  4 memo 1 3623  </span>
<span class="s0">482 0 0 38 589 3623 0 0 0 1 4 this 3 3884  </span>
<span class="s0">483 0 0 38 590 3623 0 0 0 2 4 this 3 3884  7 pickler 1 3623  </span>
<span class="s0">484 0 0 7 591 3894 2739 0 67 /**</span>
 <span class="s0">* Creates a NodePath with the ET_not_found error type set.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">485 0 0 7 592 3894 2739 0 65 /**</span>
 <span class="s0">* Creates a NodePath with the ET_removed error type set.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">486 0 0 7 593 3894 2739 0 62 /**</span>
 <span class="s0">* Creates a NodePath with the ET_fail error type set.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">487 0 0 4 594 3812 0 0 798 /**</span>
 <span class="s0">* Certain operations, such as find() or find_all_matches(), require a</span>
 <span class="s0">* traversal of the scene graph to search for the target node or nodes.  This</span>
 <span class="s0">* traversal does not attempt to detect cycles, so an arbitrary cap is set on</span>
 <span class="s0">* the depth of the traversal as a poor man's cycle detection, in the event</span>
 <span class="s0">* that a cycle has inadvertently been introduced into the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* There may be other reasons you'd want to truncate a search before the</span>
 <span class="s0">* bottom of the scene graph has been reached.  In any event, this function</span>
 <span class="s0">* sets the limit on the number of levels that a traversal will continue, and</span>
 <span class="s0">* hence the maximum length of a path that may be returned by a traversal.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a static method, and so changing this parameter affects all of the</span>
 <span class="s0">* NodePaths in the universe.</span>
 <span class="s0">*/ 1 16 max_search_depth 1 3593  </span>
<span class="s0">488 0 0 6 595 3593 0 0 95 /**</span>
 <span class="s0">* Returns the current setting of the search depth limit.  See</span>
 <span class="s0">* set_max_search_depth.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">489 0 0 6 596 3600 0 0 58 /**</span>
 <span class="s0">* Returns true if the NodePath contains no nodes.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">490 0 0 6 598 3600 0 0 66 /**</span>
 <span class="s0">* Returns true if the NodePath contains exactly one node.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">491 0 0 6 599 3593 0 0 51 /**</span>
 <span class="s0">* Returns the number of nodes in the path.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">492 0 0 7 600 3650 2131 0 473 /**</span>
 <span class="s0">* Returns the nth node of the path, where 0 is the referenced (bottom) node</span>
 <span class="s0">* and get_num_nodes() - 1 is the top node.  This requires iterating through</span>
 <span class="s0">* the path.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see node(), which is a convenience function to return the same thing</span>
 <span class="s0">* as get_node(0) (since the bottom node is the most important node in the</span>
 <span class="s0">* NodePath, and is the one most frequently referenced).</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this function returns the same thing as</span>
 <span class="s0">* get_ancestor(index).node().</span>
 <span class="s0">*/ 3 4 this 3 3884  5 index 1 3593  14 current_thread 5 3844  </span>
<span class="s0">493 0 0 7 604 3894 2739 0 261 /**</span>
 <span class="s0">* Returns the nth ancestor of the path, where 0 is the NodePath itself and</span>
 <span class="s0">* get_num_nodes() - 1 is get_top(). This requires iterating through the path.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see get_node(), which returns the same thing as a PandaNode pointer,</span>
 <span class="s0">* not a NodePath.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 index 1 3593  14 current_thread 5 3844  </span>
<span class="s0">494 0 0 6 607 3649 0 0 110 /**</span>
 <span class="s0">* If is_empty() is true, this returns a code that represents the reason why</span>
 <span class="s0">* the NodePath is empty.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">495 0 0 7 609 3650 2131 0 120 /**</span>
 <span class="s0">* Returns the top node of the path, or NULL if the path is empty.  This</span>
 <span class="s0">* requires iterating through the path.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">496 0 0 7 610 3894 2739 0 120 /**</span>
 <span class="s0">* Returns a singleton NodePath that represents the top of the path, or empty</span>
 <span class="s0">* NodePath if this path is empty.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">497 0 0 7 611 3650 2131 0 51 /**</span>
 <span class="s0">* Returns the referenced node of the path.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">498 0 0 6 612 3593 0 0 617 /**</span>
 <span class="s0">* Returns an integer that is guaranteed to be the same for all NodePaths that</span>
 <span class="s0">* represent the same node instance, and different for all NodePaths that</span>
 <span class="s0">* represent a different node instance.</span>
 <span class="s0">*</span>
 <span class="s0">* The same key will be returned for a particular instance as long as at least</span>
 <span class="s0">* one NodePath exists that represents that instance; if all NodePaths for a</span>
 <span class="s0">* particular instance destruct and a new one is later created, it may have a</span>
 <span class="s0">* different index.  However, a given key will never be reused for a different</span>
 <span class="s0">* instance (unless the app has been running long enough that we overflow the</span>
 <span class="s0">* integer key value).</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">499 0 0 6 613 3796 0 0 528 /**</span>
 <span class="s0">* Adds the NodePath into the running hash.  This is intended to be used by</span>
 <span class="s0">* lower-level code that computes a hash for each NodePath.  It modifies the</span>
 <span class="s0">* hash value passed in by a unique adjustment for each NodePath, and returns</span>
 <span class="s0">* the modified hash.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to the unique integer returned by get_key(), but it is not</span>
 <span class="s0">* guaranteed to remain unique beyond the lifetime of this particular</span>
 <span class="s0">* NodePath.  Once this NodePath destructs, a different NodePath may be</span>
 <span class="s0">* created which shares the same hash value.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 hash 1 3796  </span>
<span class="s0">500 0 0 6 614 3600 0 0 255 /**</span>
 <span class="s0">* Returns true if the node represented by this NodePath is parented within</span>
 <span class="s0">* the same graph as that of the other NodePath.  This is essentially the same</span>
 <span class="s0">* thing as asking whether get_top() of both NodePaths is the same (e.g., both</span>
 <span class="s0">* &quot;render&quot;).</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  14 current_thread 5 3844  </span>
<span class="s0">501 0 0 6 615 3600 0 0 143 /**</span>
 <span class="s0">* Returns true if the node represented by this NodePath is a parent or other</span>
 <span class="s0">* ancestor of the other NodePath, or false if it is not.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  14 current_thread 5 3844  </span>
<span class="s0">502 0 0 7 616 3894 2739 0 205 /**</span>
 <span class="s0">* Returns the lowest NodePath that both of these two NodePaths have in</span>
 <span class="s0">* common: the first ancestor that both of them share.  If the two NodePaths</span>
 <span class="s0">* are unrelated, returns NodePath::not_found().</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  14 current_thread 5 3844  </span>
<span class="s0">503 0 0 7 617 3895 2415 0 69 /**</span>
 <span class="s0">* Returns the set of all child nodes of the referenced node.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">504 0 0 6 618 3593 0 0 65 /**</span>
 <span class="s0">* Returns the number of children of the referenced node.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">505 0 0 7 619 3894 2739 0 80 /**</span>
 <span class="s0">* Returns a NodePath representing the nth child of the referenced node.</span>
 <span class="s0">*/ 3 4 this 3 3884  1 n 1 3593  14 current_thread 5 3844  </span>
<span class="s0">506 0 0 7 620 3895 2415 0 210 /**</span>
 <span class="s0">* Returns the set of all child nodes of the referenced node that have been</span>
 <span class="s0">* stashed.  These children are not normally visible on the node, and do not</span>
 <span class="s0">* appear in the list returned by get_children().</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">507 0 0 6 666 3593 0 0 63 /**</span>
 <span class="s0">* Returns the number of nodes at and below this level.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">508 0 0 6 667 3600 0 0 117 /**</span>
 <span class="s0">* Returns true if the referenced node has a parent; i.e.  the NodePath chain</span>
 <span class="s0">* contains at least two nodes.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">509 0 0 7 668 3894 2739 0 195 /**</span>
 <span class="s0">* Returns the NodePath to the parent of the referenced node: that is, this</span>
 <span class="s0">* NodePath, shortened by one node.  The parent of a singleton NodePath is</span>
 <span class="s0">* defined to be the empty NodePath.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">510 0 0 6 669 3593 0 0 246 /**</span>
 <span class="s0">* Returns the sort value of the referenced node within its parent; that is,</span>
 <span class="s0">* the sort number passed on the last reparenting operation for this node.</span>
 <span class="s0">* This will control the position of the node within its parent's list of</span>
 <span class="s0">* children.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">511 0 0 7 672 3894 2739 0 253 /**</span>
 <span class="s0">* Searches for a node below the referenced node that matches the indicated</span>
 <span class="s0">* string.  Returns the shortest match found, if any, or an empty NodePath if</span>
 <span class="s0">* no match can be found.</span>
 <span class="s0">*</span>
 <span class="s0">* The referenced node itself is not considered in the search.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 path 1 3841  </span>
<span class="s0">512 0 0 7 673 3894 2739 0 115 /**</span>
 <span class="s0">* Searches for the indicated node below this node and returns the shortest</span>
 <span class="s0">* NodePath that connects them.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 node 1 3650  </span>
<span class="s0">513 0 0 7 674 3895 2415 0 222 /**</span>
 <span class="s0">* Returns the complete set of all NodePaths that begin with this NodePath and</span>
 <span class="s0">* can be extended by path.  The shortest paths will be listed first.</span>
 <span class="s0">*</span>
 <span class="s0">* The referenced node itself is not considered in the search.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 path 1 3841  </span>
<span class="s0">514 0 0 7 675 3895 2415 0 147 /**</span>
 <span class="s0">* Returns the set of all NodePaths that extend from this NodePath down to the</span>
 <span class="s0">* indicated node.  The shortest paths will be listed first.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 node 1 3650  </span>
<span class="s0">515 0 0 4 676 3812 0 0 397 /**</span>
 <span class="s0">* Removes the referenced node of the NodePath from its current parent and</span>
 <span class="s0">* attaches it to the referenced node of the indicated NodePath.</span>
 <span class="s0">*</span>
 <span class="s0">* If the destination NodePath is empty, this is the same thing as</span>
 <span class="s0">* detach_node().</span>
 <span class="s0">*</span>
 <span class="s0">* If the referenced node is already a child of the indicated NodePath (via</span>
 <span class="s0">* some other instance), this operation fails and leaves the NodePath</span>
 <span class="s0">* detached.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">516 0 0 4 677 3812 0 0 189 /**</span>
 <span class="s0">* Similar to reparent_to(), but the node is added to its new parent's stashed</span>
 <span class="s0">* list, so that the result is equivalent to calling reparent_to() immediately</span>
 <span class="s0">* followed by stash().</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">517 0 0 4 678 3812 0 0 238 /**</span>
 <span class="s0">* This functions identically to reparent_to(), except the transform on this</span>
 <span class="s0">* node is also adjusted so that the node remains in the same place in world</span>
 <span class="s0">* coordinates, even if it is reparented into a different coordinate system.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">518 0 0 7 679 3894 2739 0 962 /**</span>
 <span class="s0">* Adds the referenced node of the NodePath as a child of the referenced node</span>
 <span class="s0">* of the indicated other NodePath.  Any other parent-child relations of the</span>
 <span class="s0">* node are unchanged; in particular, the node is not removed from its</span>
 <span class="s0">* existing parent, if any.</span>
 <span class="s0">*</span>
 <span class="s0">* If the node already had an existing parent, this method will create a new</span>
 <span class="s0">* instance of the node within the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* This does not change the NodePath itself, but does return a new NodePath</span>
 <span class="s0">* that reflects the new instance node.</span>
 <span class="s0">*</span>
 <span class="s0">* If the destination NodePath is empty, this creates a new instance which is</span>
 <span class="s0">* not yet parented to any node.  A new instance of this sort cannot easily be</span>
 <span class="s0">* differentiated from other similar instances, but it is nevertheless a</span>
 <span class="s0">* different instance and it will return a different get_id() value.</span>
 <span class="s0">*</span>
 <span class="s0">* If the referenced node is already a child of the indicated NodePath,</span>
 <span class="s0">* returns that already-existing instance, unstashing it first if necessary.</span>
 <span class="s0">*/ 4 4 this 3 3884  5 other 1 3884  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">519 0 0 7 680 3894 2739 0 236 /**</span>
 <span class="s0">* Behaves like instance_to(), but implicitly creates a new node to instance</span>
 <span class="s0">* the geometry under, and returns a NodePath to that new node.  This allows</span>
 <span class="s0">* the programmer to set a unique state and/or transform on this instance.</span>
 <span class="s0">*/ 5 4 this 3 3884  5 other 1 3884  4 name 1 3841  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">520 0 0 7 681 3894 2739 0 221 /**</span>
 <span class="s0">* Functions like instance_to(), except a deep copy is made of the referenced</span>
 <span class="s0">* node and all of its descendents, which is then parented to the indicated</span>
 <span class="s0">* node.  A NodePath to the newly created copy is returned.</span>
 <span class="s0">*/ 4 4 this 3 3884  5 other 1 3884  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">521 0 0 7 682 3894 2739 0 454 /**</span>
 <span class="s0">* Attaches a new node, with or without existing parents, to the scene graph</span>
 <span class="s0">* below the referenced node of this NodePath.  This is the preferred way to</span>
 <span class="s0">* add nodes to the graph.</span>
 <span class="s0">*</span>
 <span class="s0">* If the node was already a child of the parent, this returns a NodePath to</span>
 <span class="s0">* the existing child.</span>
 <span class="s0">*</span>
 <span class="s0">* This does *not* automatically extend the current NodePath to reflect the</span>
 <span class="s0">* attachment; however, a NodePath that does reflect this extension is</span>
 <span class="s0">* returned.</span>
 <span class="s0">*/ 4 4 this 3 3884  4 node 1 3650  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">522 0 0 7 682 3894 2739 0 132 /**</span>
 <span class="s0">* Creates an ordinary PandaNode and attaches it below the current NodePath,</span>
 <span class="s0">* returning a new NodePath that references it.</span>
 <span class="s0">*/ 4 4 this 3 3884  4 name 1 3841  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">523 0 0 4 683 3812 0 0 754 /**</span>
 <span class="s0">* Disconnects the referenced node from the scene graph.  This will also</span>
 <span class="s0">* delete the node if there are no other pointers to it.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, this should be called only when you are really done with the</span>
 <span class="s0">* node.  If you want to remove a node from the scene graph but keep it around</span>
 <span class="s0">* for later, you should probably use detach_node() instead.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, the only difference between remove_node() and detach_node() is</span>
 <span class="s0">* that remove_node() also resets the NodePath to empty, which will cause the</span>
 <span class="s0">* node to be deleted immediately if there are no other references.  On the</span>
 <span class="s0">* other hand, detach_node() leaves the NodePath referencing the node, which</span>
 <span class="s0">* will keep at least one reference to the node for as long as the NodePath</span>
 <span class="s0">* exists.</span>
 <span class="s0">*/ 2 4 this 3 3894  14 current_thread 5 3844  </span>
<span class="s0">524 0 0 4 684 3812 0 0 735 /**</span>
 <span class="s0">* Disconnects the referenced node from its parent, but does not immediately</span>
 <span class="s0">* delete it.  The NodePath retains a pointer to the node, and becomes a</span>
 <span class="s0">* singleton NodePath.</span>
 <span class="s0">*</span>
 <span class="s0">* This should be called to detach a node from the scene graph, with the</span>
 <span class="s0">* option of reattaching it later to the same parent or to a different parent.</span>
 <span class="s0">*</span>
 <span class="s0">* In practice, the only difference between remove_node() and detach_node() is</span>
 <span class="s0">* that remove_node() also resets the NodePath to empty, which will cause the</span>
 <span class="s0">* node to be deleted immediately if there are no other references.  On the</span>
 <span class="s0">* other hand, detach_node() leaves the NodePath referencing the node, which</span>
 <span class="s0">* will keep at least one reference to the node for as long as the NodePath</span>
 <span class="s0">* exists.</span>
 <span class="s0">*/ 2 4 this 3 3894  14 current_thread 5 3844  </span>
<span class="s0">525 0 0 4 685 3812 0 0 91 /**</span>
 <span class="s0">* Writes a sensible description of the NodePath to the indicated output</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/ 2 4 this 3 3884  3 out 1 3813  </span>
<span class="s0">526 0 0 4 686 3812 0 0 64 /**</span>
 <span class="s0">* Lists the hierarchy at and below the referenced node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">527 0 0 4 686 3812 0 0 64 /**</span>
 <span class="s0">* Lists the hierarchy at and below the referenced node.</span>
 <span class="s0">*/ 3 4 this 3 3884  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">528 0 0 4 687 3812 0 0 64 /**</span>
 <span class="s0">* Lists the hierarchy at and above the referenced node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">529 0 0 6 687 3593 0 0 64 /**</span>
 <span class="s0">* Lists the hierarchy at and above the referenced node.</span>
 <span class="s0">*/ 3 4 this 3 3884  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">530 0 0 7 688 3825 0 0 145 /**</span>
 <span class="s0">* Returns the state changes that must be made to transition to the render</span>
 <span class="s0">* state of this node from the render state of the other node.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  14 current_thread 5 3844  </span>
<span class="s0">531 0 0 7 688 3825 0 0 62 /**</span>
 <span class="s0">* Returns the complete state object set on this node.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">532 0 0 4 689 3812 0 0 180 /**</span>
 <span class="s0">* Sets the state object on this node, relative to the other node.  This</span>
 <span class="s0">* computes a new state object that will have the indicated value when seen</span>
 <span class="s0">* from the other node.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 state 1 3825  14 current_thread 5 3844  </span>
<span class="s0">533 0 0 4 689 3812 0 0 58 /**</span>
 <span class="s0">* Changes the complete state object on this node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 state 1 3825  14 current_thread 5 3844  </span>
<span class="s0">534 0 0 7 690 3825 0 0 60 /**</span>
 <span class="s0">* Returns the net state on this node from the root.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">535 0 0 4 691 3812 0 0 220 /**</span>
 <span class="s0">* Adds the indicated render attribute to the scene graph on this node.  This</span>
 <span class="s0">* attribute will now apply to this node and everything below.  If there was</span>
 <span class="s0">* already an attribute of the same type, it is replaced.</span>
 <span class="s0">*/ 3 4 this 3 3894  6 attrib 1 3607  8 priority 5 3593  </span>
<span class="s0">536 0 0 7 692 3607 0 0 270 /**</span>
 <span class="s0">* Returns the render attribute of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.  This checks only what is set on this</span>
 <span class="s0">* particular node level, and has nothing to do with what render attributes</span>
 <span class="s0">* may be inherited from parent nodes.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 type 1 3816  </span>
<span class="s0">537 0 0 6 693 3600 0 0 127 /**</span>
 <span class="s0">* Returns true if there is a render attribute of the indicated type defined</span>
 <span class="s0">* on this node, or false if there is not.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 type 1 3816  </span>
<span class="s0">538 0 0 4 694 3812 0 0 194 /**</span>
 <span class="s0">* Removes the render attribute of the given type from this node.  This node,</span>
 <span class="s0">* and the subgraph below, will now inherit the indicated render attribute</span>
 <span class="s0">* from the nodes above this one.</span>
 <span class="s0">*/ 2 4 this 3 3894  4 type 1 3816  </span>
<span class="s0">539 0 0 4 695 3812 0 0 145 /**</span>
 <span class="s0">* Adds the indicated render effect to the scene graph on this node.  If there</span>
 <span class="s0">* was already an effect of the same type, it is replaced.</span>
 <span class="s0">*/ 2 4 this 3 3894  6 effect 1 3837  </span>
<span class="s0">540 0 0 7 696 3837 0 0 114 /**</span>
 <span class="s0">* Returns the render effect of the indicated type, if it is defined on the</span>
 <span class="s0">* node, or NULL if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 type 1 3816  </span>
<span class="s0">541 0 0 6 697 3600 0 0 124 /**</span>
 <span class="s0">* Returns true if there is a render effect of the indicated type defined on</span>
 <span class="s0">* this node, or false if there is not.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 type 1 3816  </span>
<span class="s0">542 0 0 4 698 3812 0 0 70 /**</span>
 <span class="s0">* Removes the render effect of the given type from this node.</span>
 <span class="s0">*/ 2 4 this 3 3894  4 type 1 3816  </span>
<span class="s0">543 0 0 4 699 3812 0 0 177 /**</span>
 <span class="s0">* Sets the complete RenderEffects that will be applied this node.  This</span>
 <span class="s0">* completely replaces whatever has been set on this node via repeated calls</span>
 <span class="s0">* to set_attrib().</span>
 <span class="s0">*/ 2 4 this 3 3894  7 effects 1 3839  </span>
<span class="s0">544 0 0 7 700 3839 0 0 80 /**</span>
 <span class="s0">* Returns the complete RenderEffects that will be applied to this node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">545 0 0 4 701 3812 0 0 54 /**</span>
 <span class="s0">* Resets this node to have no render effects.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">546 0 0 7 702 3794 0 0 145 /**</span>
 <span class="s0">* Returns the relative transform to this node from the other node; i.e.  the</span>
 <span class="s0">* transformation of this node as seen from the other node.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  14 current_thread 5 3844  </span>
<span class="s0">547 0 0 7 702 3794 0 0 66 /**</span>
 <span class="s0">* Returns the complete transform object set on this node.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">548 0 0 4 703 3812 0 0 171 /**</span>
 <span class="s0">* Sets the transform object on this node to identity, relative to the other</span>
 <span class="s0">* node.  This effectively places this node at the same position as the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  14 current_thread 5 3844  </span>
<span class="s0">549 0 0 4 703 3812 0 0 62 /**</span>
 <span class="s0">* Sets the transform object on this node to identity.</span>
 <span class="s0">*/ 2 4 this 3 3894  14 current_thread 5 3844  </span>
<span class="s0">550 0 0 4 704 3812 0 0 188 /**</span>
 <span class="s0">* Sets the transform object on this node, relative to the other node.  This</span>
 <span class="s0">* computes a new transform object that will have the indicated value when</span>
 <span class="s0">* seen from the other node.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  9 transform 1 3794  14 current_thread 5 3844  </span>
<span class="s0">551 0 0 4 704 3812 0 0 62 /**</span>
 <span class="s0">* Changes the complete transform object on this node.</span>
 <span class="s0">*/ 3 4 this 3 3894  9 transform 1 3794  14 current_thread 5 3844  </span>
<span class="s0">552 0 0 7 705 3794 0 0 64 /**</span>
 <span class="s0">* Returns the net transform on this node from the root.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">553 0 0 7 706 3794 0 0 196 /**</span>
 <span class="s0">* Returns the relative &quot;previous&quot; transform to this node from the other node;</span>
 <span class="s0">* i.e.  the position of this node in the previous frame, as seen by the other</span>
 <span class="s0">* node in the previous frame.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  14 current_thread 5 3844  </span>
<span class="s0">554 0 0 7 706 3794 0 0 115 /**</span>
 <span class="s0">* Returns the transform that has been set as this node's &quot;previous&quot; position.</span>
 <span class="s0">* See set_prev_transform().</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">555 0 0 4 707 3812 0 0 199 /**</span>
 <span class="s0">* Sets the &quot;previous&quot; transform object on this node, relative to the other</span>
 <span class="s0">* node.  This computes a new transform object that will have the indicated</span>
 <span class="s0">* value when seen from the other node.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  9 transform 1 3794  14 current_thread 5 3844  </span>
<span class="s0">556 0 0 4 707 3812 0 0 173 /**</span>
 <span class="s0">* Sets the transform that represents this node's &quot;previous&quot; position, one</span>
 <span class="s0">* frame ago, for the purposes of detecting motion for accurate collision</span>
 <span class="s0">* calculations.</span>
 <span class="s0">*/ 3 4 this 3 3894  9 transform 1 3794  14 current_thread 5 3844  </span>
<span class="s0">557 0 0 7 708 3794 0 0 105 /**</span>
 <span class="s0">* Returns the net &quot;previous&quot; transform on this node from the root.  See</span>
 <span class="s0">* set_prev_transform().</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">558 0 0 4 709 3812 0 0 329 /**</span>
 <span class="s0">* Sets the translation component of the transform, leaving rotation and scale</span>
 <span class="s0">* untouched.  This also resets the node's &quot;previous&quot; position, so that the</span>
 <span class="s0">* collision system will see the node as having suddenly appeared in the new</span>
 <span class="s0">* position, without passing any points in between.  See Also:</span>
 <span class="s0">* NodePath::set_fluid_pos</span>
 <span class="s0">*/ 2 4 this 3 3894  3 pos 1 3798  </span>
<span class="s0">559 0 0 4 709 3812 0 0 90 /**</span>
 <span class="s0">* Sets the translation component of the transform, relative to the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  3 pos 1 3798  </span>
<span class="s0">560 0 0 4 709 3812 0 0 90 /**</span>
 <span class="s0">* Sets the translation component of the transform, relative to the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">561 0 0 4 709 3812 0 0 291 /**</span>
 <span class="s0">* Sets the translation component of the transform, leaving rotation and scale</span>
 <span class="s0">* untouched.  This also resets the node's &quot;previous&quot; position, so that the</span>
 <span class="s0">* collision system will see the node as having suddenly appeared in the new</span>
 <span class="s0">* position, without passing any points in between.</span>
 <span class="s0">*/ 4 4 this 3 3894  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">562 0 0 4 710 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 x 1 3598  </span>
<span class="s0">563 0 0 4 710 3812 0 0 115 /**</span>
 <span class="s0">* Sets the X component of the position transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_pos()</span>
 <span class="s0">*/ 2 4 this 3 3894  1 x 1 3598  </span>
<span class="s0">564 0 0 4 711 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 y 1 3598  </span>
<span class="s0">565 0 0 4 711 3812 0 0 115 /**</span>
 <span class="s0">* Sets the Y component of the position transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_pos()</span>
 <span class="s0">*/ 2 4 this 3 3894  1 y 1 3598  </span>
<span class="s0">566 0 0 4 712 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 z 1 3598  </span>
<span class="s0">567 0 0 4 712 3812 0 0 115 /**</span>
 <span class="s0">* Sets the Z component of the position transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_pos()</span>
 <span class="s0">*/ 2 4 this 3 3894  1 z 1 3598  </span>
<span class="s0">568 0 0 4 713 3812 0 0 232 /**</span>
 <span class="s0">* Sets the translation component, without changing the &quot;previous&quot; position,</span>
 <span class="s0">* so that the collision system will see the node as moving fluidly from its</span>
 <span class="s0">* previous position to its new position.  See Also: NodePath::set_pos</span>
 <span class="s0">*/ 2 4 this 3 3894  3 pos 1 3798  </span>
<span class="s0">569 0 0 4 713 3812 0 0 90 /**</span>
 <span class="s0">* Sets the translation component of the transform, relative to the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  3 pos 1 3798  </span>
<span class="s0">570 0 0 4 713 3812 0 0 203 /**</span>
 <span class="s0">* Sets the translation component, without changing the &quot;previous&quot; position,</span>
 <span class="s0">* so that the collision system will see the node as moving fluidly from its</span>
 <span class="s0">* previous position to its new position.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">571 0 0 4 713 3812 0 0 203 /**</span>
 <span class="s0">* Sets the translation component, without changing the &quot;previous&quot; position,</span>
 <span class="s0">* so that the collision system will see the node as moving fluidly from its</span>
 <span class="s0">* previous position to its new position.</span>
 <span class="s0">*/ 4 4 this 3 3894  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">572 0 0 4 714 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 x 1 3598  </span>
<span class="s0">573 0 0 4 714 3812 0 0 0 2 4 this 3 3894  1 x 1 3598  </span>
<span class="s0">574 0 0 4 715 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 y 1 3598  </span>
<span class="s0">575 0 0 4 715 3812 0 0 0 2 4 this 3 3894  1 y 1 3598  </span>
<span class="s0">576 0 0 4 716 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 z 1 3598  </span>
<span class="s0">577 0 0 4 716 3812 0 0 0 2 4 this 3 3894  1 z 1 3598  </span>
<span class="s0">578 0 0 7 717 3896 0 0 64 /**</span>
 <span class="s0">* Retrieves the translation component of the transform.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">579 0 0 7 717 3896 0 0 95 /**</span>
 <span class="s0">* Returns the relative position of the referenced node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">580 0 0 6 718 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">581 0 0 6 718 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">582 0 0 6 719 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">583 0 0 6 719 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">584 0 0 6 720 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">585 0 0 6 720 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">586 0 0 7 721 3899 0 0 469 /**</span>
 <span class="s0">* Returns the delta vector from this node's position in the previous frame</span>
 <span class="s0">* (according to set_prev_transform(), typically set via the use of</span>
 <span class="s0">* set_fluid_pos()) and its position in the current frame.  This is the vector</span>
 <span class="s0">* used to determine collisions.  Generally, if the node was last repositioned</span>
 <span class="s0">* via set_pos(), the delta will be zero; if it was adjusted via</span>
 <span class="s0">* set_fluid_pos(), the delta will represent the change from the previous</span>
 <span class="s0">* frame's position.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">587 0 0 7 721 3899 0 0 519 /**</span>
 <span class="s0">* Returns the delta vector from this node's position in the previous frame</span>
 <span class="s0">* (according to set_prev_transform(), typically set via the use of</span>
 <span class="s0">* set_fluid_pos()) and its position in the current frame, as seen in the</span>
 <span class="s0">* indicated node's coordinate space.  This is the vector used to determine</span>
 <span class="s0">* collisions.  Generally, if the node was last repositioned via set_pos(),</span>
 <span class="s0">* the delta will be zero; if it was adjusted via set_fluid_pos(), the delta</span>
 <span class="s0">* will represent the change from the previous frame's position.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">588 0 0 4 722 3812 0 0 100 /**</span>
 <span class="s0">* Sets the rotation component of the transform, leaving translation and scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 2 4 this 3 3894  3 hpr 1 3798  </span>
<span class="s0">589 0 0 4 722 3812 0 0 84 /**</span>
 <span class="s0">* Sets the rotation component of the transform, relative to the other node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  3 hpr 1 3798  </span>
<span class="s0">590 0 0 4 722 3812 0 0 84 /**</span>
 <span class="s0">* Sets the rotation component of the transform, relative to the other node.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  1 h 1 3598  1 p 1 3598  1 r 1 3598  </span>
<span class="s0">591 0 0 4 722 3812 0 0 100 /**</span>
 <span class="s0">* Sets the rotation component of the transform, leaving translation and scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 4 4 this 3 3894  1 h 1 3598  1 p 1 3598  1 r 1 3598  </span>
<span class="s0">592 0 0 4 723 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 h 1 3598  </span>
<span class="s0">593 0 0 4 723 3812 0 0 0 2 4 this 3 3894  1 h 1 3598  </span>
<span class="s0">594 0 0 4 724 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 p 1 3598  </span>
<span class="s0">595 0 0 4 724 3812 0 0 0 2 4 this 3 3894  1 p 1 3598  </span>
<span class="s0">596 0 0 4 725 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  1 r 1 3598  </span>
<span class="s0">597 0 0 4 725 3812 0 0 0 2 4 this 3 3894  1 r 1 3598  </span>
<span class="s0">598 0 0 7 726 3900 0 0 61 /**</span>
 <span class="s0">* Retrieves the rotation component of the transform.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">599 0 0 7 726 3900 0 0 94 /**</span>
 <span class="s0">* Returns the relative orientation of the bottom node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">600 0 0 6 727 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">601 0 0 6 727 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">602 0 0 6 728 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">603 0 0 6 728 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">604 0 0 6 729 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">605 0 0 6 729 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">606 0 0 4 730 3812 0 0 100 /**</span>
 <span class="s0">* Sets the rotation component of the transform, leaving translation and scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 2 4 this 3 3894  4 quat 1 3799  </span>
<span class="s0">607 0 0 4 730 3812 0 0 84 /**</span>
 <span class="s0">* Sets the rotation component of the transform, relative to the other node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  4 quat 1 3799  </span>
<span class="s0">608 0 0 7 731 3901 0 0 61 /**</span>
 <span class="s0">* Retrieves the rotation component of the transform.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">609 0 0 7 731 3901 0 0 94 /**</span>
 <span class="s0">* Returns the relative orientation of the bottom node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">610 0 0 4 732 3812 0 0 100 /**</span>
 <span class="s0">* Sets the scale component of the transform, leaving translation and rotation</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 scale 1 3798  </span>
<span class="s0">611 0 0 4 732 3812 0 0 81 /**</span>
 <span class="s0">* Sets the scale component of the transform, relative to the other node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  5 scale 1 3798  </span>
<span class="s0">612 0 0 4 732 3812 0 0 81 /**</span>
 <span class="s0">* Sets the scale component of the transform, relative to the other node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  5 scale 1 3598  </span>
<span class="s0">613 0 0 4 732 3812 0 0 81 /**</span>
 <span class="s0">* Sets the scale component of the transform, relative to the other node.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  2 sx 1 3598  2 sy 1 3598  2 sz 1 3598  </span>
<span class="s0">614 0 0 4 732 3812 0 0 100 /**</span>
 <span class="s0">* Sets the scale component of the transform, leaving translation and rotation</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 scale 1 3598  </span>
<span class="s0">615 0 0 4 732 3812 0 0 0 4 4 this 3 3894  2 sx 1 3598  2 sy 1 3598  2 sz 1 3598  </span>
<span class="s0">616 0 0 4 733 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  2 sx 1 3598  </span>
<span class="s0">617 0 0 4 733 3812 0 0 114 /**</span>
 <span class="s0">* Sets the x-scale component of the transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_scale()</span>
 <span class="s0">*/ 2 4 this 3 3894  2 sx 1 3598  </span>
<span class="s0">618 0 0 4 734 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  2 sy 1 3598  </span>
<span class="s0">619 0 0 4 734 3812 0 0 114 /**</span>
 <span class="s0">* Sets the y-scale component of the transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_scale()</span>
 <span class="s0">*/ 2 4 this 3 3894  2 sy 1 3598  </span>
<span class="s0">620 0 0 4 735 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  2 sz 1 3598  </span>
<span class="s0">621 0 0 4 735 3812 0 0 114 /**</span>
 <span class="s0">* Sets the z-scale component of the transform, leaving other components</span>
 <span class="s0">* untouched.</span>
 <span class="s0">* @see set_scale()</span>
 <span class="s0">*/ 2 4 this 3 3894  2 sz 1 3598  </span>
<span class="s0">622 0 0 7 736 3900 0 0 58 /**</span>
 <span class="s0">* Retrieves the scale component of the transform.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">623 0 0 7 736 3900 0 0 85 /**</span>
 <span class="s0">* Returns the relative scale of the bottom node as seen from the other node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">624 0 0 6 737 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">625 0 0 6 737 3598 0 0 92 /**</span>
 <span class="s0">* Returns the relative scale of the referenced node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">626 0 0 6 738 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">627 0 0 6 738 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">628 0 0 6 739 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">629 0 0 6 739 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">630 0 0 4 740 3812 0 0 100 /**</span>
 <span class="s0">* Sets the shear component of the transform, leaving translation and rotation</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 shear 1 3798  </span>
<span class="s0">631 0 0 4 740 3812 0 0 81 /**</span>
 <span class="s0">* Sets the shear component of the transform, relative to the other node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  5 shear 1 3798  </span>
<span class="s0">632 0 0 4 740 3812 0 0 81 /**</span>
 <span class="s0">* Sets the shear component of the transform, relative to the other node.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  4 shxy 1 3598  4 shxz 1 3598  4 shyz 1 3598  </span>
<span class="s0">633 0 0 4 740 3812 0 0 108 /**</span>
 <span class="s0">* Sets the shear component of the transform, leaving translation, rotation,</span>
 <span class="s0">* and scale untouched.</span>
 <span class="s0">*/ 4 4 this 3 3894  4 shxy 1 3598  4 shxz 1 3598  4 shyz 1 3598  </span>
<span class="s0">634 0 0 4 741 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  4 shxy 1 3598  </span>
<span class="s0">635 0 0 4 741 3812 0 0 0 2 4 this 3 3894  4 shxy 1 3598  </span>
<span class="s0">636 0 0 4 742 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  4 shxz 1 3598  </span>
<span class="s0">637 0 0 4 742 3812 0 0 0 2 4 this 3 3894  4 shxz 1 3598  </span>
<span class="s0">638 0 0 4 743 3812 0 0 0 3 4 this 3 3894  5 other 1 3884  4 shyz 1 3598  </span>
<span class="s0">639 0 0 4 743 3812 0 0 0 2 4 this 3 3894  4 shyz 1 3598  </span>
<span class="s0">640 0 0 7 744 3900 0 0 58 /**</span>
 <span class="s0">* Retrieves the shear component of the transform.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">641 0 0 7 744 3900 0 0 85 /**</span>
 <span class="s0">* Returns the relative shear of the bottom node as seen from the other node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">642 0 0 6 745 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">643 0 0 6 745 3598 0 0 92 /**</span>
 <span class="s0">* Returns the relative shear of the referenced node as seen from the other</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">644 0 0 6 746 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">645 0 0 6 746 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">646 0 0 6 747 3598 0 0 0 1 4 this 3 3884  </span>
<span class="s0">647 0 0 6 747 3598 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">648 0 0 4 748 3812 0 0 100 /**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, leaving scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 3 4 this 3 3894  3 pos 1 3798  3 hpr 1 3798  </span>
<span class="s0">649 0 0 4 748 3812 0 0 103 /**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, relative to</span>
 <span class="s0">* the other node.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  3 pos 1 3798  3 hpr 1 3798  </span>
<span class="s0">650 0 0 4 748 3812 0 0 103 /**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, relative to</span>
 <span class="s0">* the other node.</span>
 <span class="s0">*/ 8 4 this 3 3894  5 other 1 3884  1 x 1 3598  1 y 1 3598  1 z 1 3598  1 h 1 3598  1 p 1 3598  1 r 1 3598  </span>
<span class="s0">651 0 0 4 748 3812 0 0 100 /**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, leaving scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 7 4 this 3 3894  1 x 1 3598  1 y 1 3598  1 z 1 3598  1 h 1 3598  1 p 1 3598  1 r 1 3598  </span>
<span class="s0">652 0 0 4 749 3812 0 0 100 /**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, leaving scale</span>
 <span class="s0">* untouched.</span>
 <span class="s0">*/ 3 4 this 3 3894  3 pos 1 3798  4 quat 1 3799  </span>
<span class="s0">653 0 0 4 749 3812 0 0 103 /**</span>
 <span class="s0">* Sets the translation and rotation component of the transform, relative to</span>
 <span class="s0">* the other node.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  3 pos 1 3798  4 quat 1 3799  </span>
<span class="s0">654 0 0 4 750 3812 0 0 101 /**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.</span>
 <span class="s0">*/ 3 4 this 3 3894  3 hpr 1 3798  5 scale 1 3798  </span>
<span class="s0">655 0 0 4 750 3812 0 0 219 /**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.  This, or set_pos_hpr_scale, is the preferred way to</span>
 <span class="s0">* update a transform when both hpr and scale are to be changed.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  3 hpr 1 3798  5 scale 1 3798  </span>
<span class="s0">656 0 0 4 750 3812 0 0 219 /**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.  This, or set_pos_hpr_scale, is the preferred way to</span>
 <span class="s0">* update a transform when both hpr and scale are to be changed.</span>
 <span class="s0">*/ 8 4 this 3 3894  5 other 1 3884  1 h 1 3598  1 p 1 3598  1 r 1 3598  2 sx 1 3598  2 sy 1 3598  2 sz 1 3598  </span>
<span class="s0">657 0 0 4 750 3812 0 0 101 /**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.</span>
 <span class="s0">*/ 7 4 this 3 3894  1 h 1 3598  1 p 1 3598  1 r 1 3598  2 sx 1 3598  2 sy 1 3598  2 sz 1 3598  </span>
<span class="s0">658 0 0 4 751 3812 0 0 101 /**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.</span>
 <span class="s0">*/ 3 4 this 3 3894  4 quat 1 3799  5 scale 1 3798  </span>
<span class="s0">659 0 0 4 751 3812 0 0 221 /**</span>
 <span class="s0">* Sets the rotation and scale components of the transform, leaving</span>
 <span class="s0">* translation untouched.  This, or set_pos_quat_scale, is the preferred way</span>
 <span class="s0">* to update a transform when both quat and scale are to be changed.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  4 quat 1 3799  5 scale 1 3798  </span>
<span class="s0">660 0 0 4 752 3812 0 0 102 /**</span>
 <span class="s0">* Replaces the translation, rotation, and scale components, implicitly</span>
 <span class="s0">* setting shear to 0.</span>
 <span class="s0">*/ 4 4 this 3 3894  3 pos 1 3798  3 hpr 1 3798  5 scale 1 3798  </span>
<span class="s0">661 0 0 4 752 3812 0 0 160 /**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, and scale</span>
 <span class="s0">* components, relative to the other node, implicitly setting shear to 0.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  3 pos 1 3798  3 hpr 1 3798  5 scale 1 3798  </span>
<span class="s0">662 0 0 4 752 3812 0 0 129 /**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, and scale</span>
 <span class="s0">* components, relative to the other node.</span>
 <span class="s0">*/ 11 4 this 3 3894  5 other 1 3884  1 x 1 3598  1 y 1 3598  1 z 1 3598  1 h 1 3598  1 p 1 3598  1 r 1 3598  2 sx 1 3598  2 sy 1 3598  2 sz 1 3598  </span>
<span class="s0">663 0 0 4 752 3812 0 0 101 /**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, and scale</span>
 <span class="s0">* components.</span>
 <span class="s0">*/ 10 4 this 3 3894  1 x 1 3598  1 y 1 3598  1 z 1 3598  1 h 1 3598  1 p 1 3598  1 r 1 3598  2 sx 1 3598  2 sy 1 3598  2 sz 1 3598  </span>
<span class="s0">664 0 0 4 753 3812 0 0 102 /**</span>
 <span class="s0">* Replaces the translation, rotation, and scale components, implicitly</span>
 <span class="s0">* setting shear to 0.</span>
 <span class="s0">*/ 4 4 this 3 3894  3 pos 1 3798  4 quat 1 3799  5 scale 1 3798  </span>
<span class="s0">665 0 0 4 753 3812 0 0 160 /**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, and scale</span>
 <span class="s0">* components, relative to the other node, implicitly setting shear to 0.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  3 pos 1 3798  4 quat 1 3799  5 scale 1 3798  </span>
<span class="s0">666 0 0 4 754 3812 0 0 108 /**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, scale,</span>
 <span class="s0">* and shear components.</span>
 <span class="s0">*/ 5 4 this 3 3894  3 pos 1 3798  3 hpr 1 3798  5 scale 1 3798  5 shear 1 3798  </span>
<span class="s0">667 0 0 4 754 3812 0 0 136 /**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, scale,</span>
 <span class="s0">* and shear components, relative to the other node.</span>
 <span class="s0">*/ 6 4 this 3 3894  5 other 1 3884  3 pos 1 3798  3 hpr 1 3798  5 scale 1 3798  5 shear 1 3798  </span>
<span class="s0">668 0 0 4 755 3812 0 0 108 /**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, scale,</span>
 <span class="s0">* and shear components.</span>
 <span class="s0">*/ 5 4 this 3 3894  3 pos 1 3798  4 quat 1 3799  5 scale 1 3798  5 shear 1 3798  </span>
<span class="s0">669 0 0 4 755 3812 0 0 136 /**</span>
 <span class="s0">* Completely replaces the transform with new translation, rotation, scale,</span>
 <span class="s0">* and shear components, relative to the other node.</span>
 <span class="s0">*/ 6 4 this 3 3894  5 other 1 3884  3 pos 1 3798  4 quat 1 3799  5 scale 1 3798  5 shear 1 3798  </span>
<span class="s0">670 0 0 4 756 3812 0 0 59 /**</span>
 <span class="s0">* Directly sets an arbitrary 4x4 transform matrix.</span>
 <span class="s0">*/ 2 4 this 3 3894  3 mat 1 3800  </span>
<span class="s0">671 0 0 4 756 3812 0 0 136 /**</span>
 <span class="s0">* Converts the indicated matrix from the other's coordinate space to the</span>
 <span class="s0">* local coordinate space, and applies it to the node.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 other 1 3884  3 mat 1 3800  </span>
<span class="s0">672 0 0 4 757 3812 0 0 69 /**</span>
 <span class="s0">* Completely removes any transform from the referenced node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">673 0 0 6 758 3600 0 0 119 /**</span>
 <span class="s0">* Returns true if a non-identity transform matrix has been applied to the</span>
 <span class="s0">* referenced node, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">674 0 0 6 759 3800 0 0 142 /**</span>
 <span class="s0">* Returns the transform matrix that has been applied to the referenced node,</span>
 <span class="s0">* or the identity matrix if no matrix has been applied.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">675 0 0 7 759 3902 0 0 149 /**</span>
 <span class="s0">* Returns the matrix that describes the coordinate space of the bottom node,</span>
 <span class="s0">* relative to the other path's bottom node's coordinate space.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">676 0 0 4 760 3812 0 0 100 /**</span>
 <span class="s0">* Sets the hpr on this NodePath so that it rotates to face the indicated</span>
 <span class="s0">* point in space.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 point 1 3809  2 up 5 3903  </span>
<span class="s0">677 0 0 4 760 3812 0 0 147 /**</span>
 <span class="s0">* Sets the transform on this NodePath so that it rotates to face the</span>
 <span class="s0">* indicated point in space, which is relative to the other NodePath.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 point 5 3809  2 up 5 3903  </span>
<span class="s0">678 0 0 4 760 3812 0 0 141 /**</span>
 <span class="s0">* Sets the hpr on this NodePath so that it rotates to face the indicated</span>
 <span class="s0">* point in space, which is relative to the other NodePath.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">679 0 0 4 760 3812 0 0 216 /**</span>
 <span class="s0">* Sets the transform on this NodePath so that it rotates to face the</span>
 <span class="s0">* indicated point in space.  This will overwrite any previously existing</span>
 <span class="s0">* scale on the node, although it will preserve any translation.</span>
 <span class="s0">*/ 4 4 this 3 3894  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">680 0 0 4 761 3812 0 0 133 /**</span>
 <span class="s0">* Behaves like look_at(), but with a strong preference to keeping the up</span>
 <span class="s0">* vector oriented in the indicated &quot;up&quot; direction.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 point 1 3809  2 up 5 3903  </span>
<span class="s0">681 0 0 4 761 3812 0 0 133 /**</span>
 <span class="s0">* Behaves like look_at(), but with a strong preference to keeping the up</span>
 <span class="s0">* vector oriented in the indicated &quot;up&quot; direction.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 point 5 3809  2 up 5 3903  </span>
<span class="s0">682 0 0 4 761 3812 0 0 133 /**</span>
 <span class="s0">* Behaves like look_at(), but with a strong preference to keeping the up</span>
 <span class="s0">* vector oriented in the indicated &quot;up&quot; direction.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">683 0 0 4 761 3812 0 0 133 /**</span>
 <span class="s0">* Behaves like look_at(), but with a strong preference to keeping the up</span>
 <span class="s0">* vector oriented in the indicated &quot;up&quot; direction.</span>
 <span class="s0">*/ 4 4 this 3 3894  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">684 0 0 7 762 3896 0 0 148 /**</span>
 <span class="s0">* Given that the indicated point is in the coordinate system of the other</span>
 <span class="s0">* node, returns the same point in this node's coordinate system.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  5 point 1 3798  </span>
<span class="s0">685 0 0 7 763 3899 0 0 150 /**</span>
 <span class="s0">* Given that the indicated vector is in the coordinate system of the other</span>
 <span class="s0">* node, returns the same vector in this node's coordinate system.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  3 vec 1 3798  </span>
<span class="s0">686 0 0 6 764 3598 0 0 143 /**</span>
 <span class="s0">* Returns the straight-line distance between this referenced node's</span>
 <span class="s0">* coordinate frame's origin, and that of the other node's origin.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">687 0 0 4 765 3812 0 0 189 /**</span>
 <span class="s0">* Applies a scene-graph color to the referenced node.  This color will apply</span>
 <span class="s0">* to all geometry at this level and below (that does not specify a new color</span>
 <span class="s0">* or a set_color_off()).</span>
 <span class="s0">*/ 3 4 this 3 3894  5 color 1 3820  8 priority 5 3593  </span>
<span class="s0">688 0 0 4 765 3812 0 0 189 /**</span>
 <span class="s0">* Applies a scene-graph color to the referenced node.  This color will apply</span>
 <span class="s0">* to all geometry at this level and below (that does not specify a new color</span>
 <span class="s0">* or a set_color_off()).</span>
 <span class="s0">*/ 6 4 this 3 3894  1 r 1 3598  1 g 1 3598  1 b 1 3598  1 a 5 3598  8 priority 5 3593  </span>
<span class="s0">689 0 0 4 766 3812 0 0 277 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using the geometry</span>
 <span class="s0">* color.  This is normally the default, but it may be useful to use this to</span>
 <span class="s0">* contradict set_color() at a higher node level (or, with a priority, to</span>
 <span class="s0">* override a set_color() at a lower level).</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">690 0 0 4 767 3812 0 0 209 /**</span>
 <span class="s0">* Completely removes any color adjustment from the node.  This allows the</span>
 <span class="s0">* natural color of the geometry, or whatever color transitions might be</span>
 <span class="s0">* otherwise affecting the geometry, to show instead.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">691 0 0 6 768 3600 0 0 90 /**</span>
 <span class="s0">* Returns true if a color has been applied to the given node, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">692 0 0 7 769 3905 0 0 107 /**</span>
 <span class="s0">* Returns the color that has been assigned to the node, or black if no color</span>
 <span class="s0">* has been assigned.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">693 0 0 6 770 3600 0 0 194 /**</span>
 <span class="s0">* Returns true if a color scale has been applied to the referenced node,</span>
 <span class="s0">* false otherwise.  It is still possible that color at this node might have</span>
 <span class="s0">* been scaled by an ancestor node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">694 0 0 4 771 3812 0 0 221 /**</span>
 <span class="s0">* Completely removes any color scale from the referenced node.  This is</span>
 <span class="s0">* preferable to simply setting the color scale to identity, as it also</span>
 <span class="s0">* removes the overhead associated with having a color scale at all.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">695 0 0 4 772 3812 0 0 106 /**</span>
 <span class="s0">* Sets the color scale component of the transform, leaving translation and</span>
 <span class="s0">* rotation untouched.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 scale 1 3880  8 priority 5 3593  </span>
<span class="s0">696 0 0 4 772 3812 0 0 58 /**</span>
 <span class="s0">* Sets the color scale component of the transform</span>
 <span class="s0">*/ 6 4 this 3 3894  2 sx 1 3598  2 sy 1 3598  2 sz 1 3598  2 sa 1 3598  8 priority 5 3593  </span>
<span class="s0">697 0 0 4 773 3812 0 0 138 /**</span>
 <span class="s0">* multiplies the color scale component of the transform, with previous color</span>
 <span class="s0">* scale leaving translation and rotation untouched.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 scale 1 3880  8 priority 5 3593  </span>
<span class="s0">698 0 0 4 773 3812 0 0 58 /**</span>
 <span class="s0">* Sets the color scale component of the transform</span>
 <span class="s0">*/ 6 4 this 3 3894  2 sx 1 3598  2 sy 1 3598  2 sz 1 3598  2 sa 1 3598  8 priority 5 3593  </span>
<span class="s0">699 0 0 4 774 3812 0 0 533 /**</span>
 <span class="s0">* Disables any color scale attribute inherited from above.  This is not the</span>
 <span class="s0">* same thing as clear_color_scale(), which undoes any previous</span>
 <span class="s0">* set_color_scale() operation on this node; rather, this actively disables</span>
 <span class="s0">* any set_color_scale() that might be inherited from a parent node.  This</span>
 <span class="s0">* also disables set_alpha_scale() at the same time.</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal to specify a new color scale on the same node with a subsequent</span>
 <span class="s0">* call to set_color_scale() or set_alpha_scale(); this new scale will apply</span>
 <span class="s0">* to lower geometry.</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">700 0 0 4 775 3812 0 0 176 /**</span>
 <span class="s0">* Sets the alpha scale component of the transform without (much) affecting</span>
 <span class="s0">* the color scale.  Note that any priority specified will also apply to the</span>
 <span class="s0">* color scale.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 scale 1 3598  8 priority 5 3593  </span>
<span class="s0">701 0 0 4 776 3812 0 0 206 /**</span>
 <span class="s0">* Scales all the color components of the object by the same amount, darkening</span>
 <span class="s0">* the object, without (much) affecting alpha.  Note that any priority</span>
 <span class="s0">* specified will also apply to the alpha scale.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 scale 1 3598  8 priority 5 3593  </span>
<span class="s0">702 0 0 4 777 3812 0 0 79 /**</span>
 <span class="s0">* Sets the red component of the color scale.</span>
 <span class="s0">* @see set_color_scale()</span>
 <span class="s0">*/ 2 4 this 3 3894  2 sr 1 3598  </span>
<span class="s0">703 0 0 4 778 3812 0 0 81 /**</span>
 <span class="s0">* Sets the green component of the color scale.</span>
 <span class="s0">* @see set_color_scale()</span>
 <span class="s0">*/ 2 4 this 3 3894  2 sg 1 3598  </span>
<span class="s0">704 0 0 4 779 3812 0 0 80 /**</span>
 <span class="s0">* Sets the blue component of the color scale.</span>
 <span class="s0">* @see set_color_scale()</span>
 <span class="s0">*/ 2 4 this 3 3894  2 sb 1 3598  </span>
<span class="s0">705 0 0 4 780 3812 0 0 81 /**</span>
 <span class="s0">* Sets the alpha component of the color scale.</span>
 <span class="s0">* @see set_color_scale()</span>
 <span class="s0">*/ 2 4 this 3 3894  2 sa 1 3598  </span>
<span class="s0">706 0 0 6 781 3880 0 0 234 /**</span>
 <span class="s0">* Returns the complete color scale vector that has been applied to this node</span>
 <span class="s0">* via a previous call to set_color_scale() and/or set_alpha_scale(), or all</span>
 <span class="s0">* 1's (identity) if no scale has been applied to this particular node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">707 0 0 6 782 3598 0 0 79 /**</span>
 <span class="s0">* Gets the red component of the color scale.</span>
 <span class="s0">* @see get_color_scale()</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">708 0 0 6 783 3598 0 0 81 /**</span>
 <span class="s0">* Gets the green component of the color scale.</span>
 <span class="s0">* @see get_color_scale()</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">709 0 0 6 784 3598 0 0 80 /**</span>
 <span class="s0">* Gets the blue component of the color scale.</span>
 <span class="s0">* @see get_color_scale()</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">710 0 0 6 785 3598 0 0 81 /**</span>
 <span class="s0">* Gets the alpha component of the color scale.</span>
 <span class="s0">* @see get_color_scale()</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">711 0 0 4 786 3812 0 0 309 /**</span>
 <span class="s0">* Adds the indicated Light or PolylightNode to the list of lights that</span>
 <span class="s0">* illuminate geometry at this node and below.  The light itself should be</span>
 <span class="s0">* parented into the scene graph elsewhere, to represent the light's position</span>
 <span class="s0">* in space; but until set_light() is called it will illuminate no geometry.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 light 1 3884  8 priority 5 3593  </span>
<span class="s0">712 0 0 4 787 3812 0 0 396 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render without using the</span>
 <span class="s0">* indicated Light.  This is different from not specifying the Light; rather,</span>
 <span class="s0">* this specifically contradicts set_light() at a higher node level (or, with</span>
 <span class="s0">* a priority, overrides a set_light() at a lower level).</span>
 <span class="s0">*</span>
 <span class="s0">* This interface does not support PolylightNodes, which cannot be turned off</span>
 <span class="s0">* at a lower level.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 light 1 3884  8 priority 5 3593  </span>
<span class="s0">713 0 0 4 787 3812 0 0 401 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no lights at all.</span>
 <span class="s0">* This is different from not specifying a light; rather, this specifically</span>
 <span class="s0">* contradicts set_light() at a higher node level (or, with a priority,</span>
 <span class="s0">* overrides a set_light() at a lower level).</span>
 <span class="s0">*</span>
 <span class="s0">* If no lights are in effect on a particular piece of geometry, that geometry</span>
 <span class="s0">* is rendered with lighting disabled.</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">714 0 0 4 788 3812 0 0 141 /**</span>
 <span class="s0">* Completely removes any lighting operations that may have been set via</span>
 <span class="s0">* set_light() or set_light_off() from this particular node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">715 0 0 4 788 3812 0 0 94 /**</span>
 <span class="s0">* Removes any reference to the indicated Light or PolylightNode from the</span>
 <span class="s0">* NodePath.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 light 1 3884  </span>
<span class="s0">716 0 0 6 789 3600 0 0 207 /**</span>
 <span class="s0">* Returns true if the indicated Light or PolylightNode has been specifically</span>
 <span class="s0">* enabled on this particular node.  This means that someone called</span>
 <span class="s0">* set_light() on this node with the indicated light.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 light 1 3884  </span>
<span class="s0">717 0 0 6 790 3600 0 0 181 /**</span>
 <span class="s0">* Returns true if all Lights have been specifically disabled on this</span>
 <span class="s0">* particular node.  This means that someone called set_light_off() on this</span>
 <span class="s0">* node with no parameters.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">718 0 0 6 790 3600 0 0 297 /**</span>
 <span class="s0">* Returns true if the indicated Light has been specifically disabled on this</span>
 <span class="s0">* particular node.  This means that someone called set_light_off() on this</span>
 <span class="s0">* node with the indicated light.</span>
 <span class="s0">*</span>
 <span class="s0">* This interface does not support PolylightNodes, which cannot be turned off</span>
 <span class="s0">* at a lower level.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 light 1 3884  </span>
<span class="s0">719 0 0 4 791 3812 0 0 324 /**</span>
 <span class="s0">* Adds the indicated clipping plane to the list of planes that apply to</span>
 <span class="s0">* geometry at this node and below.  The clipping plane itself, a PlaneNode,</span>
 <span class="s0">* should be parented into the scene graph elsewhere, to represent the plane's</span>
 <span class="s0">* position in space; but until set_clip_plane() is called it will clip no</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/ 3 4 this 3 3894  10 clip_plane 1 3884  8 priority 5 3593  </span>
<span class="s0">720 0 0 4 792 3812 0 0 326 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render without being clipped</span>
 <span class="s0">* by the indicated PlaneNode.  This is different from not specifying the</span>
 <span class="s0">* PlaneNode; rather, this specifically contradicts set_clip_plane() at a</span>
 <span class="s0">* higher node level (or, with a priority, overrides a set_clip_plane() at a</span>
 <span class="s0">* lower level).</span>
 <span class="s0">*/ 3 4 this 3 3894  10 clip_plane 1 3884  8 priority 5 3593  </span>
<span class="s0">721 0 0 4 792 3812 0 0 465 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no clip_planes at</span>
 <span class="s0">* all.  This is different from not specifying a clip_plane; rather, this</span>
 <span class="s0">* specifically contradicts set_clip_plane() at a higher node level (or, with</span>
 <span class="s0">* a priority, overrides a set_clip_plane() at a lower level).</span>
 <span class="s0">*</span>
 <span class="s0">* If no clip_planes are in effect on a particular piece of geometry, that</span>
 <span class="s0">* geometry is rendered without being clipped (other than by the viewing</span>
 <span class="s0">* frustum).</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">722 0 0 4 793 3812 0 0 143 /**</span>
 <span class="s0">* Completely removes any clip planes that may have been set via</span>
 <span class="s0">* set_clip_plane() or set_clip_plane_off() from this particular node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">723 0 0 4 793 3812 0 0 83 /**</span>
 <span class="s0">* Removes any reference to the indicated clipping plane from the NodePath.</span>
 <span class="s0">*/ 2 4 this 3 3894  10 clip_plane 1 3884  </span>
<span class="s0">724 0 0 6 794 3600 0 0 209 /**</span>
 <span class="s0">* Returns true if the indicated clipping plane has been specifically applied</span>
 <span class="s0">* to this particular node.  This means that someone called set_clip_plane()</span>
 <span class="s0">* on this node with the indicated clip_plane.</span>
 <span class="s0">*/ 2 4 this 3 3884  10 clip_plane 1 3884  </span>
<span class="s0">725 0 0 6 795 3600 0 0 195 /**</span>
 <span class="s0">* Returns true if all clipping planes have been specifically disabled on this</span>
 <span class="s0">* particular node.  This means that someone called set_clip_plane_off() on</span>
 <span class="s0">* this node with no parameters.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">726 0 0 6 795 3600 0 0 214 /**</span>
 <span class="s0">* Returns true if the indicated clipping plane has been specifically disabled</span>
 <span class="s0">* on this particular node.  This means that someone called</span>
 <span class="s0">* set_clip_plane_off() on this node with the indicated clip_plane.</span>
 <span class="s0">*/ 2 4 this 3 3884  10 clip_plane 1 3884  </span>
<span class="s0">727 0 0 4 796 3812 0 0 280 /**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The two points are understood to be relative to this node.  When these</span>
 <span class="s0">* points are projected into screen space, they define the diagonally-opposite</span>
 <span class="s0">* points that determine the scissor region.</span>
 <span class="s0">*/ 3 4 this 3 3894  1 a 1 3809  1 b 1 3809  </span>
<span class="s0">728 0 0 4 796 3812 0 0 347 /**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The four points are understood to be relative to this node.  When these</span>
 <span class="s0">* points are projected into screen space, they define the bounding volume of</span>
 <span class="s0">* the scissor region (the scissor region is the smallest onscreen rectangle</span>
 <span class="s0">* that encloses all four points).</span>
 <span class="s0">*/ 5 4 this 3 3894  1 a 1 3809  1 b 1 3809  1 c 1 3809  1 d 1 3809  </span>
<span class="s0">729 0 0 4 796 3812 0 0 294 /**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The two points are understood to be relative to the indicated other node.</span>
 <span class="s0">* When these points are projected into screen space, they define the</span>
 <span class="s0">* diagonally-opposite points that determine the scissor region.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  1 a 1 3809  1 b 1 3809  </span>
<span class="s0">730 0 0 4 796 3812 0 0 361 /**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The four points are understood to be relative to the indicated other node.</span>
 <span class="s0">* When these points are projected into screen space, they define the bounding</span>
 <span class="s0">* volume of the scissor region (the scissor region is the smallest onscreen</span>
 <span class="s0">* rectangle that encloses all four points).</span>
 <span class="s0">*/ 6 4 this 3 3894  5 other 1 3884  1 a 1 3809  1 b 1 3809  1 c 1 3809  1 d 1 3809  </span>
<span class="s0">731 0 0 4 796 3812 0 0 322 /**</span>
 <span class="s0">* Sets up a scissor region on the nodes rendered at this level and below.</span>
 <span class="s0">* The four coordinates are understood to define a rectangle in screen space.</span>
 <span class="s0">* These numbers are relative to the current DisplayRegion, where (0,0) is the</span>
 <span class="s0">* lower-left corner of the DisplayRegion, and (1,1) is the upper-right</span>
 <span class="s0">* corner.</span>
 <span class="s0">*/ 5 4 this 3 3894  4 left 1 3598  5 right 1 3598  6 bottom 1 3598  3 top 1 3598  </span>
<span class="s0">732 0 0 4 797 3812 0 0 113 /**</span>
 <span class="s0">* Removes the scissor region that was defined at this node level by a</span>
 <span class="s0">* previous call to set_scissor().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">733 0 0 6 798 3600 0 0 325 /**</span>
 <span class="s0">* Returns true if a scissor region was defined at this node by a previous</span>
 <span class="s0">* call to set_scissor().  This does not check for scissor regions inherited</span>
 <span class="s0">* from a parent class.  It also does not check for the presence of a low-</span>
 <span class="s0">* level ScissorAttrib, which is different from the ScissorEffect added by</span>
 <span class="s0">* set_scissor.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">734 0 0 4 799 3812 0 0 320 /**</span>
 <span class="s0">* Adds the indicated occluder to the list of occluders that apply to geometry</span>
 <span class="s0">* at this node and below.  The occluder itself, an OccluderNode, should be</span>
 <span class="s0">* parented into the scene graph elsewhere, to represent the occluder's</span>
 <span class="s0">* position in space; but until set_occluder() is called it will clip no</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/ 2 4 this 3 3894  8 occluder 1 3884  </span>
<span class="s0">735 0 0 4 800 3812 0 0 115 /**</span>
 <span class="s0">* Completely removes any occluders that may have been set via set_occluder()</span>
 <span class="s0">* from this particular node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">736 0 0 4 800 3812 0 0 77 /**</span>
 <span class="s0">* Removes any reference to the indicated occluder from the NodePath.</span>
 <span class="s0">*/ 2 4 this 3 3894  8 occluder 1 3884  </span>
<span class="s0">737 0 0 6 801 3600 0 0 199 /**</span>
 <span class="s0">* Returns true if the indicated occluder has been specifically applied to</span>
 <span class="s0">* this particular node.  This means that someone called set_occluder() on</span>
 <span class="s0">* this node with the indicated occluder.</span>
 <span class="s0">*/ 2 4 this 3 3884  8 occluder 1 3884  </span>
<span class="s0">738 0 0 4 802 3812 0 0 884 /**</span>
 <span class="s0">* Assigns the geometry at this level and below to the named rendering bin.</span>
 <span class="s0">* It is the user's responsibility to ensure that such a bin already exists,</span>
 <span class="s0">* either via the cull-bin Configrc variable, or by explicitly creating a</span>
 <span class="s0">* GeomBin of the appropriate type at runtime.</span>
 <span class="s0">*</span>
 <span class="s0">* There are two default bins created when Panda is started: &quot;default&quot; and</span>
 <span class="s0">* &quot;fixed&quot;.  Normally, all geometry is assigned to &quot;default&quot; unless specified</span>
 <span class="s0">* otherwise.  This bin renders opaque geometry in state-sorted order,</span>
 <span class="s0">* followed by transparent geometry sorted back-to-front.  If any geometry is</span>
 <span class="s0">* assigned to &quot;fixed&quot;, this will be rendered following all the geometry in</span>
 <span class="s0">* &quot;default&quot;, in the order specified by draw_order for each piece of geometry</span>
 <span class="s0">* so assigned.</span>
 <span class="s0">*</span>
 <span class="s0">* The draw_order parameter is meaningful only for GeomBinFixed type bins,</span>
 <span class="s0">* e.g.  &quot;fixed&quot;.  Other kinds of bins ignore it.</span>
 <span class="s0">*/ 4 4 this 3 3894  8 bin_name 1 3841  10 draw_order 1 3593  8 priority 5 3593  </span>
<span class="s0">739 0 0 4 803 3812 0 0 115 /**</span>
 <span class="s0">* Completely removes any bin adjustment that may have been set via set_bin()</span>
 <span class="s0">* from this particular node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">740 0 0 6 804 3600 0 0 122 /**</span>
 <span class="s0">* Returns true if the node has been assigned to the a particular rendering</span>
 <span class="s0">* bin via set_bin(), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">741 0 0 6 805 3841 0 0 175 /**</span>
 <span class="s0">* Returns the name of the bin that this particular node was assigned to via</span>
 <span class="s0">* set_bin(), or the empty string if no bin was assigned.  See set_bin() and</span>
 <span class="s0">* has_bin().</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">742 0 0 6 806 3593 0 0 182 /**</span>
 <span class="s0">* Returns the drawing order associated with the bin that this particular node</span>
 <span class="s0">* was assigned to via set_bin(), or 0 if no bin was assigned.  See set_bin()</span>
 <span class="s0">* and has_bin().</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">743 0 0 4 807 3812 0 0 558 /**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the default texture stage.</span>
 <span class="s0">*</span>
 <span class="s0">* The given sampler state will override the sampling settings on the texture</span>
 <span class="s0">* itself.  Note that this method makes a copy of the sampler settings that</span>
 <span class="s0">* you give; further changes to this object will not be reflected.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the convenience single-texture variant of this method; it is now</span>
 <span class="s0">* superceded by set_texture() that accepts a stage and texture.  You may use</span>
 <span class="s0">* this method if you just want to adjust the default stage.</span>
 <span class="s0">*/ 4 4 this 3 3894  3 tex 1 3755  7 sampler 1 3877  8 priority 5 3593  </span>
<span class="s0">744 0 0 4 807 3812 0 0 334 /**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the default texture stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the convenience single-texture variant of this method; it is now</span>
 <span class="s0">* superceded by set_texture() that accepts a stage and texture.  You may use</span>
 <span class="s0">* this method if you just want to adjust the default stage.</span>
 <span class="s0">*/ 3 4 this 3 3894  3 tex 1 3755  8 priority 5 3593  </span>
<span class="s0">745 0 0 4 807 3812 0 0 583 /**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the indicated multitexture stage.  If there are multiple texture stages</span>
 <span class="s0">* specified (possibly on multiple different nodes at different levels), they</span>
 <span class="s0">* will all be applied to geometry together, according to the stage</span>
 <span class="s0">* specification set up in the TextureStage object.</span>
 <span class="s0">*</span>
 <span class="s0">* The given sampler state will override the sampling settings on the texture</span>
 <span class="s0">* itself.  Note that this method makes a copy of the sampler settings that</span>
 <span class="s0">* you give; further changes to this object will not be reflected.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 stage 1 3753  3 tex 1 3755  7 sampler 1 3877  8 priority 5 3593  </span>
<span class="s0">746 0 0 4 807 3812 0 0 359 /**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the indicated multitexture stage.  If there are multiple texture stages</span>
 <span class="s0">* specified (possibly on multiple different nodes at different levels), they</span>
 <span class="s0">* will all be applied to geometry together, according to the stage</span>
 <span class="s0">* specification set up in the TextureStage object.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 stage 1 3753  3 tex 1 3755  8 priority 5 3593  </span>
<span class="s0">747 0 0 4 808 3812 0 0 305 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no texture, on</span>
 <span class="s0">* the indicated stage.  This is different from not specifying a texture;</span>
 <span class="s0">* rather, this specifically contradicts set_texture() at a higher node level</span>
 <span class="s0">* (or, with a priority, overrides a set_texture() at a lower level).</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  8 priority 5 3593  </span>
<span class="s0">748 0 0 4 808 3812 0 0 295 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no texture, on</span>
 <span class="s0">* any stage.  This is different from not specifying a texture; rather, this</span>
 <span class="s0">* specifically contradicts set_texture() at a higher node level (or, with a</span>
 <span class="s0">* priority, overrides a set_texture() at a lower level).</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">749 0 0 4 809 3812 0 0 240 /**</span>
 <span class="s0">* Completely removes any texture adjustment that may have been set via</span>
 <span class="s0">* set_texture() or set_texture_off() from this particular node.  This allows</span>
 <span class="s0">* whatever textures might be otherwise affecting the geometry to show</span>
 <span class="s0">* instead.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">750 0 0 4 809 3812 0 0 82 /**</span>
 <span class="s0">* Removes any reference to the indicated texture stage from the NodePath.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 stage 1 3753  </span>
<span class="s0">751 0 0 6 810 3600 0 0 293 /**</span>
 <span class="s0">* Returns true if a texture has been applied to this particular node via</span>
 <span class="s0">* set_texture(), false otherwise.  This is not the same thing as asking</span>
 <span class="s0">* whether the geometry at this node will be rendered with texturing, as there</span>
 <span class="s0">* may be a texture in effect from a higher or lower level.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">752 0 0 6 810 3600 0 0 306 /**</span>
 <span class="s0">* Returns true if texturing has been specifically enabled on this particular</span>
 <span class="s0">* node for the indicated stage.  This means that someone called set_texture()</span>
 <span class="s0">* on this node with the indicated stage name, or the stage_name is the</span>
 <span class="s0">* default stage_name, and someone called set_texture() on this node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">753 0 0 6 811 3600 0 0 307 /**</span>
 <span class="s0">* Returns true if texturing has been specifically disabled on this particular</span>
 <span class="s0">* node via set_texture_off(), false otherwise.  This is not the same thing as</span>
 <span class="s0">* asking whether the geometry at this node will be rendered untextured, as</span>
 <span class="s0">* there may be a texture in effect from a higher or lower level.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">754 0 0 6 811 3600 0 0 295 /**</span>
 <span class="s0">* Returns true if texturing has been specifically disabled on this particular</span>
 <span class="s0">* node for the indicated stage.  This means that someone called</span>
 <span class="s0">* set_texture_off() on this node with the indicated stage name, or that</span>
 <span class="s0">* someone called set_texture_off() on this node to remove all stages.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">755 0 0 7 812 3755 0 0 318 /**</span>
 <span class="s0">* Returns the base-level texture that has been set on this particular node,</span>
 <span class="s0">* or NULL if no texture has been set.  This is not necessarily the texture</span>
 <span class="s0">* that will be applied to the geometry at or below this level, as another</span>
 <span class="s0">* texture at a higher or lower level may override.</span>
 <span class="s0">*</span>
 <span class="s0">* See also find_texture().</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">756 0 0 7 812 3755 0 0 151 /**</span>
 <span class="s0">* Returns the texture that has been set on the indicated stage for this</span>
 <span class="s0">* particular node, or NULL if no texture has been set for this stage.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">757 0 0 4 813 3812 0 0 219 /**</span>
 <span class="s0">* Recursively searches the scene graph for references to the given texture,</span>
 <span class="s0">* and replaces them with the new texture.</span>
 <span class="s0">*</span>
 <span class="s0">* As of Panda3D 1.10.13, new_tex may be null to remove the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.4</span>
 <span class="s0">*/ 3 4 this 3 3894  3 tex 1 3755  7 new_tex 1 3755  </span>
<span class="s0">758 0 0 4 813 3812 0 0 46 // Let interrogate know this also accepts None 3 4 this 3 3894  3 tex 1 3755  7 new_tex 1 3906  </span>
<span class="s0">759 0 0 6 814 3877 0 0 321 /**</span>
 <span class="s0">* Returns the sampler state that has been given for the base-level texture</span>
 <span class="s0">* that has been set on this particular node.  If no sampler state was given,</span>
 <span class="s0">* this returns the texture's default sampler settings.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error to call this if there is no base-level texture applied to</span>
 <span class="s0">* this particular node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">760 0 0 6 814 3877 0 0 326 /**</span>
 <span class="s0">* Returns the sampler state that has been given for the indicated texture</span>
 <span class="s0">* stage that has been set on this particular node.  If no sampler state was</span>
 <span class="s0">* given, this returns the texture's default sampler settings.</span>
 <span class="s0">*</span>
 <span class="s0">* It is an error to call this if there is no texture set for this stage on</span>
 <span class="s0">* this particular node.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">761 0 0 4 815 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3894  3 sha 1 3771  8 priority 5 3593  </span>
<span class="s0">762 0 0 4 816 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">763 0 0 4 817 3812 0 0 51 /**</span>
 <span class="s0">* overloaded for auto shader customization</span>
 <span class="s0">*/ 3 4 this 3 3894  13 shader_switch 1 3908  8 priority 5 3593  </span>
<span class="s0">764 0 0 4 817 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">765 0 0 4 818 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">766 0 0 4 819 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 7 4 this 3 3894  2 id 1 3873  2 n1 1 3598  2 n2 1 3598  2 n3 5 3598  2 n4 5 3598  8 priority 5 3593  </span>
<span class="s0">767 0 0 36 819 3812 0 0 0 4 4 this 3 3894  6 param0 0 3873  6 param1 0 3623  8 priority 5 3593  </span>
<span class="s0">768 0 0 4 819 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 3894  2 id 1 3873  3 tex 1 3755  7 sampler 1 3877  8 priority 5 3593  </span>
<span class="s0">769 0 0 4 819 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 8 4 this 3 3894  2 id 1 3873  3 tex 1 3755  4 read 1 3600  5 write 1 3600  1 z 5 3593  1 n 5 3593  8 priority 5 3593  </span>
<span class="s0">770 0 0 4 819 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 7 4 this 3 3894  2 id 1 3873  2 n1 1 3593  2 n2 1 3593  2 n3 5 3593  2 n4 5 3593  8 priority 5 3593  </span>
<span class="s0">771 0 0 4 819 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3894  5 input 1 3878  </span>
<span class="s0">772 0 0 36 820 3812 0 0 0 3 4 this 3 3894  4 args 1 3623  6 kwargs 1 3623  </span>
<span class="s0">773 0 0 4 821 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3894  2 id 1 3873  </span>
<span class="s0">774 0 0 4 822 3812 0 0 174 /**</span>
 <span class="s0">* Sets the geometry instance count, or 0 if geometry instancing should be</span>
 <span class="s0">* disabled.  Do not confuse with instanceTo which only applies to animation</span>
 <span class="s0">* instancing.</span>
 <span class="s0">*/ 2 4 this 3 3894  14 instance_count 1 3593  </span>
<span class="s0">775 0 0 7 823 3771 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">776 0 0 7 824 3876 2285 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3884  2 id 1 3873  </span>
<span class="s0">777 0 0 6 825 3593 0 0 93 /**</span>
 <span class="s0">* Returns the geometry instance count, or 0 if disabled.  See</span>
 <span class="s0">* set_instance_count.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">778 0 0 4 826 3812 0 0 105 /**</span>
 <span class="s0">* Sets the texture matrix on the current node to the indicated transform for</span>
 <span class="s0">* the given stage.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 stage 1 3753  9 transform 1 3794  </span>
<span class="s0">779 0 0 4 826 3812 0 0 105 /**</span>
 <span class="s0">* Sets the texture matrix on the current node to the indicated transform for</span>
 <span class="s0">* the given stage.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  9 transform 1 3794  </span>
<span class="s0">780 0 0 4 827 3812 0 0 62 /**</span>
 <span class="s0">* Removes all texture matrices from the current node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">781 0 0 4 827 3812 0 0 78 /**</span>
 <span class="s0">* Removes the texture matrix on the current node for the given stage.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 stage 1 3753  </span>
<span class="s0">782 0 0 6 828 3600 0 0 106 /**</span>
 <span class="s0">* Returns true if there is an explicit texture matrix on the current node for</span>
 <span class="s0">* the given stage.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">783 0 0 7 829 3794 0 0 109 /**</span>
 <span class="s0">* Returns the texture matrix on the current node for the given stage,</span>
 <span class="s0">* relative to the other node.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  5 stage 1 3753  </span>
<span class="s0">784 0 0 7 829 3794 0 0 165 /**</span>
 <span class="s0">* Returns the texture matrix on the current node for the given stage, or</span>
 <span class="s0">* identity transform if there is no explicit transform set for the given</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">785 0 0 4 830 3812 0 0 183 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 stage 1 3753  2 uv 1 3801  </span>
<span class="s0">786 0 0 4 830 3812 0 0 183 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  5 stage 1 3753  1 u 1 3598  1 v 1 3598  </span>
<span class="s0">787 0 0 4 830 3812 0 0 183 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  2 uv 1 3801  </span>
<span class="s0">788 0 0 4 830 3812 0 0 183 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 stage 1 3753  1 u 1 3598  1 v 1 3598  </span>
<span class="s0">789 0 0 4 831 3812 0 0 208 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* clockwise in degrees, to UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 stage 1 3753  1 r 1 3598  </span>
<span class="s0">790 0 0 4 831 3812 0 0 208 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* clockwise in degrees, to UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  1 r 1 3598  </span>
<span class="s0">791 0 0 4 832 3812 0 0 182 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 stage 1 3753  5 scale 1 3801  </span>
<span class="s0">792 0 0 4 832 3812 0 0 174 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 stage 1 3753  5 scale 1 3798  </span>
<span class="s0">793 0 0 4 832 3812 0 0 180 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 2-d or 3-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 stage 1 3753  5 scale 1 3598  </span>
<span class="s0">794 0 0 4 832 3812 0 0 182 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 other 1 3884  5 stage 1 3753  2 su 1 3598  2 sv 1 3598  </span>
<span class="s0">795 0 0 4 832 3812 0 0 174 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 6 4 this 3 3894  5 other 1 3884  5 stage 1 3753  2 su 1 3598  2 sv 1 3598  2 sw 1 3598  </span>
<span class="s0">796 0 0 4 832 3812 0 0 182 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  5 scale 1 3801  </span>
<span class="s0">797 0 0 4 832 3812 0 0 174 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  5 scale 1 3798  </span>
<span class="s0">798 0 0 4 832 3812 0 0 181 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 2-d or 3-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  5 scale 1 3598  </span>
<span class="s0">799 0 0 4 832 3812 0 0 182 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UV's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 stage 1 3753  2 su 1 3598  2 sv 1 3598  </span>
<span class="s0">800 0 0 4 832 3812 0 0 174 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated scale to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 stage 1 3753  2 su 1 3598  2 sv 1 3598  2 sw 1 3598  </span>
<span class="s0">801 0 0 7 833 3810 0 0 159 /**</span>
 <span class="s0">* Returns the offset set for the UV's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  5 stage 1 3753  </span>
<span class="s0">802 0 0 7 833 3810 0 0 159 /**</span>
 <span class="s0">* Returns the offset set for the UV's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">803 0 0 6 834 3598 0 0 161 /**</span>
 <span class="s0">* Returns the rotation set for the UV's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  5 stage 1 3753  </span>
<span class="s0">804 0 0 6 834 3598 0 0 161 /**</span>
 <span class="s0">* Returns the rotation set for the UV's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">805 0 0 7 835 3810 0 0 155 /**</span>
 <span class="s0">* Returns the scale set for the UV's for the given stage on the current node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  5 stage 1 3753  </span>
<span class="s0">806 0 0 7 835 3810 0 0 155 /**</span>
 <span class="s0">* Returns the scale set for the UV's for the given stage on the current node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for ordinary 2-d texture coordinates.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">807 0 0 4 836 3812 0 0 175 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 stage 1 3753  3 uvw 1 3798  </span>
<span class="s0">808 0 0 4 836 3812 0 0 175 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 6 4 this 3 3894  5 other 1 3884  5 stage 1 3753  1 u 1 3598  1 v 1 3598  1 w 1 3598  </span>
<span class="s0">809 0 0 4 836 3812 0 0 175 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  3 uvw 1 3798  </span>
<span class="s0">810 0 0 4 836 3812 0 0 175 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated offset to</span>
 <span class="s0">* UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 stage 1 3753  1 u 1 3598  1 v 1 3598  1 w 1 3598  </span>
<span class="s0">811 0 0 4 837 3812 0 0 192 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* as a 3-D HPR, to UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 other 1 3884  5 stage 1 3753  3 hpr 1 3798  </span>
<span class="s0">812 0 0 4 837 3812 0 0 192 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* as a 3-D HPR, to UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 6 4 this 3 3894  5 other 1 3884  5 stage 1 3753  1 h 1 3598  1 p 1 3598  1 r 1 3598  </span>
<span class="s0">813 0 0 4 837 3812 0 0 192 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* as a 3-D HPR, to UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3894  5 stage 1 3753  3 hpr 1 3798  </span>
<span class="s0">814 0 0 4 837 3812 0 0 192 /**</span>
 <span class="s0">* Sets a texture matrix on the current node to apply the indicated rotation,</span>
 <span class="s0">* as a 3-D HPR, to UVW's for the given stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 stage 1 3753  1 h 1 3598  1 p 1 3598  1 r 1 3598  </span>
<span class="s0">815 0 0 7 838 3900 0 0 151 /**</span>
 <span class="s0">* Returns the offset set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  5 stage 1 3753  </span>
<span class="s0">816 0 0 7 838 3900 0 0 151 /**</span>
 <span class="s0">* Returns the offset set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">817 0 0 7 839 3900 0 0 152 /**</span>
 <span class="s0">* Returns the 3-D HPR set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  5 stage 1 3753  </span>
<span class="s0">818 0 0 7 839 3900 0 0 152 /**</span>
 <span class="s0">* Returns the 3-D HPR set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">819 0 0 7 840 3900 0 0 150 /**</span>
 <span class="s0">* Returns the scale set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 3 4 this 3 3884  5 other 1 3884  5 stage 1 3753  </span>
<span class="s0">820 0 0 7 840 3900 0 0 150 /**</span>
 <span class="s0">* Returns the scale set for the UVW's for the given stage on the current</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* This call is appropriate for 3-d texture coordinates.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">821 0 0 4 841 3812 0 0 213 /**</span>
 <span class="s0">* Enables automatic texture coordinate generation for the indicated texture</span>
 <span class="s0">* stage.  This version of this method is useful when setting M_constant,</span>
 <span class="s0">* which requires a constant texture coordinate value.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 stage 1 3753  4 mode 1 3595  14 constant_value 1 3909  8 priority 5 3593  </span>
<span class="s0">822 0 0 4 841 3812 0 0 94 /**</span>
 <span class="s0">* Enables automatic texture coordinate generation for the indicated texture</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 stage 1 3753  4 mode 1 3595  8 priority 5 3593  </span>
<span class="s0">823 0 0 4 842 3812 0 0 98 /**</span>
 <span class="s0">* Removes the texture coordinate generation mode from all texture stages on</span>
 <span class="s0">* this node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">824 0 0 4 842 3812 0 0 95 /**</span>
 <span class="s0">* Disables automatic texture coordinate generation for the indicated texture</span>
 <span class="s0">* stage.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 stage 1 3753  </span>
<span class="s0">825 0 0 6 843 3600 0 0 130 /**</span>
 <span class="s0">* Returns true if there is a mode for automatic texture coordinate generation</span>
 <span class="s0">* on the current node for the given stage.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">826 0 0 6 844 3595 0 0 144 /**</span>
 <span class="s0">* Returns the texture coordinate generation mode for the given stage, or</span>
 <span class="s0">* M_off if there is no explicit mode set for the given stage.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">827 0 0 4 845 3812 0 0 529 /**</span>
 <span class="s0">* Establishes a TexProjectorEffect on this node, which can be used to</span>
 <span class="s0">* establish projective texturing (but see also the</span>
 <span class="s0">* NodePath::project_texture() convenience function), or it can be used to</span>
 <span class="s0">* bind this node's texture transform to particular node's position in space,</span>
 <span class="s0">* allowing a LerpInterval (for instance) to adjust this node's texture</span>
 <span class="s0">* coordinates.</span>
 <span class="s0">*</span>
 <span class="s0">* If to is a LensNode, then the fourth parameter, lens_index, can be provided</span>
 <span class="s0">* to select a particular lens to apply.  Otherwise lens_index is not used.</span>
 <span class="s0">*/ 5 4 this 3 3894  5 stage 1 3753  4 from 1 3884  2 to 1 3884  10 lens_index 5 3593  </span>
<span class="s0">828 0 0 4 846 3812 0 0 72 /**</span>
 <span class="s0">* Removes the TexProjectorEffect for all stages from this node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">829 0 0 4 846 3812 0 0 81 /**</span>
 <span class="s0">* Removes the TexProjectorEffect for the indicated stage from this node.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 stage 1 3753  </span>
<span class="s0">830 0 0 6 847 3600 0 0 106 /**</span>
 <span class="s0">* Returns true if this node has a TexProjectorEffect for the indicated stage,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">831 0 0 7 848 3894 2739 0 227 /**</span>
 <span class="s0">* Returns the &quot;from&quot; node associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  The relative transform between the &quot;from&quot; and the &quot;to&quot;</span>
 <span class="s0">* nodes is automatically applied to the texture transform each frame.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">832 0 0 7 849 3894 2739 0 225 /**</span>
 <span class="s0">* Returns the &quot;to&quot; node associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  The relative transform between the &quot;from&quot; and the &quot;to&quot;</span>
 <span class="s0">* nodes is automatically applied to the texture transform each frame.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">833 0 0 4 850 3812 0 0 181 /**</span>
 <span class="s0">* A convenience function to enable projective texturing at this node level</span>
 <span class="s0">* and below, using the indicated NodePath (which should contain a LensNode)</span>
 <span class="s0">* as the projector.</span>
 <span class="s0">*/ 4 4 this 3 3894  5 stage 1 3753  3 tex 1 3755  9 projector 1 3884  </span>
<span class="s0">834 0 0 4 851 3812 0 0 50 /**</span>
 <span class="s0">* Undoes the effect of project_texture().</span>
 <span class="s0">*/ 2 4 this 3 3894  5 stage 1 3753  </span>
<span class="s0">835 0 0 6 852 3600 0 0 211 /**</span>
 <span class="s0">* Returns true if there are at least some vertices at this node and below</span>
 <span class="s0">* that use the named texture coordinate set, false otherwise.  Pass the empty</span>
 <span class="s0">* string for the default texture coordinate set.</span>
 <span class="s0">*/ 2 4 this 3 3884  13 texcoord_name 1 3841  </span>
<span class="s0">836 0 0 6 853 3600 0 0 309 /**</span>
 <span class="s0">* Returns true if there are at least some vertices at this node and below</span>
 <span class="s0">* that contain a reference to the indicated vertex data column name, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* This is particularly useful for testing whether a particular model has a</span>
 <span class="s0">* given texture coordinate set (but see has_texcoord()).</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3873  </span>
<span class="s0">837 0 0 7 854 3885 2288 0 116 /**</span>
 <span class="s0">* Returns a list of all vertex array columns stored on some geometry found at</span>
 <span class="s0">* this node level and below.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">838 0 0 7 854 3885 2288 0 189 /**</span>
 <span class="s0">* Returns a list of all vertex array columns stored on some geometry found at</span>
 <span class="s0">* this node level and below that match the indicated name (which may contain</span>
 <span class="s0">* wildcard characters).</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3841  </span>
<span class="s0">839 0 0 7 855 3885 2288 0 110 /**</span>
 <span class="s0">* Returns a list of all texture coordinate sets used by any geometry at this</span>
 <span class="s0">* node level and below.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">840 0 0 7 855 3885 2288 0 183 /**</span>
 <span class="s0">* Returns a list of all texture coordinate sets used by any geometry at this</span>
 <span class="s0">* node level and below that match the indicated name (which may contain</span>
 <span class="s0">* wildcard characters).</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3841  </span>
<span class="s0">841 0 0 7 856 3755 0 0 198 /**</span>
 <span class="s0">* Returns the first texture found applied to geometry at this node or below</span>
 <span class="s0">* that is assigned to the indicated texture stage.  Returns the texture if it</span>
 <span class="s0">* is found, or NULL if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">842 0 0 7 856 3755 0 0 212 /**</span>
 <span class="s0">* Returns the first texture found applied to geometry at this node or below</span>
 <span class="s0">* that matches the indicated name (which may contain wildcards).  Returns the</span>
 <span class="s0">* texture if it is found, or NULL if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3841  </span>
<span class="s0">843 0 0 7 857 3914 0 0 83 /**</span>
 <span class="s0">* Returns a list of a textures applied to geometry at this node and below.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">844 0 0 7 857 3914 0 0 127 /**</span>
 <span class="s0">* Returns a list of a textures on geometry at this node and below that are</span>
 <span class="s0">* assigned to the indicated texture stage.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 stage 1 3753  </span>
<span class="s0">845 0 0 7 857 3914 0 0 156 /**</span>
 <span class="s0">* Returns a list of a textures applied to geometry at this node and below</span>
 <span class="s0">* that match the indicated name (which may contain wildcard characters).</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3841  </span>
<span class="s0">846 0 0 7 858 3753 0 0 221 /**</span>
 <span class="s0">* Returns the first TextureStage found applied to geometry at this node or</span>
 <span class="s0">* below that matches the indicated name (which may contain wildcards).</span>
 <span class="s0">* Returns the TextureStage if it is found, or NULL if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3841  </span>
<span class="s0">847 0 0 7 859 3891 2325 0 91 /**</span>
 <span class="s0">* Returns a list of a TextureStages applied to geometry at this node and</span>
 <span class="s0">* below.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">848 0 0 7 859 3891 2325 0 164 /**</span>
 <span class="s0">* Returns a list of a TextureStages applied to geometry at this node and</span>
 <span class="s0">* below that match the indicated name (which may contain wildcard</span>
 <span class="s0">* characters).</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3841  </span>
<span class="s0">849 0 0 4 860 3812 0 0 323 /**</span>
 <span class="s0">* Searches through all TextureStages at this node and below.  Any</span>
 <span class="s0">* TextureStages that share the same name as the indicated TextureStage object</span>
 <span class="s0">* are replaced with this object, thus ensuring that all geometry at this node</span>
 <span class="s0">* and below with a particular TextureStage name is using the same</span>
 <span class="s0">* TextureStage object.</span>
 <span class="s0">*/ 2 4 this 3 3894  5 stage 1 3753  </span>
<span class="s0">850 0 0 7 861 3733 0 0 214 /**</span>
 <span class="s0">* Returns the first material found applied to geometry at this node or below</span>
 <span class="s0">* that matches the indicated name (which may contain wildcards).  Returns the</span>
 <span class="s0">* material if it is found, or NULL if it is not.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3841  </span>
<span class="s0">851 0 0 7 862 3888 2306 0 84 /**</span>
 <span class="s0">* Returns a list of a materials applied to geometry at this node and below.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">852 0 0 7 862 3888 2306 0 157 /**</span>
 <span class="s0">* Returns a list of a materials applied to geometry at this node and below</span>
 <span class="s0">* that match the indicated name (which may contain wildcard characters).</span>
 <span class="s0">*/ 2 4 this 3 3884  4 name 1 3841  </span>
<span class="s0">853 0 0 4 863 3812 0 0 216 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using the indicated</span>
 <span class="s0">* material.</span>
 <span class="s0">*</span>
 <span class="s0">* Previously, this operation made a copy of the material structure, but</span>
 <span class="s0">* nowadays it assigns the pointer directly.</span>
 <span class="s0">*/ 3 4 this 3 3894  3 tex 1 3733  8 priority 5 3593  </span>
<span class="s0">854 0 0 4 864 3812 0 0 275 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no material.</span>
 <span class="s0">* This is normally the default, but it may be useful to use this to</span>
 <span class="s0">* contradict set_material() at a higher node level (or, with a priority, to</span>
 <span class="s0">* override a set_material() at a lower level).</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">855 0 0 4 865 3812 0 0 125 /**</span>
 <span class="s0">* Completely removes any material adjustment that may have been set via</span>
 <span class="s0">* set_material() from this particular node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">856 0 0 6 866 3600 0 0 118 /**</span>
 <span class="s0">* Returns true if a material has been applied to this particular node via</span>
 <span class="s0">* set_material(), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">857 0 0 7 867 3733 0 0 312 /**</span>
 <span class="s0">* Returns the material that has been set on this particular node, or NULL if</span>
 <span class="s0">* no material has been set.  This is not necessarily the material that will</span>
 <span class="s0">* be applied to the geometry at or below this level, as another material at a</span>
 <span class="s0">* higher or lower level may override.</span>
 <span class="s0">*</span>
 <span class="s0">* See also find_material().</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">858 0 0 4 868 3812 0 0 222 /**</span>
 <span class="s0">* Recursively searches the scene graph for references to the given material,</span>
 <span class="s0">* and replaces them with the new material.</span>
 <span class="s0">*</span>
 <span class="s0">* As of Panda3D 1.10.13, new_mat may be null to remove the material.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 3 4 this 3 3894  3 mat 1 3733  7 new_mat 1 3733  </span>
<span class="s0">859 0 0 4 868 3812 0 0 46 // Let interrogate know this also accepts None 3 4 this 3 3894  3 mat 1 3733  7 new_mat 1 3906  </span>
<span class="s0">860 0 0 4 869 3812 0 0 90 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using the indicated</span>
 <span class="s0">* fog.</span>
 <span class="s0">*/ 3 4 this 3 3894  3 fog 1 3708  8 priority 5 3593  </span>
<span class="s0">861 0 0 4 870 3812 0 0 261 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no fog.  This is</span>
 <span class="s0">* normally the default, but it may be useful to use this to contradict</span>
 <span class="s0">* set_fog() at a higher node level (or, with a priority, to override a</span>
 <span class="s0">* set_fog() at a lower level).</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">862 0 0 4 871 3812 0 0 221 /**</span>
 <span class="s0">* Completely removes any fog adjustment that may have been set via set_fog()</span>
 <span class="s0">* or set_fog_off() from this particular node.  This allows whatever fogs</span>
 <span class="s0">* might be otherwise affecting the geometry to show instead.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">863 0 0 6 872 3600 0 0 275 /**</span>
 <span class="s0">* Returns true if a fog has been applied to this particular node via</span>
 <span class="s0">* set_fog(), false otherwise.  This is not the same thing as asking whether</span>
 <span class="s0">* the geometry at this node will be rendered with fog, as there may be a fog</span>
 <span class="s0">* in effect from a higher or lower level.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">864 0 0 6 873 3600 0 0 293 /**</span>
 <span class="s0">* Returns true if a fog has been specifically disabled on this particular</span>
 <span class="s0">* node via set_fog_off(), false otherwise.  This is not the same thing as</span>
 <span class="s0">* asking whether the geometry at this node will be rendered unfogged, as</span>
 <span class="s0">* there may be a fog in effect from a higher or lower level.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">865 0 0 7 874 3708 2131 0 260 /**</span>
 <span class="s0">* Returns the fog that has been set on this particular node, or NULL if no</span>
 <span class="s0">* fog has been set.  This is not necessarily the fog that will be applied to</span>
 <span class="s0">* the geometry at or below this level, as another fog at a higher or lower</span>
 <span class="s0">* level may override.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">866 0 0 4 875 3812 0 0 107 /**</span>
 <span class="s0">* Sets up the geometry at this level and below (unless overridden) to render</span>
 <span class="s0">* in wireframe mode.</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">867 0 0 4 876 3812 0 0 126 /**</span>
 <span class="s0">* Sets up the geometry at this level and below (unless overridden) to render</span>
 <span class="s0">* in filled (i.e.  not wireframe) mode.</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">868 0 0 4 877 3812 0 0 197 /**</span>
 <span class="s0">* Sets up the geometry at this level and below (unless overridden) to render</span>
 <span class="s0">* in filled, but overlay the wireframe on top with a fixed color.  This is</span>
 <span class="s0">* useful for debug visualizations.</span>
 <span class="s0">*/ 3 4 this 3 3894  15 wireframe_color 1 3820  8 priority 5 3593  </span>
<span class="s0">869 0 0 4 878 3812 0 0 359 /**</span>
 <span class="s0">* Sets up the point geometry at this level and below to render as thick</span>
 <span class="s0">* points (that is, billboarded quads).  The thickness is in pixels, unless</span>
 <span class="s0">* set_render_mode_perspective is also true, in which case it is in 3-D units.</span>
 <span class="s0">*</span>
 <span class="s0">* If you want the quads to be individually textured, you should also set a</span>
 <span class="s0">* TexGenAttrib::M_point_sprite on the node.</span>
 <span class="s0">*/ 3 4 this 3 3894  9 thickness 1 3598  8 priority 5 3593  </span>
<span class="s0">870 0 0 4 879 3812 0 0 461 /**</span>
 <span class="s0">* Sets up the point geometry at this level and below to render as perspective</span>
 <span class="s0">* sprites (that is, billboarded quads).  The thickness, as specified with</span>
 <span class="s0">* set_render_mode_thickness(), is the width of each point in 3-D units,</span>
 <span class="s0">* unless it is overridden on a per-vertex basis.  This does not affect</span>
 <span class="s0">* geometry other than points.</span>
 <span class="s0">*</span>
 <span class="s0">* If you want the quads to be individually textured, you should also set a</span>
 <span class="s0">* TexGenAttrib::M_point_sprite on the node.</span>
 <span class="s0">*/ 3 4 this 3 3894  11 perspective 1 3600  8 priority 5 3593  </span>
<span class="s0">871 0 0 4 880 3812 0 0 162 /**</span>
 <span class="s0">* Sets up the geometry at this level and below (unless overridden) to render</span>
 <span class="s0">* in the specified mode and with the indicated line and/or point thickness.</span>
 <span class="s0">*/ 4 4 this 3 3894  4 mode 1 3597  9 thickness 1 3598  8 priority 5 3593  </span>
<span class="s0">872 0 0 4 881 3812 0 0 156 /**</span>
 <span class="s0">* Completely removes any render mode adjustment that may have been set on</span>
 <span class="s0">* this node via set_render_mode_wireframe() or set_render_mode_filled().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">873 0 0 6 882 3600 0 0 195 /**</span>
 <span class="s0">* Returns true if a render mode has been explicitly set on this particular</span>
 <span class="s0">* node via set_render_mode() (or set_render_mode_wireframe() or</span>
 <span class="s0">* set_render_mode_filled()), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">874 0 0 6 883 3597 0 0 144 /**</span>
 <span class="s0">* Returns the render mode that has been specifically set on this node via</span>
 <span class="s0">* set_render_mode(), or M_unchanged if nothing has been set.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">875 0 0 6 884 3598 0 0 146 /**</span>
 <span class="s0">* Returns the render mode thickness that has been specifically set on this</span>
 <span class="s0">* node via set_render_mode(), or 1.0 if nothing has been set.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">876 0 0 6 885 3600 0 0 130 /**</span>
 <span class="s0">* Returns the flag that has been set on this node via</span>
 <span class="s0">* set_render_mode_perspective(), or false if no flag has been set.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">877 0 0 4 886 3812 0 0 237 /**</span>
 <span class="s0">* Specifically sets or disables two-sided rendering mode on this particular</span>
 <span class="s0">* node.  If no other nodes override, this will cause backfacing polygons to</span>
 <span class="s0">* be drawn (in two-sided mode, true) or culled (in one-sided mode, false).</span>
 <span class="s0">*/ 3 4 this 3 3894  9 two_sided 1 3600  8 priority 5 3593  </span>
<span class="s0">878 0 0 4 887 3812 0 0 336 /**</span>
 <span class="s0">* Completely removes any two-sided adjustment that may have been set on this</span>
 <span class="s0">* node via set_two_sided(). The geometry at this level and below will</span>
 <span class="s0">* subsequently be rendered either two-sided or one-sided, according to</span>
 <span class="s0">* whatever other nodes may have had set_two_sided() on it, or according to</span>
 <span class="s0">* the initial state otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">879 0 0 6 888 3600 0 0 215 /**</span>
 <span class="s0">* Returns true if a two-sided adjustment has been explicitly set on this</span>
 <span class="s0">* particular node via set_two_sided().  If this returns true, then</span>
 <span class="s0">* get_two_sided() may be called to determine which has been set.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">880 0 0 6 889 3600 0 0 378 /**</span>
 <span class="s0">* Returns true if two-sided rendering has been specifically set on this node</span>
 <span class="s0">* via set_two_sided(), or false if one-sided rendering has been specifically</span>
 <span class="s0">* set, or if nothing has been specifically set.  See also has_two_sided().</span>
 <span class="s0">* This does not necessarily imply that the geometry will or will not be</span>
 <span class="s0">* rendered two-sided, as there may be other nodes that override.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">881 0 0 4 890 3812 0 0 236 /**</span>
 <span class="s0">* Specifically sets or disables the testing of the depth buffer on this</span>
 <span class="s0">* particular node.  This is normally on in the 3-d scene graph and off in the</span>
 <span class="s0">* 2-d scene graph; it should be on for rendering most 3-d objects properly.</span>
 <span class="s0">*/ 3 4 this 3 3894  10 depth_test 1 3600  8 priority 5 3593  </span>
<span class="s0">882 0 0 4 891 3812 0 0 116 /**</span>
 <span class="s0">* Completely removes any depth-test adjustment that may have been set on this</span>
 <span class="s0">* node via set_depth_test().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">883 0 0 6 892 3600 0 0 218 /**</span>
 <span class="s0">* Returns true if a depth-test adjustment has been explicitly set on this</span>
 <span class="s0">* particular node via set_depth_test().  If this returns true, then</span>
 <span class="s0">* get_depth_test() may be called to determine which has been set.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">884 0 0 6 893 3600 0 0 262 /**</span>
 <span class="s0">* Returns true if depth-test rendering has been specifically set on this node</span>
 <span class="s0">* via set_depth_test(), or false if depth-test rendering has been</span>
 <span class="s0">* specifically disabled.  If nothing has been specifically set, returns true.</span>
 <span class="s0">* See also has_depth_test().</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">885 0 0 4 894 3812 0 0 236 /**</span>
 <span class="s0">* Specifically sets or disables the writing to the depth buffer on this</span>
 <span class="s0">* particular node.  This is normally on in the 3-d scene graph and off in the</span>
 <span class="s0">* 2-d scene graph; it should be on for rendering most 3-d objects properly.</span>
 <span class="s0">*/ 3 4 this 3 3894  11 depth_write 1 3600  8 priority 5 3593  </span>
<span class="s0">886 0 0 4 895 3812 0 0 118 /**</span>
 <span class="s0">* Completely removes any depth-write adjustment that may have been set on</span>
 <span class="s0">* this node via set_depth_write().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">887 0 0 6 896 3600 0 0 221 /**</span>
 <span class="s0">* Returns true if a depth-write adjustment has been explicitly set on this</span>
 <span class="s0">* particular node via set_depth_write().  If this returns true, then</span>
 <span class="s0">* get_depth_write() may be called to determine which has been set.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">888 0 0 6 897 3600 0 0 266 /**</span>
 <span class="s0">* Returns true if depth-write rendering has been specifically set on this</span>
 <span class="s0">* node via set_depth_write(), or false if depth-write rendering has been</span>
 <span class="s0">* specifically disabled.  If nothing has been specifically set, returns true.</span>
 <span class="s0">* See also has_depth_write().</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">889 0 0 4 898 3812 0 0 542 /**</span>
 <span class="s0">* This instructs the graphics driver to apply an offset or bias to the</span>
 <span class="s0">* generated depth values for rendered polygons, before they are written to</span>
 <span class="s0">* the depth buffer.  This can be used to shift polygons forward slightly, to</span>
 <span class="s0">* resolve depth conflicts, or self-shadowing artifacts on thin objects.  The</span>
 <span class="s0">* bias is always an integer number, and each integer increment represents the</span>
 <span class="s0">* smallest possible increment in Z that is sufficient to completely resolve</span>
 <span class="s0">* two coplanar polygons.  Positive numbers are closer towards the camera.</span>
 <span class="s0">*/ 3 4 this 3 3894  4 bias 1 3593  8 priority 5 3593  </span>
<span class="s0">890 0 0 4 899 3812 0 0 120 /**</span>
 <span class="s0">* Completely removes any depth-offset adjustment that may have been set on</span>
 <span class="s0">* this node via set_depth_offset().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">891 0 0 6 900 3600 0 0 224 /**</span>
 <span class="s0">* Returns true if a depth-offset adjustment has been explicitly set on this</span>
 <span class="s0">* particular node via set_depth_offset().  If this returns true, then</span>
 <span class="s0">* get_depth_offset() may be called to determine which has been set.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">892 0 0 6 901 3593 0 0 106 /**</span>
 <span class="s0">* Returns the depth offset value if it has been specified using</span>
 <span class="s0">* set_depth_offset, or 0 if not.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">893 0 0 4 902 3812 0 0 170 /**</span>
 <span class="s0">* Performs a billboard-type rotate to the indicated camera node, one time</span>
 <span class="s0">* only, and leaves the object rotated.  This is similar in principle to</span>
 <span class="s0">* heads_up().</span>
 <span class="s0">*/ 3 4 this 3 3894  6 camera 1 3884  6 offset 1 3598  </span>
<span class="s0">894 0 0 4 903 3812 0 0 266 /**</span>
 <span class="s0">* Performs a billboard-type rotate to the indicated camera node, one time</span>
 <span class="s0">* only, and leaves the object rotated.  This is similar in principle to</span>
 <span class="s0">* look_at(), although the point_eye billboard effect cannot be achieved using</span>
 <span class="s0">* the ordinary look_at() call.</span>
 <span class="s0">*/ 3 4 this 3 3894  6 camera 1 3884  6 offset 1 3598  </span>
<span class="s0">895 0 0 4 904 3812 0 0 169 /**</span>
 <span class="s0">* Performs a billboard-type rotate to the indicated camera node, one time</span>
 <span class="s0">* only, and leaves the object rotated.  This is similar in principle to</span>
 <span class="s0">* look_at().</span>
 <span class="s0">*/ 3 4 this 3 3894  6 camera 1 3884  6 offset 1 3598  </span>
<span class="s0">896 0 0 4 905 3812 0 0 182 /**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in two</span>
 <span class="s0">* dimensions around the up axis, towards a specified &quot;camera&quot; instead of to</span>
 <span class="s0">* the viewing camera.</span>
 <span class="s0">*/ 3 4 this 3 3894  6 camera 1 3884  6 offset 1 3598  </span>
<span class="s0">897 0 0 4 905 3812 0 0 116 /**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in two</span>
 <span class="s0">* dimensions around the up axis.</span>
 <span class="s0">*/ 2 4 this 3 3894  6 offset 5 3598  </span>
<span class="s0">898 0 0 4 906 3812 0 0 239 /**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in three</span>
 <span class="s0">* dimensions about the origin, keeping its up vector oriented to the top of</span>
 <span class="s0">* the camera, towards a specified &quot;camera&quot; instead of to the viewing camera.</span>
 <span class="s0">*/ 4 4 this 3 3894  6 camera 1 3884  6 offset 1 3598  11 fixed_depth 5 3600  </span>
<span class="s0">899 0 0 4 906 3812 0 0 176 /**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in three</span>
 <span class="s0">* dimensions about the origin, keeping its up vector oriented to the top of</span>
 <span class="s0">* the camera.</span>
 <span class="s0">*/ 3 4 this 3 3894  6 offset 5 3598  11 fixed_depth 5 3600  </span>
<span class="s0">900 0 0 4 907 3812 0 0 225 /**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in three</span>
 <span class="s0">* dimensions about the origin, keeping its up vector oriented to the sky,</span>
 <span class="s0">* towards a specified &quot;camera&quot; instead of to the viewing camera.</span>
 <span class="s0">*/ 3 4 this 3 3894  6 camera 1 3884  6 offset 1 3598  </span>
<span class="s0">901 0 0 4 907 3812 0 0 159 /**</span>
 <span class="s0">* Puts a billboard transition on the node such that it will rotate in three</span>
 <span class="s0">* dimensions about the origin, keeping its up vector oriented to the sky.</span>
 <span class="s0">*/ 2 4 this 3 3894  6 offset 5 3598  </span>
<span class="s0">902 0 0 4 908 3812 0 0 54 /**</span>
 <span class="s0">* Removes any billboard effect from the node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">903 0 0 6 909 3600 0 0 69 /**</span>
 <span class="s0">* Returns true if there is any billboard effect on the node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">904 0 0 4 910 3812 0 0 204 /**</span>
 <span class="s0">* Puts a compass effect on the node, so that it will retain a fixed rotation</span>
 <span class="s0">* relative to the reference node (or render if the reference node is empty)</span>
 <span class="s0">* regardless of the transforms above it.</span>
 <span class="s0">*/ 2 4 this 3 3894  9 reference 5 3884  </span>
<span class="s0">905 0 0 4 911 3812 0 0 52 /**</span>
 <span class="s0">* Removes any compass effect from the node.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">906 0 0 6 912 3600 0 0 67 /**</span>
 <span class="s0">* Returns true if there is any compass effect on the node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">907 0 0 4 913 3812 0 0 222 /**</span>
 <span class="s0">* Specifically sets or disables transparent rendering mode on this particular</span>
 <span class="s0">* node.  If no other nodes override, this will cause items with a non-1 value</span>
 <span class="s0">* for alpha color to be rendered partially transparent.</span>
 <span class="s0">*/ 3 4 this 3 3894  4 mode 1 3639  8 priority 5 3593  </span>
<span class="s0">908 0 0 4 914 3812 0 0 285 /**</span>
 <span class="s0">* Completely removes any transparency adjustment that may have been set on</span>
 <span class="s0">* this node via set_transparency(). The geometry at this level and below will</span>
 <span class="s0">* subsequently be rendered either transparent or not, to whatever other nodes</span>
 <span class="s0">* may have had set_transparency() on them.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">909 0 0 6 915 3600 0 0 303 /**</span>
 <span class="s0">* Returns true if a transparent-rendering adjustment has been explicitly set</span>
 <span class="s0">* on this particular node via set_transparency().  If this returns true, then</span>
 <span class="s0">* get_transparency() may be called to determine whether transparency has been</span>
 <span class="s0">* explicitly enabled or explicitly disabled for this node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">910 0 0 6 916 3639 0 0 399 /**</span>
 <span class="s0">* Returns the transparent rendering that has been specifically set on this</span>
 <span class="s0">* node via set_transparency(), or M_none if nontransparent rendering has been</span>
 <span class="s0">* specifically set, or if nothing has been specifically set.  See also</span>
 <span class="s0">* has_transparency().  This does not necessarily imply that the geometry will</span>
 <span class="s0">* or will not be rendered transparent, as there may be other nodes that</span>
 <span class="s0">* override.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">911 0 0 4 917 3812 0 0 248 /**</span>
 <span class="s0">* Specifically sets or disables a logical operation on this particular node.</span>
 <span class="s0">* If no other nodes override, this will cause geometry to be rendered without</span>
 <span class="s0">* color blending but instead using the given logical operator.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 3 4 this 3 3894  2 op 1 3641  8 priority 5 3593  </span>
<span class="s0">912 0 0 4 918 3812 0 0 231 /**</span>
 <span class="s0">* Completely removes any logical operation that may have been set on this</span>
 <span class="s0">* node via set_logic_op(). The geometry at this level and below will</span>
 <span class="s0">* subsequently be rendered using standard color blending.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">913 0 0 6 919 3600 0 0 316 /**</span>
 <span class="s0">* Returns true if a logical operation has been explicitly set on this</span>
 <span class="s0">* particular node via set_logic_op().  If this returns true, then</span>
 <span class="s0">* get_logic_op() may be called to determine whether a logical operation has</span>
 <span class="s0">* been explicitly disabled for this node or set to particular operation.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">914 0 0 6 920 3641 0 0 427 /**</span>
 <span class="s0">* Returns the logical operation that has been specifically set on this node</span>
 <span class="s0">* via set_logic_op(), or O_none if standard color blending has been</span>
 <span class="s0">* specifically set, or if nothing has been specifically set.  See also</span>
 <span class="s0">* has_logic_op().  This does not necessarily imply that the geometry will</span>
 <span class="s0">* or will not be rendered with the given logical operation, as there may be</span>
 <span class="s0">* other nodes that override.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">915 0 0 4 921 3812 0 0 114 /**</span>
 <span class="s0">* Specifies the antialiasing type that should be applied at this node and</span>
 <span class="s0">* below.  See AntialiasAttrib.</span>
 <span class="s0">*/ 3 4 this 3 3894  4 mode 1 3612  8 priority 5 3593  </span>
<span class="s0">916 0 0 4 922 3812 0 0 111 /**</span>
 <span class="s0">* Completely removes any antialias setting that may have been set on this</span>
 <span class="s0">* node via set_antialias().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">917 0 0 6 923 3600 0 0 216 /**</span>
 <span class="s0">* Returns true if an antialias setting has been explicitly mode on this</span>
 <span class="s0">* particular node via set_antialias().  If this returns true, then</span>
 <span class="s0">* get_antialias() may be called to determine what the setting was.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">918 0 0 6 924 3612 0 0 147 /**</span>
 <span class="s0">* Returns the antialias setting that has been specifically set on this node</span>
 <span class="s0">* via set_antialias(), or M_none if no setting has been made.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">919 0 0 6 925 3600 0 0 197 /**</span>
 <span class="s0">* Returns true if an audio volume has been applied to the referenced node,</span>
 <span class="s0">* false otherwise.  It is still possible that volume at this node might have</span>
 <span class="s0">* been scaled by an ancestor node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">920 0 0 4 926 3812 0 0 225 /**</span>
 <span class="s0">* Completely removes any audio volume from the referenced node.  This is</span>
 <span class="s0">* preferable to simply setting the audio volume to identity, as it also</span>
 <span class="s0">* removes the overhead associated with having an audio volume at all.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">921 0 0 4 927 3812 0 0 59 /**</span>
 <span class="s0">* Sets the audio volume component of the transform</span>
 <span class="s0">*/ 3 4 this 3 3894  6 volume 1 3598  8 priority 5 3593  </span>
<span class="s0">922 0 0 4 928 3812 0 0 447 /**</span>
 <span class="s0">* Disables any audio volume attribute inherited from above.  This is not the</span>
 <span class="s0">* same thing as clear_audio_volume(), which undoes any previous</span>
 <span class="s0">* set_audio_volume() operation on this node; rather, this actively disables</span>
 <span class="s0">* any set_audio_volume() that might be inherited from a parent node.</span>
 <span class="s0">*</span>
 <span class="s0">* It is legal to specify a new volume on the same node with a subsequent call</span>
 <span class="s0">* to set_audio_volume(); this new scale will apply to lower nodes.</span>
 <span class="s0">*/ 2 4 this 3 3894  8 priority 5 3593  </span>
<span class="s0">923 0 0 6 929 3598 0 0 200 /**</span>
 <span class="s0">* Returns the complete audio volume that has been applied to this node via a</span>
 <span class="s0">* previous call to set_audio_volume(), or 1. (identity) if no volume has been</span>
 <span class="s0">* applied to this particular node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">924 0 0 6 930 3598 0 0 109 /**</span>
 <span class="s0">* Returns the complete audio volume for this node taking highers nodes in the</span>
 <span class="s0">* graph into account.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">925 0 0 4 931 3812 0 0 339 /**</span>
 <span class="s0">* Adds the indicated adjustment amount (which may be negative) to the</span>
 <span class="s0">* priority for all transitions on the referenced node, and for all nodes in</span>
 <span class="s0">* the subgraph below.  This can be used to force these nodes not to be</span>
 <span class="s0">* overridden by a high-level state change above.  If the priority would drop</span>
 <span class="s0">* below zero, it is set to zero.</span>
 <span class="s0">*/ 2 4 this 3 3894  10 adjustment 1 3593  </span>
<span class="s0">926 0 0 4 932 3812 0 0 228 /**</span>
 <span class="s0">* Undoes the effect of a previous hide() on this node: makes the referenced</span>
 <span class="s0">* node (and the entire subgraph below this node) visible to all cameras.</span>
 <span class="s0">*</span>
 <span class="s0">* This will not reveal the node if a parent node has been hidden.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">927 0 0 4 932 3812 0 0 264 /**</span>
 <span class="s0">* Makes the referenced node visible just to the cameras whose camera_mask</span>
 <span class="s0">* shares the indicated bits.</span>
 <span class="s0">*</span>
 <span class="s0">* This undoes the effect of a previous hide() call.  It will not reveal the</span>
 <span class="s0">* node if a parent node has been hidden.  However, see show_through().</span>
 <span class="s0">*/ 2 4 this 3 3894  11 camera_mask 1 3849  </span>
<span class="s0">928 0 0 4 933 3812 0 0 243 /**</span>
 <span class="s0">* Makes the referenced node visible just to the cameras whose camera_mask</span>
 <span class="s0">* shares the indicated bits.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike show(), this will reveal the node even if a parent node has been</span>
 <span class="s0">* hidden, thus &quot;showing through&quot; a parent's hide().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">929 0 0 4 933 3812 0 0 390 /**</span>
 <span class="s0">* Makes the referenced node visible just to the cameras whose camera_mask</span>
 <span class="s0">* shares the indicated bits.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike show(), this will reveal the node even if a parent node has been</span>
 <span class="s0">* hidden via the one-parameter hide() method, thus &quot;showing through&quot; a</span>
 <span class="s0">* parent's hide().  (However, it will not show through a parent's hide() call</span>
 <span class="s0">* if the no-parameter form of hide() was used.)</span>
 <span class="s0">*/ 2 4 this 3 3894  11 camera_mask 1 3849  </span>
<span class="s0">930 0 0 4 934 3812 0 0 304 /**</span>
 <span class="s0">* Makes the referenced node (and the entire subgraph below this node)</span>
 <span class="s0">* invisible to all cameras.  It remains part of the scene graph, its bounding</span>
 <span class="s0">* volume still contributes to its parent's bounding volume, and it will still</span>
 <span class="s0">* be involved in collision tests.</span>
 <span class="s0">*</span>
 <span class="s0">* To undo this, call show().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">931 0 0 4 934 3812 0 0 328 /**</span>
 <span class="s0">* Makes the referenced node invisible just to the cameras whose camera_mask</span>
 <span class="s0">* shares the indicated bits.</span>
 <span class="s0">*</span>
 <span class="s0">* This will also hide any nodes below this node in the scene graph, including</span>
 <span class="s0">* those nodes for which show() has been called, but it will not hide</span>
 <span class="s0">* descendent nodes for which show_through() has been called.</span>
 <span class="s0">*/ 2 4 this 3 3894  11 camera_mask 1 3849  </span>
<span class="s0">932 0 0 6 935 3600 0 0 141 /**</span>
 <span class="s0">* Returns true if the referenced node is hidden from the indicated camera(s)</span>
 <span class="s0">* either directly, or because some ancestor is hidden.</span>
 <span class="s0">*/ 2 4 this 3 3884  11 camera_mask 5 3849  </span>
<span class="s0">933 0 0 7 936 3894 2739 0 215 /**</span>
 <span class="s0">* Returns the NodePath at or above the referenced node that is hidden to the</span>
 <span class="s0">* indicated camera(s), or an empty NodePath if no ancestor of the referenced</span>
 <span class="s0">* node is hidden (and the node should be visible).</span>
 <span class="s0">*/ 3 4 this 3 3884  11 camera_mask 5 3849  14 current_thread 5 3844  </span>
<span class="s0">934 0 0 4 937 3812 0 0 480 /**</span>
 <span class="s0">* Removes the referenced node (and the entire subgraph below this node) from</span>
 <span class="s0">* the scene graph in any normal sense.  The node will no longer be visible</span>
 <span class="s0">* and is not tested for collisions; furthermore, no normal scene graph</span>
 <span class="s0">* traversal will visit the node.  The node's bounding volume no longer</span>
 <span class="s0">* contributes to its parent's bounding volume.</span>
 <span class="s0">*</span>
 <span class="s0">* A stashed node cannot be located by a normal find() operation (although a</span>
 <span class="s0">* special find string can still retrieve it).</span>
 <span class="s0">*/ 3 4 this 3 3894  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">935 0 0 4 938 3812 0 0 174 /**</span>
 <span class="s0">* Undoes the effect of a previous stash() on this node: makes the referenced</span>
 <span class="s0">* node (and the entire subgraph below this node) once again part of the scene</span>
 <span class="s0">* graph.</span>
 <span class="s0">*/ 3 4 this 3 3894  4 sort 5 3593  14 current_thread 5 3844  </span>
<span class="s0">936 0 0 4 939 3812 0 0 59 /**</span>
 <span class="s0">* Unstashes this node and all stashed child nodes.</span>
 <span class="s0">*/ 2 4 this 3 3894  14 current_thread 5 3844  </span>
<span class="s0">937 0 0 6 940 3600 0 0 114 /**</span>
 <span class="s0">* Returns true if the referenced node is stashed either directly, or because</span>
 <span class="s0">* some ancestor is stashed.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">938 0 0 7 941 3894 2739 0 190 /**</span>
 <span class="s0">* Returns the NodePath at or above the referenced node that is stashed, or an</span>
 <span class="s0">* empty NodePath if no ancestor of the referenced node is stashed (and the</span>
 <span class="s0">* node should be visible).</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">939 0 0 7 942 3850 0 0 309 /**</span>
 <span class="s0">* Returns the union of all of the into_collide_masks for nodes at this level</span>
 <span class="s0">* and below.  This is the same thing as node()-&gt;get_net_collide_mask().</span>
 <span class="s0">*</span>
 <span class="s0">* If you want to return what the into_collide_mask of this node itself is,</span>
 <span class="s0">* without regard to its children, use node()-&gt;get_into_collide_mask().</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">940 0 0 4 943 3812 0 0 489 /**</span>
 <span class="s0">* Recursively applies the indicated CollideMask to the into_collide_masks for</span>
 <span class="s0">* all nodes at this level and below.  If node_type is not TypeHandle::none(),</span>
 <span class="s0">* then only nodes matching (or inheriting from) the indicated PandaNode</span>
 <span class="s0">* subclass are modified.</span>
 <span class="s0">*</span>
 <span class="s0">* The default is to change all bits, but if bits_to_change is not all bits</span>
 <span class="s0">* on, then only the bits that are set in bits_to_change are modified,</span>
 <span class="s0">* allowing this call to change only a subset of the bits in the subgraph.</span>
 <span class="s0">*/ 4 4 this 3 3894  8 new_mask 1 3850  14 bits_to_change 5 3850  9 node_type 5 3816  </span>
<span class="s0">941 0 0 6 944 3600 0 0 21 // Comparison methods 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">942 0 0 6 944 3600 0 0 0 2 4 this 3 3884  5 other 1 3915  </span>
<span class="s0">943 0 0 6 945 3600 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">944 0 0 6 945 3600 0 0 0 2 4 this 3 3884  5 other 1 3915  </span>
<span class="s0">945 0 0 6 946 3600 0 0 0 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">946 0 0 6 946 3600 0 0 0 2 4 this 3 3884  5 other 1 3915  </span>
<span class="s0">947 0 0 6 947 3593 0 0 486 /**</span>
 <span class="s0">* Returns a number less than zero if this NodePath sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two NodePaths are considered equivalent if they consist of exactly the same</span>
 <span class="s0">* list of nodes in the same order.  Otherwise, they are different; different</span>
 <span class="s0">* NodePaths will be ranked in a consistent but undefined ordering; the</span>
 <span class="s0">* ordering is useful only for placing the NodePaths in a sorted container</span>
 <span class="s0">* like an STL set.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3884  </span>
<span class="s0">948 0 0 6 947 3593 0 0 486 /**</span>
 <span class="s0">* Returns a number less than zero if this NodePath sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two NodePaths are considered equivalent if they consist of exactly the same</span>
 <span class="s0">* list of nodes in the same order.  Otherwise, they are different; different</span>
 <span class="s0">* NodePaths will be ranked in a consistent but undefined ordering; the</span>
 <span class="s0">* ordering is useful only for placing the NodePaths in a sorted container</span>
 <span class="s0">* like an STL set.</span>
 <span class="s0">*/ 2 4 this 3 3884  5 other 1 3915  </span>
<span class="s0">949 0 0 6 948 3600 0 0 107 /**</span>
 <span class="s0">* Returns true if all of the nodes described in the NodePath are connected,</span>
 <span class="s0">* or false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">950 0 0 4 949 3812 0 0 414 /**</span>
 <span class="s0">* Walks through the scene graph beginning at the bottom node, and internally</span>
 <span class="s0">* adjusts any GeomVertexFormats for optimal rendering on the indicated GSG.</span>
 <span class="s0">* If this step is not done prior to rendering, the formats will be optimized</span>
 <span class="s0">* at render time instead, for a small cost.</span>
 <span class="s0">*</span>
 <span class="s0">* It is not normally necessary to do this on a model loaded directly from</span>
 <span class="s0">* disk, since the loader will do this by default.</span>
 <span class="s0">*/ 2 4 this 3 3894  3 gsg 5 3851  </span>
<span class="s0">951 0 0 4 950 3812 0 0 476 /**</span>
 <span class="s0">* Walks through the scene graph beginning at the bottom node, and does</span>
 <span class="s0">* whatever initialization is required to render the scene properly with the</span>
 <span class="s0">* indicated GSG.  It is not strictly necessary to call this, since the GSG</span>
 <span class="s0">* will initialize itself when the scene is rendered, but this may take some</span>
 <span class="s0">* of the overhead away from that process.</span>
 <span class="s0">*</span>
 <span class="s0">* In particular, this will ensure that textures and vertex buffers within the</span>
 <span class="s0">* scene are loaded into graphics memory.</span>
 <span class="s0">*/ 2 4 this 3 3894  3 gsg 1 3851  </span>
<span class="s0">952 0 0 4 951 3812 0 0 273 /**</span>
 <span class="s0">* Causes the bounding volume of the bottom node and all of its descendants</span>
 <span class="s0">* (that is, the bounding volume associated with the the bottom arc) to be</span>
 <span class="s0">* rendered, if possible.  The rendering method is less than optimal; this is</span>
 <span class="s0">* intended primarily for debugging.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">953 0 0 4 952 3812 0 0 288 /**</span>
 <span class="s0">* Similar to show_bounds(), this draws a bounding box representing the</span>
 <span class="s0">* &quot;tight&quot; bounds of this node and all of its descendants.  The bounding box</span>
 <span class="s0">* is recomputed every frame by reexamining all of the vertices; this is far</span>
 <span class="s0">* from efficient, but this is intended for debugging.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">954 0 0 4 953 3812 0 0 79 /**</span>
 <span class="s0">* Stops the rendering of the bounding volume begun with show_bounds().</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">955 0 0 7 954 3672 0 0 214 /**</span>
 <span class="s0">* Returns a newly-allocated bounding volume containing the bottom node and</span>
 <span class="s0">* all of its descendants.  This is the bounding volume on the bottom arc,</span>
 <span class="s0">* converted to the local coordinate space of the node.</span>
 <span class="s0">*/ 2 4 this 3 3884  14 current_thread 5 3844  </span>
<span class="s0">956 0 0 4 955 3812 0 0 520 /**</span>
 <span class="s0">* Forces the recomputing of all the bounding volumes at every node in the</span>
 <span class="s0">* subgraph beginning at this node and below.</span>
 <span class="s0">*</span>
 <span class="s0">* This should not normally need to be called, since the bounding volumes are</span>
 <span class="s0">* supposed to be recomputed automatically when necessary.  It may be useful</span>
 <span class="s0">* when debugging, to verify that the bounding volumes have not become</span>
 <span class="s0">* inadvertently stale; it may also be useful to force animated characters to</span>
 <span class="s0">* update their bounding volumes (which does not presently happen</span>
 <span class="s0">* automatically).</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">957 0 0 4 956 3812 0 0 143 /**</span>
 <span class="s0">* Writes a description of the bounding volume containing the bottom node and</span>
 <span class="s0">* all of its descendants to the indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 3884  3 out 1 3813  </span>
<span class="s0">958 0 0 6 957 3600 0 0 725 /**</span>
 <span class="s0">* Calculates the minimum and maximum vertices of all Geoms at this NodePath's</span>
 <span class="s0">* bottom node and below.  This is a tight bounding box; it will generally be</span>
 <span class="s0">* tighter than the bounding volume returned by get_bounds() (but it is more</span>
 <span class="s0">* expensive to compute).</span>
 <span class="s0">*</span>
 <span class="s0">* The bounding box is computed relative to the parent node's coordinate</span>
 <span class="s0">* system by default.  You can optionally specify a different NodePath to</span>
 <span class="s0">* compute the bounds relative to.  Note that the box is always axis-aligned</span>
 <span class="s0">* against the given NodePath's coordinate system, so you might get a</span>
 <span class="s0">* differently sized box depending on which node you pass.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if any points are within the bounding volume, or</span>
 <span class="s0">* false if none are.</span>
 <span class="s0">*/ 5 4 this 3 3884  9 min_point 1 3896  9 max_point 1 3896  5 other 5 3884  14 current_thread 5 3844  </span>
<span class="s0">959 0 0 38 958 3623 0 0 0 2 4 this 3 3884  5 other 5 3884  </span>
<span class="s0">960 0 0 6 959 3593 0 0 811 /**</span>
 <span class="s0">* Lightly flattens out the hierarchy below this node by applying transforms,</span>
 <span class="s0">* colors, and texture matrices from the nodes onto the vertices, but does not</span>
 <span class="s0">* remove any nodes.</span>
 <span class="s0">*</span>
 <span class="s0">* This can result in improved rendering performance because there will be</span>
 <span class="s0">* fewer transforms in the resulting scene graph, but the number of nodes will</span>
 <span class="s0">* remain the same.</span>
 <span class="s0">*</span>
 <span class="s0">* In particular, any NodePaths that reference nodes within this hierarchy</span>
 <span class="s0">* will not be damaged.  However, since this operation will remove transforms</span>
 <span class="s0">* from the scene graph, it may be dangerous to apply to nodes where you</span>
 <span class="s0">* expect to dynamically modify the transform, or where you expect the</span>
 <span class="s0">* geometry to remain in a particular local coordinate system.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is always 0, since flatten_light does not remove any</span>
 <span class="s0">* nodes.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">961 0 0 6 960 3593 0 0 488 /**</span>
 <span class="s0">* A more thorough flattening than flatten_light(), this first applies all the</span>
 <span class="s0">* transforms, colors, and texture matrices from the nodes onto the vertices,</span>
 <span class="s0">* and then removes unneeded grouping nodes--nodes that have exactly one</span>
 <span class="s0">* child, for instance, but have no special properties in themselves.</span>
 <span class="s0">*</span>
 <span class="s0">* This results in improved performance over flatten_light() because the</span>
 <span class="s0">* number of nodes in the scene graph is reduced.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the number of nodes removed.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">962 0 0 6 961 3593 0 0 630 /**</span>
 <span class="s0">* The strongest possible flattening.  This first applies all of the</span>
 <span class="s0">* transforms to the vertices, as in flatten_medium(), but then it will</span>
 <span class="s0">* combine sibling nodes together when possible, in addition to removing</span>
 <span class="s0">* unnecessary parent-child nodes.  This can result in substantially fewer</span>
 <span class="s0">* nodes, but any nicely-grouped hierachical bounding volumes may be lost.</span>
 <span class="s0">*</span>
 <span class="s0">* It is generally a good idea to apply this kind of flattening only to nodes</span>
 <span class="s0">* that will be culled largely as a single unit, like a car.  Applying this to</span>
 <span class="s0">* an entire scene may result in overall poorer performance because of less-</span>
 <span class="s0">* effective culling.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">963 0 0 4 962 3812 0 0 692 /**</span>
 <span class="s0">* Removes textures from Geoms at this node and below by applying the texture</span>
 <span class="s0">* colors to the vertices.  This is primarily useful to simplify a low-LOD</span>
 <span class="s0">* model.  The texture colors are replaced by flat colors that approximate the</span>
 <span class="s0">* original textures.</span>
 <span class="s0">*</span>
 <span class="s0">* Only the bottommost texture on each Geom is used (if there is more than</span>
 <span class="s0">* one), and it is applied as if it were M_modulate, and WM_repeat, regardless</span>
 <span class="s0">* of its actual settings.  If the texture has a simple_ram_image, this may be</span>
 <span class="s0">* used if the main image isn't resident.</span>
 <span class="s0">*</span>
 <span class="s0">* After this call, there will be no texturing specified at this level and</span>
 <span class="s0">* below.  Of course, there might still be texturing inherited from above.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">964 0 0 6 963 3593 0 0 315 /**</span>
 <span class="s0">* Recursively walks through the scene graph at this level and below, looking</span>
 <span class="s0">* for ModelNodes, and calls model_node-&gt;set_preserve_transform(PT_drop_node)</span>
 <span class="s0">* on each one.  This allows a subsequent call to flatten_strong() to</span>
 <span class="s0">* eliminate all of the ModelNodes.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the number of ModelNodes found.</span>
 <span class="s0">*/ 1 4 this 3 3894  </span>
<span class="s0">965 0 0 4 964 3812 0 0 391 /**</span>
 <span class="s0">* Associates a user-defined value with a user-defined key which is stored on</span>
 <span class="s0">* the node.  This value has no meaning to Panda; but it is stored</span>
 <span class="s0">* indefinitely on the node until it is requested again.</span>
 <span class="s0">*</span>
 <span class="s0">* Each unique key stores a different string value.  There is no effective</span>
 <span class="s0">* limit on the number of different keys that may be stored or on the length</span>
 <span class="s0">* of any one key's value.</span>
 <span class="s0">*/ 3 4 this 3 3894  3 key 1 3841  5 value 1 3841  </span>
<span class="s0">966 0 0 6 965 3841 0 0 207 /**</span>
 <span class="s0">* Retrieves the user-defined value that was previously set on this node for</span>
 <span class="s0">* the particular key, if any.  If no value has been previously set, returns</span>
 <span class="s0">* the empty string.  See also get_net_tag().</span>
 <span class="s0">*/ 2 4 this 3 3884  3 key 1 3841  </span>
<span class="s0">967 0 0 38 966 3623 0 0 0 1 4 this 3 3884  </span>
<span class="s0">968 0 0 4 966 3812 0 0 232 /**</span>
 <span class="s0">* Fills the given vector up with the list of tags on this PandaNode.</span>
 <span class="s0">*</span>
 <span class="s0">* It is the user's responsibility to ensure that the keys vector is empty</span>
 <span class="s0">* before making this call; otherwise, the new files will be appended to it.</span>
 <span class="s0">*/ 2 4 this 3 3884  4 keys 1 3917  </span>
<span class="s0">969 0 0 6 967 3600 0 0 195 /**</span>
 <span class="s0">* Returns true if a value has been defined on this node for the particular</span>
 <span class="s0">* key (even if that value is the empty string), or false if no value has been</span>
 <span class="s0">* set.  See also has_net_tag().</span>
 <span class="s0">*/ 2 4 this 3 3884  3 key 1 3841  </span>
<span class="s0">970 0 0 4 968 3812 0 0 158 /**</span>
 <span class="s0">* Removes the value defined for this key on this particular node.  After a</span>
 <span class="s0">* call to clear_tag(), has_tag() will return false for the indicated key.</span>
 <span class="s0">*/ 2 4 this 3 3894  3 key 1 3841  </span>
<span class="s0">971 0 0 6 969 3841 0 0 251 /**</span>
 <span class="s0">* Returns the tag value that has been defined on this node, or the nearest</span>
 <span class="s0">* ancestor node, for the indicated key.  If no value has been defined for the</span>
 <span class="s0">* indicated key on any ancestor node, returns the empty string.  See also</span>
 <span class="s0">* get_tag().</span>
 <span class="s0">*/ 2 4 this 3 3884  3 key 1 3841  </span>
<span class="s0">972 0 0 6 970 3600 0 0 149 /**</span>
 <span class="s0">* Returns true if the indicated tag value has been defined on this node or on</span>
 <span class="s0">* any ancestor node, or false otherwise.  See also has_tag().</span>
 <span class="s0">*/ 2 4 this 3 3884  3 key 1 3841  </span>
<span class="s0">973 0 0 7 971 3894 2739 0 215 /**</span>
 <span class="s0">* Returns the lowest ancestor of this node that contains a tag definition</span>
 <span class="s0">* with the indicated key, if any, or an empty NodePath if no ancestor of this</span>
 <span class="s0">* node contains this tag definition.  See set_tag().</span>
 <span class="s0">*/ 2 4 this 3 3884  3 key 1 3841  </span>
<span class="s0">974 0 0 38 973 3623 0 0 0 1 4 this 3 3884  </span>
<span class="s0">975 0 0 38 975 3623 0 0 0 1 4 this 3 3894  </span>
<span class="s0">976 0 0 36 976 3812 0 0 0 3 4 this 3 3894  4 keys 1 3623  5 value 1 3623  </span>
<span class="s0">977 0 0 38 977 3623 0 0 0 2 4 this 3 3884  4 keys 1 3623  </span>
<span class="s0">978 0 0 38 978 3623 0 0 0 1 4 this 3 3884  </span>
<span class="s0">979 0 0 38 979 3600 0 0 0 2 4 this 3 3884  4 keys 1 3623  </span>
<span class="s0">980 0 0 36 980 3812 0 0 0 2 4 this 3 3894  4 keys 1 3623  </span>
<span class="s0">981 0 0 38 981 3623 0 0 0 2 4 this 3 3884  4 keys 1 3623  </span>
<span class="s0">982 0 0 38 982 3600 0 0 0 2 4 this 3 3884  4 keys 1 3623  </span>
<span class="s0">983 0 0 39 983 3894 2739 0 0 2 4 this 3 3884  4 keys 1 3623  </span>
<span class="s0">984 0 0 38 985 3593 0 0 0 3 4 this 3 3894  5 visit 1 3847  3 arg 1 3848  </span>
<span class="s0">985 0 0 4 986 3812 0 0 153 /**</span>
 <span class="s0">* Lists the tags to the nout stream, one per line.  See</span>
 <span class="s0">* PandaNode::list_tags() for a variant that allows you to specify the output</span>
 <span class="s0">* stream.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">986 0 0 4 987 3812 0 0 51 /**</span>
 <span class="s0">* Changes the name of the referenced node.</span>
 <span class="s0">*/ 2 4 this 3 3894  4 name 1 3841  </span>
<span class="s0">987 0 0 6 988 3841 0 0 51 /**</span>
 <span class="s0">* Returns the name of the referenced node.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">988 0 0 6 990 3600 0 0 230 /**</span>
 <span class="s0">* Writes the contents of this node and below out to a bam file with the</span>
 <span class="s0">* indicated filename.  This file may then be read in again, as is, at some</span>
 <span class="s0">* later point.  Returns true if successful, false on some kind of error.</span>
 <span class="s0">*/ 2 4 this 3 3884  8 filename 1 3920  </span>
<span class="s0">989 0 0 6 991 3600 0 0 82 /**</span>
 <span class="s0">* Writes the contents of this node and below out to the indicated stream.</span>
 <span class="s0">*/ 2 4 this 3 3884  3 out 1 3813  </span>
<span class="s0">990 0 0 6 992 3858 0 0 303 /**</span>
 <span class="s0">* Converts the NodePath object into a single stream of data using a</span>
 <span class="s0">* BamWriter, and returns that data as a string string.  Returns empty string</span>
 <span class="s0">* on failure.  This is similar to write_bam_stream().</span>
 <span class="s0">*</span>
 <span class="s0">* This method is used by __reduce__ to handle streaming of NodePaths to a</span>
 <span class="s0">* pickle file.</span>
 <span class="s0">*/ 1 4 this 3 3884  </span>
<span class="s0">991 0 0 6 992 3600 0 0 1067 /**</span>
 <span class="s0">* Converts the NodePath object into a single stream of data using a</span>
 <span class="s0">* BamWriter, and stores that data in the indicated string.  Returns true on</span>
 <span class="s0">* success, false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* If the BamWriter is NULL, this behaves the same way as</span>
 <span class="s0">* NodePath::write_bam_stream() and PandaNode::encode_to_bam_stream(), in the</span>
 <span class="s0">* sense that it only writes this node and all nodes below it.</span>
 <span class="s0">*</span>
 <span class="s0">* However, if the BamWriter is not NULL, it behaves very differently.  In</span>
 <span class="s0">* this case, it encodes the *entire graph* of all nodes connected to the</span>
 <span class="s0">* NodePath, including all parent nodes and siblings.  This is necessary for</span>
 <span class="s0">* correct streaming of related NodePaths and restoration of instances, etc.,</span>
 <span class="s0">* but it does mean you must detach() a node before writing it if you want to</span>
 <span class="s0">* limit the nodes that get written.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is used by __reduce__ to handle streaming of NodePaths to a</span>
 <span class="s0">* pickle file.  The BamWriter case is used by the direct.stdpy.pickle module,</span>
 <span class="s0">* while the saner, non-BamWriter case is used when the standard pickle module</span>
 <span class="s0">* calls this function.</span>
 <span class="s0">*/ 3 4 this 3 3884  4 data 1 3921  6 writer 5 3663  </span>
<span class="s0">992 0 0 7 993 3894 2739 0 162 /**</span>
 <span class="s0">* Reads the string created by a previous call to encode_to_bam_stream(), and</span>
 <span class="s0">* extracts and returns the NodePath on that string.  Returns NULL on error.</span>
 <span class="s0">*/ 2 4 data 1 3858  6 reader 5 3661  </span>
<span class="s0">993 0 0 7 994 3816 0 0 0 0 </span>
<span class="s0">994 0 0 6 597 3600 0 0 0 1 4 this 3 3884  </span>
<span class="s0">995 0 0 7 623 3895 2415 0 0 0 </span>
<span class="s0">996 0 0 15 623 3895 2415 0 0 1 6 param0 0 3922  </span>
<span class="s0">997 0 0 55 623 3895 2415 0 0 1 8 sequence 1 3623  </span>
<span class="s0">998 0 0 38 624 3623 0 0 0 1 4 this 3 3922  </span>
<span class="s0">999 0 0 4 625 3812 0 0 49 /**</span>
 <span class="s0">* Adds a new NodePath to the collection.</span>
 <span class="s0">*/ 2 4 this 3 3895  9 node_path 1 3884  </span>
<span class="s0">1000 0 0 6 626 3600 0 0 152 /**</span>
 <span class="s0">* Removes the indicated NodePath from the collection.  Returns true if the</span>
 <span class="s0">* path was removed, false if it was not a member of the collection.</span>
 <span class="s0">*/ 2 4 this 3 3895  9 node_path 1 3884  </span>
<span class="s0">1001 0 0 4 627 3812 0 0 204 /**</span>
 <span class="s0">* Adds all the NodePaths indicated in the other collection to this path.  The</span>
 <span class="s0">* other paths are simply appended to the end of the paths in this list;</span>
 <span class="s0">* duplicates are not automatically removed.</span>
 <span class="s0">*/ 2 4 this 3 3895  5 other 1 3922  </span>
<span class="s0">1002 0 0 4 628 3812 0 0 95 /**</span>
 <span class="s0">* Removes from this collection all of the NodePaths listed in the other</span>
 <span class="s0">* collection.</span>
 <span class="s0">*/ 2 4 this 3 3895  5 other 1 3922  </span>
<span class="s0">1003 0 0 4 629 3812 0 0 197 /**</span>
 <span class="s0">* Removes any duplicate entries of the same NodePaths on this collection.  If</span>
 <span class="s0">* a NodePath appears multiple times, the first appearance is retained;</span>
 <span class="s0">* subsequent appearances are removed.</span>
 <span class="s0">*/ 1 4 this 3 3895  </span>
<span class="s0">1004 0 0 6 630 3600 0 0 97 /**</span>
 <span class="s0">* Returns true if the indicated NodePath appears in this collection, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3922  4 path 1 3884  </span>
<span class="s0">1005 0 0 4 631 3812 0 0 53 /**</span>
 <span class="s0">* Removes all NodePaths from the collection.</span>
 <span class="s0">*/ 1 4 this 3 3895  </span>
<span class="s0">1006 0 0 4 632 3812 0 0 157 /**</span>
 <span class="s0">* This is a hint to Panda to allocate enough memory to hold the given number</span>
 <span class="s0">* of NodePaths, if you know ahead of time how many you will be adding.</span>
 <span class="s0">*/ 2 4 this 3 3895  3 num 1 3796  </span>
<span class="s0">1007 0 0 6 633 3600 0 0 85 /**</span>
 <span class="s0">* Returns true if there are no NodePaths in the collection, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3922  </span>
<span class="s0">1008 0 0 6 634 3593 0 0 61 /**</span>
 <span class="s0">* Returns the number of NodePaths in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3922  </span>
<span class="s0">1009 0 0 7 635 3894 2739 0 54 /**</span>
 <span class="s0">* Returns the nth NodePath in the collection.</span>
 <span class="s0">*/ 2 4 this 3 3922  5 index 1 3593  </span>
<span class="s0">1010 0 0 7 637 3894 2739 0 0 2 4 this 3 3922  5 index 1 3796  </span>
<span class="s0">1011 0 0 6 638 3796 0 0 104 /**</span>
 <span class="s0">* Returns the number of paths in the collection.  This is the same thing as</span>
 <span class="s0">* get_num_paths().</span>
 <span class="s0">*/ 1 4 this 3 3922  </span>
<span class="s0">1012 0 0 6 639 3895 0 0 0 2 4 this 3 3895  5 other 1 3922  </span>
<span class="s0">1013 0 0 7 640 3895 2415 0 0 2 4 this 3 3922  5 other 1 3922  </span>
<span class="s0">1014 0 0 4 641 3812 0 0 153 /**</span>
 <span class="s0">* Adds a new NodePath to the collection.  This method duplicates the</span>
 <span class="s0">* add_path() method; it is provided to satisfy Python's naming convention.</span>
 <span class="s0">*/ 2 4 this 3 3895  9 node_path 1 3884  </span>
<span class="s0">1015 0 0 4 642 3812 0 0 157 /**</span>
 <span class="s0">* Appends the other list onto the end of this one.  This method duplicates</span>
 <span class="s0">* the += operator; it is provided to satisfy Python's naming convention.</span>
 <span class="s0">*/ 2 4 this 3 3895  5 other 1 3922  </span>
<span class="s0">1016 0 0 4 643 3812 0 0 90 /**</span>
 <span class="s0">* Lists all the nodes at and below each node in the collection</span>
 <span class="s0">* hierarchically.</span>
 <span class="s0">*/ 1 4 this 3 3922  </span>
<span class="s0">1017 0 0 4 643 3812 0 0 90 /**</span>
 <span class="s0">* Lists all the nodes at and below each node in the collection</span>
 <span class="s0">* hierarchically.</span>
 <span class="s0">*/ 3 4 this 3 3922  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">1018 0 0 7 644 3895 2415 0 177 /**</span>
 <span class="s0">* Returns the complete set of all NodePaths that begin with any NodePath in</span>
 <span class="s0">* this collection and can be extended by path.  The shortest paths will be</span>
 <span class="s0">* listed first.</span>
 <span class="s0">*/ 2 4 this 3 3922  4 path 1 3841  </span>
<span class="s0">1019 0 0 4 645 3812 0 0 79 /**</span>
 <span class="s0">* Reparents all the NodePaths in the collection to the indicated node.</span>
 <span class="s0">*/ 2 4 this 3 3895  5 other 1 3884  </span>
<span class="s0">1020 0 0 4 646 3812 0 0 147 /**</span>
 <span class="s0">* Reparents all the NodePaths in the collection to the indicated node,</span>
 <span class="s0">* adjusting each transform so as not to move in world coordinates.</span>
 <span class="s0">*/ 2 4 this 3 3895  5 other 1 3884  </span>
<span class="s0">1021 0 0 4 647 3812 0 0 49 /**</span>
 <span class="s0">* Shows all NodePaths in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3895  </span>
<span class="s0">1022 0 0 4 648 3812 0 0 49 /**</span>
 <span class="s0">* Hides all NodePaths in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3895  </span>
<span class="s0">1023 0 0 4 649 3812 0 0 51 /**</span>
 <span class="s0">* Stashes all NodePaths in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3895  </span>
<span class="s0">1024 0 0 4 650 3812 0 0 53 /**</span>
 <span class="s0">* Unstashes all NodePaths in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3895  </span>
<span class="s0">1025 0 0 4 651 3812 0 0 52 /**</span>
 <span class="s0">* Detaches all NodePaths in the collection.</span>
 <span class="s0">*/ 1 4 this 3 3895  </span>
<span class="s0">1026 0 0 7 652 3850 0 0 309 /**</span>
 <span class="s0">* Returns the union of all of the into_collide_masks for nodes at this level</span>
 <span class="s0">* and below.  This is the same thing as node()-&gt;get_net_collide_mask().</span>
 <span class="s0">*</span>
 <span class="s0">* If you want to return what the into_collide_mask of this node itself is,</span>
 <span class="s0">* without regard to its children, use node()-&gt;get_into_collide_mask().</span>
 <span class="s0">*/ 1 4 this 3 3922  </span>
<span class="s0">1027 0 0 4 653 3812 0 0 349 /**</span>
 <span class="s0">* Recursively applies the indicated CollideMask to the into_collide_masks for</span>
 <span class="s0">* all nodes at this level and below.</span>
 <span class="s0">*</span>
 <span class="s0">* The default is to change all bits, but if bits_to_change is not all bits</span>
 <span class="s0">* on, then only the bits that are set in bits_to_change are modified,</span>
 <span class="s0">* allowing this call to change only a subset of the bits in the subgraph.</span>
 <span class="s0">*/ 4 4 this 3 3895  8 new_mask 1 3850  14 bits_to_change 5 3850  9 node_type 5 3816  </span>
<span class="s0">1028 0 0 6 654 3600 0 0 369 /**</span>
 <span class="s0">* Calculates the minimum and maximum vertices of all Geoms at these</span>
 <span class="s0">* NodePath's bottom nodes and below This is a tight bounding box; it will</span>
 <span class="s0">* generally be tighter than the bounding volume returned by get_bounds() (but</span>
 <span class="s0">* it is more expensive to compute).</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if any points are within the bounding volume, or</span>
 <span class="s0">* false if none are.</span>
 <span class="s0">*/ 3 4 this 3 3922  9 min_point 1 3896  9 max_point 1 3896  </span>
<span class="s0">1029 0 0 38 655 3623 0 0 0 1 4 this 3 3922  </span>
<span class="s0">1030 0 0 4 656 3812 0 0 377 /**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the default texture stage.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the deprecated single-texture variant of this method; it is now</span>
 <span class="s0">* superceded by set_texture() that accepts a stage and texture.  However,</span>
 <span class="s0">* this method may be used in the presence of multitexture if you just want to</span>
 <span class="s0">* adjust the default stage.</span>
 <span class="s0">*/ 3 4 this 3 3895  3 tex 1 3755  8 priority 5 3593  </span>
<span class="s0">1031 0 0 4 656 3812 0 0 359 /**</span>
 <span class="s0">* Adds the indicated texture to the list of textures that will be rendered on</span>
 <span class="s0">* the indicated multitexture stage.  If there are multiple texture stages</span>
 <span class="s0">* specified (possibly on multiple different nodes at different levels), they</span>
 <span class="s0">* will all be applied to geometry together, according to the stage</span>
 <span class="s0">* specification set up in the TextureStage object.</span>
 <span class="s0">*/ 4 4 this 3 3895  5 stage 1 3753  3 tex 1 3755  8 priority 5 3593  </span>
<span class="s0">1032 0 0 4 657 3812 0 0 305 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no texture, on</span>
 <span class="s0">* the indicated stage.  This is different from not specifying a texture;</span>
 <span class="s0">* rather, this specifically contradicts set_texture() at a higher node level</span>
 <span class="s0">* (or, with a priority, overrides a set_texture() at a lower level).</span>
 <span class="s0">*/ 3 4 this 3 3895  5 stage 1 3753  8 priority 5 3593  </span>
<span class="s0">1033 0 0 4 657 3812 0 0 295 /**</span>
 <span class="s0">* Sets the geometry at this level and below to render using no texture, on</span>
 <span class="s0">* any stage.  This is different from not specifying a texture; rather, this</span>
 <span class="s0">* specifically contradicts set_texture() at a higher node level (or, with a</span>
 <span class="s0">* priority, overrides a set_texture() at a lower level).</span>
 <span class="s0">*/ 2 4 this 3 3895  8 priority 5 3593  </span>
<span class="s0">1034 0 0 4 658 3812 0 0 49 /**</span>
 <span class="s0">* Colors all NodePaths in the collection</span>
 <span class="s0">*/ 3 4 this 3 3895  5 color 1 3820  8 priority 5 3593  </span>
<span class="s0">1035 0 0 4 658 3812 0 0 49 /**</span>
 <span class="s0">* Colors all NodePaths in the collection</span>
 <span class="s0">*/ 6 4 this 3 3895  1 r 1 3598  1 g 1 3598  1 b 1 3598  1 a 5 3598  8 priority 5 3593  </span>
<span class="s0">1036 0 0 4 659 3812 0 0 109 /**</span>
 <span class="s0">* Applies color scales to all NodePaths in the collection.  The existing</span>
 <span class="s0">* color scale is replaced.</span>
 <span class="s0">*/ 3 4 this 3 3895  5 scale 1 3880  8 priority 5 3593  </span>
<span class="s0">1037 0 0 4 659 3812 0 0 109 /**</span>
 <span class="s0">* Applies color scales to all NodePaths in the collection.  The existing</span>
 <span class="s0">* color scale is replaced.</span>
 <span class="s0">*/ 6 4 this 3 3895  1 r 1 3598  1 g 1 3598  1 b 1 3598  1 a 5 3598  8 priority 5 3593  </span>
<span class="s0">1038 0 0 4 660 3812 0 0 149 /**</span>
 <span class="s0">* Applies color scales to all NodePaths in the collection.  The existing</span>
 <span class="s0">* color scale, if any, is multiplied by the specified color scale.</span>
 <span class="s0">*/ 3 4 this 3 3895  5 scale 1 3880  8 priority 5 3593  </span>
<span class="s0">1039 0 0 4 660 3812 0 0 149 /**</span>
 <span class="s0">* Applies color scales to all NodePaths in the collection.  The existing</span>
 <span class="s0">* color scale, if any, is multiplied by the specified color scale.</span>
 <span class="s0">*/ 6 4 this 3 3895  1 r 1 3598  1 g 1 3598  1 b 1 3598  1 a 5 3598  8 priority 5 3593  </span>
<span class="s0">1040 0 0 4 661 3812 0 0 223 /**</span>
 <span class="s0">* Applies the indicated RenderAttrib to all NodePaths in the collection.  An</span>
 <span class="s0">* effort is made to apply the attrib to many NodePaths as quickly as</span>
 <span class="s0">* possible; redundant RenderState compositions are not duplicated.</span>
 <span class="s0">*/ 3 4 this 3 3895  6 attrib 1 3607  8 priority 5 3593  </span>
<span class="s0">1041 0 0 4 662 3812 0 0 107 /**</span>
 <span class="s0">* Writes a brief one-line description of the NodePathCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 2 4 this 3 3922  3 out 1 3813  </span>
<span class="s0">1042 0 0 4 663 3812 0 0 112 /**</span>
 <span class="s0">* Writes a complete multi-line description of the NodePathCollection to the</span>
 <span class="s0">* indicated output stream.</span>
 <span class="s0">*/ 3 4 this 3 3922  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">1043 0 0 4 997 3812 0 0 556 /**</span>
 <span class="s0">* Adds the indicated NodePath to the registry.  The name and type of the node</span>
 <span class="s0">* are noted at the time of this call; if the name changes later, it will not</span>
 <span class="s0">* update the registry index.</span>
 <span class="s0">*</span>
 <span class="s0">* The NodePath must reference some kind of an attribute node, such as a</span>
 <span class="s0">* LightNode or a PlaneNode.  When bam files that reference an attribute node</span>
 <span class="s0">* of the same type and the same name are loaded, they will quietly be</span>
 <span class="s0">* redirected to reference this NodePath.</span>
 <span class="s0">*</span>
 <span class="s0">* If there is already a node matching the indicated name and type, it will be</span>
 <span class="s0">* replaced.</span>
 <span class="s0">*/ 2 4 this 3 3924  11 attrib_node 1 3884  </span>
<span class="s0">1044 0 0 6 998 3600 0 0 320 /**</span>
 <span class="s0">* Removes the indicated NodePath from the registry.  The name of the node</span>
 <span class="s0">* must not have changed since the matching call to add_node(), or it will not</span>
 <span class="s0">* be successfully removed.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the NodePath is found and removed, false if it is not found</span>
 <span class="s0">* (for instance, because the name has changed).</span>
 <span class="s0">*/ 2 4 this 3 3924  11 attrib_node 1 3884  </span>
<span class="s0">1045 0 0 4 998 3812 0 0 50 /**</span>
 <span class="s0">* Removes the nth node from the registry.</span>
 <span class="s0">*/ 2 4 this 3 3924  1 n 1 3593  </span>
<span class="s0">1046 0 0 7 999 3894 2739 0 215 /**</span>
 <span class="s0">* Looks up the indicated NodePath in the registry.  If there is a node</span>
 <span class="s0">* already in the registry with the matching name and type, returns that</span>
 <span class="s0">* NodePath instead; otherwise, returns the original NodePath.</span>
 <span class="s0">*/ 2 4 this 3 3925  9 orig_node 1 3884  </span>
<span class="s0">1047 0 0 6 1000 3593 0 0 61 /**</span>
 <span class="s0">* Returns the total number of nodes in the registry.</span>
 <span class="s0">*/ 1 4 this 3 3925  </span>
<span class="s0">1048 0 0 7 1001 3894 2739 0 61 /**</span>
 <span class="s0">* Returns the nth NodePath recorded in the registry.</span>
 <span class="s0">*/ 2 4 this 3 3925  1 n 1 3593  </span>
<span class="s0">1049 0 0 7 1003 3816 0 0 73 /**</span>
 <span class="s0">* Returns the type of the nth node, as recorded in the registry.</span>
 <span class="s0">*/ 2 4 this 3 3925  1 n 1 3593  </span>
<span class="s0">1050 0 0 6 1004 3841 0 0 236 /**</span>
 <span class="s0">* Returns the name of the nth node, as recorded in the registry.  This will</span>
 <span class="s0">* be the node name as it was at the time the node was recorded; if the node</span>
 <span class="s0">* has changed names since then, this will still return the original name.</span>
 <span class="s0">*/ 2 4 this 3 3925  1 n 1 3593  </span>
<span class="s0">1051 0 0 6 1005 3593 0 0 244 /**</span>
 <span class="s0">* Returns the index number of the indicated NodePath in the registry</span>
 <span class="s0">* (assuming its name hasn't changed since it was recorded in the registry),</span>
 <span class="s0">* or -1 if the NodePath cannot be found (for instance, because its name has</span>
 <span class="s0">* changed).</span>
 <span class="s0">*/ 2 4 this 3 3925  11 attrib_node 1 3884  </span>
<span class="s0">1052 0 0 6 1005 3593 0 0 148 /**</span>
 <span class="s0">* Returns the index number of the node with the indicated type and name in</span>
 <span class="s0">* the registry, or -1 if there is no such node in the registry.</span>
 <span class="s0">*/ 3 4 this 3 3925  4 type 1 3816  4 name 1 3841  </span>
<span class="s0">1053 0 0 4 1006 3812 0 0 47 /**</span>
 <span class="s0">* Removes all nodes from the registry.</span>
 <span class="s0">*/ 1 4 this 3 3924  </span>
<span class="s0">1054 0 0 4 1007 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3925  3 out 1 3813  </span>
<span class="s0">1055 0 0 4 1008 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3925  3 out 1 3813  </span>
<span class="s0">1056 0 0 6 1009 3924 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1057 0 0 7 1012 3607 0 0 54 /**</span>
 <span class="s0">* Constructs an identity audio volume attrib.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1058 0 0 23 1013 3607 0 0 125 /**</span>
 <span class="s0">* Constructs a new AudioVolumeAttrib object that indicates audio volume</span>
 <span class="s0">* should be scaled by the indicated factor.</span>
 <span class="s0">*/ 1 6 volume 1 3598  </span>
<span class="s0">1059 0 0 7 1014 3607 0 0 213 /**</span>
 <span class="s0">* Constructs a new AudioVolumeAttrib object that ignores any</span>
 <span class="s0">* AudioVolumeAttrib inherited from above.  You may also specify an additional</span>
 <span class="s0">* volume scale to apply to geometry below (using set_volume()).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1060 0 0 7 1015 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1061 0 0 6 1016 3600 0 0 257 /**</span>
 <span class="s0">* Returns true if the AudioVolumeAttrib will ignore any color scales</span>
 <span class="s0">* inherited from above, false otherwise.  This is not the same thing as</span>
 <span class="s0">* !has_scale(); a AudioVolumeAttrib may have the &quot;off&quot; flag set and also have</span>
 <span class="s0">* another scale specified.</span>
 <span class="s0">*/ 1 4 this 3 3927  </span>
<span class="s0">1062 0 0 6 1017 3600 0 0 159 /**</span>
 <span class="s0">* Returns true if the AudioVolumeAttrib has a non-identity volume, false</span>
 <span class="s0">* otherwise (in which case it might be an off attrib or an identity attrib).</span>
 <span class="s0">*/ 1 4 this 3 3927  </span>
<span class="s0">1063 0 0 6 1018 3598 0 0 54 /**</span>
 <span class="s0">* Returns the volume to be applied to sounds.</span>
 <span class="s0">*/ 1 4 this 3 3927  </span>
<span class="s0">1064 0 0 7 1019 3607 0 0 118 /**</span>
 <span class="s0">* Returns a new AudioVolumeAttrib, just like this one, but with the volume</span>
 <span class="s0">* changed to the indicated value.</span>
 <span class="s0">*/ 2 4 this 3 3927  6 volume 1 3598  </span>
<span class="s0">1065 0 0 6 1021 3593 0 0 0 0 </span>
<span class="s0">1066 0 0 7 1023 3816 0 0 0 0 </span>
<span class="s0">1067 0 0 7 1027 3607 0 0 57 /**</span>
 <span class="s0">* Constructs a default AuxBitplaneAttrib object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1068 0 0 23 1027 3607 0 0 59 /**</span>
 <span class="s0">* Constructs a specified AuxBitplaneAttrib object.</span>
 <span class="s0">*/ 1 7 outputs 1 3593  </span>
<span class="s0">1069 0 0 7 1028 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1070 0 0 6 1029 3593 0 0 53 /**</span>
 <span class="s0">* Returns the AuxBitplaneAttrib output bits.</span>
 <span class="s0">*/ 1 4 this 3 3929  </span>
<span class="s0">1071 0 0 6 1031 3593 0 0 0 0 </span>
<span class="s0">1072 0 0 7 1033 3816 0 0 0 0 </span>
<span class="s0">1073 0 0 15 1045 3674 2779 0 0 1 6 param0 0 3931  </span>
<span class="s0">1074 0 0 4 1037 3812 0 0 159 /**</span>
 <span class="s0">* Specifies the minimum length in time, in seconds, to keep this AuxSceneData</span>
 <span class="s0">* object around in the scene graph after the last time it was rendered.</span>
 <span class="s0">*/ 2 4 this 3 3674  8 duration 1 3933  </span>
<span class="s0">1075 0 0 6 1038 3933 0 0 157 /**</span>
 <span class="s0">* Returns the minimum length in time, in seconds, to keep this AuxSceneData</span>
 <span class="s0">* object around in the scene graph after the last time it was rendered.</span>
 <span class="s0">*/ 1 4 this 3 3931  </span>
<span class="s0">1076 0 0 4 1039 3812 0 0 111 /**</span>
 <span class="s0">* Should be called with the current frame_time each time the AuxSceneData is</span>
 <span class="s0">* used during traversal.</span>
 <span class="s0">*/ 2 4 this 3 3674  11 render_time 1 3933  </span>
<span class="s0">1077 0 0 6 1040 3933 0 0 112 /**</span>
 <span class="s0">* Returns the last time this object was used during traversal (according to</span>
 <span class="s0">* set_last_render_time()).</span>
 <span class="s0">*/ 1 4 this 3 3931  </span>
<span class="s0">1078 0 0 6 1041 3933 0 0 129 /**</span>
 <span class="s0">* Returns the frame_time at which this AuxSceneData object is currently</span>
 <span class="s0">* scheduled to be removed from the scene graph.</span>
 <span class="s0">*/ 1 4 this 3 3931  </span>
<span class="s0">1079 0 0 4 1042 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3931  3 out 1 3813  </span>
<span class="s0">1080 0 0 4 1043 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 3931  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">1081 0 0 7 1044 3816 0 0 0 0 </span>
<span class="s0">1082 0 0 7 1049 3934 2781 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1083 0 0 6 1051 3600 0 0 111 /**</span>
 <span class="s0">* Attempts to open the indicated filename for reading.  Returns true if</span>
 <span class="s0">* successful, false on error.</span>
 <span class="s0">*/ 3 4 this 3 3934  12 bam_filename 1 3920  13 report_errors 5 3600  </span>
<span class="s0">1084 0 0 6 1051 3600 0 0 162 /**</span>
 <span class="s0">* Attempts to open the indicated stream for reading.  The filename is just</span>
 <span class="s0">* for information purposes only.  Returns true if successful, false on error.</span>
 <span class="s0">*/ 4 4 this 3 3934  2 in 1 3935  12 bam_filename 5 3841  13 report_errors 5 3600  </span>
<span class="s0">1085 0 0 6 1052 3937 0 0 313 /**</span>
 <span class="s0">* Reads and returns the next object from the Bam file, or NULL if the end of</span>
 <span class="s0">* the file has been reached, or if there is an error condition.  Use is_eof()</span>
 <span class="s0">* to differentiate these two cases.</span>
 <span class="s0">*</span>
 <span class="s0">* The pointers returned by this method will not be valid for use until</span>
 <span class="s0">* resolve() is subsequently called.</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1086 0 0 6 1053 3600 0 0 138 /**</span>
 <span class="s0">* Returns true if the reader has reached end-of-file, false otherwise.  This</span>
 <span class="s0">* call is only valid after a call to read_object().</span>
 <span class="s0">*/ 1 4 this 3 3939  </span>
<span class="s0">1087 0 0 6 1054 3600 0 0 358 /**</span>
 <span class="s0">* This must be called after one or more objects have been read via calls to</span>
 <span class="s0">* read_object() in order to resolve all internal pointer references in the</span>
 <span class="s0">* objects read and make all the pointers valid.  It returns true if all</span>
 <span class="s0">* objects are successfully resolved, or false if some have not been (in which</span>
 <span class="s0">* case you must call resolve() again later).</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1088 0 0 7 1055 3650 2131 0 758 /**</span>
 <span class="s0">* Although the bam file format is general enough to store a list of objects</span>
 <span class="s0">* of arbitrary type, bam files on disk usually contain just one object, a</span>
 <span class="s0">* PandaNode that is the root of a scene graph.  (Bam files that store other</span>
 <span class="s0">* kinds of things are usually given the extension &quot;boo&quot;, for &quot;binary other</span>
 <span class="s0">* objects&quot;, to differentiate them from the normal scene graph type file.)</span>
 <span class="s0">*</span>
 <span class="s0">* This is a convenience method for when you believe you are reading a scene</span>
 <span class="s0">* graph bam file.  It reads the one PandaNode and returns it.  It also calls</span>
 <span class="s0">* resolve() to fully resolve the object, since we expect this will be the</span>
 <span class="s0">* only object in the file.</span>
 <span class="s0">*</span>
 <span class="s0">* If the bam file contains something other than a PandaNode, an error is</span>
 <span class="s0">* printed and NULL is returned.</span>
 <span class="s0">*/ 2 4 this 3 3934  13 report_errors 5 3600  </span>
<span class="s0">1089 0 0 6 1056 3600 0 0 190 /**</span>
 <span class="s0">* Attempts to open the indicated file for writing.  If another file by the</span>
 <span class="s0">* same name already exists, it will be silently removed.  Returns true if</span>
 <span class="s0">* successful, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 3934  12 bam_filename 1 3920  13 report_errors 5 3600  </span>
<span class="s0">1090 0 0 6 1056 3600 0 0 162 /**</span>
 <span class="s0">* Attempts to open the indicated stream for writing.  The filename is just</span>
 <span class="s0">* for information purposes only.  Returns true if successful, false on error.</span>
 <span class="s0">*/ 4 4 this 3 3934  3 out 1 3813  12 bam_filename 5 3841  13 report_errors 5 3600  </span>
<span class="s0">1091 0 0 6 1057 3600 0 0 103 /**</span>
 <span class="s0">* Writes the indicated object to the Bam file.  Returns true if successful,</span>
 <span class="s0">* false on error.</span>
 <span class="s0">*/ 2 4 this 3 3934  6 object 1 3941  </span>
<span class="s0">1092 0 0 4 1058 3812 0 0 45 /**</span>
 <span class="s0">* Closes the input or output stream.</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1093 0 0 6 1059 3600 0 0 124 /**</span>
 <span class="s0">* Returns true if the Bam file is open and ready for reading with no errors</span>
 <span class="s0">* so far detected, or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3939  </span>
<span class="s0">1094 0 0 6 1060 3600 0 0 124 /**</span>
 <span class="s0">* Returns true if the Bam file is open and ready for writing with no errors</span>
 <span class="s0">* so far detected, or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3939  </span>
<span class="s0">1095 0 0 6 1061 3593 0 0 168 /**</span>
 <span class="s0">* Returns the major version number of the file currently being read, or the</span>
 <span class="s0">* system current major version number if no file is currently open for</span>
 <span class="s0">* reading.</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1096 0 0 6 1062 3593 0 0 168 /**</span>
 <span class="s0">* Returns the minor version number of the file currently being read, or the</span>
 <span class="s0">* system current minor version number if no file is currently open for</span>
 <span class="s0">* reading.</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1097 0 0 6 1063 3660 0 0 102 /**</span>
 <span class="s0">* Returns the endian preference indicated by the Bam file currently being</span>
 <span class="s0">* read or written.</span>
 <span class="s0">*/ 1 4 this 3 3939  </span>
<span class="s0">1098 0 0 6 1064 3600 0 0 122 /**</span>
 <span class="s0">* Returns true if the file stores all &quot;standard&quot; floats as 64-bit doubles, or</span>
 <span class="s0">* false if they are 32-bit floats.</span>
 <span class="s0">*/ 1 4 this 3 3939  </span>
<span class="s0">1099 0 0 6 1065 3593 0 0 140 /**</span>
 <span class="s0">* Returns the system current major version number.  This is the version</span>
 <span class="s0">* number that will be assigned to any generated Bam files.</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1100 0 0 6 1066 3593 0 0 140 /**</span>
 <span class="s0">* Returns the system current minor version number.  This is the version</span>
 <span class="s0">* number that will be assigned to any generated Bam files.</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1101 0 0 6 1067 3661 0 0 134 /**</span>
 <span class="s0">* Returns the BamReader in charge of performing the read operations.  This</span>
 <span class="s0">* will return NULL unless open_read() was called.</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1102 0 0 6 1068 3663 0 0 136 /**</span>
 <span class="s0">* Returns the BamWriter in charge of performing the write operations.  This</span>
 <span class="s0">* will return NULL unless open_write() was called.</span>
 <span class="s0">*/ 1 4 this 3 3934  </span>
<span class="s0">1103 0 0 23 1079 3837 0 0 81 /**</span>
 <span class="s0">* Constructs a new BillboardEffect object with the indicated properties.</span>
 <span class="s0">*/ 7 9 up_vector 1 3903  12 eye_relative 1 3600  12 axial_rotate 1 3600  6 offset 1 3598  7 look_at 1 3884  13 look_at_point 1 3809  11 fixed_depth 5 3600  </span>
<span class="s0">1104 0 0 7 1080 3837 0 0 76 /**</span>
 <span class="s0">* A convenience function to make a typical axis-rotating billboard.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1105 0 0 7 1081 3837 0 0 93 /**</span>
 <span class="s0">* A convenience function to make a typical eye-relative point-rotating</span>
 <span class="s0">* billboard.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1106 0 0 7 1082 3837 0 0 95 /**</span>
 <span class="s0">* A convenience function to make a typical world-relative point-rotating</span>
 <span class="s0">* billboard.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1107 0 0 6 1083 3600 0 0 323 /**</span>
 <span class="s0">* Returns true if the BillboardEffect is an 'off' BillboardEffect, indicating</span>
 <span class="s0">* that it does not enable billboarding.  This kind of BillboardEffect isn't</span>
 <span class="s0">* particularly useful and isn't normally created or stored in the graph; it</span>
 <span class="s0">* might be implicitly discovered as the result of a</span>
 <span class="s0">* NodePath::get_rel_state().</span>
 <span class="s0">*/ 1 4 this 3 3943  </span>
<span class="s0">1108 0 0 6 1084 3903 0 0 62 /**</span>
 <span class="s0">* Returns the up vector in effect for this billboard.</span>
 <span class="s0">*/ 1 4 this 3 3943  </span>
<span class="s0">1109 0 0 6 1085 3600 0 0 134 /**</span>
 <span class="s0">* Returns true if this billboard interprets the up vector relative to the</span>
 <span class="s0">* camera, or false if it is relative to the world.</span>
 <span class="s0">*/ 1 4 this 3 3943  </span>
<span class="s0">1110 0 0 6 1086 3600 0 0 142 /**</span>
 <span class="s0">* Returns true if this billboard rotates only around the axis of the up</span>
 <span class="s0">* vector, or false if it rotates freely in three dimensions.</span>
 <span class="s0">*/ 1 4 this 3 3943  </span>
<span class="s0">1111 0 0 6 1087 3600 0 0 96 /**</span>
 <span class="s0">* Returns true if this billboard always appears at a fixed distance from the</span>
 <span class="s0">* camera.</span>
 <span class="s0">*/ 1 4 this 3 3943  </span>
<span class="s0">1112 0 0 6 1088 3598 0 0 204 /**</span>
 <span class="s0">* Returns the distance toward the camera (or the look_at_point) the billboard</span>
 <span class="s0">* is moved towards, after rotating.  This can be used to ensure the billboard</span>
 <span class="s0">* is not obscured by nearby geometry.</span>
 <span class="s0">*/ 1 4 this 3 3943  </span>
<span class="s0">1113 0 0 6 1089 3884 0 0 188 /**</span>
 <span class="s0">* Returns the node this billboard will rotate to look towards.  If this is</span>
 <span class="s0">* empty, it means the billboard will rotate towards the current camera node,</span>
 <span class="s0">* wherever that might be.</span>
 <span class="s0">*/ 1 4 this 3 3943  </span>
<span class="s0">1114 0 0 6 1090 3809 0 0 132 /**</span>
 <span class="s0">* Returns the point, relative to the look_at node, towards which the</span>
 <span class="s0">* billboard will rotate.  Normally this is (0, 0, 0).</span>
 <span class="s0">*/ 1 4 this 3 3943  </span>
<span class="s0">1115 0 0 7 1091 3816 0 0 0 0 </span>
<span class="s0">1116 0 0 7 1094 3947 2826 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 name 1 3841  4 lens 5 3945  </span>
<span class="s0">1117 0 0 4 1095 3812 0 0 148 /**</span>
 <span class="s0">* Sets up the LensNode using a copy of the indicated Lens.  If the original</span>
 <span class="s0">* Lens is changed or destroyed, this LensNode is not affected.</span>
 <span class="s0">*/ 2 4 this 3 3947  4 lens 1 3948  </span>
<span class="s0">1118 0 0 4 1095 3812 0 0 61 /**</span>
 <span class="s0">* Copies the indicated lens into the specified slot.</span>
 <span class="s0">*/ 3 4 this 3 3947  5 index 1 3593  4 lens 1 3948  </span>
<span class="s0">1119 0 0 4 1096 3812 0 0 168 /**</span>
 <span class="s0">* Sets up the LensNode using this particular Lens pointer.  If the lens is</span>
 <span class="s0">* subsequently modified, the LensNode properties immediately reflect the</span>
 <span class="s0">* change.</span>
 <span class="s0">*/ 2 4 this 3 3947  4 lens 1 3945  </span>
<span class="s0">1120 0 0 4 1096 3812 0 0 302 /**</span>
 <span class="s0">* Sets the indicated lens.  Although a LensNode normally holds only one lens,</span>
 <span class="s0">* it may optionally include multiple lenses, each with a different index</span>
 <span class="s0">* number.  The different lenses may be referenced by index number on the</span>
 <span class="s0">* DisplayRegion.  Adding a new lens automatically makes it active.</span>
 <span class="s0">*/ 3 4 this 3 3947  5 index 1 3593  4 lens 1 3945  </span>
<span class="s0">1121 0 0 7 1097 3945 0 0 191 /**</span>
 <span class="s0">* Returns a pointer to the particular Lens associated with this LensNode, or</span>
 <span class="s0">* NULL if there is not yet a Lens associated.  If an index number is</span>
 <span class="s0">* specified, returns the nth lens.</span>
 <span class="s0">*/ 2 4 this 3 3950  5 index 5 3593  </span>
<span class="s0">1122 0 0 6 1098 3600 0 0 263 /**</span>
 <span class="s0">* Sets the active flag for the nth lens.  When a lens is inactive, it is not</span>
 <span class="s0">* used for rendering, and any DisplayRegions associated with it are</span>
 <span class="s0">* implicitly inactive as well.  Returns true if the flag is changed, false if</span>
 <span class="s0">* it already had this value.</span>
 <span class="s0">*/ 3 4 this 3 3947  5 index 1 3593  6 active 1 3600  </span>
<span class="s0">1123 0 0 6 1099 3600 0 0 52 /**</span>
 <span class="s0">* Returns the active flag for the nth lens.</span>
 <span class="s0">*/ 2 4 this 3 3950  5 index 1 3593  </span>
<span class="s0">1124 0 0 6 1100 3600 0 0 65 /**</span>
 <span class="s0">* An alternate way to call set_lens_active(index, true).</span>
 <span class="s0">*/ 2 4 this 3 3947  5 index 1 3593  </span>
<span class="s0">1125 0 0 6 1101 3600 0 0 66 /**</span>
 <span class="s0">* An alternate way to call set_lens_active(index, false).</span>
 <span class="s0">*/ 2 4 this 3 3947  5 index 1 3593  </span>
<span class="s0">1126 0 0 6 1102 3600 0 0 135 /**</span>
 <span class="s0">* Returns true if the given point is within the bounds of the lens of the</span>
 <span class="s0">* LensNode (i.e.  if the camera can see the point).</span>
 <span class="s0">*/ 2 4 this 3 3947  3 pos 1 3809  </span>
<span class="s0">1127 0 0 6 1102 3600 0 0 135 /**</span>
 <span class="s0">* Returns true if the given point is within the bounds of the lens of the</span>
 <span class="s0">* LensNode (i.e.  if the camera can see the point).</span>
 <span class="s0">*/ 3 4 this 3 3947  5 index 1 3593  3 pos 1 3809  </span>
<span class="s0">1128 0 0 4 1103 3812 0 0 149 /**</span>
 <span class="s0">* Enables the drawing of the lens's frustum to aid in visualization.  This</span>
 <span class="s0">* actually creates a GeomNode which is parented to the LensNode.</span>
 <span class="s0">*/ 1 4 this 3 3947  </span>
<span class="s0">1129 0 0 4 1104 3812 0 0 78 /**</span>
 <span class="s0">* Disables the drawing of the lens's frustum to aid in visualization.</span>
 <span class="s0">*/ 1 4 this 3 3947  </span>
<span class="s0">1130 0 0 7 1105 3816 0 0 0 0 </span>
<span class="s0">1131 0 0 23 1108 3952 2828 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 9 node_path 1 3884  </span>
<span class="s0">1132 0 0 15 1108 3952 2828 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3915  </span>
<span class="s0">1133 0 0 6 1110 3952 0 0 0 2 4 this 3 3952  9 node_path 1 3884  </span>
<span class="s0">1134 0 0 6 1110 3952 0 0 0 2 4 this 3 3952  4 copy 1 3915  </span>
<span class="s0">1135 0 0 4 1111 3812 0 0 93 /**</span>
 <span class="s0">* Sets this NodePath to the empty NodePath.  It will no longer point to any</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 1 4 this 3 3952  </span>
<span class="s0">1136 0 0 6 1113 3600 0 0 85 /**</span>
 <span class="s0">* Returns true if the NodePath contains no nodes, or if it has been deleted.</span>
 <span class="s0">*/ 1 4 this 3 3915  </span>
<span class="s0">1137 0 0 6 1114 3600 0 0 116 /**</span>
 <span class="s0">* Returns true if the NodePath we were referencing has been quietly deleted</span>
 <span class="s0">* outside of the WeakNodePath.</span>
 <span class="s0">*/ 1 4 this 3 3915  </span>
<span class="s0">1138 0 0 7 1115 3894 2739 0 131 /**</span>
 <span class="s0">* Returns the NodePath held within this object, or an empty NodePath with the</span>
 <span class="s0">* error flag set if the object was deleted.</span>
 <span class="s0">*/ 1 4 this 3 3915  </span>
<span class="s0">1139 0 0 7 1116 3650 2131 0 98 /**</span>
 <span class="s0">* Returns the PandaNode held within this object, or nullptr if the object was</span>
 <span class="s0">* deleted.</span>
 <span class="s0">*/ 1 4 this 3 3915  </span>
<span class="s0">1140 0 0 6 1117 3600 0 0 0 2 4 this 3 3915  5 other 1 3884  </span>
<span class="s0">1141 0 0 6 1117 3600 0 0 0 2 4 this 3 3915  5 other 1 3915  </span>
<span class="s0">1142 0 0 6 1118 3600 0 0 0 2 4 this 3 3915  5 other 1 3884  </span>
<span class="s0">1143 0 0 6 1118 3600 0 0 0 2 4 this 3 3915  5 other 1 3915  </span>
<span class="s0">1144 0 0 6 1119 3600 0 0 0 2 4 this 3 3915  5 other 1 3884  </span>
<span class="s0">1145 0 0 6 1119 3600 0 0 0 2 4 this 3 3915  5 other 1 3915  </span>
<span class="s0">1146 0 0 6 1120 3593 0 0 486 /**</span>
 <span class="s0">* Returns a number less than zero if this NodePath sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two NodePaths are considered equivalent if they consist of exactly the same</span>
 <span class="s0">* list of nodes in the same order.  Otherwise, they are different; different</span>
 <span class="s0">* NodePaths will be ranked in a consistent but undefined ordering; the</span>
 <span class="s0">* ordering is useful only for placing the NodePaths in a sorted container</span>
 <span class="s0">* like an STL set.</span>
 <span class="s0">*/ 2 4 this 3 3915  5 other 1 3884  </span>
<span class="s0">1147 0 0 6 1120 3593 0 0 502 /**</span>
 <span class="s0">* Returns a number less than zero if this WeakNodePath sorts before the other</span>
 <span class="s0">* one, greater than zero if it sorts after, or zero if they are equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two WeakNodePaths are considered equivalent if they consist of exactly the</span>
 <span class="s0">* same list of nodes in the same order.  Otherwise, they are different;</span>
 <span class="s0">* different WeakNodePaths will be ranked in a consistent but undefined</span>
 <span class="s0">* ordering; the ordering is useful only for placing the WeakNodePaths in a</span>
 <span class="s0">* sorted container like an STL set.</span>
 <span class="s0">*/ 2 4 this 3 3915  5 other 1 3915  </span>
<span class="s0">1148 0 0 6 1121 3593 0 0 58 /**</span>
 <span class="s0">* Returns the same values as NodePath::get_key().</span>
 <span class="s0">*/ 1 4 this 3 3915  </span>
<span class="s0">1149 0 0 4 1122 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3915  3 out 1 3813  </span>
<span class="s0">1150 0 0 6 1112 3600 0 0 0 1 4 this 3 3915  </span>
<span class="s0">1151 0 0 15 1124 3955 2826 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3953  </span>
<span class="s0">1152 0 0 7 1124 3955 2826 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 name 1 3841  4 lens 5 3945  </span>
<span class="s0">1153 0 0 4 1125 3812 0 0 107 /**</span>
 <span class="s0">* Sets the active flag on the camera.  When the camera is not active, nothing</span>
 <span class="s0">* will be rendered.</span>
 <span class="s0">*/ 2 4 this 3 3955  6 active 1 3600  </span>
<span class="s0">1154 0 0 6 1126 3600 0 0 72 /**</span>
 <span class="s0">* Returns the current setting of the active flag on the camera.</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1155 0 0 4 1128 3812 0 0 479 /**</span>
 <span class="s0">* Sets the scene that will be rendered by the camera.  This is normally the</span>
 <span class="s0">* root node of a scene graph, typically a node called 'render', although it</span>
 <span class="s0">* could represent the root of any subgraph.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the use of this method is now deprecated.  In the absence of an</span>
 <span class="s0">* explicit scene set on the camera, the camera will render whatever scene it</span>
 <span class="s0">* is parented into.  This is the preferred way to specify the scene, since it</span>
 <span class="s0">* is the more intuitive mechanism.</span>
 <span class="s0">*/ 2 4 this 3 3955  5 scene 1 3884  </span>
<span class="s0">1156 0 0 6 1129 3884 0 0 83 /**</span>
 <span class="s0">* Returns the scene that will be rendered by the camera.  See set_scene().</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1157 0 0 6 1132 3796 0 0 76 /**</span>
 <span class="s0">* Returns the number of display regions associated with the camera.</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1158 0 0 6 1133 3670 0 0 69 /**</span>
 <span class="s0">* Returns the nth display region associated with the camera.</span>
 <span class="s0">*/ 2 4 this 3 3953  1 n 1 3796  </span>
<span class="s0">1159 0 0 4 1138 3812 0 0 401 /**</span>
 <span class="s0">* Changes the set of bits that represent the subset of the scene graph the</span>
 <span class="s0">* camera will render.</span>
 <span class="s0">*</span>
 <span class="s0">* During the cull traversal, a node is not visited if none of its draw mask</span>
 <span class="s0">* bits intersect with the camera's camera mask bits.  These masks can be used</span>
 <span class="s0">* to selectively hide and show different parts of the scene graph from</span>
 <span class="s0">* different cameras that are otherwise viewing the same scene.</span>
 <span class="s0">*/ 2 4 this 3 3955  4 mask 1 3849  </span>
<span class="s0">1160 0 0 7 1139 3849 0 0 130 /**</span>
 <span class="s0">* Returns the set of bits that represent the subset of the scene graph the</span>
 <span class="s0">* camera will render.  See set_camera_mask().</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1161 0 0 4 1141 3812 0 0 320 /**</span>
 <span class="s0">* Specifies the point from which the culling operations are performed.</span>
 <span class="s0">* Normally, this is the same as the camera, and that is the default if this</span>
 <span class="s0">* is not specified; but it may sometimes be useful to perform the culling</span>
 <span class="s0">* from some other viewpoint, particularly when you are debugging the culling</span>
 <span class="s0">* itself.</span>
 <span class="s0">*/ 2 4 this 3 3955  11 cull_center 1 3884  </span>
<span class="s0">1162 0 0 6 1142 3884 0 0 153 /**</span>
 <span class="s0">* Returns the point from which the culling operations will be performed, if</span>
 <span class="s0">* it was set by set_cull_center(), or the empty NodePath otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1163 0 0 4 1144 3812 0 0 379 /**</span>
 <span class="s0">* Specifies the bounding volume that should be used to perform culling from</span>
 <span class="s0">* this camera.  Normally, this is the bounding volume returned from the</span>
 <span class="s0">* active lens' make_bounds() call, but you may override this to specify a</span>
 <span class="s0">* custom volume if you require.  The specified bounding volume will be</span>
 <span class="s0">* understood to be in the coordinate space of the get_cull_center() node.</span>
 <span class="s0">*/ 2 4 this 3 3955  11 cull_bounds 1 3672  </span>
<span class="s0">1164 0 0 7 1145 3672 0 0 129 /**</span>
 <span class="s0">* Returns the custom cull volume that was set by set_cull_bounds(), if any,</span>
 <span class="s0">* or NULL if no custom cull volume was set.</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1165 0 0 4 1148 3812 0 0 379 /**</span>
 <span class="s0">* Specifies the point from which the LOD distances are measured.  Normally,</span>
 <span class="s0">* this is the same as the camera, and that is the default if this is not</span>
 <span class="s0">* specified; but it may sometimes be useful to perform the distance test from</span>
 <span class="s0">* some other viewpoint.  This may be used, for instance, to reduce LOD</span>
 <span class="s0">* popping when the camera rotates in a small circle about an avatar.</span>
 <span class="s0">*/ 2 4 this 3 3955  10 lod_center 1 3884  </span>
<span class="s0">1166 0 0 6 1149 3884 0 0 146 /**</span>
 <span class="s0">* Returns the point from which the LOD distances will be measured, if it was</span>
 <span class="s0">* set by set_lod_center(), or the empty NodePath otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1167 0 0 4 1151 3812 0 0 129 /**</span>
 <span class="s0">* Sets the initial state which is applied to all nodes in the scene, as if it</span>
 <span class="s0">* were set at the top of the scene graph.</span>
 <span class="s0">*/ 2 4 this 3 3955  5 state 1 3825  </span>
<span class="s0">1168 0 0 7 1152 3825 0 0 86 /**</span>
 <span class="s0">* Returns the initial state as set by a previous call to set_initial_state().</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1169 0 0 4 1154 3812 0 0 218 /**</span>
 <span class="s0">* Sets the tag key which, when encountered as a tag on nodes in the scene</span>
 <span class="s0">* graph, causes this Camera to apply an arbitrary state transition based on</span>
 <span class="s0">* the value of the tag (as specified to set_tag_state()).</span>
 <span class="s0">*/ 2 4 this 3 3955  13 tag_state_key 1 3841  </span>
<span class="s0">1170 0 0 6 1155 3841 0 0 80 /**</span>
 <span class="s0">* Returns the tag key as set by a previous call to set_tag_state_key().</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1171 0 0 4 1158 3812 0 0 114 /**</span>
 <span class="s0">* Sets the multiplier for LOD distances.  This value is multiplied with the</span>
 <span class="s0">* LOD scale set on LodNodes.</span>
 <span class="s0">*/ 2 4 this 3 3955  5 value 1 3598  </span>
<span class="s0">1172 0 0 6 1159 3598 0 0 52 /**</span>
 <span class="s0">* Returns the multiplier for LOD distances.</span>
 <span class="s0">*/ 1 4 this 3 3953  </span>
<span class="s0">1173 0 0 4 1161 3812 0 0 585 /**</span>
 <span class="s0">* Associates a particular state transition with the indicated tag value.</span>
 <span class="s0">* When a node is encountered during traversal with the tag key specified by</span>
 <span class="s0">* set_tag_state_key(), if the value of that tag matches tag_state, then the</span>
 <span class="s0">* indicated state is applied to this node--but only when it is rendered by</span>
 <span class="s0">* this camera.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to apply special effects to nodes when they are rendered</span>
 <span class="s0">* by certain cameras.  It is particularly useful for multipass rendering, in</span>
 <span class="s0">* which specialty cameras might be needed to render the scene with a</span>
 <span class="s0">* particular set of effects.</span>
 <span class="s0">*/ 3 4 this 3 3955  9 tag_state 1 3841  5 state 1 3825  </span>
<span class="s0">1174 0 0 4 1162 3812 0 0 85 /**</span>
 <span class="s0">* Removes the association established by a previous call to set_tag_state().</span>
 <span class="s0">*/ 2 4 this 3 3955  9 tag_state 1 3841  </span>
<span class="s0">1175 0 0 4 1163 3812 0 0 85 /**</span>
 <span class="s0">* Removes all associations established by previous calls to set_tag_state().</span>
 <span class="s0">*/ 1 4 this 3 3955  </span>
<span class="s0">1176 0 0 6 1164 3600 0 0 119 /**</span>
 <span class="s0">* Returns true if set_tag_state() has previously been called with the</span>
 <span class="s0">* indicated tag state, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3953  9 tag_state 1 3841  </span>
<span class="s0">1177 0 0 7 1165 3825 0 0 161 /**</span>
 <span class="s0">* Returns the state associated with the indicated tag state by a previous</span>
 <span class="s0">* call to set_tag_state(), or the empty state if nothing has been associated.</span>
 <span class="s0">*/ 2 4 this 3 3953  9 tag_state 1 3841  </span>
<span class="s0">1178 0 0 4 1167 3812 0 0 157 /**</span>
 <span class="s0">* Associates the indicated AuxSceneData object with the given NodePath,</span>
 <span class="s0">* possibly replacing a previous data defined for the same NodePath, if any.</span>
 <span class="s0">*/ 3 4 this 3 3955  9 node_path 1 3884  4 data 1 3674  </span>
<span class="s0">1179 0 0 6 1168 3600 0 0 153 /**</span>
 <span class="s0">* Removes the AuxSceneData associated with the indicated NodePath.  Returns</span>
 <span class="s0">* true if it is removed successfully, false if it was already gone.</span>
 <span class="s0">*/ 2 4 this 3 3955  9 node_path 1 3884  </span>
<span class="s0">1180 0 0 7 1169 3674 2779 0 112 /**</span>
 <span class="s0">* Returns the AuxSceneData associated with the indicated NodePath, or NULL if</span>
 <span class="s0">* nothing is associated.</span>
 <span class="s0">*/ 2 4 this 3 3953  9 node_path 1 3884  </span>
<span class="s0">1181 0 0 4 1170 3812 0 0 65 /**</span>
 <span class="s0">* Outputs all of the NodePaths and AuxSceneDatas in use.</span>
 <span class="s0">*/ 2 4 this 3 3953  3 out 1 3813  </span>
<span class="s0">1182 0 0 6 1171 3593 0 0 179 /**</span>
 <span class="s0">* Walks through the list of currently-assigned AuxSceneData objects and</span>
 <span class="s0">* releases any that are past their expiration times.  Returns the number of</span>
 <span class="s0">* elements released.</span>
 <span class="s0">*/ 2 4 this 3 3955  14 current_thread 5 3844  </span>
<span class="s0">1183 0 0 7 1174 3816 0 0 0 0 </span>
<span class="s0">1184 0 0 7 1176 3957 2884 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 name 1 3841  5 plane 5 3956  </span>
<span class="s0">1185 0 0 4 1177 3812 0 0 66 /**</span>
 <span class="s0">* Sets the particular plane represented by the PlaneNode.</span>
 <span class="s0">*/ 2 4 this 3 3957  5 plane 1 3956  </span>
<span class="s0">1186 0 0 6 1178 3956 0 0 58 /**</span>
 <span class="s0">* Returns the plane represented by the PlaneNode.</span>
 <span class="s0">*/ 1 4 this 3 3958  </span>
<span class="s0">1187 0 0 4 1179 3812 0 0 115 /**</span>
 <span class="s0">* Specifies the size of the visual representation of the plane that is drawn</span>
 <span class="s0">* if the PlaneNode is shown.</span>
 <span class="s0">*/ 2 4 this 3 3957  9 viz_scale 1 3598  </span>
<span class="s0">1188 0 0 6 1180 3598 0 0 113 /**</span>
 <span class="s0">* Returns the size of the visual representation of the plane that is drawn if</span>
 <span class="s0">* the PlaneNode is shown.</span>
 <span class="s0">*/ 1 4 this 3 3958  </span>
<span class="s0">1189 0 0 4 1181 3812 0 0 454 /**</span>
 <span class="s0">* Changes the relative importance of this PlaneNode (when it is used as a</span>
 <span class="s0">* clip plane) relative to the other clip planes that are applied</span>
 <span class="s0">* simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The priority number is used to decide which of the requested clip planes</span>
 <span class="s0">* are to be activated when more clip planes are requested than the hardware</span>
 <span class="s0">* will support.  The highest-priority n planes are selected for rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to TextureStage::set_priority().</span>
 <span class="s0">*/ 2 4 this 3 3957  8 priority 1 3593  </span>
<span class="s0">1190 0 0 6 1182 3593 0 0 85 /**</span>
 <span class="s0">* Returns the priority associated with this clip plane.  See set_priority().</span>
 <span class="s0">*/ 1 4 this 3 3958  </span>
<span class="s0">1191 0 0 4 1184 3812 0 0 436 /**</span>
 <span class="s0">* Specifies the sort of things this plane will actually clip (when it is used</span>
 <span class="s0">* as a clip plane).  This is a bitmask union of ClipEffect values.  If it</span>
 <span class="s0">* includes CE_visible, then it will clip visible geometry; if it includes</span>
 <span class="s0">* CE_collision, then it will clip collision polygons.  If it includes neither</span>
 <span class="s0">* bit, it will still affect culling, but objects will either be wholly behind</span>
 <span class="s0">* the clipping plane, or wholly present.</span>
 <span class="s0">*/ 2 4 this 3 3957  11 clip_effect 1 3593  </span>
<span class="s0">1192 0 0 6 1185 3593 0 0 84 /**</span>
 <span class="s0">* Returns the clip_effect bits for this clip plane.  See set_clip_effect().</span>
 <span class="s0">*/ 1 4 this 3 3958  </span>
<span class="s0">1193 0 0 7 1193 3816 0 0 0 0 </span>
<span class="s0">1194 0 0 7 1197 3607 0 0 75 // The following is the new, more general interface to the ClipPlaneAttrib. 0 </span>
<span class="s0">1195 0 0 23 1197 3607 0 0 186 /**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that enables (or disables,</span>
 <span class="s0">* according to op) the indicated plane(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/ 2 2 op 1 3681  5 plane 1 3957  </span>
<span class="s0">1196 0 0 23 1197 3607 0 0 181 /**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that turns on (or off, according to</span>
 <span class="s0">* op) the indicate plane(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/ 3 2 op 1 3681  6 plane1 1 3957  6 plane2 1 3957  </span>
<span class="s0">1197 0 0 23 1197 3607 0 0 181 /**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that turns on (or off, according to</span>
 <span class="s0">* op) the indicate plane(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/ 4 2 op 1 3681  6 plane1 1 3957  6 plane2 1 3957  6 plane3 1 3957  </span>
<span class="s0">1198 0 0 23 1197 3607 0 0 181 /**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that turns on (or off, according to</span>
 <span class="s0">* op) the indicate plane(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/ 5 2 op 1 3681  6 plane1 1 3957  6 plane2 1 3957  6 plane3 1 3957  6 plane4 1 3957  </span>
<span class="s0">1199 0 0 7 1198 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1200 0 0 6 1199 3681 0 0 512 /**</span>
 <span class="s0">* Returns the basic operation type of the ClipPlaneAttrib.  If this is O_set,</span>
 <span class="s0">* the planes listed here completely replace any planes that were already on.</span>
 <span class="s0">* If this is O_add, the planes here are added to the set of planes that</span>
 <span class="s0">* were already on, and if O_remove, the planes here are removed from the set</span>
 <span class="s0">* of planes that were on.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and</span>
 <span class="s0">* off_planes, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/ 1 4 this 3 3960  </span>
<span class="s0">1201 0 0 6 1200 3593 0 0 234 /**</span>
 <span class="s0">* Returns the number of planes listed in the attribute.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and</span>
 <span class="s0">* off_planes, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/ 1 4 this 3 3960  </span>
<span class="s0">1202 0 0 7 1201 3957 2884 0 227 /**</span>
 <span class="s0">* Returns the nth plane listed in the attribute.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and</span>
 <span class="s0">* off_planes, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/ 2 4 this 3 3960  1 n 1 3593  </span>
<span class="s0">1203 0 0 6 1202 3600 0 0 261 /**</span>
 <span class="s0">* Returns true if the indicated plane is listed in the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated ClipPlaneAttribs nowadays have a separate list of on_planes and</span>
 <span class="s0">* off_planes, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3957  </span>
<span class="s0">1204 0 0 7 1203 3607 0 0 187 /**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane added to the list of planes.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_plane() or add_off_plane() instead.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3957  </span>
<span class="s0">1205 0 0 7 1204 3607 0 0 197 /**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane removed from the list of planes.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use remove_on_plane() or remove_off_plane() instead.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3957  </span>
<span class="s0">1206 0 0 7 1205 3607 0 0 109 /**</span>
 <span class="s0">* Constructs a new ClipPlaneAttrib object that disables all planes (and hence</span>
 <span class="s0">* disables clipping).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1207 0 0 6 1206 3593 0 0 74 /**</span>
 <span class="s0">* Returns the number of planes that are enabled by the attribute.</span>
 <span class="s0">*/ 1 4 this 3 3960  </span>
<span class="s0">1208 0 0 7 1207 3894 2739 0 82 /**</span>
 <span class="s0">* Returns the nth plane enabled by the attribute, sorted in render order.</span>
 <span class="s0">*/ 2 4 this 3 3960  1 n 1 3593  </span>
<span class="s0">1209 0 0 6 1209 3600 0 0 92 /**</span>
 <span class="s0">* Returns true if the indicated plane is enabled by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3884  </span>
<span class="s0">1210 0 0 6 1210 3593 0 0 75 /**</span>
 <span class="s0">* Returns the number of planes that are disabled by the attribute.</span>
 <span class="s0">*/ 1 4 this 3 3960  </span>
<span class="s0">1211 0 0 7 1211 3894 2739 0 99 /**</span>
 <span class="s0">* Returns the nth plane disabled by the attribute, sorted in arbitrary</span>
 <span class="s0">* (pointer) order.</span>
 <span class="s0">*/ 2 4 this 3 3960  1 n 1 3593  </span>
<span class="s0">1212 0 0 6 1213 3600 0 0 93 /**</span>
 <span class="s0">* Returns true if the indicated plane is disabled by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3884  </span>
<span class="s0">1213 0 0 6 1214 3600 0 0 97 /**</span>
 <span class="s0">* Returns true if this attrib disables all planes (although it may also</span>
 <span class="s0">* enable some).</span>
 <span class="s0">*/ 1 4 this 3 3960  </span>
<span class="s0">1214 0 0 6 1215 3600 0 0 102 /**</span>
 <span class="s0">* Returns true if this is an identity attrib: it does not change the set of</span>
 <span class="s0">* planes in use.</span>
 <span class="s0">*/ 1 4 this 3 3960  </span>
<span class="s0">1215 0 0 7 1216 3607 0 0 145 /**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane added to the list of planes enabled by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3884  </span>
<span class="s0">1216 0 0 7 1217 3607 0 0 149 /**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane removed from the list of planes enabled by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3884  </span>
<span class="s0">1217 0 0 7 1218 3607 0 0 146 /**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane added to the list of planes disabled by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3884  </span>
<span class="s0">1218 0 0 7 1219 3607 0 0 150 /**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, just like this one, but with the indicated</span>
 <span class="s0">* plane removed from the list of planes disabled by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 3960  5 plane 1 3884  </span>
<span class="s0">1219 0 0 7 1220 3960 0 0 216 /**</span>
 <span class="s0">* Returns a new ClipPlaneAttrib, very much like this one, but with the number</span>
 <span class="s0">* of on_planes reduced to be no more than max_clip_planes.  The number of</span>
 <span class="s0">* off_planes in the new ClipPlaneAttrib is undefined.</span>
 <span class="s0">*/ 2 4 this 3 3960  15 max_clip_planes 1 3593  </span>
<span class="s0">1220 0 0 6 1221 3593 0 0 0 0 </span>
<span class="s0">1221 0 0 7 1223 3816 0 0 0 0 </span>
<span class="s0">1222 0 0 7 1227 3607 0 0 127 /**</span>
 <span class="s0">* Constructs a new ColorAttrib object that indicates geometry should be</span>
 <span class="s0">* rendered according to its own vertex color.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1223 0 0 7 1228 3607 0 0 116 /**</span>
 <span class="s0">* Constructs a new ColorAttrib object that indicates geometry should be</span>
 <span class="s0">* rendered in the indicated color.</span>
 <span class="s0">*/ 1 5 color 1 3820  </span>
<span class="s0">1224 0 0 7 1229 3607 0 0 102 /**</span>
 <span class="s0">* Constructs a new ColorAttrib object that indicates geometry should be</span>
 <span class="s0">* rendered in white.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1225 0 0 7 1230 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1226 0 0 6 1231 3683 0 0 313 /**</span>
 <span class="s0">* Returns the type of color specified by this ColorAttrib.  The options are:</span>
 <span class="s0">*</span>
 <span class="s0">* T_vertex - use the vertex color specified in the geometry itself.</span>
 <span class="s0">*</span>
 <span class="s0">* T_flat - use the color specified in this ColorAttrib for all geometry.  You</span>
 <span class="s0">* can get this color via get_color().</span>
 <span class="s0">*</span>
 <span class="s0">* T_off - use the color white.</span>
 <span class="s0">*/ 1 4 this 3 3962  </span>
<span class="s0">1227 0 0 6 1232 3820 0 0 149 /**</span>
 <span class="s0">* If the type is T_flat or T_off, this returns the color that will be applied</span>
 <span class="s0">* to geometry.  If the type is T_vertex, this is meaningless.</span>
 <span class="s0">*/ 1 4 this 3 3962  </span>
<span class="s0">1228 0 0 6 1235 3593 0 0 0 0 </span>
<span class="s0">1229 0 0 7 1237 3816 0 0 0 0 </span>
<span class="s0">1230 0 0 7 1242 3607 0 0 142 /**</span>
 <span class="s0">* Constructs a new ColorBlendAttrib object that disables special-effect</span>
 <span class="s0">* blending, allowing normal transparency to be used instead.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1231 0 0 23 1243 3607 0 0 124 /**</span>
 <span class="s0">* Constructs a new ColorBlendAttrib object.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use the three- or four-parameter constructor instead.</span>
 <span class="s0">*/ 1 4 mode 1 3685  </span>
<span class="s0">1232 0 0 23 1243 3607 0 0 217 /**</span>
 <span class="s0">* Constructs a new ColorBlendAttrib object that enables special-effect</span>
 <span class="s0">* blending.  This supercedes transparency.  This form is used to specify</span>
 <span class="s0">* separate blending parameters for the RGB and alpha channels.</span>
 <span class="s0">*/ 7 8 rgb_mode 1 3685  5 rgb_a 1 3686  5 rgb_b 1 3686  10 alpha_mode 1 3685  7 alpha_a 1 3686  7 alpha_b 1 3686  5 color 5 3820  </span>
<span class="s0">1233 0 0 23 1243 3607 0 0 201 /**</span>
 <span class="s0">* Constructs a new ColorBlendAttrib object that enables special-effect</span>
 <span class="s0">* blending.  This supercedes transparency.  The given mode and operands are</span>
 <span class="s0">* used for both the RGB and alpha channels.</span>
 <span class="s0">*/ 4 4 mode 1 3685  1 a 1 3686  1 b 1 3686  5 color 5 3820  </span>
<span class="s0">1234 0 0 7 1244 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1235 0 0 6 1245 3685 0 0 58 /**</span>
 <span class="s0">* Returns the blending mode for the RGB channels.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1236 0 0 6 1246 3686 0 0 62 /**</span>
 <span class="s0">* Returns the RGB multiplier for the first component.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1237 0 0 6 1247 3686 0 0 63 /**</span>
 <span class="s0">* Returns the RGB multiplier for the second component.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1238 0 0 6 1248 3685 0 0 59 /**</span>
 <span class="s0">* Returns the blending mode for the alpha channel.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1239 0 0 6 1249 3686 0 0 64 /**</span>
 <span class="s0">* Returns the alpha multiplier for the first component.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1240 0 0 6 1250 3686 0 0 65 /**</span>
 <span class="s0">* Returns the alpha multiplier for the second component.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1241 0 0 7 1251 3905 0 0 65 /**</span>
 <span class="s0">* Returns the constant color associated with the attrib.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1242 0 0 6 1252 3600 0 0 84 /**</span>
 <span class="s0">* Returns true if the this attrib uses the constant color, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1243 0 0 6 1252 3600 0 0 93 /**</span>
 <span class="s0">* Returns true if the indicated operand uses the constant color, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 7 operand 1 3686  </span>
<span class="s0">1244 0 0 6 1253 3600 0 0 91 /**</span>
 <span class="s0">* Returns true if the this attrib uses the color scale attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3964  </span>
<span class="s0">1245 0 0 6 1253 3600 0 0 97 /**</span>
 <span class="s0">* Returns true if the indicated operand uses the color scale attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 7 operand 1 3686  </span>
<span class="s0">1246 0 0 6 1261 3593 0 0 0 0 </span>
<span class="s0">1247 0 0 7 1263 3816 0 0 0 0 </span>
<span class="s0">1248 0 0 7 1266 3607 0 0 47 /**</span>
 <span class="s0">* Constructs an identity scale attrib.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1249 0 0 23 1267 3607 0 0 120 /**</span>
 <span class="s0">* Constructs a new ColorScaleAttrib object that indicates geometry should be</span>
 <span class="s0">* scaled by the indicated factor.</span>
 <span class="s0">*/ 1 5 scale 1 3880  </span>
<span class="s0">1250 0 0 7 1268 3607 0 0 209 /**</span>
 <span class="s0">* Constructs a new ColorScaleAttrib object that ignores any ColorScaleAttrib</span>
 <span class="s0">* inherited from above.  You may also specify an additional color scale to</span>
 <span class="s0">* apply to geometry below (using set_scale()).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1251 0 0 7 1269 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1252 0 0 6 1270 3600 0 0 255 /**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib will ignore any color scales inherited</span>
 <span class="s0">* from above, false otherwise.  This is not the same thing as !has_scale(); a</span>
 <span class="s0">* ColorScaleAttrib may have the &quot;off&quot; flag set and also have another scale</span>
 <span class="s0">* specified.</span>
 <span class="s0">*/ 1 4 this 3 3966  </span>
<span class="s0">1253 0 0 6 1271 3600 0 0 128 /**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib is an identity attrib, false if it is</span>
 <span class="s0">* either an off attrib or it has a scale.</span>
 <span class="s0">*/ 1 4 this 3 3966  </span>
<span class="s0">1254 0 0 6 1272 3600 0 0 157 /**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib has a non-identity scale, false</span>
 <span class="s0">* otherwise (in which case it might be an off attrib or an identity attrib).</span>
 <span class="s0">*/ 1 4 this 3 3966  </span>
<span class="s0">1255 0 0 6 1273 3600 0 0 135 /**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib has a non-identity scale in the RGB</span>
 <span class="s0">* components (ignoring alpha), or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3966  </span>
<span class="s0">1256 0 0 6 1274 3600 0 0 134 /**</span>
 <span class="s0">* Returns true if the ColorScaleAttrib has a non-identity scale in the alpha</span>
 <span class="s0">* component (ignoring RGB), or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3966  </span>
<span class="s0">1257 0 0 6 1275 3880 0 0 53 /**</span>
 <span class="s0">* Returns the scale to be applied to colors.</span>
 <span class="s0">*/ 1 4 this 3 3966  </span>
<span class="s0">1258 0 0 7 1276 3607 0 0 116 /**</span>
 <span class="s0">* Returns a new ColorScaleAttrib, just like this one, but with the scale</span>
 <span class="s0">* changed to the indicated value.</span>
 <span class="s0">*/ 2 4 this 3 3966  5 scale 1 3880  </span>
<span class="s0">1259 0 0 6 1280 3593 0 0 0 0 </span>
<span class="s0">1260 0 0 7 1282 3816 0 0 0 0 </span>
<span class="s0">1261 0 0 23 1286 3607 0 0 52 /**</span>
 <span class="s0">* Constructs a new ColorWriteAttrib object.</span>
 <span class="s0">*/ 1 8 channels 1 3692  </span>
<span class="s0">1262 0 0 7 1287 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1263 0 0 6 1288 3692 0 0 78 /**</span>
 <span class="s0">* Returns the mask of color channels that are enabled by this attrib.</span>
 <span class="s0">*/ 1 4 this 3 3968  </span>
<span class="s0">1264 0 0 6 1291 3593 0 0 0 0 </span>
<span class="s0">1265 0 0 7 1293 3816 0 0 0 0 </span>
<span class="s0">1266 0 0 23 1297 3837 0 0 354 /**</span>
 <span class="s0">* Constructs a new CompassEffect object.  If the reference is an empty</span>
 <span class="s0">* NodePath, it means the CompassEffect is relative to the root of the scene</span>
 <span class="s0">* graph; otherwise, it's relative to the indicated node.  The properties</span>
 <span class="s0">* bitmask specifies the set of properties that the compass node inherits from</span>
 <span class="s0">* the reference instead of from its parent.</span>
 <span class="s0">*/ 2 9 reference 1 3884  10 properties 5 3593  </span>
<span class="s0">1267 0 0 6 1298 3884 0 0 150 /**</span>
 <span class="s0">* Returns the reference node from which the CompassEffect inherits its</span>
 <span class="s0">* transform.  If this is empty, it means the root of the scene graph.</span>
 <span class="s0">*/ 1 4 this 3 3970  </span>
<span class="s0">1268 0 0 6 1299 3593 0 0 131 /**</span>
 <span class="s0">* Returns the bitmask of properties that this CompassEffect object inherits</span>
 <span class="s0">* from its reference node (or from the root).</span>
 <span class="s0">*/ 1 4 this 3 3970  </span>
<span class="s0">1269 0 0 7 1300 3816 0 0 0 0 </span>
<span class="s0">1270 0 0 7 1304 3972 2960 0 0 0 </span>
<span class="s0">1271 0 0 15 1304 3972 2960 0 0 1 6 param0 0 3973  </span>
<span class="s0">1272 0 0 7 1307 3975 2131 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3841  </span>
<span class="s0">1273 0 0 4 1308 3812 0 0 123 /**</span>
 <span class="s0">* Sets the &quot;preserved&quot; flag.  When this is true, the GeomNode will be left</span>
 <span class="s0">* untouched by any flatten operations.</span>
 <span class="s0">*/ 2 4 this 3 3975  5 value 1 3600  </span>
<span class="s0">1274 0 0 6 1309 3600 0 0 126 /**</span>
 <span class="s0">* Returns the &quot;preserved&quot; flag.  When this is true, the GeomNode will be left</span>
 <span class="s0">* untouched by any flatten operations.</span>
 <span class="s0">*/ 1 4 this 3 3976  </span>
<span class="s0">1275 0 0 6 1310 3593 0 0 51 /**</span>
 <span class="s0">* Returns the number of geoms in the node.</span>
 <span class="s0">*/ 1 4 this 3 3976  </span>
<span class="s0">1276 0 0 7 1311 3980 0 0 186 /**</span>
 <span class="s0">* Returns the nth geom of the node.  This object should not be modified,</span>
 <span class="s0">* since the same object might be shared between multiple different GeomNodes,</span>
 <span class="s0">* but see modify_geom().</span>
 <span class="s0">*/ 2 4 this 3 3976  1 n 1 3593  </span>
<span class="s0">1277 0 0 7 1313 3981 0 0 641 /**</span>
 <span class="s0">* Returns the nth geom of the node, suitable for modifying it.  If the nth</span>
 <span class="s0">* Geom has multiple reference counts to it, reassigns it to an identical copy</span>
 <span class="s0">* first, and returns the new copy--this provides a &quot;copy on write&quot; that</span>
 <span class="s0">* ensures that the Geom that is returned is unique to this GeomNode and is</span>
 <span class="s0">* not shared with any other GeomNodes.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this method is called in a downstream stage (for instance,</span>
 <span class="s0">* during cull or draw), then it will propagate the new list of Geoms upstream</span>
 <span class="s0">* all the way to pipeline stage 0, which may step on changes that were made</span>
 <span class="s0">* independently in pipeline stage 0. Use with caution.</span>
 <span class="s0">*/ 2 4 this 3 3975  1 n 1 3593  </span>
<span class="s0">1278 0 0 7 1315 3825 0 0 296 /**</span>
 <span class="s0">* Returns the RenderState associated with the nth geom of the node.  This is</span>
 <span class="s0">* just the RenderState directly associated with the Geom; the actual state in</span>
 <span class="s0">* which the Geom is rendered will also be affected by RenderStates that</span>
 <span class="s0">* appear on the scene graph in nodes above this GeomNode.</span>
 <span class="s0">*/ 2 4 this 3 3976  1 n 1 3593  </span>
<span class="s0">1279 0 0 4 1317 3812 0 0 586 /**</span>
 <span class="s0">* Changes the RenderState associated with the nth geom of the node.  This is</span>
 <span class="s0">* just the RenderState directly associated with the Geom; the actual state in</span>
 <span class="s0">* which the Geom is rendered will also be affected by RenderStates that</span>
 <span class="s0">* appear on the scene graph in nodes above this GeomNode.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this method is called in a downstream stage (for instance,</span>
 <span class="s0">* during cull or draw), then it will propagate the new list of Geoms upstream</span>
 <span class="s0">* all the way to pipeline stage 0, which may step on changes that were made</span>
 <span class="s0">* independently in pipeline stage 0. Use with caution.</span>
 <span class="s0">*/ 3 4 this 3 3975  1 n 1 3593  5 state 1 3825  </span>
<span class="s0">1280 0 0 4 1318 3812 0 0 180 /**</span>
 <span class="s0">* Adds a new Geom to the node.  The geom is given the indicated state (which</span>
 <span class="s0">* may be RenderState::make_empty(), to completely inherit its state from the</span>
 <span class="s0">* scene graph).</span>
 <span class="s0">*/ 3 4 this 3 3975  4 geom 1 3981  5 state 5 3825  </span>
<span class="s0">1281 0 0 4 1319 3812 0 0 109 /**</span>
 <span class="s0">* Copies the Geoms (and their associated RenderStates) from the indicated</span>
 <span class="s0">* GeomNode into this one.</span>
 <span class="s0">*/ 2 4 this 3 3975  5 other 1 3976  </span>
<span class="s0">1282 0 0 4 1320 3812 0 0 401 /**</span>
 <span class="s0">* Replaces the nth Geom of the node with a new pointer.  There must already</span>
 <span class="s0">* be a Geom in this slot.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that if this method is called in a downstream stage (for instance,</span>
 <span class="s0">* during cull or draw), then it will propagate the new list of Geoms upstream</span>
 <span class="s0">* all the way to pipeline stage 0, which may step on changes that were made</span>
 <span class="s0">* independently in pipeline stage 0. Use with caution.</span>
 <span class="s0">*/ 3 4 this 3 3975  1 n 1 3593  4 geom 1 3981  </span>
<span class="s0">1283 0 0 4 1321 3812 0 0 46 /**</span>
 <span class="s0">* Removes the nth geom from the node.</span>
 <span class="s0">*/ 2 4 this 3 3975  1 n 1 3593  </span>
<span class="s0">1284 0 0 4 1322 3812 0 0 55 /**</span>
 <span class="s0">* Removes all the geoms from the node at once.</span>
 <span class="s0">*/ 1 4 this 3 3975  </span>
<span class="s0">1285 0 0 6 1323 3600 0 0 198 /**</span>
 <span class="s0">* Verifies that the each Geom within the GeomNode reference vertices that</span>
 <span class="s0">* actually exist within its GeomVertexData.  Returns true if the GeomNode</span>
 <span class="s0">* appears to be valid, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3976  </span>
<span class="s0">1286 0 0 4 1324 3812 0 0 431 /**</span>
 <span class="s0">* Calls decompose() on each Geom with the GeomNode.  This decomposes higher-</span>
 <span class="s0">* order primitive types, like triangle strips, into lower-order types like</span>
 <span class="s0">* indexed triangles.  Normally there is no reason to do this, but it can be</span>
 <span class="s0">* useful as an early preprocessing step, to allow a later call to unify() to</span>
 <span class="s0">* proceed more quickly.</span>
 <span class="s0">*</span>
 <span class="s0">* See also SceneGraphReducer::decompose(), which is the normal way this is</span>
 <span class="s0">* called.</span>
 <span class="s0">*/ 1 4 this 3 3975  </span>
<span class="s0">1287 0 0 4 1325 3812 0 0 901 /**</span>
 <span class="s0">* Attempts to unify all of the Geoms contained within this node into a single</span>
 <span class="s0">* Geom, or at least as few Geoms as possible.  In turn, the individual</span>
 <span class="s0">* GeomPrimitives contained within each resulting Geom are also unified.  The</span>
 <span class="s0">* goal is to reduce the number of GeomPrimitives within the node as far as</span>
 <span class="s0">* possible.  This may result in composite primitives, such as triangle strips</span>
 <span class="s0">* and triangle fans, being decomposed into triangles.  See also</span>
 <span class="s0">* Geom::unify().</span>
 <span class="s0">*</span>
 <span class="s0">* max_indices represents the maximum number of indices that will be put in</span>
 <span class="s0">* any one GeomPrimitive.  If preserve_order is true, then the primitives will</span>
 <span class="s0">* not be reordered during the operation, even if this results in a suboptimal</span>
 <span class="s0">* result.</span>
 <span class="s0">*</span>
 <span class="s0">* In order for this to be successful, the primitives must reference the same</span>
 <span class="s0">* GeomVertexData, have the same fundamental primitive type, and have</span>
 <span class="s0">* compatible shade models.</span>
 <span class="s0">*/ 3 4 this 3 3975  11 max_indices 1 3593  14 preserve_order 1 3600  </span>
<span class="s0">1288 0 0 4 1326 3812 0 0 67 /**</span>
 <span class="s0">* Writes a short description of all the Geoms in the node.</span>
 <span class="s0">*/ 3 4 this 3 3976  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">1289 0 0 4 1327 3812 0 0 70 /**</span>
 <span class="s0">* Writes a detailed description of all the Geoms in the node.</span>
 <span class="s0">*/ 3 4 this 3 3976  3 out 1 3813  12 indent_level 1 3593  </span>
<span class="s0">1290 0 0 7 1328 3850 0 0 75 /**</span>
 <span class="s0">* Returns the default into_collide_mask assigned to new GeomNodes.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1291 0 0 7 1330 3816 0 0 0 0 </span>
<span class="s0">1292 0 0 23 1332 3607 0 0 297 /**</span>
 <span class="s0">* Constructs a new CullBinAttrib assigning geometry into the named bin.  If</span>
 <span class="s0">* the bin name is the empty string, the default bin is used.</span>
 <span class="s0">*</span>
 <span class="s0">* The draw_order specifies further ordering information which is relevant</span>
 <span class="s0">* only to certain kinds of bins (in particular CullBinFixed type bins).</span>
 <span class="s0">*/ 2 8 bin_name 1 3841  10 draw_order 1 3593  </span>
<span class="s0">1293 0 0 7 1333 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1294 0 0 6 1334 3841 0 0 127 /**</span>
 <span class="s0">* Returns the name of the bin this attribute specifies.  If this is the empty</span>
 <span class="s0">* string, it refers to the default bin.</span>
 <span class="s0">*/ 1 4 this 3 3982  </span>
<span class="s0">1295 0 0 6 1335 3593 0 0 186 /**</span>
 <span class="s0">* Returns the draw order this attribute specifies.  Some bins (in particular,</span>
 <span class="s0">* CullBinFixed bins) use this to further specify the order in which objects</span>
 <span class="s0">* should be rendered.</span>
 <span class="s0">*/ 1 4 this 3 3982  </span>
<span class="s0">1296 0 0 6 1338 3593 0 0 0 0 </span>
<span class="s0">1297 0 0 7 1340 3816 0 0 0 0 </span>
<span class="s0">1298 0 0 6 1343 3593 0 0 232 /**</span>
 <span class="s0">* Defines a new bin with the indicated name, and returns the new bin_index.</span>
 <span class="s0">* If there is already a bin with the same name returns its bin_index if it</span>
 <span class="s0">* had the same properties; otherwise, reports an error and returns -1.</span>
 <span class="s0">*/ 4 4 this 3 3984  4 name 1 3841  4 type 1 3985  4 sort 1 3593  </span>
<span class="s0">1299 0 0 4 1344 3812 0 0 357 /**</span>
 <span class="s0">* Permanently removes the indicated bin.  This operation is not protected</span>
 <span class="s0">* from the pipeline and will disturb whatever is currently rendering in draw.</span>
 <span class="s0">* You should not call this during the normal course of rendering a frame; it</span>
 <span class="s0">* is intended only as an aid to development, to allow the developer to</span>
 <span class="s0">* interactively fiddle with the set of bins.</span>
 <span class="s0">*/ 2 4 this 3 3984  9 bin_index 1 3593  </span>
<span class="s0">1300 0 0 6 1345 3593 0 0 51 /**</span>
 <span class="s0">* Returns the number of bins in the world.</span>
 <span class="s0">*/ 1 4 this 3 3986  </span>
<span class="s0">1301 0 0 6 1346 3593 0 0 240 /**</span>
 <span class="s0">* Returns the bin_index of the nth bin in the set, where n is a number</span>
 <span class="s0">* between 0 and get_num_bins(). This returns the list of bin_index numbers,</span>
 <span class="s0">* in sorted order (that is, in the order in which the bins should be</span>
 <span class="s0">* rendered).</span>
 <span class="s0">*/ 2 4 this 3 3986  1 n 1 3593  </span>
<span class="s0">1302 0 0 6 1348 3593 0 0 109 /**</span>
 <span class="s0">* Returns the bin_index associated with the bin of the given name, or -1 if</span>
 <span class="s0">* no bin has that name.</span>
 <span class="s0">*/ 2 4 this 3 3986  4 name 1 3841  </span>
<span class="s0">1303 0 0 6 1349 3841 0 0 196 /**</span>
 <span class="s0">* Returns the name of the bin with the indicated bin_index (where bin_index</span>
 <span class="s0">* was retrieved by get_bin() or find_bin()).  The bin's name may not be</span>
 <span class="s0">* changed during the life of the bin.</span>
 <span class="s0">*/ 2 4 this 3 3986  9 bin_index 1 3593  </span>
<span class="s0">1304 0 0 6 1350 3985 0 0 130 /**</span>
 <span class="s0">* Returns the type of the bin with the indicated bin_index (where bin_index</span>
 <span class="s0">* was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*/ 2 4 this 3 3986  9 bin_index 1 3593  </span>
<span class="s0">1305 0 0 6 1350 3985 0 0 63 /**</span>
 <span class="s0">* Returns the type of the bin with the indicated name.</span>
 <span class="s0">*/ 2 4 this 3 3986  4 name 1 3841  </span>
<span class="s0">1306 0 0 4 1351 3812 0 0 244 /**</span>
 <span class="s0">* Changes the type of the bin with the indicated bin_index (where bin_index</span>
 <span class="s0">* was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* The change might be effective immediately, or it might take place next</span>
 <span class="s0">* frame, depending on the bin type.</span>
 <span class="s0">*/ 3 4 this 3 3984  9 bin_index 1 3593  4 type 1 3985  </span>
<span class="s0">1307 0 0 4 1351 3812 0 0 177 /**</span>
 <span class="s0">* Changes the type of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* The change might be effective immediately, or it might take place next</span>
 <span class="s0">* frame, depending on the bin type.</span>
 <span class="s0">*/ 3 4 this 3 3984  4 name 1 3841  4 type 1 3985  </span>
<span class="s0">1308 0 0 6 1352 3593 0 0 274 /**</span>
 <span class="s0">* Returns the sort order of the bin with the indicated bin_index (where</span>
 <span class="s0">* bin_index was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* The bins are rendered in increasing order by their sort order; this number</span>
 <span class="s0">* may be changed from time to time to reorder the bins.</span>
 <span class="s0">*/ 2 4 this 3 3986  9 bin_index 1 3593  </span>
<span class="s0">1309 0 0 6 1352 3593 0 0 207 /**</span>
 <span class="s0">* Returns the sort order of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* The bins are rendered in increasing order by their sort order; this number</span>
 <span class="s0">* may be changed from time to time to reorder the bins.</span>
 <span class="s0">*/ 2 4 this 3 3986  4 name 1 3841  </span>
<span class="s0">1310 0 0 4 1353 3812 0 0 274 /**</span>
 <span class="s0">* Changes the sort order of the bin with the indicated bin_index (where</span>
 <span class="s0">* bin_index was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* The bins are rendered in increasing order by their sort order; this number</span>
 <span class="s0">* may be changed from time to time to reorder the bins.</span>
 <span class="s0">*/ 3 4 this 3 3984  9 bin_index 1 3593  4 sort 1 3593  </span>
<span class="s0">1311 0 0 4 1353 3812 0 0 207 /**</span>
 <span class="s0">* Changes the sort order of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* The bins are rendered in increasing order by their sort order; this number</span>
 <span class="s0">* may be changed from time to time to reorder the bins.</span>
 <span class="s0">*/ 3 4 this 3 3984  4 name 1 3841  4 sort 1 3593  </span>
<span class="s0">1312 0 0 6 1354 3600 0 0 219 /**</span>
 <span class="s0">* Returns the active flag of the bin with the indicated bin_index (where</span>
 <span class="s0">* bin_index was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* When a bin is marked inactive, all geometry assigned to it is not rendered.</span>
 <span class="s0">*/ 2 4 this 3 3986  9 bin_index 1 3593  </span>
<span class="s0">1313 0 0 6 1354 3600 0 0 152 /**</span>
 <span class="s0">* Returns the active flag of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* When a bin is marked inactive, all geometry assigned to it is not rendered.</span>
 <span class="s0">*/ 2 4 this 3 3986  4 name 1 3841  </span>
<span class="s0">1314 0 0 4 1355 3812 0 0 219 /**</span>
 <span class="s0">* Changes the active flag of the bin with the indicated bin_index (where</span>
 <span class="s0">* bin_index was retrieved by get_bin() or find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* When a bin is marked inactive, all geometry assigned to it is not rendered.</span>
 <span class="s0">*/ 3 4 this 3 3984  9 bin_index 1 3593  6 active 1 3600  </span>
<span class="s0">1315 0 0 4 1355 3812 0 0 152 /**</span>
 <span class="s0">* Changes the active flag of the bin with the indicated name.</span>
 <span class="s0">*</span>
 <span class="s0">* When a bin is marked inactive, all geometry assigned to it is not rendered.</span>
 <span class="s0">*/ 3 4 this 3 3984  4 name 1 3841  6 active 1 3600  </span>
<span class="s0">1316 0 0 6 1356 3600 0 0 227 /**</span>
 <span class="s0">* Returns true if the bin with the given bin_index is configured to flash at</span>
 <span class="s0">* a predetermined color (where bin_index was retrieved by get_bin() or</span>
 <span class="s0">* find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not available in release builds.</span>
 <span class="s0">*/ 2 4 this 3 3986  9 bin_index 1 3593  </span>
<span class="s0">1317 0 0 6 1357 3820 0 0 147 /**</span>
 <span class="s0">* Returns the color that this bin has been configured to flash to, if</span>
 <span class="s0">* configured.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not available in release builds.</span>
 <span class="s0">*/ 2 4 this 3 3986  9 bin_index 1 3593  </span>
<span class="s0">1318 0 0 4 1358 3812 0 0 216 /**</span>
 <span class="s0">* When set to true, the given bin_index is configured to flash at a</span>
 <span class="s0">* predetermined color (where bin_index was retrieved by get_bin() or</span>
 <span class="s0">* find_bin()).</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not available in release builds.</span>
 <span class="s0">*/ 3 4 this 3 3984  9 bin_index 1 3593  6 active 1 3600  </span>
<span class="s0">1319 0 0 4 1359 3812 0 0 113 /**</span>
 <span class="s0">* Changes the flash color for the given bin index.</span>
 <span class="s0">*</span>
 <span class="s0">* This method is not available in release builds.</span>
 <span class="s0">*/ 3 4 this 3 3984  9 bin_index 1 3593  5 color 1 3820  </span>
<span class="s0">1320 0 0 4 1360 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 3986  3 out 1 3813  </span>
<span class="s0">1321 0 0 6 1361 3984 0 0 67 /**</span>
 <span class="s0">* Returns the pointer to the global CullBinManager object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1322 0 0 23 1364 3607 0 0 400 /**</span>
 <span class="s0">* Constructs a new CullFaceAttrib object that specifies how to cull geometry.</span>
 <span class="s0">* By Panda convention, vertices are ordered counterclockwise when seen from</span>
 <span class="s0">* the front, so the M_cull_clockwise will cull backfacing polygons.</span>
 <span class="s0">*</span>
 <span class="s0">* M_cull_unchanged is an identity attrib; if this is applied to vertices</span>
 <span class="s0">* without any other intervening attrib, it is the same as applying the</span>
 <span class="s0">* default attrib.</span>
 <span class="s0">*/ 1 4 mode 5 3701  </span>
<span class="s0">1323 0 0 7 1365 3607 0 0 246 /**</span>
 <span class="s0">* Constructs a new CullFaceAttrib object that reverses the effects of any</span>
 <span class="s0">* other CullFaceAttrib objects in the scene graph.  M_cull_clockwise will be</span>
 <span class="s0">* treated as M_cull_counter_clockwise, and vice-versa.  M_cull_none is</span>
 <span class="s0">* unchanged.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1324 0 0 7 1366 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1325 0 0 6 1367 3701 0 0 131 /**</span>
 <span class="s0">* Returns the actual culling mode, without considering the effects of the</span>
 <span class="s0">* reverse flag.  See also get_effective_mode().</span>
 <span class="s0">*/ 1 4 this 3 3988  </span>
<span class="s0">1326 0 0 6 1368 3600 0 0 299 /**</span>
 <span class="s0">* Returns the 'reverse' flag.  If this is true, the actual cull direction</span>
 <span class="s0">* (clockwise vs.  counterclockwise) is the reverse of what is specified here.</span>
 <span class="s0">* This allows support for make_reverse(), which defines a CullFaceAttrib that</span>
 <span class="s0">* reverses whatever the sense of culling would have been.</span>
 <span class="s0">*/ 1 4 this 3 3988  </span>
<span class="s0">1327 0 0 6 1369 3701 0 0 220 /**</span>
 <span class="s0">* Returns the effective culling mode.  This is the same as the actual culling</span>
 <span class="s0">* mode, unless the reverse flag is set, which swaps CW for CCW and vice-</span>
 <span class="s0">* versa.  Also, M_cull_unchanged is mapped to M_cull_none.</span>
 <span class="s0">*/ 1 4 this 3 3988  </span>
<span class="s0">1328 0 0 6 1373 3593 0 0 0 0 </span>
<span class="s0">1329 0 0 7 1375 3816 0 0 0 0 </span>
<span class="s0">1330 0 0 15 1394 3990 3028 0 0 1 6 param0 0 3831  </span>
<span class="s0">1331 0 0 7 1384 3650 2131 0 48 /**</span>
 <span class="s0">* Returns the node traversed to so far.</span>
 <span class="s0">*/ 1 4 this 3 3831  </span>
<span class="s0">1332 0 0 7 1385 3794 0 0 99 /**</span>
 <span class="s0">* Returns the modelview transform: the relative transform from the camera to</span>
 <span class="s0">* the model.</span>
 <span class="s0">*/ 2 4 this 3 3831  4 trav 1 3991  </span>
<span class="s0">1333 0 0 7 1386 3794 0 0 110 /**</span>
 <span class="s0">* Returns the internal transform: the modelview transform in the GSG's</span>
 <span class="s0">* internal coordinate system.</span>
 <span class="s0">*/ 2 4 this 3 3831  4 trav 1 3991  </span>
<span class="s0">1334 0 0 7 1387 3794 0 0 113 /**</span>
 <span class="s0">* Returns the net transform: the relative transform from root of the scene</span>
 <span class="s0">* graph to the current node.</span>
 <span class="s0">*/ 2 4 this 3 3831  4 trav 1 3991  </span>
<span class="s0">1335 0 0 6 1388 3600 0 0 252 /**</span>
 <span class="s0">* Returns true if the current node is within the view frustum, false</span>
 <span class="s0">* otherwise.  If the node's bounding volume falls completely within the view</span>
 <span class="s0">* frustum, this will also reset the view frustum pointer, saving some work</span>
 <span class="s0">* for future nodes.</span>
 <span class="s0">*/ 2 4 this 3 3990  11 camera_mask 1 3993  </span>
<span class="s0">1336 0 0 6 1389 3600 0 0 234 /**</span>
 <span class="s0">* Returns true if this particular node is hidden, even though we might be</span>
 <span class="s0">* traversing past this node to find a child node that has had show_through()</span>
 <span class="s0">* called for it.  If this returns true, the node should not be rendered.</span>
 <span class="s0">*/ 2 4 this 3 3831  11 camera_mask 1 3993  </span>
<span class="s0">1337 0 0 4 1390 3812 0 0 128 /**</span>
 <span class="s0">* Applies the transform and state from the current node onto the current</span>
 <span class="s0">* data.  This also evaluates billboards, etc.</span>
 <span class="s0">*/ 2 4 this 3 3990  4 trav 1 3830  </span>
<span class="s0">1338 0 0 4 1391 3812 0 0 73 /**</span>
 <span class="s0">* Applies the indicated transform changes onto the current data.</span>
 <span class="s0">*/ 2 4 this 3 3990  14 node_transform 1 3794  </span>
<span class="s0">1339 0 0 15 1425 3997 3058 0 0 1 6 param0 0 3995  </span>
<span class="s0">1340 0 0 4 1397 3812 0 0 54 /**</span>
 <span class="s0">* Specifies the display region for the scene.</span>
 <span class="s0">*/ 2 4 this 3 3997  14 display_region 1 3670  </span>
<span class="s0">1341 0 0 6 1398 3670 0 0 52 /**</span>
 <span class="s0">* Returns the display region for the scene.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1342 0 0 4 1399 3812 0 0 74 /**</span>
 <span class="s0">* Specifies the size of the viewport (display region), in pixels.</span>
 <span class="s0">*/ 3 4 this 3 3997  5 width 1 3593  6 height 1 3593  </span>
<span class="s0">1343 0 0 6 1400 3593 0 0 72 /**</span>
 <span class="s0">* Returns the width of the viewport (display region) in pixels.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1344 0 0 6 1401 3593 0 0 73 /**</span>
 <span class="s0">* Returns the height of the viewport (display region) in pixels.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1345 0 0 4 1402 3812 0 0 48 /**</span>
 <span class="s0">* Specifies the root node of the scene.</span>
 <span class="s0">*/ 2 4 this 3 3997  10 scene_root 1 3884  </span>
<span class="s0">1346 0 0 6 1403 3884 0 0 46 /**</span>
 <span class="s0">* Returns the root node of the scene.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1347 0 0 4 1404 3812 0 0 48 /**</span>
 <span class="s0">* Specifies the NodePath to the camera.</span>
 <span class="s0">*/ 2 4 this 3 3997  11 camera_path 1 3884  </span>
<span class="s0">1348 0 0 6 1405 3884 0 0 46 /**</span>
 <span class="s0">* Returns the NodePath to the camera.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1349 0 0 4 1406 3812 0 0 57 /**</span>
 <span class="s0">* Specifies the camera used to render the scene.</span>
 <span class="s0">*/ 2 4 this 3 3997  11 camera_node 1 3955  </span>
<span class="s0">1350 0 0 7 1407 3955 2826 0 55 /**</span>
 <span class="s0">* Returns the camera used to render the scene.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1351 0 0 4 1408 3812 0 0 60 /**</span>
 <span class="s0">* Indicates the particular Lens used for rendering.</span>
 <span class="s0">*/ 2 4 this 3 3997  4 lens 1 3948  </span>
<span class="s0">1352 0 0 7 1409 3948 0 0 58 /**</span>
 <span class="s0">* Returns the particular Lens used for rendering.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1353 0 0 4 1410 3812 0 0 220 /**</span>
 <span class="s0">* Changes the current setting of the inverted flag.  When this is true, the</span>
 <span class="s0">* scene is rendered into the window upside-down and backwards, that is,</span>
 <span class="s0">* inverted as if viewed through a mirror placed on the floor.</span>
 <span class="s0">*/ 2 4 this 3 3997  8 inverted 1 3600  </span>
<span class="s0">1354 0 0 6 1411 3600 0 0 177 /**</span>
 <span class="s0">* Returns the current setting of the inverted flag.  When this is true, the</span>
 <span class="s0">* scene is rendered into the window upside-down, flipped like a mirror along</span>
 <span class="s0">* the X axis.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1355 0 0 6 1412 3884 0 0 207 /**</span>
 <span class="s0">* Returns the point from which the culling operations will be performed.</span>
 <span class="s0">* This is normally the camera, but if camera-&gt;set_cull_center() has been</span>
 <span class="s0">* specified, it will be that special node instead.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1356 0 0 7 1413 3672 0 0 246 /**</span>
 <span class="s0">* Returns the bounding volume that should be used to perform view-frustum</span>
 <span class="s0">* culling (in the space of get_cull_center()).  This is normally the current</span>
 <span class="s0">* lens' bounding volume, but it may be overridden with</span>
 <span class="s0">* Camera::set_cull_bounds().</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1357 0 0 4 1414 3812 0 0 129 /**</span>
 <span class="s0">* Sets the initial state which is applied to all nodes in the scene, as if it</span>
 <span class="s0">* were set at the top of the scene graph.</span>
 <span class="s0">*/ 2 4 this 3 3997  13 initial_state 1 3825  </span>
<span class="s0">1358 0 0 7 1415 3825 0 0 86 /**</span>
 <span class="s0">* Returns the initial state as set by a previous call to set_initial_state().</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1359 0 0 4 1416 3812 0 0 78 /**</span>
 <span class="s0">* Specifies the position of the camera relative to the starting node.</span>
 <span class="s0">*/ 2 4 this 3 3997  16 camera_transform 1 3794  </span>
<span class="s0">1360 0 0 7 1417 3794 0 0 76 /**</span>
 <span class="s0">* Returns the position of the camera relative to the starting node.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1361 0 0 4 1418 3812 0 0 127 /**</span>
 <span class="s0">* Specifies the position of the starting node relative to the camera.  This</span>
 <span class="s0">* is the inverse of the camera transform.</span>
 <span class="s0">*/ 2 4 this 3 3997  15 world_transform 1 3794  </span>
<span class="s0">1362 0 0 7 1419 3794 0 0 125 /**</span>
 <span class="s0">* Returns the position of the starting node relative to the camera.  This is</span>
 <span class="s0">* the inverse of the camera transform.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1363 0 0 4 1420 3812 0 0 114 /**</span>
 <span class="s0">* Specifies the transform from the camera's coordinate system to the GSG's</span>
 <span class="s0">* internal coordinate system.</span>
 <span class="s0">*/ 2 4 this 3 3997  12 cs_transform 1 3794  </span>
<span class="s0">1364 0 0 7 1421 3794 0 0 112 /**</span>
 <span class="s0">* Returns the transform from the camera's coordinate system to the GSG's</span>
 <span class="s0">* internal coordinate system.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1365 0 0 4 1422 3812 0 0 124 /**</span>
 <span class="s0">* Specifies the position from the starting node relative to the camera, in</span>
 <span class="s0">* the GSG's internal coordinate system.</span>
 <span class="s0">*/ 2 4 this 3 3997  18 cs_world_transform 1 3794  </span>
<span class="s0">1366 0 0 7 1423 3794 0 0 122 /**</span>
 <span class="s0">* Returns the position from the starting node relative to the camera, in the</span>
 <span class="s0">* GSG's internal coordinate system.</span>
 <span class="s0">*/ 1 4 this 3 3995  </span>
<span class="s0">1367 0 0 7 1424 3816 0 0 0 0 </span>
<span class="s0">1368 0 0 7 1428 3708 2131 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3841  </span>
<span class="s0">1369 0 0 6 1430 3706 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 3998  </span>
<span class="s0">1370 0 0 4 1431 3812 0 0 586 /**</span>
 <span class="s0">* Specifies the computation that is used to determine the fog effect.  If</span>
 <span class="s0">* this is M_linear, then the fog will range from linearly from the onset</span>
 <span class="s0">* point to the opaque point (or for the distances specified in</span>
 <span class="s0">* set_linear_range), and the fog object should be parented into the scene</span>
 <span class="s0">* graph, or to the camera.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is anything else, the onset point and opaque point are not used,</span>
 <span class="s0">* and the fog effect is based on the value specified to set_exp_density(),</span>
 <span class="s0">* and it doesn't matter to which node the fog object is parented, or if it is</span>
 <span class="s0">* parented anywhere at all.</span>
 <span class="s0">*/ 2 4 this 3 3708  4 mode 1 3706  </span>
<span class="s0">1371 0 0 6 1433 3820 0 0 40 /**</span>
 <span class="s0">* Returns the color of the fog.</span>
 <span class="s0">*/ 1 4 this 3 3998  </span>
<span class="s0">1372 0 0 4 1434 3812 0 0 71 /**</span>
 <span class="s0">* Sets the color of the fog.  The alpha component is not used.</span>
 <span class="s0">*/ 2 4 this 3 3708  5 color 1 3820  </span>
<span class="s0">1373 0 0 4 1434 3812 0 0 37 /**</span>
 <span class="s0">* Sets the color of the fog.</span>
 <span class="s0">*/ 4 4 this 3 3708  1 r 1 3598  1 g 1 3598  1 b 1 3598  </span>
<span class="s0">1374 0 0 4 1436 3812 0 0 400 /**</span>
 <span class="s0">* Specifies the effects of the fog in linear distance units.  This is only</span>
 <span class="s0">* used if the mode is M_linear.</span>
 <span class="s0">*</span>
 <span class="s0">* This specifies a fog that begins at distance onset units from the origin,</span>
 <span class="s0">* and becomes totally opaque at distance opaque units from the origin, along</span>
 <span class="s0">* the forward axis (usually Y).</span>
 <span class="s0">*</span>
 <span class="s0">* This function also implicitly sets the mode the M_linear, if it is not</span>
 <span class="s0">* already set.</span>
 <span class="s0">*/ 3 4 this 3 3708  5 onset 1 3598  6 opaque 1 3598  </span>
<span class="s0">1375 0 0 6 1437 3809 0 0 109 /**</span>
 <span class="s0">* Returns the point in space at which the fog begins.  This is only used if</span>
 <span class="s0">* the mode is M_linear.</span>
 <span class="s0">*/ 1 4 this 3 3998  </span>
<span class="s0">1376 0 0 4 1438 3812 0 0 111 /**</span>
 <span class="s0">* Specifies the point in space at which the fog begins.  This is only used if</span>
 <span class="s0">* the mode is M_linear.</span>
 <span class="s0">*/ 2 4 this 3 3708  18 linear_onset_point 1 3809  </span>
<span class="s0">1377 0 0 4 1438 3812 0 0 111 /**</span>
 <span class="s0">* Specifies the point in space at which the fog begins.  This is only used if</span>
 <span class="s0">* the mode is M_linear.</span>
 <span class="s0">*/ 4 4 this 3 3708  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">1378 0 0 6 1440 3809 0 0 130 /**</span>
 <span class="s0">* Returns the point in space at which the fog completely obscures geometry.</span>
 <span class="s0">* This is only used if the mode is M_linear.</span>
 <span class="s0">*/ 1 4 this 3 3998  </span>
<span class="s0">1379 0 0 4 1441 3812 0 0 132 /**</span>
 <span class="s0">* Specifies the point in space at which the fog completely obscures geometry.</span>
 <span class="s0">* This is only used if the mode is M_linear.</span>
 <span class="s0">*/ 2 4 this 3 3708  19 linear_opaque_point 1 3809  </span>
<span class="s0">1380 0 0 4 1441 3812 0 0 132 /**</span>
 <span class="s0">* Specifies the point in space at which the fog completely obscures geometry.</span>
 <span class="s0">* This is only used if the mode is M_linear.</span>
 <span class="s0">*/ 4 4 this 3 3708  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">1381 0 0 4 1443 3812 0 0 1553 /**</span>
 <span class="s0">* Fog effects are traditionally defined in camera-relative space, but the</span>
 <span class="s0">* Panda Fog node has a special mode in which it can define a linear fog</span>
 <span class="s0">* effect in an arbitrary coordinate space.</span>
 <span class="s0">*</span>
 <span class="s0">* This is done by specifying 3-d onset and opaque points, and parenting the</span>
 <span class="s0">* Fog object somewhere within the scene graph.  In this mode, the fog will be</span>
 <span class="s0">* rendered as if it extended along the vector from the onset point to the</span>
 <span class="s0">* opaque point, in 3-d space.</span>
 <span class="s0">*</span>
 <span class="s0">* However, the underlying fog effect supported by hardware is generally only</span>
 <span class="s0">* one-dimensional, and must be rendered based on linear distance from the</span>
 <span class="s0">* camera plane.  Thus, this in-the-world effect is most effective when the</span>
 <span class="s0">* fog vector from onset point to opaque point is most nearly parallel to the</span>
 <span class="s0">* camera's eye vector.</span>
 <span class="s0">*</span>
 <span class="s0">* As the angle between the fog vector and the eye vector increases, the</span>
 <span class="s0">* accuracy of the effect diminishes, up to a complete breakdown of the effect</span>
 <span class="s0">* at a 90 degree angle.</span>
 <span class="s0">*</span>
 <span class="s0">* This function exists to define the workaround to this problem.  The linear</span>
 <span class="s0">* fallback parameters given here specify how the fog should be rendered when</span>
 <span class="s0">* the parameters are exceeded in this way.</span>
 <span class="s0">*</span>
 <span class="s0">* The angle parameter is the minimum angle, in degrees, of the fog vector to</span>
 <span class="s0">* the eye vector, at which the fallback effect should be employed.  The onset</span>
 <span class="s0">* and opaque parameters specify the camera-relative onset and opaque</span>
 <span class="s0">* distances to pass to the rendering hardware when employing the fallback</span>
 <span class="s0">* effect.  This supercedes the 3-d onset point and opaque points.</span>
 <span class="s0">*/ 4 4 this 3 3708  5 angle 1 3598  5 onset 1 3598  6 opaque 1 3598  </span>
<span class="s0">1382 0 0 6 1444 3598 0 0 122 /**</span>
 <span class="s0">* Returns the density of the fog for exponential calculations.  This is only</span>
 <span class="s0">* used if the mode is not M_linear.</span>
 <span class="s0">*/ 1 4 this 3 3998  </span>
<span class="s0">1383 0 0 4 1445 3812 0 0 221 /**</span>
 <span class="s0">* Sets the density of the fog for exponential calculations.  This is only</span>
 <span class="s0">* used if the mode is not M_linear.</span>
 <span class="s0">*</span>
 <span class="s0">* If the mode is currently set to M_linear, this function implicitly sets it</span>
 <span class="s0">* to M_exponential.</span>
 <span class="s0">*/ 2 4 this 3 3708  11 exp_density 1 3598  </span>
<span class="s0">1384 0 0 7 1447 3816 0 0 0 0 </span>
<span class="s0">1385 0 0 23 1449 3607 0 0 103 /**</span>
 <span class="s0">* Constructs a new FogAttrib object suitable for rendering the indicated fog</span>
 <span class="s0">* onto geometry.</span>
 <span class="s0">*/ 1 3 fog 1 3708  </span>
<span class="s0">1386 0 0 7 1450 3607 0 0 84 /**</span>
 <span class="s0">* Constructs a new FogAttrib object suitable for rendering unfogd geometry.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1387 0 0 7 1451 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1388 0 0 6 1452 3600 0 0 105 /**</span>
 <span class="s0">* Returns true if the FogAttrib is an 'off' FogAttrib, indicating that it</span>
 <span class="s0">* should disable fog.</span>
 <span class="s0">*/ 1 4 this 3 4000  </span>
<span class="s0">1389 0 0 7 1453 3708 2131 0 118 /**</span>
 <span class="s0">* If the FogAttrib is not an 'off' FogAttrib, returns the fog that is</span>
 <span class="s0">* associated.  Otherwise, return NULL.</span>
 <span class="s0">*/ 1 4 this 3 4000  </span>
<span class="s0">1390 0 0 6 1456 3593 0 0 0 0 </span>
<span class="s0">1391 0 0 7 1458 3816 0 0 0 0 </span>
<span class="s0">1392 0 0 7 1461 3830 3107 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1393 0 0 15 1461 3830 3107 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 3991  </span>
<span class="s0">1394 0 0 7 1462 3851 0 0 55 /**</span>
 <span class="s0">* Returns the GraphicsStateGuardian in effect.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1395 0 0 7 1463 3844 0 0 104 /**</span>
 <span class="s0">* Returns the currently-executing thread object, as passed to the</span>
 <span class="s0">* CullTraverser constructor.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1396 0 0 4 1464 3812 0 0 134 /**</span>
 <span class="s0">* Sets the SceneSetup object that indicates the initial camera position, etc.</span>
 <span class="s0">* This must be called before traversal begins.</span>
 <span class="s0">*/ 4 4 this 3 3830  11 scene_setup 1 3997  3 gsg 1 3851  20 dr_incomplete_render 1 3600  </span>
<span class="s0">1397 0 0 7 1465 3997 3058 0 41 /**</span>
 <span class="s0">* Returns the SceneSetup object.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1398 0 0 6 1466 3600 0 0 114 /**</span>
 <span class="s0">* Returns true if a nonempty tag state key has been specified for the scene's</span>
 <span class="s0">* camera, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1399 0 0 6 1467 3841 0 0 95 /**</span>
 <span class="s0">* Returns the tag state key that has been specified for the scene's camera,</span>
 <span class="s0">* if any.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1400 0 0 4 1468 3812 0 0 276 /**</span>
 <span class="s0">* Changes the visibility mask for the camera viewing the scene.  This is</span>
 <span class="s0">* normally set automatically at the time setup_scene() is called; you should</span>
 <span class="s0">* change this only if you want to render some set of objects different from</span>
 <span class="s0">* what the camera normally would draw.</span>
 <span class="s0">*/ 2 4 this 3 3830  11 camera_mask 1 3993  </span>
<span class="s0">1401 0 0 6 1469 3993 0 0 73 /**</span>
 <span class="s0">* Returns the visibility mask from the camera viewing the scene.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1402 0 0 7 1470 3794 0 0 76 /**</span>
 <span class="s0">* Returns the position of the camera relative to the starting node.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1403 0 0 7 1471 3794 0 0 362 /**</span>
 <span class="s0">* Returns the position of the starting node relative to the camera.  This is</span>
 <span class="s0">* the inverse of the camera transform.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this value is always the position of the starting node, not the</span>
 <span class="s0">* current node, even if it is sampled during a traversal.  To get the</span>
 <span class="s0">* transform of the current node use</span>
 <span class="s0">* CullTraverserData::get_modelview_transform().</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1404 0 0 7 1472 3825 0 0 149 /**</span>
 <span class="s0">* Returns the initial RenderState at the top of the scene graph we are</span>
 <span class="s0">* traversing, or the empty state if the initial state was never set.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1405 0 0 6 1473 3600 0 0 96 /**</span>
 <span class="s0">* Returns true, as depth offsets are the only way that we implement decals</span>
 <span class="s0">* nowadays.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1406 0 0 4 1474 3812 0 0 154 /**</span>
 <span class="s0">* Specifies the bounding volume that corresponds to the view frustum.  Any</span>
 <span class="s0">* primitives that fall entirely outside of this volume are not drawn.</span>
 <span class="s0">*/ 2 4 this 3 3830  12 view_frustum 1 4002  </span>
<span class="s0">1407 0 0 7 1475 4002 0 0 423 /**</span>
 <span class="s0">* Returns the bounding volume that corresponds to the view frustum, or NULL</span>
 <span class="s0">* if the view frustum is not in use or has not been set.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the view frustum returned here is always in the coordinate space</span>
 <span class="s0">* of the starting node, not the current node, even if it is sampled during a</span>
 <span class="s0">* traversal.  To get the view frustum in the current node's coordinate space,</span>
 <span class="s0">* check in the current CullTraverserData.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1408 0 0 4 1476 3812 0 0 115 /**</span>
 <span class="s0">* Specifies the object that will receive the culled Geoms.  This must be set</span>
 <span class="s0">* before calling traverse().</span>
 <span class="s0">*/ 2 4 this 3 3830  12 cull_handler 1 4004  </span>
<span class="s0">1409 0 0 6 1477 4004 0 0 65 /**</span>
 <span class="s0">* Returns the object that will receive the culled Geoms.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1410 0 0 4 1478 3812 0 0 108 /**</span>
 <span class="s0">* Specifies _portal_clipper object pointer that subsequent traverse() or</span>
 <span class="s0">* traverse_below may use.</span>
 <span class="s0">*/ 2 4 this 3 3830  14 portal_clipper 1 4006  </span>
<span class="s0">1411 0 0 6 1479 4006 0 0 46 /**</span>
 <span class="s0">* Returns the _portal_clipper pointer</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1412 0 0 6 1480 3600 0 0 341 /**</span>
 <span class="s0">* Returns true if the cull traversal is effectively in incomplete_render</span>
 <span class="s0">* state, considering both the GSG's incomplete_render and the current</span>
 <span class="s0">* DisplayRegion's incomplete_render flags.  This returns the flag during the</span>
 <span class="s0">* cull traversal; see GSG::get_effective_incomplete_render() for this same</span>
 <span class="s0">* flag during the draw traversal.</span>
 <span class="s0">*/ 1 4 this 3 3991  </span>
<span class="s0">1413 0 0 4 1481 3812 0 0 161 /**</span>
 <span class="s0">* Traverses from the next node with the given data, which has been</span>
 <span class="s0">* constructed with the node but has not yet been converted into the node's</span>
 <span class="s0">* space.</span>
 <span class="s0">*/ 2 4 this 3 3830  4 data 1 3990  </span>
<span class="s0">1414 0 0 4 1481 3812 0 0 56 /**</span>
 <span class="s0">* Begins the traversal from the indicated node.</span>
 <span class="s0">*/ 2 4 this 3 3830  4 root 1 3884  </span>
<span class="s0">1415 0 0 4 1482 3812 0 0 132 /**</span>
 <span class="s0">* Traverses all the children of the indicated node, with the given data,</span>
 <span class="s0">* which has been converted into the node's space.</span>
 <span class="s0">*/ 2 4 this 3 3830  4 data 1 3990  </span>
<span class="s0">1416 0 0 4 1483 3812 0 0 141 /**</span>
 <span class="s0">* Should be called when the traverser has finished traversing its scene, this</span>
 <span class="s0">* gives it a chance to do any necessary finalization.</span>
 <span class="s0">*/ 1 4 this 3 3830  </span>
<span class="s0">1417 0 0 4 1484 3812 0 0 61 /**</span>
 <span class="s0">* Flushes the PStatCollectors used during traversal.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1418 0 0 4 1485 3812 0 0 79 /**</span>
 <span class="s0">* Draws an appropriate visualization of the indicated bounding volume.</span>
 <span class="s0">*/ 3 4 this 3 3991  3 vol 1 3853  18 internal_transform 1 3794  </span>
<span class="s0">1419 0 0 7 1486 3816 0 0 0 0 </span>
<span class="s0">1420 0 0 6 1490 4010 0 0 74 /**</span>
 <span class="s0">* Returns a pointer to the particular object that is being drawn.</span>
 <span class="s0">*/ 1 4 this 3 4008  </span>
<span class="s0">1421 0 0 7 1491 3851 0 0 48 /**</span>
 <span class="s0">* Returns a pointer to the current GSG.</span>
 <span class="s0">*/ 1 4 this 3 4008  </span>
<span class="s0">1422 0 0 6 1492 3600 0 0 246 /**</span>
 <span class="s0">* Returns true if any required data should be forced into memory if necessary</span>
 <span class="s0">* to render the object, or false if the object should be omitted if some of</span>
 <span class="s0">* the data is not available (at least until the data becomes available</span>
 <span class="s0">* later).</span>
 <span class="s0">*/ 1 4 this 3 4008  </span>
<span class="s0">1423 0 0 4 1493 3812 0 0 461 /**</span>
 <span class="s0">* Sets the lost_state flag.  If this is true, the callback does not have to</span>
 <span class="s0">* be quite so careful to clean up after itself; Panda will assume that the</span>
 <span class="s0">* graphics state is in an unknown state after the callback has finished, and</span>
 <span class="s0">* will issue all the necessary calls to restore it.  If this is false, Panda</span>
 <span class="s0">* will assume the callback will leave the graphics state exactly as it came</span>
 <span class="s0">* in, and won't bother to try to restore it.  The default is true.</span>
 <span class="s0">*/ 2 4 this 3 4012  10 lost_state 1 3600  </span>
<span class="s0">1424 0 0 6 1494 3600 0 0 62 /**</span>
 <span class="s0">* Returns the lost_state flag.  See set_lost_state().</span>
 <span class="s0">*/ 1 4 this 3 4008  </span>
<span class="s0">1425 0 0 7 1495 3816 0 0 0 0 </span>
<span class="s0">1426 0 0 23 1499 3607 0 0 169 /**</span>
 <span class="s0">* Constructs a new RescaleNormalAttrib object that specifies whether to</span>
 <span class="s0">* rescale normals to compensate for transform scales or incorrectly defined</span>
 <span class="s0">* normals.</span>
 <span class="s0">*/ 1 4 mode 1 3713  </span>
<span class="s0">1427 0 0 7 1500 3607 0 0 209 /**</span>
 <span class="s0">* Constructs a RescaleNormalAttrib object that's suitable for putting at the</span>
 <span class="s0">* top of a scene graph.  This will contain whatever attrib was suggested by</span>
 <span class="s0">* the user's rescale-normals Config variable.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1428 0 0 6 1501 3713 0 0 35 /**</span>
 <span class="s0">* Returns the render mode.</span>
 <span class="s0">*/ 1 4 this 3 4013  </span>
<span class="s0">1429 0 0 6 1503 3593 0 0 0 0 </span>
<span class="s0">1430 0 0 7 1505 3816 0 0 0 0 </span>
<span class="s0">1431 0 0 15 1516 4017 0 0 0 1 6 param0 0 4015  </span>
<span class="s0">1432 0 0 7 1509 4017 0 0 185 /**</span>
 <span class="s0">* Returns a newly-allocated CullResult object that contains a copy of just</span>
 <span class="s0">* the subset of the data from this CullResult object that is worth keeping</span>
 <span class="s0">* around for next frame.</span>
 <span class="s0">*/ 1 4 this 3 4015  </span>
<span class="s0">1433 0 0 7 1510 4019 0 0 238 /**</span>
 <span class="s0">* Returns the CullBin associated with the indicated bin_index, or NULL if the</span>
 <span class="s0">* bin_index is invalid.  If there is the first time this bin_index has been</span>
 <span class="s0">* requested for this CullResult, creates a new CullBin object on the fly.</span>
 <span class="s0">*/ 2 4 this 3 4017  9 bin_index 1 3593  </span>
<span class="s0">1434 0 0 4 1511 3812 0 0 152 /**</span>
 <span class="s0">* Adds the indicated CullableObject to the appropriate bin.  The bin becomes</span>
 <span class="s0">* the owner of the object pointer, and will eventually delete it.</span>
 <span class="s0">*/ 3 4 this 3 4017  6 object 1 4010  9 traverser 1 3991  </span>
<span class="s0">1435 0 0 4 1512 3812 0 0 219 /**</span>
 <span class="s0">* Called after all the geoms have been added, this indicates that the cull</span>
 <span class="s0">* process is finished for this frame and gives the bins a chance to do any</span>
 <span class="s0">* post-processing (like sorting) before moving on to draw.</span>
 <span class="s0">*/ 3 4 this 3 4017  11 scene_setup 1 3997  14 current_thread 1 3844  </span>
<span class="s0">1436 0 0 4 1513 3812 0 0 69 /**</span>
 <span class="s0">* Asks all the bins to draw themselves in the correct order.</span>
 <span class="s0">*/ 2 4 this 3 4017  14 current_thread 1 3844  </span>
<span class="s0">1437 0 0 7 1514 3650 2131 0 496 /**</span>
 <span class="s0">* Returns a special scene graph constructed to represent the results of the</span>
 <span class="s0">* cull.  This will be a hierarchy of nodes, one node for each bin, each of</span>
 <span class="s0">* which will in term be a parent of a number of GeomNodes, representing the</span>
 <span class="s0">* geometry drawn in each bin.</span>
 <span class="s0">*</span>
 <span class="s0">* This is useful mainly for high-level debugging and abstraction tools; it</span>
 <span class="s0">* should not be mistaken for the low-level cull result itself.  For the low-</span>
 <span class="s0">* level cull result, use draw() to efficiently draw the culled scene.</span>
 <span class="s0">*/ 1 4 this 3 4017  </span>
<span class="s0">1438 0 0 7 1515 3816 0 0 0 0 </span>
<span class="s0">1439 0 0 7 1518 3837 0 0 47 /**</span>
 <span class="s0">* Constructs a new DecalEffect object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1440 0 0 7 1519 3816 0 0 0 0 </span>
<span class="s0">1441 0 0 23 1522 3607 0 0 152 /**</span>
 <span class="s0">* Constructs a new DepthOffsetAttrib object that indicates the relative</span>
 <span class="s0">* amount of bias to write to the depth buffer for subsequent geometry.</span>
 <span class="s0">*/ 1 6 offset 5 3593  </span>
<span class="s0">1442 0 0 23 1522 3607 0 0 349 /**</span>
 <span class="s0">* Constructs a new DepthOffsetAttrib object that indicates the bias, and also</span>
 <span class="s0">* specifies a minimum and maximum (or, more precisely, nearest and farthest)</span>
 <span class="s0">* values to write to the depth buffer, in the range 0 .. 1.  This range is 0,</span>
 <span class="s0">* 1 by default; setting it to some other range can be used to create</span>
 <span class="s0">* additional depth buffer effects.</span>
 <span class="s0">*/ 3 6 offset 1 3593  9 min_value 1 3598  9 max_value 1 3598  </span>
<span class="s0">1443 0 0 7 1523 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1444 0 0 6 1524 3593 0 0 63 /**</span>
 <span class="s0">* Returns the depth offset represented by this attrib.</span>
 <span class="s0">*/ 1 4 this 3 4020  </span>
<span class="s0">1445 0 0 6 1525 3598 0 0 118 /**</span>
 <span class="s0">* Returns the value for the minimum (closest) depth value to be stored in the</span>
 <span class="s0">* buffer, in the range 0 .. 1.</span>
 <span class="s0">*/ 1 4 this 3 4020  </span>
<span class="s0">1446 0 0 6 1526 3598 0 0 119 /**</span>
 <span class="s0">* Returns the value for the maximum (farthest) depth value to be stored in</span>
 <span class="s0">* the buffer, in the range 0 .. 1.</span>
 <span class="s0">*/ 1 4 this 3 4020  </span>
<span class="s0">1447 0 0 6 1530 3593 0 0 0 0 </span>
<span class="s0">1448 0 0 7 1532 3816 0 0 0 0 </span>
<span class="s0">1449 0 0 23 1535 3607 0 0 51 /**</span>
 <span class="s0">* Constructs a new DepthTestAttrib object.</span>
 <span class="s0">*/ 1 4 mode 1 3594  </span>
<span class="s0">1450 0 0 7 1536 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1451 0 0 6 1537 3594 0 0 40 /**</span>
 <span class="s0">* Returns the depth write mode.</span>
 <span class="s0">*/ 1 4 this 3 4022  </span>
<span class="s0">1452 0 0 6 1539 3593 0 0 0 0 </span>
<span class="s0">1453 0 0 7 1541 3816 0 0 0 0 </span>
<span class="s0">1454 0 0 23 1545 3607 0 0 52 /**</span>
 <span class="s0">* Constructs a new DepthWriteAttrib object.</span>
 <span class="s0">*/ 1 4 mode 1 3720  </span>
<span class="s0">1455 0 0 7 1546 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1456 0 0 6 1547 3720 0 0 40 /**</span>
 <span class="s0">* Returns the depth write mode.</span>
 <span class="s0">*/ 1 4 this 3 4024  </span>
<span class="s0">1457 0 0 6 1549 3593 0 0 0 0 </span>
<span class="s0">1458 0 0 7 1551 3816 0 0 0 0 </span>
<span class="s0">1459 0 0 7 1555 3650 2131 0 0 1 4 this 3 3857  </span>
<span class="s0">1460 0 0 6 1556 3600 0 0 95 /**</span>
 <span class="s0">* Returns true if this is an AmbientLight, false if it is some other kind of</span>
 <span class="s0">* light.</span>
 <span class="s0">*/ 1 4 this 3 4026  </span>
<span class="s0">1461 0 0 6 1557 3820 0 0 48 /**</span>
 <span class="s0">* Returns the basic color of the light.</span>
 <span class="s0">*/ 1 4 this 3 4026  </span>
<span class="s0">1462 0 0 4 1558 3812 0 0 45 /**</span>
 <span class="s0">* Sets the basic color of the light.</span>
 <span class="s0">*/ 2 4 this 3 3857  5 color 1 3820  </span>
<span class="s0">1463 0 0 6 1560 3600 0 0 140 /**</span>
 <span class="s0">* Returns true if the color was specified as a temperature in kelvins, and</span>
 <span class="s0">* get_color_temperature is defined.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 4026  </span>
<span class="s0">1464 0 0 6 1561 3598 0 0 130 /**</span>
 <span class="s0">* Returns the basic color temperature of the light, assuming</span>
 <span class="s0">* has_color_temperature() returns true.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 4026  </span>
<span class="s0">1465 0 0 4 1562 3812 0 0 234 /**</span>
 <span class="s0">* Sets the color temperature of the light in kelvins.  This will recalculate</span>
 <span class="s0">* the light's color.</span>
 <span class="s0">*</span>
 <span class="s0">* The default value is 6500 K, corresponding to a perfectly white light</span>
 <span class="s0">* assuming a D65 white point.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 2 4 this 3 3857  11 temperature 1 3598  </span>
<span class="s0">1466 0 0 6 1564 3598 0 0 168 /**</span>
 <span class="s0">* For spotlights, returns the exponent that controls the amount of light</span>
 <span class="s0">* falloff from the center of the spotlight.  For other kinds of lights,</span>
 <span class="s0">* returns 0.</span>
 <span class="s0">*/ 1 4 this 3 4026  </span>
<span class="s0">1467 0 0 6 1565 3820 0 0 125 /**</span>
 <span class="s0">* Returns the color of specular highlights generated by the light.  This</span>
 <span class="s0">* value is meaningless for ambient lights.</span>
 <span class="s0">*/ 1 4 this 3 4026  </span>
<span class="s0">1468 0 0 6 1566 3798 0 0 193 /**</span>
 <span class="s0">* Returns the terms of the attenuation equation for the light.  These are, in</span>
 <span class="s0">* order, the constant, linear, and quadratic terms based on the distance from</span>
 <span class="s0">* the point to the vertex.</span>
 <span class="s0">*/ 1 4 this 3 4026  </span>
<span class="s0">1469 0 0 4 1567 3812 0 0 411 /**</span>
 <span class="s0">* Changes the relative importance of this light relative to the other lights</span>
 <span class="s0">* that are applied simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The priority number is used to decide which of the requested lights are to</span>
 <span class="s0">* be selected for rendering when more lights are requested than the hardware</span>
 <span class="s0">* will support.  The highest-priority n lights are selected for rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* This is similar to TextureStage::set_priority().</span>
 <span class="s0">*/ 2 4 this 3 3857  8 priority 1 3593  </span>
<span class="s0">1470 0 0 6 1568 3593 0 0 80 /**</span>
 <span class="s0">* Returns the priority associated with this light.  See set_priority().</span>
 <span class="s0">*/ 1 4 this 3 4026  </span>
<span class="s0">1471 0 0 6 1569 3593 0 0 0 1 4 this 3 4026  </span>
<span class="s0">1472 0 0 7 1571 3816 0 0 0 0 </span>
<span class="s0">1473 0 0 7 1574 3607 0 0 71 // The following is the new, more general interface to the LightAttrib. 0 </span>
<span class="s0">1474 0 0 23 1574 3607 0 0 178 /**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns on (or off, according to op)</span>
 <span class="s0">* the indicated light(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/ 2 2 op 1 3723  5 light 1 3857  </span>
<span class="s0">1475 0 0 23 1574 3607 0 0 177 /**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns on (or off, according to op)</span>
 <span class="s0">* the indicate light(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/ 3 2 op 1 3723  6 light1 1 3857  6 light2 1 3857  </span>
<span class="s0">1476 0 0 23 1574 3607 0 0 177 /**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns on (or off, according to op)</span>
 <span class="s0">* the indicate light(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/ 4 2 op 1 3723  6 light1 1 3857  6 light2 1 3857  6 light3 1 3857  </span>
<span class="s0">1477 0 0 23 1574 3607 0 0 177 /**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns on (or off, according to op)</span>
 <span class="s0">* the indicate light(s).</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/ 5 2 op 1 3723  6 light1 1 3857  6 light2 1 3857  6 light3 1 3857  6 light4 1 3857  </span>
<span class="s0">1478 0 0 7 1575 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1479 0 0 6 1576 3723 0 0 505 /**</span>
 <span class="s0">* Returns the basic operation type of the LightAttrib.  If this is O_set, the</span>
 <span class="s0">* lights listed here completely replace any lights that were already on.  If</span>
 <span class="s0">* this is O_add, the lights here are added to the set of lights that were</span>
 <span class="s0">* already on, and if O_remove, the lights here are removed from the set of</span>
 <span class="s0">* lights that were on.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated LightAttribs nowadays have a separate list of on_lights and</span>
 <span class="s0">* off_lights, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1480 0 0 6 1577 3593 0 0 230 /**</span>
 <span class="s0">* Returns the number of lights listed in the attribute.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated LightAttribs nowadays have a separate list of on_lights and</span>
 <span class="s0">* off_lights, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1481 0 0 6 1578 3857 0 0 223 /**</span>
 <span class="s0">* Returns the nth light listed in the attribute.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated LightAttribs nowadays have a separate list of on_lights and</span>
 <span class="s0">* off_lights, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/ 2 4 this 3 4028  1 n 1 3593  </span>
<span class="s0">1482 0 0 6 1579 3600 0 0 257 /**</span>
 <span class="s0">* Returns true if the indicated light is listed in the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated LightAttribs nowadays have a separate list of on_lights and</span>
 <span class="s0">* off_lights, so this method no longer makes sense.  Query the lists</span>
 <span class="s0">* independently.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3857  </span>
<span class="s0">1483 0 0 7 1580 3607 0 0 183 /**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* added to the list of lights.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use add_on_light() or add_off_light() instead.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3857  </span>
<span class="s0">1484 0 0 7 1581 3607 0 0 193 /**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* removed from the list of lights.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use remove_on_light() or remove_off_light() instead.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3857  </span>
<span class="s0">1485 0 0 7 1582 3607 0 0 106 /**</span>
 <span class="s0">* Constructs a new LightAttrib object that turns off all lights (and hence</span>
 <span class="s0">* disables lighting).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1486 0 0 6 1583 3796 0 0 76 /**</span>
 <span class="s0">* Returns the number of lights that are turned on by the attribute.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1487 0 0 6 1584 3796 0 0 92 /**</span>
 <span class="s0">* Returns the number of non-ambient lights that are turned on by this</span>
 <span class="s0">* attribute.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1488 0 0 7 1585 3894 2739 0 84 /**</span>
 <span class="s0">* Returns the nth light turned on by the attribute, sorted in render order.</span>
 <span class="s0">*/ 2 4 this 3 4028  1 n 1 3796  </span>
<span class="s0">1489 0 0 6 1587 3600 0 0 94 /**</span>
 <span class="s0">* Returns true if the indicated light is turned on by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3884  </span>
<span class="s0">1490 0 0 6 1588 3600 0 0 81 /**</span>
 <span class="s0">* Returns true if any light is turned on by the attrib, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1491 0 0 6 1589 3796 0 0 77 /**</span>
 <span class="s0">* Returns the number of lights that are turned off by the attribute.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1492 0 0 7 1590 3894 2739 0 101 /**</span>
 <span class="s0">* Returns the nth light turned off by the attribute, sorted in arbitrary</span>
 <span class="s0">* (pointer) order.</span>
 <span class="s0">*/ 2 4 this 3 4028  1 n 1 3796  </span>
<span class="s0">1493 0 0 6 1592 3600 0 0 95 /**</span>
 <span class="s0">* Returns true if the indicated light is turned off by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3884  </span>
<span class="s0">1494 0 0 6 1593 3600 0 0 99 /**</span>
 <span class="s0">* Returns true if this attrib turns off all lights (although it may also turn</span>
 <span class="s0">* some on).</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1495 0 0 6 1594 3600 0 0 102 /**</span>
 <span class="s0">* Returns true if this is an identity attrib: it does not change the set of</span>
 <span class="s0">* lights in use.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1496 0 0 7 1595 3607 0 0 143 /**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* added to the list of lights turned on by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3884  </span>
<span class="s0">1497 0 0 7 1596 3607 0 0 147 /**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* removed from the list of lights turned on by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3884  </span>
<span class="s0">1498 0 0 7 1597 3607 0 0 126 /**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* replaced with the given other light.</span>
 <span class="s0">*/ 3 4 this 3 4028  6 source 1 3884  4 dest 1 3884  </span>
<span class="s0">1499 0 0 7 1598 3607 0 0 144 /**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* added to the list of lights turned off by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3884  </span>
<span class="s0">1500 0 0 7 1599 3607 0 0 148 /**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* removed from the list of lights turned off by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 4028  5 light 1 3884  </span>
<span class="s0">1501 0 0 7 1600 3607 0 0 126 /**</span>
 <span class="s0">* Returns a new LightAttrib, just like this one, but with the indicated light</span>
 <span class="s0">* replaced with the given other light.</span>
 <span class="s0">*/ 3 4 this 3 4028  6 source 1 3884  4 dest 1 3884  </span>
<span class="s0">1502 0 0 7 1601 3894 2739 0 209 /**</span>
 <span class="s0">* Returns the most important light (that is, the light with the highest</span>
 <span class="s0">* priority) in the LightAttrib, excluding any ambient lights.  Returns an</span>
 <span class="s0">* empty NodePath if no non-ambient lights are found.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1503 0 0 7 1602 3905 0 0 68 /**</span>
 <span class="s0">* Returns the total contribution of all the ambient lights.</span>
 <span class="s0">*/ 1 4 this 3 4028  </span>
<span class="s0">1504 0 0 6 1605 3593 0 0 0 0 </span>
<span class="s0">1505 0 0 7 1607 3816 0 0 0 0 </span>
<span class="s0">1506 0 0 7 1610 3607 0 0 151 /**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This is the standard OpenGL</span>
 <span class="s0">* lighting ramp, which clamps the final light total to the 0-1 range.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1507 0 0 7 1611 3607 0 0 169 /**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This differs from the usual</span>
 <span class="s0">* OpenGL lighting model in that it does not clamp the final lighting total to</span>
 <span class="s0">* (0,1).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1508 0 0 7 1612 3607 0 0 290 /**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes the luminance of the</span>
 <span class="s0">* diffuse lighting contribution to be quantized using a single threshold:</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* if (original_luminance &gt; threshold0) {</span>
 <span class="s0">*   luminance = level0;</span>
 <span class="s0">* } else {</span>
 <span class="s0">*   luminance = 0.0;</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/ 2 7 thresh0 1 3598  4 lev0 1 3598  </span>
<span class="s0">1509 0 0 7 1613 3607 0 0 360 /**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes the luminance of the</span>
 <span class="s0">* diffuse lighting contribution to be quantized using two thresholds:</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* if (original_luminance &gt; threshold1) {</span>
 <span class="s0">*   luminance = level1;</span>
 <span class="s0">* } else if (original_luminance &gt; threshold0) {</span>
 <span class="s0">*   luminance = level0;</span>
 <span class="s0">* } else {</span>
 <span class="s0">*   luminance = 0.0;</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/ 4 7 thresh0 1 3598  4 lev0 1 3598  7 thresh1 1 3598  4 lev1 1 3598  </span>
<span class="s0">1510 0 0 7 1614 3607 0 0 814 /**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes an HDR tone mapping</span>
 <span class="s0">* operation to be applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, brightness values greater than 1 cannot be distinguished from</span>
 <span class="s0">* each other, causing very brightly lit objects to wash out white and all</span>
 <span class="s0">* detail to be erased.  HDR tone mapping remaps brightness values in the</span>
 <span class="s0">* range 0-infinity into the range (0,1), making it possible to distinguish</span>
 <span class="s0">* detail in scenes whose brightness exceeds 1.</span>
 <span class="s0">*</span>
 <span class="s0">* However, the monitor has finite contrast.  Normally, all of that contrast</span>
 <span class="s0">* is used to represent brightnesses in the range 0-1.  The HDR0 tone mapping</span>
 <span class="s0">* operator 'steals' one quarter of that contrast to represent brightnesses in</span>
 <span class="s0">* the range 1-infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* FINAL_RGB = (RGB^3 + RGB^2 + RGB) / (RGB^3 + RGB^2 + RGB + 1)</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1511 0 0 7 1615 3607 0 0 796 /**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes an HDR tone mapping</span>
 <span class="s0">* operation to be applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, brightness values greater than 1 cannot be distinguished from</span>
 <span class="s0">* each other, causing very brightly lit objects to wash out white and all</span>
 <span class="s0">* detail to be erased.  HDR tone mapping remaps brightness values in the</span>
 <span class="s0">* range 0-infinity into the range (0,1), making it possible to distinguish</span>
 <span class="s0">* detail in scenes whose brightness exceeds 1.</span>
 <span class="s0">*</span>
 <span class="s0">* However, the monitor has finite contrast.  Normally, all of that contrast</span>
 <span class="s0">* is used to represent brightnesses in the range 0-1.  The HDR1 tone mapping</span>
 <span class="s0">* operator 'steals' one third of that contrast to represent brightnesses in</span>
 <span class="s0">* the range 1-infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* FINAL_RGB = (RGB^2 + RGB) / (RGB^2 + RGB + 1)</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1512 0 0 7 1616 3607 0 0 779 /**</span>
 <span class="s0">* Constructs a new LightRampAttrib object.  This causes an HDR tone mapping</span>
 <span class="s0">* operation to be applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Normally, brightness values greater than 1 cannot be distinguished from</span>
 <span class="s0">* each other, causing very brightly lit objects to wash out white and all</span>
 <span class="s0">* detail to be erased.  HDR tone mapping remaps brightness values in the</span>
 <span class="s0">* range 0-infinity into the range (0,1), making it possible to distinguish</span>
 <span class="s0">* detail in scenes whose brightness exceeds 1.</span>
 <span class="s0">*</span>
 <span class="s0">* However, the monitor has finite contrast.  Normally, all of that contrast</span>
 <span class="s0">* is used to represent brightnesses in the range 0-1.  The HDR2 tone mapping</span>
 <span class="s0">* operator 'steals' one half of that contrast to represent brightnesses in</span>
 <span class="s0">* the range 1-infinity.</span>
 <span class="s0">*</span>
 <span class="s0">* @code</span>
 <span class="s0">* FINAL_RGB = (RGB) / (RGB + 1)</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1513 0 0 6 1617 3725 0 0 44 /**</span>
 <span class="s0">* Returns the LightRampAttrib mode.</span>
 <span class="s0">*/ 1 4 this 3 4030  </span>
<span class="s0">1514 0 0 6 1618 3598 0 0 42 /**</span>
 <span class="s0">* Returns the nth lighting level.</span>
 <span class="s0">*/ 2 4 this 3 4030  1 n 1 3593  </span>
<span class="s0">1515 0 0 6 1619 3598 0 0 43 /**</span>
 <span class="s0">* Returns the nth threshold level.</span>
 <span class="s0">*/ 2 4 this 3 4030  1 n 1 3593  </span>
<span class="s0">1516 0 0 6 1621 3593 0 0 0 0 </span>
<span class="s0">1517 0 0 7 1623 3816 0 0 0 0 </span>
<span class="s0">1518 0 0 15 1640 3742 3237 0 0 1 6 param0 0 4032  </span>
<span class="s0">1519 0 0 7 1640 3742 3237 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 5 3841  </span>
<span class="s0">1520 0 0 4 1641 3812 0 0 118 /**</span>
 <span class="s0">* Specifies the task manager that is used for asynchronous loads.  The</span>
 <span class="s0">* default is the global task manager.</span>
 <span class="s0">*/ 2 4 this 3 3742  12 task_manager 1 4034  </span>
<span class="s0">1521 0 0 7 1642 4034 0 0 72 /**</span>
 <span class="s0">* Returns the task manager that is used for asynchronous loads.</span>
 <span class="s0">*/ 1 4 this 3 4032  </span>
<span class="s0">1522 0 0 4 1643 3812 0 0 130 /**</span>
 <span class="s0">* Specifies the task chain that is used for asynchronous loads.  The default</span>
 <span class="s0">* is the initial name of the Loader object.</span>
 <span class="s0">*/ 2 4 this 3 3742  10 task_chain 1 3841  </span>
<span class="s0">1523 0 0 6 1644 3841 0 0 70 /**</span>
 <span class="s0">* Returns the task chain that is used for asynchronous loads.</span>
 <span class="s0">*/ 1 4 this 3 4032  </span>
<span class="s0">1524 0 0 4 1645 3812 0 0 56 /**</span>
 <span class="s0">* Stop any threads used for asynchronous loads.</span>
 <span class="s0">*/ 1 4 this 3 3742  </span>
<span class="s0">1525 0 0 6 1646 3600 0 0 168 /**</span>
 <span class="s0">* Removes a pending asynchronous load request.  Returns true if successful,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">* @deprecated use task.cancel() to cancel the request instead.</span>
 <span class="s0">*/ 2 4 this 3 3742  4 task 1 4036  </span>
<span class="s0">1526 0 0 7 1647 3650 2131 0 187 /**</span>
 <span class="s0">* Loads the file immediately, waiting for it to complete.</span>
 <span class="s0">*</span>
 <span class="s0">* If search is true, the file is searched for along the model path;</span>
 <span class="s0">* otherwise, only the exact filename is loaded.</span>
 <span class="s0">*/ 3 4 this 3 4032  8 filename 1 3920  7 options 5 4037  </span>
<span class="s0">1527 0 0 7 1648 4036 0 0 117 /**</span>
 <span class="s0">* Returns a new AsyncTask object suitable for adding to load_async() to start</span>
 <span class="s0">* an asynchronous model load.</span>
 <span class="s0">*/ 3 4 this 3 3742  8 filename 1 3920  7 options 5 4037  </span>
<span class="s0">1528 0 0 4 1649 3812 0 0 591 /**</span>
 <span class="s0">* Begins an asynchronous load request.  To use this call, first call</span>
 <span class="s0">* make_async_request() to create a new ModelLoadRequest object with the</span>
 <span class="s0">* filename you wish to load, and then add that object to the Loader with</span>
 <span class="s0">* load_async.  This function will return immediately, and the model will be</span>
 <span class="s0">* loaded in the background.</span>
 <span class="s0">*</span>
 <span class="s0">* To determine when the model has completely loaded, you may poll</span>
 <span class="s0">* request-&gt;is_ready() from time to time, or set the done_event on the request</span>
 <span class="s0">* object and listen for that event.  When the model is ready, you may</span>
 <span class="s0">* retrieve it via request-&gt;get_model().</span>
 <span class="s0">*/ 2 4 this 3 3742  7 request 1 4036  </span>
<span class="s0">1529 0 0 6 1650 3600 0 0 66 /**</span>
 <span class="s0">* Saves the file immediately, waiting for it to complete.</span>
 <span class="s0">*/ 4 4 this 3 4032  8 filename 1 3920  7 options 1 4037  4 node 1 3650  </span>
<span class="s0">1530 0 0 7 1651 4036 0 0 117 /**</span>
 <span class="s0">* Returns a new AsyncTask object suitable for adding to save_async() to start</span>
 <span class="s0">* an asynchronous model save.</span>
 <span class="s0">*/ 4 4 this 3 3742  8 filename 1 3920  7 options 1 4037  4 node 1 3650  </span>
<span class="s0">1531 0 0 4 1652 3812 0 0 620 /**</span>
 <span class="s0">* Begins an asynchronous save request.  To use this call, first call</span>
 <span class="s0">* make_async_save_request() to create a new ModelSaveRequest object with the</span>
 <span class="s0">* filename you wish to load, and then add that object to the Loader with</span>
 <span class="s0">* save_async.  This function will return immediately, and the model will be</span>
 <span class="s0">* loaded in the background.</span>
 <span class="s0">*</span>
 <span class="s0">* To determine when the model has completely loaded, you may poll</span>
 <span class="s0">* request-&gt;is_ready() from time to time, or set the done_event on the request</span>
 <span class="s0">* object and listen for that event.  When the request is ready, you may</span>
 <span class="s0">* retrieve the success or failure via request-&gt;get_success().</span>
 <span class="s0">*/ 2 4 this 3 3742  7 request 1 4036  </span>
<span class="s0">1532 0 0 7 1653 3650 2131 0 109 /**</span>
 <span class="s0">* Attempts to read a bam file from the indicated stream and return the scene</span>
 <span class="s0">* graph defined there.</span>
 <span class="s0">*/ 2 4 this 3 3742  2 in 1 3935  </span>
<span class="s0">1533 0 0 4 1654 3812 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 4032  3 out 1 3813  </span>
<span class="s0">1534 0 0 7 1655 3742 3237 0 119 /**</span>
 <span class="s0">* Returns a pointer to the global Loader.  This is the Loader that most code</span>
 <span class="s0">* should use for loading models.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1535 0 0 7 1656 3816 0 0 0 0 </span>
<span class="s0">1536 0 0 7 1626 4038 0 0 0 1 4 this 3 3742  </span>
<span class="s0">1537 0 0 6 1628 3861 0 0 0 1 4 this 3 3742  </span>
<span class="s0">1538 0 0 7 1631 4039 3215 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1539 0 0 15 1631 4039 3215 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 4040  </span>
<span class="s0">1540 0 0 6 1632 4039 0 0 0 2 4 this 3 4039  4 copy 1 4040  </span>
<span class="s0">1541 0 0 4 1634 3812 0 0 47 /**</span>
 <span class="s0">* Removes all the files from the list.</span>
 <span class="s0">*/ 1 4 this 3 4039  </span>
<span class="s0">1542 0 0 6 1635 3593 0 0 58 /**</span>
 <span class="s0">* Returns the number of files on the result list.</span>
 <span class="s0">*/ 1 4 this 3 4040  </span>
<span class="s0">1543 0 0 6 1636 3920 0 0 51 /**</span>
 <span class="s0">* Returns the nth file on the result list.</span>
 <span class="s0">*/ 2 4 this 3 4040  1 n 1 3593  </span>
<span class="s0">1544 0 0 6 1638 3731 0 0 68 /**</span>
 <span class="s0">* Returns the file type of the nth file on the result list.</span>
 <span class="s0">*/ 2 4 this 3 4040  1 n 1 3593  </span>
<span class="s0">1545 0 0 6 1660 3841 0 0 0 1 4 this 3 4042  </span>
<span class="s0">1546 0 0 6 1661 3841 0 0 0 1 4 this 3 4042  </span>
<span class="s0">1547 0 0 6 1662 3841 0 0 146 /**</span>
 <span class="s0">* Returns a space-separated list of extension, in addition to the one</span>
 <span class="s0">* returned by get_extension(), that are recognized by this loader.</span>
 <span class="s0">*/ 1 4 this 3 4042  </span>
<span class="s0">1548 0 0 6 1663 3600 0 0 132 /**</span>
 <span class="s0">* Returns true if this file type can transparently load compressed files</span>
 <span class="s0">* (with a .pz or .gz extension), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 4042  </span>
<span class="s0">1549 0 0 6 1664 3600 0 0 138 /**</span>
 <span class="s0">* Returns true if the loader flags allow retrieving the model from the on-</span>
 <span class="s0">* disk bam cache (if it is enabled), false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 4042  7 options 1 4037  </span>
<span class="s0">1550 0 0 6 1665 3600 0 0 127 /**</span>
 <span class="s0">* Returns true if the loader flags allow retrieving the model from the in-</span>
 <span class="s0">* memory ModelPool cache, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 4042  7 options 1 4037  </span>
<span class="s0">1551 0 0 6 1666 3600 0 0 172 /**</span>
 <span class="s0">* Returns true if the file type can be used to load files, and load_file() is</span>
 <span class="s0">* supported.  Returns false if load_file() is unimplemented and will always</span>
 <span class="s0">* fail.</span>
 <span class="s0">*/ 1 4 this 3 4042  </span>
<span class="s0">1552 0 0 6 1667 3600 0 0 172 /**</span>
 <span class="s0">* Returns true if the file type can be used to save files, and save_file() is</span>
 <span class="s0">* supported.  Returns false if save_file() is unimplemented and will always</span>
 <span class="s0">* fail.</span>
 <span class="s0">*/ 1 4 this 3 4042  </span>
<span class="s0">1553 0 0 7 1668 3816 0 0 0 0 </span>
<span class="s0">1554 0 0 15 1683 4046 3247 0 0 1 6 param0 0 4044  </span>
<span class="s0">1555 0 0 36 1671 3812 0 0 0 2 4 this 3 4046  4 type 1 3623  </span>
<span class="s0">1556 0 0 36 1672 3812 0 0 0 2 4 this 3 4046  11 entry_point 1 3623  </span>
<span class="s0">1557 0 0 36 1673 3812 0 0 0 2 4 this 3 4046  4 type 1 3623  </span>
<span class="s0">1558 0 0 6 1674 3593 0 0 56 /**</span>
 <span class="s0">* Returns the total number of types registered.</span>
 <span class="s0">*/ 1 4 this 3 4044  </span>
<span class="s0">1559 0 0 6 1675 3731 0 0 43 /**</span>
 <span class="s0">* Returns the nth type registered.</span>
 <span class="s0">*/ 2 4 this 3 4044  1 n 1 3593  </span>
<span class="s0">1560 0 0 6 1679 3731 0 0 163 /**</span>
 <span class="s0">* Determines the type of the file based on the indicated extension (without a</span>
 <span class="s0">* leading dot).  Returns NULL if the extension matches no known file types.</span>
 <span class="s0">*/ 2 4 this 3 4046  9 extension 1 3841  </span>
<span class="s0">1561 0 0 4 1680 3812 0 0 97 /**</span>
 <span class="s0">* Writes a list of supported file types to the indicated output stream, one</span>
 <span class="s0">* per line.</span>
 <span class="s0">*/ 3 4 this 3 4044  3 out 1 3813  12 indent_level 5 3593  </span>
<span class="s0">1562 0 0 6 1681 4046 0 0 73 /**</span>
 <span class="s0">* Returns a pointer to the global LoaderFileTypeRegistry object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1563 0 0 38 1682 3623 0 0 0 1 4 this 3 4044  </span>
<span class="s0">1564 0 0 23 1685 3607 0 0 113 /**</span>
 <span class="s0">* Constructs a new MaterialAttrib object suitable for rendering the indicated</span>
 <span class="s0">* material onto geometry.</span>
 <span class="s0">*/ 1 8 material 1 3733  </span>
<span class="s0">1565 0 0 7 1686 3607 0 0 97 /**</span>
 <span class="s0">* Constructs a new MaterialAttrib object suitable for rendering unmateriald</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1566 0 0 7 1687 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1567 0 0 6 1688 3600 0 0 132 /**</span>
 <span class="s0">* Returns true if the MaterialAttrib is an 'off' MaterialAttrib, indicating</span>
 <span class="s0">* that it should disable the use of materials.</span>
 <span class="s0">*/ 1 4 this 3 4047  </span>
<span class="s0">1568 0 0 7 1689 3733 0 0 133 /**</span>
 <span class="s0">* If the MaterialAttrib is not an 'off' MaterialAttrib, returns the material</span>
 <span class="s0">* that is associated.  Otherwise, return NULL.</span>
 <span class="s0">*/ 1 4 this 3 4047  </span>
<span class="s0">1569 0 0 6 1693 3593 0 0 0 0 </span>
<span class="s0">1570 0 0 7 1695 3816 0 0 0 0 </span>
<span class="s0">1571 0 0 15 1699 4051 3271 0 0 1 6 param0 0 4049  </span>
<span class="s0">1572 0 0 7 1699 4051 3271 0 121 /**</span>
 <span class="s0">* Create a new ModelFlattenRequest, and add it to the loader via</span>
 <span class="s0">* load_async(), to begin an asynchronous load.</span>
 <span class="s0">*/ 1 4 orig 1 3650  </span>
<span class="s0">1573 0 0 7 1700 3650 2131 0 50 /**</span>
 <span class="s0">* Returns the original, unflattened node.</span>
 <span class="s0">*/ 1 4 this 3 4049  </span>
<span class="s0">1574 0 0 6 1701 3600 0 0 239 /**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending.</span>
 <span class="s0">* When this returns true, you may retrieve the model loaded by calling</span>
 <span class="s0">* result().</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/ 1 4 this 3 4049  </span>
<span class="s0">1575 0 0 7 1702 3650 2131 0 148 /**</span>
 <span class="s0">* Returns the flattened copy of the model.  It is an error to call this</span>
 <span class="s0">* unless done() returns true.</span>
 <span class="s0">* @deprecated Use result() instead.</span>
 <span class="s0">*/ 1 4 this 3 4049  </span>
<span class="s0">1576 0 0 7 1704 3816 0 0 0 0 </span>
<span class="s0">1577 0 0 15 1707 4054 3279 0 0 1 6 param0 0 4052  </span>
<span class="s0">1578 0 0 7 1707 4054 3279 0 118 /**</span>
 <span class="s0">* Create a new ModelLoadRequest, and add it to the loader via load_async(),</span>
 <span class="s0">* to begin an asynchronous load.</span>
 <span class="s0">*/ 4 4 name 1 3841  8 filename 1 3920  7 options 1 4037  6 loader 1 3742  </span>
<span class="s0">1579 0 0 6 1708 3920 0 0 83 /**</span>
 <span class="s0">* Returns the filename associated with this asynchronous ModelLoadRequest.</span>
 <span class="s0">*/ 1 4 this 3 4052  </span>
<span class="s0">1580 0 0 6 1709 4037 0 0 91 /**</span>
 <span class="s0">* Returns the LoaderOptions associated with this asynchronous</span>
 <span class="s0">* ModelLoadRequest.</span>
 <span class="s0">*/ 1 4 this 3 4052  </span>
<span class="s0">1581 0 0 7 1710 3742 3237 0 91 /**</span>
 <span class="s0">* Returns the Loader object associated with this asynchronous</span>
 <span class="s0">* ModelLoadRequest.</span>
 <span class="s0">*/ 1 4 this 3 4052  </span>
<span class="s0">1582 0 0 6 1711 3600 0 0 271 /**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending or</span>
 <span class="s0">* if it has been cancelled.  When this returns true, you may retrieve the</span>
 <span class="s0">* model loaded by calling get_model().</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/ 1 4 this 3 4052  </span>
<span class="s0">1583 0 0 7 1712 3650 2131 0 196 /**</span>
 <span class="s0">* Returns the model that was loaded asynchronously, if any, or null if there</span>
 <span class="s0">* was an error.  It is an error to call this unless done() returns true.</span>
 <span class="s0">* @deprecated Use result() instead.</span>
 <span class="s0">*/ 1 4 this 3 4052  </span>
<span class="s0">1584 0 0 7 1721 3816 0 0 0 0 </span>
<span class="s0">1585 0 0 7 1724 4055 3287 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3841  </span>
<span class="s0">1586 0 0 4 1726 3812 0 0 1183 /**</span>
 <span class="s0">* Sets the preserve_transform flag.  This restricts the ability of a flatten</span>
 <span class="s0">* operation to affect the transform stored on this node, and/or the node</span>
 <span class="s0">* itself.  In the order from weakest to strongest restrictions, the possible</span>
 <span class="s0">* flags are:</span>
 <span class="s0">*</span>
 <span class="s0">* PT_drop_node - This node should be removed at the next flatten call.</span>
 <span class="s0">*</span>
 <span class="s0">* PT_none - The transform may be adjusted at will.  The node itself will not</span>
 <span class="s0">* be removed.  This is the default.</span>
 <span class="s0">*</span>
 <span class="s0">* PT_net - Preserve the net transform from the root, but it's acceptable to</span>
 <span class="s0">* modify the local transform stored on this particular node if necessary, so</span>
 <span class="s0">* long as the net transform is not changed.  This eliminates the need to drop</span>
 <span class="s0">* an extra transform on the node above.</span>
 <span class="s0">*</span>
 <span class="s0">* PT_local - The local (and net) transform should not be changed in any way.</span>
 <span class="s0">* If necessary, an extra transform will be left on the node above to</span>
 <span class="s0">* guarantee this.  This is a stronger restriction than PT_net.</span>
 <span class="s0">*</span>
 <span class="s0">* PT_no_touch - The local transform will not be changed, the node will not be</span>
 <span class="s0">* removed, and furthermore any flatten operation will not continue below this</span>
 <span class="s0">* node--this node and all descendents are protected from the effects of</span>
 <span class="s0">* flatten.</span>
 <span class="s0">*/ 2 4 this 3 4055  18 preserve_transform 1 3744  </span>
<span class="s0">1587 0 0 6 1727 3744 0 0 104 /**</span>
 <span class="s0">* Returns the current setting of the preserve_transform flag.  See</span>
 <span class="s0">* set_preserve_transform().</span>
 <span class="s0">*/ 1 4 this 3 4056  </span>
<span class="s0">1588 0 0 4 1728 3812 0 0 295 /**</span>
 <span class="s0">* Sets the preserve_attributes flag.  This restricts the ability of a flatten</span>
 <span class="s0">* operation to affect the render attributes stored on this node.</span>
 <span class="s0">*</span>
 <span class="s0">* The value should be the union of bits from SceneGraphReducer::AttribTypes</span>
 <span class="s0">* that represent the attributes that should *not* be changed.</span>
 <span class="s0">*/ 2 4 this 3 4055  11 attrib_mask 1 3593  </span>
<span class="s0">1589 0 0 6 1729 3593 0 0 106 /**</span>
 <span class="s0">* Returns the current setting of the preserve_attributes flag.  See</span>
 <span class="s0">* set_preserve_attributes().</span>
 <span class="s0">*/ 1 4 this 3 4056  </span>
<span class="s0">1590 0 0 4 1730 3812 0 0 0 2 4 this 3 4055  5 limit 1 3598  </span>
<span class="s0">1591 0 0 7 1731 3816 0 0 0 0 </span>
<span class="s0">1592 0 0 7 1734 4058 3299 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 8 fullpath 1 3920  9 timestamp 1 3746  </span>
<span class="s0">1593 0 0 7 1734 4058 3299 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 3841  </span>
<span class="s0">1594 0 0 6 1735 3593 0 0 344 /**</span>
 <span class="s0">* Returns the number of copies that exist of this particular ModelRoot node.</span>
 <span class="s0">* Each time ModelRoot::copy_subgraph() or make_copy() is called (or some</span>
 <span class="s0">* other copying mechanism, such as NodePath.copy_to(), is used), this count</span>
 <span class="s0">* will increment by one in all copies; when one of the copies is destructed,</span>
 <span class="s0">* this count will decrement.</span>
 <span class="s0">*/ 1 4 this 3 4059  </span>
<span class="s0">1595 0 0 6 1737 3920 0 0 206 /**</span>
 <span class="s0">* Returns the full pathname of the model represented by this node, as found</span>
 <span class="s0">* on disk.  This is mainly useful for reference purposes, but is also used to</span>
 <span class="s0">* index the ModelRoot into the ModelPool.</span>
 <span class="s0">*/ 1 4 this 3 4059  </span>
<span class="s0">1596 0 0 4 1738 3812 0 0 399 /**</span>
 <span class="s0">* Sets the full pathname of the model represented by this node, as found on</span>
 <span class="s0">* disk.  This is mainly useful for reference purposes, but is also used to</span>
 <span class="s0">* index the ModelRoot into the ModelPool.</span>
 <span class="s0">*</span>
 <span class="s0">* This is normally set automatically when a model is loaded, and should not</span>
 <span class="s0">* be set directly by the user.  If you change this on a loaded model, then</span>
 <span class="s0">* ModelPool::release_model() may fail.</span>
 <span class="s0">*/ 2 4 this 3 4058  8 fullpath 1 3920  </span>
<span class="s0">1597 0 0 6 1740 3746 0 0 324 /**</span>
 <span class="s0">* Returns the timestamp of the file on disk that was read for this model, at</span>
 <span class="s0">* the time it was read, if it is known.  Returns 0 if the timestamp is not</span>
 <span class="s0">* known or could not be provided.  This can be used as a quick (but fallible)</span>
 <span class="s0">* check to verify whether the file might have changed since the model was</span>
 <span class="s0">* read.</span>
 <span class="s0">*/ 1 4 this 3 4059  </span>
<span class="s0">1598 0 0 4 1741 3812 0 0 189 /**</span>
 <span class="s0">* Sets the timestamp of the file on disk that was read for this model.  This</span>
 <span class="s0">* is normally set automatically when a model is loaded, and should not be set</span>
 <span class="s0">* directly by the user.</span>
 <span class="s0">*/ 2 4 this 3 4058  9 timestamp 1 3746  </span>
<span class="s0">1599 0 0 7 1748 3749 3295 0 315 /**</span>
 <span class="s0">* Returns the pointer that represents the object shared between all copies of</span>
 <span class="s0">* this ModelRoot.  Since there's not much associated with this object other</span>
 <span class="s0">* than a reference count, normally there's not much reason to get the pointer</span>
 <span class="s0">* (though it may be compared pointerwise with other ModelRoot objects).</span>
 <span class="s0">*/ 1 4 this 3 4059  </span>
<span class="s0">1600 0 0 4 1749 3812 0 0 212 /**</span>
 <span class="s0">* Changes the pointer that represents the object shared between all copies of</span>
 <span class="s0">* this ModelRoot.  This will disassociate this ModelRoot from all of its</span>
 <span class="s0">* copies.  Normally, there's no reason to do this.</span>
 <span class="s0">*/ 2 4 this 3 4058  3 ref 1 3749  </span>
<span class="s0">1601 0 0 7 1752 3816 0 0 0 0 </span>
<span class="s0">1602 0 0 7 1746 3749 3295 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1603 0 0 15 1746 3749 3295 0 0 1 6 param0 0 4061  </span>
<span class="s0">1604 0 0 6 1755 3600 0 0 149 /**</span>
 <span class="s0">* Returns true if the model has ever been loaded, false otherwise.  Note that</span>
 <span class="s0">* this does not guarantee that the model is still up-to-date.</span>
 <span class="s0">*/ 1 8 filename 1 3920  </span>
<span class="s0">1605 0 0 6 1756 3600 0 0 549 /**</span>
 <span class="s0">* Loads the given filename up as a model, if it has not already been loaded,</span>
 <span class="s0">* and returns true to indicate success, or false to indicate failure.  If</span>
 <span class="s0">* this returns true, it is probable that a subsequent call to load_model()</span>
 <span class="s0">* with the same model name will return a valid PandaNode.</span>
 <span class="s0">*</span>
 <span class="s0">* However, even if this returns true, it is still possible for a subsequent</span>
 <span class="s0">* call to load_model() to fail.  This can happen if cache-check-timestamps is</span>
 <span class="s0">* true, and the on-disk file is subsequently modified to replace it with an</span>
 <span class="s0">* invalid model.</span>
 <span class="s0">*/ 1 8 filename 1 3920  </span>
<span class="s0">1606 0 0 7 1757 4058 3299 0 244 /**</span>
 <span class="s0">* Returns the model that has already been previously loaded, or NULL</span>
 <span class="s0">* otherwise.  If verify is true, it will check if the file is still up-to-</span>
 <span class="s0">* date (and hasn't been modified in the meantime), and if not, will still</span>
 <span class="s0">* return NULL.</span>
 <span class="s0">*/ 2 8 filename 1 3920  6 verify 1 3600  </span>
<span class="s0">1607 0 0 7 1758 4058 3299 0 369 /**</span>
 <span class="s0">* Loads the given filename up as a model, if it has not already been loaded,</span>
 <span class="s0">* and returns the new model.  If a model with the same filename was</span>
 <span class="s0">* previously loaded, returns that one instead (unless cache-check-timestamps</span>
 <span class="s0">* is true and the file has recently changed).  If the model file cannot be</span>
 <span class="s0">* found, or cannot be loaded for some reason, returns NULL.</span>
 <span class="s0">*/ 2 8 filename 1 3920  7 options 5 4037  </span>
<span class="s0">1608 0 0 4 1759 3812 0 0 224 /**</span>
 <span class="s0">* Adds the indicated already-loaded model to the pool.  The model will</span>
 <span class="s0">* replace any previously-loaded model in the pool that had the same filename.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use the one-parameter add_model(model) instead.</span>
 <span class="s0">*/ 2 8 filename 1 3920  5 model 1 4058  </span>
<span class="s0">1609 0 0 4 1759 3812 0 0 158 /**</span>
 <span class="s0">* Adds the indicated already-loaded model to the pool.  The model will</span>
 <span class="s0">* replace any previously-loaded model in the pool that had the same filename.</span>
 <span class="s0">*/ 1 5 model 1 4058  </span>
<span class="s0">1610 0 0 4 1760 3812 0 0 318 /**</span>
 <span class="s0">* Removes the indicated model from the pool, indicating it will never be</span>
 <span class="s0">* loaded again; the model may then be freed.  If this function is never</span>
 <span class="s0">* called, a reference count will be maintained on every model every loaded,</span>
 <span class="s0">* and models will never be freed.</span>
 <span class="s0">*</span>
 <span class="s0">* @deprecated Use release_model(model) instead.</span>
 <span class="s0">*/ 1 8 filename 1 3920  </span>
<span class="s0">1611 0 0 4 1760 3812 0 0 434 /**</span>
 <span class="s0">* Removes the indicated model from the pool, indicating it will never be</span>
 <span class="s0">* loaded again; the model may then be freed.  If this function (and</span>
 <span class="s0">* garbage_collect()) is never called, a reference count will be maintained on</span>
 <span class="s0">* every model every loaded, and models will never be freed.</span>
 <span class="s0">*</span>
 <span class="s0">* The model's get_fullpath() value should not have been changed during its</span>
 <span class="s0">* lifetime, or this function may fail to locate it in the pool.</span>
 <span class="s0">*/ 1 5 model 1 4058  </span>
<span class="s0">1612 0 0 4 1761 3812 0 0 84 /**</span>
 <span class="s0">* Releases all models in the pool and restores the pool to the empty state.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1613 0 0 6 1762 3593 0 0 206 /**</span>
 <span class="s0">* Releases only those models in the pool that have a reference count of</span>
 <span class="s0">* exactly 1; i.e.  only those models that are not being used outside of the</span>
 <span class="s0">* pool.  Returns the number of models released.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1614 0 0 4 1763 3812 0 0 56 /**</span>
 <span class="s0">* Lists the contents of the model pool to cout.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1615 0 0 4 1763 3812 0 0 79 /**</span>
 <span class="s0">* Lists the contents of the model pool to the indicated output stream.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">1616 0 0 4 1764 3812 0 0 105 /**</span>
 <span class="s0">* Lists the contents of the model pool to the indicated output stream.  Helps</span>
 <span class="s0">* with debugging.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">1617 0 0 15 1767 4065 3319 0 0 1 6 param0 0 4063  </span>
<span class="s0">1618 0 0 7 1767 4065 3319 0 118 /**</span>
 <span class="s0">* Create a new ModelSaveRequest, and add it to the loader via save_async(),</span>
 <span class="s0">* to begin an asynchronous save.</span>
 <span class="s0">*/ 5 4 name 1 3841  8 filename 1 3920  7 options 1 4037  4 node 1 3650  6 loader 1 3742  </span>
<span class="s0">1619 0 0 6 1768 3920 0 0 83 /**</span>
 <span class="s0">* Returns the filename associated with this asynchronous ModelSaveRequest.</span>
 <span class="s0">*/ 1 4 this 3 4063  </span>
<span class="s0">1620 0 0 6 1769 4037 0 0 91 /**</span>
 <span class="s0">* Returns the LoaderOptions associated with this asynchronous</span>
 <span class="s0">* ModelSaveRequest.</span>
 <span class="s0">*/ 1 4 this 3 4063  </span>
<span class="s0">1621 0 0 7 1770 3650 2131 0 63 /**</span>
 <span class="s0">* Returns the node that was passed to the constructor.</span>
 <span class="s0">*/ 1 4 this 3 4063  </span>
<span class="s0">1622 0 0 7 1771 3742 3237 0 91 /**</span>
 <span class="s0">* Returns the Loader object associated with this asynchronous</span>
 <span class="s0">* ModelSaveRequest.</span>
 <span class="s0">*/ 1 4 this 3 4063  </span>
<span class="s0">1623 0 0 6 1772 3600 0 0 238 /**</span>
 <span class="s0">* Returns true if this request has completed, false if it is still pending.</span>
 <span class="s0">* When this returns true, you may retrieve the success flag with</span>
 <span class="s0">* get_success().</span>
 <span class="s0">* Equivalent to `req.done() and not req.cancelled()`.</span>
 <span class="s0">* @see done()</span>
 <span class="s0">*/ 1 4 this 3 4063  </span>
<span class="s0">1624 0 0 6 1773 3600 0 0 141 /**</span>
 <span class="s0">* Returns the true if the model was saved successfully, false otherwise.  It</span>
 <span class="s0">* is an error to call this unless done() returns true.</span>
 <span class="s0">*/ 1 4 this 3 4063  </span>
<span class="s0">1625 0 0 7 1778 3816 0 0 0 0 </span>
<span class="s0">1626 0 0 7 1781 3607 0 0 255 // The following methods define the new multitexture mode for TextureAttrib.</span>
<span class="s0">// Each TextureAttrib can add or remove individual texture stages from the</span>
<span class="s0">// complete set of textures that are to be applied; this is similar to the</span>
<span class="s0">// mechanism of LightAttrib. 0 </span>
<span class="s0">1627 0 0 23 1781 3607 0 0 143 /**</span>
 <span class="s0">* Constructs a new TextureAttrib object suitable for rendering the indicated</span>
 <span class="s0">* texture onto geometry, using the default TextureStage.</span>
 <span class="s0">*/ 1 3 tex 1 3755  </span>
<span class="s0">1628 0 0 7 1782 3607 0 0 95 /**</span>
 <span class="s0">* Constructs a new TextureAttrib object suitable for rendering untextured</span>
 <span class="s0">* geometry.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1629 0 0 7 1783 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1630 0 0 6 1784 3600 0 0 365 /**</span>
 <span class="s0">* Returns true if the TextureAttrib is an 'off' TextureAttrib, indicating</span>
 <span class="s0">* that it should disable texturing.</span>
 <span class="s0">*</span>
 <span class="s0">* If multitexture is in effect, a TextureAttrib may not be strictly &quot;on&quot; or</span>
 <span class="s0">* &quot;off&quot;; therefore, to get a more precise answer to this question, you should</span>
 <span class="s0">* consider using has_all_off() or get_num_off_stages() or has_off_stage()</span>
 <span class="s0">* instead.</span>
 <span class="s0">*/ 1 4 this 3 4066  </span>
<span class="s0">1631 0 0 7 1785 3755 0 0 141 /**</span>
 <span class="s0">* If the TextureAttrib is not an 'off' TextureAttrib, returns the base-level</span>
 <span class="s0">* texture that is associated.  Otherwise, return NULL.</span>
 <span class="s0">*/ 1 4 this 3 4066  </span>
<span class="s0">1632 0 0 7 1786 3607 0 0 109 /**</span>
 <span class="s0">* Constructs a new TextureAttrib object that turns off all stages (and hence</span>
 <span class="s0">* disables texturing).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1633 0 0 6 1787 3593 0 0 76 /**</span>
 <span class="s0">* Returns the number of stages that are turned on by the attribute.</span>
 <span class="s0">*/ 1 4 this 3 4066  </span>
<span class="s0">1634 0 0 7 1788 3753 0 0 84 /**</span>
 <span class="s0">* Returns the nth stage turned on by the attribute, sorted in render order.</span>
 <span class="s0">*/ 2 4 this 3 4066  1 n 1 3593  </span>
<span class="s0">1635 0 0 6 1790 3593 0 0 154 /**</span>
 <span class="s0">* Returns the number of on-stages that are relevant to the classic fixed</span>
 <span class="s0">* function pipeline.  This excludes texture stages such as normal maps.</span>
 <span class="s0">*/ 1 4 this 3 4066  </span>
<span class="s0">1636 0 0 7 1791 3753 0 0 211 /**</span>
 <span class="s0">* Returns the nth stage turned on by the attribute, sorted in render order,</span>
 <span class="s0">* including only those relevant to the classic fixed function pipeline.  This</span>
 <span class="s0">* excludes texture stages such as normal maps.</span>
 <span class="s0">*/ 2 4 this 3 4066  1 n 1 3593  </span>
<span class="s0">1637 0 0 6 1793 3593 0 0 315 /**</span>
 <span class="s0">* For each TextureStage listed in get_on_ff_stage(), this returns a unique</span>
 <span class="s0">* index number for the texture coordinate name used by that TextureStage.  It</span>
 <span class="s0">* is guaranteed to remain the same index number for each texcoord name (for a</span>
 <span class="s0">* given set of TextureStages), even if the texture render order changes.</span>
 <span class="s0">*/ 2 4 this 3 4066  1 n 1 3593  </span>
<span class="s0">1638 0 0 6 1794 3600 0 0 94 /**</span>
 <span class="s0">* Returns true if the indicated stage is turned on by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 3753  </span>
<span class="s0">1639 0 0 7 1795 3755 0 0 107 /**</span>
 <span class="s0">* Returns the texture associated with the indicated stage, or NULL if no</span>
 <span class="s0">* texture is associated.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 3753  </span>
<span class="s0">1640 0 0 6 1796 3877 0 0 209 /**</span>
 <span class="s0">* Returns the sampler associated with the indicated stage, or the one</span>
 <span class="s0">* associated with its texture if no custom stage has been specified.  It is</span>
 <span class="s0">* an error to call this if the stage does not exist.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 3753  </span>
<span class="s0">1641 0 0 6 1797 3593 0 0 74 /**</span>
 <span class="s0">* Returns the override value associated with the indicated stage.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 3753  </span>
<span class="s0">1642 0 0 6 1798 3593 0 0 142 /**</span>
 <span class="s0">* Returns the index number of the indicated TextureStage within the list of</span>
 <span class="s0">* on_stages, or -1 if the indicated stage is not listed.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 4068  </span>
<span class="s0">1643 0 0 6 1808 3593 0 0 77 /**</span>
 <span class="s0">* Returns the number of stages that are turned off by the attribute.</span>
 <span class="s0">*/ 1 4 this 3 4066  </span>
<span class="s0">1644 0 0 7 1809 3753 0 0 101 /**</span>
 <span class="s0">* Returns the nth stage turned off by the attribute, sorted in arbitrary</span>
 <span class="s0">* (pointer) order.</span>
 <span class="s0">*/ 2 4 this 3 4066  1 n 1 3593  </span>
<span class="s0">1645 0 0 6 1811 3600 0 0 95 /**</span>
 <span class="s0">* Returns true if the indicated stage is turned off by the attrib, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 3753  </span>
<span class="s0">1646 0 0 6 1812 3600 0 0 99 /**</span>
 <span class="s0">* Returns true if this attrib turns off all stages (although it may also turn</span>
 <span class="s0">* some on).</span>
 <span class="s0">*/ 1 4 this 3 4066  </span>
<span class="s0">1647 0 0 6 1814 3600 0 0 102 /**</span>
 <span class="s0">* Returns true if this is an identity attrib: it does not change the set of</span>
 <span class="s0">* stages in use.</span>
 <span class="s0">*/ 1 4 this 3 4066  </span>
<span class="s0">1648 0 0 7 1815 3607 0 0 145 /**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage added to the list of stages turned on by this attrib.</span>
 <span class="s0">*/ 5 4 this 3 4066  5 stage 1 3753  3 tex 1 3755  7 sampler 1 3877  8 override 5 3593  </span>
<span class="s0">1649 0 0 7 1815 3607 0 0 145 /**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage added to the list of stages turned on by this attrib.</span>
 <span class="s0">*/ 4 4 this 3 4066  5 stage 1 3753  3 tex 1 3755  8 override 5 3593  </span>
<span class="s0">1650 0 0 7 1816 3607 0 0 149 /**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage removed from the list of stages turned on by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 3753  </span>
<span class="s0">1651 0 0 7 1817 3607 0 0 146 /**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage added to the list of stages turned off by this attrib.</span>
 <span class="s0">*/ 3 4 this 3 4066  5 stage 1 3753  8 override 5 3593  </span>
<span class="s0">1652 0 0 7 1818 3607 0 0 150 /**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with the indicated</span>
 <span class="s0">* stage removed from the list of stages turned off by this attrib.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 3753  </span>
<span class="s0">1653 0 0 7 1819 3607 0 0 182 /**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with any included</span>
 <span class="s0">* TextureAttribs that happen to have the same name as the given object</span>
 <span class="s0">* replaced with the object.</span>
 <span class="s0">*/ 2 4 this 3 4066  5 stage 1 3753  </span>
<span class="s0">1654 0 0 7 1820 3607 0 0 230 /**</span>
 <span class="s0">* Returns a new TextureAttrib, just like this one, but with all references to</span>
 <span class="s0">* the given texture replaced with the new texture.</span>
 <span class="s0">*</span>
 <span class="s0">* As of Panda3D 1.10.13, new_tex may be null to remove the texture.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.4</span>
 <span class="s0">*/ 3 4 this 3 4066  3 tex 1 3755  7 new_tex 1 3755  </span>
<span class="s0">1655 0 0 7 1820 3607 0 0 46 // Let interrogate know this also accepts None 3 4 this 3 4066  3 tex 1 3755  7 new_tex 1 3906  </span>
<span class="s0">1656 0 0 6 1821 3593 0 0 0 0 </span>
<span class="s0">1657 0 0 7 1823 3816 0 0 0 0 </span>
<span class="s0">1658 0 0 7 1826 3607 0 0 69 /**</span>
 <span class="s0">* Constructs a TexGenAttrib that generates no stages at all.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1659 0 0 23 1826 3607 0 0 77 /**</span>
 <span class="s0">* Constructs a TexGenAttrib that generates just the indicated stage.</span>
 <span class="s0">*/ 2 5 stage 1 3753  4 mode 1 4070  </span>
<span class="s0">1660 0 0 7 1827 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1661 0 0 7 1828 3607 0 0 172 /**</span>
 <span class="s0">* Returns a new TexGenAttrib just like this one, with the indicated</span>
 <span class="s0">* generation mode for the given stage.  If this stage already exists, its</span>
 <span class="s0">* mode is replaced.</span>
 <span class="s0">*/ 3 4 this 3 4071  5 stage 1 3753  4 mode 1 4070  </span>
<span class="s0">1662 0 0 7 1828 3607 0 0 271 /**</span>
 <span class="s0">* Returns a new TexGenAttrib just like this one, with the indicated</span>
 <span class="s0">* generation mode for the given stage.  If this stage already exists, its</span>
 <span class="s0">* mode is replaced.</span>
 <span class="s0">*</span>
 <span class="s0">* This variant also accepts constant_value, which is only meaningful if mode</span>
 <span class="s0">* is M_constant.</span>
 <span class="s0">*/ 4 4 this 3 4071  5 stage 1 3753  4 mode 1 4070  14 constant_value 1 3909  </span>
<span class="s0">1663 0 0 7 1829 3607 0 0 94 /**</span>
 <span class="s0">* Returns a new TexGenAttrib just like this one, with the indicated stage</span>
 <span class="s0">* removed.</span>
 <span class="s0">*/ 2 4 this 3 4071  5 stage 1 3753  </span>
<span class="s0">1664 0 0 6 1830 3600 0 0 98 /**</span>
 <span class="s0">* Returns true if no stages are defined in the TexGenAttrib, false if at</span>
 <span class="s0">* least one is.</span>
 <span class="s0">*/ 1 4 this 3 4071  </span>
<span class="s0">1665 0 0 6 1831 3600 0 0 157 /**</span>
 <span class="s0">* Returns true if there is a mode associated with the indicated stage, or</span>
 <span class="s0">* false otherwise (in which case get_transform(stage) will return M_off).</span>
 <span class="s0">*/ 2 4 this 3 4071  5 stage 1 3753  </span>
<span class="s0">1666 0 0 6 1832 4070 0 0 142 /**</span>
 <span class="s0">* Returns the generation mode associated with the named texture stage, or</span>
 <span class="s0">* M_off if nothing is associated with the indicated stage.</span>
 <span class="s0">*/ 2 4 this 3 4071  5 stage 1 3753  </span>
<span class="s0">1667 0 0 6 1833 3600 0 0 207 /**</span>
 <span class="s0">* Returns true if the indicated TextureStage will have texture coordinates</span>
 <span class="s0">* generated for it automatically (and thus there is no need to upload the</span>
 <span class="s0">* texture coordinates encoded in the vertices).</span>
 <span class="s0">*/ 2 4 this 3 4071  5 stage 1 3753  </span>
<span class="s0">1668 0 0 6 1834 3909 0 0 133 /**</span>
 <span class="s0">* Returns the constant value associated with the named texture stage.  This</span>
 <span class="s0">* is only meaningful if the mode is M_constant.</span>
 <span class="s0">*/ 2 4 this 3 4071  5 stage 1 3753  </span>
<span class="s0">1669 0 0 6 1835 3593 0 0 182 /**</span>
 <span class="s0">* Returns the union of the Geom::GeomRendering bits that will be required</span>
 <span class="s0">* once this TexGenAttrib is applied to a geom which includes the indicated</span>
 <span class="s0">* geom_rendering bits.</span>
 <span class="s0">*/ 2 4 this 3 4071  14 geom_rendering 1 3593  </span>
<span class="s0">1670 0 0 6 1836 3593 0 0 0 0 </span>
<span class="s0">1671 0 0 7 1838 3816 0 0 0 0 </span>
<span class="s0">1672 0 0 7 1840 4073 2131 0 269 /**</span>
 <span class="s0">* The default constructor creates a default occlusion polygon in the XZ plane</span>
 <span class="s0">* (or XY plane in a y-up coordinate system).  Use the normal Panda set_pos(),</span>
 <span class="s0">* set_hpr(), set_scale() to position it appropriately, or replace the</span>
 <span class="s0">* vertices with set_vertices().</span>
 <span class="s0">*/ 1 4 name 1 3841  </span>
<span class="s0">1673 0 0 4 1841 3812 0 0 62 /**</span>
 <span class="s0">* If true, the back-face will also be used to occlude</span>
 <span class="s0">*/ 2 4 this 3 4073  5 value 1 3600  </span>
<span class="s0">1674 0 0 6 1842 3600 0 0 40 /**</span>
 <span class="s0">* Is this occluder double-sided</span>
 <span class="s0">*/ 1 4 this 3 4073  </span>
<span class="s0">1675 0 0 4 1843 3812 0 0 202 /**</span>
 <span class="s0">* Minimum screen coverage needed before occluder used.  Range should be 0 to</span>
 <span class="s0">* 1. For example, setting to 0.2 would mean that the occluder needs to cover</span>
 <span class="s0">* 20% of the screen to be considered.</span>
 <span class="s0">*/ 2 4 this 3 4073  5 value 1 3598  </span>
<span class="s0">1676 0 0 6 1844 3598 0 0 47 /**</span>
 <span class="s0">* Returns the minimum screen coverage.</span>
 <span class="s0">*/ 1 4 this 3 4073  </span>
<span class="s0">1677 0 0 4 1845 3812 0 0 176 /**</span>
 <span class="s0">* Replaces the four vertices of the occluder polygon.  The vertices should be</span>
 <span class="s0">* defined in a counterclockwise orientation when looking at the face of the</span>
 <span class="s0">* occluder.</span>
 <span class="s0">*/ 5 4 this 3 4073  2 v0 1 3809  2 v1 1 3809  2 v2 1 3809  2 v3 1 3809  </span>
<span class="s0">1678 0 0 6 1846 3796 0 0 99 /**</span>
 <span class="s0">* Returns the number of vertices in the occluder polygon.  This should always</span>
 <span class="s0">* return 4.</span>
 <span class="s0">*/ 1 4 this 3 4074  </span>
<span class="s0">1679 0 0 6 1847 3809 0 0 58 /**</span>
 <span class="s0">* Returns the nth vertex of the occluder polygon.</span>
 <span class="s0">*/ 2 4 this 3 4074  1 n 1 3796  </span>
<span class="s0">1680 0 0 4 1848 3812 0 0 55 /**</span>
 <span class="s0">* Sets the nth vertex of the occluder polygon.</span>
 <span class="s0">*/ 3 4 this 3 4073  1 n 1 3796  1 v 1 3809  </span>
<span class="s0">1681 0 0 7 1853 3816 0 0 0 0 </span>
<span class="s0">1682 0 0 7 1855 3837 0 0 68 /**</span>
 <span class="s0">* Constructs a new OccluderEffect object that does nothing.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1683 0 0 6 1856 3593 0 0 77 /**</span>
 <span class="s0">* Returns the number of occluders that are enabled by the effectute.</span>
 <span class="s0">*/ 1 4 this 3 4076  </span>
<span class="s0">1684 0 0 7 1857 3894 2739 0 85 /**</span>
 <span class="s0">* Returns the nth occluder enabled by the effectute, sorted in render order.</span>
 <span class="s0">*/ 2 4 this 3 4076  1 n 1 3593  </span>
<span class="s0">1685 0 0 6 1859 3600 0 0 95 /**</span>
 <span class="s0">* Returns true if the indicated occluder is enabled by the effect, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 4076  8 occluder 1 3884  </span>
<span class="s0">1686 0 0 6 1860 3600 0 0 105 /**</span>
 <span class="s0">* Returns true if this is an identity effect: it does not change the set of</span>
 <span class="s0">* occluders in use.</span>
 <span class="s0">*/ 1 4 this 3 4076  </span>
<span class="s0">1687 0 0 7 1861 3837 0 0 150 /**</span>
 <span class="s0">* Returns a new OccluderEffect, just like this one, but with the indicated</span>
 <span class="s0">* occluder added to the list of occluders enabled by this effect.</span>
 <span class="s0">*/ 2 4 this 3 4076  8 occluder 1 3884  </span>
<span class="s0">1688 0 0 7 1862 3837 0 0 154 /**</span>
 <span class="s0">* Returns a new OccluderEffect, just like this one, but with the indicated</span>
 <span class="s0">* occluder removed from the list of occluders enabled by this effect.</span>
 <span class="s0">*/ 2 4 this 3 4076  8 occluder 1 3884  </span>
<span class="s0">1689 0 0 7 1863 3816 0 0 0 0 </span>
<span class="s0">1690 0 0 15 1868 4080 3418 0 0 1 6 param0 0 4078  </span>
<span class="s0">1691 0 0 7 1868 4080 3418 0 71 /**</span>
 <span class="s0">* Use PolylightNode() to construct a new PolylightNode object.</span>
 <span class="s0">*/ 1 4 name 1 3841  </span>
<span class="s0">1692 0 0 4 1869 3812 0 0 28 /**</span>
 <span class="s0">* Enable this light</span>
 <span class="s0">*/ 1 4 this 3 4080  </span>
<span class="s0">1693 0 0 4 1870 3812 0 0 29 /**</span>
 <span class="s0">* Disable this light</span>
 <span class="s0">*/ 1 4 this 3 4080  </span>
<span class="s0">1694 0 0 4 1871 3812 0 0 36 /**</span>
 <span class="s0">* Set this light's position</span>
 <span class="s0">*/ 2 4 this 3 4080  8 position 1 3809  </span>
<span class="s0">1695 0 0 4 1871 3812 0 0 36 /**</span>
 <span class="s0">* Set this light's position</span>
 <span class="s0">*/ 4 4 this 3 4080  1 x 1 3598  1 y 1 3598  1 z 1 3598  </span>
<span class="s0">1696 0 0 7 1872 3896 0 0 40 /**</span>
 <span class="s0">* Returns position as a LPoint3</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1697 0 0 4 1873 3812 0 0 35 /**</span>
 <span class="s0">* Set the light's color...</span>
 <span class="s0">*/ 2 4 this 3 4080  5 color 1 3820  </span>
<span class="s0">1698 0 0 4 1873 3812 0 0 60 /**</span>
 <span class="s0">* Set the light's color... 3 floats between 0 and 1</span>
 <span class="s0">*/ 4 4 this 3 4080  1 r 1 3598  1 g 1 3598  1 b 1 3598  </span>
<span class="s0">1699 0 0 7 1874 3905 0 0 46 /**</span>
 <span class="s0">* Returns the light's color as LColor</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1700 0 0 7 1875 3905 0 0 173 /**</span>
 <span class="s0">* This differs from get_color in that when applying the light color we need</span>
 <span class="s0">* to make sure that a color flattening external to the PolylightNode is not</span>
 <span class="s0">* ignored.</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1701 0 0 4 1876 3812 0 0 51 /**</span>
 <span class="s0">* Set radius of the spherical light volume</span>
 <span class="s0">*/ 2 4 this 3 4080  1 r 1 3598  </span>
<span class="s0">1702 0 0 6 1877 3598 0 0 51 /**</span>
 <span class="s0">* Get radius of the spherical light volume</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1703 0 0 6 1878 3600 0 0 48 /**</span>
 <span class="s0">* Set ALINEAR or AQUADRATIC attenuation</span>
 <span class="s0">*/ 2 4 this 3 4080  4 type 1 3764  </span>
<span class="s0">1704 0 0 6 1879 3764 0 0 55 /**</span>
 <span class="s0">* Get &quot;linear&quot; or &quot;quadratic&quot; attenuation type</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1705 0 0 4 1880 3812 0 0 105 /**</span>
 <span class="s0">* Set the quadratic attenuation factor a0 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/ 2 4 this 3 4080  2 a0 1 3598  </span>
<span class="s0">1706 0 0 4 1881 3812 0 0 105 /**</span>
 <span class="s0">* Set the quadratic attenuation factor a1 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/ 2 4 this 3 4080  2 a1 1 3598  </span>
<span class="s0">1707 0 0 4 1882 3812 0 0 105 /**</span>
 <span class="s0">* Set the quadratic attenuation factor a2 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/ 2 4 this 3 4080  2 a2 1 3598  </span>
<span class="s0">1708 0 0 6 1883 3598 0 0 105 /**</span>
 <span class="s0">* Get the quadratic attenuation factor a0 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1709 0 0 6 1884 3598 0 0 105 /**</span>
 <span class="s0">* Get the quadratic attenuation factor a1 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1710 0 0 6 1885 3598 0 0 105 /**</span>
 <span class="s0">* Get the quadratic attenuation factor a2 fd = 1 / ( a0 + a1*distance +</span>
 <span class="s0">* a2*distance*distance)</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1711 0 0 4 1886 3812 0 0 104 /**</span>
 <span class="s0">* Set flickering to true so at every loop this light's color is varied based</span>
 <span class="s0">* on flicker_type</span>
 <span class="s0">*/ 1 4 this 3 4080  </span>
<span class="s0">1712 0 0 4 1887 3812 0 0 30 /**</span>
 <span class="s0">* Turn flickering off</span>
 <span class="s0">*/ 1 4 this 3 4080  </span>
<span class="s0">1713 0 0 6 1888 3600 0 0 44 /**</span>
 <span class="s0">* Check is this light is flickering</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1714 0 0 6 1889 3600 0 0 181 /**</span>
 <span class="s0">* Flicker type can be FRANDOM or FSIN At a later point there might be a</span>
 <span class="s0">* FCUSTOM Custom flicker will be a set of fix points recorded by animating</span>
 <span class="s0">* the light's intensity</span>
 <span class="s0">*/ 2 4 this 3 4080  4 type 1 3763  </span>
<span class="s0">1715 0 0 6 1890 3763 0 0 34 /**</span>
 <span class="s0">* Returns FRANDOM or FSIN</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1716 0 0 4 1891 3812 0 0 142 /**</span>
 <span class="s0">* Set the offset value for the random and sin flicker variations... used to</span>
 <span class="s0">* tweak the flicker This value is added to the variation</span>
 <span class="s0">*/ 2 4 this 3 4080  6 offset 1 3598  </span>
<span class="s0">1717 0 0 6 1892 3598 0 0 73 /**</span>
 <span class="s0">* Get the offset value for the random and sin flicker variations</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1718 0 0 4 1893 3812 0 0 148 /**</span>
 <span class="s0">* Set the scale value for the random and sin flicker variations... used to</span>
 <span class="s0">* tweak the flicker This value is multiplied with the variation</span>
 <span class="s0">*/ 2 4 this 3 4080  5 scale 1 3598  </span>
<span class="s0">1719 0 0 6 1894 3598 0 0 72 /**</span>
 <span class="s0">* Get the scale value for the random and sin flicker variations</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1720 0 0 4 1895 3812 0 0 133 /**</span>
 <span class="s0">* Set the step size for the sin function in flicker This is the increment</span>
 <span class="s0">* size for the value supplied to the sin function</span>
 <span class="s0">*/ 2 4 this 3 4080  4 step 1 3598  </span>
<span class="s0">1721 0 0 6 1896 3598 0 0 133 /**</span>
 <span class="s0">* Get the step size for the sin function in flicker This is the increment</span>
 <span class="s0">* size for the value supplied to the sin function</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1722 0 0 4 1897 3812 0 0 39 /**</span>
 <span class="s0">* Set frequency of sin flicker</span>
 <span class="s0">*/ 2 4 this 3 4080  1 f 1 3598  </span>
<span class="s0">1723 0 0 6 1898 3598 0 0 39 /**</span>
 <span class="s0">* Get frequency of sin flicker</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1724 0 0 6 1899 3600 0 0 21 // Comparison methods 2 4 this 3 4078  5 other 1 4078  </span>
<span class="s0">1725 0 0 6 1900 3600 0 0 0 2 4 this 3 4078  5 other 1 4078  </span>
<span class="s0">1726 0 0 6 1901 3600 0 0 0 2 4 this 3 4078  5 other 1 4078  </span>
<span class="s0">1727 0 0 6 1902 3593 0 0 486 /**</span>
 <span class="s0">* Returns a number less than zero if this PolylightNode sorts before the</span>
 <span class="s0">* other one, greater than zero if it sorts after, or zero if they are</span>
 <span class="s0">* equivalent.</span>
 <span class="s0">*</span>
 <span class="s0">* Two PolylightNodes are considered equivalent if they consist of exactly the</span>
 <span class="s0">* same properties Otherwise, they are different; different PolylightNodes</span>
 <span class="s0">* will be ranked in a consistent but undefined ordering; the ordering is</span>
 <span class="s0">* useful only for placing the PolylightNodes in a sorted container like an</span>
 <span class="s0">* STL set.</span>
 <span class="s0">*/ 2 4 this 3 4078  5 other 1 4078  </span>
<span class="s0">1728 0 0 6 1903 3600 0 0 45 /**</span>
 <span class="s0">* Is this light is enabled/disabled?</span>
 <span class="s0">*/ 1 4 this 3 4078  </span>
<span class="s0">1729 0 0 7 1904 3816 0 0 0 0 </span>
<span class="s0">1730 0 0 7 1910 3837 0 0 51 /**</span>
 <span class="s0">* Constructs a new PolylightEffect object.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1731 0 0 23 1910 3837 0 0 51 /**</span>
 <span class="s0">* Constructs a new PolylightEffect object.</span>
 <span class="s0">*/ 3 6 weight 1 3598  7 contrib 1 3766  13 effect_center 1 3809  </span>
<span class="s0">1732 0 0 23 1910 3837 0 0 51 /**</span>
 <span class="s0">* Constructs a new PolylightEffect object.</span>
 <span class="s0">*/ 4 6 weight 1 3598  7 contrib 1 3766  13 effect_center 1 3809  6 lights 1 4081  </span>
<span class="s0">1733 0 0 7 1911 3837 0 0 76 /**</span>
 <span class="s0">* Add a PolylightNode object to this effect and return a new effect</span>
 <span class="s0">*/ 2 4 this 3 4083  8 newlight 1 3884  </span>
<span class="s0">1734 0 0 7 1912 3837 0 0 74 /**</span>
 <span class="s0">* Remove a light from this effect.  Return the new updated effect</span>
 <span class="s0">*/ 2 4 this 3 4083  8 newlight 1 3884  </span>
<span class="s0">1735 0 0 7 1913 3837 0 0 241 /**</span>
 <span class="s0">* Set weight and return a new effect... the reason this couldnt be done</span>
 <span class="s0">* through make was because that would return a new effect without the</span>
 <span class="s0">* lightgroup which is static and cant be accessed Here, we just pass that to</span>
 <span class="s0">* the make</span>
 <span class="s0">*/ 2 4 this 3 4083  1 w 1 3598  </span>
<span class="s0">1736 0 0 7 1914 3837 0 0 247 /**</span>
 <span class="s0">* Set Contrib Type and return a new effect... the reason this couldnt be done</span>
 <span class="s0">* through make was because that would return a new effect without the</span>
 <span class="s0">* lightgroup which is static and cant be accessed Here, we just pass that to</span>
 <span class="s0">* the make</span>
 <span class="s0">*/ 2 4 this 3 4083  1 c 1 3766  </span>
<span class="s0">1737 0 0 7 1915 3837 0 0 241 /**</span>
 <span class="s0">* Set weight and return a new effect... the reason this couldnt be done</span>
 <span class="s0">* through make was because that would return a new effect without the</span>
 <span class="s0">* lightgroup which is static and cant be accessed Here, we just pass that to</span>
 <span class="s0">* the make</span>
 <span class="s0">*/ 2 4 this 3 4083  2 ec 1 3809  </span>
<span class="s0">1738 0 0 6 1916 3598 0 0 31 /**</span>
 <span class="s0">* Get the weight value</span>
 <span class="s0">*/ 1 4 this 3 4083  </span>
<span class="s0">1739 0 0 6 1917 3766 0 0 40 /**</span>
 <span class="s0">* Returns CT_all or CT_proximal</span>
 <span class="s0">*/ 1 4 this 3 4083  </span>
<span class="s0">1740 0 0 7 1918 3896 0 0 49 /**</span>
 <span class="s0">* Return the value of the _effect_center</span>
 <span class="s0">*/ 1 4 this 3 4083  </span>
<span class="s0">1741 0 0 6 1919 3600 0 0 100 /**</span>
 <span class="s0">* Returns true if the indicated light is listed in the PolylightEffect, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 4083  5 light 1 3884  </span>
<span class="s0">1742 0 0 7 1920 3816 0 0 0 0 </span>
<span class="s0">1743 0 0 23 1923 3607 0 0 65 /**</span>
 <span class="s0">* Constructs a new ShaderAttrib object with nothing set.</span>
 <span class="s0">*/ 2 6 shader 5 3771  8 priority 5 3593  </span>
<span class="s0">1744 0 0 7 1924 3607 0 0 133 /**</span>
 <span class="s0">* Constructs a new ShaderAttrib object that disables the use of shaders (it</span>
 <span class="s0">* does not clear out all shader data, however.)</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1745 0 0 7 1925 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1746 0 0 6 1927 3600 0 0 109 /**</span>
 <span class="s0">* If true, the shader field of this attribute overrides the shader field of</span>
 <span class="s0">* the parent attribute.</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1747 0 0 6 1928 3600 0 0 142 /**</span>
 <span class="s0">* If true, then this ShaderAttrib does not contain an explicit shader -</span>
 <span class="s0">* instead, it requests the automatic generation of a shader.</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1748 0 0 6 1929 3593 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1749 0 0 6 1930 3593 0 0 105 /**</span>
 <span class="s0">* Returns the number of geometry instances.  A value of 0 means not to use</span>
 <span class="s0">* instancing at all.</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1750 0 0 6 1931 3600 0 0 0 1 4 this 3 4085  </span>
<span class="s0">1751 0 0 6 1932 3600 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1752 0 0 6 1933 3600 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1753 0 0 6 1934 3600 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1754 0 0 6 1935 3600 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1755 0 0 7 1936 3607 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 4085  1 s 1 3771  8 priority 5 3593  </span>
<span class="s0">1756 0 0 7 1937 3607 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 4085  8 priority 5 3593  </span>
<span class="s0">1757 0 0 7 1938 3607 0 0 104 /**</span>
 <span class="s0">* Set auto shader with bitmask to customize use, e.g., to keep normal, glow,</span>
 <span class="s0">* etc., on or off</span>
 <span class="s0">*/ 3 4 this 3 4085  13 shader_switch 1 3908  8 priority 5 3593  </span>
<span class="s0">1758 0 0 7 1938 3607 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 4085  8 priority 5 3593  </span>
<span class="s0">1759 0 0 7 1939 3607 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1760 0 0 39 1940 3607 0 0 0 4 4 this 3 4085  6 param0 0 3873  6 param1 0 3623  8 priority 5 3593  </span>
<span class="s0">1761 0 0 7 1940 3607 0 0 16 // Shader Inputs 2 4 this 3 4085  5 input 1 3878  </span>
<span class="s0">1762 0 0 39 1941 3607 0 0 0 3 4 this 3 4085  4 args 1 3623  6 kwargs 1 3623  </span>
<span class="s0">1763 0 0 7 1942 3607 0 0 211 /**</span>
 <span class="s0">* Sets the geometry instance count.  Do not confuse this with instanceTo,</span>
 <span class="s0">* which is used for animation instancing, and has nothing to do with this.  A</span>
 <span class="s0">* value of 0 means not to use instancing at all.</span>
 <span class="s0">*/ 2 4 this 3 4085  14 instance_count 1 3593  </span>
<span class="s0">1764 0 0 7 1943 3607 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 4085  4 flag 1 3593  5 value 1 3600  </span>
<span class="s0">1765 0 0 7 1944 3607 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 4085  4 flag 1 3593  </span>
<span class="s0">1766 0 0 7 1945 3607 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 3873  </span>
<span class="s0">1767 0 0 7 1945 3607 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 3841  </span>
<span class="s0">1768 0 0 7 1946 3607 0 0 54 /**</span>
 <span class="s0">* Clears all the shader inputs on the attrib.</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1769 0 0 6 1947 3600 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 4085  4 flag 1 3593  </span>
<span class="s0">1770 0 0 6 1948 3600 0 0 68 /**</span>
 <span class="s0">* Returns true if there is a ShaderInput of the given name.</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 3873  </span>
<span class="s0">1771 0 0 7 1949 3771 0 0 186 /**</span>
 <span class="s0">* Returns the shader object associated with the node.  If get_override</span>
 <span class="s0">* returns true, but get_shader returns NULL, that means that this attribute</span>
 <span class="s0">* should disable the shader.</span>
 <span class="s0">*/ 1 4 this 3 4085  </span>
<span class="s0">1772 0 0 6 1950 3878 0 0 158 /**</span>
 <span class="s0">* Returns the ShaderInput of the given name.  If no such name is found, this</span>
 <span class="s0">* function does not return NULL --- it returns the &quot;blank&quot; ShaderInput.</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 3873  </span>
<span class="s0">1773 0 0 6 1950 3878 0 0 158 /**</span>
 <span class="s0">* Returns the ShaderInput of the given name.  If no such name is found, this</span>
 <span class="s0">* function does not return NULL --- it returns the &quot;blank&quot; ShaderInput.</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 3841  </span>
<span class="s0">1774 0 0 6 1951 3884 0 0 115 /**</span>
 <span class="s0">* Returns the ShaderInput as a nodepath.  Assertion fails if there is none,</span>
 <span class="s0">* or if it is not a nodepath.</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 3873  </span>
<span class="s0">1775 0 0 7 1952 4088 0 0 111 /**</span>
 <span class="s0">* Returns the ShaderInput as a vector.  Assertion fails if there is none, or</span>
 <span class="s0">* if it is not a vector.</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 4087  </span>
<span class="s0">1776 0 0 7 1953 3755 0 0 207 /**</span>
 <span class="s0">* Returns the ShaderInput as a texture.  Assertion fails if there is none, or</span>
 <span class="s0">* if it is not a texture.</span>
 <span class="s0">*</span>
 <span class="s0">* If sampler is not NULL, the sampler state to use for this texture is</span>
 <span class="s0">* assigned to it.</span>
 <span class="s0">*/ 3 4 this 3 4085  2 id 1 3873  7 sampler 5 4089  </span>
<span class="s0">1777 0 0 6 1954 3881 0 0 136 /**</span>
 <span class="s0">* Returns the ShaderInput as a ShaderPtrData struct.  Assertion fails if</span>
 <span class="s0">* there is none.  or if it is not a PTA(double/float)</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 3873  </span>
<span class="s0">1778 0 0 6 1955 3800 0 0 123 /**</span>
 <span class="s0">* Returns the ShaderInput as a matrix.  Assertion fails if there is none, or</span>
 <span class="s0">* if it is not a matrix or NodePath.</span>
 <span class="s0">*/ 3 4 this 3 4085  2 id 1 3873  6 matrix 1 3902  </span>
<span class="s0">1779 0 0 7 1956 4091 0 0 123 /**</span>
 <span class="s0">* Returns the ShaderInput as a ShaderBuffer.  Assertion fails if there is</span>
 <span class="s0">* none, or if it is not a ShaderBuffer.</span>
 <span class="s0">*/ 2 4 this 3 4085  2 id 1 3873  </span>
<span class="s0">1780 0 0 4 1957 3812 0 0 53 /**</span>
 <span class="s0">* Factory method to generate a Shader object</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1781 0 0 6 1963 3593 0 0 0 0 </span>
<span class="s0">1782 0 0 7 1965 3816 0 0 0 0 </span>
<span class="s0">1783 0 0 23 1968 3837 0 0 52 /**</span>
 <span class="s0">* Constructs a new ShowBoundsEffect object.</span>
 <span class="s0">*/ 1 5 tight 5 3600  </span>
<span class="s0">1784 0 0 6 1969 3600 0 0 157 /**</span>
 <span class="s0">* Returns true if the &quot;tight&quot; flag was set, meaning the effect should compute</span>
 <span class="s0">* and draw the tight bounding-box of the node's vertices every frame.</span>
 <span class="s0">*/ 1 4 this 3 4092  </span>
<span class="s0">1785 0 0 7 1970 3816 0 0 0 0 </span>
<span class="s0">1786 0 0 7 1973 3837 0 0 74 /**</span>
 <span class="s0">* Constructs a TexProjectorEffect that modifies no stages at all.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1787 0 0 7 1974 3837 0 0 536 /**</span>
 <span class="s0">* Returns a new TexProjectorEffect just like this one, with the indicated</span>
 <span class="s0">* projection for the given stage.  If this stage already exists, its</span>
 <span class="s0">* projection definition is replaced.</span>
 <span class="s0">*</span>
 <span class="s0">* The relative transform between the &quot;from&quot; and the &quot;to&quot; nodes is</span>
 <span class="s0">* automatically applied to the texture transform each frame.</span>
 <span class="s0">*</span>
 <span class="s0">* Furthermore, if the &quot;to&quot; node is a LensNode, its projection matrix is also</span>
 <span class="s0">* applied to the texture transform.  In this case, the lens_index may be used</span>
 <span class="s0">* to select the particular lens that should be used.</span>
 <span class="s0">*/ 5 4 this 3 4094  5 stage 1 3753  4 from 1 3884  2 to 1 3884  10 lens_index 5 3593  </span>
<span class="s0">1788 0 0 7 1975 3837 0 0 100 /**</span>
 <span class="s0">* Returns a new TexProjectorEffect just like this one, with the indicated</span>
 <span class="s0">* stage removed.</span>
 <span class="s0">*/ 2 4 this 3 4094  5 stage 1 3753  </span>
<span class="s0">1789 0 0 6 1976 3600 0 0 104 /**</span>
 <span class="s0">* Returns true if no stages are defined in the TexProjectorEffect, false if</span>
 <span class="s0">* at least one is.</span>
 <span class="s0">*/ 1 4 this 3 4094  </span>
<span class="s0">1790 0 0 6 1977 3600 0 0 182 /**</span>
 <span class="s0">* Returns true if there is a transform associated with the indicated stage,</span>
 <span class="s0">* or false otherwise (in which case get_transform(stage) will return the</span>
 <span class="s0">* identity transform).</span>
 <span class="s0">*/ 2 4 this 3 4094  5 stage 1 3753  </span>
<span class="s0">1791 0 0 7 1978 3894 2739 0 227 /**</span>
 <span class="s0">* Returns the &quot;from&quot; node associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  The relative transform between the &quot;from&quot; and the &quot;to&quot;</span>
 <span class="s0">* nodes is automatically applied to the texture transform each frame.</span>
 <span class="s0">*/ 2 4 this 3 4094  5 stage 1 3753  </span>
<span class="s0">1792 0 0 7 1979 3894 2739 0 343 /**</span>
 <span class="s0">* Returns the &quot;to&quot; node associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  The relative transform between the &quot;from&quot; and the &quot;to&quot;</span>
 <span class="s0">* nodes is automatically applied to the texture transform each frame.</span>
 <span class="s0">*</span>
 <span class="s0">* Furthermore, if the &quot;to&quot; node is a LensNode, its projection matrix is also</span>
 <span class="s0">* applied to the texture transform.</span>
 <span class="s0">*/ 2 4 this 3 4094  5 stage 1 3753  </span>
<span class="s0">1793 0 0 6 1980 3593 0 0 221 /**</span>
 <span class="s0">* Returns the lens_index associated with the TexProjectorEffect on the</span>
 <span class="s0">* indicated stage.  This is only used if the &quot;to&quot; node is a LensNode, in</span>
 <span class="s0">* which case it specifies the particular lens that should be used.</span>
 <span class="s0">*/ 2 4 this 3 4094  5 stage 1 3753  </span>
<span class="s0">1794 0 0 7 1981 3816 0 0 0 0 </span>
<span class="s0">1795 0 0 7 1983 3837 0 0 169 /**</span>
 <span class="s0">* Constructs a new screen-relative ScissorEffect.  The frame defines a left,</span>
 <span class="s0">* right, bottom, top region, relative to the DisplayRegion.  See</span>
 <span class="s0">* ScissorAttrib.</span>
 <span class="s0">*/ 2 5 frame 1 3880  4 clip 5 3600  </span>
<span class="s0">1796 0 0 7 1984 3837 0 0 249 /**</span>
 <span class="s0">* Constructs a new node-relative ScissorEffect.  The four points are</span>
 <span class="s0">* understood to be relative to the indicated node, or the current node if the</span>
 <span class="s0">* indicated NodePath is empty, and determine four points surrounding the</span>
 <span class="s0">* scissor region.</span>
 <span class="s0">*/ 5 1 a 1 3809  1 b 1 3809  1 c 1 3809  1 d 1 3809  4 node 5 3884  </span>
<span class="s0">1797 0 0 7 1984 3837 0 0 249 /**</span>
 <span class="s0">* Constructs a new node-relative ScissorEffect.  The two points are</span>
 <span class="s0">* understood to be relative to the indicated node, or the current node if the</span>
 <span class="s0">* NodePath is empty, and determine the diagonally opposite corners of the</span>
 <span class="s0">* scissor region.</span>
 <span class="s0">*/ 3 1 a 1 3809  1 b 1 3809  4 node 5 3884  </span>
<span class="s0">1798 0 0 7 1984 3837 0 0 197 /**</span>
 <span class="s0">* Constructs a new node-relative ScissorEffect, with no points.  This empty</span>
 <span class="s0">* ScissorEffect does nothing.  You must then call add_point a number of times</span>
 <span class="s0">* to add the points you require.</span>
 <span class="s0">*/ 1 4 clip 5 3600  </span>
<span class="s0">1799 0 0 7 1985 3837 0 0 325 /**</span>
 <span class="s0">* Returns a new ScissorEffect with the indicated point added.  It is only</span>
 <span class="s0">* valid to call this on a &quot;node&quot; type ScissorEffect.  The full set of points,</span>
 <span class="s0">* projected into screen space, defines the bounding volume of the rectangular</span>
 <span class="s0">* scissor region.</span>
 <span class="s0">*</span>
 <span class="s0">* Each point may be relative to a different node, if desired.</span>
 <span class="s0">*/ 3 4 this 3 4096  5 point 1 3809  4 node 5 3884  </span>
<span class="s0">1800 0 0 6 1986 3600 0 0 149 /**</span>
 <span class="s0">* Returns true if the ScissorEffect is a screen-based effect, meaning</span>
 <span class="s0">* get_frame() has a meaningful value, but get_a() and get_b() do not.</span>
 <span class="s0">*/ 1 4 this 3 4096  </span>
<span class="s0">1801 0 0 6 1987 3880 0 0 253 /**</span>
 <span class="s0">* If is_screen() returns true, this method may be called to query the screen-</span>
 <span class="s0">* based scissor frame.  This is a series of left, right, bottom, top,</span>
 <span class="s0">* representing the scissor frame relative to the current DisplayRegion.  See</span>
 <span class="s0">* ScissorAttrib.</span>
 <span class="s0">*/ 1 4 this 3 4096  </span>
<span class="s0">1802 0 0 6 1988 3593 0 0 77 /**</span>
 <span class="s0">* Returns the number of node-based scissor points.  See get_point().</span>
 <span class="s0">*/ 1 4 this 3 4096  </span>
<span class="s0">1803 0 0 6 1989 3809 0 0 293 /**</span>
 <span class="s0">* If is_screen() returns false, then get_num_points() and get_point() may be</span>
 <span class="s0">* called to query the node-based scissor frame.  These return n points (at</span>
 <span class="s0">* least two), which are understood to be in the space of this node, and which</span>
 <span class="s0">* define any opposite corners of the scissor frame.</span>
 <span class="s0">*/ 2 4 this 3 4096  1 n 1 3593  </span>
<span class="s0">1804 0 0 7 1991 3894 2739 0 114 /**</span>
 <span class="s0">* Returns the node to which the nth point is relative, or empty NodePath to</span>
 <span class="s0">* indicate the current node.</span>
 <span class="s0">*/ 2 4 this 3 4096  1 n 1 3593  </span>
<span class="s0">1805 0 0 6 1993 3600 0 0 104 /**</span>
 <span class="s0">* Returns true if this ScissorEffect actually enables scissoring, or false if</span>
 <span class="s0">* it culls only.</span>
 <span class="s0">*/ 1 4 this 3 4096  </span>
<span class="s0">1806 0 0 7 1994 3816 0 0 0 0 </span>
<span class="s0">1807 0 0 7 1997 4098 3493 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 3 gsg 5 3851  </span>
<span class="s0">1808 0 0 15 1997 4098 3493 0 0 1 6 param0 0 4099  </span>
<span class="s0">1809 0 0 4 2003 3812 0 0 360 /**</span>
 <span class="s0">* Specifies the particular GraphicsStateGuardian that this object will</span>
 <span class="s0">* attempt to optimize to.  The GSG may specify parameters such as maximum</span>
 <span class="s0">* number of vertices per vertex data, max number of vertices per primitive,</span>
 <span class="s0">* and whether triangle strips are preferred.  It also affects the types of</span>
 <span class="s0">* vertex column data that is created by premunge().</span>
 <span class="s0">*/ 2 4 this 3 4098  3 gsg 1 3851  </span>
<span class="s0">1810 0 0 4 2004 3812 0 0 218 /**</span>
 <span class="s0">* Specifies that no particular GraphicsStateGuardian will be used to guide</span>
 <span class="s0">* the optimization.  The SceneGraphReducer will instead use config variables</span>
 <span class="s0">* such as max-collect-vertices and max-collect-indices.</span>
 <span class="s0">*/ 1 4 this 3 4098  </span>
<span class="s0">1811 0 0 7 2005 3851 0 0 120 /**</span>
 <span class="s0">* Returns the particular GraphicsStateGuardian that this object will attempt</span>
 <span class="s0">* to optimize to.  See set_gsg().</span>
 <span class="s0">*/ 1 4 this 3 4099  </span>
<span class="s0">1812 0 0 4 2006 3812 0 0 413 /**</span>
 <span class="s0">* Specifies the radius that is used in conjunction with CS_within_radius to</span>
 <span class="s0">* decide whether a subgraph's siblings should be combined into a single node</span>
 <span class="s0">* or not.</span>
 <span class="s0">*</span>
 <span class="s0">* If the CS_within_radius bit is included in the combine_siblings_bits</span>
 <span class="s0">* parameter passed to flatten, than any nodes whose bounding volume is</span>
 <span class="s0">* smaller than the indicated radius will be combined together (as if CS_other</span>
 <span class="s0">* were set).</span>
 <span class="s0">*/ 2 4 this 3 4098  14 combine_radius 1 3598  </span>
<span class="s0">1813 0 0 6 2007 3598 0 0 110 /**</span>
 <span class="s0">* Returns the radius that is used in conjunction with CS_within_radius.  See</span>
 <span class="s0">* set_combine_radius().</span>
 <span class="s0">*/ 1 4 this 3 4099  </span>
<span class="s0">1814 0 0 4 2008 3812 0 0 245 /**</span>
 <span class="s0">* This flavor of apply_attribs() can be called recursively from within</span>
 <span class="s0">* another flatten process (e.g.  from</span>
 <span class="s0">* PandaNode::apply_attribs_to_vertices()). The parameters were presumably</span>
 <span class="s0">* received from a parent SceneGraphReducer object.</span>
 <span class="s0">*/ 5 4 this 3 4098  4 node 1 3650  7 attribs 1 4101  12 attrib_types 1 3593  11 transformer 1 4104  </span>
<span class="s0">1815 0 0 4 2008 3812 0 0 509 /**</span>
 <span class="s0">* Walks the scene graph, accumulating attribs of the indicated types,</span>
 <span class="s0">* applying them to the vertices, and removing them from the scene graph.</span>
 <span class="s0">* This has a performance optimization benefit in itself, but is especially</span>
 <span class="s0">* useful to pave the way for a call to flatten() and greatly improve the</span>
 <span class="s0">* effectiveness of the flattening operation.</span>
 <span class="s0">*</span>
 <span class="s0">* Multiply instanced geometry is duplicated before the attribs are applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Of course, this operation does make certain dynamic operations impossible.</span>
 <span class="s0">*/ 3 4 this 3 4098  4 node 1 3650  12 attrib_types 5 3593  </span>
<span class="s0">1816 0 0 6 2009 3593 0 0 559 /**</span>
 <span class="s0">* Simplifies the graph by removing unnecessary nodes and nodes.</span>
 <span class="s0">*</span>
 <span class="s0">* In general, a node (and its parent node) is a candidate for removal if the</span>
 <span class="s0">* node has no siblings and the node has no special properties.</span>
 <span class="s0">*</span>
 <span class="s0">* If combine_siblings_bits is nonzero, some sibling nodes (according to the</span>
 <span class="s0">* bits set in combine_siblings_bits) may also be collapsed into a single</span>
 <span class="s0">* node.  This will further reduce scene graph complexity, sometimes</span>
 <span class="s0">* substantially, at the cost of reduced spatial separation.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the number of nodes removed from the graph.</span>
 <span class="s0">*/ 3 4 this 3 4098  4 root 1 3650  21 combine_siblings_bits 1 3593  </span>
<span class="s0">1817 0 0 6 2010 3593 0 0 154 /**</span>
 <span class="s0">* Removes the indicated data column from any GeomVertexDatas found at the</span>
 <span class="s0">* indicated root and below.  Returns the number of GeomNodes modified.</span>
 <span class="s0">*/ 3 4 this 3 4098  4 root 1 3650  6 column 1 3873  </span>
<span class="s0">1818 0 0 6 2011 3593 0 0 254 /**</span>
 <span class="s0">* Searches for GeomNodes that contain multiple Geoms that differ only in</span>
 <span class="s0">* their ColorAttribs.  If such a GeomNode is found, then all the colors are</span>
 <span class="s0">* pushed down into the vertices.  This makes it feasible for the geoms to be</span>
 <span class="s0">* unified later.</span>
 <span class="s0">*/ 2 4 this 3 4098  4 root 1 3650  </span>
<span class="s0">1819 0 0 6 2012 3593 0 0 715 /**</span>
 <span class="s0">* Walks through the tree at this node and below and unifies the</span>
 <span class="s0">* GeomVertexFormat for any GeomVertexData objects that are found, so that all</span>
 <span class="s0">* eligible vdatas (according to collect_bits; see collect_vertex_data) will</span>
 <span class="s0">* share the same vertex format.</span>
 <span class="s0">*</span>
 <span class="s0">* This will add unused columns where necessary to match formats.  It can</span>
 <span class="s0">* result in suboptimal performance if used needlessly.</span>
 <span class="s0">*</span>
 <span class="s0">* There is usually no reason to call this explicitly, since</span>
 <span class="s0">* collect_vertex_data() will do this anyway if it has not been done already.</span>
 <span class="s0">* However, calling it ahead of time can make that future call to</span>
 <span class="s0">* collect_vertex_data() run a little bit faster.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is the number of vertex datas modified.</span>
 <span class="s0">*/ 3 4 this 3 4098  4 root 1 3650  12 collect_bits 5 3593  </span>
<span class="s0">1820 0 0 4 2013 3812 0 0 396 /**</span>
 <span class="s0">* Calls decompose() on every GeomNode at this level and below.</span>
 <span class="s0">*</span>
 <span class="s0">* There is usually no reason to call this explicitly, since unify() will do</span>
 <span class="s0">* this anyway if it needs to be done.  However, calling it ahead of time can</span>
 <span class="s0">* make that future call to unify() run a little bit faster.</span>
 <span class="s0">*</span>
 <span class="s0">* This operation has no effect if the config variable preserve-triangle-</span>
 <span class="s0">* strips has been set true.</span>
 <span class="s0">*/ 2 4 this 3 4098  4 root 1 3650  </span>
<span class="s0">1821 0 0 6 2014 3593 0 0 579 /**</span>
 <span class="s0">* Collects all different GeomVertexData blocks that have compatible formats</span>
 <span class="s0">* at this node and below into a single, unified block (or at least multiple</span>
 <span class="s0">* larger blocks).  This is intended to reduce rendering overhead incurred by</span>
 <span class="s0">* switching vertex buffers.  It can also make a subsequent call to unify()</span>
 <span class="s0">* much more effective than it would have been otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* The set of bits passed in collect_bits indicates which properties are used</span>
 <span class="s0">* to differentiate GeomVertexData blocks.  If it is 0, then more blocks will</span>
 <span class="s0">* be combined together than if it is nonzero.</span>
 <span class="s0">*/ 3 4 this 3 4098  4 root 1 3650  12 collect_bits 5 3593  </span>
<span class="s0">1822 0 0 6 2015 3593 0 0 308 /**</span>
 <span class="s0">* Converts indexed geometry to nonindexed geometry at the indicated node and</span>
 <span class="s0">* below, by duplicating vertices where necessary.  The parameter</span>
 <span class="s0">* nonindexed_bits is a union of bits defined in</span>
 <span class="s0">* SceneGraphReducer::MakeNonindexed, which specifes which types of geometry</span>
 <span class="s0">* to avoid making nonindexed.</span>
 <span class="s0">*/ 3 4 this 3 4098  4 root 1 3650  15 nonindexed_bits 5 3593  </span>
<span class="s0">1823 0 0 4 2016 3812 0 0 224 /**</span>
 <span class="s0">* Calls unify() on every GeomNode at this level and below.  This attempts to</span>
 <span class="s0">* reduce the total number of individual Geoms and GeomPrimitives by combining</span>
 <span class="s0">* these objects wherever possible.  See GeomNode::unify().</span>
 <span class="s0">*/ 3 4 this 3 4098  4 root 1 3650  14 preserve_order 1 3600  </span>
<span class="s0">1824 0 0 4 2017 3812 0 0 273 /**</span>
 <span class="s0">* Removes any vertices in GeomVertexDatas that are no longer used at this</span>
 <span class="s0">* level and below.  This requires remapping vertex indices in all of the</span>
 <span class="s0">* GeomPrimitives, to remove holes in the GeomVertexDatas.  It is normally not</span>
 <span class="s0">* necessary to call this explicitly.</span>
 <span class="s0">*/ 2 4 this 3 4098  4 root 1 3650  </span>
<span class="s0">1825 0 0 4 2018 3812 0 0 320 /**</span>
 <span class="s0">* Walks the scene graph rooted at this node and below, and uses the indicated</span>
 <span class="s0">* GSG to premunge every Geom found to optimize it for eventual rendering on</span>
 <span class="s0">* the indicated GSG.  If there is no GSG indicated for the SceneGraphReducer,</span>
 <span class="s0">* this is a no-op.</span>
 <span class="s0">*</span>
 <span class="s0">* This operation will also apply to stashed children.</span>
 <span class="s0">*/ 3 4 this 3 4098  4 root 1 3650  13 initial_state 1 3825  </span>
<span class="s0">1826 0 0 6 2019 3600 0 0 359 /**</span>
 <span class="s0">* In a non-release build, returns false if the node is correctly not in a</span>
 <span class="s0">* live scene graph.  (Calling flatten on a node that is part of a live scene</span>
 <span class="s0">* graph, for instance, a node somewhere under render, can cause problems in a</span>
 <span class="s0">* multithreaded environment.)</span>
 <span class="s0">*</span>
 <span class="s0">* If allow_live_flatten is true, or in a release build, this always returns</span>
 <span class="s0">* true.</span>
 <span class="s0">*/ 2 4 this 3 4098  4 node 1 3650  </span>
<span class="s0">1827 0 0 23 2024 4106 3516 0 74 /**</span>
 <span class="s0">* Creates a new ParamNodePath storing the given node path object.</span>
 <span class="s0">*/ 1 9 node_path 1 3884  </span>
<span class="s0">1828 0 0 6 2025 3884 0 0 58 /**</span>
 <span class="s0">* Retrieves the NodePath stored in the parameter.</span>
 <span class="s0">*/ 1 4 this 3 4107  </span>
<span class="s0">1829 0 0 7 2026 3816 0 0 0 0 </span>
<span class="s0">1830 0 0 7 2029 4109 2131 0 222 /**</span>
 <span class="s0">* Default constructor, just an empty node, no geo This is used to read portal</span>
 <span class="s0">* from model.  You can also use this from python to create an empty portal.</span>
 <span class="s0">* Then you can set the vertices yourself, with addVertex.</span>
 <span class="s0">*/ 1 4 name 1 3841  </span>
<span class="s0">1831 0 0 7 2029 4109 2131 0 113 /**</span>
 <span class="s0">* Create a default rectangle as portal.  Use this to create an arbitrary</span>
 <span class="s0">* portal and setup from Python</span>
 <span class="s0">*/ 3 4 name 1 3841  3 pos 1 3896  5 scale 5 3598  </span>
<span class="s0">1832 0 0 4 2030 3812 0 0 97 /**</span>
 <span class="s0">* Simultaneously sets both the &quot;from&quot; and &quot;into&quot; PortalMask values to the</span>
 <span class="s0">* same thing.</span>
 <span class="s0">*/ 2 4 this 3 4109  4 mask 1 4110  </span>
<span class="s0">1833 0 0 4 2031 3812 0 0 218 /**</span>
 <span class="s0">* Sets the &quot;from&quot; PortalMask.  In order for a portal to be detected from this</span>
 <span class="s0">* object into another object, the intersection of this object's &quot;from&quot; mask</span>
 <span class="s0">* and the other object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/ 2 4 this 3 4109  4 mask 1 4110  </span>
<span class="s0">1834 0 0 4 2032 3812 0 0 218 /**</span>
 <span class="s0">* Sets the &quot;into&quot; PortalMask.  In order for a portal to be detected from</span>
 <span class="s0">* another object into this object, the intersection of the other object's</span>
 <span class="s0">* &quot;from&quot; mask and this object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/ 2 4 this 3 4109  4 mask 1 4110  </span>
<span class="s0">1835 0 0 7 2033 4110 0 0 229 /**</span>
 <span class="s0">* Returns the current &quot;from&quot; PortalMask.  In order for a portal to be</span>
 <span class="s0">* detected from this object into another object, the intersection of this</span>
 <span class="s0">* object's &quot;from&quot; mask and the other object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/ 1 4 this 3 4111  </span>
<span class="s0">1836 0 0 7 2034 4110 0 0 229 /**</span>
 <span class="s0">* Returns the current &quot;into&quot; PortalMask.  In order for a portal to be</span>
 <span class="s0">* detected from another object into this object, the intersection of the</span>
 <span class="s0">* other object's &quot;from&quot; mask and this object's &quot;into&quot; mask must be nonzero.</span>
 <span class="s0">*/ 1 4 this 3 4111  </span>
<span class="s0">1837 0 0 4 2035 3812 0 0 496 /**</span>
 <span class="s0">* Sets the state of the &quot;portal geom&quot; flag for this PortalNode.  Normally,</span>
 <span class="s0">* this is false; when this is set true, the PortalSolids in this node will</span>
 <span class="s0">* test for portals with actual renderable geometry, in addition to whatever</span>
 <span class="s0">* PortalSolids may be indicated by the from_portal_mask.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this to true causes this to test *all* GeomNodes for portals.  It</span>
 <span class="s0">* is an all-or-none thing; there is no way to portal with only some</span>
 <span class="s0">* GeomNodes, as GeomNodes have no into_portal_mask.</span>
 <span class="s0">*/ 2 4 this 3 4109  4 flag 1 3600  </span>
<span class="s0">1838 0 0 6 2036 3600 0 0 85 /**</span>
 <span class="s0">* Returns the current state of the portal_geom flag.  See set_portal_geom().</span>
 <span class="s0">*/ 1 4 this 3 4111  </span>
<span class="s0">1839 0 0 4 2037 3812 0 0 63 /**</span>
 <span class="s0">* Resets the vertices of the portal to the empty list.</span>
 <span class="s0">*/ 1 4 this 3 4109  </span>
<span class="s0">1840 0 0 4 2038 3812 0 0 153 /**</span>
 <span class="s0">* Adds a new vertex to the portal polygon.  The vertices should be defined in</span>
 <span class="s0">* a counterclockwise orientation when viewing through the portal.</span>
 <span class="s0">*/ 2 4 this 3 4109  6 vertex 1 3809  </span>
<span class="s0">1841 0 0 6 2039 3593 0 0 64 /**</span>
 <span class="s0">* Returns the number of vertices in the portal polygon.</span>
 <span class="s0">*/ 1 4 this 3 4111  </span>
<span class="s0">1842 0 0 6 2040 3809 0 0 56 /**</span>
 <span class="s0">* Returns the nth vertex of the portal polygon.</span>
 <span class="s0">*/ 2 4 this 3 4111  1 n 1 3593  </span>
<span class="s0">1843 0 0 4 2042 3812 0 0 52 /**</span>
 <span class="s0">* Sets the cell that this portal belongs to</span>
 <span class="s0">*/ 2 4 this 3 4109  4 cell 1 3884  </span>
<span class="s0">1844 0 0 7 2043 3894 2739 0 52 /**</span>
 <span class="s0">* Sets the cell that this portal belongs to</span>
 <span class="s0">*/ 1 4 this 3 4111  </span>
<span class="s0">1845 0 0 4 2044 3812 0 0 54 /**</span>
 <span class="s0">* Sets the cell that this portal leads out to</span>
 <span class="s0">*/ 2 4 this 3 4109  4 cell 1 3884  </span>
<span class="s0">1846 0 0 7 2045 3894 2739 0 54 /**</span>
 <span class="s0">* Sets the cell that this portal leads out to</span>
 <span class="s0">*/ 1 4 this 3 4111  </span>
<span class="s0">1847 0 0 4 2046 3812 0 0 80 /**</span>
 <span class="s0">* this is set if the portal will clip against its left and right planes</span>
 <span class="s0">*/ 2 4 this 3 4109  5 value 1 3600  </span>
<span class="s0">1848 0 0 6 2047 3600 0 0 64 /**</span>
 <span class="s0">* Is this portal clipping against its left-right planes</span>
 <span class="s0">*/ 1 4 this 3 4109  </span>
<span class="s0">1849 0 0 4 2048 3812 0 0 53 /**</span>
 <span class="s0">* this is set if the portal is facing camera</span>
 <span class="s0">*/ 2 4 this 3 4109  5 value 1 3600  </span>
<span class="s0">1850 0 0 6 2049 3600 0 0 43 /**</span>
 <span class="s0">* Is this portal facing the camera</span>
 <span class="s0">*/ 1 4 this 3 4109  </span>
<span class="s0">1851 0 0 4 2050 3812 0 0 63 /**</span>
 <span class="s0">* Set the maximum depth this portal will be visible at</span>
 <span class="s0">*/ 2 4 this 3 4109  5 value 1 3593  </span>
<span class="s0">1852 0 0 6 2051 3593 0 0 67 /**</span>
 <span class="s0">* Returns the maximum depth this portal will be visible at</span>
 <span class="s0">*/ 1 4 this 3 4109  </span>
<span class="s0">1853 0 0 4 2052 3812 0 0 55 /**</span>
 <span class="s0">* Python sets this based on curent camera zone</span>
 <span class="s0">*/ 2 4 this 3 4109  5 value 1 3600  </span>
<span class="s0">1854 0 0 6 2053 3600 0 0 55 /**</span>
 <span class="s0">* Is this portal open from current camera zone</span>
 <span class="s0">*/ 1 4 this 3 4109  </span>
<span class="s0">1855 0 0 7 2065 3816 0 0 0 0 </span>
<span class="s0">1856 0 0 7 2067 3607 0 0 112 /**</span>
 <span class="s0">* Constructs a new ScissorAttrib object that removes the scissor region and</span>
 <span class="s0">* fills the DisplayRegion.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1857 0 0 23 2068 3607 0 0 216 /**</span>
 <span class="s0">* Constructs a ScissorAttrib that restricts rendering to the indicated frame</span>
 <span class="s0">* within the current DisplayRegion.  (0,0) is the lower-left corner of the</span>
 <span class="s0">* DisplayRegion, and (1,1) is the upper-right corner.</span>
 <span class="s0">*/ 1 5 frame 1 3880  </span>
<span class="s0">1858 0 0 23 2068 3607 0 0 216 /**</span>
 <span class="s0">* Constructs a ScissorAttrib that restricts rendering to the indicated frame</span>
 <span class="s0">* within the current DisplayRegion.  (0,0) is the lower-left corner of the</span>
 <span class="s0">* DisplayRegion, and (1,1) is the upper-right corner.</span>
 <span class="s0">*/ 4 4 left 1 3598  5 right 1 3598  6 bottom 1 3598  3 top 1 3598  </span>
<span class="s0">1859 0 0 7 2069 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1860 0 0 6 2070 3600 0 0 119 /**</span>
 <span class="s0">* Returns true if the ScissorAttrib is an 'off' ScissorAttrib, indicating</span>
 <span class="s0">* that scissor testing is disabled.</span>
 <span class="s0">*/ 1 4 this 3 4113  </span>
<span class="s0">1861 0 0 6 2071 3880 0 0 234 /**</span>
 <span class="s0">* Returns the left, right, bottom, top coordinates of the scissor frame.</span>
 <span class="s0">* This defines a frame within the current DisplayRegion, where 0,0 is the</span>
 <span class="s0">* lower-left corner of the DisplayRegion, and 1,1 is the upper-right corner.</span>
 <span class="s0">*/ 1 4 this 3 4113  </span>
<span class="s0">1862 0 0 6 2073 3593 0 0 0 0 </span>
<span class="s0">1863 0 0 7 2075 3816 0 0 0 0 </span>
<span class="s0">1864 0 0 23 2079 3607 0 0 149 /**</span>
 <span class="s0">* Constructs a new ShadeModelAttrib object that specifies whether to draw</span>
 <span class="s0">* polygons with flat shading or with per-vertex (smooth) shading.</span>
 <span class="s0">*/ 1 4 mode 1 3788  </span>
<span class="s0">1865 0 0 7 2080 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1866 0 0 6 2081 3788 0 0 34 /**</span>
 <span class="s0">* Returns the shade mode.</span>
 <span class="s0">*/ 1 4 this 3 4115  </span>
<span class="s0">1867 0 0 6 2083 3593 0 0 0 0 </span>
<span class="s0">1868 0 0 7 2085 3816 0 0 0 0 </span>
<span class="s0">1869 0 0 7 2091 3607 0 0 69 /**</span>
 <span class="s0">* Constructs a StencilAttrib that has stenciling turned off.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1870 0 0 7 2092 3607 0 0 145 /**</span>
 <span class="s0">* Returns a RenderAttrib that corresponds to whatever the standard default</span>
 <span class="s0">* properties for render attributes of this type ought to be.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1871 0 0 23 2093 3607 0 0 49 /**</span>
 <span class="s0">* Constructs a front face StencilAttrib.</span>
 <span class="s0">*/ 8 12 front_enable 1 3600  25 front_comparison_function 1 3594  22 stencil_fail_operation 1 3792  29 stencil_pass_z_fail_operation 1 3792  35 front_stencil_pass_z_pass_operation 1 3792  9 reference 1 3692  9 read_mask 1 3692  10 write_mask 5 3692  </span>
<span class="s0">1872 0 0 7 2094 3607 0 0 48 /**</span>
 <span class="s0">* Constructs a two-sided StencilAttrib.</span>
 <span class="s0">*/ 13 12 front_enable 1 3600  11 back_enable 1 3600  25 front_comparison_function 1 3594  22 stencil_fail_operation 1 3792  29 stencil_pass_z_fail_operation 1 3792  35 front_stencil_pass_z_pass_operation 1 3792  9 reference 1 3692  9 read_mask 1 3692  10 write_mask 1 3692  24 back_comparison_function 1 3594  27 back_stencil_fail_operation 1 3792  34 back_stencil_pass_z_fail_operation 1 3792  34 back_stencil_pass_z_pass_operation 1 3792  </span>
<span class="s0">1873 0 0 7 2095 3607 0 0 49 /**</span>
 <span class="s0">* Constructs a front face StencilAttrib.</span>
 <span class="s0">*/ 10 12 front_enable 1 3600  25 front_comparison_function 1 3594  22 stencil_fail_operation 1 3792  29 stencil_pass_z_fail_operation 1 3792  35 front_stencil_pass_z_pass_operation 1 3792  9 reference 1 3692  9 read_mask 1 3692  10 write_mask 1 3692  5 clear 1 3600  11 clear_value 1 3692  </span>
<span class="s0">1874 0 0 7 2096 3607 0 0 48 /**</span>
 <span class="s0">* Constructs a two-sided StencilAttrib.</span>
 <span class="s0">*/ 15 12 front_enable 1 3600  11 back_enable 1 3600  25 front_comparison_function 1 3594  22 stencil_fail_operation 1 3792  29 stencil_pass_z_fail_operation 1 3792  35 front_stencil_pass_z_pass_operation 1 3792  9 reference 1 3692  9 read_mask 1 3692  10 write_mask 1 3692  24 back_comparison_function 1 3594  27 back_stencil_fail_operation 1 3792  34 back_stencil_pass_z_fail_operation 1 3792  34 back_stencil_pass_z_pass_operation 1 3792  5 clear 1 3600  11 clear_value 1 3692  </span>
<span class="s0">1875 0 0 6 2097 3692 0 0 32 /**</span>
 <span class="s0">* Returns render state.</span>
 <span class="s0">*/ 2 4 this 3 4117  23 render_state_identifier 1 3790  </span>
<span class="s0">1876 0 0 6 2098 3593 0 0 0 0 </span>
<span class="s0">1877 0 0 7 2100 3816 0 0 0 0 </span>
<span class="s0">1878 0 0 6 2103 3600 0 0 76 /**</span>
 <span class="s0">* Returns true if the shader has ever been loaded, false otherwise.</span>
 <span class="s0">*/ 1 8 filename 1 3920  </span>
<span class="s0">1879 0 0 6 2104 3600 0 0 306 /**</span>
 <span class="s0">* Loads the given filename up into a shader, if it has not already been</span>
 <span class="s0">* loaded, and returns true to indicate success, or false to indicate failure.</span>
 <span class="s0">* If this returns true, it is guaranteed that a subsequent call to</span>
 <span class="s0">* load_shader() with the same shader name will return a valid Shader pointer.</span>
 <span class="s0">*/ 1 8 filename 1 3920  </span>
<span class="s0">1880 0 0 7 2105 3771 0 0 261 /**</span>
 <span class="s0">* Loads the given filename up into a shader, if it has not already been</span>
 <span class="s0">* loaded, and returns the new shader.  If a shader with the same filename was</span>
 <span class="s0">* previously loaded, returns that one instead.  If the shader file cannot be</span>
 <span class="s0">* found, returns NULL.</span>
 <span class="s0">*/ 1 8 filename 1 3920  </span>
<span class="s0">1881 0 0 4 2106 3812 0 0 171 /**</span>
 <span class="s0">* Adds the indicated already-loaded shader to the pool.  The shader will</span>
 <span class="s0">* always replace any previously-loaded shader in the pool that had the same</span>
 <span class="s0">* filename.</span>
 <span class="s0">*/ 2 8 filename 1 3920  6 shader 1 4119  </span>
<span class="s0">1882 0 0 4 2107 3812 0 0 270 /**</span>
 <span class="s0">* Removes the indicated shader from the pool, indicating it will never be</span>
 <span class="s0">* loaded again; the shader may then be freed.  If this function is never</span>
 <span class="s0">* called, a reference count will be maintained on every shader every loaded,</span>
 <span class="s0">* and shaders will never be freed.</span>
 <span class="s0">*/ 1 8 filename 1 3920  </span>
<span class="s0">1883 0 0 4 2108 3812 0 0 85 /**</span>
 <span class="s0">* Releases all shaders in the pool and restores the pool to the empty state.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1884 0 0 6 2109 3593 0 0 209 /**</span>
 <span class="s0">* Releases only those shaders in the pool that have a reference count of</span>
 <span class="s0">* exactly 1; i.e.  only those shaders that are not being used outside of the</span>
 <span class="s0">* pool.  Returns the number of shaders released.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">1885 0 0 4 2110 3812 0 0 80 /**</span>
 <span class="s0">* Lists the contents of the shader pool to the indicated output stream.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">1886 0 0 4 2111 3812 0 0 80 /**</span>
 <span class="s0">* Lists the contents of the shader pool to the indicated output stream.</span>
 <span class="s0">*/ 1 3 out 1 3813  </span>
<span class="s0">1887 0 0 7 2020 3894 2739 0 0 1 4 data 1 3858  </span>
<span class="s0">1888 0 0 7 2021 3894 2739 0 0 2 9 unpickler 1 3623  4 data 1 3858  </span>
<span class="s0">544</span>
<span class="s0">3576 14 TransformState 0 16852993 14 TransformState 14 TransformState 0 0 0 0 0 7 4120 4121 4122 4123 4124 4125 4126 97 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 0 0 1 0 3577 0 0 0 0 734</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates a coordinate-system transform on vertices.  TransformStates are</span>
 <span class="s0">* the primary means for storing transformations on the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* Transforms may be specified in one of two ways: componentwise, with a pos-</span>
 <span class="s0">* hpr-scale, or with an arbitrary transform matrix.  If you specify a</span>
 <span class="s0">* transform componentwise, it will remember its original components.</span>
 <span class="s0">*</span>
 <span class="s0">* TransformState objects are managed very much like RenderState objects.</span>
 <span class="s0">* They are immutable and reference-counted automatically.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a TransformState object</span>
 <span class="s0">* directly.  Instead, call one of the make() functions to create one for you.</span>
 <span class="s0">* And instead of modifying a TransformState object, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">3577 24 NodeCachedReferenceCount 0 2048 24 NodeCachedReferenceCount 24 NodeCachedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 1495</span>
<span class="s0">/**</span>
 <span class="s0">* This class further specializes CachedTypedWritableReferenceCount to also</span>
 <span class="s0">* add a node_ref_count, for the purposes of counting the number of times the</span>
 <span class="s0">* object is referenced by a &quot;node&quot;, presumably a PandaNode.</span>
 <span class="s0">*</span>
 <span class="s0">* This essentially combines the functionality of NodeReferenceCount and</span>
 <span class="s0">* CachedTypedWritableReferenceCount, so that a derivative of this object</span>
 <span class="s0">* actually has three counters: the standard reference count, the &quot;cache&quot;</span>
 <span class="s0">* reference count, and the &quot;node&quot; reference count.  Rather than multiply</span>
 <span class="s0">* inheriting from the two reference count classes, we inherit only from</span>
 <span class="s0">* CachedTypedWritableReferenceCount and simply duplicate the functionality of</span>
 <span class="s0">* NodeReferenceCount, to avoid all of the problems associated with multiple</span>
 <span class="s0">* inheritance.</span>
 <span class="s0">*</span>
 <span class="s0">* The intended design is to use this as a base class for RenderState and</span>
 <span class="s0">* TransformState, both of which are held by PandaNodes, and also have caches</span>
 <span class="s0">* which are independently maintained.  By keeping track of how many nodes</span>
 <span class="s0">* hold a pointer to a particular object, we can classify each object into</span>
 <span class="s0">* node-referenced, cache-referenced, or other, which is primarily useful for</span>
 <span class="s0">* PStats reporting.</span>
 <span class="s0">*</span>
 <span class="s0">* As with CachedTypedWritableReferenceCount's cache_ref() and cache_unref(),</span>
 <span class="s0">* the new methods node_ref() and node_unref() automatically increment and</span>
 <span class="s0">* decrement the primary reference count as well.  In this case, however,</span>
 <span class="s0">* there does exist a NodePointerTo&lt;&gt; class to maintain the node_ref counters</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*/</span>

<span class="s0">3578 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 3579 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3579 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 3580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3580 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3581 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 3582 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3582 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 3583 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3583 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3584 17 LQuaternion const 0 8832 17 LQuaternion const 17 LQuaternion const 0 0 3585 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3585 11 LQuaternion 0 2105344 11 LQuaternion 11 LQuaternion 0 0 3586 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3586 12 LQuaternionf 0 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 0 44</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base quaternion class</span>
 <span class="s0">*/</span>

<span class="s0">3587 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 3588 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3588 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 3589 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3589 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3590 20 RenderAttribRegistry 0 43009 20 RenderAttribRegistry 20 RenderAttribRegistry 0 0 0 0 0 0 10 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 0 0 0 0 0 212</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used to associate each RenderAttrib with a different slot</span>
 <span class="s0">* index at runtime, so we can store a list of RenderAttribs in the</span>
 <span class="s0">* RenderState object, and very quickly look them up by type.</span>
 <span class="s0">*/</span>

<span class="s0">3591 12 RenderAttrib 0 75777 12 RenderAttrib 12 RenderAttrib 0 0 0 0 0 1 4127 14 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 0 0 1 0 3592 0 0 0 2 3594 3595 1074</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for a number of render attributes (other than</span>
 <span class="s0">* transform) that may be set on scene graph nodes to control the appearance</span>
 <span class="s0">* of geometry.  This includes TextureAttrib, ColorAttrib, etc.</span>
 <span class="s0">*</span>
 <span class="s0">* RenderAttrib represents render attributes that always propagate down to the</span>
 <span class="s0">* leaves without regard to the particular node they are assigned to.  A</span>
 <span class="s0">* RenderAttrib will have the same effect on a leaf node whether it is</span>
 <span class="s0">* assigned to the graph at the leaf or several nodes above.  This is</span>
 <span class="s0">* different from RenderEffect, which represents a particular render property</span>
 <span class="s0">* that is applied immediately to the node on which it is encountered, like</span>
 <span class="s0">* billboarding or decaling.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a RenderAttrib directly;</span>
 <span class="s0">* instead, use the make() method of the appropriate kind of attrib you want.</span>
 <span class="s0">* This will allocate and return a new RenderAttrib of the appropriate type,</span>
 <span class="s0">* and it may share pointers if possible.  Do not modify the new RenderAttrib</span>
 <span class="s0">* if you wish to change its properties; instead, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">3592 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedWritable and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedWritables and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">3593 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3594 16 PandaCompareFunc 0 794624 30 RenderAttrib::PandaCompareFunc 30 RenderAttrib::PandaCompareFunc 3591 0 0 0 0 0 0 0 0 0 9 6 M_none 20 RenderAttrib::M_none 36</span>
<span class="s0">// alpha-test disabled (always-draw)</span>
<span class="s0">0 7 M_never 21 RenderAttrib::M_never 14</span>
<span class="s0">// Never draw.</span>
<span class="s0">1 6 M_less 20 RenderAttrib::M_less 29</span>
<span class="s0">// incoming &lt; reference_alpha</span>
<span class="s0">2 7 M_equal 21 RenderAttrib::M_equal 30</span>
<span class="s0">// incoming == reference_alpha</span>
<span class="s0">3 12 M_less_equal 26 RenderAttrib::M_less_equal 30</span>
<span class="s0">// incoming &lt;= reference_alpha</span>
<span class="s0">4 9 M_greater 23 RenderAttrib::M_greater 29</span>
<span class="s0">// incoming &gt; reference_alpha</span>
<span class="s0">5 11 M_not_equal 25 RenderAttrib::M_not_equal 30</span>
<span class="s0">// incoming != reference_alpha</span>
<span class="s0">6 15 M_greater_equal 29 RenderAttrib::M_greater_equal 30</span>
<span class="s0">// incoming &gt;= reference_alpha</span>
<span class="s0">7 8 M_always 22 RenderAttrib::M_always 15</span>
<span class="s0">// Always draw.</span>
<span class="s0">8 0 44</span>
<span class="s0">// intentionally defined to match D3DCMPFUNC</span>

<span class="s0">3595 10 TexGenMode 0 794624 24 RenderAttrib::TexGenMode 24 RenderAttrib::TexGenMode 3591 0 0 0 0 0 0 0 0 0 12 5 M_off 19 RenderAttrib::M_off 0</span>
<span class="s0">0 16 M_eye_sphere_map 30 RenderAttrib::M_eye_sphere_map 210</span>
<span class="s0">// Sphere maps are classic static reflection maps.  They are supported on</span>
<span class="s0">// just about any hardware, and require a precomputed 360-degree fisheye</span>
<span class="s0">// image.  Sphere maps only make sense in eye coordinate space.</span>
<span class="s0">1 16 M_world_cube_map 30 RenderAttrib::M_world_cube_map 439</span>
<span class="s0">/*</span>
 <span class="s0">* Cube maps are a modern improvement on the sphere map; they don't suffer</span>
 <span class="s0">* from any polar singularities, but they require six texture images.  They</span>
 <span class="s0">* can also be generated dynamically for real-time reflections (see</span>
 <span class="s0">* GraphicsOutput::make_cube_map()). Typically, a statically-generated cube</span>
 <span class="s0">* map will be in eye space, while a dynamically-generated map will be in</span>
 <span class="s0">* world space.  Cube mapping is not supported on all hardware.</span>
 <span class="s0">*/</span>
<span class="s0">2 14 M_eye_cube_map 28 RenderAttrib::M_eye_cube_map 0</span>
<span class="s0">3 14 M_world_normal 28 RenderAttrib::M_world_normal 100</span>
<span class="s0">// Normal maps are most useful for applying diffuse lighting effects via a</span>
<span class="s0">// pregenerated cube map.</span>
<span class="s0">4 12 M_eye_normal 26 RenderAttrib::M_eye_normal 0</span>
<span class="s0">5 16 M_world_position 30 RenderAttrib::M_world_position 180</span>
<span class="s0">// Position maps convert XYZ coordinates directly to texture coordinates.</span>
<span class="s0">// This is particularly useful for implementing projective texturing (see</span>
<span class="s0">// NodePath::project_texture()).</span>
<span class="s0">6 8 M_unused 22 RenderAttrib::M_unused 46</span>
<span class="s0">// formerly M_object_position, now deprecated.</span>
<span class="s0">7 14 M_eye_position 28 RenderAttrib::M_eye_position 0</span>
<span class="s0">8 14 M_point_sprite 28 RenderAttrib::M_point_sprite 683</span>
<span class="s0">/*</span>
 <span class="s0">* With M_point_sprite, texture coordinates will be generated for large points</span>
 <span class="s0">* in the range (0,0) - (1,1) from upper-left to lower-right across the</span>
 <span class="s0">* point's face.  Without this, each point will have just a single uniform</span>
 <span class="s0">* texture coordinate value across its face.  Unfortunately, the generated</span>
 <span class="s0">* texture coordinates are inverted (upside-down) from Panda's usual</span>
 <span class="s0">* convention, but this is what the graphics card manufacturers decided to</span>
 <span class="s0">* use.  You could use a texture matrix to re-invert the texture, but that</span>
 <span class="s0">* will probably force the sprites' vertices to be computed in the CPU. You'll</span>
 <span class="s0">* have to paint your textures upside-down if you want true hardware sprites.</span>
 <span class="s0">*/</span>
<span class="s0">9 9 M_unused2 23 RenderAttrib::M_unused2 324</span>
<span class="s0">// M_light_vector generated special 3-d texture coordinates that</span>
<span class="s0">// represented the vector to a particular Light in the scene graph,</span>
<span class="s0">// expressed in each vertex's tangent space.  This has now been removed.</span>
<span class="s0">// We need to reserve the slot in the enum, though, to make sure the</span>
<span class="s0">// following enum value still has the same value.</span>
<span class="s0">10 10 M_constant 24 RenderAttrib::M_constant 193</span>
<span class="s0">// M_constant generates the same fixed texture coordinates at each vertex.</span>
<span class="s0">// Not terribly useful, of course, except for certain special effects</span>
<span class="s0">// involving moving a flat color over an object.</span>
<span class="s0">11 0 179</span>
<span class="s0">// This is the enumerated type for TexGenAttrib.  It is inherited into</span>
<span class="s0">// TexGenAttrib.  It is defined up at this level only to avoid circular</span>
<span class="s0">// dependencies in the header files.</span>

<span class="s0">3596 16 RenderModeAttrib 0 141313 16 RenderModeAttrib 16 RenderModeAttrib 0 0 0 0 2019 5 4128 4129 4130 4131 4132 9 2010 2011 2012 2013 2014 2015 2016 2017 2018 0 0 1 0 3591 0 0 0 1 3597 50</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies how polygons are to be drawn.</span>
 <span class="s0">*/</span>

<span class="s0">3597 4 Mode 0 794624 22 RenderModeAttrib::Mode 22 RenderModeAttrib::Mode 3596 0 0 0 0 0 0 0 0 0 6 11 M_unchanged 29 RenderModeAttrib::M_unchanged 0</span>
<span class="s0">0 8 M_filled 26 RenderModeAttrib::M_filled 27</span>
<span class="s0">// Normal, filled polygons.</span>
<span class="s0">1 11 M_wireframe 29 RenderModeAttrib::M_wireframe 47</span>
<span class="s0">// Wireframe polygons, possibly with thickness.</span>
<span class="s0">2 7 M_point 25 RenderModeAttrib::M_point 80</span>
<span class="s0">// Points at vertices only, possibly with thickness andor perspective</span>
<span class="s0">// sizing.</span>
<span class="s0">3 13 M_filled_flat 31 RenderModeAttrib::M_filled_flat 152</span>
<span class="s0">// Filled polygons, without any particular emphasis on perspective</span>
<span class="s0">// correctness (a particularly useful designation for software rendering</span>
<span class="s0">// sprites).</span>
<span class="s0">4 18 M_filled_wireframe 36 RenderModeAttrib::M_filled_wireframe 94</span>
<span class="s0">// Filled polygons with wireframe rendered in front.  The wireframe is</span>
<span class="s0">// given a solid color.</span>
<span class="s0">5 0 0</span>

<span class="s0">3598 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3599 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3599 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3600 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3601 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3602 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3602 6 LColor 0 2105344 6 LColor 6 LColor 0 0 3603 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3603 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 3604 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3604 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3605 15 TexMatrixAttrib 0 75777 15 TexMatrixAttrib 15 TexMatrixAttrib 0 0 0 0 0 1 4133 14 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 1 4297 0 1 0 3591 0 0 0 0 71</span>
<span class="s0">/**</span>
 <span class="s0">* Applies a transform matrix to UV's before they are rendered.</span>
 <span class="s0">*/</span>

<span class="s0">3606 11 RenderState 0 75777 11 RenderState 11 RenderState 0 0 0 0 0 1 4134 51 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 0 0 1 0 3577 0 0 0 0 340</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a unique collection of RenderAttrib objects that correspond</span>
 <span class="s0">* to a particular renderable state.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a RenderState object directly.</span>
 <span class="s0">* Instead, call one of the make() functions to create one for you.  And</span>
 <span class="s0">* instead of modifying a RenderState object, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">3607 20 RenderAttrib const * 0 8576 20 RenderAttrib const * 20 RenderAttrib const * 0 0 3608 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3608 18 RenderAttrib const 0 8832 18 RenderAttrib const 18 RenderAttrib const 0 0 3591 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3609 15 AlphaTestAttrib 0 141313 15 AlphaTestAttrib 15 AlphaTestAttrib 0 0 0 0 2091 3 4135 4136 4137 6 2085 2086 2087 2088 2089 2090 0 0 1 0 3591 0 0 0 0 126</span>
<span class="s0">/**</span>
 <span class="s0">* Enables or disables writing of pixel to framebuffer based on its alpha</span>
 <span class="s0">* value relative to a reference alpha value</span>
 <span class="s0">*/</span>

<span class="s0">3610 15 AntialiasAttrib 0 141313 15 AntialiasAttrib 15 AntialiasAttrib 0 0 0 0 2099 4 4138 4139 4140 4141 7 2092 2093 2094 2095 2096 2097 2098 0 0 1 0 3591 0 0 0 1 3611 100</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies whether or how to enable antialiasing, if supported by the</span>
 <span class="s0">* backend renderer.</span>
 <span class="s0">*/</span>

<span class="s0">3611 4 Mode 0 794624 21 AntialiasAttrib::Mode 21 AntialiasAttrib::Mode 3610 0 0 0 0 0 0 0 0 0 10 6 M_none 23 AntialiasAttrib::M_none 0</span>
<span class="s0">0 7 M_point 24 AntialiasAttrib::M_point 0</span>
<span class="s0">1 6 M_line 23 AntialiasAttrib::M_line 0</span>
<span class="s0">2 9 M_polygon 26 AntialiasAttrib::M_polygon 0</span>
<span class="s0">4 13 M_multisample 30 AntialiasAttrib::M_multisample 0</span>
<span class="s0">8 6 M_auto 23 AntialiasAttrib::M_auto 0</span>
<span class="s0">31 11 M_type_mask 28 AntialiasAttrib::M_type_mask 0</span>
<span class="s0">31 8 M_faster 25 AntialiasAttrib::M_faster 50</span>
<span class="s0">// Extra add-on bits for performancequality hints.</span>
<span class="s0">32 8 M_better 25 AntialiasAttrib::M_better 0</span>
<span class="s0">64 11 M_dont_care 28 AntialiasAttrib::M_dont_care 0</span>
<span class="s0">96 0 0</span>

<span class="s0">3612 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3613 12 RenderEffect 0 75777 12 RenderEffect 12 RenderEffect 0 0 0 0 0 0 7 2100 2101 2102 2103 2104 2105 2106 0 0 1 0 3592 0 0 0 0 901</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for a number of special render effects that may be</span>
 <span class="s0">* set on scene graph nodes to change the way they render.  This includes</span>
 <span class="s0">* BillboardEffect, DecalEffect, etc.</span>
 <span class="s0">*</span>
 <span class="s0">* RenderEffect represents render properties that must be applied as soon as</span>
 <span class="s0">* they are encountered in the scene graph, rather than propagating down to</span>
 <span class="s0">* the leaves.  This is different from RenderAttrib, which represents</span>
 <span class="s0">* properties like color and texture that don't do anything until they</span>
 <span class="s0">* propagate down to a GeomNode.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a RenderEffect directly;</span>
 <span class="s0">* instead, use the make() method of the appropriate kind of effect you want.</span>
 <span class="s0">* This will allocate and return a new RenderEffect of the appropriate type,</span>
 <span class="s0">* and it may share pointers if possible.  Do not modify the new RenderEffect</span>
 <span class="s0">* if you wish to change its properties; instead, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">3614 13 RenderEffects 0 75777 13 RenderEffects 13 RenderEffects 0 0 0 0 0 0 17 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 0 0 1 0 3592 0 0 0 0 344</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a unique collection of RenderEffect objects that correspond</span>
 <span class="s0">* to a particular renderable state.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a RenderEffects object directly.</span>
 <span class="s0">* Instead, call one of the make() functions to create one for you.  And</span>
 <span class="s0">* instead of modifying a RenderEffects object, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">3615 9 PandaNode 0 26625 9 PandaNode 9 PandaNode 0 0 0 1 2130 2131 22 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 112 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2256 3 4298 4299 4300 0 3 3 3592 2124 2125 3 3616 2126 2127 3 3617 2128 2129 0 5 3626 3634 3635 3636 3637 175</span>
<span class="s0">/**</span>
 <span class="s0">* A basic node of the scene graph or data graph.  This is the base class of</span>
 <span class="s0">* all specialized nodes, and also serves as a generic node with no special</span>
 <span class="s0">* properties.</span>
 <span class="s0">*/</span>

<span class="s0">3616 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">3617 14 LinkedListNode 0 2048 14 LinkedListNode 14 LinkedListNode 0 0 0 0 0 0 0 0 0 0 0 0 468</span>
<span class="s0">/**</span>
 <span class="s0">* This just stores the pointers to implement a doubly-linked list of some</span>
 <span class="s0">* kind of object.  There are occasions when a hand-rolled linked list is more</span>
 <span class="s0">* appropriate than an STL container.</span>
 <span class="s0">*</span>
 <span class="s0">* Typically, each node of the linked list, as well as the root of the list,</span>
 <span class="s0">* will inherit from this class.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this class is not inherently thread-safe; derived classes are</span>
 <span class="s0">* responsible for protecting any calls into it within mutexes, if necessary.</span>
 <span class="s0">*/</span>

<span class="s0">3618 29 ConstPointerTo&lt; RenderState &gt; 0 2048 29 ConstPointerTo&lt; RenderState &gt; 29 ConstPointerTo&lt; RenderState &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3619 31 ConstPointerTo&lt; RenderEffects &gt; 0 2048 31 ConstPointerTo&lt; RenderEffects &gt; 31 ConstPointerTo&lt; RenderEffects &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3620 32 ConstPointerTo&lt; TransformState &gt; 0 2048 32 ConstPointerTo&lt; TransformState &gt; 32 ConstPointerTo&lt; TransformState &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3621 6 string 0 2105344 11 std::string 11 std::string 0 0 3622 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3622 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3623 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3624 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3624 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3625 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3625 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3626 16 UnexpectedChange 0 794624 27 PandaNode::UnexpectedChange 27 PandaNode::UnexpectedChange 3615 0 0 0 0 0 0 0 0 0 5 10 UC_parents 21 PandaNode::UC_parents 0</span>
<span class="s0">1 11 UC_children 22 PandaNode::UC_children 0</span>
<span class="s0">2 12 UC_transform 23 PandaNode::UC_transform 0</span>
<span class="s0">4 8 UC_state 19 PandaNode::UC_state 0</span>
<span class="s0">8 12 UC_draw_mask 23 PandaNode::UC_draw_mask 0</span>
<span class="s0">16 0 0</span>

<span class="s0">3627 8 DrawMask 0 2105344 8 DrawMask 8 DrawMask 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3628 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 3629 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3629 23 BitMask&lt; uint32_t, 32 &gt; 0 2048 23 BitMask&lt; uint32_t, 32 &gt; 23 BitMask&lt; uint32_t, 32 &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3630 11 CollideMask 0 2105344 11 CollideMask 11 CollideMask 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3631 10 BoundsType 0 794624 26 BoundingVolume::BoundsType 26 BoundingVolume::BoundsType 3632 0 0 0 0 0 0 0 0 0 5 10 BT_default 26 BoundingVolume::BT_default 0</span>
<span class="s0">0 7 BT_best 23 BoundingVolume::BT_best 0</span>
<span class="s0">1 9 BT_sphere 25 BoundingVolume::BT_sphere 0</span>
<span class="s0">2 6 BT_box 22 BoundingVolume::BT_box 0</span>
<span class="s0">3 10 BT_fastest 26 BoundingVolume::BT_fastest 0</span>
<span class="s0">4 0 80</span>
<span class="s0">// This enum is used to control the automatic generation of bounding</span>
<span class="s0">// volumes.</span>

<span class="s0">3632 14 BoundingVolume 0 2048 14 BoundingVolume 14 BoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 330</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class for any volume in any sense which can be said to</span>
 <span class="s0">* define the locality of reference of a node in a graph, along with all of</span>
 <span class="s0">* its descendants.  It is not necessarily a geometric volume (although see</span>
 <span class="s0">* GeometricBoundingVolume); this is simply an abstract interface for bounds</span>
 <span class="s0">* of any sort.</span>
 <span class="s0">*/</span>

<span class="s0">3633 32 ConstPointerTo&lt; BoundingVolume &gt; 0 2048 32 ConstPointerTo&lt; BoundingVolume &gt; 32 ConstPointerTo&lt; BoundingVolume &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3634 9 FancyBits 0 794624 20 PandaNode::FancyBits 20 PandaNode::FancyBits 3615 0 0 0 0 0 0 0 0 0 6 12 FB_transform 23 PandaNode::FB_transform 0</span>
<span class="s0">1 8 FB_state 19 PandaNode::FB_state 0</span>
<span class="s0">2 10 FB_effects 21 PandaNode::FB_effects 0</span>
<span class="s0">4 6 FB_tag 17 PandaNode::FB_tag 0</span>
<span class="s0">16 12 FB_draw_mask 23 PandaNode::FB_draw_mask 0</span>
<span class="s0">32 16 FB_cull_callback 27 PandaNode::FB_cull_callback 0</span>
<span class="s0">64 0 0</span>

<span class="s0">3635 8 Children 0 403457 19 PandaNode::Children 19 PandaNode::Children 3615 0 0 0 2247 0 2 2245 2246 0 0 0 0 0 382</span>
<span class="s0">// This class is returned from get_children().  Use it to walk through the</span>
<span class="s0">// list of children.  This is faster, and safer, than walking through the</span>
<span class="s0">// children one at a time via get_num_children()/get_child(), since the list</span>
<span class="s0">// of children is saved out ahead of time, rather than having to reacquire</span>
<span class="s0">// the lock with each iteration, or to keep the lock held for the entire</span>
<span class="s0">// pass.</span>

<span class="s0">3636 7 Stashed 0 403457 18 PandaNode::Stashed 18 PandaNode::Stashed 3615 0 0 0 2250 0 2 2248 2249 0 0 0 0 0 34</span>
<span class="s0">// Similarly for stashed children.</span>

<span class="s0">3637 7 Parents 0 403457 18 PandaNode::Parents 18 PandaNode::Parents 3615 0 0 0 2253 0 2 2251 2252 0 0 0 0 0 45</span>
<span class="s0">// This class is returned from get_parents().</span>

<span class="s0">3638 18 TransparencyAttrib 0 141313 18 TransparencyAttrib 18 TransparencyAttrib 0 0 0 0 2262 2 4164 4165 5 2257 2258 2259 2260 2261 0 0 1 0 3591 0 0 0 1 3639 425</span>
<span class="s0">/**</span>
 <span class="s0">* This controls the enabling of transparency.  Simply setting an alpha</span>
 <span class="s0">* component to non-1 does not in itself make an object transparent; you must</span>
 <span class="s0">* also enable transparency mode with a suitable TransparencyAttrib.</span>
 <span class="s0">* Similarly, it is wasteful to render an object with a TransparencyAttrib in</span>
 <span class="s0">* effect unless you actually want it to be at least partially transparent</span>
 <span class="s0">* (and it has alpha components less than 1).</span>
 <span class="s0">*/</span>

<span class="s0">3639 4 Mode 0 794624 24 TransparencyAttrib::Mode 24 TransparencyAttrib::Mode 3638 0 0 0 0 0 0 0 0 0 7 6 M_none 26 TransparencyAttrib::M_none 19</span>
<span class="s0">// No transparency.</span>
<span class="s0">0 7 M_alpha 27 TransparencyAttrib::M_alpha 54</span>
<span class="s0">// Normal transparency, panda will sort back-to-front.</span>
<span class="s0">1 21 M_premultiplied_alpha 41 TransparencyAttrib::M_premultiplied_alpha 43</span>
<span class="s0">// Assume textures use premultiplied alpha.</span>
<span class="s0">2 13 M_multisample 33 TransparencyAttrib::M_multisample 48</span>
<span class="s0">// Uses ms buffer, alpha values modified to 1.0.</span>
<span class="s0">3 18 M_multisample_mask 38 TransparencyAttrib::M_multisample_mask 45</span>
<span class="s0">// Uses ms buffer, alpha values not modified.</span>
<span class="s0">4 8 M_binary 28 TransparencyAttrib::M_binary 40</span>
<span class="s0">// Only writes pixels with alpha &gt;= 0.5.</span>
<span class="s0">5 6 M_dual 26 TransparencyAttrib::M_dual 53</span>
<span class="s0">// opaque parts first, then sorted transparent parts.</span>
<span class="s0">6 0 0</span>

<span class="s0">3640 13 LogicOpAttrib 0 141313 13 LogicOpAttrib 13 LogicOpAttrib 0 0 0 0 2269 2 4166 4167 6 2263 2264 2265 2266 2267 2268 0 0 1 0 3591 0 0 0 1 3641 263</span>
<span class="s0">/**</span>
 <span class="s0">* If enabled, specifies that a custom logical operation be performed instead</span>
 <span class="s0">* of any color blending.  Setting it to a value other than M_none will cause</span>
 <span class="s0">* color blending to be disabled and the given logic operation to be performed.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">3641 9 Operation 0 794624 24 LogicOpAttrib::Operation 24 LogicOpAttrib::Operation 3640 0 0 0 0 0 0 0 0 0 17 6 O_none 21 LogicOpAttrib::O_none 45</span>
<span class="s0">// LogicOp disabled, regular blending occurs.</span>
<span class="s0">0 7 O_clear 22 LogicOpAttrib::O_clear 28</span>
<span class="s0">// Clears framebuffer value.</span>
<span class="s0">1 5 O_and 20 LogicOpAttrib::O_and 0</span>
<span class="s0">2 13 O_and_reverse 28 LogicOpAttrib::O_and_reverse 0</span>
<span class="s0">3 6 O_copy 21 LogicOpAttrib::O_copy 48</span>
<span class="s0">// Writes the incoming color to the framebuffer.</span>
<span class="s0">4 14 O_and_inverted 29 LogicOpAttrib::O_and_inverted 0</span>
<span class="s0">5 6 O_noop 21 LogicOpAttrib::O_noop 42</span>
<span class="s0">// Leaves the framebuffer value unaltered.</span>
<span class="s0">6 5 O_xor 20 LogicOpAttrib::O_xor 0</span>
<span class="s0">7 4 O_or 19 LogicOpAttrib::O_or 0</span>
<span class="s0">8 5 O_nor 20 LogicOpAttrib::O_nor 0</span>
<span class="s0">9 12 O_equivalent 27 LogicOpAttrib::O_equivalent 0</span>
<span class="s0">10 8 O_invert 23 LogicOpAttrib::O_invert 0</span>
<span class="s0">11 12 O_or_reverse 27 LogicOpAttrib::O_or_reverse 0</span>
<span class="s0">12 15 O_copy_inverted 30 LogicOpAttrib::O_copy_inverted 0</span>
<span class="s0">13 13 O_or_inverted 28 LogicOpAttrib::O_or_inverted 0</span>
<span class="s0">14 6 O_nand 21 LogicOpAttrib::O_nand 0</span>
<span class="s0">15 5 O_set 20 LogicOpAttrib::O_set 45</span>
<span class="s0">// Sets all the bits in the framebuffer to 1.</span>
<span class="s0">16 0 0</span>

<span class="s0">3642 11 ShaderInput 0 141313 11 ShaderInput 11 ShaderInput 0 0 0 1 2271 2285 0 13 2270 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 0 1 2272 0 0 2 3643 3644 127</span>
<span class="s0">/**</span>
 <span class="s0">* This is a small container class that can hold any one of the value types</span>
 <span class="s0">* that can be passed as input to a shader.</span>
 <span class="s0">*/</span>

<span class="s0">3643 11 AccessFlags 0 794624 24 ShaderInput::AccessFlags 24 ShaderInput::AccessFlags 3642 0 0 0 0 0 0 0 0 0 3 6 A_read 19 ShaderInput::A_read 0</span>
<span class="s0">1 7 A_write 20 ShaderInput::A_write 0</span>
<span class="s0">2 9 A_layered 22 ShaderInput::A_layered 0</span>
<span class="s0">4 0 36</span>
<span class="s0">// Used when binding texture images.</span>

<span class="s0">3644 15 ShaderInputType 0 794624 28 ShaderInput::ShaderInputType 28 ShaderInput::ShaderInputType 3642 0 0 0 0 0 0 0 0 0 9 9 M_invalid 22 ShaderInput::M_invalid 0</span>
<span class="s0">0 9 M_texture 22 ShaderInput::M_texture 0</span>
<span class="s0">1 10 M_nodepath 23 ShaderInput::M_nodepath 0</span>
<span class="s0">2 8 M_vector 21 ShaderInput::M_vector 0</span>
<span class="s0">3 9 M_numeric 22 ShaderInput::M_numeric 0</span>
<span class="s0">4 17 M_texture_sampler 30 ShaderInput::M_texture_sampler 0</span>
<span class="s0">5 7 M_param 20 ShaderInput::M_param 0</span>
<span class="s0">6 15 M_texture_image 28 ShaderInput::M_texture_image 0</span>
<span class="s0">7 8 M_buffer 21 ShaderInput::M_buffer 0</span>
<span class="s0">8 0 0</span>

<span class="s0">3645 22 InternalNameCollection 0 26625 22 InternalNameCollection 22 InternalNameCollection 0 0 0 1 2286 2288 0 16 2287 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 1 4301 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">3646 18 MaterialCollection 0 26625 18 MaterialCollection 18 MaterialCollection 0 0 0 1 2304 2306 0 17 2305 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 0 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">3647 22 TextureStageCollection 0 26625 22 TextureStageCollection 22 TextureStageCollection 0 0 0 1 2323 2325 0 18 2324 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 1 4302 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">3648 8 NodePath 0 141313 8 NodePath 8 NodePath 0 0 0 1 2343 2739 11 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 353 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2 4303 4304 1 2357 0 0 1 3649 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">3649 9 ErrorType 0 794624 19 NodePath::ErrorType 19 NodePath::ErrorType 3648 0 0 0 0 0 0 0 0 0 4 5 ET_ok 15 NodePath::ET_ok 49</span>
<span class="s0">// i.e. not empty, or never assigned to anything.</span>
<span class="s0">0 12 ET_not_found 22 NodePath::ET_not_found 53</span>
<span class="s0">// returned from a failed find() or similar function.</span>
<span class="s0">1 10 ET_removed 20 NodePath::ET_removed 56</span>
<span class="s0">// remove_node() was previously called on this NodePath.</span>
<span class="s0">2 7 ET_fail 17 NodePath::ET_fail 45</span>
<span class="s0">// general failure return from some function.</span>
<span class="s0">3 0 109</span>
<span class="s0">// This enumeration is returned by get_error_type() for an empty NodePath to</span>
<span class="s0">// report the reason it's empty.</span>

<span class="s0">3650 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 3615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3651 18 NodePathCollection 0 141313 18 NodePathCollection 18 NodePathCollection 0 0 0 1 2375 2415 0 39 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 1 4305 0 0 0 0 178</span>
<span class="s0">/**</span>
 <span class="s0">* This is a set of zero or more NodePaths.  It's handy for returning from</span>
 <span class="s0">* functions that need to return multiple NodePaths (for instance,</span>
 <span class="s0">* NodePaths::get_children).</span>
 <span class="s0">*/</span>

<span class="s0">3652 18 AttribNodeRegistry 0 141313 18 AttribNodeRegistry 18 AttribNodeRegistry 0 0 0 0 2752 0 12 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 1 4306 0 0 0 0 549</span>
<span class="s0">/**</span>
 <span class="s0">* This global object records NodePaths that are referenced by scene graph</span>
 <span class="s0">* attribs, such as ClipPlaneAttribs and LightAttribs.</span>
 <span class="s0">*</span>
 <span class="s0">* Its primary purpose is to unify attribs that are loaded in from bam files.</span>
 <span class="s0">* Attrib nodes are identified by name and type; when a bam file that contains</span>
 <span class="s0">* references to some attrib nodes is loaded, those nodes are first looked up</span>
 <span class="s0">* here in the AttribNodeRegistry.  If there is a match (by name and node</span>
 <span class="s0">* type), the identified node is used instead of the node referenced within</span>
 <span class="s0">* the bam file itself.</span>
 <span class="s0">*/</span>

<span class="s0">3653 17 AudioVolumeAttrib 0 141313 17 AudioVolumeAttrib 17 AudioVolumeAttrib 0 0 0 0 2763 2 4179 4180 10 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 0 0 1 0 3591 0 0 0 0 84</span>
<span class="s0">/**</span>
 <span class="s0">* Applies a scale to audio volume for positional sounds in the scene graph.</span>
 <span class="s0">*/</span>

<span class="s0">3654 17 AuxBitplaneAttrib 0 141313 17 AuxBitplaneAttrib 17 AuxBitplaneAttrib 0 0 0 0 2769 2 4181 4182 5 2764 2765 2766 2767 2768 0 0 1 0 3591 0 0 0 1 3655 1237</span>
<span class="s0">/**</span>
 <span class="s0">* Modern frame buffers can have 'aux' bitplanes, which are additional</span>
 <span class="s0">* bitplanes above and beyond the standard depth and color.  This attrib</span>
 <span class="s0">* controls what gets rendered into those additional bitplanes.  It can also</span>
 <span class="s0">* affect what goes into the alpha channel of the primary color buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* ABO_glow: copy the glow map into the alpha channel of the primary frame</span>
 <span class="s0">* buffer.  If there is no glow map, set it to zero.  Caveat: it is not</span>
 <span class="s0">* possible to write glow or depth values to the framebuffer alpha channel at</span>
 <span class="s0">* the same time as using alpha blending or alpha testing.  Any attempt to use</span>
 <span class="s0">* transparency, blending, or alpha testing will cause this flag to be</span>
 <span class="s0">* overridden.</span>
 <span class="s0">*</span>
 <span class="s0">* ABO_aux_normal: put the camera-space normal into the into the R,G</span>
 <span class="s0">* components of the first auxiliary bitplane.</span>
 <span class="s0">*</span>
 <span class="s0">* ABO_aux_modelz: put the clip-space Z coordinate of the center of the model</span>
 <span class="s0">* (after perspective divide) into the B channel of the first auxiliary</span>
 <span class="s0">* bitplane.</span>
 <span class="s0">*</span>
 <span class="s0">* ABO_aux_glow: put a copy of the glow map into the alpha channel of the</span>
 <span class="s0">* first auxiliary bitplane.  If there is no glow map, set it to zero.</span>
 <span class="s0">*</span>
 <span class="s0">* AuxBitplaneAttrib is relevant only when shader generation is enabled.</span>
 <span class="s0">* Otherwise, it has no effect.</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">3655 17 AuxBitplaneOutput 0 794624 36 AuxBitplaneAttrib::AuxBitplaneOutput 36 AuxBitplaneAttrib::AuxBitplaneOutput 3654 0 0 0 0 0 0 0 0 0 3 8 ABO_glow 27 AuxBitplaneAttrib::ABO_glow 0</span>
<span class="s0">1 14 ABO_aux_normal 33 AuxBitplaneAttrib::ABO_aux_normal 0</span>
<span class="s0">2 12 ABO_aux_glow 31 AuxBitplaneAttrib::ABO_aux_glow 0</span>
<span class="s0">4 0 0</span>

<span class="s0">3656 12 AuxSceneData 0 141313 12 AuxSceneData 12 AuxSceneData 0 0 0 1 2778 2779 0 8 2770 2771 2772 2773 2774 2775 2776 2777 0 0 1 0 3657 0 0 0 0 378</span>
<span class="s0">/**</span>
 <span class="s0">* This is a base class for a generic data structure that can be attached per-</span>
 <span class="s0">* instance to the camera, to store per-instance data that must be preserved</span>
 <span class="s0">* over multiple frames.</span>
 <span class="s0">*</span>
 <span class="s0">* In particular, this is used to implement the FadeLODNode, which must</span>
 <span class="s0">* remember during traversal at what point it is in the fade, separately for</span>
 <span class="s0">* each instance and for each camera.</span>
 <span class="s0">*/</span>

<span class="s0">3657 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">3658 7 BamFile 0 26625 7 BamFile 7 BamFile 0 0 0 1 2780 2781 4 4183 4184 4185 4186 18 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 0 0 1 0 3659 0 0 0 0 574</span>
<span class="s0">/**</span>
 <span class="s0">* The principle public interface to reading and writing Bam disk files.  See</span>
 <span class="s0">* also BamReader and BamWriter, the more general implementation of this</span>
 <span class="s0">* class.</span>
 <span class="s0">*</span>
 <span class="s0">* Bam files are most often used to store scene graphs or subgraphs, and by</span>
 <span class="s0">* convention they are given filenames ending in the extension &quot;.bam&quot; when</span>
 <span class="s0">* they are used for this purpose.  However, a Bam file may store any</span>
 <span class="s0">* arbitrary list of TypedWritable objects; in this more general usage, they</span>
 <span class="s0">* are given filenames ending in &quot;.boo&quot; to differentiate them from the more</span>
 <span class="s0">* common scene graph files.</span>
 <span class="s0">*/</span>

<span class="s0">3659 8 BamEnums 0 2048 8 BamEnums 8 BamEnums 0 0 0 0 0 0 0 0 0 0 0 0 104</span>
<span class="s0">/**</span>
 <span class="s0">* This class exists just to provide scoping for the enums shared by BamReader</span>
 <span class="s0">* and BamWriter.</span>
 <span class="s0">*/</span>

<span class="s0">3660 9 BamEndian 0 794624 19 BamEnums::BamEndian 19 BamEnums::BamEndian 3659 0 0 0 0 0 0 0 0 0 3 12 BE_bigendian 22 BamEnums::BE_bigendian 0</span>
<span class="s0">0 15 BE_littleendian 25 BamEnums::BE_littleendian 0</span>
<span class="s0">1 9 BE_native 19 BamEnums::BE_native 0</span>
<span class="s0">1 0 365</span>
<span class="s0">/**</span>
   <span class="s0">* This defines an enumerated type used to represent the endianness of</span>
   <span class="s0">* certain numeric values stored in a Bam file.  It really has only two</span>
   <span class="s0">* possible values, either BE_bigendian or BE_littleendian; but through a</span>
   <span class="s0">* preprocessor trick we also add BE_native, which is the same numerically</span>
   <span class="s0">* as whichever value the hardware supports natively.</span>
   <span class="s0">*/</span>

<span class="s0">3661 11 BamReader * 0 8576 11 BamReader * 11 BamReader * 0 0 3662 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3662 9 BamReader 0 2048 9 BamReader 9 BamReader 0 0 0 0 0 0 0 0 0 0 0 0 1311</span>
<span class="s0">/**</span>
 <span class="s0">* This is the fundamental interface for extracting binary objects from a Bam</span>
 <span class="s0">* file, as generated by a BamWriter.</span>
 <span class="s0">*</span>
 <span class="s0">* A Bam file can be thought of as a linear collection of objects.  Each</span>
 <span class="s0">* object is an instance of a class that inherits, directly or indirectly,</span>
 <span class="s0">* from TypedWritable.  The objects may include pointers to other objects</span>
 <span class="s0">* within the Bam file; the BamReader automatically manages these (with help</span>
 <span class="s0">* from code within each class) and restores the pointers correctly.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the abstract interface and does not specifically deal with disk</span>
 <span class="s0">* files, but rather with a DatagramGenerator of some kind, which is simply a</span>
 <span class="s0">* linear source of Datagrams.  It is probably from a disk file, but it might</span>
 <span class="s0">* conceivably be streamed directly from a network or some such nonsense.</span>
 <span class="s0">*</span>
 <span class="s0">* Bam files are most often used to store scene graphs or subgraphs, and by</span>
 <span class="s0">* convention they are given filenames ending in the extension &quot;.bam&quot; when</span>
 <span class="s0">* they are used for this purpose.  However, a Bam file may store any</span>
 <span class="s0">* arbitrary list of TypedWritable objects; in this more general usage, they</span>
 <span class="s0">* are given filenames ending in &quot;.boo&quot; to differentiate them from the more</span>
 <span class="s0">* common scene graph files.</span>
 <span class="s0">*</span>
 <span class="s0">* See also BamFile, which defines a higher-level interface to read and write</span>
 <span class="s0">* Bam files on disk.</span>
 <span class="s0">*/</span>

<span class="s0">3663 11 BamWriter * 0 8576 11 BamWriter * 11 BamWriter * 0 0 3664 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3664 9 BamWriter 0 2048 9 BamWriter 9 BamWriter 0 0 0 0 0 0 0 0 0 0 0 0 1376</span>
<span class="s0">/**</span>
 <span class="s0">* This is the fundamental interface for writing binary objects to a Bam file,</span>
 <span class="s0">* to be extracted later by a BamReader.</span>
 <span class="s0">*</span>
 <span class="s0">* A Bam file can be thought of as a linear collection of objects.  Each</span>
 <span class="s0">* object is an instance of a class that inherits, directly or indirectly,</span>
 <span class="s0">* from TypedWritable.  The objects may include pointers to other objects; the</span>
 <span class="s0">* BamWriter automatically manages these (with help from code within each</span>
 <span class="s0">* class) and writes all referenced objects to the file in such a way that the</span>
 <span class="s0">* pointers may be correctly restored later.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the abstract interface and does not specifically deal with disk</span>
 <span class="s0">* files, but rather with a DatagramSink of some kind, which simply accepts a</span>
 <span class="s0">* linear stream of Datagrams.  It is probably written to a disk file, but it</span>
 <span class="s0">* might conceivably be streamed directly to a network or some such nonsense.</span>
 <span class="s0">*</span>
 <span class="s0">* Bam files are most often used to store scene graphs or subgraphs, and by</span>
 <span class="s0">* convention they are given filenames ending in the extension &quot;.bam&quot; when</span>
 <span class="s0">* they are used for this purpose.  However, a Bam file may store any</span>
 <span class="s0">* arbitrary list of TypedWritable objects; in this more general usage, they</span>
 <span class="s0">* are given filenames ending in &quot;.boo&quot; to differentiate them from the more</span>
 <span class="s0">* common scene graph files.</span>
 <span class="s0">*</span>
 <span class="s0">* See also BamFile, which defines a higher-level interface to read and write</span>
 <span class="s0">* Bam files on disk.</span>
 <span class="s0">*/</span>

<span class="s0">3665 15 BillboardEffect 0 141313 15 BillboardEffect 15 BillboardEffect 0 0 0 0 2813 0 13 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 0 0 1 0 3613 0 0 0 0 127</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that geometry at this node should automatically rotate to face</span>
 <span class="s0">* the camera, or any other arbitrary node.</span>
 <span class="s0">*/</span>

<span class="s0">3666 8 LensNode 0 141313 8 LensNode 8 LensNode 0 0 0 1 2814 2826 0 11 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 0 0 1 0 3615 0 0 0 0 181</span>
<span class="s0">/**</span>
 <span class="s0">* A node that contains a Lens.  The most important example of this kind of</span>
 <span class="s0">* node is a Camera, but other kinds of nodes also contain a lens (for</span>
 <span class="s0">* instance, a Spotlight).</span>
 <span class="s0">*/</span>

<span class="s0">3667 12 WeakNodePath 0 26625 12 WeakNodePath 12 WeakNodePath 0 0 0 1 2827 2828 0 12 2829 2830 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 0 1 2831 0 0 0 397</span>
<span class="s0">/**</span>
 <span class="s0">* This class is a wrapper around a NodePath that, unlike the actual NodePath</span>
 <span class="s0">* class, doesn't hold a reference count to the node.  Thus the node may be</span>
 <span class="s0">* detached from the scene graph and destructed at any time.</span>
 <span class="s0">*</span>
 <span class="s0">* You can call is_valid() or was_deleted() at any time to determine whether</span>
 <span class="s0">* the node is still around; if it is, get_node_path() will return the</span>
 <span class="s0">* associated NodePath.</span>
 <span class="s0">*/</span>

<span class="s0">3668 6 Camera 0 75777 6 Camera 6 Camera 0 0 0 1 2842 2826 12 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 31 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 1 4307 0 1 0 3666 0 0 0 0 121</span>
<span class="s0">/**</span>
 <span class="s0">* A node that can be positioned around in the scene graph to represent a</span>
 <span class="s0">* point of view for rendering a scene.</span>
 <span class="s0">*/</span>

<span class="s0">3669 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 3648 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3670 15 DisplayRegion * 0 8576 15 DisplayRegion * 15 DisplayRegion * 0 0 3671 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3671 13 DisplayRegion 0 2048 13 DisplayRegion 13 DisplayRegion 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3672 16 BoundingVolume * 0 8576 16 BoundingVolume * 16 BoundingVolume * 0 0 3632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3673 12 string const 0 8832 17 std::string const 17 std::string const 0 0 3621 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3674 14 AuxSceneData * 0 8576 14 AuxSceneData * 14 AuxSceneData * 0 0 3656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3675 9 PlaneNode 0 141313 9 PlaneNode 9 PlaneNode 0 0 0 1 2874 2884 4 4199 4200 4201 4202 9 2875 2876 2877 2878 2879 2880 2881 2882 2883 0 0 1 0 3615 0 0 0 1 3676 213</span>
<span class="s0">/**</span>
 <span class="s0">* A node that contains a plane.  This is most often used as a clipping plane,</span>
 <span class="s0">* but it can serve other purposes as well; whenever a plane is needed to be</span>
 <span class="s0">* defined in some coordinate space in the world.</span>
 <span class="s0">*/</span>

<span class="s0">3676 10 ClipEffect 0 794624 21 PlaneNode::ClipEffect 21 PlaneNode::ClipEffect 3675 0 0 0 0 0 0 0 0 0 2 10 CE_visible 21 PlaneNode::CE_visible 0</span>
<span class="s0">1 12 CE_collision 23 PlaneNode::CE_collision 0</span>
<span class="s0">2 0 0</span>

<span class="s0">3677 12 LPlane const 0 8832 12 LPlane const 12 LPlane const 0 0 3678 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3678 6 LPlane 0 2105344 6 LPlane 6 LPlane 0 0 3679 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3679 7 LPlanef 0 2048 7 LPlanef 7 LPlanef 0 0 0 0 0 0 0 0 0 0 0 0 120</span>
<span class="s0">/**</span>
 <span class="s0">* An abstract mathematical description of a plane.  A plane is defined by the</span>
 <span class="s0">* equation Ax + By + Cz + D = 0.</span>
 <span class="s0">*/</span>

<span class="s0">3680 15 ClipPlaneAttrib 0 141313 15 ClipPlaneAttrib 15 ClipPlaneAttrib 0 0 0 0 2909 1 4203 24 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2 4308 4309 0 1 0 3591 0 0 0 1 3681 260</span>
<span class="s0">/**</span>
 <span class="s0">* This functions similarly to a LightAttrib.  It indicates the set of</span>
 <span class="s0">* clipping planes that modify the geometry at this level and below.  A</span>
 <span class="s0">* ClipPlaneAttrib can either add planes or remove planes from the total set</span>
 <span class="s0">* of clipping planes in effect.</span>
 <span class="s0">*/</span>

<span class="s0">3681 9 Operation 0 794624 26 ClipPlaneAttrib::Operation 26 ClipPlaneAttrib::Operation 3680 0 0 0 0 0 0 0 0 0 3 5 O_set 22 ClipPlaneAttrib::O_set 0</span>
<span class="s0">0 5 O_add 22 ClipPlaneAttrib::O_add 0</span>
<span class="s0">1 8 O_remove 25 ClipPlaneAttrib::O_remove 0</span>
<span class="s0">2 0 146</span>
<span class="s0">// This is the old, deprecated interface to ClipPlaneAttrib.  Do not use any</span>
<span class="s0">// of these methods for new code; these methods will be removed soon.</span>

<span class="s0">3682 11 ColorAttrib 0 141313 11 ColorAttrib 11 ColorAttrib 0 0 0 0 2918 3 4204 4205 4206 8 2910 2911 2912 2913 2914 2915 2916 2917 0 0 1 0 3591 0 0 0 1 3683 73</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates what color should be applied to renderable geometry.</span>
 <span class="s0">*/</span>

<span class="s0">3683 4 Type 0 794624 17 ColorAttrib::Type 17 ColorAttrib::Type 3682 0 0 0 0 0 0 0 0 0 3 8 T_vertex 21 ColorAttrib::T_vertex 0</span>
<span class="s0">0 6 T_flat 19 ColorAttrib::T_flat 0</span>
<span class="s0">1 5 T_off 18 ColorAttrib::T_off 0</span>
<span class="s0">2 0 0</span>

<span class="s0">3684 16 ColorBlendAttrib 0 141313 16 ColorBlendAttrib 16 ColorBlendAttrib 0 0 0 0 2933 8 4207 4208 4209 4210 4211 4212 4213 4214 14 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 0 0 1 0 3591 0 0 0 2 3685 3686 159</span>
<span class="s0">/**</span>
 <span class="s0">* This specifies how colors are blended into the frame buffer, for special</span>
 <span class="s0">* effects.  This overrides transparency if transparency is also specified.</span>
 <span class="s0">*/</span>

<span class="s0">3685 4 Mode 0 794624 22 ColorBlendAttrib::Mode 22 ColorBlendAttrib::Mode 3684 0 0 0 0 0 0 0 0 0 6 6 M_none 24 ColorBlendAttrib::M_none 23</span>
<span class="s0">// Blending is disabled</span>
<span class="s0">0 5 M_add 23 ColorBlendAttrib::M_add 41</span>
<span class="s0">// incoming color * A + fbuffer color * B</span>
<span class="s0">1 10 M_subtract 28 ColorBlendAttrib::M_subtract 41</span>
<span class="s0">// incoming color * A - fbuffer color * B</span>
<span class="s0">2 14 M_inv_subtract 32 ColorBlendAttrib::M_inv_subtract 41</span>
<span class="s0">// fbuffer color * B - incoming color * A</span>
<span class="s0">3 5 M_min 23 ColorBlendAttrib::M_min 37</span>
<span class="s0">// min(incoming color, fbuffer color)</span>
<span class="s0">4 5 M_max 23 ColorBlendAttrib::M_max 37</span>
<span class="s0">// max(incoming color, fbuffer color)</span>
<span class="s0">5 0 0</span>

<span class="s0">3686 7 Operand 0 794624 25 ColorBlendAttrib::Operand 25 ColorBlendAttrib::Operand 3684 0 0 0 0 0 0 0 0 0 23 6 O_zero 24 ColorBlendAttrib::O_zero 0</span>
<span class="s0">0 5 O_one 23 ColorBlendAttrib::O_one 0</span>
<span class="s0">1 16 O_incoming_color 34 ColorBlendAttrib::O_incoming_color 0</span>
<span class="s0">2 26 O_one_minus_incoming_color 44 ColorBlendAttrib::O_one_minus_incoming_color 0</span>
<span class="s0">3 15 O_fbuffer_color 33 ColorBlendAttrib::O_fbuffer_color 0</span>
<span class="s0">4 25 O_one_minus_fbuffer_color 43 ColorBlendAttrib::O_one_minus_fbuffer_color 0</span>
<span class="s0">5 16 O_incoming_alpha 34 ColorBlendAttrib::O_incoming_alpha 0</span>
<span class="s0">6 26 O_one_minus_incoming_alpha 44 ColorBlendAttrib::O_one_minus_incoming_alpha 0</span>
<span class="s0">7 15 O_fbuffer_alpha 33 ColorBlendAttrib::O_fbuffer_alpha 0</span>
<span class="s0">8 25 O_one_minus_fbuffer_alpha 43 ColorBlendAttrib::O_one_minus_fbuffer_alpha 0</span>
<span class="s0">9 16 O_constant_color 34 ColorBlendAttrib::O_constant_color 0</span>
<span class="s0">10 26 O_one_minus_constant_color 44 ColorBlendAttrib::O_one_minus_constant_color 0</span>
<span class="s0">11 16 O_constant_alpha 34 ColorBlendAttrib::O_constant_alpha 0</span>
<span class="s0">12 26 O_one_minus_constant_alpha 44 ColorBlendAttrib::O_one_minus_constant_alpha 0</span>
<span class="s0">13 25 O_incoming_color_saturate 43 ColorBlendAttrib::O_incoming_color_saturate 27</span>
<span class="s0">// valid only for operand a</span>
<span class="s0">14 17 O_incoming1_color 35 ColorBlendAttrib::O_incoming1_color 135</span>
<span class="s0">// The following are used for dual-source blending, where the fragment</span>
<span class="s0">// shader outputs a second color that will be used for blending.</span>
<span class="s0">15 27 O_one_minus_incoming1_color 45 ColorBlendAttrib::O_one_minus_incoming1_color 0</span>
<span class="s0">16 17 O_incoming1_alpha 35 ColorBlendAttrib::O_incoming1_alpha 0</span>
<span class="s0">17 27 O_one_minus_incoming1_alpha 45 ColorBlendAttrib::O_one_minus_incoming1_alpha 0</span>
<span class="s0">18 13 O_color_scale 31 ColorBlendAttrib::O_color_scale 52</span>
<span class="s0">// These modes are being considered for deprecation.</span>
<span class="s0">19 23 O_one_minus_color_scale 41 ColorBlendAttrib::O_one_minus_color_scale 0</span>
<span class="s0">20 13 O_alpha_scale 31 ColorBlendAttrib::O_alpha_scale 0</span>
<span class="s0">21 23 O_one_minus_alpha_scale 41 ColorBlendAttrib::O_one_minus_alpha_scale 0</span>
<span class="s0">22 0 0</span>

<span class="s0">3687 16 ColorScaleAttrib 0 141313 16 ColorScaleAttrib 16 ColorScaleAttrib 0 0 0 0 2947 2 4215 4216 13 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 0 0 1 0 3591 0 0 0 0 72</span>
<span class="s0">/**</span>
 <span class="s0">* Applies a scale to colors in the scene graph and on vertices.</span>
 <span class="s0">*/</span>

<span class="s0">3688 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 3689 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3689 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 3604 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3690 16 ColorWriteAttrib 0 141313 16 ColorWriteAttrib 16 ColorWriteAttrib 0 0 0 0 2953 2 4217 4218 5 2948 2949 2950 2951 2952 0 0 1 0 3591 0 0 0 1 3691 209</span>
<span class="s0">/**</span>
 <span class="s0">* Enables or disables writing to the color buffer.  This is primarily useful</span>
 <span class="s0">* for certain special effects in which it is important to write to the depth</span>
 <span class="s0">* buffer without affecting the color buffer.</span>
 <span class="s0">*/</span>

<span class="s0">3691 8 Channels 0 794624 26 ColorWriteAttrib::Channels 26 ColorWriteAttrib::Channels 3690 0 0 0 0 0 0 0 0 0 7 5 C_off 23 ColorWriteAttrib::C_off 110</span>
<span class="s0">// By coincidence, these bits are the same as those for</span>
<span class="s0">// D3DCOLORWRITEENABLE_RED, _GREEN, _BLUE, and _ALPHA.</span>
<span class="s0">0 5 C_red 23 ColorWriteAttrib::C_red 0</span>
<span class="s0">1 7 C_green 25 ColorWriteAttrib::C_green 0</span>
<span class="s0">2 6 C_blue 24 ColorWriteAttrib::C_blue 0</span>
<span class="s0">4 5 C_rgb 23 ColorWriteAttrib::C_rgb 30</span>
<span class="s0">// == C_red | C_green | C_blue</span>
<span class="s0">7 7 C_alpha 25 ColorWriteAttrib::C_alpha 0</span>
<span class="s0">8 5 C_all 23 ColorWriteAttrib::C_all 0</span>
<span class="s0">15 0 0</span>

<span class="s0">3692 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3693 13 CompassEffect 0 141313 13 CompassEffect 13 CompassEffect 0 0 0 0 2958 0 4 2954 2955 2956 2957 0 0 1 0 3613 0 0 0 1 3694 1226</span>
<span class="s0">/**</span>
 <span class="s0">* A CompassEffect causes a node to inherit its rotation (or pos or scale, if</span>
 <span class="s0">* specified) from some other reference node in the graph, or more often from</span>
 <span class="s0">* the root.</span>
 <span class="s0">*</span>
 <span class="s0">* In its purest form, a CompassEffect is used to keep the node's rotation</span>
 <span class="s0">* fixed relative to the top of the scene graph, despite other transforms that</span>
 <span class="s0">* may exist above the node.  Hence the name: the node behaves like a magnetic</span>
 <span class="s0">* compass, always pointing in the same direction.</span>
 <span class="s0">*</span>
 <span class="s0">* As an couple of generalizing extensions, the CompassEffect may also be set</span>
 <span class="s0">* up to always orient its node according to some other reference node than</span>
 <span class="s0">* the root of the scene graph.  Furthermore, it may optionally adjust any of</span>
 <span class="s0">* pos, rotation, or scale, instead of necessarily rotation; and it may adjust</span>
 <span class="s0">* individual pos and scale components.  (Rotation may not be adjusted on an</span>
 <span class="s0">* individual component basis; that's just asking for trouble.)</span>
 <span class="s0">*</span>
 <span class="s0">* Be careful when using the pos and scale modes.  In these modes, it's</span>
 <span class="s0">* possible for the CompassEffect to move its node far from its normal</span>
 <span class="s0">* bounding volume, causing culling to fail.  If this is an issue, you may</span>
 <span class="s0">* need to explicitly set a large (or infinite) bounding volume on the effect</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>

<span class="s0">3694 10 Properties 0 794624 25 CompassEffect::Properties 25 CompassEffect::Properties 3693 0 0 0 0 0 0 0 0 0 10 3 P_x 18 CompassEffect::P_x 0</span>
<span class="s0">1 3 P_y 18 CompassEffect::P_y 0</span>
<span class="s0">2 3 P_z 18 CompassEffect::P_z 0</span>
<span class="s0">4 5 P_pos 20 CompassEffect::P_pos 0</span>
<span class="s0">7 5 P_rot 20 CompassEffect::P_rot 0</span>
<span class="s0">8 4 P_sx 19 CompassEffect::P_sx 0</span>
<span class="s0">16 4 P_sy 19 CompassEffect::P_sy 0</span>
<span class="s0">32 4 P_sz 19 CompassEffect::P_sz 0</span>
<span class="s0">64 7 P_scale 22 CompassEffect::P_scale 0</span>
<span class="s0">112 5 P_all 20 CompassEffect::P_all 0</span>
<span class="s0">127 0 0</span>

<span class="s0">3695 12 CullBinEnums 0 141313 12 CullBinEnums 12 CullBinEnums 0 0 0 1 2959 2960 0 0 0 0 0 0 1 3696 92</span>
<span class="s0">/**</span>
 <span class="s0">* Provides scoping for the enumerated type shared by CullBin and</span>
 <span class="s0">* CullBinManager.</span>
 <span class="s0">*/</span>

<span class="s0">3696 7 BinType 0 794624 21 CullBinEnums::BinType 21 CullBinEnums::BinType 3695 0 0 0 0 0 0 0 0 0 6 10 BT_invalid 24 CullBinEnums::BT_invalid 0</span>
<span class="s0">0 11 BT_unsorted 25 CullBinEnums::BT_unsorted 0</span>
<span class="s0">1 15 BT_state_sorted 29 CullBinEnums::BT_state_sorted 0</span>
<span class="s0">2 16 BT_back_to_front 30 CullBinEnums::BT_back_to_front 0</span>
<span class="s0">3 16 BT_front_to_back 30 CullBinEnums::BT_front_to_back 0</span>
<span class="s0">4 8 BT_fixed 22 CullBinEnums::BT_fixed 0</span>
<span class="s0">5 0 0</span>

<span class="s0">3697 8 GeomNode 0 75777 8 GeomNode 8 GeomNode 0 0 0 1 2961 2131 1 4219 19 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 3 4310 4311 4312 0 1 0 3615 0 0 0 0 208</span>
<span class="s0">/**</span>
 <span class="s0">* A node that holds Geom objects, renderable pieces of geometry.  This is the</span>
 <span class="s0">* primary kind of leaf node in the scene graph; almost all visible objects</span>
 <span class="s0">* will be contained in a GeomNode somewhere.</span>
 <span class="s0">*/</span>

<span class="s0">3698 13 CullBinAttrib 0 141313 13 CullBinAttrib 13 CullBinAttrib 0 0 0 0 2987 3 4220 4221 4222 6 2981 2982 2983 2984 2985 2986 0 0 1 0 3591 0 0 0 0 130</span>
<span class="s0">/**</span>
 <span class="s0">* Assigns geometry to a particular bin by name.  The bins must be created</span>
 <span class="s0">* separately via the CullBinManager interface.</span>
 <span class="s0">*/</span>

<span class="s0">3699 14 CullBinManager 0 43009 14 CullBinManager 14 CullBinManager 0 0 0 0 0 0 18 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 1 4313 0 1 0 3695 0 0 0 0 99</span>
<span class="s0">/**</span>
 <span class="s0">* This is a global object that maintains the collection of named CullBins in</span>
 <span class="s0">* the world.</span>
 <span class="s0">*/</span>

<span class="s0">3700 14 CullFaceAttrib 0 141313 14 CullFaceAttrib 14 CullFaceAttrib 0 0 0 0 3014 4 4223 4224 4225 4226 8 3006 3007 3008 3009 3010 3011 3012 3013 0 0 1 0 3591 0 0 0 1 3701 81</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates which faces should be culled based on their vertex ordering.</span>
 <span class="s0">*/</span>

<span class="s0">3701 4 Mode 0 794624 20 CullFaceAttrib::Mode 20 CullFaceAttrib::Mode 3700 0 0 0 0 0 0 0 0 0 4 11 M_cull_none 27 CullFaceAttrib::M_cull_none 19</span>
<span class="s0">// Cull no polygons</span>
<span class="s0">0 16 M_cull_clockwise 32 CullFaceAttrib::M_cull_clockwise 35</span>
<span class="s0">// Cull clockwise-oriented polygons</span>
<span class="s0">1 24 M_cull_counter_clockwise 40 CullFaceAttrib::M_cull_counter_clockwise 43</span>
<span class="s0">// Cull counter-clockwise-oriented polygons</span>
<span class="s0">2 16 M_cull_unchanged 32 CullFaceAttrib::M_cull_unchanged 39</span>
<span class="s0">// Do not change existing cull behavior</span>
<span class="s0">3 0 0</span>

<span class="s0">3702 15 WorkingNodePath 0 26625 15 WorkingNodePath 15 WorkingNodePath 0 0 0 0 3015 2 4227 4228 0 0 0 0 0 0 750</span>
<span class="s0">/**</span>
 <span class="s0">* This is a class designed to support low-overhead traversals of the complete</span>
 <span class="s0">* scene graph, with a memory of the complete path through the graph at any</span>
 <span class="s0">* given point.</span>
 <span class="s0">*</span>
 <span class="s0">* You could just use a regular NodePath to do this, but since the NodePath</span>
 <span class="s0">* requires storing NodePathComponents on each node as it is constructed, and</span>
 <span class="s0">* then removing them when it destructs, there is considerable overhead in</span>
 <span class="s0">* that approach.</span>
 <span class="s0">*</span>
 <span class="s0">* The WorkingNodePath eliminates this overhead (but does not guarantee</span>
 <span class="s0">* consistency if the scene graph changes while the path is held).</span>
 <span class="s0">*</span>
 <span class="s0">* At any given point, you may ask the WorkingNodePath for its actual</span>
 <span class="s0">* NodePath, and it will construct and return a new NodePath representing the</span>
 <span class="s0">* complete generated chain.</span>
 <span class="s0">*/</span>

<span class="s0">3703 17 CullTraverserData 0 141313 17 CullTraverserData 17 CullTraverserData 0 0 0 1 3027 3028 1 4229 8 3018 3019 3020 3021 3022 3023 3024 3025 0 0 0 0 0 464</span>
<span class="s0">/**</span>
 <span class="s0">* This collects together the pieces of data that are accumulated for each</span>
 <span class="s0">* node while walking the scene graph during the cull traversal.</span>
 <span class="s0">*</span>
 <span class="s0">* Having this as a separate object simplifies the parameter list to</span>
 <span class="s0">* CullTraverser::r_traverse(), as well as to other functions like</span>
 <span class="s0">* PandaNode::cull_callback().  It also makes it easier to add cull</span>
 <span class="s0">* parameters, and provides a place to abstract out some of the cull behavior</span>
 <span class="s0">* (like view-frustum culling).</span>
 <span class="s0">*/</span>

<span class="s0">3704 10 SceneSetup 0 141313 10 SceneSetup 10 SceneSetup 0 0 0 1 3057 3058 0 28 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 0 0 1 0 3657 0 0 0 0 128</span>
<span class="s0">/**</span>
 <span class="s0">* This object holds the camera position, etc., and other general setup</span>
 <span class="s0">* information for rendering a particular scene.</span>
 <span class="s0">*/</span>

<span class="s0">3705 3 Fog 0 75777 3 Fog 3 Fog 0 0 0 1 3059 2131 5 4230 4231 4232 4233 4234 13 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 0 0 1 0 3615 0 0 0 1 3706 782</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies how atmospheric fog effects are applied to geometry.  The Fog</span>
 <span class="s0">* object is now a PandaNode, which means it can be used similarly to a Light</span>
 <span class="s0">* to define effects relative to a particular coordinate system within the</span>
 <span class="s0">* scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* In exponential mode, the fog effects are always camera-relative, and it</span>
 <span class="s0">* does not matter where the Fog node is parented.  However, in linear mode,</span>
 <span class="s0">* the onset and opaque distances are defined as offsets along the local</span>
 <span class="s0">* forward axis (e.g.  the Y axis).  This allows the fog effect to be</span>
 <span class="s0">* localized to a particular region in space, rather than always camera-</span>
 <span class="s0">* relative.  If the fog object is not parented to any node, it is used to</span>
 <span class="s0">* generate traditonal camera-relative fog, as if it were parented to the</span>
 <span class="s0">* camera.</span>
 <span class="s0">*/</span>

<span class="s0">3706 4 Mode 0 794624 9 Fog::Mode 9 Fog::Mode 3705 0 0 0 0 0 0 0 0 0 3 8 M_linear 13 Fog::M_linear 32</span>
<span class="s0">// f = (end - z) / (end - start)</span>
<span class="s0">0 13 M_exponential 18 Fog::M_exponential 23</span>
<span class="s0">// f = e^(-density * z)</span>
<span class="s0">1 21 M_exponential_squared 26 Fog::M_exponential_squared 27</span>
<span class="s0">// f = e^((-density * z)^2)</span>
<span class="s0">2 0 0</span>

<span class="s0">3707 9 FogAttrib 0 141313 9 FogAttrib 9 FogAttrib 0 0 0 0 3080 2 4235 4236 7 3073 3074 3075 3076 3077 3078 3079 0 0 1 0 3591 0 0 0 0 64</span>
<span class="s0">/**</span>
 <span class="s0">* Applies a Fog to the geometry at and below this node.</span>
 <span class="s0">*/</span>

<span class="s0">3708 5 Fog * 0 8576 5 Fog * 5 Fog * 0 0 3705 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3709 13 CullTraverser 0 141313 13 CullTraverser 13 CullTraverser 0 0 0 1 3081 3107 0 25 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 0 0 1 0 3657 0 0 0 0 279</span>
<span class="s0">/**</span>
 <span class="s0">* This object performs a depth-first traversal of the scene graph, with</span>
 <span class="s0">* optional view-frustum culling, collecting CullState and searching for</span>
 <span class="s0">* GeomNodes.  Each renderable Geom encountered is passed along with its</span>
 <span class="s0">* associated RenderState to the CullHandler object.</span>
 <span class="s0">*/</span>

<span class="s0">3710 20 GeomDrawCallbackData 0 141313 20 GeomDrawCallbackData 20 GeomDrawCallbackData 0 0 0 0 3114 0 6 3108 3109 3110 3111 3112 3113 0 0 1 0 3711 0 0 0 0 150</span>
<span class="s0">/**</span>
 <span class="s0">* This specialization on CallbackData is passed when the callback is</span>
 <span class="s0">* initiated from deep within the draw traversal, for a particular Geom.</span>
 <span class="s0">*/</span>

<span class="s0">3711 12 CallbackData 0 2048 12 CallbackData 12 CallbackData 0 0 0 0 0 0 0 0 0 0 0 0 348</span>
<span class="s0">/**</span>
 <span class="s0">* This is a generic data block that is passed along to a CallbackObject when</span>
 <span class="s0">* a callback is made.  It contains data specific to the particular callback</span>
 <span class="s0">* type in question.</span>
 <span class="s0">*</span>
 <span class="s0">* This is actually an abstract base class and contains no data.</span>
 <span class="s0">* Specializations of this class will contain the actual data relevant to each</span>
 <span class="s0">* callback type.</span>
 <span class="s0">*/</span>

<span class="s0">3712 19 RescaleNormalAttrib 0 141313 19 RescaleNormalAttrib 19 RescaleNormalAttrib 0 0 0 0 3120 2 4237 4238 5 3115 3116 3117 3118 3119 0 0 1 0 3591 0 0 0 1 3713 50</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies how polygons are to be drawn.</span>
 <span class="s0">*/</span>

<span class="s0">3713 4 Mode 0 794624 25 RescaleNormalAttrib::Mode 25 RescaleNormalAttrib::Mode 3712 0 0 0 0 0 0 0 0 0 4 6 M_none 27 RescaleNormalAttrib::M_none 38</span>
<span class="s0">// No adjustments are made to normals.</span>
<span class="s0">0 9 M_rescale 30 RescaleNormalAttrib::M_rescale 99</span>
<span class="s0">// Normals are counterscaled by the transform's uniform scale, if</span>
<span class="s0">// supported by the graphics API.</span>
<span class="s0">1 11 M_normalize 32 RescaleNormalAttrib::M_normalize 60</span>
<span class="s0">// Normals are scaled to unit length; potentially expensive.</span>
<span class="s0">2 6 M_auto 27 RescaleNormalAttrib::M_auto 141</span>
<span class="s0">// Normals are counterscaled in the presence of a uniform scale transform,</span>
<span class="s0">// or normalized in the presence of a non-uniform scale transform.</span>
<span class="s0">3 0 0</span>

<span class="s0">3714 10 CullResult 0 75777 10 CullResult 10 CullResult 0 0 0 1 3128 0 0 7 3121 3122 3123 3124 3125 3126 3127 0 0 1 0 3715 0 0 0 0 349</span>
<span class="s0">/**</span>
 <span class="s0">* This stores the result of a BinCullHandler traversal: an ordered collection</span>
 <span class="s0">* of CullBins, each of which holds a number of Geoms and RenderStates to be</span>
 <span class="s0">* rendered in some defined order.</span>
 <span class="s0">*</span>
 <span class="s0">* This is also used to keep the results of last frame's cull traversal around</span>
 <span class="s0">* to make next frame's traversal of the same scene a little easier.</span>
 <span class="s0">*/</span>

<span class="s0">3715 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">3716 11 DecalEffect 0 141313 11 DecalEffect 11 DecalEffect 0 0 0 0 3131 0 2 3129 3130 0 0 1 0 3613 0 0 0 0 151</span>
<span class="s0">/**</span>
 <span class="s0">* Applied to a GeomNode to indicate that the children of this GeomNode are</span>
 <span class="s0">* coplanar and should be drawn as decals (eliminating Z-fighting).</span>
 <span class="s0">*/</span>

<span class="s0">3717 17 DepthOffsetAttrib 0 141313 17 DepthOffsetAttrib 17 DepthOffsetAttrib 0 0 0 0 3139 4 4239 4240 4241 4242 7 3132 3133 3134 3135 3136 3137 3138 0 0 1 0 3591 0 0 0 0 1333</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special kind of attribute that instructs the graphics driver to</span>
 <span class="s0">* apply an offset or bias to the generated depth values for rendered</span>
 <span class="s0">* polygons, before they are written to the depth buffer.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to shift polygons forward slightly, to resolve depth</span>
 <span class="s0">* conflicts.  The cull traverser may optionally use this, for instance, to</span>
 <span class="s0">* implement decals.  However, driver support for this feature seems to be</span>
 <span class="s0">* spotty, so use with caution.</span>
 <span class="s0">*</span>
 <span class="s0">* The bias is always an integer number, and each integer increment represents</span>
 <span class="s0">* the smallest possible increment in Z that is sufficient to completely</span>
 <span class="s0">* resolve two coplanar polygons.  Positive numbers are closer towards the</span>
 <span class="s0">* camera.</span>
 <span class="s0">*</span>
 <span class="s0">* Nested DepthOffsetAttrib values accumulate; that is, a DepthOffsetAttrib</span>
 <span class="s0">* with a value of 1 beneath another DepthOffsetAttrib with a value of 2</span>
 <span class="s0">* presents a net offset of 3.  (A DepthOffsetAttrib will not, however,</span>
 <span class="s0">* combine with any other DepthOffsetAttribs with a lower override parameter.)</span>
 <span class="s0">* The net value should probably not exceed 16 or drop below 0 for maximum</span>
 <span class="s0">* portability.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, and only tangentially related, the DepthOffsetAttrib can be used to</span>
 <span class="s0">* constrain the Z output value to a subset of the usual [0, 1] range (or</span>
 <span class="s0">* reversing its direction) by specifying a new min_value and max_value.</span>
 <span class="s0">*/</span>

<span class="s0">3718 15 DepthTestAttrib 0 141313 15 DepthTestAttrib 15 DepthTestAttrib 0 0 0 0 3145 2 4243 4244 5 3140 3141 3142 3143 3144 0 0 1 0 3591 0 0 0 0 59</span>
<span class="s0">/**</span>
 <span class="s0">* Enables or disables writing to the depth buffer.</span>
 <span class="s0">*/</span>

<span class="s0">3719 16 DepthWriteAttrib 0 141313 16 DepthWriteAttrib 16 DepthWriteAttrib 0 0 0 0 3151 2 4245 4246 5 3146 3147 3148 3149 3150 0 0 1 0 3591 0 0 0 1 3720 59</span>
<span class="s0">/**</span>
 <span class="s0">* Enables or disables writing to the depth buffer.</span>
 <span class="s0">*/</span>

<span class="s0">3720 4 Mode 0 794624 22 DepthWriteAttrib::Mode 22 DepthWriteAttrib::Mode 3719 0 0 0 0 0 0 0 0 0 2 5 M_off 23 DepthWriteAttrib::M_off 0</span>
<span class="s0">0 4 M_on 22 DepthWriteAttrib::M_on 0</span>
<span class="s0">1 0 0</span>

<span class="s0">3721 5 Light 0 26625 5 Light 5 Light 0 0 0 0 3152 3 4247 4248 4249 14 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract interface to all kinds of lights.  The actual light objects</span>
 <span class="s0">* also inherit from PandaNode, and can therefore be added to the scene graph</span>
 <span class="s0">* at some arbitrary point to define the coordinate system of effect.</span>
 <span class="s0">*/</span>

<span class="s0">3722 11 LightAttrib 0 75777 11 LightAttrib 11 LightAttrib 0 0 0 0 0 3 4250 4251 4252 29 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 2 4314 4315 0 1 0 3591 0 0 0 1 3723 209</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates which set of lights should be considered &quot;on&quot; to illuminate</span>
 <span class="s0">* geometry at this level and below.  A LightAttrib can either add lights or</span>
 <span class="s0">* remove lights from the total set of &quot;on&quot; lights.</span>
 <span class="s0">*/</span>

<span class="s0">3723 9 Operation 0 794624 22 LightAttrib::Operation 22 LightAttrib::Operation 3722 0 0 0 0 0 0 0 0 0 3 5 O_set 18 LightAttrib::O_set 0</span>
<span class="s0">0 5 O_add 18 LightAttrib::O_add 0</span>
<span class="s0">1 8 O_remove 21 LightAttrib::O_remove 0</span>
<span class="s0">2 0 142</span>
<span class="s0">// This is the old, deprecated interface to LightAttrib.  Do not use any of</span>
<span class="s0">// these methods for new code; these methods will be removed soon.</span>

<span class="s0">3724 15 LightRampAttrib 0 141313 15 LightRampAttrib 15 LightRampAttrib 0 0 0 0 3208 2 4253 4254 12 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 0 0 1 0 3591 0 0 0 1 3725 302</span>
<span class="s0">/**</span>
 <span class="s0">* A Light Ramp is any unary operator that takes a rendered pixel as input,</span>
 <span class="s0">* and adjusts the brightness of that pixel.  For example, gamma correction is</span>
 <span class="s0">* a kind of light ramp.  So is HDR tone mapping.  So is cartoon shading.  See</span>
 <span class="s0">* the constructors for an explanation of each kind of ramp.</span>
 <span class="s0">*/</span>

<span class="s0">3725 13 LightRampMode 0 794624 30 LightRampAttrib::LightRampMode 30 LightRampAttrib::LightRampMode 3724 0 0 0 0 0 0 0 0 0 7 11 LRT_default 28 LightRampAttrib::LRT_default 0</span>
<span class="s0">0 12 LRT_identity 29 LightRampAttrib::LRT_identity 0</span>
<span class="s0">1 20 LRT_single_threshold 37 LightRampAttrib::LRT_single_threshold 0</span>
<span class="s0">2 20 LRT_double_threshold 37 LightRampAttrib::LRT_double_threshold 0</span>
<span class="s0">3 8 LRT_hdr0 25 LightRampAttrib::LRT_hdr0 0</span>
<span class="s0">4 8 LRT_hdr1 25 LightRampAttrib::LRT_hdr1 0</span>
<span class="s0">5 8 LRT_hdr2 25 LightRampAttrib::LRT_hdr2 0</span>
<span class="s0">6 0 0</span>

<span class="s0">3726 6 Loader 0 141313 6 Loader 6 Loader 0 0 0 1 3220 3237 0 16 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 0 0 2 3 3657 3209 3210 3 3616 3211 3212 0 1 3727 503</span>
<span class="s0">/**</span>
 <span class="s0">* A convenient class for loading models from disk, in bam or egg format (or</span>
 <span class="s0">* any of a number of other formats implemented by a LoaderFileType, such as</span>
 <span class="s0">* ptloader).</span>
 <span class="s0">*</span>
 <span class="s0">* This class supports synchronous as well as asynchronous loading.  In</span>
 <span class="s0">* asynchronous loading, the model is loaded in the background by a thread,</span>
 <span class="s0">* and an event will be generated when the model is available.  If threading</span>
 <span class="s0">* is not available, the asynchronous loading interface may be used, but it</span>
 <span class="s0">* loads synchronously.</span>
 <span class="s0">*/</span>

<span class="s0">3727 7 Results 0 288769 15 Loader::Results 15 Loader::Results 3726 0 0 1 3213 3215 0 5 3214 3216 3217 3218 3219 2 4316 4317 0 0 0 0 0</span>

<span class="s0">3728 14 LoaderFileType 0 75777 14 LoaderFileType 14 LoaderFileType 0 0 0 0 0 0 9 3238 3239 3240 3241 3242 3243 3244 3245 3246 0 0 1 0 3729 0 0 0 0 215</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for a family of scene-graph file types that the</span>
 <span class="s0">* Loader supports.  Each kind of loader that's available should define a</span>
 <span class="s0">* corresponding LoaderFileType object and register itself.</span>
 <span class="s0">*/</span>

<span class="s0">3729 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">3730 22 LoaderFileTypeRegistry 0 26625 22 LoaderFileTypeRegistry 22 LoaderFileTypeRegistry 0 0 0 1 3257 3247 1 4255 9 3248 3249 3250 3251 3252 3253 3254 3255 3256 1 4318 0 0 0 0 85</span>
<span class="s0">/**</span>
 <span class="s0">* This class maintains the set of all known LoaderFileTypes in the universe.</span>
 <span class="s0">*/</span>

<span class="s0">3731 16 LoaderFileType * 0 8576 16 LoaderFileType * 16 LoaderFileType * 0 0 3728 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3732 14 MaterialAttrib 0 141313 14 MaterialAttrib 14 MaterialAttrib 0 0 0 0 3265 2 4256 4257 7 3258 3259 3260 3261 3262 3263 3264 0 0 1 0 3591 0 0 0 0 202</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates which, if any, material should be applied to geometry.  The</span>
 <span class="s0">* material is used primarily to control lighting effects, and isn't necessary</span>
 <span class="s0">* (or useful) in the absence of lighting.</span>
 <span class="s0">*/</span>

<span class="s0">3733 10 Material * 0 8576 10 Material * 10 Material * 0 0 3734 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3734 8 Material 0 2048 8 Material 8 Material 0 0 0 0 0 0 0 0 0 0 0 0 682</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the way an object appears in the presence of lighting.  A material</span>
 <span class="s0">* is only necessary if lighting is to be enabled; otherwise, the material</span>
 <span class="s0">* isn't used.</span>
 <span class="s0">*</span>
 <span class="s0">* There are two workflows that are supported: the &quot;classic&quot; workflow of</span>
 <span class="s0">* providing separate ambient, diffuse and specular colors, and the</span>
 <span class="s0">* &quot;metalness&quot; workflow, in which a base color is specified along with a</span>
 <span class="s0">* &quot;metallic&quot; value that indicates whether the material is a metal or a</span>
 <span class="s0">* dielectric.</span>
 <span class="s0">*</span>
 <span class="s0">* The size of the specular highlight can be specified by either specifying</span>
 <span class="s0">* the specular exponent (shininess) or by specifying a roughness value that</span>
 <span class="s0">* in perceptually linear in the range of 0-1.</span>
 <span class="s0">*/</span>

<span class="s0">3735 19 ModelFlattenRequest 0 141313 19 ModelFlattenRequest 19 ModelFlattenRequest 0 0 0 1 3266 3271 1 4258 4 3267 3268 3269 3270 0 0 1 0 3736 0 0 0 0 287</span>
<span class="s0">/**</span>
 <span class="s0">* This class object manages a single asynchronous request to flatten a model.</span>
 <span class="s0">* The model will be duplicated and flattened in a sub-thread (if threading is</span>
 <span class="s0">* available), without affecting the original model; and when the result is</span>
 <span class="s0">* done it may be retrieved from this object.</span>
 <span class="s0">*/</span>

<span class="s0">3736 9 AsyncTask 0 2048 9 AsyncTask 9 AsyncTask 0 0 0 0 0 0 0 0 0 0 0 0 217</span>
<span class="s0">/**</span>
 <span class="s0">* This class represents a concrete task performed by an AsyncManager.</span>
 <span class="s0">* Normally, you would subclass from this class, and override do_task(), to</span>
 <span class="s0">* define the functionality you wish to have the task perform.</span>
 <span class="s0">*/</span>

<span class="s0">3737 16 ModelLoadRequest 0 141313 16 ModelLoadRequest 16 ModelLoadRequest 0 0 0 1 3272 3279 3 4259 4260 4261 6 3273 3274 3275 3276 3277 3278 0 0 1 0 3736 0 0 0 0 191</span>
<span class="s0">/**</span>
 <span class="s0">* A class object that manages a single asynchronous model load request.</span>
 <span class="s0">* Create a new ModelLoadRequest, and add it to the loader via load_async(),</span>
 <span class="s0">* to begin an asynchronous load.</span>
 <span class="s0">*/</span>

<span class="s0">3738 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 3739 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3739 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">3740 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 3741 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3741 13 LoaderOptions 0 2048 13 LoaderOptions 13 LoaderOptions 0 0 0 0 0 0 0 0 0 0 0 0 65</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies parameters that may be passed to the loader.</span>
 <span class="s0">*/</span>

<span class="s0">3742 8 Loader * 0 8576 8 Loader * 8 Loader * 0 0 3726 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3743 9 ModelNode 0 141313 9 ModelNode 9 ModelNode 0 0 0 1 3280 3287 0 6 3281 3282 3283 3284 3285 3286 0 0 1 0 3615 0 0 0 1 3744 411</span>
<span class="s0">/**</span>
 <span class="s0">* This node is placed at key points within the scene graph to indicate the</span>
 <span class="s0">* roots of &quot;models&quot;: subtrees that are conceptually to be treated as a single</span>
 <span class="s0">* unit, like a car or a room, for instance.  It doesn't affect rendering or</span>
 <span class="s0">* any other operations; it's primarily useful as a high-level model</span>
 <span class="s0">* indication.</span>
 <span class="s0">*</span>
 <span class="s0">* ModelNodes are created in response to a &lt;Model&gt; { 1 } flag within an egg</span>
 <span class="s0">* file.</span>
 <span class="s0">*/</span>

<span class="s0">3744 17 PreserveTransform 0 794624 28 ModelNode::PreserveTransform 28 ModelNode::PreserveTransform 3743 0 0 0 0 0 0 0 0 0 5 7 PT_none 18 ModelNode::PT_none 0</span>
<span class="s0">0 8 PT_local 19 ModelNode::PT_local 0</span>
<span class="s0">1 6 PT_net 17 ModelNode::PT_net 0</span>
<span class="s0">2 12 PT_drop_node 23 ModelNode::PT_drop_node 0</span>
<span class="s0">3 11 PT_no_touch 22 ModelNode::PT_no_touch 0</span>
<span class="s0">4 0 0</span>

<span class="s0">3745 9 ModelRoot 0 141313 9 ModelRoot 9 ModelRoot 0 0 0 1 3288 3299 4 4262 4263 4264 4265 8 3289 3290 3291 3292 3293 3296 3297 3298 0 0 1 0 3743 0 0 0 1 3748 314</span>
<span class="s0">/**</span>
 <span class="s0">* A node of this type is created automatically at the root of each model file</span>
 <span class="s0">* that is loaded.  It may eventually contain some information about the</span>
 <span class="s0">* contents of the model; at the moment, it contains no special information,</span>
 <span class="s0">* but can be used as a flag to indicate the presence of a loaded model file.</span>
 <span class="s0">*/</span>

<span class="s0">3746 6 time_t 0 2105344 6 time_t 6 time_t 0 0 3747 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3747 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3748 14 ModelReference 0 403457 25 ModelRoot::ModelReference 25 ModelRoot::ModelReference 3745 0 0 1 3294 3295 0 0 0 0 1 0 3715 0 0 0 0 60</span>
<span class="s0">// This class is used to unify references to the same model.</span>

<span class="s0">3749 16 ModelReference * 0 8576 27 ModelRoot::ModelReference * 27 ModelRoot::ModelReference * 0 0 3748 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3750 9 ModelPool 0 141313 9 ModelPool 9 ModelPool 0 0 0 0 3310 0 10 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 0 0 0 0 0 804</span>
<span class="s0">/**</span>
 <span class="s0">* This class unifies all references to the same filename, so that multiple</span>
 <span class="s0">* attempts to load the same model will return the same pointer.  Note that</span>
 <span class="s0">* the default behavior is thus to make instances: use with caution.  Use the</span>
 <span class="s0">* copy_subgraph() method on Node (or use NodePath::copy_to) to make</span>
 <span class="s0">* modifiable copies of the node.</span>
 <span class="s0">*</span>
 <span class="s0">* Unlike TexturePool, this class does not automatically resolve the model</span>
 <span class="s0">* filenames before loading, so a relative path and an absolute path to the</span>
 <span class="s0">* same model will appear to be different filenames.</span>
 <span class="s0">*</span>
 <span class="s0">* However, see the Loader class, which is now the preferred interface for</span>
 <span class="s0">* loading models.  The Loader class can resolve filenames, supports threaded</span>
 <span class="s0">* loading, and can automatically consult the ModelPool, according to the</span>
 <span class="s0">* supplied LoaderOptions.</span>
 <span class="s0">*/</span>

<span class="s0">3751 16 ModelSaveRequest 0 141313 16 ModelSaveRequest 16 ModelSaveRequest 0 0 0 1 3311 3319 4 4266 4267 4268 4269 7 3312 3313 3314 3315 3316 3317 3318 0 0 1 0 3736 0 0 0 0 191</span>
<span class="s0">/**</span>
 <span class="s0">* A class object that manages a single asynchronous model save request.</span>
 <span class="s0">* Create a new ModelSaveRequest, and add it to the loader via save_async(),</span>
 <span class="s0">* to begin an asynchronous save.</span>
 <span class="s0">*/</span>

<span class="s0">3752 13 TextureAttrib 0 141313 13 TextureAttrib 13 TextureAttrib 0 0 0 0 3349 5 4270 4271 4272 4273 4274 29 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3 4319 4320 4321 0 1 0 3591 0 0 0 0 130</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates the set of TextureStages and their associated Textures that</span>
 <span class="s0">* should be applied to (or removed from) a node.</span>
 <span class="s0">*/</span>

<span class="s0">3753 14 TextureStage * 0 8576 14 TextureStage * 14 TextureStage * 0 0 3754 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3754 12 TextureStage 0 2048 12 TextureStage 12 TextureStage 0 0 0 0 0 0 0 0 0 0 0 0 336</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the properties of a named stage of the multitexture pipeline.  The</span>
 <span class="s0">* TextureAttrib will associated a number of these stages with Texture</span>
 <span class="s0">* objects, and the GSG will render geometry by sorting all of the currently</span>
 <span class="s0">* active TextureStages in order and then issuing the appropriate rendering</span>
 <span class="s0">* calls to activate them.</span>
 <span class="s0">*/</span>

<span class="s0">3755 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 3756 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3756 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a texture object, which is typically a single 2-d image but may</span>
 <span class="s0">* also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube</span>
 <span class="s0">* map texture.</span>
 <span class="s0">*</span>
 <span class="s0">* A texture's image data might be stored in system RAM (see get_ram_image())</span>
 <span class="s0">* or its image may be represented in texture memory on one or more</span>
 <span class="s0">* GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern</span>
 <span class="s0">* is that a texture is loaded from an image file on disk, which copies its</span>
 <span class="s0">* image data into system RAM; then the first time the texture is rendered its</span>
 <span class="s0">* image data is copied to texture memory (actually, to the graphics API), and</span>
 <span class="s0">* the system RAM image is automatically freed.</span>
 <span class="s0">*/</span>

<span class="s0">3757 18 SamplerState const 0 8832 18 SamplerState const 18 SamplerState const 0 0 3758 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3758 12 SamplerState 0 2048 12 SamplerState 12 SamplerState 0 0 0 0 0 0 0 0 0 0 0 0 176</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a set of settings that indicate how a texture is sampled.  This</span>
 <span class="s0">* can be used to sample the same texture using different settings in</span>
 <span class="s0">* different places.</span>
 <span class="s0">*/</span>

<span class="s0">3759 12 TexGenAttrib 0 75777 12 TexGenAttrib 12 TexGenAttrib 0 0 0 0 0 1 4275 12 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 0 0 1 0 3591 0 0 0 0 281</span>
<span class="s0">/**</span>
 <span class="s0">* Computes texture coordinates for geometry automatically based on vertex</span>
 <span class="s0">* position and/or normal.  This can be used to implement reflection and/or</span>
 <span class="s0">* refraction maps, for instance to make shiny surfaces, as well as other</span>
 <span class="s0">* special effects such as projective texturing.</span>
 <span class="s0">*/</span>

<span class="s0">3760 12 OccluderNode 0 75777 12 OccluderNode 12 OccluderNode 0 0 0 1 3362 2131 3 4276 4277 4278 9 3363 3364 3365 3366 3367 3368 3369 3370 3371 1 4322 0 1 0 3615 0 0 0 0 272</span>
<span class="s0">/**</span>
 <span class="s0">* A node in the scene graph that can hold an occluder polygon, which must be</span>
 <span class="s0">* a rectangle.  When the occluder is activated with something like</span>
 <span class="s0">* render.set_occluder(), then objects whose bouding volume lies entirely</span>
 <span class="s0">* behind the occluder will not be rendered.</span>
 <span class="s0">*/</span>

<span class="s0">3761 14 OccluderEffect 0 141313 14 OccluderEffect 14 OccluderEffect 0 0 0 0 3380 0 8 3372 3373 3374 3375 3376 3377 3378 3379 1 4323 0 1 0 3613 0 0 0 0 336</span>
<span class="s0">/**</span>
 <span class="s0">* This functions similarly to a LightAttrib or ClipPlaneAttrib.  It indicates</span>
 <span class="s0">* the set of occluders that modify the geometry at this level and below.</span>
 <span class="s0">* Unlike a ClipPlaneAttrib, an OccluderEffect takes effect immediately when</span>
 <span class="s0">* it is encountered during traversal, and thus can only add occluders; it may</span>
 <span class="s0">* not remove them.</span>
 <span class="s0">*/</span>

<span class="s0">3762 13 PolylightNode 0 141313 13 PolylightNode 13 PolylightNode 0 0 0 1 3381 3418 0 36 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 0 0 1 0 3615 0 0 0 2 3763 3764 26</span>
<span class="s0">/**</span>
 <span class="s0">* A PolylightNode</span>
 <span class="s0">*/</span>

<span class="s0">3763 12 Flicker_Type 0 794624 27 PolylightNode::Flicker_Type 27 PolylightNode::Flicker_Type 3762 0 0 0 0 0 0 0 0 0 3 7 FRANDOM 22 PolylightNode::FRANDOM 0</span>
<span class="s0">0 4 FSIN 19 PolylightNode::FSIN 0</span>
<span class="s0">1 7 FCUSTOM 22 PolylightNode::FCUSTOM 0</span>
<span class="s0">2 0 0</span>

<span class="s0">3764 16 Attenuation_Type 0 794624 31 PolylightNode::Attenuation_Type 31 PolylightNode::Attenuation_Type 3762 0 0 0 0 0 0 0 0 0 2 7 ALINEAR 22 PolylightNode::ALINEAR 0</span>
<span class="s0">0 10 AQUADRATIC 25 PolylightNode::AQUADRATIC 0</span>
<span class="s0">1 0 0</span>

<span class="s0">3765 15 PolylightEffect 0 141313 15 PolylightEffect 15 PolylightEffect 0 0 0 0 3430 0 11 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 0 0 1 0 3613 0 0 0 2 3766 3767 306</span>
<span class="s0">/**</span>
 <span class="s0">* A PolylightEffect can be used on a node to define a LightGroup  for that</span>
 <span class="s0">* node.  A LightGroup contains PolylightNodes which are essentially nodes</span>
 <span class="s0">* that add color to the polygons of a model based on distance.  PolylightNode</span>
 <span class="s0">* is a cheap way to get lighting effects specially for night scenes</span>
 <span class="s0">*/</span>

<span class="s0">3766 11 ContribType 0 794624 28 PolylightEffect::ContribType 28 PolylightEffect::ContribType 3765 0 0 0 0 0 0 0 0 0 2 11 CT_proximal 28 PolylightEffect::CT_proximal 0</span>
<span class="s0">0 6 CT_all 23 PolylightEffect::CT_all 0</span>
<span class="s0">1 0 0</span>

<span class="s0">3767 10 LightGroup 0 2367488 27 PolylightEffect::LightGroup 27 PolylightEffect::LightGroup 3765 0 3768 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3768 19 pvector&lt; NodePath &gt; 0 2048 19 pvector&lt; NodePath &gt; 19 pvector&lt; NodePath &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3769 12 ShaderAttrib 0 141313 12 ShaderAttrib 12 ShaderAttrib 0 0 0 0 3467 3 4279 4280 4281 36 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 0 0 1 0 3591 0 0 0 1 3770 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">3770 0 0 794624 14 ShaderAttrib:: 0 3769 0 0 0 0 0 0 0 0 0 4 21 F_disable_alpha_write 35 ShaderAttrib::F_disable_alpha_write 49</span>
<span class="s0">// Suppress writes to color buffer alpha channel.</span>
<span class="s0">0 20 F_subsume_alpha_test 34 ShaderAttrib::F_subsume_alpha_test 58</span>
<span class="s0">// Shader promises to subsume the alpha test using TEXKILL</span>
<span class="s0">1 19 F_hardware_skinning 33 ShaderAttrib::F_hardware_skinning 37</span>
<span class="s0">// Shader needs pre-animated vertices</span>
<span class="s0">2 19 F_shader_point_size 33 ShaderAttrib::F_shader_point_size 51</span>
<span class="s0">// Shader provides point size, not RenderModeAttrib</span>
<span class="s0">3 0 0</span>

<span class="s0">3771 14 Shader const * 0 8576 14 Shader const * 14 Shader const * 0 0 3772 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3772 12 Shader const 0 8832 12 Shader const 12 Shader const 0 0 3773 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3773 6 Shader 0 2048 6 Shader 6 Shader 0 0 0 0 0 0 0 0 0 0 0 0 8</span>
<span class="s0">/**</span>

 <span class="s0">*/</span>

<span class="s0">3774 16 ShowBoundsEffect 0 141313 16 ShowBoundsEffect 16 ShowBoundsEffect 0 0 0 0 3471 0 3 3468 3469 3470 0 0 1 0 3613 0 0 0 0 189</span>
<span class="s0">/**</span>
 <span class="s0">* Applied to a GeomNode to cause a visible bounding volume to be drawn for</span>
 <span class="s0">* this node.  This is generally used only during development to help identify</span>
 <span class="s0">* bounding volume issues.</span>
 <span class="s0">*/</span>

<span class="s0">3775 18 TexProjectorEffect 0 75777 18 TexProjectorEffect 18 TexProjectorEffect 0 0 0 0 0 0 9 3472 3473 3474 3475 3476 3477 3478 3479 3480 0 0 1 0 3613 0 0 0 0 1344</span>
<span class="s0">/**</span>
 <span class="s0">* This effect automatically applies a computed texture matrix to the</span>
 <span class="s0">* specified texture stage, according to the relative position of two</span>
 <span class="s0">* specified nodes.</span>
 <span class="s0">*</span>
 <span class="s0">* The relative transform from the &quot;from&quot; node to the &quot;to&quot; node is applied</span>
 <span class="s0">* directly to the texture matrix each frame.  If the &quot;to&quot; node happens to be</span>
 <span class="s0">* a LensNode, its lens projection matrix is applied as well.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used to apply a number of special effects.  Fundamentally, it</span>
 <span class="s0">* may simply be used to provide a separate PandaNode that may be adjusted</span>
 <span class="s0">* (e.g.  via a LerpInterval) in order to easily apply a linear transformation</span>
 <span class="s0">* to an object's texture coordinates (rather than having to explicitly call</span>
 <span class="s0">* NodePath.set_tex_transform() each frame).</span>
 <span class="s0">*</span>
 <span class="s0">* In a more sophisticated case, the TexProjectorEffect is particularly useful</span>
 <span class="s0">* in conjunction with a TexGenAttrib that specifies a mode of</span>
 <span class="s0">* M_world_position (which copies the world position of each vertex to the</span>
 <span class="s0">* texture coordinates).  Then the TexProjector can be used to convert these</span>
 <span class="s0">* world coordinates to the relative coordinates of a particular node, causing</span>
 <span class="s0">* (for instance) a texture to appear to follow a node around as it moves</span>
 <span class="s0">* through the world.  With a LensNode, you can project a texture onto the</span>
 <span class="s0">* walls, for instance to apply a flashlight effect or an image-based shadow.</span>
 <span class="s0">*/</span>

<span class="s0">3776 13 ScissorEffect 0 141313 13 ScissorEffect 13 ScissorEffect 0 0 0 0 3491 0 10 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 2 4324 4325 0 1 0 3613 0 0 0 0 219</span>
<span class="s0">/**</span>
 <span class="s0">* This provides a higher-level wrapper around ScissorAttrib.  It allows for</span>
 <span class="s0">* the scissor region to be defined via points relative to the current node,</span>
 <span class="s0">* and also performs culling based on the scissor region.</span>
 <span class="s0">*/</span>

<span class="s0">3777 17 SceneGraphReducer 0 26625 17 SceneGraphReducer 17 SceneGraphReducer 0 0 0 1 3492 3493 0 17 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 0 0 0 0 4 3778 3779 3780 3781 341</span>
<span class="s0">/**</span>
 <span class="s0">* An interface for simplifying (&quot;flattening&quot;) scene graphs by eliminating</span>
 <span class="s0">* unneeded nodes and collapsing out unneeded state changes and transforms.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is designed so that it may be inherited from and specialized, if</span>
 <span class="s0">* needed, to fine-tune the flattening behavior, but normally the default</span>
 <span class="s0">* behavior is sufficient.</span>
 <span class="s0">*/</span>

<span class="s0">3778 11 AttribTypes 0 794624 30 SceneGraphReducer::AttribTypes 30 SceneGraphReducer::AttribTypes 3777 0 0 0 0 0 0 0 0 0 8 12 TT_transform 31 SceneGraphReducer::TT_transform 0</span>
<span class="s0">1 8 TT_color 27 SceneGraphReducer::TT_color 0</span>
<span class="s0">2 14 TT_color_scale 33 SceneGraphReducer::TT_color_scale 0</span>
<span class="s0">4 13 TT_tex_matrix 32 SceneGraphReducer::TT_tex_matrix 0</span>
<span class="s0">8 13 TT_clip_plane 32 SceneGraphReducer::TT_clip_plane 0</span>
<span class="s0">16 12 TT_cull_face 31 SceneGraphReducer::TT_cull_face 0</span>
<span class="s0">32 22 TT_apply_texture_color 41 SceneGraphReducer::TT_apply_texture_color 0</span>
<span class="s0">64 8 TT_other 27 SceneGraphReducer::TT_other 0</span>
<span class="s0">128 0 0</span>

<span class="s0">3779 15 CombineSiblings 0 794624 34 SceneGraphReducer::CombineSiblings 34 SceneGraphReducer::CombineSiblings 3777 0 0 0 0 0 0 0 0 0 4 12 CS_geom_node 31 SceneGraphReducer::CS_geom_node 0</span>
<span class="s0">1 16 CS_within_radius 35 SceneGraphReducer::CS_within_radius 0</span>
<span class="s0">2 8 CS_other 27 SceneGraphReducer::CS_other 0</span>
<span class="s0">4 10 CS_recurse 29 SceneGraphReducer::CS_recurse 0</span>
<span class="s0">8 0 0</span>

<span class="s0">3780 17 CollectVertexData 0 794624 36 SceneGraphReducer::CollectVertexData 36 SceneGraphReducer::CollectVertexData 3777 0 0 0 0 0 0 0 0 0 8 8 CVD_name 27 SceneGraphReducer::CVD_name 86</span>
<span class="s0">// If set, two GeomVertexDatas with different names will not be collected</span>
<span class="s0">// together.</span>
<span class="s0">1 9 CVD_model 28 SceneGraphReducer::CVD_model 129</span>
<span class="s0">// If set, a ModelNode begins a subgraph of nodes whose GeomVertexDatas</span>
<span class="s0">// will not be collected with nodes outside the subgraph.</span>
<span class="s0">2 13 CVD_transform 32 SceneGraphReducer::CVD_transform 142</span>
<span class="s0">// If set, a non-identity transform begins a subgraph of nodes whose</span>
<span class="s0">// GeomVertexDatas will not be collected with nodes outside the subgraph.</span>
<span class="s0">4 17 CVD_avoid_dynamic 36 SceneGraphReducer::CVD_avoid_dynamic 237</span>
<span class="s0">// If set, GeomVertexDatas with any usage_hint other than UH_static will</span>
<span class="s0">// not be collected with any other Geoms in a different GeomNode.</span>
<span class="s0">// However, two different dynamic Geoms within the same node might still</span>
<span class="s0">// be collected together.</span>
<span class="s0">8 17 CVD_one_node_only 36 SceneGraphReducer::CVD_one_node_only 90</span>
<span class="s0">// If set, only those GeomVertexDatas within the same node might be</span>
<span class="s0">// collected together.</span>
<span class="s0">16 10 CVD_format 29 SceneGraphReducer::CVD_format 230</span>
<span class="s0">// If set, two GeomVertexDatas with different formats will not be</span>
<span class="s0">// collected together.  If not set, GeomVertexDatas of different formats</span>
<span class="s0">// may be combined by expanding all GeomVertexDatas to the union of all</span>
<span class="s0">// defined columns.</span>
<span class="s0">32 14 CVD_usage_hint 33 SceneGraphReducer::CVD_usage_hint 134</span>
<span class="s0">// If set, two GeomVertexDatas with different usage hints (for instance,</span>
<span class="s0">// UH_static vs.  UH_dynamic) will not be collected together.</span>
<span class="s0">64 18 CVD_animation_type 37 SceneGraphReducer::CVD_animation_type 120</span>
<span class="s0">// If set, GeomVertexDatas with unanimated vertices will not be combined</span>
<span class="s0">// with GeomVertexDatas with animated vertices.</span>
<span class="s0">128 0 0</span>

<span class="s0">3781 14 MakeNonindexed 0 794624 33 SceneGraphReducer::MakeNonindexed 33 SceneGraphReducer::MakeNonindexed 3777 0 0 0 0 0 0 0 0 0 3 17 MN_composite_only 36 SceneGraphReducer::MN_composite_only 155</span>
<span class="s0">// If set, only composite primitives such as tristrips and trifans will be</span>
<span class="s0">// made nonindexed; simple primitives such as triangles will be left</span>
<span class="s0">// indexed.</span>
<span class="s0">1 17 MN_avoid_animated 36 SceneGraphReducer::MN_avoid_animated 163</span>
<span class="s0">// If set any GeomVertexData with any animation indication will not be</span>
<span class="s0">// adjusted, whether the animation is to be performed on the CPU or on the</span>
<span class="s0">// graphics pipe.</span>
<span class="s0">2 16 MN_avoid_dynamic 35 SceneGraphReducer::MN_avoid_dynamic 108</span>
<span class="s0">// If set, any GeomVertexData or Geom with a usage_hint other than</span>
<span class="s0">// UH_static will not be made nonindexed.</span>
<span class="s0">4 0 0</span>

<span class="s0">3782 13 ParamNodePath 0 141313 13 ParamNodePath 13 ParamNodePath 0 0 0 1 3513 3516 0 2 3514 3515 0 0 1 0 3783 0 0 0 0 64</span>
<span class="s0">/**</span>
 <span class="s0">* A class object for storing a NodePath as a parameter.</span>
 <span class="s0">*/</span>

<span class="s0">3783 14 ParamValueBase 0 2048 14 ParamValueBase 14 ParamValueBase 0 0 0 0 0 0 0 0 0 0 0 0 141</span>
<span class="s0">/**</span>
 <span class="s0">* A non-template base class of ParamValue (below), which serves mainly to</span>
 <span class="s0">* define the placeholder for the virtual output function.</span>
 <span class="s0">*/</span>

<span class="s0">3784 10 PortalNode 0 75777 10 PortalNode 10 PortalNode 0 0 0 1 3517 2131 10 4282 4283 4284 4285 4286 4287 4288 4289 4290 4291 24 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 1 4326 0 1 0 3615 0 0 0 0 217</span>
<span class="s0">/**</span>
 <span class="s0">* A node in the scene graph that can hold a Portal Polygon, which is a</span>
 <span class="s0">* rectangle.  Other types of polygons are not supported for now.  It also</span>
 <span class="s0">* holds a PT(PandaNode) Cell that this portal is connected to</span>
 <span class="s0">*/</span>

<span class="s0">3785 10 PortalMask 0 2105344 10 PortalMask 10 PortalMask 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3786 13 ScissorAttrib 0 141313 13 ScissorAttrib 13 ScissorAttrib 0 0 0 0 3549 2 4292 4293 7 3542 3543 3544 3545 3546 3547 3548 0 0 1 0 3591 0 0 0 0 528</span>
<span class="s0">/**</span>
 <span class="s0">* This restricts rendering to within a rectangular region of the scene,</span>
 <span class="s0">* without otherwise affecting the viewport or lens properties.  Geometry that</span>
 <span class="s0">* falls outside the scissor region is not rendered.  It is akin to the OpenGL</span>
 <span class="s0">* glScissor() function.</span>
 <span class="s0">*</span>
 <span class="s0">* The ScissorAttrib always specifies its region relative to its enclosing</span>
 <span class="s0">* DisplayRegion, in screen space, and performs no culling.</span>
 <span class="s0">*</span>
 <span class="s0">* See ScissorEffect if you wish to define a region relative to 2-D or 3-D</span>
 <span class="s0">* coordinates in the scene graph, with culling.</span>
 <span class="s0">*/</span>

<span class="s0">3787 16 ShadeModelAttrib 0 141313 16 ShadeModelAttrib 16 ShadeModelAttrib 0 0 0 0 3555 2 4294 4295 5 3550 3551 3552 3553 3554 0 0 1 0 3591 0 0 0 1 3788 103</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies whether flat shading (per-polygon) or smooth shading (per-vertex)</span>
 <span class="s0">* is in effect.</span>
 <span class="s0">*/</span>

<span class="s0">3788 4 Mode 0 794624 22 ShadeModelAttrib::Mode 22 ShadeModelAttrib::Mode 3787 0 0 0 0 0 0 0 0 0 2 6 M_flat 24 ShadeModelAttrib::M_flat 0</span>
<span class="s0">0 8 M_smooth 26 ShadeModelAttrib::M_smooth 0</span>
<span class="s0">1 0 0</span>

<span class="s0">3789 13 StencilAttrib 0 141313 13 StencilAttrib 13 StencilAttrib 0 0 0 0 3565 1 4296 9 3556 3557 3558 3559 3560 3561 3562 3563 3564 0 0 1 0 3591 0 0 0 3 3790 3791 3792 312</span>
<span class="s0">/**</span>
 <span class="s0">* A StencilAttrib is a collection of all stencil render states.  The render</span>
 <span class="s0">* states in a StencilAttrib are read-only.  A StencilAttrib is created with</span>
 <span class="s0">* make or make_2_sided.  To determine if two sided stencil is supported, call</span>
 <span class="s0">* the function GraphicsStateGuardian:: get_supports_two_sided_stencil.</span>
 <span class="s0">*/</span>

<span class="s0">3790 18 StencilRenderState 0 794624 33 StencilAttrib::StencilRenderState 33 StencilAttrib::StencilRenderState 3789 0 0 0 0 0 0 0 0 0 14 29 SRS_front_comparison_function 44 StencilAttrib::SRS_front_comparison_function 0</span>
<span class="s0">0 32 SRS_front_stencil_fail_operation 47 StencilAttrib::SRS_front_stencil_fail_operation 0</span>
<span class="s0">1 39 SRS_front_stencil_pass_z_fail_operation 54 StencilAttrib::SRS_front_stencil_pass_z_fail_operation 0</span>
<span class="s0">2 39 SRS_front_stencil_pass_z_pass_operation 54 StencilAttrib::SRS_front_stencil_pass_z_pass_operation 0</span>
<span class="s0">3 13 SRS_reference 28 StencilAttrib::SRS_reference 0</span>
<span class="s0">4 13 SRS_read_mask 28 StencilAttrib::SRS_read_mask 0</span>
<span class="s0">5 14 SRS_write_mask 29 StencilAttrib::SRS_write_mask 0</span>
<span class="s0">6 28 SRS_back_comparison_function 43 StencilAttrib::SRS_back_comparison_function 0</span>
<span class="s0">7 31 SRS_back_stencil_fail_operation 46 StencilAttrib::SRS_back_stencil_fail_operation 0</span>
<span class="s0">8 38 SRS_back_stencil_pass_z_fail_operation 53 StencilAttrib::SRS_back_stencil_pass_z_fail_operation 0</span>
<span class="s0">9 38 SRS_back_stencil_pass_z_pass_operation 53 StencilAttrib::SRS_back_stencil_pass_z_pass_operation 0</span>
<span class="s0">10 9 SRS_clear 24 StencilAttrib::SRS_clear 0</span>
<span class="s0">11 15 SRS_clear_value 30 StencilAttrib::SRS_clear_value 0</span>
<span class="s0">12 9 SRS_total 24 StencilAttrib::SRS_total 0</span>
<span class="s0">13 0 80</span>
<span class="s0">// enums are duplicated here from class StencilRenderStates for use in</span>
<span class="s0">// Python</span>

<span class="s0">3791 25 StencilComparisonFunction 0 794624 40 StencilAttrib::StencilComparisonFunction 40 StencilAttrib::StencilComparisonFunction 3789 0 0 0 0 0 0 0 0 0 8 9 SCF_never 24 StencilAttrib::SCF_never 0</span>
<span class="s0">1 13 SCF_less_than 28 StencilAttrib::SCF_less_than 0</span>
<span class="s0">2 9 SCF_equal 24 StencilAttrib::SCF_equal 0</span>
<span class="s0">3 22 SCF_less_than_or_equal 37 StencilAttrib::SCF_less_than_or_equal 0</span>
<span class="s0">4 16 SCF_greater_than 31 StencilAttrib::SCF_greater_than 0</span>
<span class="s0">5 13 SCF_not_equal 28 StencilAttrib::SCF_not_equal 0</span>
<span class="s0">6 25 SCF_greater_than_or_equal 40 StencilAttrib::SCF_greater_than_or_equal 0</span>
<span class="s0">7 10 SCF_always 25 StencilAttrib::SCF_always 0</span>
<span class="s0">8 0 44</span>
<span class="s0">// Exists purely for backward compatibility.</span>

<span class="s0">3792 16 StencilOperation 0 794624 31 StencilAttrib::StencilOperation 31 StencilAttrib::StencilOperation 3789 0 0 0 0 0 0 0 0 0 8 7 SO_keep 22 StencilAttrib::SO_keep 0</span>
<span class="s0">0 7 SO_zero 22 StencilAttrib::SO_zero 0</span>
<span class="s0">1 10 SO_replace 25 StencilAttrib::SO_replace 0</span>
<span class="s0">2 12 SO_increment 27 StencilAttrib::SO_increment 0</span>
<span class="s0">3 12 SO_decrement 27 StencilAttrib::SO_decrement 0</span>
<span class="s0">4 9 SO_invert 24 StencilAttrib::SO_invert 0</span>
<span class="s0">5 21 SO_increment_saturate 36 StencilAttrib::SO_increment_saturate 0</span>
<span class="s0">6 21 SO_decrement_saturate 36 StencilAttrib::SO_decrement_saturate 0</span>
<span class="s0">7 0 0</span>

<span class="s0">3793 10 ShaderPool 0 141313 10 ShaderPool 10 ShaderPool 0 0 0 0 3575 0 9 3566 3567 3568 3569 3570 3571 3572 3573 3574 0 0 0 0 0 189</span>
<span class="s0">/**</span>
 <span class="s0">* This is the preferred interface for loading shaders for the TextNode</span>
 <span class="s0">* system.  It is similar to ModelPool and TexturePool in that it unifies</span>
 <span class="s0">* references to the same filename.</span>
 <span class="s0">*/</span>

<span class="s0">3794 22 TransformState const * 0 8576 22 TransformState const * 22 TransformState const * 0 0 3795 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3795 20 TransformState const 0 8832 20 TransformState const 20 TransformState const 0 0 3576 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3796 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3797 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3797 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3798 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 3581 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3799 19 LQuaternion const * 0 8576 19 LQuaternion const * 19 LQuaternion const * 0 0 3584 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3800 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 3587 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3801 17 LVecBase2 const * 0 8576 17 LVecBase2 const * 17 LVecBase2 const * 0 0 3802 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3802 15 LVecBase2 const 0 8832 15 LVecBase2 const 15 LVecBase2 const 0 0 3803 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3803 9 LVecBase2 0 2105344 9 LVecBase2 9 LVecBase2 0 0 3804 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3804 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">3805 16 LMatrix3 const * 0 8576 16 LMatrix3 const * 16 LMatrix3 const * 0 0 3806 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3806 14 LMatrix3 const 0 8832 14 LMatrix3 const 14 LMatrix3 const 0 0 3807 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3807 8 LMatrix3 0 2105344 8 LMatrix3 8 LMatrix3 0 0 3808 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3808 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 3-by-3 transform matrix.  It typically will represent either a</span>
 <span class="s0">* rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix</span>
 <span class="s0">* (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.</span>
 <span class="s0">*/</span>

<span class="s0">3809 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 3578 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3810 11 LVecBase2 * 0 8576 11 LVecBase2 * 11 LVecBase2 * 0 0 3803 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3811 10 LMatrix3 * 0 8576 10 LMatrix3 * 10 LMatrix3 * 0 0 3807 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3812 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3813 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3814 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3814 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3815 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">3816 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3815 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3817 28 RenderAttribRegistry const * 0 8576 28 RenderAttribRegistry const * 28 RenderAttribRegistry const * 0 0 3818 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3818 26 RenderAttribRegistry const 0 8832 26 RenderAttribRegistry const 26 RenderAttribRegistry const 0 0 3590 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3819 22 RenderAttribRegistry * 0 8576 22 RenderAttribRegistry * 22 RenderAttribRegistry * 0 0 3590 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3820 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3601 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3821 24 RenderModeAttrib const * 0 8576 24 RenderModeAttrib const * 24 RenderModeAttrib const * 0 0 3822 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3822 22 RenderModeAttrib const 0 8832 22 RenderModeAttrib const 22 RenderModeAttrib const 0 0 3596 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3823 23 TexMatrixAttrib const * 0 8576 23 TexMatrixAttrib const * 23 TexMatrixAttrib const * 0 0 3824 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3824 21 TexMatrixAttrib const 0 8832 21 TexMatrixAttrib const 21 TexMatrixAttrib const 0 0 3605 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3825 19 RenderState const * 0 8576 19 RenderState const * 19 RenderState const * 0 0 3826 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3826 17 RenderState const 0 8832 17 RenderState const 17 RenderState const 0 0 3606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3827 10 SlotMask * 0 8576 23 RenderState::SlotMask * 23 RenderState::SlotMask * 0 0 3828 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3828 8 SlotMask 0 2367488 21 RenderState::SlotMask 21 RenderState::SlotMask 3606 0 3829 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3829 8 SlotMask 0 2367488 30 RenderAttribRegistry::SlotMask 30 RenderAttribRegistry::SlotMask 3590 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3830 15 CullTraverser * 0 8576 15 CullTraverser * 15 CullTraverser * 0 0 3709 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3831 25 CullTraverserData const * 0 8576 25 CullTraverserData const * 25 CullTraverserData const * 0 0 3832 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3832 23 CullTraverserData const 0 8832 23 CullTraverserData const 23 CullTraverserData const 0 0 3703 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3833 23 AlphaTestAttrib const * 0 8576 23 AlphaTestAttrib const * 23 AlphaTestAttrib const * 0 0 3834 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3834 21 AlphaTestAttrib const 0 8832 21 AlphaTestAttrib const 21 AlphaTestAttrib const 0 0 3609 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3835 23 AntialiasAttrib const * 0 8576 23 AntialiasAttrib const * 23 AntialiasAttrib const * 0 0 3836 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3836 21 AntialiasAttrib const 0 8832 21 AntialiasAttrib const 21 AntialiasAttrib const 0 0 3610 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3837 20 RenderEffect const * 0 8576 20 RenderEffect const * 20 RenderEffect const * 0 0 3838 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3838 18 RenderEffect const 0 8832 18 RenderEffect const 18 RenderEffect const 0 0 3613 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3839 21 RenderEffects const * 0 8576 21 RenderEffects const * 21 RenderEffects const * 0 0 3840 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3840 19 RenderEffects const 0 8832 19 RenderEffects const 19 RenderEffects const 0 0 3614 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3841 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3842 17 PandaNode const * 0 8576 17 PandaNode const * 17 PandaNode const * 0 0 3843 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3843 15 PandaNode const 0 8832 15 PandaNode const 15 PandaNode const 0 0 3615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3844 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 3845 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3845 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 396</span>
<span class="s0">/**</span>
 <span class="s0">* A thread; that is, a lightweight process.  This is an abstract base class;</span>
 <span class="s0">* to use it, you must subclass from it and redefine thread_main().</span>
 <span class="s0">*</span>
 <span class="s0">* The thread itself will keep a reference count on the Thread object while it</span>
 <span class="s0">* is running; when the thread returns from its root function, the Thread</span>
 <span class="s0">* object will automatically be destructed if no other pointers are</span>
 <span class="s0">* referencing it.</span>
 <span class="s0">*/</span>

<span class="s0">3846 9 Stashed * 0 8576 20 PandaNode::Stashed * 20 PandaNode::Stashed * 0 0 3636 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3847 9 visitproc 0 2105344 9 visitproc 9 visitproc 0 0 3848 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3848 6 void * 0 8576 6 void * 6 void * 0 0 3812 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3849 10 DrawMask * 0 8576 10 DrawMask * 10 DrawMask * 0 0 3627 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3850 13 CollideMask * 0 8576 13 CollideMask * 13 CollideMask * 0 0 3630 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3851 27 GraphicsStateGuardianBase * 0 8576 27 GraphicsStateGuardianBase * 27 GraphicsStateGuardianBase * 0 0 3852 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3852 25 GraphicsStateGuardianBase 0 2048 25 GraphicsStateGuardianBase 25 GraphicsStateGuardianBase 0 0 0 0 0 0 0 0 0 0 0 0 607</span>
<span class="s0">/**</span>
 <span class="s0">* This is a base class for the GraphicsStateGuardian class, which is itself a</span>
 <span class="s0">* base class for the various GSG's for different platforms.  This class</span>
 <span class="s0">* contains all the function prototypes to support the double-dispatch of GSG</span>
 <span class="s0">* to geoms, transitions, etc.  It lives in a separate class in its own</span>
 <span class="s0">* package so we can avoid circular build dependency problems.</span>
 <span class="s0">*</span>
 <span class="s0">* GraphicsStateGuardians are not actually writable to bam files, of course,</span>
 <span class="s0">* but they may be passed as event parameters, so they inherit from</span>
 <span class="s0">* TypedWritableReferenceCount instead of TypedReferenceCount for that</span>
 <span class="s0">* convenience.</span>
 <span class="s0">*/</span>

<span class="s0">3853 22 BoundingVolume const * 0 8576 22 BoundingVolume const * 22 BoundingVolume const * 0 0 3854 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3854 20 BoundingVolume const 0 8832 20 BoundingVolume const 20 BoundingVolume const 0 0 3632 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3855 11 UpdateSeq * 0 8576 11 UpdateSeq * 11 UpdateSeq * 0 0 3856 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3856 9 UpdateSeq 0 2048 9 UpdateSeq 9 UpdateSeq 0 0 0 0 0 0 0 0 0 0 0 0 761</span>
<span class="s0">/**</span>
 <span class="s0">* This is a sequence number that increments monotonically.  It can be used to</span>
 <span class="s0">* track cache updates, or serve as a kind of timestamp for any changing</span>
 <span class="s0">* properties.</span>
 <span class="s0">*</span>
 <span class="s0">* A special class is used instead of simply an int, so we can elegantly</span>
 <span class="s0">* handle such things as wraparound and special cases.  There are two special</span>
 <span class="s0">* cases.  Firstly, a sequence number is 'initial' when it is first created.</span>
 <span class="s0">* This sequence is older than any other sequence number.  Secondly, a</span>
 <span class="s0">* sequence number may be explicitly set to 'old'.  This is older than any</span>
 <span class="s0">* other sequence number except 'initial'.  Finally, we have the explicit</span>
 <span class="s0">* number 'fresh', which is newer than any other sequence number.  All other</span>
 <span class="s0">* sequences are numeric and are monotonically increasing.</span>
 <span class="s0">*/</span>

<span class="s0">3857 7 Light * 0 8576 7 Light * 7 Light * 0 0 3721 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3858 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 3859 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3859 24 pvector&lt; unsigned char &gt; 0 2048 24 pvector&lt; unsigned char &gt; 24 pvector&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3860 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 3592 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3861 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 3616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3862 16 LinkedListNode * 0 8576 16 LinkedListNode * 16 LinkedListNode * 0 0 3617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3863 16 Children const * 0 8576 27 PandaNode::Children const * 27 PandaNode::Children const * 0 0 3864 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3864 14 Children const 0 8832 25 PandaNode::Children const 25 PandaNode::Children const 0 0 3635 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3865 15 Stashed const * 0 8576 26 PandaNode::Stashed const * 26 PandaNode::Stashed const * 0 0 3866 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3866 13 Stashed const 0 8832 24 PandaNode::Stashed const 24 PandaNode::Stashed const 0 0 3636 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3867 15 Parents const * 0 8576 26 PandaNode::Parents const * 26 PandaNode::Parents const * 0 0 3868 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3868 13 Parents const 0 8832 24 PandaNode::Parents const 24 PandaNode::Parents const 0 0 3637 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3869 26 TransparencyAttrib const * 0 8576 26 TransparencyAttrib const * 26 TransparencyAttrib const * 0 0 3870 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3870 24 TransparencyAttrib const 0 8832 24 TransparencyAttrib const 24 TransparencyAttrib const 0 0 3638 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3871 21 LogicOpAttrib const * 0 8576 21 LogicOpAttrib const * 21 LogicOpAttrib const * 0 0 3872 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3872 19 LogicOpAttrib const 0 8832 19 LogicOpAttrib const 19 LogicOpAttrib const 0 0 3640 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3873 20 InternalName const * 0 8576 20 InternalName const * 20 InternalName const * 0 0 3874 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3874 18 InternalName const 0 8832 18 InternalName const 18 InternalName const 0 0 3875 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3875 12 InternalName 0 16779264 12 InternalName 12 InternalName 0 0 0 0 0 0 0 0 0 0 0 0 514</span>
<span class="s0">/**</span>
 <span class="s0">* Encodes a string name in a hash table, mapping it to a pointer.  This is</span>
 <span class="s0">* used to tokenify names so they may be used efficiently in low-level Panda</span>
 <span class="s0">* structures, for instance to differentiate the multiple sets of texture</span>
 <span class="s0">* coordinates that might be stored on a Geom.</span>
 <span class="s0">*</span>
 <span class="s0">* InternalNames are hierarchical, with the '.' used by convention as a</span>
 <span class="s0">* separator character.  You can construct a single InternalName as a</span>
 <span class="s0">* composition of one or more other names, or by giving it a source string</span>
 <span class="s0">* directly.</span>
 <span class="s0">*/</span>

<span class="s0">3876 13 ShaderInput * 0 8576 13 ShaderInput * 13 ShaderInput * 0 0 3642 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3877 20 SamplerState const * 0 8576 20 SamplerState const * 20 SamplerState const * 0 0 3757 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3878 19 ShaderInput const * 0 8576 19 ShaderInput const * 19 ShaderInput const * 0 0 3879 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3879 17 ShaderInput const 0 8832 17 ShaderInput const 17 ShaderInput const 0 0 3642 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3880 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 3688 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3881 21 ShaderPtrData const * 0 8576 29 Shader::ShaderPtrData const * 29 Shader::ShaderPtrData const * 0 0 3882 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3882 19 ShaderPtrData const 0 8832 27 Shader::ShaderPtrData const 27 Shader::ShaderPtrData const 0 0 3883 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3883 13 ShaderPtrData 0 263168 21 Shader::ShaderPtrData 21 Shader::ShaderPtrData 3773 0 0 0 0 0 0 0 0 0 0 0 60</span>
<span class="s0">// Container structure for data of parameters ShaderPtrSpec.</span>

<span class="s0">3884 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 3669 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3885 24 InternalNameCollection * 0 8576 24 InternalNameCollection * 24 InternalNameCollection * 0 0 3645 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3886 30 InternalNameCollection const * 0 8576 30 InternalNameCollection const * 30 InternalNameCollection const * 0 0 3887 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3887 28 InternalNameCollection const 0 8832 28 InternalNameCollection const 28 InternalNameCollection const 0 0 3645 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3888 20 MaterialCollection * 0 8576 20 MaterialCollection * 20 MaterialCollection * 0 0 3646 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3889 26 MaterialCollection const * 0 8576 26 MaterialCollection const * 26 MaterialCollection const * 0 0 3890 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3890 24 MaterialCollection const 0 8832 24 MaterialCollection const 24 MaterialCollection const 0 0 3646 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3891 24 TextureStageCollection * 0 8576 24 TextureStageCollection * 24 TextureStageCollection * 0 0 3647 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3892 30 TextureStageCollection const * 0 8576 30 TextureStageCollection const * 30 TextureStageCollection const * 0 0 3893 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3893 28 TextureStageCollection const 0 8832 28 TextureStageCollection const 28 TextureStageCollection const 0 0 3647 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3894 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 3648 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3895 20 NodePathCollection * 0 8576 20 NodePathCollection * 20 NodePathCollection * 0 0 3651 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3896 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 3579 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3897 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 3898 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3898 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">3899 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 3897 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3900 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 3582 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3901 13 LQuaternion * 0 8576 13 LQuaternion * 13 LQuaternion * 0 0 3585 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3902 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 3588 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3903 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 3904 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3904 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 3897 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3905 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3602 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3906 9 nullptr_t 0 2105344 14 std::nullptr_t 14 std::nullptr_t 0 0 3907 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3907 17 decltype(nullptr) 0 8194 17 decltype(nullptr) 17 decltype(nullptr) 0 9 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3908 11 BitMask32 * 0 8576 11 BitMask32 * 11 BitMask32 * 0 0 3628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3909 18 LTexCoord3 const * 0 8576 18 LTexCoord3 const * 18 LTexCoord3 const * 0 0 3910 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3910 16 LTexCoord3 const 0 8832 16 LTexCoord3 const 16 LTexCoord3 const 0 0 3911 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3911 10 LTexCoord3 0 2105344 10 LTexCoord3 10 LTexCoord3 0 0 3912 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3912 11 LTexCoord3f 0 2105344 11 LTexCoord3f 11 LTexCoord3f 0 0 3580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3913 17 TextureCollection 0 2048 17 TextureCollection 17 TextureCollection 0 0 0 0 0 0 0 0 0 0 0 0 97</span>
<span class="s0">/**</span>
 <span class="s0">* Manages a list of Texture objects, as returned by</span>
 <span class="s0">* TexturePool::find_all_textures().</span>
 <span class="s0">*/</span>

<span class="s0">3914 19 TextureCollection * 0 8576 19 TextureCollection * 19 TextureCollection * 0 0 3913 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3915 20 WeakNodePath const * 0 8576 20 WeakNodePath const * 20 WeakNodePath const * 0 0 3916 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3916 18 WeakNodePath const 0 8832 18 WeakNodePath const 18 WeakNodePath const 0 0 3667 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3917 15 vector_string * 0 8576 15 vector_string * 15 vector_string * 0 0 3918 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3918 13 vector_string 0 2105344 13 vector_string 13 vector_string 0 0 3919 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3919 17 pvector&lt; string &gt; 0 2048 22 pvector&lt; std::string &gt; 22 pvector&lt; std::string &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3920 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 3738 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3921 14 vector_uchar * 0 8576 14 vector_uchar * 14 vector_uchar * 0 0 3858 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3922 26 NodePathCollection const * 0 8576 26 NodePathCollection const * 26 NodePathCollection const * 0 0 3923 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3923 24 NodePathCollection const 0 8832 24 NodePathCollection const 24 NodePathCollection const 0 0 3651 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3924 20 AttribNodeRegistry * 0 8576 20 AttribNodeRegistry * 20 AttribNodeRegistry * 0 0 3652 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3925 26 AttribNodeRegistry const * 0 8576 26 AttribNodeRegistry const * 26 AttribNodeRegistry const * 0 0 3926 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3926 24 AttribNodeRegistry const 0 8832 24 AttribNodeRegistry const 24 AttribNodeRegistry const 0 0 3652 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3927 25 AudioVolumeAttrib const * 0 8576 25 AudioVolumeAttrib const * 25 AudioVolumeAttrib const * 0 0 3928 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3928 23 AudioVolumeAttrib const 0 8832 23 AudioVolumeAttrib const 23 AudioVolumeAttrib const 0 0 3653 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3929 25 AuxBitplaneAttrib const * 0 8576 25 AuxBitplaneAttrib const * 25 AuxBitplaneAttrib const * 0 0 3930 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3930 23 AuxBitplaneAttrib const 0 8832 23 AuxBitplaneAttrib const 23 AuxBitplaneAttrib const 0 0 3654 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3931 20 AuxSceneData const * 0 8576 20 AuxSceneData const * 20 AuxSceneData const * 0 0 3932 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3932 18 AuxSceneData const 0 8832 18 AuxSceneData const 18 AuxSceneData const 0 0 3656 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3933 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3934 9 BamFile * 0 8576 9 BamFile * 9 BamFile * 0 0 3658 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3935 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 3936 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3936 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3937 15 TypedWritable * 0 8576 15 TypedWritable * 15 TypedWritable * 0 0 3938 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3938 13 TypedWritable 0 2048 13 TypedWritable 13 TypedWritable 0 0 0 0 0 0 0 0 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* Base class for objects that can be written to and read from Bam files.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">3939 15 BamFile const * 0 8576 15 BamFile const * 15 BamFile const * 0 0 3940 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3940 13 BamFile const 0 8832 13 BamFile const 13 BamFile const 0 0 3658 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3941 21 TypedWritable const * 0 8576 21 TypedWritable const * 21 TypedWritable const * 0 0 3942 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3942 19 TypedWritable const 0 8832 19 TypedWritable const 19 TypedWritable const 0 0 3938 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3943 23 BillboardEffect const * 0 8576 23 BillboardEffect const * 23 BillboardEffect const * 0 0 3944 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3944 21 BillboardEffect const 0 8832 21 BillboardEffect const 21 BillboardEffect const 0 0 3665 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3945 6 Lens * 0 8576 6 Lens * 6 Lens * 0 0 3946 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3946 4 Lens 0 2048 4 Lens 4 Lens 0 0 0 0 0 0 0 0 0 0 0 0 398</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for any number of different kinds of lenses, linear and</span>
 <span class="s0">* otherwise.  Presently, this includes perspective and orthographic lenses.</span>
 <span class="s0">*</span>
 <span class="s0">* A Lens object is the main part of a Camera node, which defines the</span>
 <span class="s0">* fundamental interface to point-of-view for rendering.  Lenses are also used</span>
 <span class="s0">* in other contexts, however; for instance, a Spotlight is also defined using</span>
 <span class="s0">* a lens.</span>
 <span class="s0">*/</span>

<span class="s0">3947 10 LensNode * 0 8576 10 LensNode * 10 LensNode * 0 0 3666 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3948 12 Lens const * 0 8576 12 Lens const * 12 Lens const * 0 0 3949 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3949 10 Lens const 0 8832 10 Lens const 10 Lens const 0 0 3946 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3950 16 LensNode const * 0 8576 16 LensNode const * 16 LensNode const * 0 0 3951 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3951 14 LensNode const 0 8832 14 LensNode const 14 LensNode const 0 0 3666 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3952 14 WeakNodePath * 0 8576 14 WeakNodePath * 14 WeakNodePath * 0 0 3667 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3953 14 Camera const * 0 8576 14 Camera const * 14 Camera const * 0 0 3954 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3954 12 Camera const 0 8832 12 Camera const 12 Camera const 0 0 3668 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3955 8 Camera * 0 8576 8 Camera * 8 Camera * 0 0 3668 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3956 14 LPlane const * 0 8576 14 LPlane const * 14 LPlane const * 0 0 3677 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3957 11 PlaneNode * 0 8576 11 PlaneNode * 11 PlaneNode * 0 0 3675 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3958 17 PlaneNode const * 0 8576 17 PlaneNode const * 17 PlaneNode const * 0 0 3959 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3959 15 PlaneNode const 0 8832 15 PlaneNode const 15 PlaneNode const 0 0 3675 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3960 23 ClipPlaneAttrib const * 0 8576 23 ClipPlaneAttrib const * 23 ClipPlaneAttrib const * 0 0 3961 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3961 21 ClipPlaneAttrib const 0 8832 21 ClipPlaneAttrib const 21 ClipPlaneAttrib const 0 0 3680 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3962 19 ColorAttrib const * 0 8576 19 ColorAttrib const * 19 ColorAttrib const * 0 0 3963 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3963 17 ColorAttrib const 0 8832 17 ColorAttrib const 17 ColorAttrib const 0 0 3682 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3964 24 ColorBlendAttrib const * 0 8576 24 ColorBlendAttrib const * 24 ColorBlendAttrib const * 0 0 3965 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3965 22 ColorBlendAttrib const 0 8832 22 ColorBlendAttrib const 22 ColorBlendAttrib const 0 0 3684 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3966 24 ColorScaleAttrib const * 0 8576 24 ColorScaleAttrib const * 24 ColorScaleAttrib const * 0 0 3967 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3967 22 ColorScaleAttrib const 0 8832 22 ColorScaleAttrib const 22 ColorScaleAttrib const 0 0 3687 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3968 24 ColorWriteAttrib const * 0 8576 24 ColorWriteAttrib const * 24 ColorWriteAttrib const * 0 0 3969 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3969 22 ColorWriteAttrib const 0 8832 22 ColorWriteAttrib const 22 ColorWriteAttrib const 0 0 3690 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3970 21 CompassEffect const * 0 8576 21 CompassEffect const * 21 CompassEffect const * 0 0 3971 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3971 19 CompassEffect const 0 8832 19 CompassEffect const 19 CompassEffect const 0 0 3693 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3972 14 CullBinEnums * 0 8576 14 CullBinEnums * 14 CullBinEnums * 0 0 3695 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3973 20 CullBinEnums const * 0 8576 20 CullBinEnums const * 20 CullBinEnums const * 0 0 3974 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3974 18 CullBinEnums const 0 8832 18 CullBinEnums const 18 CullBinEnums const 0 0 3695 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3975 10 GeomNode * 0 8576 10 GeomNode * 10 GeomNode * 0 0 3697 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3976 16 GeomNode const * 0 8576 16 GeomNode const * 16 GeomNode const * 0 0 3977 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3977 14 GeomNode const 0 8832 14 GeomNode const 14 GeomNode const 0 0 3697 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3978 10 Geom const 0 8832 10 Geom const 10 Geom const 0 0 3979 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3979 4 Geom 0 2048 4 Geom 4 Geom 0 0 0 0 0 0 0 0 0 0 0 0 418</span>
<span class="s0">/**</span>
 <span class="s0">* A container for geometry primitives.  This class associates one or more</span>
 <span class="s0">* GeomPrimitive objects with a table of vertices defined by a GeomVertexData</span>
 <span class="s0">* object.  All of the primitives stored in a particular Geom are drawn from</span>
 <span class="s0">* the same set of vertices (each primitive uses a subset of all of the</span>
 <span class="s0">* vertices in the table), and all of them must be rendered at the same time,</span>
 <span class="s0">* in the same graphics state.</span>
 <span class="s0">*/</span>

<span class="s0">3980 12 Geom const * 0 8576 12 Geom const * 12 Geom const * 0 0 3978 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3981 6 Geom * 0 8576 6 Geom * 6 Geom * 0 0 3979 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3982 21 CullBinAttrib const * 0 8576 21 CullBinAttrib const * 21 CullBinAttrib const * 0 0 3983 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3983 19 CullBinAttrib const 0 8832 19 CullBinAttrib const 19 CullBinAttrib const 0 0 3698 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3984 16 CullBinManager * 0 8576 16 CullBinManager * 16 CullBinManager * 0 0 3699 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3985 7 BinType 0 2367488 23 CullBinManager::BinType 23 CullBinManager::BinType 3699 0 3696 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3986 22 CullBinManager const * 0 8576 22 CullBinManager const * 22 CullBinManager const * 0 0 3987 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3987 20 CullBinManager const 0 8832 20 CullBinManager const 20 CullBinManager const 0 0 3699 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3988 22 CullFaceAttrib const * 0 8576 22 CullFaceAttrib const * 22 CullFaceAttrib const * 0 0 3989 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3989 20 CullFaceAttrib const 0 8832 20 CullFaceAttrib const 20 CullFaceAttrib const 0 0 3700 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3990 19 CullTraverserData * 0 8576 19 CullTraverserData * 19 CullTraverserData * 0 0 3703 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3991 21 CullTraverser const * 0 8576 21 CullTraverser const * 21 CullTraverser const * 0 0 3992 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3992 19 CullTraverser const 0 8832 19 CullTraverser const 19 CullTraverser const 0 0 3709 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3993 16 DrawMask const * 0 8576 16 DrawMask const * 16 DrawMask const * 0 0 3994 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3994 14 DrawMask const 0 8832 14 DrawMask const 14 DrawMask const 0 0 3627 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3995 18 SceneSetup const * 0 8576 18 SceneSetup const * 18 SceneSetup const * 0 0 3996 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3996 16 SceneSetup const 0 8832 16 SceneSetup const 16 SceneSetup const 0 0 3704 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3997 12 SceneSetup * 0 8576 12 SceneSetup * 12 SceneSetup * 0 0 3704 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3998 11 Fog const * 0 8576 11 Fog const * 11 Fog const * 0 0 3999 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">3999 9 Fog const 0 8832 9 Fog const 9 Fog const 0 0 3705 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4000 17 FogAttrib const * 0 8576 17 FogAttrib const * 17 FogAttrib const * 0 0 4001 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4001 15 FogAttrib const 0 8832 15 FogAttrib const 15 FogAttrib const 0 0 3707 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4002 25 GeometricBoundingVolume * 0 8576 25 GeometricBoundingVolume * 25 GeometricBoundingVolume * 0 0 4003 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4003 23 GeometricBoundingVolume 0 2048 23 GeometricBoundingVolume 23 GeometricBoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 167</span>
<span class="s0">/**</span>
 <span class="s0">* This is another abstract class, for a general class of bounding volumes</span>
 <span class="s0">* that actually enclose points in 3-d space, such as BSP's and bounding</span>
 <span class="s0">* spheres.</span>
 <span class="s0">*/</span>

<span class="s0">4004 13 CullHandler * 0 8576 13 CullHandler * 13 CullHandler * 0 0 4005 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4005 11 CullHandler 0 2048 11 CullHandler 11 CullHandler 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4006 15 PortalClipper * 0 8576 15 PortalClipper * 15 PortalClipper * 0 0 4007 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4007 13 PortalClipper 0 2048 13 PortalClipper 13 PortalClipper 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4008 28 GeomDrawCallbackData const * 0 8576 28 GeomDrawCallbackData const * 28 GeomDrawCallbackData const * 0 0 4009 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4009 26 GeomDrawCallbackData const 0 8832 26 GeomDrawCallbackData const 26 GeomDrawCallbackData const 0 0 3710 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4010 16 CullableObject * 0 8576 16 CullableObject * 16 CullableObject * 0 0 4011 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4011 14 CullableObject 0 1050624 14 CullableObject 14 CullableObject 0 0 0 0 0 0 0 0 0 0 0 0 133</span>
<span class="s0">/**</span>
 <span class="s0">* The smallest atom of cull.  This is normally just a Geom and its associated</span>
 <span class="s0">* state, but it also contain a draw callback.</span>
 <span class="s0">*/</span>

<span class="s0">4012 22 GeomDrawCallbackData * 0 8576 22 GeomDrawCallbackData * 22 GeomDrawCallbackData * 0 0 3710 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4013 27 RescaleNormalAttrib const * 0 8576 27 RescaleNormalAttrib const * 27 RescaleNormalAttrib const * 0 0 4014 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4014 25 RescaleNormalAttrib const 0 8832 25 RescaleNormalAttrib const 25 RescaleNormalAttrib const 0 0 3712 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4015 18 CullResult const * 0 8576 18 CullResult const * 18 CullResult const * 0 0 4016 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4016 16 CullResult const 0 8832 16 CullResult const 16 CullResult const 0 0 3714 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4017 12 CullResult * 0 8576 12 CullResult * 12 CullResult * 0 0 3714 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4018 7 CullBin 0 1050624 7 CullBin 7 CullBin 0 0 0 0 0 0 0 0 0 0 0 0 320</span>
<span class="s0">/**</span>
 <span class="s0">* A collection of Geoms and their associated state, for a particular scene.</span>
 <span class="s0">* The cull traversal (and the BinCullHandler) assigns Geoms to bins as it</span>
 <span class="s0">* comes across them.</span>
 <span class="s0">*</span>
 <span class="s0">* This is an abstract base class; derived classes like CullBinStateSorted and</span>
 <span class="s0">* CullBinBackToFront provide the actual implementation.</span>
 <span class="s0">*/</span>

<span class="s0">4019 9 CullBin * 0 8576 9 CullBin * 9 CullBin * 0 0 4018 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4020 25 DepthOffsetAttrib const * 0 8576 25 DepthOffsetAttrib const * 25 DepthOffsetAttrib const * 0 0 4021 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4021 23 DepthOffsetAttrib const 0 8832 23 DepthOffsetAttrib const 23 DepthOffsetAttrib const 0 0 3717 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4022 23 DepthTestAttrib const * 0 8576 23 DepthTestAttrib const * 23 DepthTestAttrib const * 0 0 4023 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4023 21 DepthTestAttrib const 0 8832 21 DepthTestAttrib const 21 DepthTestAttrib const 0 0 3718 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4024 24 DepthWriteAttrib const * 0 8576 24 DepthWriteAttrib const * 24 DepthWriteAttrib const * 0 0 4025 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4025 22 DepthWriteAttrib const 0 8832 22 DepthWriteAttrib const 22 DepthWriteAttrib const 0 0 3719 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4026 13 Light const * 0 8576 13 Light const * 13 Light const * 0 0 4027 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4027 11 Light const 0 8832 11 Light const 11 Light const 0 0 3721 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4028 19 LightAttrib const * 0 8576 19 LightAttrib const * 19 LightAttrib const * 0 0 4029 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4029 17 LightAttrib const 0 8832 17 LightAttrib const 17 LightAttrib const 0 0 3722 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4030 23 LightRampAttrib const * 0 8576 23 LightRampAttrib const * 23 LightRampAttrib const * 0 0 4031 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4031 21 LightRampAttrib const 0 8832 21 LightRampAttrib const 21 LightRampAttrib const 0 0 3724 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4032 14 Loader const * 0 8576 14 Loader const * 14 Loader const * 0 0 4033 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4033 12 Loader const 0 8832 12 Loader const 12 Loader const 0 0 3726 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4034 18 AsyncTaskManager * 0 8576 18 AsyncTaskManager * 18 AsyncTaskManager * 0 0 4035 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4035 16 AsyncTaskManager 0 2048 16 AsyncTaskManager 16 AsyncTaskManager 0 0 0 0 0 0 0 0 0 0 0 0 674</span>
<span class="s0">/**</span>
 <span class="s0">* A class to manage a loose queue of isolated tasks, which can be performed</span>
 <span class="s0">* either synchronously (in the foreground thread) or asynchronously (by a</span>
 <span class="s0">* background thread).</span>
 <span class="s0">*</span>
 <span class="s0">* The AsyncTaskManager is actually a collection of AsyncTaskChains, each of</span>
 <span class="s0">* which maintains a list of tasks.  Each chain can be either foreground or</span>
 <span class="s0">* background (it may run only in the main thread, or it may be serviced by</span>
 <span class="s0">* one or more background threads). See AsyncTaskChain for more information.</span>
 <span class="s0">*</span>
 <span class="s0">* If you do not require background processing, it is perfectly acceptable to</span>
 <span class="s0">* create only one AsyncTaskChain, which runs in the main thread.  This is a</span>
 <span class="s0">* common configuration.</span>
 <span class="s0">*/</span>

<span class="s0">4036 11 AsyncTask * 0 8576 11 AsyncTask * 11 AsyncTask * 0 0 3736 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4037 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 3740 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4038 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 3657 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4039 9 Results * 0 8576 17 Loader::Results * 17 Loader::Results * 0 0 3727 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4040 15 Results const * 0 8576 23 Loader::Results const * 23 Loader::Results const * 0 0 4041 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4041 13 Results const 0 8832 21 Loader::Results const 21 Loader::Results const 0 0 3727 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4042 22 LoaderFileType const * 0 8576 22 LoaderFileType const * 22 LoaderFileType const * 0 0 4043 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4043 20 LoaderFileType const 0 8832 20 LoaderFileType const 20 LoaderFileType const 0 0 3728 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4044 30 LoaderFileTypeRegistry const * 0 8576 30 LoaderFileTypeRegistry const * 30 LoaderFileTypeRegistry const * 0 0 4045 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4045 28 LoaderFileTypeRegistry const 0 8832 28 LoaderFileTypeRegistry const 28 LoaderFileTypeRegistry const 0 0 3730 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4046 24 LoaderFileTypeRegistry * 0 8576 24 LoaderFileTypeRegistry * 24 LoaderFileTypeRegistry * 0 0 3730 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4047 22 MaterialAttrib const * 0 8576 22 MaterialAttrib const * 22 MaterialAttrib const * 0 0 4048 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4048 20 MaterialAttrib const 0 8832 20 MaterialAttrib const 20 MaterialAttrib const 0 0 3732 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4049 27 ModelFlattenRequest const * 0 8576 27 ModelFlattenRequest const * 27 ModelFlattenRequest const * 0 0 4050 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4050 25 ModelFlattenRequest const 0 8832 25 ModelFlattenRequest const 25 ModelFlattenRequest const 0 0 3735 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4051 21 ModelFlattenRequest * 0 8576 21 ModelFlattenRequest * 21 ModelFlattenRequest * 0 0 3735 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4052 24 ModelLoadRequest const * 0 8576 24 ModelLoadRequest const * 24 ModelLoadRequest const * 0 0 4053 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4053 22 ModelLoadRequest const 0 8832 22 ModelLoadRequest const 22 ModelLoadRequest const 0 0 3737 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4054 18 ModelLoadRequest * 0 8576 18 ModelLoadRequest * 18 ModelLoadRequest * 0 0 3737 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4055 11 ModelNode * 0 8576 11 ModelNode * 11 ModelNode * 0 0 3743 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4056 17 ModelNode const * 0 8576 17 ModelNode const * 17 ModelNode const * 0 0 4057 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4057 15 ModelNode const 0 8832 15 ModelNode const 15 ModelNode const 0 0 3743 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4058 11 ModelRoot * 0 8576 11 ModelRoot * 11 ModelRoot * 0 0 3745 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4059 17 ModelRoot const * 0 8576 17 ModelRoot const * 17 ModelRoot const * 0 0 4060 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4060 15 ModelRoot const 0 8832 15 ModelRoot const 15 ModelRoot const 0 0 3745 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4061 22 ModelReference const * 0 8576 33 ModelRoot::ModelReference const * 33 ModelRoot::ModelReference const * 0 0 4062 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4062 20 ModelReference const 0 8832 31 ModelRoot::ModelReference const 31 ModelRoot::ModelReference const 0 0 3748 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4063 24 ModelSaveRequest const * 0 8576 24 ModelSaveRequest const * 24 ModelSaveRequest const * 0 0 4064 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4064 22 ModelSaveRequest const 0 8832 22 ModelSaveRequest const 22 ModelSaveRequest const 0 0 3751 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4065 18 ModelSaveRequest * 0 8576 18 ModelSaveRequest * 18 ModelSaveRequest * 0 0 3751 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4066 21 TextureAttrib const * 0 8576 21 TextureAttrib const * 21 TextureAttrib const * 0 0 4067 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4067 19 TextureAttrib const 0 8832 19 TextureAttrib const 19 TextureAttrib const 0 0 3752 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4068 20 TextureStage const * 0 8576 20 TextureStage const * 20 TextureStage const * 0 0 4069 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4069 18 TextureStage const 0 8832 18 TextureStage const 18 TextureStage const 0 0 3754 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4070 4 Mode 0 2367488 18 TexGenAttrib::Mode 18 TexGenAttrib::Mode 3759 0 3595 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4071 20 TexGenAttrib const * 0 8576 20 TexGenAttrib const * 20 TexGenAttrib const * 0 0 4072 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4072 18 TexGenAttrib const 0 8832 18 TexGenAttrib const 18 TexGenAttrib const 0 0 3759 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4073 14 OccluderNode * 0 8576 14 OccluderNode * 14 OccluderNode * 0 0 3760 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4074 20 OccluderNode const * 0 8576 20 OccluderNode const * 20 OccluderNode const * 0 0 4075 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4075 18 OccluderNode const 0 8832 18 OccluderNode const 18 OccluderNode const 0 0 3760 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4076 22 OccluderEffect const * 0 8576 22 OccluderEffect const * 22 OccluderEffect const * 0 0 4077 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4077 20 OccluderEffect const 0 8832 20 OccluderEffect const 20 OccluderEffect const 0 0 3761 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4078 21 PolylightNode const * 0 8576 21 PolylightNode const * 21 PolylightNode const * 0 0 4079 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4079 19 PolylightNode const 0 8832 19 PolylightNode const 19 PolylightNode const 0 0 3762 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4080 15 PolylightNode * 0 8576 15 PolylightNode * 15 PolylightNode * 0 0 3762 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4081 18 LightGroup const * 0 8576 35 PolylightEffect::LightGroup const * 35 PolylightEffect::LightGroup const * 0 0 4082 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4082 16 LightGroup const 0 8832 33 PolylightEffect::LightGroup const 33 PolylightEffect::LightGroup const 0 0 3767 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4083 23 PolylightEffect const * 0 8576 23 PolylightEffect const * 23 PolylightEffect const * 0 0 4084 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4084 21 PolylightEffect const 0 8832 21 PolylightEffect const 21 PolylightEffect const 0 0 3765 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4085 20 ShaderAttrib const * 0 8576 20 ShaderAttrib const * 20 ShaderAttrib const * 0 0 4086 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4086 18 ShaderAttrib const 0 8832 18 ShaderAttrib const 18 ShaderAttrib const 0 0 3769 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4087 14 InternalName * 0 8576 14 InternalName * 14 InternalName * 0 0 3875 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4088 11 LVecBase4 * 0 8576 11 LVecBase4 * 11 LVecBase4 * 0 0 3689 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4089 14 SamplerState * 0 8576 14 SamplerState * 14 SamplerState * 0 0 3758 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4090 12 ShaderBuffer 0 2048 12 ShaderBuffer 12 ShaderBuffer 0 0 0 0 0 0 0 0 0 0 0 0 93</span>
<span class="s0">/**</span>
 <span class="s0">* This is a generic buffer object that lives in graphics memory.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">4091 14 ShaderBuffer * 0 8576 14 ShaderBuffer * 14 ShaderBuffer * 0 0 4090 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4092 24 ShowBoundsEffect const * 0 8576 24 ShowBoundsEffect const * 24 ShowBoundsEffect const * 0 0 4093 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4093 22 ShowBoundsEffect const 0 8832 22 ShowBoundsEffect const 22 ShowBoundsEffect const 0 0 3774 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4094 26 TexProjectorEffect const * 0 8576 26 TexProjectorEffect const * 26 TexProjectorEffect const * 0 0 4095 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4095 24 TexProjectorEffect const 0 8832 24 TexProjectorEffect const 24 TexProjectorEffect const 0 0 3775 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4096 21 ScissorEffect const * 0 8576 21 ScissorEffect const * 21 ScissorEffect const * 0 0 4097 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4097 19 ScissorEffect const 0 8832 19 ScissorEffect const 19 ScissorEffect const 0 0 3776 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4098 19 SceneGraphReducer * 0 8576 19 SceneGraphReducer * 19 SceneGraphReducer * 0 0 3777 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4099 25 SceneGraphReducer const * 0 8576 25 SceneGraphReducer const * 25 SceneGraphReducer const * 0 0 4100 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4100 23 SceneGraphReducer const 0 8832 23 SceneGraphReducer const 23 SceneGraphReducer const 0 0 3777 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4101 26 AccumulatedAttribs const * 0 8576 26 AccumulatedAttribs const * 26 AccumulatedAttribs const * 0 0 4102 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4102 24 AccumulatedAttribs const 0 8832 24 AccumulatedAttribs const 24 AccumulatedAttribs const 0 0 4103 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4103 18 AccumulatedAttribs 0 1050624 18 AccumulatedAttribs 18 AccumulatedAttribs 0 0 0 0 0 0 0 0 0 0 0 0 206</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used by the SceneGraphReducer to maintain and accumulate the</span>
 <span class="s0">* set of attributes we have encountered on each node that might eventually be</span>
 <span class="s0">* applied to the vertices at the leaves.</span>
 <span class="s0">*/</span>

<span class="s0">4104 17 GeomTransformer * 0 8576 17 GeomTransformer * 17 GeomTransformer * 0 0 4105 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4105 15 GeomTransformer 0 1050624 15 GeomTransformer 15 GeomTransformer 0 0 0 0 0 0 0 0 0 0 0 0 630</span>
<span class="s0">/**</span>
 <span class="s0">* An object specifically designed to transform the vertices of a Geom without</span>
 <span class="s0">* disturbing indexing or affecting any other Geoms that may share the same</span>
 <span class="s0">* vertex arrays, and without needlessly wasting memory when different Geoms</span>
 <span class="s0">* sharing the same vertex arrays are transformed by the same amount.</span>
 <span class="s0">*</span>
 <span class="s0">* If you create a single GeomTransformer and use it to transform a number of</span>
 <span class="s0">* different Geoms by various transformations, then those Geoms which happen</span>
 <span class="s0">* to share the same arrays and are transformed by the same amounts will still</span>
 <span class="s0">* share the same arrays as each other (but different from the original</span>
 <span class="s0">* arrays).</span>
 <span class="s0">*/</span>

<span class="s0">4106 15 ParamNodePath * 0 8576 15 ParamNodePath * 15 ParamNodePath * 0 0 3782 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4107 21 ParamNodePath const * 0 8576 21 ParamNodePath const * 21 ParamNodePath const * 0 0 4108 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4108 19 ParamNodePath const 0 8832 19 ParamNodePath const 19 ParamNodePath const 0 0 3782 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4109 12 PortalNode * 0 8576 12 PortalNode * 12 PortalNode * 0 0 3784 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4110 12 PortalMask * 0 8576 12 PortalMask * 12 PortalMask * 0 0 3785 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4111 18 PortalNode const * 0 8576 18 PortalNode const * 18 PortalNode const * 0 0 4112 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4112 16 PortalNode const 0 8832 16 PortalNode const 16 PortalNode const 0 0 3784 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4113 21 ScissorAttrib const * 0 8576 21 ScissorAttrib const * 21 ScissorAttrib const * 0 0 4114 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4114 19 ScissorAttrib const 0 8832 19 ScissorAttrib const 19 ScissorAttrib const 0 0 3786 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4115 24 ShadeModelAttrib const * 0 8576 24 ShadeModelAttrib const * 24 ShadeModelAttrib const * 0 0 4116 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4116 22 ShadeModelAttrib const 0 8832 22 ShadeModelAttrib const 22 ShadeModelAttrib const 0 0 3787 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4117 21 StencilAttrib const * 0 8576 21 StencilAttrib const * 21 StencilAttrib const * 0 0 4118 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4118 19 StencilAttrib const 0 8832 19 StencilAttrib const 19 StencilAttrib const 0 0 3789 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">4119 8 Shader * 0 8576 8 Shader * 8 Shader * 0 0 3773 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">177</span>
<span class="s0">4120 3 pos 0 2 3578 1931 0 0 0 0 0 0 0 19 TransformState::pos 0</span>

<span class="s0">4121 3 hpr 0 2 3581 1932 0 0 0 0 0 0 0 19 TransformState::hpr 0</span>

<span class="s0">4122 4 quat 0 2 3584 1933 0 0 0 0 0 0 0 20 TransformState::quat 0</span>

<span class="s0">4123 9 norm_quat 0 2 3584 1934 0 0 0 0 0 0 0 25 TransformState::norm_quat 0</span>

<span class="s0">4124 5 scale 0 2 3581 1935 0 0 0 0 0 0 0 21 TransformState::scale 0</span>

<span class="s0">4125 5 shear 0 2 3581 1937 0 0 0 0 0 0 0 21 TransformState::shear 0</span>

<span class="s0">4126 3 mat 0 2 3587 1938 0 0 0 0 0 0 0 19 TransformState::mat 0</span>

<span class="s0">4127 4 slot 0 2 3593 2008 0 0 0 0 0 0 0 18 RenderAttrib::slot 0</span>

<span class="s0">4128 4 mode 0 2 3597 2012 0 0 0 0 0 0 0 22 RenderModeAttrib::mode 0</span>

<span class="s0">4129 9 thickness 0 2 3598 2013 0 0 0 0 0 0 0 27 RenderModeAttrib::thickness 0</span>

<span class="s0">4130 11 perspective 0 2 3600 2014 0 0 0 0 0 0 0 29 RenderModeAttrib::perspective 0</span>

<span class="s0">4131 15 wireframe_color 0 2 3601 2015 0 0 0 0 0 0 0 33 RenderModeAttrib::wireframe_color 0</span>

<span class="s0">4132 10 class_slot 0 2 3593 2017 0 0 0 0 0 0 0 28 RenderModeAttrib::class_slot 0</span>

<span class="s0">4133 10 class_slot 0 2 3593 2032 0 0 0 0 0 0 0 27 TexMatrixAttrib::class_slot 0</span>

<span class="s0">4134 7 attribs 0 138 3607 2050 0 2049 0 0 0 0 0 20 RenderState::attribs 0</span>

<span class="s0">4135 15 reference_alpha 0 2 3598 2087 0 0 0 0 0 0 0 32 AlphaTestAttrib::reference_alpha 0</span>

<span class="s0">4136 4 mode 0 2 3594 2088 0 0 0 0 0 0 0 21 AlphaTestAttrib::mode 0</span>

<span class="s0">4137 10 class_slot 0 2 3593 2089 0 0 0 0 0 0 0 27 AlphaTestAttrib::class_slot 0</span>

<span class="s0">4138 4 mode 0 2 3612 2094 0 0 0 0 0 0 0 21 AntialiasAttrib::mode 0</span>

<span class="s0">4139 9 mode_type 0 2 3612 2095 0 0 0 0 0 0 0 26 AntialiasAttrib::mode_type 0</span>

<span class="s0">4140 12 mode_quality 0 2 3612 2096 0 0 0 0 0 0 0 29 AntialiasAttrib::mode_quality 0</span>

<span class="s0">4141 10 class_slot 0 2 3593 2097 0 0 0 0 0 0 0 27 AntialiasAttrib::class_slot 0</span>

<span class="s0">4142 5 state 0 6 3618 2168 2167 0 0 0 0 0 0 16 PandaNode::state 0</span>

<span class="s0">4143 7 effects 0 6 3619 2171 2170 0 0 0 0 0 0 18 PandaNode::effects 0</span>

<span class="s0">4144 9 transform 0 6 3620 2174 2173 0 0 0 0 0 0 20 PandaNode::transform 0</span>

<span class="s0">4145 14 prev_transform 0 2 3620 2177 0 0 0 0 0 0 0 25 PandaNode::prev_transform 0</span>

<span class="s0">4146 4 tags 0 686 3621 2182 2181 2183 0 2184 2185 0 2186 15 PandaNode::tags 0</span>

<span class="s0">4147 11 python_tags 0 2 3623 2188 0 0 0 0 0 0 0 22 PandaNode::python_tags 0</span>

<span class="s0">4148 11 overall_bit 0 2 3627 2204 0 0 0 0 0 0 0 22 PandaNode::overall_bit 0</span>

<span class="s0">4149 15 all_camera_mask 0 2 3627 2205 0 0 0 0 0 0 0 26 PandaNode::all_camera_mask 0</span>

<span class="s0">4150 14 overall_hidden 0 6 3600 2206 2207 0 0 0 0 0 0 25 PandaNode::overall_hidden 0</span>

<span class="s0">4151 17 draw_control_mask 0 2 3627 2209 0 0 0 0 0 0 0 28 PandaNode::draw_control_mask 0</span>

<span class="s0">4152 14 draw_show_mask 0 2 3627 2210 0 0 0 0 0 0 0 25 PandaNode::draw_show_mask 0</span>

<span class="s0">4153 17 into_collide_mask 0 6 3630 2214 2213 0 0 0 0 0 0 28 PandaNode::into_collide_mask 0</span>

<span class="s0">4154 18 legal_collide_mask 0 2 3630 2215 0 0 0 0 0 0 0 29 PandaNode::legal_collide_mask 0</span>

<span class="s0">4155 11 bounds_type 0 6 3631 2225 2224 0 0 0 0 0 0 22 PandaNode::bounds_type 0</span>

<span class="s0">4156 15 nested_vertices 0 2 3593 2230 0 0 0 0 0 0 0 26 PandaNode::nested_vertices 0</span>

<span class="s0">4157 15 internal_bounds 0 2 3633 2231 0 0 0 0 0 0 0 26 PandaNode::internal_bounds 0</span>

<span class="s0">4158 17 internal_vertices 0 2 3593 2232 0 0 0 0 0 0 0 28 PandaNode::internal_vertices 0</span>

<span class="s0">4159 12 bounds_stale 0 2 3600 2235 0 0 0 0 0 0 0 23 PandaNode::bounds_stale 0</span>

<span class="s0">4160 5 final 0 6 3600 2237 2236 0 0 0 0 0 0 16 PandaNode::final 0</span>

<span class="s0">4161 8 children 0 2 3635 2254 0 0 0 0 0 0 0 19 PandaNode::children 0</span>

<span class="s0">4162 7 stashed 0 2 3636 2151 0 0 0 0 0 0 0 18 PandaNode::stashed 0</span>

<span class="s0">4163 7 parents 0 2 3637 2255 0 0 0 0 0 0 0 18 PandaNode::parents 0</span>

<span class="s0">4164 4 mode 0 2 3639 2259 0 0 0 0 0 0 0 24 TransparencyAttrib::mode 0</span>

<span class="s0">4165 10 class_slot 0 2 3593 2260 0 0 0 0 0 0 0 30 TransparencyAttrib::class_slot 0</span>

<span class="s0">4166 9 operation 0 2 3641 2266 0 0 0 0 0 0 0 24 LogicOpAttrib::operation 0</span>

<span class="s0">4167 10 class_slot 0 2 3593 2267 0 0 0 0 0 0 0 25 LogicOpAttrib::class_slot 0</span>

<span class="s0">4168 5 nodes 0 66 3650 2360 0 0 0 0 2359 0 0 15 NodePath::nodes 0</span>

<span class="s0">4169 9 ancestors 0 66 3648 2361 0 0 0 0 2359 0 0 19 NodePath::ancestors 0</span>

<span class="s0">4170 10 error_type 0 2 3649 2362 0 0 0 0 0 0 0 20 NodePath::error_type 0</span>

<span class="s0">4171 8 children 0 2 3651 2371 0 0 0 0 0 0 0 18 NodePath::children 0</span>

<span class="s0">4172 16 stashed_children 0 2 3651 2374 0 0 0 0 0 0 0 26 NodePath::stashed_children 0</span>

<span class="s0">4173 6 parent 0 10 3648 2418 0 2417 0 0 0 0 0 16 NodePath::parent 0</span>

<span class="s0">4174 4 sort 0 2 3593 2419 0 0 0 0 0 0 0 14 NodePath::sort 0</span>

<span class="s0">4175 8 net_tags 0 138 3621 2717 0 2718 0 0 0 0 0 18 NodePath::net_tags 0</span>

<span class="s0">4176 4 tags 0 2 3623 2720 0 0 0 0 0 0 0 14 NodePath::tags 0</span>

<span class="s0">4177 11 python_tags 0 2 3623 2721 0 0 0 0 0 0 0 21 NodePath::python_tags 0</span>

<span class="s0">4178 4 name 0 6 3621 2733 2732 0 0 0 0 0 0 14 NodePath::name 0</span>

<span class="s0">4179 6 volume 0 10 3598 2759 0 2758 0 0 0 0 0 25 AudioVolumeAttrib::volume 0</span>

<span class="s0">4180 10 class_slot 0 2 3593 2761 0 0 0 0 0 0 0 29 AudioVolumeAttrib::class_slot 0</span>

<span class="s0">4181 7 outputs 0 2 3593 2766 0 0 0 0 0 0 0 26 AuxBitplaneAttrib::outputs 0</span>

<span class="s0">4182 10 class_slot 0 2 3593 2767 0 0 0 0 0 0 0 29 AuxBitplaneAttrib::class_slot 0</span>

<span class="s0">4183 11 file_endian 0 2 3660 2794 0 0 0 0 0 0 0 20 BamFile::file_endian 0</span>

<span class="s0">4184 20 file_stdfloat_double 0 2 3600 2795 0 0 0 0 0 0 0 29 BamFile::file_stdfloat_double 0</span>

<span class="s0">4185 6 reader 0 2 3661 2798 0 0 0 0 0 0 0 15 BamFile::reader 0</span>

<span class="s0">4186 6 writer 0 2 3663 2799 0 0 0 0 0 0 0 15 BamFile::writer 0</span>

<span class="s0">4187 6 active 0 6 3600 2844 2843 0 0 0 0 0 0 14 Camera::active 0</span>

<span class="s0">4188 5 scene 0 6 3669 2846 2845 0 0 0 0 0 0 13 Camera::scene 0</span>

<span class="s0">4189 15 display_regions 0 66 3670 2848 0 0 0 0 2847 0 0 23 Camera::display_regions 0</span>

<span class="s0">4190 11 camera_mask 0 6 3627 2850 2849 0 0 0 0 0 0 19 Camera::camera_mask 0</span>

<span class="s0">4191 11 cull_center 0 6 3669 2852 2851 0 0 0 0 0 0 19 Camera::cull_center 0</span>

<span class="s0">4192 11 cull_bounds 0 6 3672 2854 2853 0 0 0 0 0 0 19 Camera::cull_bounds 0</span>

<span class="s0">4193 10 lod_center 0 6 3669 2856 2855 0 0 0 0 0 0 18 Camera::lod_center 0</span>

<span class="s0">4194 13 initial_state 0 6 3618 2858 2857 0 0 0 0 0 0 21 Camera::initial_state 0</span>

<span class="s0">4195 13 tag_state_key 0 6 3673 2860 2859 0 0 0 0 0 0 21 Camera::tag_state_key 0</span>

<span class="s0">4196 9 lod_scale 0 6 3598 2862 2861 0 0 0 0 0 0 17 Camera::lod_scale 0</span>

<span class="s0">4197 10 tag_states 0 174 3618 2867 2863 2866 0 2864 0 0 0 18 Camera::tag_states 0</span>

<span class="s0">4198 14 aux_scene_data 0 174 3674 2870 2868 2870 0 2869 0 0 0 22 Camera::aux_scene_data 0</span>

<span class="s0">4199 5 plane 0 6 3677 2876 2875 0 0 0 0 0 0 16 PlaneNode::plane 0</span>

<span class="s0">4200 9 viz_scale 0 6 3598 2878 2877 0 0 0 0 0 0 20 PlaneNode::viz_scale 0</span>

<span class="s0">4201 8 priority 0 6 3593 2880 2879 0 0 0 0 0 0 19 PlaneNode::priority 0</span>

<span class="s0">4202 11 clip_effect 0 6 3593 2882 2881 0 0 0 0 0 0 22 PlaneNode::clip_effect 0</span>

<span class="s0">4203 10 class_slot 0 2 3593 2907 0 0 0 0 0 0 0 27 ClipPlaneAttrib::class_slot 0</span>

<span class="s0">4204 10 color_type 0 2 3683 2914 0 0 0 0 0 0 0 23 ColorAttrib::color_type 0</span>

<span class="s0">4205 5 color 0 2 3601 2915 0 0 0 0 0 0 0 18 ColorAttrib::color 0</span>

<span class="s0">4206 10 class_slot 0 2 3593 2916 0 0 0 0 0 0 0 23 ColorAttrib::class_slot 0</span>

<span class="s0">4207 8 rgb_mode 0 2 3685 2922 0 0 0 0 0 0 0 26 ColorBlendAttrib::rgb_mode 0</span>

<span class="s0">4208 13 rgb_operand_a 0 2 3686 2923 0 0 0 0 0 0 0 31 ColorBlendAttrib::rgb_operand_a 0</span>

<span class="s0">4209 13 rgb_operand_b 0 2 3686 2924 0 0 0 0 0 0 0 31 ColorBlendAttrib::rgb_operand_b 0</span>

<span class="s0">4210 10 alpha_mode 0 2 3685 2925 0 0 0 0 0 0 0 28 ColorBlendAttrib::alpha_mode 0</span>

<span class="s0">4211 15 alpha_operand_a 0 2 3686 2926 0 0 0 0 0 0 0 33 ColorBlendAttrib::alpha_operand_a 0</span>

<span class="s0">4212 15 alpha_operand_b 0 2 3686 2927 0 0 0 0 0 0 0 33 ColorBlendAttrib::alpha_operand_b 0</span>

<span class="s0">4213 5 color 0 2 3602 2928 0 0 0 0 0 0 0 23 ColorBlendAttrib::color 0</span>

<span class="s0">4214 10 class_slot 0 2 3593 2931 0 0 0 0 0 0 0 28 ColorBlendAttrib::class_slot 0</span>

<span class="s0">4215 5 scale 0 10 3688 2943 0 2940 0 0 0 0 0 23 ColorScaleAttrib::scale 0</span>

<span class="s0">4216 10 class_slot 0 2 3593 2945 0 0 0 0 0 0 0 28 ColorScaleAttrib::class_slot 0</span>

<span class="s0">4217 8 channels 0 2 3692 2950 0 0 0 0 0 0 0 26 ColorWriteAttrib::channels 0</span>

<span class="s0">4218 10 class_slot 0 2 3593 2951 0 0 0 0 0 0 0 28 ColorWriteAttrib::class_slot 0</span>

<span class="s0">4219 20 default_collide_mask 0 2 3630 2979 0 0 0 0 0 0 0 30 GeomNode::default_collide_mask 0</span>

<span class="s0">4220 8 bin_name 0 2 3673 2983 0 0 0 0 0 0 0 23 CullBinAttrib::bin_name 0</span>

<span class="s0">4221 10 draw_order 0 2 3593 2984 0 0 0 0 0 0 0 25 CullBinAttrib::draw_order 0</span>

<span class="s0">4222 10 class_slot 0 2 3593 2985 0 0 0 0 0 0 0 25 CullBinAttrib::class_slot 0</span>

<span class="s0">4223 4 mode 0 2 3701 3009 0 0 0 0 0 0 0 20 CullFaceAttrib::mode 0</span>

<span class="s0">4224 7 reverse 0 2 3600 3010 0 0 0 0 0 0 0 23 CullFaceAttrib::reverse 0</span>

<span class="s0">4225 14 effective_mode 0 2 3701 3011 0 0 0 0 0 0 0 30 CullFaceAttrib::effective_mode 0</span>

<span class="s0">4226 10 class_slot 0 2 3593 3012 0 0 0 0 0 0 0 26 CullFaceAttrib::class_slot 0</span>

<span class="s0">4227 5 valid 0 2 3600 3016 0 0 0 0 0 0 0 22 WorkingNodePath::valid 0</span>

<span class="s0">4228 9 node_path 0 2 3648 3017 0 0 0 0 0 0 0 26 WorkingNodePath::node_path 0</span>

<span class="s0">4229 9 node_path 0 2 3648 3026 0 0 0 0 0 0 0 28 CullTraverserData::node_path 0</span>

<span class="s0">4230 4 mode 0 6 3706 3060 3061 0 0 0 0 0 0 9 Fog::mode 0</span>

<span class="s0">4231 5 color 0 6 3601 3062 3063 0 0 0 0 0 0 10 Fog::color 0</span>

<span class="s0">4232 18 linear_onset_point 0 6 3578 3065 3066 0 0 0 0 0 0 23 Fog::linear_onset_point 0</span>

<span class="s0">4233 19 linear_opaque_point 0 6 3578 3067 3068 0 0 0 0 0 0 24 Fog::linear_opaque_point 0</span>

<span class="s0">4234 11 exp_density 0 6 3598 3070 3071 0 0 0 0 0 0 16 Fog::exp_density 0</span>

<span class="s0">4235 3 fog 0 2 3708 3077 0 0 0 0 0 0 0 14 FogAttrib::fog 0</span>

<span class="s0">4236 10 class_slot 0 2 3593 3078 0 0 0 0 0 0 0 21 FogAttrib::class_slot 0</span>

<span class="s0">4237 4 mode 0 2 3713 3117 0 0 0 0 0 0 0 25 RescaleNormalAttrib::mode 0</span>

<span class="s0">4238 10 class_slot 0 2 3593 3118 0 0 0 0 0 0 0 31 RescaleNormalAttrib::class_slot 0</span>

<span class="s0">4239 6 offset 0 2 3593 3134 0 0 0 0 0 0 0 25 DepthOffsetAttrib::offset 0</span>

<span class="s0">4240 9 min_value 0 2 3598 3135 0 0 0 0 0 0 0 28 DepthOffsetAttrib::min_value 0</span>

<span class="s0">4241 9 max_value 0 2 3598 3136 0 0 0 0 0 0 0 28 DepthOffsetAttrib::max_value 0</span>

<span class="s0">4242 10 class_slot 0 2 3593 3137 0 0 0 0 0 0 0 29 DepthOffsetAttrib::class_slot 0</span>

<span class="s0">4243 4 mode 0 2 3594 3142 0 0 0 0 0 0 0 21 DepthTestAttrib::mode 0</span>

<span class="s0">4244 10 class_slot 0 2 3593 3143 0 0 0 0 0 0 0 27 DepthTestAttrib::class_slot 0</span>

<span class="s0">4245 4 mode 0 2 3720 3148 0 0 0 0 0 0 0 22 DepthWriteAttrib::mode 0</span>

<span class="s0">4246 10 class_slot 0 2 3593 3149 0 0 0 0 0 0 0 28 DepthWriteAttrib::class_slot 0</span>

<span class="s0">4247 5 color 0 6 3601 3155 3156 0 0 0 0 0 0 12 Light::color 0</span>

<span class="s0">4248 17 color_temperature 0 6 3598 3158 3159 0 0 0 0 0 0 24 Light::color_temperature 0</span>

<span class="s0">4249 8 priority 0 6 3593 3164 3163 0 0 0 0 0 0 15 Light::priority 0</span>

<span class="s0">4250 9 on_lights 0 66 3648 3178 0 0 0 0 3176 0 0 22 LightAttrib::on_lights 0</span>

<span class="s0">4251 10 off_lights 0 66 3648 3182 0 0 0 0 3181 0 0 23 LightAttrib::off_lights 0</span>

<span class="s0">4252 10 class_slot 0 2 3593 3194 0 0 0 0 0 0 0 23 LightAttrib::class_slot 0</span>

<span class="s0">4253 4 mode 0 2 3725 3203 0 0 0 0 0 0 0 21 LightRampAttrib::mode 0</span>

<span class="s0">4254 10 class_slot 0 2 3593 3206 0 0 0 0 0 0 0 27 LightRampAttrib::class_slot 0</span>

<span class="s0">4255 5 types 0 66 3731 3252 0 0 0 0 3251 0 0 29 LoaderFileTypeRegistry::types 0</span>

<span class="s0">4256 8 material 0 2 3733 3262 0 0 0 0 0 0 0 24 MaterialAttrib::material 0</span>

<span class="s0">4257 10 class_slot 0 2 3593 3263 0 0 0 0 0 0 0 26 MaterialAttrib::class_slot 0</span>

<span class="s0">4258 4 orig 0 2 3650 3267 0 0 0 0 0 0 0 25 ModelFlattenRequest::orig 0</span>

<span class="s0">4259 8 filename 0 2 3738 3273 0 0 0 0 0 0 0 26 ModelLoadRequest::filename 0</span>

<span class="s0">4260 7 options 0 2 3740 3274 0 0 0 0 0 0 0 25 ModelLoadRequest::options 0</span>

<span class="s0">4261 6 loader 0 2 3742 3275 0 0 0 0 0 0 0 24 ModelLoadRequest::loader 0</span>

<span class="s0">4262 15 model_ref_count 0 2 3593 3289 0 0 0 0 0 0 0 26 ModelRoot::model_ref_count 0</span>

<span class="s0">4263 8 fullpath 0 6 3738 3290 3291 0 0 0 0 0 0 19 ModelRoot::fullpath 0</span>

<span class="s0">4264 9 timestamp 0 6 3746 3292 3293 0 0 0 0 0 0 20 ModelRoot::timestamp 0</span>

<span class="s0">4265 9 reference 0 6 3749 3296 3297 0 0 0 0 0 0 20 ModelRoot::reference 0</span>

<span class="s0">4266 8 filename 0 2 3738 3312 0 0 0 0 0 0 0 26 ModelSaveRequest::filename 0</span>

<span class="s0">4267 7 options 0 2 3740 3313 0 0 0 0 0 0 0 25 ModelSaveRequest::options 0</span>

<span class="s0">4268 4 node 0 2 3650 3314 0 0 0 0 0 0 0 22 ModelSaveRequest::node 0</span>

<span class="s0">4269 6 loader 0 2 3742 3315 0 0 0 0 0 0 0 24 ModelSaveRequest::loader 0</span>

<span class="s0">4270 9 on_stages 0 66 3753 3327 0 0 0 0 3326 0 0 24 TextureAttrib::on_stages 0</span>

<span class="s0">4271 8 textures 0 650 3755 3332 0 3331 0 0 3326 0 3327 23 TextureAttrib::textures 0</span>

<span class="s0">4272 8 samplers 0 650 3757 3333 0 3331 0 0 3326 0 3327 23 TextureAttrib::samplers 0</span>

<span class="s0">4273 10 off_stages 0 66 3753 3337 0 0 0 0 3336 0 0 25 TextureAttrib::off_stages 0</span>

<span class="s0">4274 10 class_slot 0 2 3593 3347 0 0 0 0 0 0 0 25 TextureAttrib::class_slot 0</span>

<span class="s0">4275 10 class_slot 0 2 3593 3360 0 0 0 0 0 0 0 24 TexGenAttrib::class_slot 0</span>

<span class="s0">4276 12 double_sided 0 6 3600 3364 3363 0 0 0 0 0 0 26 OccluderNode::double_sided 0</span>

<span class="s0">4277 12 min_coverage 0 6 3598 3366 3365 0 0 0 0 0 0 26 OccluderNode::min_coverage 0</span>

<span class="s0">4278 8 vertices 0 70 3578 3369 3370 0 0 0 3368 0 0 22 OccluderNode::vertices 0</span>

<span class="s0">4279 6 shader 0 2 3771 3456 0 0 0 0 0 0 0 20 ShaderAttrib::shader 0</span>

<span class="s0">4280 14 instance_count 0 2 3593 3437 0 0 0 0 0 0 0 28 ShaderAttrib::instance_count 0</span>

<span class="s0">4281 10 class_slot 0 2 3593 3465 0 0 0 0 0 0 0 24 ShaderAttrib::class_slot 0</span>

<span class="s0">4282 16 into_portal_mask 0 6 3785 3522 3520 0 0 0 0 0 0 28 PortalNode::into_portal_mask 0</span>

<span class="s0">4283 16 from_portal_mask 0 6 3785 3521 3519 0 0 0 0 0 0 28 PortalNode::from_portal_mask 0</span>

<span class="s0">4284 11 portal_geom 0 6 3600 3524 3523 0 0 0 0 0 0 23 PortalNode::portal_geom 0</span>

<span class="s0">4285 8 vertices 0 66 3578 3528 0 0 0 0 3527 0 0 20 PortalNode::vertices 0</span>

<span class="s0">4286 7 cell_in 0 6 3648 3530 3529 0 0 0 0 0 0 19 PortalNode::cell_in 0</span>

<span class="s0">4287 8 cell_out 0 6 3648 3532 3531 0 0 0 0 0 0 20 PortalNode::cell_out 0</span>

<span class="s0">4288 10 clip_plane 0 6 3600 3534 3533 0 0 0 0 0 0 22 PortalNode::clip_plane 0</span>

<span class="s0">4289 7 visible 0 6 3600 3536 3535 0 0 0 0 0 0 19 PortalNode::visible 0</span>

<span class="s0">4290 9 max_depth 0 6 3593 3538 3537 0 0 0 0 0 0 21 PortalNode::max_depth 0</span>

<span class="s0">4291 4 open 0 6 3600 3540 3539 0 0 0 0 0 0 16 PortalNode::open 0</span>

<span class="s0">4292 5 frame 0 2 3688 3546 0 0 0 0 0 0 0 20 ScissorAttrib::frame 0</span>

<span class="s0">4293 10 class_slot 0 2 3593 3547 0 0 0 0 0 0 0 25 ScissorAttrib::class_slot 0</span>

<span class="s0">4294 4 mode 0 2 3788 3552 0 0 0 0 0 0 0 22 ShadeModelAttrib::mode 0</span>

<span class="s0">4295 10 class_slot 0 2 3593 3553 0 0 0 0 0 0 0 28 ShadeModelAttrib::class_slot 0</span>

<span class="s0">4296 10 class_slot 0 2 3593 3563 0 0 0 0 0 0 0 25 StencilAttrib::class_slot 0</span>

<span class="s0">30</span>
<span class="s0">4297 10 get_stages 0 2026 2027 27 TexMatrixAttrib::get_stages 0</span>

<span class="s0">4298 11 get_parents 0 2137 2138 22 PandaNode::get_parents 0</span>

<span class="s0">4299 12 get_children 0 2140 2141 23 PandaNode::get_children 0</span>

<span class="s0">4300 11 get_stashed 0 2150 2151 22 PandaNode::get_stashed 0</span>

<span class="s0">4301 9 get_names 0 2296 2297 33 InternalNameCollection::get_names 0</span>

<span class="s0">4302 18 get_texture_stages 0 2334 2335 42 TextureStageCollection::get_texture_stages 0</span>

<span class="s0">4303 9 get_nodes 0 2359 2360 19 NodePath::get_nodes 0</span>

<span class="s0">4304 13 get_ancestors 0 2359 2361 23 NodePath::get_ancestors 0</span>

<span class="s0">4305 9 get_paths 0 2386 2387 29 NodePathCollection::get_paths 0</span>

<span class="s0">4306 9 get_nodes 0 2743 2744 29 AttribNodeRegistry::get_nodes 0</span>

<span class="s0">4307 19 get_display_regions 0 2847 2848 27 Camera::get_display_regions 0</span>

<span class="s0">4308 13 get_on_planes 0 2894 2895 30 ClipPlaneAttrib::get_on_planes 0</span>

<span class="s0">4309 14 get_off_planes 0 2897 2898 31 ClipPlaneAttrib::get_off_planes 0</span>

<span class="s0">4310 9 get_geoms 0 2964 2965 19 GeomNode::get_geoms 0</span>

<span class="s0">4311 12 modify_geoms 0 2964 2966 22 GeomNode::modify_geoms 0</span>

<span class="s0">4312 15 get_geom_states 0 2964 2967 25 GeomNode::get_geom_states 0</span>

<span class="s0">4313 8 get_bins 0 2990 2991 24 CullBinManager::get_bins 0</span>

<span class="s0">4314 13 get_on_lights 0 3176 3178 26 LightAttrib::get_on_lights 0</span>

<span class="s0">4315 14 get_off_lights 0 3181 3182 27 LightAttrib::get_off_lights 0</span>

<span class="s0">4316 9 get_files 0 3217 3218 26 Loader::Results::get_files 0</span>

<span class="s0">4317 14 get_file_types 0 3217 3219 31 Loader::Results::get_file_types 0</span>

<span class="s0">4318 9 get_types 0 3251 3252 33 LoaderFileTypeRegistry::get_types 0</span>

<span class="s0">4319 13 get_on_stages 0 3326 3327 28 TextureAttrib::get_on_stages 0</span>

<span class="s0">4320 16 get_on_ff_stages 0 3328 3329 31 TextureAttrib::get_on_ff_stages 0</span>

<span class="s0">4321 14 get_off_stages 0 3336 3337 29 TextureAttrib::get_off_stages 0</span>

<span class="s0">4322 12 get_vertices 0 3368 3369 26 OccluderNode::get_vertices 0</span>

<span class="s0">4323 16 get_on_occluders 0 3373 3374 32 OccluderEffect::get_on_occluders 0</span>

<span class="s0">4324 10 get_points 0 3486 3487 25 ScissorEffect::get_points 0</span>

<span class="s0">4325 9 get_nodes 0 3486 3488 24 ScissorEffect::get_nodes 0</span>

<span class="s0">4326 12 get_vertices 0 3527 3528 24 PortalNode::get_vertices 0</span>

</pre>
</body>
</html>