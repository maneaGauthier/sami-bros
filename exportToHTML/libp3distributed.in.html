<html>
<head>
<title>libp3distributed.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3distributed.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">16 libp3distributed 4 nqI8 14 panda3d.direct </span>
<span class="s0">62</span>
<span class="s0">62 21 CConnectionRepository 0 260 124 44 CConnectionRepository::CConnectionRepository 0 1 1 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">explicit CConnectionRepository::CConnectionRepository(bool has_owner_view = false, bool threaded_net = false);</span>

<span class="s0">63 22 ~CConnectionRepository 0 516 124 45 CConnectionRepository::~CConnectionRepository 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">CConnectionRepository::~CConnectionRepository(void);</span>

<span class="s0">64 11 get_dc_file 0 4 124 34 CConnectionRepository::get_dc_file 0 1 2 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the DCFile object associated with this repository.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline DCFile &amp;CConnectionRepository::get_dc_file(void);</span>

<span class="s0">65 14 has_owner_view 0 4 124 37 CConnectionRepository::has_owner_view 0 1 3 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this repository can have 'owner' views of distributed</span>
 <span class="s0">* objects.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool CConnectionRepository::has_owner_view(void) const;</span>

<span class="s0">66 20 set_handle_c_updates 0 4 124 43 CConnectionRepository::set_handle_c_updates 0 1 4 153</span>
<span class="s0">/**</span>
 <span class="s0">* Set true to specify this repository should process distributed updates</span>
 <span class="s0">* internally in C++ code, or false if it should return them to Python.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline void CConnectionRepository::set_handle_c_updates(bool handle_c_updates);</span>

<span class="s0">67 20 get_handle_c_updates 0 4 124 43 CConnectionRepository::get_handle_c_updates 0 1 5 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this repository will process distributed updates internally</span>
 <span class="s0">* in C++ code, or false if it will return them to Python.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool CConnectionRepository::get_handle_c_updates(void) const;</span>

<span class="s0">68 19 set_client_datagram 0 4 124 42 CConnectionRepository::set_client_datagram 0 1 6 281</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the client_datagram flag.  If this is true, incoming datagrams are not</span>
 <span class="s0">* expected to be prefixed with the server routing information like message</span>
 <span class="s0">* sender, channel number, etc.; otherwise, these server fields are parsed and</span>
 <span class="s0">* removed from each incoming datagram.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void CConnectionRepository::set_client_datagram(bool client_datagram);</span>

<span class="s0">69 19 get_client_datagram 0 4 124 42 CConnectionRepository::get_client_datagram 0 1 7 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the client_datagram flag.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline bool CConnectionRepository::get_client_datagram(void) const;</span>

<span class="s0">70 31 set_handle_datagrams_internally 0 4 124 54 CConnectionRepository::set_handle_datagrams_internally 0 1 8 321</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the handle_datagrams_internally flag.  When true, certain message</span>
 <span class="s0">* types can be handled by the C++ code in in this module.  When false, all</span>
 <span class="s0">* datagrams, regardless of message type, are passed up to Python for</span>
 <span class="s0">* processing.</span>
 <span class="s0">*</span>
 <span class="s0">* The CMU distributed-object implementation requires this to be set false.</span>
 <span class="s0">*/</span>
<span class="s0">101</span>
<span class="s0">inline void CConnectionRepository::set_handle_datagrams_internally(bool handle_datagrams_internally);</span>

<span class="s0">71 31 get_handle_datagrams_internally 0 4 124 54 CConnectionRepository::get_handle_datagrams_internally 0 1 9 56</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the handle_datagrams_internally flag.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline bool CConnectionRepository::get_handle_datagrams_internally(void) const;</span>

<span class="s0">72 19 set_tcp_header_size 0 4 124 42 CConnectionRepository::set_tcp_header_size 0 1 10 270</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the header size of TCP packets.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">void CConnectionRepository::set_tcp_header_size(int tcp_header_size);</span>

<span class="s0">73 19 get_tcp_header_size 0 4 124 42 CConnectionRepository::get_tcp_header_size 0 1 11 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of TCP header size.  See set_tcp_header_size().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline int CConnectionRepository::get_tcp_header_size(void) const;</span>

<span class="s0">74 21 set_python_repository 0 4 124 44 CConnectionRepository::set_python_repository 0 1 12 200</span>
<span class="s0">/**</span>
 <span class="s0">* Records the pointer to the Python class that derives from</span>
 <span class="s0">* CConnectionRepository.  This allows the C++ implementation to directly</span>
 <span class="s0">* manipulation some python structures on the repository.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void CConnectionRepository::set_python_repository(PyObject *python_repository);</span>

<span class="s0">75 19 set_connection_http 0 4 124 42 CConnectionRepository::set_connection_http 0 1 13 200</span>
<span class="s0">/**</span>
 <span class="s0">* Once a connection has been established via the HTTP interface, gets the</span>
 <span class="s0">* connection and uses it.  The supplied HTTPChannel object must have a</span>
 <span class="s0">* connection available via get_connection().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void CConnectionRepository::set_connection_http(HTTPChannel *channel);</span>

<span class="s0">76 10 get_stream 0 4 124 33 CConnectionRepository::get_stream 0 1 14 160</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the SocketStream that internally represents the already-established</span>
 <span class="s0">* HTTP connection.  Returns NULL if there is no current HTTP connection.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">SocketStream *CConnectionRepository::get_stream(void);</span>

<span class="s0">77 15 try_connect_net 0 4 124 38 CConnectionRepository::try_connect_net 0 1 15 155</span>
<span class="s0">/**</span>
 <span class="s0">* Uses Panda's &quot;net&quot; library to try to connect to the server and port named</span>
 <span class="s0">* in the indicated URL.  Returns true if successful, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">bool CConnectionRepository::try_connect_net(URLSpec const &amp;url);</span>

<span class="s0">78 7 get_qcm 0 4 124 30 CConnectionRepository::get_qcm 0 1 16 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the QueuedConnectionManager object associated with the repository.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline QueuedConnectionManager &amp;CConnectionRepository::get_qcm(void);</span>

<span class="s0">79 6 get_cw 0 4 124 29 CConnectionRepository::get_cw 0 1 17 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the ConnectionWriter object associated with the repository.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline ConnectionWriter &amp;CConnectionRepository::get_cw(void);</span>

<span class="s0">80 7 get_qcr 0 4 124 30 CConnectionRepository::get_qcr 0 1 18 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the QueuedConnectionReader object associated with the repository.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline QueuedConnectionReader &amp;CConnectionRepository::get_qcr(void);</span>

<span class="s0">81 14 connect_native 0 4 124 37 CConnectionRepository::connect_native 0 1 19 91</span>
<span class="s0">/**</span>
 <span class="s0">* Connects to the server using Panda's low-level and fast &quot;native net&quot;</span>
 <span class="s0">* library.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">bool CConnectionRepository::connect_native(URLSpec const &amp;url);</span>

<span class="s0">82 7 get_bdc 0 4 124 30 CConnectionRepository::get_bdc 0 1 20 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Buffered_DatagramConnection object associated with the</span>
 <span class="s0">* repository.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline Buffered_DatagramConnection &amp;CConnectionRepository::get_bdc(void);</span>

<span class="s0">83 14 check_datagram 0 4 124 37 CConnectionRepository::check_datagram 0 1 21 226</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a new datagram is available, false otherwise.  If the</span>
 <span class="s0">* return value is true, the new datagram may be retrieved via get_datagram(),</span>
 <span class="s0">* or preferably, with get_datagram_iterator() and get_msg_type().</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">bool CConnectionRepository::check_datagram(void);</span>

<span class="s0">84 12 get_datagram 0 4 124 35 CConnectionRepository::get_datagram 0 1 22 102</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the datagram object with the datagram most recently retrieved by</span>
 <span class="s0">* check_datagram().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void CConnectionRepository::get_datagram(Datagram &amp;dg);</span>

<span class="s0">85 21 get_datagram_iterator 0 4 124 44 CConnectionRepository::get_datagram_iterator 0 1 23 256</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the DatagramIterator object with the iterator for the datagram most</span>
 <span class="s0">* recently retrieved by check_datagram().  This iterator has already read</span>
 <span class="s0">* past the datagram header and the message type, and is positioned at the</span>
 <span class="s0">* beginning of data.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline void CConnectionRepository::get_datagram_iterator(DatagramIterator &amp;di);</span>

<span class="s0">86 15 get_msg_channel 0 4 124 38 CConnectionRepository::get_msg_channel 0 1 24 160</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the channel(s) to which the current message was sent, according to</span>
 <span class="s0">* the datagram headers.  This information is not available to the client.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline CHANNEL_TYPE CConnectionRepository::get_msg_channel(int offset = 0) const;</span>

<span class="s0">87 21 get_msg_channel_count 0 4 124 44 CConnectionRepository::get_msg_channel_count 0 1 25 0</span>
<span class="s0">68</span>
<span class="s0">inline int CConnectionRepository::get_msg_channel_count(void) const;</span>

<span class="s0">88 14 get_msg_sender 0 4 124 37 CConnectionRepository::get_msg_sender 0 1 26 144</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sender ID of the current message, according to the datagram</span>
 <span class="s0">* headers.  This information is not available to the client.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline CHANNEL_TYPE CConnectionRepository::get_msg_sender(void) const;</span>

<span class="s0">89 12 get_msg_type 0 4 124 35 CConnectionRepository::get_msg_type 0 1 27 139</span>
<span class="s0">// INLINE unsigned char get_sec_code() const;</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the type ID of the current message, according to the datagram</span>
 <span class="s0">* headers.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline unsigned int CConnectionRepository::get_msg_type(void) const;</span>

<span class="s0">90 23 get_overflow_event_name 0 4 124 46 CConnectionRepository::get_overflow_event_name 0 1 28 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns event string that will be thrown if the datagram reader queue</span>
 <span class="s0">* overflows.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">static inline std::string const &amp;CConnectionRepository::get_overflow_event_name(void);</span>

<span class="s0">91 12 is_connected 0 4 124 35 CConnectionRepository::is_connected 0 1 29 303</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the connection to the gameserver is established and still</span>
 <span class="s0">* good, false if we are not connected.  A false value means either (a) we</span>
 <span class="s0">* never successfully connected, (b) we explicitly called disconnect(), or (c)</span>
 <span class="s0">* we were connected, but the connection was spontaneously lost.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">bool CConnectionRepository::is_connected(void);</span>

<span class="s0">92 13 send_datagram 0 4 124 36 CConnectionRepository::send_datagram 0 1 30 177</span>
<span class="s0">/**</span>
 <span class="s0">* Queues the indicated datagram for sending to the server.  It may not get</span>
 <span class="s0">* sent immediately if collect_tcp is in effect; call flush() to guarantee it</span>
 <span class="s0">* is sent now.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool CConnectionRepository::send_datagram(Datagram const &amp;dg);</span>

<span class="s0">93 25 set_want_message_bundling 0 4 124 48 CConnectionRepository::set_want_message_bundling 0 1 31 51</span>
<span class="s0">/**</span>
 <span class="s0">* Enable/disable outbound message bundling</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void CConnectionRepository::set_want_message_bundling(bool flag);</span>

<span class="s0">94 25 get_want_message_bundling 0 4 124 48 CConnectionRepository::get_want_message_bundling 0 1 32 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if message bundling enabled</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline bool CConnectionRepository::get_want_message_bundling(void) const;</span>

<span class="s0">95 17 set_in_quiet_zone 0 4 124 40 CConnectionRepository::set_in_quiet_zone 0 1 33 43</span>
<span class="s0">/**</span>
 <span class="s0">* Enables/disables quiet zone mode</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void CConnectionRepository::set_in_quiet_zone(bool flag);</span>

<span class="s0">96 17 get_in_quiet_zone 0 4 124 40 CConnectionRepository::get_in_quiet_zone 0 1 34 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if repository is in quiet zone mode</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool CConnectionRepository::get_in_quiet_zone(void) const;</span>

<span class="s0">97 20 start_message_bundle 0 4 124 43 CConnectionRepository::start_message_bundle 0 1 35 300</span>
<span class="s0">/**</span>
 <span class="s0">* Send a set of messages to the state server that will be processed</span>
 <span class="s0">* atomically.  For instance, you can do a combined setLocation/setPos and</span>
 <span class="s0">* prevent race conditions where clients briefly get the setLocation but not</span>
 <span class="s0">* the setPos, because the state server hasn't processed the setPos yet</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void CConnectionRepository::start_message_bundle(void);</span>

<span class="s0">98 20 is_bundling_messages 0 4 124 43 CConnectionRepository::is_bundling_messages 0 1 36 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if repository is queueing outgoing messages into a message</span>
 <span class="s0">* bundle</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool CConnectionRepository::is_bundling_messages(void) const;</span>

<span class="s0">99 19 send_message_bundle 0 4 124 42 CConnectionRepository::send_message_bundle 0 1 37 79</span>
<span class="s0">/**</span>
 <span class="s0">* Send network messages queued up since startMessageBundle was called.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">void CConnectionRepository::send_message_bundle(unsigned int channel, unsigned int sender_channel);</span>

<span class="s0">100 23 abandon_message_bundles 0 4 124 46 CConnectionRepository::abandon_message_bundles 0 1 38 74</span>
<span class="s0">/**</span>
 <span class="s0">* throw out any msgs that have been queued up for message bundles</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void CConnectionRepository::abandon_message_bundles(void);</span>

<span class="s0">101 10 bundle_msg 0 4 124 33 CConnectionRepository::bundle_msg 0 1 39 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void CConnectionRepository::bundle_msg(Datagram const &amp;dg);</span>

<span class="s0">102 14 consider_flush 0 4 124 37 CConnectionRepository::consider_flush 0 1 40 143</span>
<span class="s0">/**</span>
 <span class="s0">* Sends the most recently queued data if enough time has elapsed.  This only</span>
 <span class="s0">* has meaning if set_collect_tcp() has been set to true.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">bool CConnectionRepository::consider_flush(void);</span>

<span class="s0">103 5 flush 0 4 124 28 CConnectionRepository::flush 0 1 41 120</span>
<span class="s0">/**</span>
 <span class="s0">* Sends the most recently queued data now.  This only has meaning if</span>
 <span class="s0">* set_collect_tcp() has been set to true.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">bool CConnectionRepository::flush(void);</span>

<span class="s0">104 10 disconnect 0 4 124 33 CConnectionRepository::disconnect 0 1 42 47</span>
<span class="s0">/**</span>
 <span class="s0">* Closes the connection to the server.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void CConnectionRepository::disconnect(void);</span>

<span class="s0">105 8 shutdown 0 4 124 31 CConnectionRepository::shutdown 0 1 43 86</span>
<span class="s0">/**</span>
 <span class="s0">* May be called at application shutdown to ensure all threads are cleaned up.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void CConnectionRepository::shutdown(void);</span>

<span class="s0">106 24 set_simulated_disconnect 0 4 124 47 CConnectionRepository::set_simulated_disconnect 0 1 44 185</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the simulated disconnect flag.  While this is true, no datagrams will</span>
 <span class="s0">* be retrieved from or sent to the server.  The idea is to simulate a</span>
 <span class="s0">* temporary network outage.</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void CConnectionRepository::set_simulated_disconnect(bool simulated_disconnect);</span>

<span class="s0">107 24 get_simulated_disconnect 0 4 124 47 CConnectionRepository::get_simulated_disconnect 0 1 45 188</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the simulated disconnect flag.  While this is true, no datagrams</span>
 <span class="s0">* will be retrieved from or sent to the server.  The idea is to simulate a</span>
 <span class="s0">* temporary network outage.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline bool CConnectionRepository::get_simulated_disconnect(void) const;</span>

<span class="s0">108 14 toggle_verbose 0 4 124 37 CConnectionRepository::toggle_verbose 0 1 46 137</span>
<span class="s0">/**</span>
 <span class="s0">* Toggles the current setting of the verbose flag.  When true, this describes</span>
 <span class="s0">* every message going back and forth on the wire.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void CConnectionRepository::toggle_verbose(void);</span>

<span class="s0">109 11 set_verbose 0 4 124 34 CConnectionRepository::set_verbose 0 1 47 120</span>
<span class="s0">/**</span>
 <span class="s0">* Directly sets the verbose flag.  When true, this describes every message</span>
 <span class="s0">* going back and forth on the wire.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void CConnectionRepository::set_verbose(bool verbose);</span>

<span class="s0">110 11 get_verbose 0 4 124 34 CConnectionRepository::get_verbose 0 1 48 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the verbose flag.  When true, this describes</span>
 <span class="s0">* every message going back and forth on the wire.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool CConnectionRepository::get_verbose(void) const;</span>

<span class="s0">111 16 set_time_warning 0 4 124 39 CConnectionRepository::set_time_warning 0 1 49 170</span>
<span class="s0">/**</span>
 <span class="s0">* Directly sets the time_warning field.  When non zero, this describes every</span>
 <span class="s0">* message going back and forth on the wire when the msg handling time is over</span>
 <span class="s0">* it</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void CConnectionRepository::set_time_warning(float time_warning);</span>

<span class="s0">112 16 get_time_warning 0 4 124 39 CConnectionRepository::get_time_warning 0 1 50 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the time_warning field.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline float CConnectionRepository::get_time_warning(void) const;</span>

<span class="s0">113 26 CDistributedSmoothNodeBase 0 260 125 54 CDistributedSmoothNodeBase::CDistributedSmoothNodeBase 0 2 51 52 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(void);</span>
<span class="s0">inline CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(CDistributedSmoothNodeBase const &amp;) = default;</span>

<span class="s0">114 27 ~CDistributedSmoothNodeBase 0 516 125 55 CDistributedSmoothNodeBase::~CDistributedSmoothNodeBase 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">CDistributedSmoothNodeBase::~CDistributedSmoothNodeBase(void);</span>

<span class="s0">115 14 set_repository 0 4 125 42 CDistributedSmoothNodeBase::set_repository 0 1 53 110</span>
<span class="s0">/**</span>
 <span class="s0">* Tells the C++ instance definition about the AI or Client repository, used</span>
 <span class="s0">* for sending datagrams.</span>
 <span class="s0">*/</span>
<span class="s0">122</span>
<span class="s0">inline void CDistributedSmoothNodeBase::set_repository(CConnectionRepository *repository, bool is_ai, CHANNEL_TYPE ai_id);</span>

<span class="s0">116 15 set_clock_delta 0 4 125 43 CDistributedSmoothNodeBase::set_clock_delta 0 1 54 80</span>
<span class="s0">/**</span>
 <span class="s0">* Tells the C++ instance definition about the global ClockDelta object.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline void CDistributedSmoothNodeBase::set_clock_delta(PyObject *clock_delta);</span>

<span class="s0">117 10 initialize 0 4 125 38 CDistributedSmoothNodeBase::initialize 0 1 55 248</span>
<span class="s0">/**</span>
 <span class="s0">* Initializes the internal structures from some constructs that are normally</span>
 <span class="s0">* stored only in Python.  Also reads the current node's pos &amp; hpr values in</span>
 <span class="s0">* preparation for transmitting them via one of the broadcast_pos_hpr_*()</span>
 <span class="s0">* methods.</span>
 <span class="s0">*/</span>
<span class="s0">108</span>
<span class="s0">void CDistributedSmoothNodeBase::initialize(NodePath const &amp;node_path, DCClass *dclass, CHANNEL_TYPE do_id);</span>

<span class="s0">118 15 send_everything 0 4 125 43 CDistributedSmoothNodeBase::send_everything 0 1 56 63</span>
<span class="s0">/**</span>
 <span class="s0">* Broadcasts the current pos/hpr in its complete form.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void CDistributedSmoothNodeBase::send_everything(void);</span>

<span class="s0">119 22 broadcast_pos_hpr_full 0 4 125 50 CDistributedSmoothNodeBase::broadcast_pos_hpr_full 0 1 57 143</span>
<span class="s0">/**</span>
 <span class="s0">* Examines the complete pos/hpr information to see which of the six elements</span>
 <span class="s0">* have changed, and broadcasts the appropriate messages.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void CDistributedSmoothNodeBase::broadcast_pos_hpr_full(void);</span>

<span class="s0">120 21 broadcast_pos_hpr_xyh 0 4 125 49 CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh 0 1 58 108</span>
<span class="s0">/**</span>
 <span class="s0">* Examines only X, Y, and H of the pos/hpr information, and broadcasts the</span>
 <span class="s0">* appropriate messages.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh(void);</span>

<span class="s0">121 20 broadcast_pos_hpr_xy 0 4 125 48 CDistributedSmoothNodeBase::broadcast_pos_hpr_xy 0 1 59 104</span>
<span class="s0">/**</span>
 <span class="s0">* Examines only X and Y of the pos/hpr information, and broadcasts the</span>
 <span class="s0">* appropriate messages.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void CDistributedSmoothNodeBase::broadcast_pos_hpr_xy(void);</span>

<span class="s0">122 10 set_curr_l 0 4 125 38 CDistributedSmoothNodeBase::set_curr_l 0 1 60 54</span>
<span class="s0">/**</span>
 <span class="s0">* Appends the timestamp and sends the update.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void CDistributedSmoothNodeBase::set_curr_l(uint64_t l);</span>

<span class="s0">123 12 print_curr_l 0 4 125 40 CDistributedSmoothNodeBase::print_curr_l 0 1 61 0</span>
<span class="s0">52</span>
<span class="s0">void CDistributedSmoothNodeBase::print_curr_l(void);</span>

<span class="s0">61</span>
<span class="s0">1 0 0 7 2 127 63 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 14 has_owner_view 5 126  12 threaded_net 5 126  </span>
<span class="s0">2 0 0 6 4 128 0 0 69 /**</span>
 <span class="s0">* Returns the DCFile object associated with this repository.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">3 0 0 6 5 126 0 0 92 /**</span>
 <span class="s0">* Returns true if this repository can have 'owner' views of distributed</span>
 <span class="s0">* objects.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">4 0 0 4 6 132 0 0 153 /**</span>
 <span class="s0">* Set true to specify this repository should process distributed updates</span>
 <span class="s0">* internally in C++ code, or false if it should return them to Python.</span>
 <span class="s0">*/ 2 4 this 3 127  16 handle_c_updates 1 126  </span>
<span class="s0">5 0 0 6 7 126 0 0 145 /**</span>
 <span class="s0">* Returns true if this repository will process distributed updates internally</span>
 <span class="s0">* in C++ code, or false if it will return them to Python.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">6 0 0 4 8 132 0 0 281 /**</span>
 <span class="s0">* Sets the client_datagram flag.  If this is true, incoming datagrams are not</span>
 <span class="s0">* expected to be prefixed with the server routing information like message</span>
 <span class="s0">* sender, channel number, etc.; otherwise, these server fields are parsed and</span>
 <span class="s0">* removed from each incoming datagram.</span>
 <span class="s0">*/ 2 4 this 3 127  15 client_datagram 1 126  </span>
<span class="s0">7 0 0 6 9 126 0 0 44 /**</span>
 <span class="s0">* Returns the client_datagram flag.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">8 0 0 4 10 132 0 0 321 /**</span>
 <span class="s0">* Sets the handle_datagrams_internally flag.  When true, certain message</span>
 <span class="s0">* types can be handled by the C++ code in in this module.  When false, all</span>
 <span class="s0">* datagrams, regardless of message type, are passed up to Python for</span>
 <span class="s0">* processing.</span>
 <span class="s0">*</span>
 <span class="s0">* The CMU distributed-object implementation requires this to be set false.</span>
 <span class="s0">*/ 2 4 this 3 127  27 handle_datagrams_internally 1 126  </span>
<span class="s0">9 0 0 6 11 126 0 0 56 /**</span>
 <span class="s0">* Returns the handle_datagrams_internally flag.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">10 0 0 4 12 132 0 0 270 /**</span>
 <span class="s0">* Sets the header size of TCP packets.  At the present, legal values for this</span>
 <span class="s0">* are 0, 2, or 4; this specifies the number of bytes to use encode the</span>
 <span class="s0">* datagram length at the start of each TCP datagram.  Sender and receiver</span>
 <span class="s0">* must independently agree on this.</span>
 <span class="s0">*/ 2 4 this 3 127  15 tcp_header_size 1 133  </span>
<span class="s0">11 0 0 6 13 133 0 0 86 /**</span>
 <span class="s0">* Returns the current setting of TCP header size.  See set_tcp_header_size().</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">12 0 0 4 14 132 0 0 200 /**</span>
 <span class="s0">* Records the pointer to the Python class that derives from</span>
 <span class="s0">* CConnectionRepository.  This allows the C++ implementation to directly</span>
 <span class="s0">* manipulation some python structures on the repository.</span>
 <span class="s0">*/ 2 4 this 3 127  17 python_repository 1 134  </span>
<span class="s0">13 0 0 4 15 132 0 0 200 /**</span>
 <span class="s0">* Once a connection has been established via the HTTP interface, gets the</span>
 <span class="s0">* connection and uses it.  The supplied HTTPChannel object must have a</span>
 <span class="s0">* connection available via get_connection().</span>
 <span class="s0">*/ 2 4 this 3 127  7 channel 1 137  </span>
<span class="s0">14 0 0 6 16 139 0 0 160 /**</span>
 <span class="s0">* Returns the SocketStream that internally represents the already-established</span>
 <span class="s0">* HTTP connection.  Returns NULL if there is no current HTTP connection.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">15 0 0 6 17 126 0 0 155 /**</span>
 <span class="s0">* Uses Panda's &quot;net&quot; library to try to connect to the server and port named</span>
 <span class="s0">* in the indicated URL.  Returns true if successful, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 127  3 url 1 141  </span>
<span class="s0">16 0 0 6 18 144 0 0 85 /**</span>
 <span class="s0">* Returns the QueuedConnectionManager object associated with the repository.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">17 0 0 6 19 146 0 0 78 /**</span>
 <span class="s0">* Returns the ConnectionWriter object associated with the repository.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">18 0 0 6 20 148 0 0 84 /**</span>
 <span class="s0">* Returns the QueuedConnectionReader object associated with the repository.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">19 0 0 6 21 126 0 0 91 /**</span>
 <span class="s0">* Connects to the server using Panda's low-level and fast &quot;native net&quot;</span>
 <span class="s0">* library.</span>
 <span class="s0">*/ 2 4 this 3 127  3 url 1 141  </span>
<span class="s0">20 0 0 6 22 150 0 0 92 /**</span>
 <span class="s0">* Returns the Buffered_DatagramConnection object associated with the</span>
 <span class="s0">* repository.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">21 0 0 6 23 126 0 0 226 /**</span>
 <span class="s0">* Returns true if a new datagram is available, false otherwise.  If the</span>
 <span class="s0">* return value is true, the new datagram may be retrieved via get_datagram(),</span>
 <span class="s0">* or preferably, with get_datagram_iterator() and get_msg_type().</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">22 0 0 4 24 132 0 0 102 /**</span>
 <span class="s0">* Fills the datagram object with the datagram most recently retrieved by</span>
 <span class="s0">* check_datagram().</span>
 <span class="s0">*/ 2 4 this 3 127  2 dg 1 152  </span>
<span class="s0">23 0 0 4 25 132 0 0 256 /**</span>
 <span class="s0">* Fills the DatagramIterator object with the iterator for the datagram most</span>
 <span class="s0">* recently retrieved by check_datagram().  This iterator has already read</span>
 <span class="s0">* past the datagram header and the message type, and is positioned at the</span>
 <span class="s0">* beginning of data.</span>
 <span class="s0">*/ 2 4 this 3 127  2 di 1 154  </span>
<span class="s0">24 0 0 6 26 156 0 0 160 /**</span>
 <span class="s0">* Returns the channel(s) to which the current message was sent, according to</span>
 <span class="s0">* the datagram headers.  This information is not available to the client.</span>
 <span class="s0">*/ 2 4 this 3 130  6 offset 5 133  </span>
<span class="s0">25 0 0 6 27 133 0 0 0 1 4 this 3 130  </span>
<span class="s0">26 0 0 6 28 156 0 0 144 /**</span>
 <span class="s0">* Returns the sender ID of the current message, according to the datagram</span>
 <span class="s0">* headers.  This information is not available to the client.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">27 0 0 6 29 159 0 0 92 /**</span>
 <span class="s0">* Returns the type ID of the current message, according to the datagram</span>
 <span class="s0">* headers.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">28 0 0 6 30 160 0 0 94 /**</span>
 <span class="s0">* Returns event string that will be thrown if the datagram reader queue</span>
 <span class="s0">* overflows.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">29 0 0 6 31 126 0 0 303 /**</span>
 <span class="s0">* Returns true if the connection to the gameserver is established and still</span>
 <span class="s0">* good, false if we are not connected.  A false value means either (a) we</span>
 <span class="s0">* never successfully connected, (b) we explicitly called disconnect(), or (c)</span>
 <span class="s0">* we were connected, but the connection was spontaneously lost.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">30 0 0 6 32 126 0 0 177 /**</span>
 <span class="s0">* Queues the indicated datagram for sending to the server.  It may not get</span>
 <span class="s0">* sent immediately if collect_tcp is in effect; call flush() to guarantee it</span>
 <span class="s0">* is sent now.</span>
 <span class="s0">*/ 2 4 this 3 127  2 dg 1 161  </span>
<span class="s0">31 0 0 4 33 132 0 0 51 /**</span>
 <span class="s0">* Enable/disable outbound message bundling</span>
 <span class="s0">*/ 2 4 this 3 127  4 flag 1 126  </span>
<span class="s0">32 0 0 6 34 126 0 0 51 /**</span>
 <span class="s0">* Returns true if message bundling enabled</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">33 0 0 4 35 132 0 0 43 /**</span>
 <span class="s0">* Enables/disables quiet zone mode</span>
 <span class="s0">*/ 2 4 this 3 127  4 flag 1 126  </span>
<span class="s0">34 0 0 6 36 126 0 0 59 /**</span>
 <span class="s0">* Returns true if repository is in quiet zone mode</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">35 0 0 4 37 132 0 0 300 /**</span>
 <span class="s0">* Send a set of messages to the state server that will be processed</span>
 <span class="s0">* atomically.  For instance, you can do a combined setLocation/setPos and</span>
 <span class="s0">* prevent race conditions where clients briefly get the setLocation but not</span>
 <span class="s0">* the setPos, because the state server hasn't processed the setPos yet</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">36 0 0 6 38 126 0 0 92 /**</span>
 <span class="s0">* Returns true if repository is queueing outgoing messages into a message</span>
 <span class="s0">* bundle</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">37 0 0 4 39 132 0 0 79 /**</span>
 <span class="s0">* Send network messages queued up since startMessageBundle was called.</span>
 <span class="s0">*/ 3 4 this 3 127  7 channel 1 159  14 sender_channel 1 159  </span>
<span class="s0">38 0 0 4 40 132 0 0 74 /**</span>
 <span class="s0">* throw out any msgs that have been queued up for message bundles</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">39 0 0 4 41 132 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 127  2 dg 1 161  </span>
<span class="s0">40 0 0 6 42 126 0 0 143 /**</span>
 <span class="s0">* Sends the most recently queued data if enough time has elapsed.  This only</span>
 <span class="s0">* has meaning if set_collect_tcp() has been set to true.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">41 0 0 6 43 126 0 0 120 /**</span>
 <span class="s0">* Sends the most recently queued data now.  This only has meaning if</span>
 <span class="s0">* set_collect_tcp() has been set to true.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">42 0 0 4 44 132 0 0 47 /**</span>
 <span class="s0">* Closes the connection to the server.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">43 0 0 4 45 132 0 0 86 /**</span>
 <span class="s0">* May be called at application shutdown to ensure all threads are cleaned up.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">44 0 0 4 46 132 0 0 185 /**</span>
 <span class="s0">* Sets the simulated disconnect flag.  While this is true, no datagrams will</span>
 <span class="s0">* be retrieved from or sent to the server.  The idea is to simulate a</span>
 <span class="s0">* temporary network outage.</span>
 <span class="s0">*/ 2 4 this 3 127  20 simulated_disconnect 1 126  </span>
<span class="s0">45 0 0 6 47 126 0 0 188 /**</span>
 <span class="s0">* Returns the simulated disconnect flag.  While this is true, no datagrams</span>
 <span class="s0">* will be retrieved from or sent to the server.  The idea is to simulate a</span>
 <span class="s0">* temporary network outage.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">46 0 0 4 48 132 0 0 137 /**</span>
 <span class="s0">* Toggles the current setting of the verbose flag.  When true, this describes</span>
 <span class="s0">* every message going back and forth on the wire.</span>
 <span class="s0">*/ 1 4 this 3 127  </span>
<span class="s0">47 0 0 4 49 132 0 0 120 /**</span>
 <span class="s0">* Directly sets the verbose flag.  When true, this describes every message</span>
 <span class="s0">* going back and forth on the wire.</span>
 <span class="s0">*/ 2 4 this 3 127  7 verbose 1 126  </span>
<span class="s0">48 0 0 6 50 126 0 0 137 /**</span>
 <span class="s0">* Returns the current setting of the verbose flag.  When true, this describes</span>
 <span class="s0">* every message going back and forth on the wire.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">49 0 0 4 51 132 0 0 170 /**</span>
 <span class="s0">* Directly sets the time_warning field.  When non zero, this describes every</span>
 <span class="s0">* message going back and forth on the wire when the msg handling time is over</span>
 <span class="s0">* it</span>
 <span class="s0">*/ 2 4 this 3 127  12 time_warning 1 163  </span>
<span class="s0">50 0 0 6 52 163 0 0 65 /**</span>
 <span class="s0">* Returns the current setting of the time_warning field.</span>
 <span class="s0">*/ 1 4 this 3 130  </span>
<span class="s0">51 0 0 7 54 164 114 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">52 0 0 15 54 164 114 0 0 1 6 param0 0 165  </span>
<span class="s0">53 0 0 4 56 132 0 0 110 /**</span>
 <span class="s0">* Tells the C++ instance definition about the AI or Client repository, used</span>
 <span class="s0">* for sending datagrams.</span>
 <span class="s0">*/ 4 4 this 3 164  10 repository 1 127  5 is_ai 1 126  5 ai_id 1 156  </span>
<span class="s0">54 0 0 4 57 132 0 0 80 /**</span>
 <span class="s0">* Tells the C++ instance definition about the global ClockDelta object.</span>
 <span class="s0">*/ 2 4 this 3 164  11 clock_delta 1 134  </span>
<span class="s0">55 0 0 4 58 132 0 0 248 /**</span>
 <span class="s0">* Initializes the internal structures from some constructs that are normally</span>
 <span class="s0">* stored only in Python.  Also reads the current node's pos &amp; hpr values in</span>
 <span class="s0">* preparation for transmitting them via one of the broadcast_pos_hpr_*()</span>
 <span class="s0">* methods.</span>
 <span class="s0">*/ 4 4 this 3 164  9 node_path 1 167  6 dclass 1 170  5 do_id 1 156  </span>
<span class="s0">56 0 0 4 59 132 0 0 63 /**</span>
 <span class="s0">* Broadcasts the current pos/hpr in its complete form.</span>
 <span class="s0">*/ 1 4 this 3 164  </span>
<span class="s0">57 0 0 4 60 132 0 0 143 /**</span>
 <span class="s0">* Examines the complete pos/hpr information to see which of the six elements</span>
 <span class="s0">* have changed, and broadcasts the appropriate messages.</span>
 <span class="s0">*/ 1 4 this 3 164  </span>
<span class="s0">58 0 0 4 61 132 0 0 108 /**</span>
 <span class="s0">* Examines only X, Y, and H of the pos/hpr information, and broadcasts the</span>
 <span class="s0">* appropriate messages.</span>
 <span class="s0">*/ 1 4 this 3 164  </span>
<span class="s0">59 0 0 4 62 132 0 0 104 /**</span>
 <span class="s0">* Examines only X and Y of the pos/hpr information, and broadcasts the</span>
 <span class="s0">* appropriate messages.</span>
 <span class="s0">*/ 1 4 this 3 164  </span>
<span class="s0">60 0 0 4 63 132 0 0 54 /**</span>
 <span class="s0">* Appends the timestamp and sends the update.</span>
 <span class="s0">*/ 2 4 this 3 164  1 l 1 157  </span>
<span class="s0">61 0 0 4 64 132 0 0 0 1 4 this 3 164  </span>
<span class="s0">48</span>
<span class="s0">124 21 CConnectionRepository 0 26625 21 CConnectionRepository 21 CConnectionRepository 0 0 0 1 62 63 0 49 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 0 0 0 0 0 568</span>
<span class="s0">/**</span>
 <span class="s0">* This class implements the C++ side of the ConnectionRepository object.  In</span>
 <span class="s0">* particular, it manages the connection to the server once it has been opened</span>
 <span class="s0">* (but does not open it directly).  It manages reading and writing datagrams</span>
 <span class="s0">* on the connection and monitoring for unexpected disconnects as well as</span>
 <span class="s0">* handling intentional disconnects.</span>
 <span class="s0">*</span>
 <span class="s0">* Certain server messages, like field updates, are handled entirely within</span>
 <span class="s0">* the C++ layer, while server messages that are not understood by the C++</span>
 <span class="s0">* layer are returned up to the Python layer for processing.</span>
 <span class="s0">*/</span>

<span class="s0">125 26 CDistributedSmoothNodeBase 0 26625 26 CDistributedSmoothNodeBase 26 CDistributedSmoothNodeBase 0 0 0 1 113 114 0 9 115 116 117 118 119 120 121 122 123 0 0 0 0 0 142</span>
<span class="s0">/**</span>
 <span class="s0">* This class defines some basic methods of DistributedSmoothNodeBase which</span>
 <span class="s0">* have been moved into C++ as a performance optimization.</span>
 <span class="s0">*/</span>

<span class="s0">126 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">127 23 CConnectionRepository * 0 8576 23 CConnectionRepository * 23 CConnectionRepository * 0 0 124 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">128 8 DCFile * 0 8576 8 DCFile * 8 DCFile * 0 0 129 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">129 6 DCFile 0 2048 6 DCFile 6 DCFile 0 0 0 0 0 0 0 0 0 0 0 0 101</span>
<span class="s0">/**</span>
 <span class="s0">* Represents the complete list of Distributed Class descriptions as read from</span>
 <span class="s0">* a .dc file.</span>
 <span class="s0">*/</span>

<span class="s0">130 29 CConnectionRepository const * 0 8576 29 CConnectionRepository const * 29 CConnectionRepository const * 0 0 131 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">131 27 CConnectionRepository const 0 8832 27 CConnectionRepository const 27 CConnectionRepository const 0 0 124 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">132 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">133 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">134 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 135 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">135 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 136 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">136 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">137 13 HTTPChannel * 0 8576 13 HTTPChannel * 13 HTTPChannel * 0 0 138 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">138 11 HTTPChannel 0 2048 11 HTTPChannel 11 HTTPChannel 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">139 14 SocketStream * 0 8576 14 SocketStream * 14 SocketStream * 0 0 140 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">140 12 SocketStream 0 2048 12 SocketStream 12 SocketStream 0 0 0 0 0 0 0 0 0 0 0 0 97</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for iostreams that read and write to a (possibly non-blocking)</span>
 <span class="s0">* socket.</span>
 <span class="s0">*/</span>

<span class="s0">141 15 URLSpec const * 0 8576 15 URLSpec const * 15 URLSpec const * 0 0 142 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">142 13 URLSpec const 0 8832 13 URLSpec const 13 URLSpec const 0 0 143 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">143 7 URLSpec 0 2048 7 URLSpec 7 URLSpec 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">144 25 QueuedConnectionManager * 0 8576 25 QueuedConnectionManager * 25 QueuedConnectionManager * 0 0 145 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">145 23 QueuedConnectionManager 0 2048 23 QueuedConnectionManager 23 QueuedConnectionManager 0 0 0 0 0 0 0 0 0 0 0 0 423</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of ConnectionManager will queue up all of the reset-connection</span>
 <span class="s0">* messages from the ConnectionReaders and ConnectionWriters and report them</span>
 <span class="s0">* to the client on demand.</span>
 <span class="s0">*</span>
 <span class="s0">* When a reset connection has been discovered via</span>
 <span class="s0">* reset_connection_available()/get_reset_connection(), it is still the</span>
 <span class="s0">* responsibility of the client to call close_connection() on that connection</span>
 <span class="s0">* to free up its resources.</span>
 <span class="s0">*/</span>

<span class="s0">146 18 ConnectionWriter * 0 8576 18 ConnectionWriter * 18 ConnectionWriter * 0 0 147 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">147 16 ConnectionWriter 0 2048 16 ConnectionWriter 16 ConnectionWriter 0 0 0 0 0 0 0 0 0 0 0 0 294</span>
<span class="s0">/**</span>
 <span class="s0">* This class handles threaded delivery of datagrams to various TCP or UDP</span>
 <span class="s0">* sockets.</span>
 <span class="s0">*</span>
 <span class="s0">* A ConnectionWriter may define an arbitrary number of threads (0 or more) to</span>
 <span class="s0">* write its datagrams to sockets.  The number of threads is specified at</span>
 <span class="s0">* construction time and cannot be changed.</span>
 <span class="s0">*/</span>

<span class="s0">148 24 QueuedConnectionReader * 0 8576 24 QueuedConnectionReader * 24 QueuedConnectionReader * 0 0 149 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">149 22 QueuedConnectionReader 0 2048 22 QueuedConnectionReader 22 QueuedConnectionReader 0 0 0 0 0 0 0 0 0 0 0 0 291</span>
<span class="s0">/**</span>
 <span class="s0">* This flavor of ConnectionReader will read from its sockets and queue up all</span>
 <span class="s0">* of the datagrams read for later receipt by the client code.  This class is</span>
 <span class="s0">* useful for client code that doesn't want to deal with threading and is</span>
 <span class="s0">* willing to poll for datagrams at its convenience.</span>
 <span class="s0">*/</span>

<span class="s0">150 29 Buffered_DatagramConnection * 0 8576 29 Buffered_DatagramConnection * 29 Buffered_DatagramConnection * 0 0 151 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">151 27 Buffered_DatagramConnection 0 2048 27 Buffered_DatagramConnection 27 Buffered_DatagramConnection 0 0 0 0 0 0 0 0 0 0 0 0 176</span>
<span class="s0">// there are 3 states 1. Socket not even assigned,,,, 2. Socket Assigned and</span>
<span class="s0">// trying to get a active connect open 3. Socket is open and  writable.. (</span>
<span class="s0">// Fully powered up )...</span>

<span class="s0">152 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 153 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">153 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">154 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 155 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">155 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 365</span>
<span class="s0">/**</span>
 <span class="s0">* A class to retrieve the individual data elements previously stored in a</span>
 <span class="s0">* Datagram.  Elements may be retrieved one at a time; it is up to the caller</span>
 <span class="s0">* to know the correct type and order of each element.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that it is the responsibility of the caller to ensure that the datagram</span>
 <span class="s0">* object is not destructed while this DatagramIterator is in use.</span>
 <span class="s0">*/</span>

<span class="s0">156 12 CHANNEL_TYPE 0 2105344 12 CHANNEL_TYPE 12 CHANNEL_TYPE 0 0 157 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">157 8 uint64_t 0 2105344 8 uint64_t 8 uint64_t 0 0 158 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">158 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">159 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">160 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">161 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 162 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">162 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 153 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">163 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">164 28 CDistributedSmoothNodeBase * 0 8576 28 CDistributedSmoothNodeBase * 28 CDistributedSmoothNodeBase * 0 0 125 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">165 34 CDistributedSmoothNodeBase const * 0 8576 34 CDistributedSmoothNodeBase const * 34 CDistributedSmoothNodeBase const * 0 0 166 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">166 32 CDistributedSmoothNodeBase const 0 8832 32 CDistributedSmoothNodeBase const 32 CDistributedSmoothNodeBase const 0 0 125 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">167 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 168 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">168 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 169 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">169 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">170 9 DCClass * 0 8576 9 DCClass * 9 DCClass * 0 0 171 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">171 7 DCClass 0 2048 7 DCClass 7 DCClass 0 0 0 0 0 0 0 0 0 0 0 0 80</span>
<span class="s0">/**</span>
 <span class="s0">* Defines a particular DistributedClass as read from an input .dc file.</span>
 <span class="s0">*/</span>

<span class="s0">0</span>
<span class="s0">0</span>
<span class="s0">0</span>
</pre>
</body>
</html>