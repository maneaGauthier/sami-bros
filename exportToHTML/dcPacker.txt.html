<html>
<head>
<title>dcPacker.txt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dcPacker.txt</font>
</center></td></tr></table>
<pre><span class="s0">This document introduces the basic use of the DCPacker class, which is</span>
<span class="s0">available to C++ and Python programs for high-level packing and</span>
<span class="s0">unpacking of messages into bytestreams for shipping over the network,</span>
<span class="s0">especially via Panda's DistributedObject system.  See also the</span>
<span class="s0">comments in direct/src/dcparser/dcPacker.h and related source files.</span>


<span class="s0">OVERVIEW</span>

<span class="s0">The DCPacker has four modes of operation: pack (sequential write),</span>
<span class="s0">unpack (sequential read), unpack (random read), and repack (random</span>
<span class="s0">write).</span>

<span class="s0">To enter one of these four modes, call begin_pack(), begin_unpack(),</span>
<span class="s0">or begin_repack().  (begin_unpack() is used for both kinds of unpack</span>
<span class="s0">modes.)  Once you have called begin, you can call a series of</span>
<span class="s0">pack_this() or unpack_that() methods, and then you finish up by</span>
<span class="s0">calling end_pack(), end_unpack(), or end_repack().</span>

<span class="s0">The return value of the end method will be true to indicate that no</span>
<span class="s0">errors have occurred during the packing/unpacking process, or false if</span>
<span class="s0">something went wrong (in which case you should probably disregard the</span>
<span class="s0">output).</span>

<span class="s0">In general, when packing or unpacking a series of values, you call</span>
<span class="s0">pack_int(), pack_uint(), pack_double(), or pack_string() (or the</span>
<span class="s0">corresponding unpack methods) according to what kind of data type you</span>
<span class="s0">have for each value; it will be coerced into the appropriate data size</span>
<span class="s0">as indicated by the DC file and written to the output buffer.</span>

<span class="s0">To pack an array or an embedded class, or any element which itself is</span>
<span class="s0">made up of sub-elements, you must bracket the packs for the</span>
<span class="s0">sub-elements between calls to push() and pop().  This also applies to</span>
<span class="s0">the individual elements of a DCField; so to pack all the elements of a</span>
<span class="s0">field, you would call push(), followed by the appropriate pack() for</span>
<span class="s0">each element, then pop().</span>


<span class="s0">PACK MODE (sequential write)</span>

<span class="s0">Pack mode is used to build up a network message from scratch.  Call</span>
<span class="s0">begin_pack() and pass it the pointer to a DCField object.  You must</span>
<span class="s0">immediately call push() to indicate that you will be packing the</span>
<span class="s0">individual elements of the field, then make a series of pack calls,</span>
<span class="s0">one for each element on the field in order, followed by a call to</span>
<span class="s0">pop(), and finally end_pack().</span>

<span class="s0">You must pack all of the elements of the field, from beginning to</span>
<span class="s0">end--it is an error to leave out any elements, including the elements</span>
<span class="s0">on the end.</span>

<span class="s0">If end_pack() returns false, there was an error (see ADDITIONAL NOTES,</span>
<span class="s0">below).  Otherwise, you may call get_data() to get a pointer to the</span>
<span class="s0">packed data record, and get_length() to get the number of bytes in the</span>
<span class="s0">record.  If you immediately call begin_pack() again, you will append</span>
<span class="s0">additional data onto the end of the pack buffer--to reset the buffer</span>
<span class="s0">between pack sessions, call clear_data().</span>

  <span class="s0">DCField *field = dclass-&gt;get_field_by_name(&quot;setChat&quot;);</span>

  <span class="s0">DCPacker packer;</span>
  <span class="s0">packer.begin_pack(field);</span>
  <span class="s0">packer.push();</span>
  <span class="s0">packer.pack_string(chatString);</span>
  <span class="s0">packer.pack_int(0);</span>
  <span class="s0">packer.pop();</span>
  <span class="s0">if (!packer.end_pack()) {</span>
    <span class="s0">cerr &lt;&lt; &quot;error occurred while packing.\n&quot;;</span>
    <span class="s0">return;</span>
  <span class="s0">}</span>

  <span class="s0">memcpy(result, packer.get_data(), packer.get_length());</span>



<span class="s0">UNPACK MODE (sequential read)</span>

<span class="s0">You can also unpack all the elements of a field, from beginning to</span>
<span class="s0">end.  This is very similar to pack mode, above.  Start with a call to</span>
<span class="s0">set_unpack_data() to specify the existing data record for the field,</span>
<span class="s0">and then call begin_unpack() with the pointer to the DCField itself.</span>
<span class="s0">Then call push(), followed by the appropriate number and type of</span>
<span class="s0">unpack calls, followed by pop() and end_unpack().</span>

<span class="s0">As above, you must unpack all fields; it is an error not to unpack the</span>
<span class="s0">fields on the end.  However, it is not an error if there are</span>
<span class="s0">additional bytes in the data buffer; the assumption is the data buffer</span>
<span class="s0">may be part of a larger buffer.  After end_unpack(), you can call</span>
<span class="s0">get_num_unpacked_bytes() to determine how many bytes of the buffer</span>
<span class="s0">were consumed.  (If you immediately call begin_unpack() again, you</span>
<span class="s0">will begin to unpack the next record from the current point in the</span>
<span class="s0">buffer.)</span>

  <span class="s0">DCField *field = dclass-&gt;get_field_by_name(&quot;setChat&quot;);</span>

  <span class="s0">DCPacker packer;</span>
  <span class="s0">packer.set_unpack_data(source_buffer, source_size, false);</span>
  <span class="s0">packer.begin_unpack(field);</span>
  <span class="s0">packer.push();</span>
  <span class="s0">string chat = packer.unpack_string();</span>
  <span class="s0">int chatFlags = packer.unpack_int();</span>
  <span class="s0">packer.pop();</span>
  <span class="s0">if (!packer.end_unpack()) {</span>
    <span class="s0">cerr &lt;&lt; &quot;error occurred while unpacking.\n&quot;;</span>
    <span class="s0">return;</span>
  <span class="s0">}</span>


<span class="s0">UNPACK MODE (random read)</span>

<span class="s0">You can also unpack just the particular elements that you care about</span>
<span class="s0">by name, in no particular order.  To do this, call seek() for each</span>
<span class="s0">element you wish to unpack, specifying the name of the element.  You</span>
<span class="s0">can only do this for elements that have been given names in the DC</span>
<span class="s0">file.</span>

<span class="s0">In this case, it is not necessary to bracket the outer unpack calls</span>
<span class="s0">with push() and pop() (since you are not walking through all the</span>
<span class="s0">elements of the field).  However, you still need to use push() and</span>
<span class="s0">pop() to unpack the nested elements of an array that you seek to.</span>

  <span class="s0">DCField *field = dclass-&gt;get_field_by_name(&quot;setChat&quot;);</span>

  <span class="s0">DCPacker packer;</span>
  <span class="s0">packer.set_unpack_data(source_buffer, source_size, false);</span>
  <span class="s0">packer.begin_unpack(field);</span>
  <span class="s0">packer.seek(&quot;chat&quot;);</span>
  <span class="s0">string chat = packer.unpack_string();</span>
  <span class="s0">if (!packer.end_unpack()) {</span>
    <span class="s0">cerr &lt;&lt; &quot;error occurred while unpacking.\n&quot;;</span>
    <span class="s0">return;</span>
  <span class="s0">}</span>

<span class="s0">To seek to a field nested within another structure, use a dot to</span>
<span class="s0">compose the names: &quot;parentName.fieldName&quot;.</span>

<span class="s0">In unpack mode, you may seek to any field that has a name, including a</span>
<span class="s0">field within the currently active case of a switch.  You may also seek</span>
<span class="s0">to a switch parameter variable.  </span>


<span class="s0">REPACK MODE (random write)</span>

<span class="s0">Repack mode allows you to modify some elements of a previously-packed</span>
<span class="s0">field, without disturbing the elements you don't specify.  First, call</span>
<span class="s0">set_unpack_data() as in unpack mode, then begin_repack(); then call</span>
<span class="s0">seek() for each field you want to modify followed by the appropriate</span>
<span class="s0">pack call.</span>

<span class="s0">After end_repack() returns true, you can retrieve the newly-repacked</span>
<span class="s0">field with get_data() and get_length(), just as in pack mode.</span>

  <span class="s0">DCField *field = dclass-&gt;get_field_by_name(&quot;setChat&quot;);</span>

  <span class="s0">DCPacker packer;</span>
  <span class="s0">packer.set_unpack_data(source_buffer, source_size, false);</span>
  <span class="s0">packer.begin_repack(field);</span>
  <span class="s0">packer.seek(&quot;chat&quot;);</span>
  <span class="s0">packer.pack_string(chatString);</span>
  <span class="s0">if (!packer.end_repack()) {</span>
    <span class="s0">cerr &lt;&lt; &quot;error occurred while repacking.\n&quot;;</span>
    <span class="s0">return;</span>
  <span class="s0">}</span>

  <span class="s0">memcpy(result, packer.get_data(), packer.get_length());</span>

<span class="s0">In repack mode, you may not traverse from beginning to end of the</span>
<span class="s0">record--you must explicitly seek to each field you intend to repack.</span>
<span class="s0">You may seek to a field within the currently active case of a switch.</span>
<span class="s0">You may not seek directly to a switch parameter variable--repacking</span>
<span class="s0">this would invalidate the remaining contents of the switch--but you</span>
<span class="s0">may seek to the switch itself (if it has a name) and repack the entire</span>
<span class="s0">contents of the switch at once.</span>


<span class="s0">ADDITIONAL NOTES</span>

<span class="s0">It is acceptable to call pack_int() for a uint type element and</span>
<span class="s0">vice-versa; the data type will be range-checked and converted to the</span>
<span class="s0">appropriate signedness.  In general, all of the numeric types are</span>
<span class="s0">interchangeable--just call the appropriate one according to the data</span>
<span class="s0">type you already have; don't worry about matching to the data type</span>
<span class="s0">defined in the DC file.  However, if you are trying to write a general</span>
<span class="s0">algorithm and you need a hint, you can call get_pack_type() to return</span>
<span class="s0">a suggested type for the next pack call; this will return one of</span>
<span class="s0">PT_int, PT_uint, PT_double, PT_string, etc.</span>

<span class="s0">The same is true when unpacking: unpack_int() or unpack_uint() may be</span>
<span class="s0">used interchangeably on signed or unsigned data (but if you call</span>
<span class="s0">unpack_uint() and the data in the record happens to be negative, you</span>
<span class="s0">will trigger a pack error).  As above, get_pack_type() may be called</span>
<span class="s0">to return the suggested type for the next unpack call.</span>


<span class="s0">If end_pack() or end_repack() returns false, there are two possible</span>
<span class="s0">causes.  (1) You tried to pack some value that exceeded the range</span>
<span class="s0">specified in the DC file (or the limits of the datatype).  In this</span>
<span class="s0">case, had_range_error() will return true.  (2) There was some other,</span>
<span class="s0">more serious error while packing the data, such as a mismatched type</span>
<span class="s0">(e.g. pack_string() where a uint16 was expected), or you did not pack</span>
<span class="s0">the right number of elements.  In this case, had_pack_error() will</span>
<span class="s0">return true.  It might be the case that both error flags are</span>
<span class="s0">triggered.</span>

<span class="s0">If end_unpack() returns false, there are two similar causes.  (1)</span>
<span class="s0">There was an invalid value in the record that exceeded the limits</span>
<span class="s0">specified in the DC file.  This will be indicated by</span>
<span class="s0">had_range_error().  (2) Some mismatched data type (unpack_string() for</span>
<span class="s0">a uint16) or the wrong number of elements.  This is indicated by</span>
<span class="s0">had_pack_error().  Note that specifying a too-small return value</span>
<span class="s0">(e.g. unpack_uint() to retrieve a signed value, or unpack_int() to</span>
<span class="s0">retrieve a float64 or int64 value greater than 2^32) is considered a</span>
<span class="s0">pack error, not a range error.</span>


<span class="s0">You may call pack_literal_value() for any element for which you want</span>
<span class="s0">to supply a pre-packed data value (for instance, a default value</span>
<span class="s0">returned by DCAtomicField::get_element_default()).  This will be</span>
<span class="s0">accepted without further validation.  Similarly,</span>
<span class="s0">unpack_literal_value() will return a string corresponding to the</span>
<span class="s0">pre-packed value of the current element.  Both of these work for</span>
<span class="s0">composite elements as well as for single-component elements (that is,</span>
<span class="s0">you may call unpack_literal_value() instead of calling push()</span>
<span class="s0">.. unpack .. pop() to retrieve an entire pre-packed array in one</span>
<span class="s0">string).</span>

<span class="s0">Python programmers may be especially interested in pack_object() and</span>
<span class="s0">unpack_object().  pack_object() will accept any Python object and call</span>
<span class="s0">the appropriate pack function for it.  Python tuple or list will</span>
<span class="s0">implicitly call push(), followed by pack_object() for all the elements</span>
<span class="s0">in the list, followed by pop(), so pack_object() can pack deeply</span>
<span class="s0">nested structures with a single call, and with no need to call push()</span>
<span class="s0">and pop() explicitly.  Conversely, unpack_object() will unpack a</span>
<span class="s0">deeply nested structure and return an appropriate Python tuple or list</span>
<span class="s0">or other object.  You may also consider DCField::pack_args() and</span>
<span class="s0">DCField::unpack_args(), which automatically invokes the DCPacker for</span>
<span class="s0">you.</span>

<span class="s0">You may also find parse_and_pack() and unpack_and_format() useful for</span>
<span class="s0">presenting data to (and accepting data from) a human user.</span>
<span class="s0">parse_and_pack() accepts a string formatted in the DC file syntax</span>
<span class="s0">(that is, with the same syntax accepted for a DC file default value),</span>
<span class="s0">and packs that value for the current element.  It may be a single</span>
<span class="s0">value or a deeply nested value, with brackets and braces embedded as</span>
<span class="s0">appropriate.  Similarly, unpack_and_format() will unpack a single</span>
<span class="s0">value or a deeply nested value into the same formatted string.  As</span>
<span class="s0">with pack_object() and unpack_object(), these methods are also</span>
<span class="s0">implemented on the DCField class for convenience, as parse_string()</span>
<span class="s0">and format_data().</span>


<span class="s0">RANGE VALIDATION</span>

<span class="s0">The DCPacker automatically verifies that all data passing through its</span>
<span class="s0">fundamental pack or unpack methods fits within the ranges (if any)</span>
<span class="s0">specified in the DC file for each data type.  Violating a range</span>
<span class="s0">restriction triggers a range error, which is indicated by a false</span>
<span class="s0">return value from end_pack() / end_unpack() / end_repack() and by a</span>
<span class="s0">true return value from had_range_error().</span>

<span class="s0">If you just want to verify that a message contains legal values</span>
<span class="s0">without otherwise inspecting the values, you can use unpack_validate()</span>
<span class="s0">for this purpose.  Since unpack_validate() will work on deeply nested</span>
<span class="s0">structures, you can just call it once in lieu of the entire push()</span>
<span class="s0">.. pack .. pop() loop.  Furthermore, as in unpack_object() and</span>
<span class="s0">unpack_and_format(), above, there is a convenience function for this</span>
<span class="s0">on DCField; just call DCField::validate_ranges() to ensure that the</span>
<span class="s0">data in the record for the given field fits within its specified</span>
<span class="s0">limits.</span>
</pre>
</body>
</html>