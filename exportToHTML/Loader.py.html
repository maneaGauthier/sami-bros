<html>
<head>
<title>Loader.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Loader.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;This module contains a high-level interface for loading models, textures, 
sound, music, shaders and fonts from disk. 
&quot;&quot;&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'Loader'</span><span class="s2">]</span>

<span class="s4">from </span><span class="s1">panda3d</span><span class="s2">.</span><span class="s1">core </span><span class="s4">import </span><span class="s2">*</span>
<span class="s4">from </span><span class="s1">panda3d</span><span class="s2">.</span><span class="s1">core </span><span class="s4">import </span><span class="s1">Loader </span><span class="s4">as </span><span class="s1">PandaLoader</span>
<span class="s4">from </span><span class="s1">direct</span><span class="s2">.</span><span class="s1">directnotify</span><span class="s2">.</span><span class="s1">DirectNotifyGlobal </span><span class="s4">import </span><span class="s2">*</span>
<span class="s4">from </span><span class="s1">direct</span><span class="s2">.</span><span class="s1">showbase</span><span class="s2">.</span><span class="s1">DirectObject </span><span class="s4">import </span><span class="s1">DirectObject</span>

<span class="s5"># You can specify a phaseChecker callback to check</span>
<span class="s5"># a modelPath to see if it is being loaded in the correct</span>
<span class="s5"># phase</span>
<span class="s1">phaseChecker </span><span class="s2">= </span><span class="s4">None</span>


<span class="s4">class </span><span class="s1">Loader</span><span class="s2">(</span><span class="s1">DirectObject</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Load models, textures, sounds, and code. 
    &quot;&quot;&quot;</span>
    <span class="s1">notify </span><span class="s2">= </span><span class="s1">directNotify</span><span class="s2">.</span><span class="s1">newCategory</span><span class="s2">(</span><span class="s3">&quot;Loader&quot;</span><span class="s2">)</span>
    <span class="s1">loaderIndex </span><span class="s2">= </span><span class="s6">0</span>

    <span class="s1">_loadedPythonFileTypes </span><span class="s2">= </span><span class="s4">False</span>

    <span class="s4">class </span><span class="s1">_Callback</span><span class="s2">:</span>
        <span class="s0">&quot;&quot;&quot;Returned by loadModel when used asynchronously.  This class is 
        modelled after Future, and can be awaited.&quot;&quot;&quot;</span>

        <span class="s5"># This indicates that this class behaves like a Future.</span>
        <span class="s1">_asyncio_future_blocking </span><span class="s2">= </span><span class="s4">False</span>

        <span class="s4">class </span><span class="s1">_ResultAwaiter</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
            <span class="s0">&quot;&quot;&quot;Reinvents generators because of PEP 479, sigh.  See #513.&quot;&quot;&quot;</span>

            <span class="s1">__slots__ </span><span class="s2">= </span><span class="s3">'requestList'</span><span class="s2">, </span><span class="s3">'index'</span>

            <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">requestList</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">requestList </span><span class="s2">= </span><span class="s1">requestList</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s6">0</span>

            <span class="s4">def </span><span class="s1">__await__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
                <span class="s4">return </span><span class="s1">self</span>

            <span class="s4">def </span><span class="s1">__anext__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">&gt;= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">requestList</span><span class="s2">):</span>
                    <span class="s4">raise </span><span class="s1">StopAsyncIteration</span>
                <span class="s4">return </span><span class="s1">self</span>

            <span class="s4">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
                <span class="s4">return </span><span class="s1">self</span>

            <span class="s4">def </span><span class="s1">__next__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
                <span class="s1">i </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span>
                <span class="s1">request </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">requestList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                <span class="s4">if not </span><span class="s1">request</span><span class="s2">.</span><span class="s1">done</span><span class="s2">():</span>
                    <span class="s4">return </span><span class="s1">request</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span>

                <span class="s1">result </span><span class="s2">= </span><span class="s1">request</span><span class="s2">.</span><span class="s1">result</span><span class="s2">()</span>
                <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">PandaNode</span><span class="s2">):</span>
                    <span class="s1">result </span><span class="s2">= </span><span class="s1">NodePath</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

                <span class="s1">exc </span><span class="s2">= </span><span class="s1">StopIteration</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
                <span class="s1">exc</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">result</span>
                <span class="s4">raise </span><span class="s1">exc</span>

        <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loader</span><span class="s2">, </span><span class="s1">numObjects</span><span class="s2">, </span><span class="s1">gotList</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">extraArgs</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_loader </span><span class="s2">= </span><span class="s1">loader</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">objects </span><span class="s2">= [</span><span class="s4">None</span><span class="s2">] * </span><span class="s1">numObjects</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">gotList </span><span class="s2">= </span><span class="s1">gotList</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">callback </span><span class="s2">= </span><span class="s1">callback</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">extraArgs </span><span class="s2">= </span><span class="s1">extraArgs</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">requests </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">requestList </span><span class="s2">= []</span>

        <span class="s4">def </span><span class="s1">gotObject</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">object</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">objects</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] = </span><span class="s1">object</span>

            <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_loader </span><span class="s2">= </span><span class="s4">None</span>
                <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gotList</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">objects</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">extraArgs</span><span class="s2">)</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">(*(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">objects </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">extraArgs</span><span class="s2">))</span>

        <span class="s4">def </span><span class="s1">cancel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">&quot;Cancels the request.  Callback won't be called.&quot;</span>
            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_loader</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s1">request </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_loader</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                    <span class="s4">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_loader</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">[</span><span class="s1">request</span><span class="s2">]</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_loader </span><span class="s2">= </span><span class="s4">None</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">requests </span><span class="s2">= </span><span class="s4">None</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">requestList </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">def </span><span class="s1">cancelled</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">&quot;Returns true if the request was cancelled.&quot;</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">requestList </span><span class="s4">is None</span>

        <span class="s4">def </span><span class="s1">done</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">&quot;Returns true if all the requests were finished or cancelled.&quot;</span>
            <span class="s4">return not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">requests</span>

        <span class="s4">def </span><span class="s1">result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">&quot;Returns the results, suspending the thread to wait if necessary.&quot;</span>
            <span class="s4">for </span><span class="s1">r </span><span class="s4">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">):</span>
                <span class="s1">r</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gotList</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">objects</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">objects</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

        <span class="s4">def </span><span class="s1">exception</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">done</span><span class="s2">() </span><span class="s4">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cancelled</span><span class="s2">()</span>
            <span class="s4">return None</span>

        <span class="s4">def </span><span class="s1">__await__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">&quot;&quot;&quot; Returns a generator that raises StopIteration when the loading 
            is complete.  This allows this class to be used with 'await'.&quot;&quot;&quot;</span>

            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_asyncio_future_blocking </span><span class="s2">= </span><span class="s4">True</span>

            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gotList</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ResultAwaiter</span><span class="s2">([</span><span class="s1">self</span><span class="s2">])</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ResultAwaiter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">requestList</span><span class="s2">)</span>

        <span class="s4">def </span><span class="s1">__aiter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">&quot;&quot;&quot; This allows using `async for` to iterate asynchronously over 
            the results of this class.  It does guarantee to return the 
            results in order, though, even though they may not be loaded in 
            that order. &quot;&quot;&quot;</span>
            <span class="s1">requestList </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">requestList</span>
            <span class="s4">assert </span><span class="s1">requestList </span><span class="s4">is not None</span><span class="s2">, </span><span class="s3">&quot;Request was cancelled.&quot;</span>

            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ResultAwaiter</span><span class="s2">(</span><span class="s1">requestList</span><span class="s2">)</span>

    <span class="s5"># special methods</span>
    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">base</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">base </span><span class="s2">= </span><span class="s1">base</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">loader </span><span class="s2">= </span><span class="s1">PandaLoader</span><span class="s2">.</span><span class="s1">getGlobalPtr</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_requests </span><span class="s2">= {}</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">hook </span><span class="s2">= </span><span class="s3">&quot;async_loader_%s&quot; </span><span class="s2">% (</span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">loaderIndex</span><span class="s2">)</span>
        <span class="s1">Loader</span><span class="s2">.</span><span class="s1">loaderIndex </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">accept</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">hook</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__gotAsyncObject</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_loadPythonFileTypes</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">destroy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ignore</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">hook</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">stopThreads</span><span class="s2">()</span>
        <span class="s4">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">base</span>
        <span class="s4">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s4">def </span><span class="s1">_loadPythonFileTypes</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_loadedPythonFileTypes</span><span class="s2">:</span>
            <span class="s4">return</span>

        <span class="s4">if not </span><span class="s1">ConfigVariableBool</span><span class="s2">(</span><span class="s3">'loader-support-entry-points'</span><span class="s2">, </span><span class="s4">True</span><span class="s2">):</span>
            <span class="s4">return</span>

        <span class="s4">import </span><span class="s1">importlib</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">pkg_resources </span><span class="s2">= </span><span class="s1">importlib</span><span class="s2">.</span><span class="s1">import_module</span><span class="s2">(</span><span class="s3">'pkg_resources'</span><span class="s2">)</span>
        <span class="s4">except </span><span class="s1">ImportError</span><span class="s2">:</span>
            <span class="s1">pkg_resources </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">if </span><span class="s1">pkg_resources</span><span class="s2">:</span>
            <span class="s1">registry </span><span class="s2">= </span><span class="s1">LoaderFileTypeRegistry</span><span class="s2">.</span><span class="s1">getGlobalPtr</span><span class="s2">()</span>

            <span class="s4">for </span><span class="s1">entry_point </span><span class="s4">in </span><span class="s1">pkg_resources</span><span class="s2">.</span><span class="s1">iter_entry_points</span><span class="s2">(</span><span class="s3">'panda3d.loaders'</span><span class="s2">):</span>
                <span class="s1">registry</span><span class="s2">.</span><span class="s1">register_deferred_type</span><span class="s2">(</span><span class="s1">entry_point</span><span class="s2">)</span>

            <span class="s1">cls</span><span class="s2">.</span><span class="s1">_loadedPythonFileTypes </span><span class="s2">= </span><span class="s4">True</span>

    <span class="s5"># model loading funcs</span>
    <span class="s4">def </span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">loaderOptions </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">noCache </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                  <span class="s1">allowInstance </span><span class="s2">= </span><span class="s4">False</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                  <span class="s1">callback </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">extraArgs </span><span class="s2">= [], </span><span class="s1">priority </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                  <span class="s1">blocking </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Attempts to load a model or models from one or more relative 
        pathnames.  If the input modelPath is a string (a single model 
        pathname), the return value will be a NodePath to the model 
        loaded if the load was successful, or None otherwise.  If the 
        input modelPath is a list of pathnames, the return value will 
        be a list of `.NodePath` objects and/or Nones. 
 
        loaderOptions may optionally be passed in to control details 
        about the way the model is searched and loaded.  See the 
        `.LoaderOptions` class for more. 
 
        The default is to look in the `.ModelPool` (RAM) cache first, 
        and return a copy from that if the model can be found there. 
        If the bam cache is enabled (via the `model-cache-dir` config 
        variable), then that will be consulted next, and if both 
        caches fail, the file will be loaded from disk.  If noCache is 
        True, then neither cache will be consulted or updated. 
 
        If allowInstance is True, a shared instance may be returned 
        from the `.ModelPool`.  This is dangerous, since it is easy to 
        accidentally modify the shared instance, and invalidate future 
        load attempts of the same model.  Normally, you should leave 
        allowInstance set to False, which will always return a unique 
        copy. 
 
        If okMissing is True, None is returned if the model is not 
        found or cannot be read, and no error message is printed. 
        Otherwise, an `IOError` is raised if the model is not found or 
        cannot be read (similar to attempting to open a nonexistent 
        file).  (If modelPath is a list of filenames, then `IOError` 
        is raised if *any* of the models could not be loaded.) 
 
        If callback is not None, then the model load will be performed 
        asynchronously.  In this case, loadModel() will initiate a 
        background load and return immediately.  The return value will 
        be an object that can be used to check the status, cancel the 
        request, or use it in an `await` expression.  Unless callback 
        is the special value True, when the requested model(s) have 
        finished loading, it will be invoked with the n 
        loaded models passed as its parameter list.  It is possible 
        that the callback will be invoked immediately, even before 
        loadModel() returns.  If you use callback, you may also 
        specify a priority, which specifies the relative importance 
        over this model over all of the other asynchronous load 
        requests (higher numbers are loaded first). 
 
        True asynchronous model loading requires Panda to have been 
        compiled with threading support enabled (you can test 
        `.Thread.isThreadingSupported()`).  In the absence of threading 
        support, the asynchronous interface still exists and still 
        behaves exactly as described, except that loadModel() might 
        not return immediately. 
 
        &quot;&quot;&quot;</span>

        <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Loading model: %s&quot; </span><span class="s2">% (</span><span class="s1">modelPath</span><span class="s2">,))</span>
        <span class="s4">if </span><span class="s1">loaderOptions </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">okMissing </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">okMissing</span><span class="s2">:</span>
                <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() &amp; ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFReportErrors</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() | </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFReportErrors</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">okMissing </span><span class="s2">= ((</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() &amp; </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFReportErrors</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">noCache </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">noCache</span><span class="s2">:</span>
                <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() | </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFNoCache</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() &amp; ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFNoCache</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">allowInstance</span><span class="s2">:</span>
            <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() | </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFAllowInstance</span><span class="s2">)</span>

        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, (</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">list</span><span class="s2">, </span><span class="s1">set</span><span class="s2">)):</span>
            <span class="s5"># We were given a single model pathname.</span>
            <span class="s1">modelList </span><span class="s2">= [</span><span class="s1">modelPath</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">phaseChecker</span><span class="s2">:</span>
                <span class="s1">phaseChecker</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">loaderOptions</span><span class="s2">)</span>

            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Assume we were given a list of model pathnames.</span>
            <span class="s1">modelList </span><span class="s2">= </span><span class="s1">modelPath</span>
            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s4">if </span><span class="s1">blocking </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">blocking </span><span class="s2">= </span><span class="s1">callback </span><span class="s4">is None</span>

        <span class="s4">if </span><span class="s1">blocking</span><span class="s2">:</span>
            <span class="s5"># We got no callback, so it's a synchronous load.</span>

            <span class="s1">result </span><span class="s2">= []</span>
            <span class="s4">for </span><span class="s1">modelPath </span><span class="s4">in </span><span class="s1">modelList</span><span class="s2">:</span>
                <span class="s1">node </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">loadSync</span><span class="s2">(</span><span class="s1">Filename</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">), </span><span class="s1">loaderOptions</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">node </span><span class="s4">is not None</span><span class="s2">:</span>
                    <span class="s1">nodePath </span><span class="s2">= </span><span class="s1">NodePath</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">nodePath </span><span class="s2">= </span><span class="s4">None</span>

                <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">nodePath</span><span class="s2">)</span>

            <span class="s4">if not </span><span class="s1">okMissing </span><span class="s4">and None in </span><span class="s1">result</span><span class="s2">:</span>
                <span class="s1">message </span><span class="s2">= </span><span class="s3">'Could not load model file(s): %s' </span><span class="s2">% (</span><span class="s1">modelList</span><span class="s2">,)</span>
                <span class="s4">raise </span><span class="s1">IOError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">gotList</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">result</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">result</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># We got a callback, so we want an asynchronous (threaded)</span>
            <span class="s5"># load.  We'll return immediately, but when all of the</span>
            <span class="s5"># requested models have been loaded, we'll invoke the</span>
            <span class="s5"># callback (passing it the models on the parameter list).</span>

            <span class="s1">cb </span><span class="s2">= </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">_Callback</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">modelList</span><span class="s2">), </span><span class="s1">gotList</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">extraArgs</span><span class="s2">)</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s4">for </span><span class="s1">modelPath </span><span class="s4">in </span><span class="s1">modelList</span><span class="s2">:</span>
                <span class="s1">request </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">makeAsyncRequest</span><span class="s2">(</span><span class="s1">Filename</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">), </span><span class="s1">loaderOptions</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">priority </span><span class="s4">is not None</span><span class="s2">:</span>
                    <span class="s1">request</span><span class="s2">.</span><span class="s1">setPriority</span><span class="s2">(</span><span class="s1">priority</span><span class="s2">)</span>
                <span class="s1">request</span><span class="s2">.</span><span class="s1">setDoneEvent</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">hook</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">loadAsync</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">cb</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">cb</span><span class="s2">.</span><span class="s1">requestList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">[</span><span class="s1">request</span><span class="s2">] = (</span><span class="s1">cb</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
                <span class="s1">i </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s4">return </span><span class="s1">cb</span>

    <span class="s4">def </span><span class="s1">cancelRequest</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Cancels an aysynchronous loading or flatten request issued 
        earlier.  The callback associated with the request will not be 
        called after cancelRequest() has been performed. 
 
        This is now deprecated: call cb.cancel() instead. &quot;&quot;&quot;</span>

        <span class="s1">cb</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">isRequestPending</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Returns true if an asynchronous loading or flatten request 
        issued earlier is still pending, or false if it has completed or 
        been cancelled. 
 
        This is now deprecated: call cb.done() instead. &quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">loadModelOnce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">modelPath</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        modelPath is a string. 
 
        Attempt to load a model from modelPool, if not present 
        then attempt to load it from disk. Return a nodepath to 
        the model if successful or None otherwise 
        &quot;&quot;&quot;</span>
        <span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">info</span><span class="s2">(</span><span class="s3">&quot;loader.loadModelOnce() is deprecated; use loader.loadModel() instead.&quot;</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">noCache </span><span class="s2">= </span><span class="s4">False</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">loadModelCopy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">loaderOptions </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;loadModelCopy(self, string) 
        NOTE: This method is deprecated and should not be used. 
        Attempt to load a model from modelPool, if not present 
        then attempt to load it from disk. Return a nodepath to 
        a copy of the model if successful or None otherwise 
        &quot;&quot;&quot;</span>
        <span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">info</span><span class="s2">(</span><span class="s3">&quot;loader.loadModelCopy() is deprecated; use loader.loadModel() instead.&quot;</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">loaderOptions</span><span class="s2">, </span><span class="s1">noCache </span><span class="s2">= </span><span class="s4">False</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">loadModelNode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">modelPath</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        modelPath is a string. 
 
        This is like loadModelOnce in that it loads a model from the 
        modelPool, but it does not then instance it to hidden and it 
        returns a Node instead of a NodePath.  This is particularly 
        useful for special models like fonts that you don't care about 
        where they're parented to, and you don't want a NodePath 
        anyway--it prevents accumulation of instances of the font 
        model under hidden. 
 
        However, if you're loading a font, see loadFont(), below. 
        &quot;&quot;&quot;</span>
        <span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">info</span><span class="s2">(</span><span class="s3">&quot;loader.loadModelNode() is deprecated; use loader.loadModel() instead.&quot;</span><span class="s2">)</span>

        <span class="s1">model </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loadModel</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">noCache </span><span class="s2">= </span><span class="s4">False</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">model </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">model </span><span class="s2">= </span><span class="s1">model</span><span class="s2">.</span><span class="s1">node</span><span class="s2">()</span>

        <span class="s4">return </span><span class="s1">model</span>

    <span class="s4">def </span><span class="s1">unloadModel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">model</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        model is the return value of loadModel().  For backward 
        compatibility, it may also be the filename that was passed to 
        loadModel(), though this requires a disk search. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">model</span><span class="s2">, </span><span class="s1">NodePath</span><span class="s2">):</span>
            <span class="s5"># Maybe we were given a NodePath</span>
            <span class="s1">modelNode </span><span class="s2">= </span><span class="s1">model</span><span class="s2">.</span><span class="s1">node</span><span class="s2">()</span>

        <span class="s4">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">model</span><span class="s2">, </span><span class="s1">ModelNode</span><span class="s2">):</span>
            <span class="s5"># Maybe we were given a node</span>
            <span class="s1">modelNode </span><span class="s2">= </span><span class="s1">model</span>

        <span class="s4">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">model</span><span class="s2">, (</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Filename</span><span class="s2">)):</span>
            <span class="s5"># If we were given a filename, we have to ask the loader</span>
            <span class="s5"># to resolve it for us.</span>
            <span class="s1">options </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFSearch </span><span class="s2">| </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFNoDiskCache </span><span class="s2">| </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFCacheOnly</span><span class="s2">)</span>
            <span class="s1">modelNode </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">loadSync</span><span class="s2">(</span><span class="s1">Filename</span><span class="s2">(</span><span class="s1">model</span><span class="s2">), </span><span class="s1">options</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">modelNode </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s5"># Model not found.</span>
                <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Unloading model not loaded: %s&quot; </span><span class="s2">% (</span><span class="s1">model</span><span class="s2">))</span>
                <span class="s4">return</span>

            <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;%s resolves to %s&quot; </span><span class="s2">% (</span><span class="s1">model</span><span class="s2">, </span><span class="s1">modelNode</span><span class="s2">.</span><span class="s1">getFullpath</span><span class="s2">()))</span>

        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">'Invalid parameter to unloadModel: %s' </span><span class="s2">% (</span><span class="s1">model</span><span class="s2">))</span>

        <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Unloading model: %s&quot; </span><span class="s2">% (</span><span class="s1">modelNode</span><span class="s2">.</span><span class="s1">getFullpath</span><span class="s2">()))</span>
        <span class="s1">ModelPool</span><span class="s2">.</span><span class="s1">releaseModel</span><span class="s2">(</span><span class="s1">modelNode</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">saveModel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">loaderOptions </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                  <span class="s1">callback </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">extraArgs </span><span class="s2">= [], </span><span class="s1">priority </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                  <span class="s1">blocking </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Saves the model (a `NodePath` or `PandaNode`) to the indicated 
        filename path.  Returns true on success, false on failure.  If 
        a callback is used, the model is saved asynchronously, and the 
        true/false status is passed to the callback function. &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">loaderOptions </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">)</span>

        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, (</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">list</span><span class="s2">, </span><span class="s1">set</span><span class="s2">)):</span>
            <span class="s5"># We were given a single model pathname.</span>
            <span class="s1">modelList </span><span class="s2">= [</span><span class="s1">modelPath</span><span class="s2">]</span>
            <span class="s1">nodeList </span><span class="s2">= [</span><span class="s1">node</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">phaseChecker</span><span class="s2">:</span>
                <span class="s1">phaseChecker</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">loaderOptions</span><span class="s2">)</span>

            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Assume we were given a list of model pathnames.</span>
            <span class="s1">modelList </span><span class="s2">= </span><span class="s1">modelPath</span>
            <span class="s1">nodeList </span><span class="s2">= </span><span class="s1">node</span>
            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s4">assert</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">modelList</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">))</span>

        <span class="s5"># Make sure we have PandaNodes, not NodePaths.</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">)):</span>
            <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">NodePath</span><span class="s2">):</span>
                <span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">node</span><span class="s2">()</span>

        <span class="s5"># From here on, we deal with a list of (filename, node) pairs.</span>
        <span class="s1">modelList </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">modelList</span><span class="s2">, </span><span class="s1">nodeList</span><span class="s2">))</span>

        <span class="s4">if </span><span class="s1">blocking </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">blocking </span><span class="s2">= </span><span class="s1">callback </span><span class="s4">is None</span>

        <span class="s4">if </span><span class="s1">blocking</span><span class="s2">:</span>
            <span class="s5"># We got no callback, so it's a synchronous save.</span>

            <span class="s1">result </span><span class="s2">= []</span>
            <span class="s4">for </span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">node </span><span class="s4">in </span><span class="s1">modelList</span><span class="s2">:</span>
                <span class="s1">thisResult </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">saveSync</span><span class="s2">(</span><span class="s1">Filename</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">), </span><span class="s1">loaderOptions</span><span class="s2">, </span><span class="s1">node</span><span class="s2">)</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">thisResult</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">gotList</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">result</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">result</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># We got a callback, so we want an asynchronous (threaded)</span>
            <span class="s5"># save.  We'll return immediately, but when all of the</span>
            <span class="s5"># requested models have been saved, we'll invoke the</span>
            <span class="s5"># callback (passing it the models on the parameter list).</span>

            <span class="s1">cb </span><span class="s2">= </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">_Callback</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">modelList</span><span class="s2">), </span><span class="s1">gotList</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">extraArgs</span><span class="s2">)</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s4">for </span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">node </span><span class="s4">in </span><span class="s1">modelList</span><span class="s2">:</span>
                <span class="s1">request </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">makeAsyncSaveRequest</span><span class="s2">(</span><span class="s1">Filename</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">), </span><span class="s1">loaderOptions</span><span class="s2">, </span><span class="s1">node</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">priority </span><span class="s4">is not None</span><span class="s2">:</span>
                    <span class="s1">request</span><span class="s2">.</span><span class="s1">setPriority</span><span class="s2">(</span><span class="s1">priority</span><span class="s2">)</span>
                <span class="s1">request</span><span class="s2">.</span><span class="s1">setDoneEvent</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">hook</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">saveAsync</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">cb</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">cb</span><span class="s2">.</span><span class="s1">requestList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">[</span><span class="s1">request</span><span class="s2">] = (</span><span class="s1">cb</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
                <span class="s1">i </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s4">return </span><span class="s1">cb</span>


    <span class="s5"># font loading funcs</span>
    <span class="s4">def </span><span class="s1">loadFont</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">modelPath</span><span class="s2">,</span>
                 <span class="s1">spaceAdvance </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">lineHeight </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">pointSize </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">pixelsPerUnit </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">scaleFactor </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">textureMargin </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">polyMargin </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">minFilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">magFilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">anisotropicDegree </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">color </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">outlineWidth </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">outlineFeather </span><span class="s2">= </span><span class="s6">0.1</span><span class="s2">,</span>
                 <span class="s1">outlineColor </span><span class="s2">= </span><span class="s1">VBase4</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">),</span>
                 <span class="s1">renderMode </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">okMissing </span><span class="s2">= </span><span class="s4">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        modelPath is a string. 
 
        This loads a special model as a `TextFont` object, for rendering 
        text with a `TextNode`.  A font file must be either a special 
        egg file (or bam file) generated with egg-mkfont, which is 
        considered a static font, or a standard font file (like a TTF 
        file) that is supported by FreeType, which is considered a 
        dynamic font. 
 
        okMissing should be True to indicate the method should return 
        None if the font file is not found.  If it is False, the 
        method will raise an exception if the font file is not found 
        or cannot be loaded. 
 
        Most font-customization parameters accepted by this method 
        (except lineHeight and spaceAdvance) may only be specified for 
        dynamic font files like TTF files, not for static egg files. 
 
        lineHeight specifies the vertical distance between consecutive 
        lines, in Panda units.  If unspecified, it is taken from the 
        font information.  This parameter may be specified for static 
        as well as dynamic fonts. 
 
        spaceAdvance specifies the width of a space character (ascii 
        32), in Panda units.  If unspecified, it is taken from the 
        font information.  This may be specified for static as well as 
        dynamic fonts. 
 
        The remaining parameters may only be specified for dynamic 
        fonts. 
 
        pixelsPerUnit controls the visual quality of the rendered text 
        characters.  It specifies the number of texture pixels per 
        each Panda unit of character height.  Increasing this number 
        increases the amount of detail that can be represented in the 
        characters, at the expense of texture memory. 
 
        scaleFactor also controls the visual quality of the rendered 
        text characters.  It is the amount by which the characters are 
        rendered bigger out of Freetype, and then downscaled to fit 
        within the texture.  Increasing this number may reduce some 
        artifacts of very small font characters, at a small cost of 
        processing time to generate the characters initially. 
 
        textureMargin specifies the number of pixels of the texture to 
        leave between adjacent characters.  It may be a floating-point 
        number.  This helps reduce bleed-through from nearby 
        characters within the texture space.  Increasing this number 
        reduces artifacts at the edges of the character cells 
        (especially for very small text scales), at the expense of 
        texture memory. 
 
        polyMargin specifies the amount of additional buffer to create 
        in the polygon that represents each character, in Panda units. 
        It is similar to textureMargin, but it controls the polygon 
        buffer, not the texture buffer.  Increasing this number 
        reduces artifacts from letters getting chopped off at the 
        edges (especially for very small text scales), with some 
        increasing risk of adjacent letters overlapping and obscuring 
        each other. 
 
        minFilter, magFilter, and anisotropicDegree specify the 
        texture filter modes that should be applied to the textures 
        that are created to hold the font characters. 
 
        If color is not None, it should be a VBase4 specifying the 
        foreground color of the font.  Specifying this option breaks 
        `TextNode.setColor()`, so you almost never want to use this 
        option; the default (white) is the most appropriate for a 
        font, as it allows text to have any arbitrary color assigned 
        at generation time.  However, if you want to use a colored 
        outline (below) with a different color for the interior, for 
        instance a yellow letter with a blue outline, then you need 
        this option, and then *all* text generated with this font will 
        have to be yellow and blue. 
 
        If outlineWidth is nonzero, an outline will be created at 
        runtime for the letters, and outlineWidth will be the desired 
        width of the outline, in points (most fonts are 10 points 
        high, so 0.5 is often a good choice).  If you specify 
        outlineWidth, you can also specify outlineFeather (0.0 .. 1.0) 
        and outlineColor.  You may need to increase pixelsPerUnit to 
        get the best results. 
 
        if renderMode is not None, it may be one of the following 
        symbols to specify a geometry-based font: 
 
            TextFont.RMTexture - this is the default.  Font characters 
              are rendered into a texture and applied to a polygon. 
              This gives the best general-purpose results. 
 
            TextFont.RMWireframe - Font characters are rendered as a 
              sequence of one-pixel lines.  Consider enabling line or 
              multisample antialiasing for best results. 
 
            TextFont.RMPolygon - Font characters are rendered as a 
              flat polygon.  This works best for very large 
              characters, and generally requires polygon or 
              multisample antialiasing to be enabled for best results. 
 
            TextFont.RMExtruded - Font characters are rendered with a 
              3-D outline made of polygons, like a cookie cutter. 
              This is appropriate for a 3-D scene, but may be 
              completely invisible when assigned to a 2-D scene and 
              viewed normally from the front, since polygons are 
              infinitely thin. 
 
            TextFont.RMSolid - A combination of RMPolygon and 
              RMExtruded: a flat polygon in front with a solid 
              three-dimensional edge.  This is best for letters that 
              will be tumbling in 3-D space. 
 
        If the texture mode is other than RMTexture, most of the above 
        parameters do not apply, though pixelsPerUnit still does apply 
        and roughly controls the tightness of the curve approximation 
        (and the number of vertices generated). 
 
        &quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Loading font: %s&quot; </span><span class="s2">% (</span><span class="s1">modelPath</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">phaseChecker</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">()</span>
            <span class="s4">if</span><span class="s2">(</span><span class="s1">okMissing</span><span class="s2">):</span>
                <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setFlags</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getFlags</span><span class="s2">() &amp; ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">LFReportErrors</span><span class="s2">)</span>
            <span class="s1">phaseChecker</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">, </span><span class="s1">loaderOptions</span><span class="s2">)</span>

        <span class="s1">font </span><span class="s2">= </span><span class="s1">FontPool</span><span class="s2">.</span><span class="s1">loadFont</span><span class="s2">(</span><span class="s1">modelPath</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">font </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">if not </span><span class="s1">okMissing</span><span class="s2">:</span>
                <span class="s1">message </span><span class="s2">= </span><span class="s3">'Could not load font file: %s' </span><span class="s2">% (</span><span class="s1">modelPath</span><span class="s2">)</span>
                <span class="s4">raise </span><span class="s1">IOError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
            <span class="s5"># If we couldn't load the model, at least return an</span>
            <span class="s5"># empty font.</span>
            <span class="s1">font </span><span class="s2">= </span><span class="s1">StaticTextFont</span><span class="s2">(</span><span class="s1">PandaNode</span><span class="s2">(</span><span class="s3">&quot;empty&quot;</span><span class="s2">))</span>

        <span class="s5"># The following properties may only be set for dynamic fonts.</span>
        <span class="s4">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">font</span><span class="s2">, </span><span class="s3">&quot;setPointSize&quot;</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">pointSize </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setPointSize</span><span class="s2">(</span><span class="s1">pointSize</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">pixelsPerUnit </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setPixelsPerUnit</span><span class="s2">(</span><span class="s1">pixelsPerUnit</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">scaleFactor </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setScaleFactor</span><span class="s2">(</span><span class="s1">scaleFactor</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">textureMargin </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setTextureMargin</span><span class="s2">(</span><span class="s1">textureMargin</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">polyMargin </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setPolyMargin</span><span class="s2">(</span><span class="s1">polyMargin</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">minFilter </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setMinfilter</span><span class="s2">(</span><span class="s1">minFilter</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">magFilter </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setMagfilter</span><span class="s2">(</span><span class="s1">magFilter</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">anisotropicDegree </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setAnisotropicDegree</span><span class="s2">(</span><span class="s1">anisotropicDegree</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">color</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setFg</span><span class="s2">(</span><span class="s1">color</span><span class="s2">)</span>
                <span class="s5"># This means we want the background to match the</span>
                <span class="s5"># foreground color, but transparent.</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setBg</span><span class="s2">(</span><span class="s1">VBase4</span><span class="s2">(</span><span class="s1">color</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">color</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">color</span><span class="s2">[</span><span class="s6">2</span><span class="s2">], </span><span class="s6">0.0</span><span class="s2">))</span>
            <span class="s4">if </span><span class="s1">outlineWidth</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setOutline</span><span class="s2">(</span><span class="s1">outlineColor</span><span class="s2">, </span><span class="s1">outlineWidth</span><span class="s2">, </span><span class="s1">outlineFeather</span><span class="s2">)</span>

                <span class="s5"># This means we want the background to match the</span>
                <span class="s5"># outline color, but transparent.</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setBg</span><span class="s2">(</span><span class="s1">VBase4</span><span class="s2">(</span><span class="s1">outlineColor</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">outlineColor</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">outlineColor</span><span class="s2">[</span><span class="s6">2</span><span class="s2">], </span><span class="s6">0.0</span><span class="s2">))</span>
            <span class="s4">if </span><span class="s1">renderMode</span><span class="s2">:</span>
                <span class="s1">font</span><span class="s2">.</span><span class="s1">setRenderMode</span><span class="s2">(</span><span class="s1">renderMode</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">lineHeight </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s5"># If the line height is specified, it overrides whatever</span>
            <span class="s5"># the font itself thinks the line height should be.  This</span>
            <span class="s5"># and spaceAdvance should be set last, since some of the</span>
            <span class="s5"># other parameters can cause these to be reset to their</span>
            <span class="s5"># default.</span>
            <span class="s1">font</span><span class="s2">.</span><span class="s1">setLineHeight</span><span class="s2">(</span><span class="s1">lineHeight</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">spaceAdvance </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">font</span><span class="s2">.</span><span class="s1">setSpaceAdvance</span><span class="s2">(</span><span class="s1">spaceAdvance</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">font</span>

    <span class="s5"># texture loading funcs</span>
    <span class="s4">def </span><span class="s1">loadTexture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">texturePath</span><span class="s2">, </span><span class="s1">alphaPath </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                    <span class="s1">readMipmaps </span><span class="s2">= </span><span class="s4">False</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s4">False</span><span class="s2">,</span>
                    <span class="s1">minfilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">magfilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                    <span class="s1">anisotropicDegree </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">loaderOptions </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                    <span class="s1">multiview </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        texturePath is a string. 
 
        Attempt to load a texture from the given file path using 
        `TexturePool` class.  Returns a `Texture` object, or raises 
        `IOError` if the file could not be loaded. 
 
        okMissing should be True to indicate the method should return 
        None if the texture file is not found.  If it is False, the 
        method will raise an exception if the texture file is not 
        found or cannot be loaded. 
 
        If alphaPath is not None, it is the name of a grayscale image 
        that is applied as the texture's alpha channel. 
 
        If readMipmaps is True, then the filename string must contain 
        a sequence of hash characters ('#') that are filled in with 
        the mipmap index number, and n images will be loaded 
        individually which define the n mipmap levels of the texture. 
        The base level is mipmap level 0, and this defines the size of 
        the texture and the number of expected mipmap images. 
 
        If minfilter or magfilter is not None, they should be a symbol 
        like `SamplerState.FTLinear` or `SamplerState.FTNearest`. 
        (minfilter may be further one of the Mipmap filter type symbols.) 
        These specify the filter mode that will automatically be applied 
        to the texture when it is loaded.  Note that this setting may 
        override the texture's existing settings, even if it has 
        already been loaded.  See `egg-texture-cards` for a more robust 
        way to apply per-texture filter types and settings. 
 
        If anisotropicDegree is not None, it specifies the anisotropic degree 
        to apply to the texture when it is loaded.  Like minfilter and 
        magfilter, `egg-texture-cards` may be a more robust way to apply 
        this setting. 
 
        If multiview is true, it indicates to load a multiview or 
        stereo texture.  In this case, the filename should contain a 
        hash character ('#') that will be replaced with '0' for the 
        left image and '1' for the right image.  Larger numbers are 
        also allowed if you need more than two views. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">loaderOptions </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">multiview </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">flags </span><span class="s2">= </span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getTextureFlags</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">multiview</span><span class="s2">:</span>
                <span class="s1">flags </span><span class="s2">|= </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">TFMultiview</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">flags </span><span class="s2">&amp;= ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">TFMultiview</span>
            <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setTextureFlags</span><span class="s2">(</span><span class="s1">flags</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">alphaPath </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Loading texture: %s&quot; </span><span class="s2">% (</span><span class="s1">texturePath</span><span class="s2">))</span>
            <span class="s1">texture </span><span class="s2">= </span><span class="s1">TexturePool</span><span class="s2">.</span><span class="s1">loadTexture</span><span class="s2">(</span><span class="s1">texturePath</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">readMipmaps</span><span class="s2">, </span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Loading texture: %s %s&quot; </span><span class="s2">% (</span><span class="s1">texturePath</span><span class="s2">, </span><span class="s1">alphaPath</span><span class="s2">))</span>
            <span class="s1">texture </span><span class="s2">= </span><span class="s1">TexturePool</span><span class="s2">.</span><span class="s1">loadTexture</span><span class="s2">(</span><span class="s1">texturePath</span><span class="s2">, </span><span class="s1">alphaPath</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">readMipmaps</span><span class="s2">, </span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">texture </span><span class="s4">and not </span><span class="s1">okMissing</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">'Could not load texture: %s' </span><span class="s2">% (</span><span class="s1">texturePath</span><span class="s2">)</span>
            <span class="s4">raise </span><span class="s1">IOError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">minfilter </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setMinfilter</span><span class="s2">(</span><span class="s1">minfilter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">magfilter </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setMagfilter</span><span class="s2">(</span><span class="s1">magfilter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">anisotropicDegree </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setAnisotropicDegree</span><span class="s2">(</span><span class="s1">anisotropicDegree</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">texture</span>

    <span class="s4">def </span><span class="s1">load3DTexture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">texturePattern</span><span class="s2">, </span><span class="s1">readMipmaps </span><span class="s2">= </span><span class="s4">False</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s4">False</span><span class="s2">,</span>
                      <span class="s1">minfilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">magfilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">anisotropicDegree </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                      <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">multiview </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">numViews </span><span class="s2">= </span><span class="s6">2</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        texturePattern is a string that contains a sequence of one or 
        more hash characters ('#'), which will be filled in with the 
        z-height number.  Returns a 3-D `Texture` object, suitable for 
        rendering volumetric textures. 
 
        okMissing should be True to indicate the method should return 
        None if the texture file is not found.  If it is False, the 
        method will raise an exception if the texture file is not 
        found or cannot be loaded. 
 
        If readMipmaps is True, then the filename string must contain 
        two sequences of hash characters; the first group is filled in 
        with the z-height number, and the second group with the mipmap 
        index number. 
 
        If multiview is true, it indicates to load a multiview or 
        stereo texture.  In this case, numViews should also be 
        specified (the default is 2), and the sequence of texture 
        images will be divided into numViews views.  The total 
        z-height will be (numImages / numViews).  For instance, if you 
        read 16 images with numViews = 2, then you have created a 
        stereo multiview image, with z = 8.  In this example, images 
        numbered 0 - 7 will be part of the left eye view, and images 
        numbered 8 - 15 will be part of the right eye view. 
        &quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Loading 3-D texture: %s&quot; </span><span class="s2">% (</span><span class="s1">texturePattern</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">loaderOptions </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">multiview </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">flags </span><span class="s2">= </span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getTextureFlags</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">multiview</span><span class="s2">:</span>
                <span class="s1">flags </span><span class="s2">|= </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">TFMultiview</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">flags </span><span class="s2">&amp;= ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">TFMultiview</span>
            <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setTextureFlags</span><span class="s2">(</span><span class="s1">flags</span><span class="s2">)</span>
            <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setTextureNumViews</span><span class="s2">(</span><span class="s1">numViews</span><span class="s2">)</span>

        <span class="s1">texture </span><span class="s2">= </span><span class="s1">TexturePool</span><span class="s2">.</span><span class="s1">load3dTexture</span><span class="s2">(</span><span class="s1">texturePattern</span><span class="s2">, </span><span class="s1">readMipmaps</span><span class="s2">, </span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">texture </span><span class="s4">and not </span><span class="s1">okMissing</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">'Could not load 3-D texture: %s' </span><span class="s2">% (</span><span class="s1">texturePattern</span><span class="s2">)</span>
            <span class="s4">raise </span><span class="s1">IOError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">minfilter </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setMinfilter</span><span class="s2">(</span><span class="s1">minfilter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">magfilter </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setMagfilter</span><span class="s2">(</span><span class="s1">magfilter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">anisotropicDegree </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setAnisotropicDegree</span><span class="s2">(</span><span class="s1">anisotropicDegree</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">texture</span>

    <span class="s4">def </span><span class="s1">load2DTextureArray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">texturePattern</span><span class="s2">, </span><span class="s1">readMipmaps </span><span class="s2">= </span><span class="s4">False</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s4">False</span><span class="s2">,</span>
                      <span class="s1">minfilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">magfilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">anisotropicDegree </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                      <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">multiview </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">numViews </span><span class="s2">= </span><span class="s6">2</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        texturePattern is a string that contains a sequence of one or 
        more hash characters ('#'), which will be filled in with the 
        z-height number.  Returns a 2-D `Texture` array object, suitable 
        for rendering array of textures. 
 
        okMissing should be True to indicate the method should return 
        None if the texture file is not found.  If it is False, the 
        method will raise an exception if the texture file is not 
        found or cannot be loaded. 
 
        If readMipmaps is True, then the filename string must contain 
        two sequences of hash characters; the first group is filled in 
        with the z-height number, and the second group with the mipmap 
        index number. 
 
        If multiview is true, it indicates to load a multiview or 
        stereo texture.  In this case, numViews should also be 
        specified (the default is 2), and the sequence of texture 
        images will be divided into numViews views.  The total 
        z-height will be (numImages / numViews).  For instance, if you 
        read 16 images with numViews = 2, then you have created a 
        stereo multiview image, with z = 8.  In this example, images 
        numbered 0 - 7 will be part of the left eye view, and images 
        numbered 8 - 15 will be part of the right eye view. 
        &quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Loading 2-D texture array: %s&quot; </span><span class="s2">% (</span><span class="s1">texturePattern</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">loaderOptions </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">multiview </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">flags </span><span class="s2">= </span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getTextureFlags</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">multiview</span><span class="s2">:</span>
                <span class="s1">flags </span><span class="s2">|= </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">TFMultiview</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">flags </span><span class="s2">&amp;= ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">TFMultiview</span>
            <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setTextureFlags</span><span class="s2">(</span><span class="s1">flags</span><span class="s2">)</span>
            <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setTextureNumViews</span><span class="s2">(</span><span class="s1">numViews</span><span class="s2">)</span>

        <span class="s1">texture </span><span class="s2">= </span><span class="s1">TexturePool</span><span class="s2">.</span><span class="s1">load2dTextureArray</span><span class="s2">(</span><span class="s1">texturePattern</span><span class="s2">, </span><span class="s1">readMipmaps</span><span class="s2">, </span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">texture </span><span class="s4">and not </span><span class="s1">okMissing</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">'Could not load 2-D texture array: %s' </span><span class="s2">% (</span><span class="s1">texturePattern</span><span class="s2">)</span>
            <span class="s4">raise </span><span class="s1">IOError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">minfilter </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setMinfilter</span><span class="s2">(</span><span class="s1">minfilter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">magfilter </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setMagfilter</span><span class="s2">(</span><span class="s1">magfilter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">anisotropicDegree </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setAnisotropicDegree</span><span class="s2">(</span><span class="s1">anisotropicDegree</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">texture</span>

    <span class="s4">def </span><span class="s1">loadCubeMap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">texturePattern</span><span class="s2">, </span><span class="s1">readMipmaps </span><span class="s2">= </span><span class="s4">False</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s4">False</span><span class="s2">,</span>
                    <span class="s1">minfilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">magfilter </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">anisotropicDegree </span><span class="s2">= </span><span class="s4">None</span><span class="s2">,</span>
                    <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">multiview </span><span class="s2">= </span><span class="s4">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        texturePattern is a string that contains a sequence of one or 
        more hash characters ('#'), which will be filled in with the 
        face index number (0 through 6).  Returns a six-face cube map 
        `Texture` object. 
 
        okMissing should be True to indicate the method should return 
        None if the texture file is not found.  If it is False, the 
        method will raise an exception if the texture file is not 
        found or cannot be loaded. 
 
        If readMipmaps is True, then the filename string must contain 
        two sequences of hash characters; the first group is filled in 
        with the face index number, and the second group with the 
        mipmap index number. 
 
        If multiview is true, it indicates to load a multiview or 
        stereo cube map.  For a stereo cube map, 12 images will be 
        loaded--images numbered 0 - 5 will become the left eye view, 
        and images 6 - 11 will become the right eye view.  In general, 
        the number of images found on disk must be a multiple of six, 
        and each six images will define a new view. 
        &quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Loading cube map: %s&quot; </span><span class="s2">% (</span><span class="s1">texturePattern</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">loaderOptions </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">loaderOptions </span><span class="s2">= </span><span class="s1">LoaderOptions</span><span class="s2">(</span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">multiview </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">flags </span><span class="s2">= </span><span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">getTextureFlags</span><span class="s2">()</span>
            <span class="s4">if </span><span class="s1">multiview</span><span class="s2">:</span>
                <span class="s1">flags </span><span class="s2">|= </span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">TFMultiview</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">flags </span><span class="s2">&amp;= ~</span><span class="s1">LoaderOptions</span><span class="s2">.</span><span class="s1">TFMultiview</span>
            <span class="s1">loaderOptions</span><span class="s2">.</span><span class="s1">setTextureFlags</span><span class="s2">(</span><span class="s1">flags</span><span class="s2">)</span>

        <span class="s1">texture </span><span class="s2">= </span><span class="s1">TexturePool</span><span class="s2">.</span><span class="s1">loadCubeMap</span><span class="s2">(</span><span class="s1">texturePattern</span><span class="s2">, </span><span class="s1">readMipmaps</span><span class="s2">, </span><span class="s1">loaderOptions</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">texture </span><span class="s4">and not </span><span class="s1">okMissing</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">'Could not load cube map: %s' </span><span class="s2">% (</span><span class="s1">texturePattern</span><span class="s2">)</span>
            <span class="s4">raise </span><span class="s1">IOError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">minfilter </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setMinfilter</span><span class="s2">(</span><span class="s1">minfilter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">magfilter </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setMagfilter</span><span class="s2">(</span><span class="s1">magfilter</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">anisotropicDegree </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">texture</span><span class="s2">.</span><span class="s1">setAnisotropicDegree</span><span class="s2">(</span><span class="s1">anisotropicDegree</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">texture</span>

    <span class="s4">def </span><span class="s1">unloadTexture</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">texture</span><span class="s2">):</span>

        <span class="s0">&quot;&quot;&quot; 
        Removes the previously-loaded texture from the cache, so 
        that when the last reference to it is gone, it will be 
        released.  This also means that the next time the same texture 
        is loaded, it will be re-read from disk (and duplicated in 
        texture memory if there are still outstanding references to 
        it). 
 
        The texture parameter may be the return value of any previous 
        call to loadTexture(), load3DTexture(), or loadCubeMap(). 
        &quot;&quot;&quot;</span>
        <span class="s4">assert </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;Unloading texture: %s&quot; </span><span class="s2">% (</span><span class="s1">texture</span><span class="s2">))</span>
        <span class="s1">TexturePool</span><span class="s2">.</span><span class="s1">releaseTexture</span><span class="s2">(</span><span class="s1">texture</span><span class="s2">)</span>

    <span class="s5"># sound loading funcs</span>
    <span class="s4">def </span><span class="s1">loadSfx</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Loads one or more sound files, specifically designated as a 
        &quot;sound effect&quot; file (that is, uses the sfxManager to load the 
        sound).  There is no distinction between sound effect files 
        and music files other than the particular `AudioManager` used 
        to load the sound file, but this distinction allows the sound 
        effects and/or the music files to be adjusted as a group, 
        independently of the other group.&quot;&quot;&quot;</span>

        <span class="s5"># showbase-created sfxManager should always be at front of list</span>
        <span class="s4">if</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">base</span><span class="s2">.</span><span class="s1">sfxManagerList</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loadSound</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">base</span><span class="s2">.</span><span class="s1">sfxManagerList</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>
        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">loadMusic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Loads one or more sound files, specifically designated as a 
        &quot;music&quot; file (that is, uses the musicManager to load the 
        sound).  There is no distinction between sound effect files 
        and music files other than the particular `AudioManager` used 
        to load the sound file, but this distinction allows the sound 
        effects and/or the music files to be adjusted as a group, 
        independently of the other group.&quot;&quot;&quot;</span>
        <span class="s4">if</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">base</span><span class="s2">.</span><span class="s1">musicManager</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">loadSound</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">base</span><span class="s2">.</span><span class="s1">musicManager</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">loadSound</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">manager</span><span class="s2">, </span><span class="s1">soundPath</span><span class="s2">, </span><span class="s1">positional </span><span class="s2">= </span><span class="s4">False</span><span class="s2">,</span>
                  <span class="s1">callback </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">extraArgs </span><span class="s2">= []):</span>

        <span class="s0">&quot;&quot;&quot;Loads one or more sound files, specifying the particular 
        AudioManager that should be used to load them.  The soundPath 
        may be either a single filename, or a list of filenames.  If a 
        callback is specified, the loading happens in the background, 
        just as in loadModel(); otherwise, the loading happens before 
        loadSound() returns.&quot;&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">soundPath</span><span class="s2">, (</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">list</span><span class="s2">, </span><span class="s1">set</span><span class="s2">)):</span>
            <span class="s5"># We were given a single sound pathname or a MovieAudio instance.</span>
            <span class="s1">soundList </span><span class="s2">= [</span><span class="s1">soundPath</span><span class="s2">]</span>
            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Assume we were given a list of sound pathnames.</span>
            <span class="s1">soundList </span><span class="s2">= </span><span class="s1">soundPath</span>
            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s4">if </span><span class="s1">callback </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s5"># We got no callback, so it's a synchronous load.</span>

            <span class="s1">result </span><span class="s2">= []</span>
            <span class="s4">for </span><span class="s1">soundPath </span><span class="s4">in </span><span class="s1">soundList</span><span class="s2">:</span>
                <span class="s5"># should return a valid sound obj even if musicMgr is invalid</span>
                <span class="s1">sound </span><span class="s2">= </span><span class="s1">manager</span><span class="s2">.</span><span class="s1">getSound</span><span class="s2">(</span><span class="s1">soundPath</span><span class="s2">, </span><span class="s1">positional</span><span class="s2">)</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sound</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">gotList</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">result</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">result</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># We got a callback, so we want an asynchronous (threaded)</span>
            <span class="s5"># load.  We'll return immediately, but when all of the</span>
            <span class="s5"># requested sounds have been loaded, we'll invoke the</span>
            <span class="s5"># callback (passing it the sounds on the parameter list).</span>

            <span class="s1">cb </span><span class="s2">= </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">_Callback</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">soundList</span><span class="s2">), </span><span class="s1">gotList</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">extraArgs</span><span class="s2">)</span>
            <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">soundPath </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">soundList</span><span class="s2">):</span>
                <span class="s1">request </span><span class="s2">= </span><span class="s1">AudioLoadRequest</span><span class="s2">(</span><span class="s1">manager</span><span class="s2">, </span><span class="s1">soundPath</span><span class="s2">, </span><span class="s1">positional</span><span class="s2">)</span>
                <span class="s1">request</span><span class="s2">.</span><span class="s1">setDoneEvent</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">hook</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">loadAsync</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">cb</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">cb</span><span class="s2">.</span><span class="s1">requestList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">[</span><span class="s1">request</span><span class="s2">] = (</span><span class="s1">cb</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">cb</span>

    <span class="s4">def </span><span class="s1">unloadSfx</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sfx</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">sfx</span><span class="s2">):</span>
            <span class="s4">if</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">base</span><span class="s2">.</span><span class="s1">sfxManagerList</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">base</span><span class="s2">.</span><span class="s1">sfxManagerList</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">uncacheSound </span><span class="s2">(</span><span class="s1">sfx</span><span class="s2">.</span><span class="s1">getName</span><span class="s2">())</span>

<span class="s5">##     def makeNodeNamesUnique(self, nodePath, nodeCount):</span>
<span class="s5">##         if nodeCount == 0:</span>
<span class="s5">##             Loader.modelCount += 1</span>
<span class="s5">##         nodePath.setName(nodePath.getName() +</span>
<span class="s5">##                          ('_%d_%d' % (Loader.modelCount, nodeCount)))</span>
<span class="s5">##         for i in range(nodePath.getNumChildren()):</span>
<span class="s5">##             nodeCount += 1</span>
<span class="s5">##             self.makeNodeNamesUnique(nodePath.getChild(i), nodeCount)</span>

    <span class="s4">def </span><span class="s1">loadShader</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">shaderPath</span><span class="s2">, </span><span class="s1">okMissing </span><span class="s2">= </span><span class="s4">False</span><span class="s2">):</span>
        <span class="s1">shader </span><span class="s2">= </span><span class="s1">ShaderPool</span><span class="s2">.</span><span class="s1">loadShader </span><span class="s2">(</span><span class="s1">shaderPath</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">shader </span><span class="s4">and not </span><span class="s1">okMissing</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">'Could not load shader file: %s' </span><span class="s2">% (</span><span class="s1">shaderPath</span><span class="s2">)</span>
            <span class="s4">raise </span><span class="s1">IOError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">shader</span>

    <span class="s4">def </span><span class="s1">unloadShader</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">shaderPath</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">shaderPath </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">ShaderPool</span><span class="s2">.</span><span class="s1">releaseShader</span><span class="s2">(</span><span class="s1">shaderPath</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">asyncFlattenStrong</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">inPlace </span><span class="s2">= </span><span class="s4">True</span><span class="s2">,</span>
                           <span class="s1">callback </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s1">extraArgs </span><span class="s2">= []):</span>
        <span class="s0">&quot;&quot;&quot; Performs a model.flattenStrong() operation in a sub-thread 
        (if threading is compiled into Panda).  The model may be a 
        single `.NodePath`, or it may be a list of NodePaths. 
 
        Each model is duplicated and flattened in the sub-thread. 
 
        If inPlace is True, then when the flatten operation completes, 
        the newly flattened copies are automatically dropped into the 
        scene graph, in place the original models. 
 
        If a callback is specified, then it is called after the 
        operation is finished, receiving the flattened model (or a 
        list of flattened models).&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">model</span><span class="s2">, </span><span class="s1">NodePath</span><span class="s2">):</span>
            <span class="s5"># We were given a single model.</span>
            <span class="s1">modelList </span><span class="s2">= [</span><span class="s1">model</span><span class="s2">]</span>
            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Assume we were given a list of models.</span>
            <span class="s1">modelList </span><span class="s2">= </span><span class="s1">model</span>
            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s4">if </span><span class="s1">inPlace</span><span class="s2">:</span>
            <span class="s1">extraArgs </span><span class="s2">= [</span><span class="s1">gotList</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">modelList</span><span class="s2">, </span><span class="s1">extraArgs</span><span class="s2">]</span>
            <span class="s1">callback </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__asyncFlattenDone</span>
            <span class="s1">gotList </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s1">cb </span><span class="s2">= </span><span class="s1">Loader</span><span class="s2">.</span><span class="s1">_Callback</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">modelList</span><span class="s2">), </span><span class="s1">gotList</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">extraArgs</span><span class="s2">)</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s4">for </span><span class="s1">model </span><span class="s4">in </span><span class="s1">modelList</span><span class="s2">:</span>
            <span class="s1">request </span><span class="s2">= </span><span class="s1">ModelFlattenRequest</span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">node</span><span class="s2">())</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">setDoneEvent</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">hook</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">loader</span><span class="s2">.</span><span class="s1">loadAsync</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
            <span class="s1">cb</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
            <span class="s1">cb</span><span class="s2">.</span><span class="s1">requestList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">[</span><span class="s1">request</span><span class="s2">] = (</span><span class="s1">cb</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
            <span class="s1">i </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4">return </span><span class="s1">cb</span>

    <span class="s4">def </span><span class="s1">__asyncFlattenDone</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">models</span><span class="s2">,</span>
                           <span class="s1">gotList</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">origModelList</span><span class="s2">, </span><span class="s1">extraArgs</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; The asynchronous flatten operation has completed; quietly 
        drop in the new models. &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">notify</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">&quot;asyncFlattenDone: %s&quot; </span><span class="s2">% (</span><span class="s1">models</span><span class="s2">,))</span>
        <span class="s4">assert</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">models</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">origModelList</span><span class="s2">))</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">models</span><span class="s2">)):</span>
            <span class="s1">origModelList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">getChildren</span><span class="s2">().</span><span class="s1">detach</span><span class="s2">()</span>
            <span class="s1">orig </span><span class="s2">= </span><span class="s1">origModelList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">node</span><span class="s2">()</span>
            <span class="s1">flat </span><span class="s2">= </span><span class="s1">models</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">node</span><span class="s2">()</span>
            <span class="s1">orig</span><span class="s2">.</span><span class="s1">copyAllProperties</span><span class="s2">(</span><span class="s1">flat</span><span class="s2">)</span>
            <span class="s1">flat</span><span class="s2">.</span><span class="s1">replaceNode</span><span class="s2">(</span><span class="s1">orig</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">callback</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">gotList</span><span class="s2">:</span>
                <span class="s1">callback</span><span class="s2">(</span><span class="s1">origModelList</span><span class="s2">, *</span><span class="s1">extraArgs</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">callback</span><span class="s2">(*(</span><span class="s1">origModelList </span><span class="s2">+ </span><span class="s1">extraArgs</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__gotAsyncObject</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;A model or sound file or some such thing has just been 
        loaded asynchronously by the sub-thread.  Add it to the list 
        of loaded objects, and call the appropriate callback when it's 
        time.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">request </span><span class="s4">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">:</span>
            <span class="s4">return</span>

        <span class="s1">cb</span><span class="s2">, </span><span class="s1">i </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">[</span><span class="s1">request</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">cb</span><span class="s2">.</span><span class="s1">cancelled</span><span class="s2">() </span><span class="s4">or </span><span class="s1">request</span><span class="s2">.</span><span class="s1">cancelled</span><span class="s2">():</span>
            <span class="s5"># Shouldn't be here.</span>
            <span class="s4">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">[</span><span class="s1">request</span><span class="s2">]</span>
            <span class="s4">return</span>

        <span class="s1">cb</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">.</span><span class="s1">discard</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">cb</span><span class="s2">.</span><span class="s1">requests</span><span class="s2">:</span>
            <span class="s4">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_requests</span><span class="s2">[</span><span class="s1">request</span><span class="s2">]</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">request</span><span class="s2">.</span><span class="s1">result</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">PandaNode</span><span class="s2">):</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">NodePath</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

        <span class="s1">cb</span><span class="s2">.</span><span class="s1">gotObject</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">result</span><span class="s2">)</span>

    <span class="s1">load_model </span><span class="s2">= </span><span class="s1">loadModel</span>
    <span class="s1">unload_model </span><span class="s2">= </span><span class="s1">unloadModel</span>
    <span class="s1">save_model </span><span class="s2">= </span><span class="s1">saveModel</span>
    <span class="s1">load_font </span><span class="s2">= </span><span class="s1">loadFont</span>
    <span class="s1">load_texture </span><span class="s2">= </span><span class="s1">loadTexture</span>
    <span class="s1">load_3d_texture </span><span class="s2">= </span><span class="s1">load3DTexture</span>
    <span class="s1">load_cube_map </span><span class="s2">= </span><span class="s1">loadCubeMap</span>
    <span class="s1">unload_texture </span><span class="s2">= </span><span class="s1">unloadTexture</span>
    <span class="s1">load_sfx </span><span class="s2">= </span><span class="s1">loadSfx</span>
    <span class="s1">load_music </span><span class="s2">= </span><span class="s1">loadMusic</span>
    <span class="s1">load_sound </span><span class="s2">= </span><span class="s1">loadSound</span>
    <span class="s1">unload_sfx </span><span class="s2">= </span><span class="s1">unloadSfx</span>
    <span class="s1">load_shader </span><span class="s2">= </span><span class="s1">loadShader</span>
    <span class="s1">unload_shader </span><span class="s2">= </span><span class="s1">unloadShader</span>
    <span class="s1">async_flatten_strong </span><span class="s2">= </span><span class="s1">asyncFlattenStrong</span>
</pre>
</body>
</html>