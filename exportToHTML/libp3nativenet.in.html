<html>
<head>
<title>libp3nativenet.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3nativenet.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">14 libp3nativenet 4 5qEC 12 panda3d.core </span>
<span class="s0">93</span>
<span class="s0">97 14 Socket_Address 0 260 190 30 Socket_Address::Socket_Address 0 2 1 2 112</span>
<span class="s0">/**</span>
 <span class="s0">* Constructor that lets us set a port value</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">145</span>
<span class="s0">inline explicit Socket_Address::Socket_Address(unsigned short int port = 0);</span>
<span class="s0">inline Socket_Address::Socket_Address(Socket_Address const &amp;inaddr);</span>

<span class="s0">98 15 ~Socket_Address 0 518 190 31 Socket_Address::~Socket_Address 0 0 28</span>
<span class="s0">/**</span>
 <span class="s0">* Normal Destructor</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">virtual inline Socket_Address::~Socket_Address(void);</span>

<span class="s0">99 10 set_any_IP 0 4 190 26 Socket_Address::set_any_IP 0 1 3 50</span>
<span class="s0">/**</span>
 <span class="s0">* Set to any address and a specified port</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool Socket_Address::set_any_IP(unsigned short int port);</span>

<span class="s0">100 12 set_any_IPv6 0 4 190 28 Socket_Address::set_any_IPv6 0 1 4 56</span>
<span class="s0">/**</span>
 <span class="s0">* Set to any IPv6 address and a specified port.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline bool Socket_Address::set_any_IPv6(unsigned short int port);</span>

<span class="s0">101 8 set_port 0 4 190 24 Socket_Address::set_port 0 1 5 34</span>
<span class="s0">/**</span>
 <span class="s0">* Set to a specified port</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline bool Socket_Address::set_port(unsigned short int port);</span>

<span class="s0">102 13 set_broadcast 0 4 190 29 Socket_Address::set_broadcast 0 1 6 60</span>
<span class="s0">/**</span>
 <span class="s0">* Set to the broadcast address and a specified port</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline bool Socket_Address::set_broadcast(unsigned short int port);</span>

<span class="s0">103 8 set_host 0 4 190 24 Socket_Address::set_host 0 3 7 8 9 387</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This function will take a port and string-based TCP address and initialize</span>
 <span class="s0">* the address with this information.  Returns true on success; on failure, it</span>
 <span class="s0">* returns false and the address may be undefined.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Initializes the address from a string specifying both the address and port,</span>
 <span class="s0">* separated by a colon.  An IPv6 address must be enclosed in brackets.</span>
 <span class="s0">*/</span>
<span class="s0">225</span>
<span class="s0">bool Socket_Address::set_host(std::string const &amp;hostname, unsigned short int port);</span>
<span class="s0">bool Socket_Address::set_host(std::string const &amp;hostname);</span>
<span class="s0">inline bool Socket_Address::set_host(uint32_t ip4addr, unsigned short int port);</span>

<span class="s0">104 5 clear 0 4 190 21 Socket_Address::clear 0 1 10 60</span>
<span class="s0">/**</span>
 <span class="s0">* Set the internal values to a suitable known value</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline void Socket_Address::clear(void);</span>

<span class="s0">105 10 get_family 0 4 190 26 Socket_Address::get_family 0 1 11 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns AF_INET if this is an IPv4 address, or AF_INET6 if this is an IPv6</span>
 <span class="s0">* address.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline sa_family_t Socket_Address::get_family(void) const;</span>

<span class="s0">106 8 get_port 0 4 190 24 Socket_Address::get_port 0 1 12 45</span>
<span class="s0">/**</span>
 <span class="s0">* Get the port portion as an integer</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline unsigned short int Socket_Address::get_port(void) const;</span>

<span class="s0">107 6 get_ip 0 4 190 22 Socket_Address::get_ip 0 1 13 64</span>
<span class="s0">/**</span>
 <span class="s0">* Return the IP address portion in dot notation string.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">std::string Socket_Address::get_ip(void) const;</span>

<span class="s0">108 11 get_ip_port 0 4 190 27 Socket_Address::get_ip_port 0 1 14 133</span>
<span class="s0">/**</span>
 <span class="s0">* Return the ip address/port in dot notation string.  If this is an IPv6</span>
 <span class="s0">* address, it will be enclosed in square brackets.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">std::string Socket_Address::get_ip_port(void) const;</span>

<span class="s0">109 15 GetIPAddressRaw 0 4 190 31 Socket_Address::GetIPAddressRaw 0 1 15 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a raw 32-bit unsigned integer representing the IPv4 address.</span>
 <span class="s0">* @deprecated  Does not work with IPv6 addresses.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">unsigned long int Socket_Address::GetIPAddressRaw(void) const;</span>

<span class="s0">110 11 operator == 0 4 190 27 Socket_Address::operator == 0 1 16 0</span>
<span class="s0">72</span>
<span class="s0">inline bool Socket_Address::operator ==(Socket_Address const &amp;in) const;</span>

<span class="s0">111 11 operator != 0 4 190 27 Socket_Address::operator != 0 1 17 0</span>
<span class="s0">72</span>
<span class="s0">inline bool Socket_Address::operator !=(Socket_Address const &amp;in) const;</span>

<span class="s0">112 10 operator &lt; 0 4 190 26 Socket_Address::operator &lt; 0 1 18 0</span>
<span class="s0">71</span>
<span class="s0">inline bool Socket_Address::operator &lt;(Socket_Address const &amp;in) const;</span>

<span class="s0">113 6 is_any 0 4 190 22 Socket_Address::is_any 0 1 19 39</span>
<span class="s0">/**</span>
 <span class="s0">* True if the address is zero.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool Socket_Address::is_any(void) const;</span>

<span class="s0">114 14 is_mcast_range 0 4 190 30 Socket_Address::is_mcast_range 0 1 20 57</span>
<span class="s0">/**</span>
 <span class="s0">* True if the address is in the multicast range.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool Socket_Address::is_mcast_range(void) const;</span>

<span class="s0">115 9 Socket_IP 0 260 191 20 Socket_IP::Socket_IP 0 2 21 22 79</span>
<span class="s0">/**</span>
 <span class="s0">* Def Constructor</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Assigns an existing socket to this class</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline Socket_IP::Socket_IP(void);</span>
<span class="s0">inline Socket_IP::Socket_IP(SOCKET in);</span>

<span class="s0">116 5 Close 0 4 191 16 Socket_IP::Close 0 1 23 53</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a socket if it is open (allocated).</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">inline void Socket_IP::Close(void);</span>

<span class="s0">117 12 GetLastError 0 4 191 23 Socket_IP::GetLastError 0 1 24 57</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the last errcode from a socket operation.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">static inline int Socket_IP::GetLastError(void);</span>

<span class="s0">118 14 SetNonBlocking 0 4 191 25 Socket_IP::SetNonBlocking 0 1 25 67</span>
<span class="s0">/**</span>
 <span class="s0">* this function will throw a socket into non-blocking mode</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline int Socket_IP::SetNonBlocking(void);</span>

<span class="s0">119 11 SetBlocking 0 4 191 22 Socket_IP::SetBlocking 0 1 26 102</span>
<span class="s0">/**</span>
 <span class="s0">* Set the socket to block on subsequent calls to socket functions that</span>
 <span class="s0">* address this socket</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline int Socket_IP::SetBlocking(void);</span>

<span class="s0">120 15 SetReuseAddress 0 4 191 26 Socket_IP::SetReuseAddress 0 1 27 57</span>
<span class="s0">/**</span>
 <span class="s0">* Informs a socket to reuse IP address as needed</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool Socket_IP::SetReuseAddress(bool flag = true);</span>

<span class="s0">121 9 SetV6Only 0 4 191 20 Socket_IP::SetV6Only 0 1 28 103</span>
<span class="s0">/**</span>
 <span class="s0">* Sets a flag indicating whether this IPv6 socket should operate in</span>
 <span class="s0">* dual-stack mode or not.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline bool Socket_IP::SetV6Only(bool flag);</span>

<span class="s0">122 6 Active 0 4 191 17 Socket_IP::Active 0 1 29 48</span>
<span class="s0">/**</span>
 <span class="s0">* Ask if the socket is open (allocated)</span>
 <span class="s0">*/</span>
<span class="s0">36</span>
<span class="s0">inline bool Socket_IP::Active(void);</span>

<span class="s0">123 17 SetRecvBufferSize 0 4 191 28 Socket_IP::SetRecvBufferSize 0 1 30 63</span>
<span class="s0">/**</span>
 <span class="s0">* Ok it sets the recv buffer size for both tcp and UDP</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int Socket_IP::SetRecvBufferSize(int size);</span>

<span class="s0">124 9 SetSocket 0 4 191 20 Socket_IP::SetSocket 0 1 31 51</span>
<span class="s0">/**</span>
 <span class="s0">* Assigns an existing socket to this class</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void Socket_IP::SetSocket(SOCKET ins);</span>

<span class="s0">125 9 GetSocket 0 4 191 20 Socket_IP::GetSocket 0 2 32 33 82</span>
<span class="s0">/**</span>
 <span class="s0">* Gets the base socket type</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Get The RAW file id of the socket</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline SOCKET Socket_IP::GetSocket(void);</span>
<span class="s0">inline SOCKET Socket_IP::GetSocket(void) const;</span>

<span class="s0">126 11 GetPeerName 0 4 191 22 Socket_IP::GetPeerName 0 1 34 43</span>
<span class="s0">/**</span>
 <span class="s0">* Wrapper on berkly getpeername...</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline Socket_Address Socket_IP::GetPeerName(void) const;</span>

<span class="s0">127 17 InitNetworkDriver 0 4 191 28 Socket_IP::InitNetworkDriver 0 1 35 0</span>
<span class="s0">53</span>
<span class="s0">static inline int Socket_IP::InitNetworkDriver(void);</span>

<span class="s0">128 14 get_class_type 0 4 191 25 Socket_IP::get_class_type 0 1 36 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle Socket_IP::get_class_type(void);</span>

<span class="s0">129 10 Socket_TCP 0 260 193 22 Socket_TCP::Socket_TCP 0 2 37 38 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline Socket_TCP::Socket_TCP(SOCKET );</span>
<span class="s0">inline Socket_TCP::Socket_TCP(void);</span>

<span class="s0">130 10 SetNoDelay 0 4 193 22 Socket_TCP::SetNoDelay 0 1 39 73</span>
<span class="s0">/**</span>
 <span class="s0">* Disable Nagle algorithm.  Don't delay send to coalesce packets</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int Socket_TCP::SetNoDelay(bool flag = true);</span>

<span class="s0">131 9 SetLinger 0 4 193 21 Socket_TCP::SetLinger 0 1 40 66</span>
<span class="s0">/**</span>
 <span class="s0">* will control the behavior of SO_LINGER for a TCP socket</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int Socket_TCP::SetLinger(int interval_seconds = 0);</span>

<span class="s0">132 10 DontLinger 0 4 193 22 Socket_TCP::DontLinger 0 1 41 217</span>
<span class="s0">/**</span>
 <span class="s0">* Turn off the linger flag.  The socket will quickly release buffered items</span>
 <span class="s0">* and free up OS resources.  You may lose a stream if you use this flag and</span>
 <span class="s0">* do not negotiate the close at the application layer.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">inline int Socket_TCP::DontLinger(void);</span>

<span class="s0">133 17 SetSendBufferSize 0 4 193 29 Socket_TCP::SetSendBufferSize 0 1 42 143</span>
<span class="s0">/**</span>
 <span class="s0">* Just like it sounds.  Sets a buffered socket recv buffer size.  This</span>
 <span class="s0">* function does not refuse ranges outside hard-coded OS limits</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int Socket_TCP::SetSendBufferSize(int insize);</span>

<span class="s0">134 10 ActiveOpen 0 4 193 22 Socket_TCP::ActiveOpen 0 1 43 200</span>
<span class="s0">// inline bool ActiveOpen(const Socket_Address &amp;theaddress);</span>

<span class="s0">/**</span>
 <span class="s0">* This function will try and set the socket up for active open to a specified</span>
 <span class="s0">* address and port provided by the input parameter</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline bool Socket_TCP::ActiveOpen(Socket_Address const &amp;theaddress, bool setdelay);</span>

<span class="s0">135 21 ActiveOpenNonBlocking 0 4 193 33 Socket_TCP::ActiveOpenNonBlocking 0 1 44 161</span>
<span class="s0">/**</span>
 <span class="s0">* This function will try and set the socket up for active open to a specified</span>
 <span class="s0">* address and port provided by the input parameter (non-blocking version)</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline bool Socket_TCP::ActiveOpenNonBlocking(Socket_Address const &amp;theaddress);</span>

<span class="s0">136 21 ErrorIs_WouldBlocking 0 4 193 33 Socket_TCP::ErrorIs_WouldBlocking 0 1 45 0</span>
<span class="s0">55</span>
<span class="s0">inline bool Socket_TCP::ErrorIs_WouldBlocking(int err);</span>

<span class="s0">137 12 ShutdownSend 0 4 193 24 Socket_TCP::ShutdownSend 0 1 46 0</span>
<span class="s0">43</span>
<span class="s0">inline bool Socket_TCP::ShutdownSend(void);</span>

<span class="s0">138 8 SendData 0 4 193 20 Socket_TCP::SendData 0 1 47 137</span>
<span class="s0">/**</span>
 <span class="s0">* Ok Lets Send the Data - if error 0 if socket closed for write or lengh is 0</span>
 <span class="s0">* + bytes writen ( May be smaller than requested)</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int Socket_TCP::SendData(std::string const &amp;str);</span>

<span class="s0">139 8 RecvData 0 4 193 20 Socket_TCP::RecvData 0 1 48 295</span>
<span class="s0">/**</span>
 <span class="s0">* Read the data from the connection - if error 0 if socket closed for read or</span>
 <span class="s0">* length is 0 + bytes read ( May be smaller than requested)</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Read the data from the connection - if error 0 if socket closed for read or</span>
 <span class="s0">* length is 0 + bytes read (May be smaller than requested)</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">std::string Socket_TCP::RecvData(int max_len);</span>

<span class="s0">140 14 get_class_type 0 4 193 26 Socket_TCP::get_class_type 0 1 49 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle Socket_TCP::get_class_type(void);</span>

<span class="s0">141 11 ~Socket_TCP 0 516 193 23 Socket_TCP::~Socket_TCP 0 0 0</span>
<span class="s0">30</span>
<span class="s0">Socket_TCP::~Socket_TCP(void);</span>

<span class="s0">142 17 Socket_TCP_Listen 0 260 194 36 Socket_TCP_Listen::Socket_TCP_Listen 0 1 50 0</span>
<span class="s0">43</span>
<span class="s0">Socket_TCP_Listen::Socket_TCP_Listen(void);</span>

<span class="s0">143 13 OpenForListen 0 4 194 32 Socket_TCP_Listen::OpenForListen 0 2 51 52 120</span>
<span class="s0">/**</span>
 <span class="s0">* This function will initialize a listening Socket</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This function will initialize a listening Socket</span>
 <span class="s0">*/</span>
<span class="s0">197</span>
<span class="s0">inline bool Socket_TCP_Listen::OpenForListen(unsigned short int port, int backlog_size = 1024);</span>
<span class="s0">inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &amp;address, int backlog_size = 1024);</span>

<span class="s0">144 21 GetIncomingConnection 0 4 194 40 Socket_TCP_Listen::GetIncomingConnection 0 1 53 58</span>
<span class="s0">/**</span>
 <span class="s0">* This function is used to accept new connections</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline bool Socket_TCP_Listen::GetIncomingConnection(Socket_TCP &amp;newsession, Socket_Address &amp;address);</span>

<span class="s0">145 14 get_class_type 0 4 194 33 Socket_TCP_Listen::get_class_type 0 1 54 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle Socket_TCP_Listen::get_class_type(void);</span>

<span class="s0">146 19 Socket_UDP_Incoming 0 260 195 40 Socket_UDP_Incoming::Socket_UDP_Incoming 0 1 55 0</span>
<span class="s0">54</span>
<span class="s0">inline Socket_UDP_Incoming::Socket_UDP_Incoming(void);</span>

<span class="s0">147 12 OpenForInput 0 4 195 33 Socket_UDP_Incoming::OpenForInput 0 2 56 57 102</span>
<span class="s0">/**</span>
 <span class="s0">* Starts a UDP socket listening on a port</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Starts a UDP socket listening on a port</span>
 <span class="s0">*/</span>
<span class="s0">149</span>
<span class="s0">inline bool Socket_UDP_Incoming::OpenForInput(unsigned short int port);</span>
<span class="s0">inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &amp;address);</span>

<span class="s0">148 17 OpenForInputMCast 0 4 195 38 Socket_UDP_Incoming::OpenForInputMCast 0 1 58 50</span>
<span class="s0">/**</span>
 <span class="s0">* Starts a UDP socket listening on a port</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline bool Socket_UDP_Incoming::OpenForInputMCast(Socket_Address const &amp;address);</span>

<span class="s0">149 9 GetPacket 0 4 195 30 Socket_UDP_Incoming::GetPacket 0 0 105</span>
<span class="s0">/**</span>
 <span class="s0">* Grabs a dataset off the listening UDP socket and fills in the source</span>
 <span class="s0">* address information</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">inline bool Socket_UDP_Incoming::GetPacket(char *data, int *max_len, Socket_Address &amp;address);</span>

<span class="s0">150 6 SendTo 0 4 195 27 Socket_UDP_Incoming::SendTo 0 1 59 41</span>
<span class="s0">/**</span>
 <span class="s0">* Send data to specified address</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">inline bool Socket_UDP_Incoming::SendTo(char const *data, int len, Socket_Address const &amp;address);</span>

<span class="s0">151 13 InitNoAddress 0 4 195 34 Socket_UDP_Incoming::InitNoAddress 0 1 60 68</span>
<span class="s0">/**</span>
 <span class="s0">* Set this socket to work without a bound external address.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool Socket_UDP_Incoming::InitNoAddress(void);</span>

<span class="s0">152 14 SetToBroadCast 0 4 195 35 Socket_UDP_Incoming::SetToBroadCast 0 1 61 85</span>
<span class="s0">/**</span>
 <span class="s0">* Flips the OS bits that allow for brodcast packets to come in on this port.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool Socket_UDP_Incoming::SetToBroadCast(void);</span>

<span class="s0">153 14 get_class_type 0 4 195 35 Socket_UDP_Incoming::get_class_type 0 1 62 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle Socket_UDP_Incoming::get_class_type(void);</span>

<span class="s0">154 20 ~Socket_UDP_Incoming 0 516 195 41 Socket_UDP_Incoming::~Socket_UDP_Incoming 0 0 0</span>
<span class="s0">48</span>
<span class="s0">Socket_UDP_Incoming::~Socket_UDP_Incoming(void);</span>

<span class="s0">155 19 Socket_UDP_Outgoing 0 260 196 40 Socket_UDP_Outgoing::Socket_UDP_Outgoing 0 1 63 0</span>
<span class="s0">54</span>
<span class="s0">inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(void);</span>

<span class="s0">156 13 InitToAddress 0 4 196 34 Socket_UDP_Outgoing::InitToAddress 0 1 64 106</span>
<span class="s0">// use this interface for a tagreted UDP connection</span>

<span class="s0">/**</span>
 <span class="s0">* Connects the Socket to a specified address</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline bool Socket_UDP_Outgoing::InitToAddress(Socket_Address const &amp;address);</span>

<span class="s0">157 4 Send 0 4 196 25 Socket_UDP_Outgoing::Send 0 1 65 84</span>
<span class="s0">/**</span>
 <span class="s0">* Send data to connected address</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Send data to connected address</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline bool Socket_UDP_Outgoing::Send(std::string const &amp;data);</span>

<span class="s0">158 13 InitNoAddress 0 4 196 34 Socket_UDP_Outgoing::InitNoAddress 0 1 66 111</span>
<span class="s0">// use this interface for a none tagreted UDP connection</span>

<span class="s0">/**</span>
 <span class="s0">* This will set a udp up for targeted sends.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool Socket_UDP_Outgoing::InitNoAddress(void);</span>

<span class="s0">159 6 SendTo 0 4 196 27 Socket_UDP_Outgoing::SendTo 0 1 67 84</span>
<span class="s0">/**</span>
 <span class="s0">* Send data to specified address</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Send data to specified address</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">inline bool Socket_UDP_Outgoing::SendTo(std::string const &amp;data, Socket_Address const &amp;address);</span>

<span class="s0">160 14 SetToBroadCast 0 4 196 35 Socket_UDP_Outgoing::SetToBroadCast 0 1 68 71</span>
<span class="s0">/**</span>
 <span class="s0">* Ask the OS to let us receive broadcast packets on this port.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool Socket_UDP_Outgoing::SetToBroadCast(void);</span>

<span class="s0">161 14 get_class_type 0 4 196 35 Socket_UDP_Outgoing::get_class_type 0 1 69 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle Socket_UDP_Outgoing::get_class_type(void);</span>

<span class="s0">162 20 ~Socket_UDP_Outgoing 0 516 196 41 Socket_UDP_Outgoing::~Socket_UDP_Outgoing 0 0 0</span>
<span class="s0">48</span>
<span class="s0">Socket_UDP_Outgoing::~Socket_UDP_Outgoing(void);</span>

<span class="s0">163 12 Socket_fdset 0 260 197 26 Socket_fdset::Socket_fdset 0 2 70 71 26</span>
<span class="s0">/**</span>
 <span class="s0">* The constructor</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">inline Socket_fdset::Socket_fdset(void);</span>
<span class="s0">inline Socket_fdset::Socket_fdset(Socket_fdset const &amp;) = default;</span>

<span class="s0">164 12 setForSocket 0 4 197 26 Socket_fdset::setForSocket 0 1 72 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void Socket_fdset::setForSocket(Socket_IP const &amp;incon);</span>

<span class="s0">165 8 IsSetFor 0 4 197 22 Socket_fdset::IsSetFor 0 1 73 70</span>
<span class="s0">/**</span>
 <span class="s0">* check to see if a socket object has been marked for reading</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool Socket_fdset::IsSetFor(Socket_IP const &amp;incon) const;</span>

<span class="s0">166 11 WaitForRead 0 4 197 25 Socket_fdset::WaitForRead 0 2 74 75 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">163</span>
<span class="s0">inline int Socket_fdset::WaitForRead(bool zeroFds, uint32_t sleep_time = 2147483647);</span>
<span class="s0">inline int Socket_fdset::WaitForRead(bool zeroFds, Time_Span const &amp;timeout);</span>

<span class="s0">167 12 WaitForWrite 0 4 197 26 Socket_fdset::WaitForWrite 0 1 76 94</span>
<span class="s0">/**</span>
 <span class="s0">* This is the function that will wait till one of the sockets is ready for</span>
 <span class="s0">* writing</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline int Socket_fdset::WaitForWrite(bool zeroFds, uint32_t sleep_time = 2147483647);</span>

<span class="s0">168 12 WaitForError 0 4 197 26 Socket_fdset::WaitForError 0 1 77 91</span>
<span class="s0">/**</span>
 <span class="s0">* This is the function that will wait till one of the sockets is in error</span>
 <span class="s0">* state</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline int Socket_fdset::WaitForError(bool zeroFds, uint32_t sleep_time = 2147483647);</span>

<span class="s0">169 5 clear 0 4 197 19 Socket_fdset::clear 0 1 78 37</span>
<span class="s0">/**</span>
 <span class="s0">* Marks the content as empty</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline void Socket_fdset::clear(void);</span>

<span class="s0">170 13 ~Socket_fdset 0 516 197 27 Socket_fdset::~Socket_fdset 0 0 0</span>
<span class="s0">34</span>
<span class="s0">Socket_fdset::~Socket_fdset(void);</span>

<span class="s0">171 10 GetMessage 0 4 198 39 Buffered_DatagramConnection::GetMessage 0 1 80 54</span>
<span class="s0">/**</span>
 <span class="s0">* Reads a message.  Returns false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline bool Buffered_DatagramConnection::GetMessage(Datagram &amp;val);</span>

<span class="s0">172 9 DoConnect 0 4 198 38 Buffered_DatagramConnection::DoConnect 0 1 81 38</span>
<span class="s0">// all the real state magic is in here</span>
<span class="s0">57</span>
<span class="s0">inline bool Buffered_DatagramConnection::DoConnect(void);</span>

<span class="s0">173 11 IsConnected 0 4 198 40 Buffered_DatagramConnection::IsConnected 0 1 82 38</span>
<span class="s0">// all the real state magic is in here</span>
<span class="s0">59</span>
<span class="s0">inline bool Buffered_DatagramConnection::IsConnected(void);</span>

<span class="s0">174 27 Buffered_DatagramConnection 0 260 198 56 Buffered_DatagramConnection::Buffered_DatagramConnection 0 1 79 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">124</span>
<span class="s0">inline explicit Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point);</span>

<span class="s0">175 11 SendMessage 0 4 198 40 Buffered_DatagramConnection::SendMessage 0 1 83 58</span>
<span class="s0">// the reason thsi all exists</span>

<span class="s0">/**</span>
 <span class="s0">* send the message</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">bool Buffered_DatagramConnection::SendMessage(Datagram const &amp;msg);</span>

<span class="s0">176 5 Flush 0 4 198 34 Buffered_DatagramConnection::Flush 0 1 84 28</span>
<span class="s0">/**</span>
 <span class="s0">* Flush all writes.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool Buffered_DatagramConnection::Flush(void);</span>

<span class="s0">177 5 Reset 0 4 198 34 Buffered_DatagramConnection::Reset 0 1 85 16</span>
<span class="s0">/**</span>
 <span class="s0">* Reset</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void Buffered_DatagramConnection::Reset(void);</span>

<span class="s0">178 23 WaitForNetworkReadEvent 0 4 198 52 Buffered_DatagramConnection::WaitForNetworkReadEvent 0 1 86 0</span>
<span class="s0">86</span>
<span class="s0">inline void Buffered_DatagramConnection::WaitForNetworkReadEvent(PN_stdfloat MaxTime);</span>

<span class="s0">179 16 AddressQueueSize 0 4 198 45 Buffered_DatagramConnection::AddressQueueSize 0 1 87 22</span>
<span class="s0">// address queue stuff</span>
<span class="s0">71</span>
<span class="s0">inline std::size_t Buffered_DatagramConnection::AddressQueueSize(void);</span>

<span class="s0">180 10 AddAddress 0 4 198 39 Buffered_DatagramConnection::AddAddress 0 1 88 52</span>
<span class="s0">/**</span>
 <span class="s0">* must be called to set value to the server</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline void Buffered_DatagramConnection::AddAddress(Socket_Address &amp;inadr);</span>

<span class="s0">181 14 ClearAddresses 0 4 198 43 Buffered_DatagramConnection::ClearAddresses 0 1 89 0</span>
<span class="s0">62</span>
<span class="s0">inline void Buffered_DatagramConnection::ClearAddresses(void);</span>

<span class="s0">182 14 get_class_type 0 4 198 43 Buffered_DatagramConnection::get_class_type 0 1 90 0</span>
<span class="s0">68</span>
<span class="s0">static TypeHandle Buffered_DatagramConnection::get_class_type(void);</span>

<span class="s0">183 10 Socket_UDP 0 260 199 22 Socket_UDP::Socket_UDP 0 1 91 0</span>
<span class="s0">36</span>
<span class="s0">inline Socket_UDP::Socket_UDP(void);</span>

<span class="s0">184 13 InitToAddress 0 4 199 25 Socket_UDP::InitToAddress 0 1 92 106</span>
<span class="s0">// use this interface for a tagreted UDP connection</span>

<span class="s0">/**</span>
 <span class="s0">* Connects the socket to a Specified address</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline bool Socket_UDP::InitToAddress(Socket_Address const &amp;address);</span>

<span class="s0">185 4 Send 0 4 199 16 Socket_UDP::Send 0 1 93 84</span>
<span class="s0">/**</span>
 <span class="s0">* Send data to connected address</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Send data to connected address</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool Socket_UDP::Send(std::string const &amp;data);</span>

<span class="s0">186 6 SendTo 0 4 199 18 Socket_UDP::SendTo 0 1 94 84</span>
<span class="s0">/**</span>
 <span class="s0">* Send data to specified address</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Send data to specified address</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline bool Socket_UDP::SendTo(std::string const &amp;data, Socket_Address const &amp;address);</span>

<span class="s0">187 14 SetToBroadCast 0 4 199 26 Socket_UDP::SetToBroadCast 0 1 95 71</span>
<span class="s0">/**</span>
 <span class="s0">* Ask the OS to let us receive broadcast packets on this port.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool Socket_UDP::SetToBroadCast(void);</span>

<span class="s0">188 14 get_class_type 0 4 199 26 Socket_UDP::get_class_type 0 1 96 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle Socket_UDP::get_class_type(void);</span>

<span class="s0">189 11 ~Socket_UDP 0 516 199 23 Socket_UDP::~Socket_UDP 0 0 0</span>
<span class="s0">30</span>
<span class="s0">Socket_UDP::~Socket_UDP(void);</span>

<span class="s0">96</span>
<span class="s0">1 0 0 15 2 202 98 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 6 inaddr 1 200  </span>
<span class="s0">2 0 0 7 2 202 98 0 52 /**</span>
 <span class="s0">* Constructor that lets us set a port value</span>
 <span class="s0">*/ 1 4 port 5 203  </span>
<span class="s0">3 0 0 6 4 204 0 0 50 /**</span>
 <span class="s0">* Set to any address and a specified port</span>
 <span class="s0">*/ 2 4 this 3 202  4 port 1 203  </span>
<span class="s0">4 0 0 6 5 204 0 0 56 /**</span>
 <span class="s0">* Set to any IPv6 address and a specified port.</span>
 <span class="s0">*/ 2 4 this 3 202  4 port 1 203  </span>
<span class="s0">5 0 0 6 6 204 0 0 34 /**</span>
 <span class="s0">* Set to a specified port</span>
 <span class="s0">*/ 2 4 this 3 202  4 port 1 203  </span>
<span class="s0">6 0 0 6 7 204 0 0 60 /**</span>
 <span class="s0">* Set to the broadcast address and a specified port</span>
 <span class="s0">*/ 2 4 this 3 202  4 port 1 203  </span>
<span class="s0">7 0 0 6 8 204 0 0 158 /**</span>
 <span class="s0">* Initializes the address from a string specifying both the address and port,</span>
 <span class="s0">* separated by a colon.  An IPv6 address must be enclosed in brackets.</span>
 <span class="s0">*/ 2 4 this 3 202  8 hostname 1 205  </span>
<span class="s0">8 0 0 6 8 204 0 0 215 /**</span>
 <span class="s0">* This function will take a port and string-based TCP address and initialize</span>
 <span class="s0">* the address with this information.  Returns true on success; on failure, it</span>
 <span class="s0">* returns false and the address may be undefined.</span>
 <span class="s0">*/ 3 4 this 3 202  8 hostname 1 205  4 port 1 203  </span>
<span class="s0">9 0 0 6 8 204 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 202  7 ip4addr 1 206  4 port 1 203  </span>
<span class="s0">10 0 0 4 9 208 0 0 60 /**</span>
 <span class="s0">* Set the internal values to a suitable known value</span>
 <span class="s0">*/ 1 4 this 3 202  </span>
<span class="s0">11 0 0 6 10 209 0 0 97 /**</span>
 <span class="s0">* Returns AF_INET if this is an IPv4 address, or AF_INET6 if this is an IPv6</span>
 <span class="s0">* address.</span>
 <span class="s0">*/ 1 4 this 3 200  </span>
<span class="s0">12 0 0 6 11 203 0 0 45 /**</span>
 <span class="s0">* Get the port portion as an integer</span>
 <span class="s0">*/ 1 4 this 3 200  </span>
<span class="s0">13 0 0 6 12 205 0 0 64 /**</span>
 <span class="s0">* Return the IP address portion in dot notation string.</span>
 <span class="s0">*/ 1 4 this 3 200  </span>
<span class="s0">14 0 0 6 13 205 0 0 133 /**</span>
 <span class="s0">* Return the ip address/port in dot notation string.  If this is an IPv6</span>
 <span class="s0">* address, it will be enclosed in square brackets.</span>
 <span class="s0">*/ 1 4 this 3 200  </span>
<span class="s0">15 0 0 6 14 210 0 0 130 /**</span>
 <span class="s0">* Returns a raw 32-bit unsigned integer representing the IPv4 address.</span>
 <span class="s0">* @deprecated  Does not work with IPv6 addresses.</span>
 <span class="s0">*/ 1 4 this 3 200  </span>
<span class="s0">16 0 0 6 15 204 0 0 0 2 4 this 3 200  2 in 1 200  </span>
<span class="s0">17 0 0 6 16 204 0 0 0 2 4 this 3 200  2 in 1 200  </span>
<span class="s0">18 0 0 6 17 204 0 0 0 2 4 this 3 200  2 in 1 200  </span>
<span class="s0">19 0 0 6 18 204 0 0 39 /**</span>
 <span class="s0">* True if the address is zero.</span>
 <span class="s0">*/ 1 4 this 3 200  </span>
<span class="s0">20 0 0 6 19 204 0 0 57 /**</span>
 <span class="s0">* True if the address is in the multicast range.</span>
 <span class="s0">*/ 1 4 this 3 200  </span>
<span class="s0">21 0 0 7 22 211 0 0 26 /**</span>
 <span class="s0">* Def Constructor</span>
 <span class="s0">*/ 0 </span>
<span class="s0">22 0 0 23 22 211 0 0 51 /**</span>
 <span class="s0">* Assigns an existing socket to this class</span>
 <span class="s0">*/ 1 2 in 1 212  </span>
<span class="s0">23 0 0 4 23 208 0 0 53 /**</span>
 <span class="s0">* Closes a socket if it is open (allocated).</span>
 <span class="s0">*/ 1 4 this 3 211  </span>
<span class="s0">24 0 0 6 24 213 0 0 57 /**</span>
 <span class="s0">* Gets the last errcode from a socket operation.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">25 0 0 6 25 213 0 0 67 /**</span>
 <span class="s0">* this function will throw a socket into non-blocking mode</span>
 <span class="s0">*/ 1 4 this 3 211  </span>
<span class="s0">26 0 0 6 26 213 0 0 102 /**</span>
 <span class="s0">* Set the socket to block on subsequent calls to socket functions that</span>
 <span class="s0">* address this socket</span>
 <span class="s0">*/ 1 4 this 3 211  </span>
<span class="s0">27 0 0 6 27 204 0 0 57 /**</span>
 <span class="s0">* Informs a socket to reuse IP address as needed</span>
 <span class="s0">*/ 2 4 this 3 211  4 flag 5 204  </span>
<span class="s0">28 0 0 6 28 204 0 0 103 /**</span>
 <span class="s0">* Sets a flag indicating whether this IPv6 socket should operate in</span>
 <span class="s0">* dual-stack mode or not.</span>
 <span class="s0">*/ 2 4 this 3 211  4 flag 1 204  </span>
<span class="s0">29 0 0 6 29 204 0 0 48 /**</span>
 <span class="s0">* Ask if the socket is open (allocated)</span>
 <span class="s0">*/ 1 4 this 3 211  </span>
<span class="s0">30 0 0 6 30 213 0 0 63 /**</span>
 <span class="s0">* Ok it sets the recv buffer size for both tcp and UDP</span>
 <span class="s0">*/ 2 4 this 3 211  4 size 1 213  </span>
<span class="s0">31 0 0 4 31 208 0 0 51 /**</span>
 <span class="s0">* Assigns an existing socket to this class</span>
 <span class="s0">*/ 2 4 this 3 211  3 ins 1 212  </span>
<span class="s0">32 0 0 6 32 212 0 0 36 /**</span>
 <span class="s0">* Gets the base socket type</span>
 <span class="s0">*/ 1 4 this 3 211  </span>
<span class="s0">33 0 0 6 32 212 0 0 44 /**</span>
 <span class="s0">* Get The RAW file id of the socket</span>
 <span class="s0">*/ 1 4 this 3 214  </span>
<span class="s0">34 0 0 7 33 202 98 0 43 /**</span>
 <span class="s0">* Wrapper on berkly getpeername...</span>
 <span class="s0">*/ 1 4 this 3 214  </span>
<span class="s0">35 0 0 6 34 213 0 0 0 0 </span>
<span class="s0">36 0 0 7 35 217 0 0 0 0 </span>
<span class="s0">37 0 0 7 37 218 141 0 0 0 </span>
<span class="s0">38 0 0 23 37 218 141 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 6 param0 0 212  </span>
<span class="s0">39 0 0 6 38 213 0 0 73 /**</span>
 <span class="s0">* Disable Nagle algorithm.  Don't delay send to coalesce packets</span>
 <span class="s0">*/ 2 4 this 3 218  4 flag 5 204  </span>
<span class="s0">40 0 0 6 39 213 0 0 66 /**</span>
 <span class="s0">* will control the behavior of SO_LINGER for a TCP socket</span>
 <span class="s0">*/ 2 4 this 3 218  16 interval_seconds 5 213  </span>
<span class="s0">41 0 0 6 40 213 0 0 217 /**</span>
 <span class="s0">* Turn off the linger flag.  The socket will quickly release buffered items</span>
 <span class="s0">* and free up OS resources.  You may lose a stream if you use this flag and</span>
 <span class="s0">* do not negotiate the close at the application layer.</span>
 <span class="s0">*/ 1 4 this 3 218  </span>
<span class="s0">42 0 0 6 41 213 0 0 143 /**</span>
 <span class="s0">* Just like it sounds.  Sets a buffered socket recv buffer size.  This</span>
 <span class="s0">* function does not refuse ranges outside hard-coded OS limits</span>
 <span class="s0">*/ 2 4 this 3 218  6 insize 1 213  </span>
<span class="s0">43 0 0 6 42 204 0 0 138 /**</span>
 <span class="s0">* This function will try and set the socket up for active open to a specified</span>
 <span class="s0">* address and port provided by the input parameter</span>
 <span class="s0">*/ 3 4 this 3 218  10 theaddress 1 200  8 setdelay 1 204  </span>
<span class="s0">44 0 0 6 43 204 0 0 161 /**</span>
 <span class="s0">* This function will try and set the socket up for active open to a specified</span>
 <span class="s0">* address and port provided by the input parameter (non-blocking version)</span>
 <span class="s0">*/ 2 4 this 3 218  10 theaddress 1 200  </span>
<span class="s0">45 0 0 6 44 204 0 0 0 2 4 this 3 218  3 err 1 213  </span>
<span class="s0">46 0 0 6 45 204 0 0 0 1 4 this 3 218  </span>
<span class="s0">47 0 0 6 46 213 0 0 0 2 4 this 3 218  3 str 1 205  </span>
<span class="s0">48 0 0 6 47 205 0 0 146 /**</span>
 <span class="s0">* Read the data from the connection - if error 0 if socket closed for read or</span>
 <span class="s0">* length is 0 + bytes read (May be smaller than requested)</span>
 <span class="s0">*/ 2 4 this 3 218  7 max_len 1 213  </span>
<span class="s0">49 0 0 7 48 217 0 0 0 0 </span>
<span class="s0">50 0 0 7 51 219 0 0 0 0 </span>
<span class="s0">51 0 0 6 52 204 0 0 59 /**</span>
 <span class="s0">* This function will initialize a listening Socket</span>
 <span class="s0">*/ 3 4 this 3 219  7 address 1 200  12 backlog_size 5 213  </span>
<span class="s0">52 0 0 6 52 204 0 0 59 /**</span>
 <span class="s0">* This function will initialize a listening Socket</span>
 <span class="s0">*/ 3 4 this 3 219  4 port 1 203  12 backlog_size 5 213  </span>
<span class="s0">53 0 0 6 53 204 0 0 0 3 4 this 3 219  10 newsession 1 218  7 address 1 202  </span>
<span class="s0">54 0 0 7 54 217 0 0 0 0 </span>
<span class="s0">55 0 0 7 56 220 154 0 0 0 </span>
<span class="s0">56 0 0 6 57 204 0 0 50 /**</span>
 <span class="s0">* Starts a UDP socket listening on a port</span>
 <span class="s0">*/ 2 4 this 3 220  7 address 1 200  </span>
<span class="s0">57 0 0 6 57 204 0 0 50 /**</span>
 <span class="s0">* Starts a UDP socket listening on a port</span>
 <span class="s0">*/ 2 4 this 3 220  4 port 1 203  </span>
<span class="s0">58 0 0 6 58 204 0 0 50 /**</span>
 <span class="s0">* Starts a UDP socket listening on a port</span>
 <span class="s0">*/ 2 4 this 3 220  7 address 1 200  </span>
<span class="s0">59 0 0 6 60 204 0 0 41 /**</span>
 <span class="s0">* Send data to specified address</span>
 <span class="s0">*/ 4 4 this 3 220  4 data 1 205  3 len 1 213  7 address 1 200  </span>
<span class="s0">60 0 0 6 61 204 0 0 68 /**</span>
 <span class="s0">* Set this socket to work without a bound external address.</span>
 <span class="s0">*/ 1 4 this 3 220  </span>
<span class="s0">61 0 0 6 62 204 0 0 85 /**</span>
 <span class="s0">* Flips the OS bits that allow for brodcast packets to come in on this port.</span>
 <span class="s0">*/ 1 4 this 3 220  </span>
<span class="s0">62 0 0 7 63 217 0 0 0 0 </span>
<span class="s0">63 0 0 7 66 221 162 0 0 0 </span>
<span class="s0">64 0 0 6 67 204 0 0 53 /**</span>
 <span class="s0">* Connects the Socket to a specified address</span>
 <span class="s0">*/ 2 4 this 3 221  7 address 1 200  </span>
<span class="s0">65 0 0 6 68 204 0 0 41 /**</span>
 <span class="s0">* Send data to connected address</span>
 <span class="s0">*/ 2 4 this 3 221  4 data 1 205  </span>
<span class="s0">66 0 0 6 69 204 0 0 56 // use this interface for a none tagreted UDP connection 1 4 this 3 221  </span>
<span class="s0">67 0 0 6 70 204 0 0 41 /**</span>
 <span class="s0">* Send data to specified address</span>
 <span class="s0">*/ 3 4 this 3 221  4 data 1 205  7 address 1 200  </span>
<span class="s0">68 0 0 6 71 204 0 0 71 /**</span>
 <span class="s0">* Ask the OS to let us receive broadcast packets on this port.</span>
 <span class="s0">*/ 1 4 this 3 221  </span>
<span class="s0">69 0 0 7 72 217 0 0 0 0 </span>
<span class="s0">70 0 0 7 75 222 170 0 26 /**</span>
 <span class="s0">* The constructor</span>
 <span class="s0">*/ 0 </span>
<span class="s0">71 0 0 15 75 222 170 0 0 1 6 param0 0 223  </span>
<span class="s0">72 0 0 4 76 208 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 222  5 incon 1 214  </span>
<span class="s0">73 0 0 6 77 204 0 0 70 /**</span>
 <span class="s0">* check to see if a socket object has been marked for reading</span>
 <span class="s0">*/ 2 4 this 3 223  5 incon 1 214  </span>
<span class="s0">74 0 0 6 78 213 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 222  7 zeroFds 1 204  7 timeout 1 225  </span>
<span class="s0">75 0 0 6 78 213 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 222  7 zeroFds 1 204  10 sleep_time 5 206  </span>
<span class="s0">76 0 0 6 79 213 0 0 94 /**</span>
 <span class="s0">* This is the function that will wait till one of the sockets is ready for</span>
 <span class="s0">* writing</span>
 <span class="s0">*/ 3 4 this 3 222  7 zeroFds 1 204  10 sleep_time 5 206  </span>
<span class="s0">77 0 0 6 80 213 0 0 91 /**</span>
 <span class="s0">* This is the function that will wait till one of the sockets is in error</span>
 <span class="s0">* state</span>
 <span class="s0">*/ 3 4 this 3 222  7 zeroFds 1 204  10 sleep_time 5 206  </span>
<span class="s0">78 0 0 4 81 208 0 0 37 /**</span>
 <span class="s0">* Marks the content as empty</span>
 <span class="s0">*/ 1 4 this 3 222  </span>
<span class="s0">79 0 0 7 87 228 141 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 8 rbufsize 1 213  8 wbufsize 1 213  17 write_flush_point 1 213  </span>
<span class="s0">80 0 0 6 84 204 0 0 54 /**</span>
 <span class="s0">* Reads a message.  Returns false on failure.</span>
 <span class="s0">*/ 2 4 this 3 228  3 val 1 229  </span>
<span class="s0">81 0 0 6 85 204 0 0 38 // all the real state magic is in here 1 4 this 3 228  </span>
<span class="s0">82 0 0 6 86 204 0 0 38 // all the real state magic is in here 1 4 this 3 228  </span>
<span class="s0">83 0 0 6 88 204 0 0 29 // the reason thsi all exists 2 4 this 3 228  3 msg 1 231  </span>
<span class="s0">84 0 0 6 89 204 0 0 28 /**</span>
 <span class="s0">* Flush all writes.</span>
 <span class="s0">*/ 1 4 this 3 228  </span>
<span class="s0">85 0 0 4 90 208 0 0 16 /**</span>
 <span class="s0">* Reset</span>
 <span class="s0">*/ 1 4 this 3 228  </span>
<span class="s0">86 0 0 4 91 208 0 0 0 2 4 this 3 228  7 MaxTime 1 233  </span>
<span class="s0">87 0 0 6 92 235 0 0 22 // address queue stuff 1 4 this 3 228  </span>
<span class="s0">88 0 0 4 93 208 0 0 52 /**</span>
 <span class="s0">* must be called to set value to the server</span>
 <span class="s0">*/ 2 4 this 3 228  5 inadr 1 202  </span>
<span class="s0">89 0 0 4 94 208 0 0 0 1 4 this 3 228  </span>
<span class="s0">90 0 0 7 95 217 0 0 0 0 </span>
<span class="s0">91 0 0 7 97 237 189 0 0 0 </span>
<span class="s0">92 0 0 6 98 204 0 0 53 /**</span>
 <span class="s0">* Connects the socket to a Specified address</span>
 <span class="s0">*/ 2 4 this 3 237  7 address 1 200  </span>
<span class="s0">93 0 0 6 99 204 0 0 41 /**</span>
 <span class="s0">* Send data to connected address</span>
 <span class="s0">*/ 2 4 this 3 237  4 data 1 205  </span>
<span class="s0">94 0 0 6 100 204 0 0 41 /**</span>
 <span class="s0">* Send data to specified address</span>
 <span class="s0">*/ 3 4 this 3 237  4 data 1 205  7 address 1 200  </span>
<span class="s0">95 0 0 6 101 204 0 0 71 /**</span>
 <span class="s0">* Ask the OS to let us receive broadcast packets on this port.</span>
 <span class="s0">*/ 1 4 this 3 237  </span>
<span class="s0">96 0 0 7 102 217 0 0 0 0 </span>
<span class="s0">48</span>
<span class="s0">190 14 Socket_Address 0 26625 14 Socket_Address 14 Socket_Address 0 0 0 1 97 98 0 16 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 0 0 0 0 0 97</span>
<span class="s0">/**</span>
 <span class="s0">* A simple place to store and manipulate tcp and port address for</span>
 <span class="s0">* communication layer</span>
 <span class="s0">*/</span>

<span class="s0">191 9 Socket_IP 0 75777 9 Socket_IP 9 Socket_IP 0 0 0 1 115 0 0 13 116 117 118 119 120 121 122 123 124 125 126 127 128 0 0 1 0 192 0 0 0 0 354</span>
<span class="s0">/**</span>
 <span class="s0">* Base functionality for a INET domain Socket This call should be the</span>
 <span class="s0">* starting point for all other unix domain sockets.</span>
 <span class="s0">*</span>
 <span class="s0">* SocketIP |</span>
 <span class="s0">* ------------------------------------------------------------------- |</span>
 <span class="s0">* |                       |                           | SocketTCP</span>
 <span class="s0">* SocketTCP_Listen    SocketUDP_Incoming   SocketUDP_OutBound</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">192 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">193 10 Socket_TCP 0 141313 10 Socket_TCP 10 Socket_TCP 0 0 0 1 129 141 0 11 130 131 132 133 134 135 136 137 138 139 140 0 0 1 0 191 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* Base functionality for a TCP connected socket This class is pretty useless</span>
 <span class="s0">* by itself but it does hide some of the platform differences from machine to</span>
 <span class="s0">* machine</span>
 <span class="s0">*/</span>

<span class="s0">194 17 Socket_TCP_Listen 0 75777 17 Socket_TCP_Listen 17 Socket_TCP_Listen 0 0 0 1 142 0 0 3 143 144 145 0 0 1 0 191 0 0 0 0 57</span>
<span class="s0">/**</span>
 <span class="s0">* Base functionality for a TCP rendezvous socket</span>
 <span class="s0">*/</span>

<span class="s0">195 19 Socket_UDP_Incoming 0 141313 19 Socket_UDP_Incoming 19 Socket_UDP_Incoming 0 0 0 1 146 154 0 7 147 148 149 150 151 152 153 0 0 1 0 191 0 0 0 0 46</span>
<span class="s0">/**</span>
 <span class="s0">* Base functionality for a UDP Reader</span>
 <span class="s0">*/</span>

<span class="s0">196 19 Socket_UDP_Outgoing 0 141313 19 Socket_UDP_Outgoing 19 Socket_UDP_Outgoing 0 0 0 1 155 162 0 6 156 157 158 159 160 161 0 0 1 0 191 0 0 0 0 54</span>
<span class="s0">/**</span>
 <span class="s0">* Base functionality for a UDP sending socket</span>
 <span class="s0">*/</span>

<span class="s0">197 12 Socket_fdset 0 141313 12 Socket_fdset 12 Socket_fdset 0 0 0 1 163 170 0 6 164 165 166 167 168 169 0 0 0 0 0 0</span>

<span class="s0">198 27 Buffered_DatagramConnection 0 75777 27 Buffered_DatagramConnection 27 Buffered_DatagramConnection 0 0 0 1 174 141 0 11 171 172 173 175 176 177 178 179 180 181 182 0 0 1 0 193 0 0 0 0 176</span>
<span class="s0">// there are 3 states 1. Socket not even assigned,,,, 2. Socket Assigned and</span>
<span class="s0">// trying to get a active connect open 3. Socket is open and  writable.. (</span>
<span class="s0">// Fully powered up )...</span>

<span class="s0">199 10 Socket_UDP 0 141313 10 Socket_UDP 10 Socket_UDP 0 0 0 1 183 189 0 5 184 185 186 187 188 0 0 1 0 195 0 0 0 0 171</span>
<span class="s0">/**</span>
 <span class="s0">* Base functionality for a combination UDP Reader and Writer.  This</span>
 <span class="s0">* duplicates code from Socket_UDP_Outgoing, to avoid the problems of multiple</span>
 <span class="s0">* inheritance.</span>
 <span class="s0">*/</span>

<span class="s0">200 22 Socket_Address const * 0 8576 22 Socket_Address const * 22 Socket_Address const * 0 0 201 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">201 20 Socket_Address const 0 8832 20 Socket_Address const 20 Socket_Address const 0 0 190 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">202 16 Socket_Address * 0 8576 16 Socket_Address * 16 Socket_Address * 0 0 190 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">203 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">204 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">205 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">206 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 207 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">207 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">208 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">209 11 sa_family_t 0 2105344 11 sa_family_t 11 sa_family_t 0 0 203 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">210 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">211 11 Socket_IP * 0 8576 11 Socket_IP * 11 Socket_IP * 0 0 191 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">212 6 SOCKET 0 2105344 6 SOCKET 6 SOCKET 0 0 210 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">213 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">214 17 Socket_IP const * 0 8576 17 Socket_IP const * 17 Socket_IP const * 0 0 215 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">215 15 Socket_IP const 0 8832 15 Socket_IP const 15 Socket_IP const 0 0 191 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">216 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">217 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 216 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">218 12 Socket_TCP * 0 8576 12 Socket_TCP * 12 Socket_TCP * 0 0 193 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">219 19 Socket_TCP_Listen * 0 8576 19 Socket_TCP_Listen * 19 Socket_TCP_Listen * 0 0 194 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">220 21 Socket_UDP_Incoming * 0 8576 21 Socket_UDP_Incoming * 21 Socket_UDP_Incoming * 0 0 195 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">221 21 Socket_UDP_Outgoing * 0 8576 21 Socket_UDP_Outgoing * 21 Socket_UDP_Outgoing * 0 0 196 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">222 14 Socket_fdset * 0 8576 14 Socket_fdset * 14 Socket_fdset * 0 0 197 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">223 20 Socket_fdset const * 0 8576 20 Socket_fdset const * 20 Socket_fdset const * 0 0 224 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">224 18 Socket_fdset const 0 8832 18 Socket_fdset const 18 Socket_fdset const 0 0 197 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">225 17 Time_Span const * 0 8576 17 Time_Span const * 17 Time_Span const * 0 0 226 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">226 15 Time_Span const 0 8832 15 Time_Span const 15 Time_Span const 0 0 227 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">227 9 Time_Span 0 1050624 9 Time_Span 9 Time_Span 0 0 0 0 0 0 0 0 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">228 29 Buffered_DatagramConnection * 0 8576 29 Buffered_DatagramConnection * 29 Buffered_DatagramConnection * 0 0 198 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">229 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 230 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">230 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">231 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 232 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">232 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 230 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">233 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 234 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">234 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">235 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 236 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">236 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">237 12 Socket_UDP * 0 8576 12 Socket_UDP * 12 Socket_UDP * 0 0 199 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">0</span>
<span class="s0">0</span>
</pre>
</body>
</html>