<html>
<head>
<title>libp3pstatclient.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3pstatclient.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">16 libp3pstatclient 4 __OL 12 panda3d.core </span>
<span class="s0">64</span>
<span class="s0">77 15 set_client_name 0 4 141 28 PStatClient::set_client_name 0 1 1 143</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the name of the client.  This is reported to the PStatsServer, and</span>
 <span class="s0">* will presumably be written in the title bar or something.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void PStatClient::set_client_name(std::string const &amp;name);</span>

<span class="s0">78 15 get_client_name 0 4 141 28 PStatClient::get_client_name 0 1 2 51</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the name of the client as set.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">std::string PStatClient::get_client_name(void) const;</span>

<span class="s0">79 12 set_max_rate 0 4 141 25 PStatClient::set_max_rate 0 1 3 469</span>
<span class="s0">/**</span>
 <span class="s0">* Controls the number of packets that will be sent to the server.  Normally,</span>
 <span class="s0">* one packet is sent per frame, but this can flood the server with more</span>
 <span class="s0">* packets than it can handle if the frame rate is especially good (e.g.  if</span>
 <span class="s0">* nothing is onscreen at the moment).  Set this parameter to a reasonable</span>
 <span class="s0">* number to prevent this from happening.</span>
 <span class="s0">*</span>
 <span class="s0">* This number specifies the maximum number of packets that will be sent to</span>
 <span class="s0">* the server per second, per thread.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void PStatClient::set_max_rate(double rate);</span>

<span class="s0">80 12 get_max_rate 0 4 141 25 PStatClient::get_max_rate 0 1 4 128</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum number of packets that will be sent to the server per</span>
 <span class="s0">* second, per thread.  See set_max_rate().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">double PStatClient::get_max_rate(void) const;</span>

<span class="s0">81 18 get_num_collectors 0 4 141 31 PStatClient::get_num_collectors 0 1 5 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of collectors the Client knows about.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline int PStatClient::get_num_collectors(void) const;</span>

<span class="s0">82 13 get_collector 0 4 141 26 PStatClient::get_collector 0 1 6 37</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth collector.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">PStatCollector PStatClient::get_collector(int index) const;</span>

<span class="s0">83 17 get_collector_def 0 4 141 30 PStatClient::get_collector_def 0 1 7 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the definition body of the nth collector.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline PStatCollectorDef *PStatClient::get_collector_def(int index) const;</span>

<span class="s0">84 18 get_collector_name 0 4 141 31 PStatClient::get_collector_name 0 1 8 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the indicated collector.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">std::string PStatClient::get_collector_name(int index) const;</span>

<span class="s0">85 22 get_collector_fullname 0 4 141 35 PStatClient::get_collector_fullname 0 1 9 186</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;full name&quot; of the indicated collector.  This will be the</span>
 <span class="s0">* concatenation of all of the collector's parents' names (except Frame) and</span>
 <span class="s0">* the collector's own name.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">std::string PStatClient::get_collector_fullname(int index) const;</span>

<span class="s0">86 15 get_num_threads 0 4 141 28 PStatClient::get_num_threads 0 1 10 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of threads the Client knows about.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int PStatClient::get_num_threads(void) const;</span>

<span class="s0">87 10 get_thread 0 4 141 23 PStatClient::get_thread 0 1 11 34</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth thread.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">PStatThread PStatClient::get_thread(int index) const;</span>

<span class="s0">88 15 get_thread_name 0 4 141 28 PStatClient::get_thread_name 0 1 12 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the indicated thread.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline std::string PStatClient::get_thread_name(int index) const;</span>

<span class="s0">89 20 get_thread_sync_name 0 4 141 33 PStatClient::get_thread_sync_name 0 1 13 57</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sync_name of the indicated thread.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline std::string PStatClient::get_thread_sync_name(int index) const;</span>

<span class="s0">90 17 get_thread_object 0 4 141 30 PStatClient::get_thread_object 0 1 14 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Panda Thread object associated with the indicated PStatThread.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline PointerTo&lt; Thread &gt; PStatClient::get_thread_object(int index) const;</span>

<span class="s0">91 15 get_main_thread 0 4 141 28 PStatClient::get_main_thread 0 1 15 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a handle to the client's Main thread.  This is the thread that</span>
 <span class="s0">* started the application.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">PStatThread PStatClient::get_main_thread(void) const;</span>

<span class="s0">92 18 get_current_thread 0 4 141 31 PStatClient::get_current_thread 0 1 16 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a handle to the currently-executing thread.  This is the thread</span>
 <span class="s0">* that PStatCollectors will be counted in if they do not specify otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">PStatThread PStatClient::get_current_thread(void) const;</span>

<span class="s0">93 13 get_real_time 0 4 141 26 PStatClient::get_real_time 0 1 17 248</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the time according to to the PStatClient's clock object.  It keeps</span>
 <span class="s0">* its own clock, instead of using the global clock object, so the stats won't</span>
 <span class="s0">* get mucked up if you put the global clock in non-real-time mode or</span>
 <span class="s0">* something.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">double PStatClient::get_real_time(void) const;</span>

<span class="s0">94 14 PStatCollector 0 260 147 30 PStatCollector::PStatCollector 0 3 31 32 33 1708</span>
<span class="s0">/**</span>
 <span class="s0">* Normally, this constructor is called only from PStatClient.  Use one of the</span>
 <span class="s0">* constructors below to create your own Collector.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a new PStatCollector, ready to start accumulating data.  The name</span>
 <span class="s0">* of the collector uniquely identifies it among the other collectors; if two</span>
 <span class="s0">* collectors share the same name then they are really the same collector.</span>
 <span class="s0">*</span>
 <span class="s0">* The name may also be a compound name, something like &quot;Cull:Sort&quot;, which</span>
 <span class="s0">* indicates that this is a collector named &quot;Sort&quot;, a child of the collector</span>
 <span class="s0">* named &quot;Cull&quot;. The parent may also be named explicitly by reference in the</span>
 <span class="s0">* other flavor of the constructor; see further comments on this for that</span>
 <span class="s0">* constructor.</span>
 <span class="s0">*</span>
 <span class="s0">* If the client pointer is non-null, it specifies a particular client to</span>
 <span class="s0">* register the collector with; otherwise, the global client is used.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a new PStatCollector, ready to start accumulating data.  The name</span>
 <span class="s0">* of the collector uniquely identifies it among the other collectors; if two</span>
 <span class="s0">* collectors share the same name then they are really the same collector.</span>
 <span class="s0">*</span>
 <span class="s0">* The parent is the collector that conceptually includes all of the time</span>
 <span class="s0">* measured for this collector.  For instance, a particular character's</span>
 <span class="s0">* animation time is owned by the &quot;Animation&quot; collector, which is in turn</span>
 <span class="s0">* owned by the &quot;Frame&quot; collector.  It is not strictly necessary that all of</span>
 <span class="s0">* the time spent in a particular collector is completely nested within time</span>
 <span class="s0">* spent in its parent's collector.  If parent is the empty string, the</span>
 <span class="s0">* collector is owned by &quot;Frame&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* This constructor does not take a client pointer; it always creates the new</span>
 <span class="s0">* collector on the same client as its parent.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">273</span>
<span class="s0">inline explicit PStatCollector::PStatCollector(std::string const &amp;name, PStatClient *client = nullptr);</span>
<span class="s0">inline explicit PStatCollector::PStatCollector(PStatCollector const &amp;parent, std::string const &amp;name);</span>
<span class="s0">inline PStatCollector::PStatCollector(PStatCollector const &amp;copy);</span>

<span class="s0">95 10 operator = 0 4 147 26 PStatCollector::operator = 0 1 34 0</span>
<span class="s0">67</span>
<span class="s0">inline void PStatCollector::operator =(PStatCollector const &amp;copy);</span>

<span class="s0">96 8 is_valid 0 4 147 24 PStatCollector::is_valid 0 1 35 178</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if collector is valid and may be used, or false if it was</span>
 <span class="s0">* constructed with the default constructor (in which case any attempt to use</span>
 <span class="s0">* it will crash).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool PStatCollector::is_valid(void) const;</span>

<span class="s0">97 8 get_name 0 4 147 24 PStatCollector::get_name 0 1 36 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the local name of this collector.  This is the rightmost part of</span>
 <span class="s0">* the fullname, after the rightmost colon.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline std::string PStatCollector::get_name(void) const;</span>

<span class="s0">98 12 get_fullname 0 4 147 28 PStatCollector::get_fullname 0 1 37 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the full name of this collector.  This includes the names of all</span>
 <span class="s0">* the collector's parents, concatenated together with colons.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline std::string PStatCollector::get_fullname(void) const;</span>

<span class="s0">99 6 output 0 4 147 22 PStatCollector::output 0 1 38 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PStatCollector::output(std::ostream &amp;out) const;</span>

<span class="s0">100 9 is_active 0 4 147 25 PStatCollector::is_active 0 2 39 40 274</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this particular collector is active on the default thread,</span>
 <span class="s0">* and we are currently transmitting PStats data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if this particular collector is active on the indicated</span>
 <span class="s0">* thread, and we are currently transmitting PStats data.</span>
 <span class="s0">*/</span>
<span class="s0">110</span>
<span class="s0">inline bool PStatCollector::is_active(void);</span>
<span class="s0">inline bool PStatCollector::is_active(PStatThread const &amp;thread);</span>

<span class="s0">101 10 is_started 0 4 147 26 PStatCollector::is_started 0 2 41 42 234</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this particular collector has been started on the default</span>
 <span class="s0">* thread, or false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if this particular collector has been started on the indicated</span>
 <span class="s0">* thread, or false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">inline bool PStatCollector::is_started(void);</span>
<span class="s0">inline bool PStatCollector::is_started(PStatThread const &amp;thread);</span>

<span class="s0">102 5 start 0 4 147 21 PStatCollector::start 0 3 43 44 45 458</span>
<span class="s0">/**</span>
 <span class="s0">* Starts this particular timer ticking.  This should be called before the</span>
 <span class="s0">* code you want to measure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Starts this timer ticking within a particular thread.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Marks that the timer should have been started as of the indicated time.</span>
 <span class="s0">* This must be a time based on the PStatClient's clock (see</span>
 <span class="s0">* PStatClient::get_clock()), and care should be taken that all such calls</span>
 <span class="s0">* exhibit a monotonically increasing series of time values.</span>
 <span class="s0">*/</span>
<span class="s0">178</span>
<span class="s0">inline void PStatCollector::start(void);</span>
<span class="s0">inline void PStatCollector::start(PStatThread const &amp;thread);</span>
<span class="s0">inline void PStatCollector::start(PStatThread const &amp;thread, double as_of);</span>

<span class="s0">103 4 stop 0 4 147 20 PStatCollector::stop 0 3 46 47 48 428</span>
<span class="s0">/**</span>
 <span class="s0">* Stops this timer.  This should be called after the code you want to</span>
 <span class="s0">* measure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Stops this timer within a particular thread.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Marks that the timer should have been stopped as of the indicated time.</span>
 <span class="s0">* This must be a time based on the PStatClient's clock (see</span>
 <span class="s0">* PStatClient::get_clock()), and care should be taken that all such calls</span>
 <span class="s0">* exhibit a monotonically increasing series of time values.</span>
 <span class="s0">*/</span>
<span class="s0">175</span>
<span class="s0">inline void PStatCollector::stop(void);</span>
<span class="s0">inline void PStatCollector::stop(PStatThread const &amp;thread);</span>
<span class="s0">inline void PStatCollector::stop(PStatThread const &amp;thread, double as_of);</span>

<span class="s0">104 11 clear_level 0 4 147 27 PStatCollector::clear_level 0 2 49 50 385</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the level setting associated with this collector for the main</span>
 <span class="s0">* thread.  The collector will no longer show up on any level graphs in the</span>
 <span class="s0">* main thread.  This implicitly calls flush_level().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the level setting associated with this collector for the indicated</span>
 <span class="s0">* thread.  The collector will no longer show up on any level graphs in this</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline void PStatCollector::clear_level(void);</span>
<span class="s0">inline void PStatCollector::clear_level(PStatThread const &amp;thread);</span>

<span class="s0">105 9 set_level 0 4 147 25 PStatCollector::set_level 0 2 51 52 267</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the level setting associated with this collector for the main thread</span>
 <span class="s0">* to the indicated value.  This implicitly calls flush_level().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the level setting associated with this collector for the indicated</span>
 <span class="s0">* thread to the indicated value.</span>
 <span class="s0">*/</span>
<span class="s0">132</span>
<span class="s0">inline void PStatCollector::set_level(double level);</span>
<span class="s0">inline void PStatCollector::set_level(PStatThread const &amp;thread, double level);</span>

<span class="s0">106 9 add_level 0 4 147 25 PStatCollector::add_level 0 2 53 54 630</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated increment (which may be negative) to the level setting</span>
 <span class="s0">* associated with this collector for the main thread.  If the collector did</span>
 <span class="s0">* not already have a level setting for the main thread, it is initialized to</span>
 <span class="s0">* 0.</span>
 <span class="s0">*</span>
 <span class="s0">* As an optimization, the data is not immediately set to the PStatClient.  It</span>
 <span class="s0">* will be sent the next time flush_level() is called.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the indicated increment (which may be negative) to the level setting</span>
 <span class="s0">* associated with this collector for the indicated thread.  If the collector</span>
 <span class="s0">* did not already have a level setting for this thread, it is initialized to</span>
 <span class="s0">* 0.</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">inline void PStatCollector::add_level(double increment);</span>
<span class="s0">inline void PStatCollector::add_level(PStatThread const &amp;thread, double increment);</span>

<span class="s0">107 9 sub_level 0 4 147 25 PStatCollector::sub_level 0 2 55 56 640</span>
<span class="s0">/**</span>
 <span class="s0">* Subtracts the indicated decrement (which may be negative) to the level</span>
 <span class="s0">* setting associated with this collector for the main thread.  If the</span>
 <span class="s0">* collector did not already have a level setting for the main thread, it is</span>
 <span class="s0">* initialized to 0.</span>
 <span class="s0">*</span>
 <span class="s0">* As an optimization, the data is not immediately set to the PStatClient.  It</span>
 <span class="s0">* will be sent the next time flush_level() is called.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Subtracts the indicated decrement (which may be negative) to the level</span>
 <span class="s0">* setting associated with this collector for the indicated thread.  If the</span>
 <span class="s0">* collector did not already have a level setting for this thread, it is</span>
 <span class="s0">* initialized to 0.</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">inline void PStatCollector::sub_level(double decrement);</span>
<span class="s0">inline void PStatCollector::sub_level(PStatThread const &amp;thread, double decrement);</span>

<span class="s0">108 13 add_level_now 0 4 147 29 PStatCollector::add_level_now 0 1 57 65</span>
<span class="s0">/**</span>
 <span class="s0">* Calls add_level() and immediately calls flush_level().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PStatCollector::add_level_now(double increment);</span>

<span class="s0">109 13 sub_level_now 0 4 147 29 PStatCollector::sub_level_now 0 1 58 65</span>
<span class="s0">/**</span>
 <span class="s0">* Calls sub_level() and immediately calls flush_level().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void PStatCollector::sub_level_now(double decrement);</span>

<span class="s0">110 11 flush_level 0 4 147 27 PStatCollector::flush_level 0 1 59 95</span>
<span class="s0">/**</span>
 <span class="s0">* Updates the PStatClient with the recent results from add_level() and</span>
 <span class="s0">* sub_level().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void PStatCollector::flush_level(void);</span>

<span class="s0">111 9 get_level 0 4 147 25 PStatCollector::get_level 0 2 60 61 193</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current level value of the given collector in the main thread.</span>
 <span class="s0">* This implicitly calls flush_level().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the current level value of the given collector.</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">inline double PStatCollector::get_level(void);</span>
<span class="s0">inline double PStatCollector::get_level(PStatThread const &amp;thread);</span>

<span class="s0">112 18 clear_thread_level 0 4 147 34 PStatCollector::clear_thread_level 0 1 62 178</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the level setting associated with this collector for the current</span>
 <span class="s0">* thread.  The collector will no longer show up on any level graphs in the</span>
 <span class="s0">* current thread.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void PStatCollector::clear_thread_level(void);</span>

<span class="s0">113 16 set_thread_level 0 4 147 32 PStatCollector::set_thread_level 0 1 63 114</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the level setting associated with this collector for the current</span>
 <span class="s0">* thread to the indicated value.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void PStatCollector::set_thread_level(double level);</span>

<span class="s0">114 16 add_thread_level 0 4 147 32 PStatCollector::add_thread_level 0 1 64 251</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated increment (which may be negative) to the level setting</span>
 <span class="s0">* associated with this collector for the current thread.  If the collector</span>
 <span class="s0">* did not already have a level setting for the current thread, it is</span>
 <span class="s0">* initialized to 0.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void PStatCollector::add_thread_level(double increment);</span>

<span class="s0">115 16 sub_thread_level 0 4 147 32 PStatCollector::sub_thread_level 0 1 65 256</span>
<span class="s0">/**</span>
 <span class="s0">* Subtracts the indicated decrement (which may be negative) to the level</span>
 <span class="s0">* setting associated with this collector for the current thread.  If the</span>
 <span class="s0">* collector did not already have a level setting for the current thread, it</span>
 <span class="s0">* is initialized to 0.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void PStatCollector::sub_thread_level(double decrement);</span>

<span class="s0">116 16 get_thread_level 0 4 147 32 PStatCollector::get_thread_level 0 1 66 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current level value of the given collector in the current</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline double PStatCollector::get_thread_level(void);</span>

<span class="s0">117 9 get_index 0 4 147 25 PStatCollector::get_index 0 1 67 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number of this particular collector within the</span>
 <span class="s0">* PStatClient.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int PStatCollector::get_index(void) const;</span>

<span class="s0">118 15 ~PStatCollector 0 516 147 31 PStatCollector::~PStatCollector 0 0 0</span>
<span class="s0">38</span>
<span class="s0">PStatCollector::~PStatCollector(void);</span>

<span class="s0">119 11 PStatThread 0 260 148 24 PStatThread::PStatThread 0 3 68 69 70 446</span>
<span class="s0">/**</span>
 <span class="s0">* Normally, this constructor is called only from PStatClient.  Use one of the</span>
 <span class="s0">* constructors below to create your own Thread.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Normally, this constructor is called only from PStatClient.  Use one of the</span>
 <span class="s0">* constructors below to create your own Thread.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a new named thread.  This will be used to unify tasks that share a</span>
 <span class="s0">* common thread, and differentiate tasks that occur in different threads.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">202</span>
<span class="s0">inline PStatThread::PStatThread(PStatClient *client, int index);</span>
<span class="s0">inline PStatThread::PStatThread(Thread *thread, PStatClient *client = nullptr);</span>
<span class="s0">inline PStatThread::PStatThread(PStatThread const &amp;copy);</span>

<span class="s0">120 10 operator = 0 4 148 23 PStatThread::operator = 0 1 71 0</span>
<span class="s0">61</span>
<span class="s0">inline void PStatThread::operator =(PStatThread const &amp;copy);</span>

<span class="s0">121 9 new_frame 0 4 148 22 PStatThread::new_frame 0 1 72 327</span>
<span class="s0">/**</span>
 <span class="s0">* This must be called at the start of every &quot;frame&quot;, whatever a frame may be</span>
 <span class="s0">* deemed to be, to accumulate all the stats that have collected so far for</span>
 <span class="s0">* the thread and ship them off to the server.</span>
 <span class="s0">*</span>
 <span class="s0">* Calling PStatClient::thread_tick() will automatically call this for any</span>
 <span class="s0">* threads with the indicated sync name.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">void PStatThread::new_frame(void);</span>

<span class="s0">122 9 add_frame 0 4 148 22 PStatThread::add_frame 0 1 73 118</span>
<span class="s0">/**</span>
 <span class="s0">* This is a slightly lower-level version of new_frame that also specifies the</span>
 <span class="s0">* data to send for this frame.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">void PStatThread::add_frame(PStatFrameData const &amp;frame_data);</span>

<span class="s0">123 10 get_thread 0 4 148 23 PStatThread::get_thread 0 1 74 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Panda Thread object associated with this particular</span>
 <span class="s0">* PStatThread.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">Thread *PStatThread::get_thread(void) const;</span>

<span class="s0">124 9 get_index 0 4 148 22 PStatThread::get_index 0 1 75 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number of this particular thread within the PStatClient.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline int PStatThread::get_index(void) const;</span>

<span class="s0">125 12 ~PStatThread 0 516 148 25 PStatThread::~PStatThread 0 0 0</span>
<span class="s0">32</span>
<span class="s0">PStatThread::~PStatThread(void);</span>

<span class="s0">126 7 connect 0 4 141 20 PStatClient::connect 0 1 18 125</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to establish a connection to the indicated PStatServer.  Returns</span>
 <span class="s0">* true if successful, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">static inline bool PStatClient::connect(std::string const &amp;hostname = string(), int port = -1);</span>

<span class="s0">127 10 disconnect 0 4 141 23 PStatClient::disconnect 0 1 19 56</span>
<span class="s0">/**</span>
 <span class="s0">* Closes the connection previously established.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">static inline void PStatClient::disconnect(void);</span>

<span class="s0">128 12 is_connected 0 4 141 25 PStatClient::is_connected 0 1 20 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the client believes it is connected to a working</span>
 <span class="s0">* PStatServer, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">static inline bool PStatClient::is_connected(void);</span>

<span class="s0">129 18 resume_after_pause 0 4 141 31 PStatClient::resume_after_pause 0 1 21 209</span>
<span class="s0">/**</span>
 <span class="s0">* Resumes the PStatClient after the simulation has been paused for a while.</span>
 <span class="s0">* This allows the stats to continue exactly where it left off, instead of</span>
 <span class="s0">* leaving a big gap that would represent a chug.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline void PStatClient::resume_after_pause(void);</span>

<span class="s0">130 9 main_tick 0 4 141 22 PStatClient::main_tick 0 1 22 147</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to call new_frame() on the global PStatClient's main</span>
 <span class="s0">* thread, and any other threads with a sync_name of &quot;Main&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">static void PStatClient::main_tick(void);</span>

<span class="s0">131 11 thread_tick 0 4 141 24 PStatClient::thread_tick 0 1 23 100</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to call new_frame() on any threads with the</span>
 <span class="s0">* indicated sync_name</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">static void PStatClient::thread_tick(std::string const &amp;sync_name);</span>

<span class="s0">132 16 client_main_tick 0 4 141 29 PStatClient::client_main_tick 0 1 24 146</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to call new_frame() on the given PStatClient's main</span>
 <span class="s0">* thread, and any other threads with a sync_name of &quot;Main&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">void PStatClient::client_main_tick(void);</span>

<span class="s0">133 18 client_thread_tick 0 4 141 31 PStatClient::client_thread_tick 0 1 25 108</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function to call new_frame() on all of the threads with the</span>
 <span class="s0">* indicated sync name.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">void PStatClient::client_thread_tick(std::string const &amp;sync_name);</span>

<span class="s0">134 14 client_connect 0 4 141 27 PStatClient::client_connect 0 1 26 53</span>
<span class="s0">/**</span>
 <span class="s0">* The nonstatic implementation of connect().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool PStatClient::client_connect(std::string hostname, int port);</span>

<span class="s0">135 17 client_disconnect 0 4 141 30 PStatClient::client_disconnect 0 1 27 56</span>
<span class="s0">/**</span>
 <span class="s0">* The nonstatic implementation of disconnect().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void PStatClient::client_disconnect(void);</span>

<span class="s0">136 19 client_is_connected 0 4 141 32 PStatClient::client_is_connected 0 1 28 58</span>
<span class="s0">/**</span>
 <span class="s0">* The nonstatic implementation of is_connected().</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">bool PStatClient::client_is_connected(void) const;</span>

<span class="s0">137 25 client_resume_after_pause 0 4 141 38 PStatClient::client_resume_after_pause 0 1 29 209</span>
<span class="s0">/**</span>
 <span class="s0">* Resumes the PStatClient after the simulation has been paused for a while.</span>
 <span class="s0">* This allows the stats to continue exactly where it left off, instead of</span>
 <span class="s0">* leaving a big gap that would represent a chug.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void PStatClient::client_resume_after_pause(void);</span>

<span class="s0">138 17 get_global_pstats 0 4 141 30 PStatClient::get_global_pstats 0 1 30 225</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the global PStatClient object.  It's legal to declare</span>
 <span class="s0">* your own PStatClient locally, but it's also convenient to have a global one</span>
 <span class="s0">* that everyone can register with.  This is the global one.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static PStatClient *PStatClient::get_global_pstats(void);</span>

<span class="s0">139 21 PStatCollectorForward 0 260 151 44 PStatCollectorForward::PStatCollectorForward 0 1 76 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline PStatCollectorForward::PStatCollectorForward(PStatCollector const &amp;col);</span>

<span class="s0">140 22 ~PStatCollectorForward 0 516 151 45 PStatCollectorForward::~PStatCollectorForward 0 0 0</span>
<span class="s0">52</span>
<span class="s0">PStatCollectorForward::~PStatCollectorForward(void);</span>

<span class="s0">76</span>
<span class="s0">1 0 0 4 4 155 0 0 143 /**</span>
 <span class="s0">* Sets the name of the client.  This is reported to the PStatsServer, and</span>
 <span class="s0">* will presumably be written in the title bar or something.</span>
 <span class="s0">*/ 2 4 this 3 153  4 name 1 154  </span>
<span class="s0">2 0 0 6 5 154 0 0 51 /**</span>
 <span class="s0">* Retrieves the name of the client as set.</span>
 <span class="s0">*/ 1 4 this 3 156  </span>
<span class="s0">3 0 0 4 6 155 0 0 469 /**</span>
 <span class="s0">* Controls the number of packets that will be sent to the server.  Normally,</span>
 <span class="s0">* one packet is sent per frame, but this can flood the server with more</span>
 <span class="s0">* packets than it can handle if the frame rate is especially good (e.g.  if</span>
 <span class="s0">* nothing is onscreen at the moment).  Set this parameter to a reasonable</span>
 <span class="s0">* number to prevent this from happening.</span>
 <span class="s0">*</span>
 <span class="s0">* This number specifies the maximum number of packets that will be sent to</span>
 <span class="s0">* the server per second, per thread.</span>
 <span class="s0">*/ 2 4 this 3 153  4 rate 1 146  </span>
<span class="s0">4 0 0 6 7 146 0 0 128 /**</span>
 <span class="s0">* Returns the maximum number of packets that will be sent to the server per</span>
 <span class="s0">* second, per thread.  See set_max_rate().</span>
 <span class="s0">*/ 1 4 this 3 156  </span>
<span class="s0">5 0 0 6 8 150 0 0 73 /**</span>
 <span class="s0">* Returns the total number of collectors the Client knows about.</span>
 <span class="s0">*/ 1 4 this 3 156  </span>
<span class="s0">6 0 0 7 9 158 118 0 37 /**</span>
 <span class="s0">* Returns the nth collector.</span>
 <span class="s0">*/ 2 4 this 3 156  5 index 1 150  </span>
<span class="s0">7 0 0 6 11 159 0 0 60 /**</span>
 <span class="s0">* Returns the definition body of the nth collector.</span>
 <span class="s0">*/ 2 4 this 3 156  5 index 1 150  </span>
<span class="s0">8 0 0 6 12 154 0 0 55 /**</span>
 <span class="s0">* Returns the name of the indicated collector.</span>
 <span class="s0">*/ 2 4 this 3 156  5 index 1 150  </span>
<span class="s0">9 0 0 6 13 154 0 0 186 /**</span>
 <span class="s0">* Returns the &quot;full name&quot; of the indicated collector.  This will be the</span>
 <span class="s0">* concatenation of all of the collector's parents' names (except Frame) and</span>
 <span class="s0">* the collector's own name.</span>
 <span class="s0">*/ 2 4 this 3 156  5 index 1 150  </span>
<span class="s0">10 0 0 6 14 150 0 0 70 /**</span>
 <span class="s0">* Returns the total number of threads the Client knows about.</span>
 <span class="s0">*/ 1 4 this 3 156  </span>
<span class="s0">11 0 0 7 15 161 125 0 34 /**</span>
 <span class="s0">* Returns the nth thread.</span>
 <span class="s0">*/ 2 4 this 3 156  5 index 1 150  </span>
<span class="s0">12 0 0 6 17 154 0 0 52 /**</span>
 <span class="s0">* Returns the name of the indicated thread.</span>
 <span class="s0">*/ 2 4 this 3 156  5 index 1 150  </span>
<span class="s0">13 0 0 6 18 154 0 0 57 /**</span>
 <span class="s0">* Returns the sync_name of the indicated thread.</span>
 <span class="s0">*/ 2 4 this 3 156  5 index 1 150  </span>
<span class="s0">14 0 0 7 19 149 0 0 85 /**</span>
 <span class="s0">* Returns the Panda Thread object associated with the indicated PStatThread.</span>
 <span class="s0">*/ 2 4 this 3 156  5 index 1 150  </span>
<span class="s0">15 0 0 7 20 161 125 0 109 /**</span>
 <span class="s0">* Returns a handle to the client's Main thread.  This is the thread that</span>
 <span class="s0">* started the application.</span>
 <span class="s0">*/ 1 4 this 3 156  </span>
<span class="s0">16 0 0 7 21 161 125 0 159 /**</span>
 <span class="s0">* Returns a handle to the currently-executing thread.  This is the thread</span>
 <span class="s0">* that PStatCollectors will be counted in if they do not specify otherwise.</span>
 <span class="s0">*/ 1 4 this 3 156  </span>
<span class="s0">17 0 0 6 22 146 0 0 248 /**</span>
 <span class="s0">* Returns the time according to to the PStatClient's clock object.  It keeps</span>
 <span class="s0">* its own clock, instead of using the global clock object, so the stats won't</span>
 <span class="s0">* get mucked up if you put the global clock in non-real-time mode or</span>
 <span class="s0">* something.</span>
 <span class="s0">*/ 1 4 this 3 156  </span>
<span class="s0">18 0 0 38 71 162 0 0 125 /**</span>
 <span class="s0">* Attempts to establish a connection to the indicated PStatServer.  Returns</span>
 <span class="s0">* true if successful, false on failure.</span>
 <span class="s0">*/ 2 8 hostname 5 154  4 port 5 150  </span>
<span class="s0">19 0 0 36 72 155 0 0 56 /**</span>
 <span class="s0">* Closes the connection previously established.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">20 0 0 6 73 162 0 0 108 /**</span>
 <span class="s0">* Returns true if the client believes it is connected to a working</span>
 <span class="s0">* PStatServer, false otherwise.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">21 0 0 4 74 155 0 0 209 /**</span>
 <span class="s0">* Resumes the PStatClient after the simulation has been paused for a while.</span>
 <span class="s0">* This allows the stats to continue exactly where it left off, instead of</span>
 <span class="s0">* leaving a big gap that would represent a chug.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">22 0 0 4 75 155 0 0 147 /**</span>
 <span class="s0">* A convenience function to call new_frame() on the global PStatClient's main</span>
 <span class="s0">* thread, and any other threads with a sync_name of &quot;Main&quot;.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">23 0 0 4 76 155 0 0 100 /**</span>
 <span class="s0">* A convenience function to call new_frame() on any threads with the</span>
 <span class="s0">* indicated sync_name</span>
 <span class="s0">*/ 1 9 sync_name 1 154  </span>
<span class="s0">24 0 0 4 77 155 0 0 146 /**</span>
 <span class="s0">* A convenience function to call new_frame() on the given PStatClient's main</span>
 <span class="s0">* thread, and any other threads with a sync_name of &quot;Main&quot;.</span>
 <span class="s0">*/ 1 4 this 3 153  </span>
<span class="s0">25 0 0 4 78 155 0 0 108 /**</span>
 <span class="s0">* A convenience function to call new_frame() on all of the threads with the</span>
 <span class="s0">* indicated sync name.</span>
 <span class="s0">*/ 2 4 this 3 153  9 sync_name 1 154  </span>
<span class="s0">26 0 0 38 79 162 0 0 53 /**</span>
 <span class="s0">* The nonstatic implementation of connect().</span>
 <span class="s0">*/ 3 4 this 3 153  8 hostname 1 154  4 port 1 150  </span>
<span class="s0">27 0 0 36 80 155 0 0 56 /**</span>
 <span class="s0">* The nonstatic implementation of disconnect().</span>
 <span class="s0">*/ 1 4 this 3 153  </span>
<span class="s0">28 0 0 6 81 162 0 0 58 /**</span>
 <span class="s0">* The nonstatic implementation of is_connected().</span>
 <span class="s0">*/ 1 4 this 3 156  </span>
<span class="s0">29 0 0 4 82 155 0 0 209 /**</span>
 <span class="s0">* Resumes the PStatClient after the simulation has been paused for a while.</span>
 <span class="s0">* This allows the stats to continue exactly where it left off, instead of</span>
 <span class="s0">* leaving a big gap that would represent a chug.</span>
 <span class="s0">*/ 1 4 this 3 153  </span>
<span class="s0">30 0 0 6 83 153 0 0 225 /**</span>
 <span class="s0">* Returns a pointer to the global PStatClient object.  It's legal to declare</span>
 <span class="s0">* your own PStatClient locally, but it's also convenient to have a global one</span>
 <span class="s0">* that everyone can register with.  This is the global one.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">31 0 0 15 30 158 118 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 163  </span>
<span class="s0">32 0 0 7 30 158 118 0 848 /**</span>
 <span class="s0">* Creates a new PStatCollector, ready to start accumulating data.  The name</span>
 <span class="s0">* of the collector uniquely identifies it among the other collectors; if two</span>
 <span class="s0">* collectors share the same name then they are really the same collector.</span>
 <span class="s0">*</span>
 <span class="s0">* The parent is the collector that conceptually includes all of the time</span>
 <span class="s0">* measured for this collector.  For instance, a particular character's</span>
 <span class="s0">* animation time is owned by the &quot;Animation&quot; collector, which is in turn</span>
 <span class="s0">* owned by the &quot;Frame&quot; collector.  It is not strictly necessary that all of</span>
 <span class="s0">* the time spent in a particular collector is completely nested within time</span>
 <span class="s0">* spent in its parent's collector.  If parent is the empty string, the</span>
 <span class="s0">* collector is owned by &quot;Frame&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* This constructor does not take a client pointer; it always creates the new</span>
 <span class="s0">* collector on the same client as its parent.</span>
 <span class="s0">*/ 2 6 parent 1 163  4 name 1 154  </span>
<span class="s0">33 0 0 7 30 158 118 0 706 /**</span>
 <span class="s0">* Creates a new PStatCollector, ready to start accumulating data.  The name</span>
 <span class="s0">* of the collector uniquely identifies it among the other collectors; if two</span>
 <span class="s0">* collectors share the same name then they are really the same collector.</span>
 <span class="s0">*</span>
 <span class="s0">* The name may also be a compound name, something like &quot;Cull:Sort&quot;, which</span>
 <span class="s0">* indicates that this is a collector named &quot;Sort&quot;, a child of the collector</span>
 <span class="s0">* named &quot;Cull&quot;. The parent may also be named explicitly by reference in the</span>
 <span class="s0">* other flavor of the constructor; see further comments on this for that</span>
 <span class="s0">* constructor.</span>
 <span class="s0">*</span>
 <span class="s0">* If the client pointer is non-null, it specifies a particular client to</span>
 <span class="s0">* register the collector with; otherwise, the global client is used.</span>
 <span class="s0">*/ 2 4 name 1 154  6 client 5 153  </span>
<span class="s0">34 0 0 6 31 158 0 0 0 2 4 this 3 158  4 copy 1 163  </span>
<span class="s0">35 0 0 6 32 162 0 0 178 /**</span>
 <span class="s0">* Returns true if collector is valid and may be used, or false if it was</span>
 <span class="s0">* constructed with the default constructor (in which case any attempt to use</span>
 <span class="s0">* it will crash).</span>
 <span class="s0">*/ 1 4 this 3 163  </span>
<span class="s0">36 0 0 6 33 154 0 0 127 /**</span>
 <span class="s0">* Returns the local name of this collector.  This is the rightmost part of</span>
 <span class="s0">* the fullname, after the rightmost colon.</span>
 <span class="s0">*/ 1 4 this 3 163  </span>
<span class="s0">37 0 0 6 34 154 0 0 146 /**</span>
 <span class="s0">* Returns the full name of this collector.  This includes the names of all</span>
 <span class="s0">* the collector's parents, concatenated together with colons.</span>
 <span class="s0">*/ 1 4 this 3 163  </span>
<span class="s0">38 0 0 4 35 155 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 163  3 out 1 165  </span>
<span class="s0">39 0 0 6 36 162 0 0 135 /**</span>
 <span class="s0">* Returns true if this particular collector is active on the default thread,</span>
 <span class="s0">* and we are currently transmitting PStats data.</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">40 0 0 6 36 162 0 0 137 /**</span>
 <span class="s0">* Returns true if this particular collector is active on the indicated</span>
 <span class="s0">* thread, and we are currently transmitting PStats data.</span>
 <span class="s0">*/ 2 4 this 3 158  6 thread 1 167  </span>
<span class="s0">41 0 0 6 37 162 0 0 115 /**</span>
 <span class="s0">* Returns true if this particular collector has been started on the default</span>
 <span class="s0">* thread, or false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">42 0 0 6 37 162 0 0 117 /**</span>
 <span class="s0">* Returns true if this particular collector has been started on the indicated</span>
 <span class="s0">* thread, or false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 158  6 thread 1 167  </span>
<span class="s0">43 0 0 4 38 155 0 0 111 /**</span>
 <span class="s0">* Starts this particular timer ticking.  This should be called before the</span>
 <span class="s0">* code you want to measure.</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">44 0 0 4 38 155 0 0 64 /**</span>
 <span class="s0">* Starts this timer ticking within a particular thread.</span>
 <span class="s0">*/ 2 4 this 3 158  6 thread 1 167  </span>
<span class="s0">45 0 0 4 38 155 0 0 279 /**</span>
 <span class="s0">* Marks that the timer should have been started as of the indicated time.</span>
 <span class="s0">* This must be a time based on the PStatClient's clock (see</span>
 <span class="s0">* PStatClient::get_clock()), and care should be taken that all such calls</span>
 <span class="s0">* exhibit a monotonically increasing series of time values.</span>
 <span class="s0">*/ 3 4 this 3 158  6 thread 1 167  5 as_of 1 146  </span>
<span class="s0">46 0 0 4 39 155 0 0 90 /**</span>
 <span class="s0">* Stops this timer.  This should be called after the code you want to</span>
 <span class="s0">* measure.</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">47 0 0 4 39 155 0 0 55 /**</span>
 <span class="s0">* Stops this timer within a particular thread.</span>
 <span class="s0">*/ 2 4 this 3 158  6 thread 1 167  </span>
<span class="s0">48 0 0 4 39 155 0 0 279 /**</span>
 <span class="s0">* Marks that the timer should have been stopped as of the indicated time.</span>
 <span class="s0">* This must be a time based on the PStatClient's clock (see</span>
 <span class="s0">* PStatClient::get_clock()), and care should be taken that all such calls</span>
 <span class="s0">* exhibit a monotonically increasing series of time values.</span>
 <span class="s0">*/ 3 4 this 3 158  6 thread 1 167  5 as_of 1 146  </span>
<span class="s0">49 0 0 4 40 155 0 0 210 /**</span>
 <span class="s0">* Removes the level setting associated with this collector for the main</span>
 <span class="s0">* thread.  The collector will no longer show up on any level graphs in the</span>
 <span class="s0">* main thread.  This implicitly calls flush_level().</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">50 0 0 4 40 155 0 0 173 /**</span>
 <span class="s0">* Removes the level setting associated with this collector for the indicated</span>
 <span class="s0">* thread.  The collector will no longer show up on any level graphs in this</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/ 2 4 this 3 158  6 thread 1 167  </span>
<span class="s0">51 0 0 4 41 155 0 0 116 /**</span>
 <span class="s0">* Sets the level setting associated with this collector for the indicated</span>
 <span class="s0">* thread to the indicated value.</span>
 <span class="s0">*/ 3 4 this 3 158  6 thread 1 167  5 level 1 146  </span>
<span class="s0">52 0 0 4 41 155 0 0 149 /**</span>
 <span class="s0">* Sets the level setting associated with this collector for the main thread</span>
 <span class="s0">* to the indicated value.  This implicitly calls flush_level().</span>
 <span class="s0">*/ 2 4 this 3 158  5 level 1 146  </span>
<span class="s0">53 0 0 4 42 155 0 0 246 /**</span>
 <span class="s0">* Adds the indicated increment (which may be negative) to the level setting</span>
 <span class="s0">* associated with this collector for the indicated thread.  If the collector</span>
 <span class="s0">* did not already have a level setting for this thread, it is initialized to</span>
 <span class="s0">* 0.</span>
 <span class="s0">*/ 3 4 this 3 158  6 thread 1 167  9 increment 1 146  </span>
<span class="s0">54 0 0 4 42 155 0 0 382 /**</span>
 <span class="s0">* Adds the indicated increment (which may be negative) to the level setting</span>
 <span class="s0">* associated with this collector for the main thread.  If the collector did</span>
 <span class="s0">* not already have a level setting for the main thread, it is initialized to</span>
 <span class="s0">* 0.</span>
 <span class="s0">*</span>
 <span class="s0">* As an optimization, the data is not immediately set to the PStatClient.  It</span>
 <span class="s0">* will be sent the next time flush_level() is called.</span>
 <span class="s0">*/ 2 4 this 3 158  9 increment 1 146  </span>
<span class="s0">55 0 0 4 43 155 0 0 251 /**</span>
 <span class="s0">* Subtracts the indicated decrement (which may be negative) to the level</span>
 <span class="s0">* setting associated with this collector for the indicated thread.  If the</span>
 <span class="s0">* collector did not already have a level setting for this thread, it is</span>
 <span class="s0">* initialized to 0.</span>
 <span class="s0">*/ 3 4 this 3 158  6 thread 1 167  9 decrement 1 146  </span>
<span class="s0">56 0 0 4 43 155 0 0 387 /**</span>
 <span class="s0">* Subtracts the indicated decrement (which may be negative) to the level</span>
 <span class="s0">* setting associated with this collector for the main thread.  If the</span>
 <span class="s0">* collector did not already have a level setting for the main thread, it is</span>
 <span class="s0">* initialized to 0.</span>
 <span class="s0">*</span>
 <span class="s0">* As an optimization, the data is not immediately set to the PStatClient.  It</span>
 <span class="s0">* will be sent the next time flush_level() is called.</span>
 <span class="s0">*/ 2 4 this 3 158  9 decrement 1 146  </span>
<span class="s0">57 0 0 4 44 155 0 0 65 /**</span>
 <span class="s0">* Calls add_level() and immediately calls flush_level().</span>
 <span class="s0">*/ 2 4 this 3 158  9 increment 1 146  </span>
<span class="s0">58 0 0 4 45 155 0 0 65 /**</span>
 <span class="s0">* Calls sub_level() and immediately calls flush_level().</span>
 <span class="s0">*/ 2 4 this 3 158  9 decrement 1 146  </span>
<span class="s0">59 0 0 4 46 155 0 0 95 /**</span>
 <span class="s0">* Updates the PStatClient with the recent results from add_level() and</span>
 <span class="s0">* sub_level().</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">60 0 0 6 47 146 0 0 125 /**</span>
 <span class="s0">* Returns the current level value of the given collector in the main thread.</span>
 <span class="s0">* This implicitly calls flush_level().</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">61 0 0 6 47 146 0 0 66 /**</span>
 <span class="s0">* Returns the current level value of the given collector.</span>
 <span class="s0">*/ 2 4 this 3 158  6 thread 1 167  </span>
<span class="s0">62 0 0 4 48 155 0 0 178 /**</span>
 <span class="s0">* Removes the level setting associated with this collector for the current</span>
 <span class="s0">* thread.  The collector will no longer show up on any level graphs in the</span>
 <span class="s0">* current thread.</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">63 0 0 4 49 155 0 0 114 /**</span>
 <span class="s0">* Sets the level setting associated with this collector for the current</span>
 <span class="s0">* thread to the indicated value.</span>
 <span class="s0">*/ 2 4 this 3 158  5 level 1 146  </span>
<span class="s0">64 0 0 4 50 155 0 0 251 /**</span>
 <span class="s0">* Adds the indicated increment (which may be negative) to the level setting</span>
 <span class="s0">* associated with this collector for the current thread.  If the collector</span>
 <span class="s0">* did not already have a level setting for the current thread, it is</span>
 <span class="s0">* initialized to 0.</span>
 <span class="s0">*/ 2 4 this 3 158  9 increment 1 146  </span>
<span class="s0">65 0 0 4 51 155 0 0 256 /**</span>
 <span class="s0">* Subtracts the indicated decrement (which may be negative) to the level</span>
 <span class="s0">* setting associated with this collector for the current thread.  If the</span>
 <span class="s0">* collector did not already have a level setting for the current thread, it</span>
 <span class="s0">* is initialized to 0.</span>
 <span class="s0">*/ 2 4 this 3 158  9 decrement 1 146  </span>
<span class="s0">66 0 0 6 52 146 0 0 91 /**</span>
 <span class="s0">* Returns the current level value of the given collector in the current</span>
 <span class="s0">* thread.</span>
 <span class="s0">*/ 1 4 this 3 158  </span>
<span class="s0">67 0 0 6 53 150 0 0 91 /**</span>
 <span class="s0">* Returns the index number of this particular collector within the</span>
 <span class="s0">* PStatClient.</span>
 <span class="s0">*/ 1 4 this 3 163  </span>
<span class="s0">68 0 0 23 57 161 125 0 135 /**</span>
 <span class="s0">* Normally, this constructor is called only from PStatClient.  Use one of the</span>
 <span class="s0">* constructors below to create your own Thread.</span>
 <span class="s0">*/ 2 6 client 1 153  5 index 1 150  </span>
<span class="s0">69 0 0 15 57 161 125 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 167  </span>
<span class="s0">70 0 0 23 57 161 125 0 160 /**</span>
 <span class="s0">* Creates a new named thread.  This will be used to unify tasks that share a</span>
 <span class="s0">* common thread, and differentiate tasks that occur in different threads.</span>
 <span class="s0">*/ 2 6 thread 1 149  6 client 5 153  </span>
<span class="s0">71 0 0 6 58 161 0 0 0 2 4 this 3 161  4 copy 1 167  </span>
<span class="s0">72 0 0 4 59 155 0 0 327 /**</span>
 <span class="s0">* This must be called at the start of every &quot;frame&quot;, whatever a frame may be</span>
 <span class="s0">* deemed to be, to accumulate all the stats that have collected so far for</span>
 <span class="s0">* the thread and ship them off to the server.</span>
 <span class="s0">*</span>
 <span class="s0">* Calling PStatClient::thread_tick() will automatically call this for any</span>
 <span class="s0">* threads with the indicated sync name.</span>
 <span class="s0">*/ 1 4 this 3 161  </span>
<span class="s0">73 0 0 4 60 155 0 0 118 /**</span>
 <span class="s0">* This is a slightly lower-level version of new_frame that also specifies the</span>
 <span class="s0">* data to send for this frame.</span>
 <span class="s0">*/ 2 4 this 3 161  10 frame_data 1 169  </span>
<span class="s0">74 0 0 7 61 149 0 0 90 /**</span>
 <span class="s0">* Returns the Panda Thread object associated with this particular</span>
 <span class="s0">* PStatThread.</span>
 <span class="s0">*/ 1 4 this 3 167  </span>
<span class="s0">75 0 0 6 62 150 0 0 85 /**</span>
 <span class="s0">* Returns the index number of this particular thread within the PStatClient.</span>
 <span class="s0">*/ 1 4 this 3 167  </span>
<span class="s0">76 0 0 23 86 172 140 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 3 col 1 163  </span>
<span class="s0">32</span>
<span class="s0">141 11 PStatClient 0 75777 11 PStatClient 11 PStatClient 0 0 0 0 0 7 173 174 175 176 179 180 181 30 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 126 127 128 129 130 131 132 133 134 135 136 137 138 2 182 183 0 1 0 142 0 0 0 0 0</span>

<span class="s0">142 14 PStatsCallback 0 264192 22 Thread::PStatsCallback 22 Thread::PStatsCallback 143 0 0 0 0 0 0 0 0 0 0 0 89</span>
<span class="s0">// This class allows integration with PStats, particularly in the</span>
<span class="s0">// SIMPLE_THREADS case.</span>

<span class="s0">143 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 396</span>
<span class="s0">/**</span>
 <span class="s0">* A thread; that is, a lightweight process.  This is an abstract base class;</span>
 <span class="s0">* to use it, you must subclass from it and redefine thread_main().</span>
 <span class="s0">*</span>
 <span class="s0">* The thread itself will keep a reference count on the Thread object while it</span>
 <span class="s0">* is running; when the thread returns from its root function, the Thread</span>
 <span class="s0">* object will automatically be destructed if no other pointers are</span>
 <span class="s0">* referencing it.</span>
 <span class="s0">*/</span>

<span class="s0">144 6 string 0 2105344 11 std::string 11 std::string 0 0 145 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">145 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">146 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">147 14 PStatCollector 0 141313 14 PStatCollector 14 PStatCollector 0 0 0 1 94 118 0 23 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 0 0 0 0 0 900</span>
<span class="s0">/**</span>
 <span class="s0">* A lightweight class that represents a single element that may be timed</span>
 <span class="s0">* and/or counted via stats.</span>
 <span class="s0">*</span>
 <span class="s0">* Collectors can be used to measure two different kinds of values: elapsed</span>
 <span class="s0">* time, and &quot;other&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* To measure elapsed time, call start() and stop() as appropriate to bracket</span>
 <span class="s0">* the section of code you want to time (or use a PStatTimer to do this</span>
 <span class="s0">* automatically).</span>
 <span class="s0">*</span>
 <span class="s0">* To measure anything else, call set_level() and/or add_level() to set the</span>
 <span class="s0">* &quot;level&quot; value associated with this collector.  The meaning of the value set</span>
 <span class="s0">* for the &quot;level&quot; is entirely up to the user; it may represent the number of</span>
 <span class="s0">* triangles rendered or the kilobytes of texture memory consumed, for</span>
 <span class="s0">* instance.  The level set will remain fixed across multiple frames until it</span>
 <span class="s0">* is reset via another set_level() or adjusted via a call to add_level().  It</span>
 <span class="s0">* may also be completely removed via clear_level().</span>
 <span class="s0">*/</span>

<span class="s0">148 11 PStatThread 0 141313 11 PStatThread 11 PStatThread 0 0 0 1 119 125 2 177 178 5 120 121 122 123 124 0 0 0 0 0 145</span>
<span class="s0">/**</span>
 <span class="s0">* A lightweight class that represents a single thread of execution to PStats.</span>
 <span class="s0">* It corresponds one-to-one with Panda's Thread instance.</span>
 <span class="s0">*/</span>

<span class="s0">149 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 143 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">150 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">151 21 PStatCollectorForward 0 141313 21 PStatCollectorForward 21 PStatCollectorForward 0 0 0 1 139 140 0 0 0 0 1 0 152 0 0 0 0 173</span>
<span class="s0">/**</span>
 <span class="s0">* This class serves as a cheap forward reference to a PStatCollector, so that</span>
 <span class="s0">* classes that are defined before the pstats module may access the</span>
 <span class="s0">* PStatCollector.</span>
 <span class="s0">*/</span>

<span class="s0">152 25 PStatCollectorForwardBase 0 2048 25 PStatCollectorForwardBase 25 PStatCollectorForwardBase 0 0 0 0 0 0 0 0 0 0 0 0 282</span>
<span class="s0">/**</span>
 <span class="s0">* This class serves as a cheap forward reference to a PStatCollector, which</span>
 <span class="s0">* is defined in the pstatclient module (and is not directly accessible here</span>
 <span class="s0">* in the express module).</span>
 <span class="s0">*</span>
 <span class="s0">* This is subclassed as PStatCollectorForward, which defines the actual</span>
 <span class="s0">* functionality.</span>
 <span class="s0">*/</span>

<span class="s0">153 13 PStatClient * 0 8576 13 PStatClient * 13 PStatClient * 0 0 141 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">154 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">155 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">156 19 PStatClient const * 0 8576 19 PStatClient const * 19 PStatClient const * 0 0 157 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">157 17 PStatClient const 0 8832 17 PStatClient const 17 PStatClient const 0 0 141 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">158 16 PStatCollector * 0 8576 16 PStatCollector * 16 PStatCollector * 0 0 147 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">159 19 PStatCollectorDef * 0 8576 19 PStatCollectorDef * 19 PStatCollectorDef * 0 0 160 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">160 17 PStatCollectorDef 0 1050624 17 PStatCollectorDef 17 PStatCollectorDef 0 0 0 0 0 0 0 0 0 0 0 0 91</span>
<span class="s0">/**</span>
 <span class="s0">* Defines the details about the Collectors: the name, the suggested color,</span>
 <span class="s0">* etc.</span>
 <span class="s0">*/</span>

<span class="s0">161 13 PStatThread * 0 8576 13 PStatThread * 13 PStatThread * 0 0 148 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">162 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">163 22 PStatCollector const * 0 8576 22 PStatCollector const * 22 PStatCollector const * 0 0 164 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">164 20 PStatCollector const 0 8832 20 PStatCollector const 20 PStatCollector const 0 0 147 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">165 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 166 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">166 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">167 19 PStatThread const * 0 8576 19 PStatThread const * 19 PStatThread const * 0 0 168 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">168 17 PStatThread const 0 8832 17 PStatThread const 17 PStatThread const 0 0 148 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">169 22 PStatFrameData const * 0 8576 22 PStatFrameData const * 22 PStatFrameData const * 0 0 170 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">170 20 PStatFrameData const 0 8832 20 PStatFrameData const 20 PStatFrameData const 0 0 171 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">171 14 PStatFrameData 0 1050624 14 PStatFrameData 14 PStatFrameData 0 0 0 0 0 0 0 0 0 0 0 0 215</span>
<span class="s0">/**</span>
 <span class="s0">* Contains the raw timing and level data for a single frame.  This is a</span>
 <span class="s0">* sequence of start/stop events, as well as a table of level values,</span>
 <span class="s0">* associated with a number of collectors within a single frame.</span>
 <span class="s0">*/</span>

<span class="s0">172 23 PStatCollectorForward * 0 8576 23 PStatCollectorForward * 23 PStatCollectorForward * 0 0 151 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">9</span>
<span class="s0">173 11 client_name 0 6 144 78 77 0 0 0 0 0 0 24 PStatClient::client_name 0</span>

<span class="s0">174 8 max_rate 0 6 146 80 79 0 0 0 0 0 0 21 PStatClient::max_rate 0</span>

<span class="s0">175 10 collectors 0 66 147 82 0 0 0 0 81 0 0 23 PStatClient::collectors 0</span>

<span class="s0">176 7 threads 0 66 148 87 0 0 0 0 86 0 0 20 PStatClient::threads 0</span>

<span class="s0">177 6 thread 0 2 149 123 0 0 0 0 0 0 0 19 PStatThread::thread 0</span>

<span class="s0">178 5 index 0 2 150 124 0 0 0 0 0 0 0 18 PStatThread::index 0</span>

<span class="s0">179 11 main_thread 0 2 148 91 0 0 0 0 0 0 0 24 PStatClient::main_thread 0</span>

<span class="s0">180 14 current_thread 0 2 148 92 0 0 0 0 0 0 0 27 PStatClient::current_thread 0</span>

<span class="s0">181 9 real_time 0 2 146 93 0 0 0 0 0 0 0 22 PStatClient::real_time 0</span>

<span class="s0">2</span>
<span class="s0">182 14 get_collectors 0 81 82 27 PStatClient::get_collectors 0</span>

<span class="s0">183 11 get_threads 0 86 87 24 PStatClient::get_threads 0</span>

</pre>
</body>
</html>