<html>
<head>
<title>libp3tform.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3tform.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">10 libp3tform 4 v_mB 12 panda3d.core </span>
<span class="s0">258</span>
<span class="s0">266 13 ButtonThrower 0 260 524 28 ButtonThrower::ButtonThrower 0 2 1 2 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">133</span>
<span class="s0">explicit ButtonThrower::ButtonThrower(std::string const &amp;name);</span>
<span class="s0">inline ButtonThrower::ButtonThrower(ButtonThrower const &amp;) = default;</span>

<span class="s0">267 21 set_button_down_event 0 4 524 36 ButtonThrower::set_button_down_event 0 1 3 510</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the generic event that is generated (if any) each time a key or</span>
 <span class="s0">* button is depressed.  Unlike the specific events that are unique to each</span>
 <span class="s0">* key, this same event name is used for *all* button events, and the name of</span>
 <span class="s0">* the button pressed (possibly with modifier prefixes) will be sent as a</span>
 <span class="s0">* parameter.</span>
 <span class="s0">*</span>
 <span class="s0">* If this string is empty, no event is generated.  It is possible to generate</span>
 <span class="s0">* both generic events and specific events for the same button.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_keystroke_event().</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void ButtonThrower::set_button_down_event(std::string const &amp;button_down_event);</span>

<span class="s0">268 21 get_button_down_event 0 4 524 36 ButtonThrower::get_button_down_event 0 1 4 114</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the button_down_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_button_down_event().</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_button_down_event(void) const;</span>

<span class="s0">269 19 set_button_up_event 0 4 524 34 ButtonThrower::set_button_up_event 0 1 5 137</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the generic event that is generated (if any) each time a key or</span>
 <span class="s0">* button is released.  See set_button_down_event().</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void ButtonThrower::set_button_up_event(std::string const &amp;button_up_event);</span>

<span class="s0">270 19 get_button_up_event 0 4 524 34 ButtonThrower::get_button_up_event 0 1 6 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the button_up_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_button_up_event().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_button_up_event(void) const;</span>

<span class="s0">271 23 set_button_repeat_event 0 4 524 38 ButtonThrower::set_button_repeat_event 0 1 7 517</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the generic event that is generated (if any) repeatedly while a</span>
 <span class="s0">* key or button is held down.  Unlike the specific events that are unique to</span>
 <span class="s0">* each key, this same event name is used for *all* button events, and the</span>
 <span class="s0">* name of the button pressed (possibly with modifier prefixes) will be sent</span>
 <span class="s0">* as a parameter.</span>
 <span class="s0">*</span>
 <span class="s0">* If this string is empty, no event is generated.  It is possible to generate</span>
 <span class="s0">* both generic events and specific events for the same button.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_keystroke_event().</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline void ButtonThrower::set_button_repeat_event(std::string const &amp;button_repeat_event);</span>

<span class="s0">272 23 get_button_repeat_event 0 4 524 38 ButtonThrower::get_button_repeat_event 0 1 8 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the button_repeat_event that has been set on this ButtonThrower.</span>
 <span class="s0">* See set_button_repeat_event().</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_button_repeat_event(void) const;</span>

<span class="s0">273 19 set_keystroke_event 0 4 524 34 ButtonThrower::set_keystroke_event 0 1 9 846</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the event that is generated (if any) for each keystroke that is</span>
 <span class="s0">* received.  A keystroke is different than a button event: it represents the</span>
 <span class="s0">* semantic meaning of the sequence of keys that have been pressed.  For</span>
 <span class="s0">* instance, pressing shift and 4 together will generate the button event</span>
 <span class="s0">* &quot;shift-4&quot;, but it will generate the keystroke &quot;$&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* If a key is held down, keyrepeat will cause the same keystroke event to be</span>
 <span class="s0">* generated repeatedly.  This is different from the corresponding down event,</span>
 <span class="s0">* which will only be generated once, followed by a number of button repeat</span>
 <span class="s0">* events.</span>
 <span class="s0">*</span>
 <span class="s0">* This event is generated with a single wstring parameter, which is a one-</span>
 <span class="s0">* character string that contains the keystroke generated.  If this event</span>
 <span class="s0">* string is empty, no event is generated.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_button_down_event().</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void ButtonThrower::set_keystroke_event(std::string const &amp;keystroke_event);</span>

<span class="s0">274 19 get_keystroke_event 0 4 524 34 ButtonThrower::get_keystroke_event 0 1 10 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the keystroke_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_keystroke_event().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_keystroke_event(void) const;</span>

<span class="s0">275 19 set_candidate_event 0 4 524 34 ButtonThrower::set_candidate_event 0 1 11 804</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the event that is generated (if any) for each IME candidate</span>
 <span class="s0">* string event received.  Events of this nature are received only when the</span>
 <span class="s0">* user is entering data using a Microsoft Input Method Editor, typically used</span>
 <span class="s0">* for Asian languages such as Japanese or Korean.</span>
 <span class="s0">*</span>
 <span class="s0">* If you are designing a typing user interface, you should track this event</span>
 <span class="s0">* to support the use of the IME.  In response to this event, you should</span>
 <span class="s0">* display the candidate string in the entry box, with the appropriate</span>
 <span class="s0">* sections highlighted, so the user can scroll through the available choices.</span>
 <span class="s0">*</span>
 <span class="s0">* This event is generated with four parameters, in order: the candidate</span>
 <span class="s0">* string, the character at which to start the highlight, the character at</span>
 <span class="s0">* which to end the highlight, and the current cursor position.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void ButtonThrower::set_candidate_event(std::string const &amp;candidate_event);</span>

<span class="s0">276 19 get_candidate_event 0 4 524 34 ButtonThrower::get_candidate_event 0 1 12 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the candidate_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_candidate_event().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_candidate_event(void) const;</span>

<span class="s0">277 14 set_move_event 0 4 524 29 ButtonThrower::set_move_event 0 1 13 108</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the event that is generated (if any) each time the mouse is moved</span>
 <span class="s0">* within the window.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void ButtonThrower::set_move_event(std::string const &amp;move_event);</span>

<span class="s0">278 14 get_move_event 0 4 524 29 ButtonThrower::get_move_event 0 1 14 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the move_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_move_event().</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_move_event(void) const;</span>

<span class="s0">279 25 set_raw_button_down_event 0 4 524 40 ButtonThrower::set_raw_button_down_event 0 1 15 192</span>
<span class="s0">/**</span>
 <span class="s0">* Like set_button_down_event, but uses the raw, untransformed scan key from</span>
 <span class="s0">* the operating system.  This uses buttons that are independent of the user's</span>
 <span class="s0">* selected keyboard layout.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">inline void ButtonThrower::set_raw_button_down_event(std::string const &amp;raw_button_down_event);</span>

<span class="s0">280 25 get_raw_button_down_event 0 4 524 40 ButtonThrower::get_raw_button_down_event 0 1 16 121</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the raw_button_down_event that has been set on this ButtonThrower.</span>
 <span class="s0">* See set_raw_button_down_event().</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_raw_button_down_event(void) const;</span>

<span class="s0">281 23 set_raw_button_up_event 0 4 524 38 ButtonThrower::set_raw_button_up_event 0 1 17 141</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the generic event that is generated (if any) each time a key or</span>
 <span class="s0">* button is released.  See set_raw_button_down_event().</span>
 <span class="s0">*/</span>
<span class="s0">91</span>
<span class="s0">inline void ButtonThrower::set_raw_button_up_event(std::string const &amp;raw_button_up_event);</span>

<span class="s0">282 23 get_raw_button_up_event 0 4 524 38 ButtonThrower::get_raw_button_up_event 0 1 18 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the raw_button_up_event that has been set on this ButtonThrower.</span>
 <span class="s0">* See set_raw_button_up_event().</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_raw_button_up_event(void) const;</span>

<span class="s0">283 10 set_prefix 0 4 524 25 ButtonThrower::set_prefix 0 1 19 229</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the prefix which is prepended to all specific event names (that is,</span>
 <span class="s0">* event names generated from the button name itself, as opposed to the</span>
 <span class="s0">* generic event names like set_button_down_event) thrown by this object.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void ButtonThrower::set_prefix(std::string const &amp;prefix);</span>

<span class="s0">284 10 get_prefix 0 4 524 25 ButtonThrower::get_prefix 0 1 20 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the prefix that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_prefix().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline std::string const &amp;ButtonThrower::get_prefix(void) const;</span>

<span class="s0">285 17 set_specific_flag 0 4 524 32 ButtonThrower::set_specific_flag 0 1 21 307</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates whether specific events (events prefixed by</span>
 <span class="s0">* set_prefix, and based on the event name) should be generated at all.  This</span>
 <span class="s0">* is true by default, but may be disabled if you are only interested in the</span>
 <span class="s0">* generic events (for instance, events like set_button_down_event).</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void ButtonThrower::set_specific_flag(bool specific_flag);</span>

<span class="s0">286 17 get_specific_flag 0 4 524 32 ButtonThrower::get_specific_flag 0 1 22 116</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that indicates whether specific events should be</span>
 <span class="s0">* generated.  See set_specific_flag().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool ButtonThrower::get_specific_flag(void) const;</span>

<span class="s0">287 13 set_time_flag 0 4 524 28 ButtonThrower::set_time_flag 0 1 23 400</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates whether the time of the button event should be</span>
 <span class="s0">* passed as a parameter or not.  When this is true, an additional parameter</span>
 <span class="s0">* is generated on each event (before all the parameters named by</span>
 <span class="s0">* add_parameter) that consists of a single double value, and reflects the</span>
 <span class="s0">* time the button was pressed or released, as a value from</span>
 <span class="s0">* ClockObject::get_global_clock().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void ButtonThrower::set_time_flag(bool time_flag);</span>

<span class="s0">288 13 get_time_flag 0 4 524 28 ButtonThrower::get_time_flag 0 1 24 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that indicates whether the time of the button event should</span>
 <span class="s0">* be passed as a parameter.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline bool ButtonThrower::get_time_flag(void) const;</span>

<span class="s0">289 13 add_parameter 0 4 524 28 ButtonThrower::add_parameter 0 1 25 137</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated parameter to the list of parameters that will be passed</span>
 <span class="s0">* with each event generated by this ButtonThrower.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">void ButtonThrower::add_parameter(EventParameter const &amp;obj);</span>

<span class="s0">290 18 get_num_parameters 0 4 524 33 ButtonThrower::get_num_parameters 0 1 26 155</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of parameters that have been added to the list of</span>
 <span class="s0">* parameters to be passed with each event generated by this ButtonThrower.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int ButtonThrower::get_num_parameters(void) const;</span>

<span class="s0">291 13 get_parameter 0 4 524 28 ButtonThrower::get_parameter 0 1 27 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth parameter that has been added to the list of parameters</span>
 <span class="s0">* passed with each event generated by this ButtonThrower.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">EventParameter ButtonThrower::get_parameter(int n) const;</span>

<span class="s0">292 20 get_modifier_buttons 0 4 524 35 ButtonThrower::get_modifier_buttons 0 1 28 463</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of ModifierButtons that the ButtonThrower will consider</span>
 <span class="s0">* important enough to prepend the event name with.  Normally, this set will</span>
 <span class="s0">* be empty, and the ButtonThrower will therefore ignore all ModifierButtons</span>
 <span class="s0">* attached to the key events, but if one or more buttons have been added to</span>
 <span class="s0">* this set, and those modifier buttons are set on the button event, then the</span>
 <span class="s0">* event name will be prepended with the names of the modifier buttons.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline ModifierButtons const &amp;ButtonThrower::get_modifier_buttons(void) const;</span>

<span class="s0">293 20 set_modifier_buttons 0 4 524 35 ButtonThrower::set_modifier_buttons 0 1 29 653</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the set of ModifierButtons that the ButtonThrower will consider</span>
 <span class="s0">* important enough to prepend the event name with.  Normally, this set will</span>
 <span class="s0">* be empty, and the ButtonThrower will therefore ignore all ModifierButtons</span>
 <span class="s0">* attached to the key events, but if one or more buttons have been added to</span>
 <span class="s0">* this set, then the event name will be prepended with the names of the</span>
 <span class="s0">* modifier buttons.</span>
 <span class="s0">*</span>
 <span class="s0">* It is recommended that you change this setting by first calling</span>
 <span class="s0">* get_modifier_buttons(), making adjustments, and passing the new value to</span>
 <span class="s0">* set_modifier_buttons().  This way the current state of the modifier buttons</span>
 <span class="s0">* will not be lost.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline void ButtonThrower::set_modifier_buttons(ModifierButtons const &amp;mods);</span>

<span class="s0">294 24 set_throw_buttons_active 0 4 524 39 ButtonThrower::set_throw_buttons_active 0 1 30 293</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates whether the ButtonThrower will only process</span>
 <span class="s0">* events for the explicitly named buttons or not.  Normally this is false,</span>
 <span class="s0">* meaning all buttons are processed; set it true to indicate that only some</span>
 <span class="s0">* buttons should be processed.  See add_throw_button().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void ButtonThrower::set_throw_buttons_active(bool flag);</span>

<span class="s0">295 24 get_throw_buttons_active 0 4 524 39 ButtonThrower::get_throw_buttons_active 0 1 31 173</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag that indicates whether the ButtonThrower will only process</span>
 <span class="s0">* events for the explicitly named buttons or not.  See</span>
 <span class="s0">* set_throw_buttons_active().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool ButtonThrower::get_throw_buttons_active(void) const;</span>

<span class="s0">296 16 add_throw_button 0 4 524 31 ButtonThrower::add_throw_button 0 1 32 663</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new button to the set of buttons that the ButtonThrower explicitly</span>
 <span class="s0">* processes.</span>
 <span class="s0">*</span>
 <span class="s0">* If set_throw_buttons_active is false (which is the default), the</span>
 <span class="s0">* ButtonThrower will process all buttons.  Otherwise, the ButtonThrower will</span>
 <span class="s0">* only process events for the button(s) explicitly named by this function;</span>
 <span class="s0">* buttons not on the list will be ignored by this object and passed on</span>
 <span class="s0">* downstream to the child node(s) in the data graph.  A button that *is* on</span>
 <span class="s0">* the list will be processed by the ButtonThrower and not passed on to the</span>
 <span class="s0">* child node(s).</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the button is added, or false if it was already</span>
 <span class="s0">* in the set.</span>
 <span class="s0">*/</span>
<span class="s0">94</span>
<span class="s0">bool ButtonThrower::add_throw_button(ModifierButtons const &amp;mods, ButtonHandle const &amp;button);</span>

<span class="s0">297 19 remove_throw_button 0 4 524 34 ButtonThrower::remove_throw_button 0 1 33 231</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated button from the set of buttons that the ButtonThrower</span>
 <span class="s0">* explicitly processes.  See add_throw_button().</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the button is removed, or false if it was not</span>
 <span class="s0">* on the set.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">bool ButtonThrower::remove_throw_button(ModifierButtons const &amp;mods, ButtonHandle const &amp;button);</span>

<span class="s0">298 16 has_throw_button 0 4 524 31 ButtonThrower::has_throw_button 0 2 34 35 498</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated button is on the set of buttons that will be</span>
 <span class="s0">* processed by the ButtonThrower, false otherwise.  See add_throw_button().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated button, in conjunction with any nonspecified</span>
 <span class="s0">* modifier buttons, is on the set of buttons that will be processed by the</span>
 <span class="s0">* ButtonThrower.  That is to say, returns true if this button was ever passed</span>
 <span class="s0">* as the second parameter add_throw_button(), regardless of what the first</span>
 <span class="s0">* parameter was.</span>
 <span class="s0">*/</span>
<span class="s0">172</span>
<span class="s0">bool ButtonThrower::has_throw_button(ModifierButtons const &amp;mods, ButtonHandle const &amp;button) const;</span>
<span class="s0">bool ButtonThrower::has_throw_button(ButtonHandle const &amp;button) const;</span>

<span class="s0">299 19 clear_throw_buttons 0 4 524 34 ButtonThrower::clear_throw_buttons 0 1 36 105</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the set of buttons that were added via add_throw_button().  See</span>
 <span class="s0">* add_throw_button().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void ButtonThrower::clear_throw_buttons(void);</span>

<span class="s0">300 14 get_class_type 0 4 524 29 ButtonThrower::get_class_type 0 1 37 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle ButtonThrower::get_class_type(void);</span>

<span class="s0">301 14 require_button 0 4 533 34 MouseInterfaceNode::require_button 0 1 39 289</span>
<span class="s0">/**</span>
 <span class="s0">* Indicates that the indicated button must be in the required state (either</span>
 <span class="s0">* up or down) in order for this particular MouseInterfaceNode to do anything.</span>
 <span class="s0">* For instance, this may be called to make a Trackball object respect mouse</span>
 <span class="s0">* input only when the control key is held down.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">void MouseInterfaceNode::require_button(ButtonHandle const &amp;button, bool is_down);</span>

<span class="s0">302 12 clear_button 0 4 533 32 MouseInterfaceNode::clear_button 0 1 40 105</span>
<span class="s0">/**</span>
 <span class="s0">* Removes any requirement on the indicated button set by an earlier call to</span>
 <span class="s0">* require_button().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">void MouseInterfaceNode::clear_button(ButtonHandle const &amp;button);</span>

<span class="s0">303 17 clear_all_buttons 0 4 533 37 MouseInterfaceNode::clear_all_buttons 0 1 41 93</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all requirements on buttons set by an earlier call to</span>
 <span class="s0">* require_button().</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">void MouseInterfaceNode::clear_all_buttons(void);</span>

<span class="s0">304 14 get_class_type 0 4 533 34 MouseInterfaceNode::get_class_type 0 1 42 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle MouseInterfaceNode::get_class_type(void);</span>

<span class="s0">305 18 MouseInterfaceNode 0 260 533 38 MouseInterfaceNode::MouseInterfaceNode 0 1 38 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline MouseInterfaceNode::MouseInterfaceNode(MouseInterfaceNode const &amp;) = default;</span>

<span class="s0">306 14 DriveInterface 0 260 534 30 DriveInterface::DriveInterface 0 2 43 44 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">explicit DriveInterface::DriveInterface(std::string const &amp;name = &quot;&quot;);</span>
<span class="s0">inline DriveInterface::DriveInterface(DriveInterface const &amp;) = default;</span>

<span class="s0">307 17 set_forward_speed 0 4 534 33 DriveInterface::set_forward_speed 0 1 45 144</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the speed of full forward motion, when the mouse is at the very top of</span>
 <span class="s0">* the window.  This is in units (e.g.  feet) per second.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void DriveInterface::set_forward_speed(PN_stdfloat speed);</span>

<span class="s0">308 17 get_forward_speed 0 4 534 33 DriveInterface::get_forward_speed 0 1 46 147</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the speed of full forward motion, when the mouse is at the very top</span>
 <span class="s0">* of the window.  This is in units (e.g.  feet) per second.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_forward_speed(void) const;</span>

<span class="s0">309 17 set_reverse_speed 0 4 534 33 DriveInterface::set_reverse_speed 0 1 47 147</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the speed of full reverse motion, when the mouse is at the very bottom</span>
 <span class="s0">* of the window.  This is in units (e.g.  feet) per second.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void DriveInterface::set_reverse_speed(PN_stdfloat speed);</span>

<span class="s0">310 17 get_reverse_speed 0 4 534 33 DriveInterface::get_reverse_speed 0 1 48 150</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the speed of full reverse motion, when the mouse is at the very</span>
 <span class="s0">* bottom of the window.  This is in units (e.g.  feet) per second.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_reverse_speed(void) const;</span>

<span class="s0">311 16 set_rotate_speed 0 4 534 32 DriveInterface::set_rotate_speed 0 1 49 161</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the maximum rate at which the user can rotate left or right, when the</span>
 <span class="s0">* mouse is at the very edge of the window.  This is in degrees per second.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void DriveInterface::set_rotate_speed(PN_stdfloat speed);</span>

<span class="s0">312 16 get_rotate_speed 0 4 534 32 DriveInterface::get_rotate_speed 0 1 50 167</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum rate at which the user can rotate left or right, when</span>
 <span class="s0">* the mouse is at the very edge of the window.  This is in degrees per</span>
 <span class="s0">* second.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_rotate_speed(void) const;</span>

<span class="s0">313 22 set_vertical_dead_zone 0 4 534 38 DriveInterface::set_vertical_dead_zone 0 1 51 300</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the size of the horizontal bar in the center of the screen that</span>
 <span class="s0">* represents the &quot;dead zone&quot; of vertical motion: the region in which the</span>
 <span class="s0">* mouse does not report vertical motion.  This is in a fraction of the window</span>
 <span class="s0">* height, so 0.5 will set a dead zone as large as half the screen.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void DriveInterface::set_vertical_dead_zone(PN_stdfloat zone);</span>

<span class="s0">314 22 get_vertical_dead_zone 0 4 534 38 DriveInterface::get_vertical_dead_zone 0 1 52 303</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of the horizontal bar in the center of the screen that</span>
 <span class="s0">* represents the &quot;dead zone&quot; of vertical motion: the region in which the</span>
 <span class="s0">* mouse does not report vertical motion.  This is in a fraction of the window</span>
 <span class="s0">* height, so 0.5 will set a dead zone as large as half the screen.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_vertical_dead_zone(void) const;</span>

<span class="s0">315 24 set_horizontal_dead_zone 0 4 534 40 DriveInterface::set_horizontal_dead_zone 0 1 53 301</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the size of the vertical bar in the center of the screen that</span>
 <span class="s0">* represents the &quot;dead zone&quot; of horizontal motion: the region in which the</span>
 <span class="s0">* mouse does not report horizontal motion.  This is in a fraction of the</span>
 <span class="s0">* window width, so 0.5 will set a dead zone as large as half the screen.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void DriveInterface::set_horizontal_dead_zone(PN_stdfloat zone);</span>

<span class="s0">316 24 get_horizontal_dead_zone 0 4 534 40 DriveInterface::get_horizontal_dead_zone 0 1 54 304</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of the vertical bar in the center of the screen that</span>
 <span class="s0">* represents the &quot;dead zone&quot; of horizontal motion: the region in which the</span>
 <span class="s0">* mouse does not report horizontal motion.  This is in a fraction of the</span>
 <span class="s0">* window width, so 0.5 will set a dead zone as large as half the screen.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_horizontal_dead_zone(void) const;</span>

<span class="s0">317 25 set_vertical_ramp_up_time 0 4 534 41 DriveInterface::set_vertical_ramp_up_time 0 1 55 173</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the amount of time, in seconds, it takes between the time an up or</span>
 <span class="s0">* down arrow key is pressed and the time it registers full forward or</span>
 <span class="s0">* backward motion.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline void DriveInterface::set_vertical_ramp_up_time(PN_stdfloat ramp_up_time);</span>

<span class="s0">318 25 get_vertical_ramp_up_time 0 4 534 41 DriveInterface::get_vertical_ramp_up_time 0 1 56 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of time, in seconds, it takes between the time an up or</span>
 <span class="s0">* down arrow key is pressed and the time it registers full forward or</span>
 <span class="s0">* backward motion.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_vertical_ramp_up_time(void) const;</span>

<span class="s0">319 27 set_vertical_ramp_down_time 0 4 534 43 DriveInterface::set_vertical_ramp_down_time 0 1 57 149</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the amount of time, in seconds, it takes between the time an up or</span>
 <span class="s0">* down arrow key is released and the time it registers no motion.</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">inline void DriveInterface::set_vertical_ramp_down_time(PN_stdfloat ramp_down_time);</span>

<span class="s0">320 27 get_vertical_ramp_down_time 0 4 534 43 DriveInterface::get_vertical_ramp_down_time 0 1 58 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of time, in seconds, it takes between the time an up or</span>
 <span class="s0">* down arrow key is released and the time it registers no motion.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_vertical_ramp_down_time(void) const;</span>

<span class="s0">321 27 set_horizontal_ramp_up_time 0 4 534 43 DriveInterface::set_horizontal_ramp_up_time 0 1 59 154</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the amount of time, in seconds, it takes between the time a left or</span>
 <span class="s0">* right arrow key is pressed and the time it registers full rotation.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline void DriveInterface::set_horizontal_ramp_up_time(PN_stdfloat ramp_up_time);</span>

<span class="s0">322 27 get_horizontal_ramp_up_time 0 4 534 43 DriveInterface::get_horizontal_ramp_up_time 0 1 60 157</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of time, in seconds, it takes between the time a left or</span>
 <span class="s0">* right arrow key is pressed and the time it registers full rotation.</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_horizontal_ramp_up_time(void) const;</span>

<span class="s0">323 29 set_horizontal_ramp_down_time 0 4 534 45 DriveInterface::set_horizontal_ramp_down_time 0 1 61 151</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the amount of time, in seconds, it takes between the time a left or</span>
 <span class="s0">* right arrow key is released and the time it registers no motion.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void DriveInterface::set_horizontal_ramp_down_time(PN_stdfloat ramp_down_time);</span>

<span class="s0">324 29 get_horizontal_ramp_down_time 0 4 534 45 DriveInterface::get_horizontal_ramp_down_time 0 1 62 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the amount of time, in seconds, it takes between the time a left or</span>
 <span class="s0">* right arrow key is released and the time it registers no motion.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_horizontal_ramp_down_time(void) const;</span>

<span class="s0">325 9 get_speed 0 4 534 25 DriveInterface::get_speed 0 1 63 64</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the speed of the previous update in units/sec</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_speed(void) const;</span>

<span class="s0">326 13 get_rot_speed 0 4 534 29 DriveInterface::get_rot_speed 0 1 64 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the rot_speed of the previous update in units/sec</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_rot_speed(void) const;</span>

<span class="s0">327 5 reset 0 4 534 21 DriveInterface::reset 0 1 65 108</span>
<span class="s0">/**</span>
 <span class="s0">* Reinitializes the driver to the origin and resets any knowledge about</span>
 <span class="s0">* buttons being held down.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">void DriveInterface::reset(void);</span>

<span class="s0">328 7 get_pos 0 4 534 23 DriveInterface::get_pos 0 1 66 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the driver's position.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LPoint3 const &amp;DriveInterface::get_pos(void) const;</span>

<span class="s0">329 5 get_x 0 4 534 21 DriveInterface::get_x 0 1 67 0</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_x(void) const;</span>

<span class="s0">330 5 get_y 0 4 534 21 DriveInterface::get_y 0 1 68 0</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_y(void) const;</span>

<span class="s0">331 5 get_z 0 4 534 21 DriveInterface::get_z 0 1 69 0</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_z(void) const;</span>

<span class="s0">332 7 set_pos 0 4 534 23 DriveInterface::set_pos 0 2 70 71 47</span>
<span class="s0">/**</span>
 <span class="s0">* Directly sets the driver's position.</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">inline void DriveInterface::set_pos(LVecBase3 const &amp;vec);</span>
<span class="s0">inline void DriveInterface::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">333 5 set_x 0 4 534 21 DriveInterface::set_x 0 1 72 0</span>
<span class="s0">49</span>
<span class="s0">inline void DriveInterface::set_x(PN_stdfloat x);</span>

<span class="s0">334 5 set_y 0 4 534 21 DriveInterface::set_y 0 1 73 0</span>
<span class="s0">49</span>
<span class="s0">inline void DriveInterface::set_y(PN_stdfloat y);</span>

<span class="s0">335 5 set_z 0 4 534 21 DriveInterface::set_z 0 1 74 0</span>
<span class="s0">49</span>
<span class="s0">inline void DriveInterface::set_z(PN_stdfloat z);</span>

<span class="s0">336 7 get_hpr 0 4 534 23 DriveInterface::get_hpr 0 1 75 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the driver's orientation.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase3 const &amp;DriveInterface::get_hpr(void) const;</span>

<span class="s0">337 5 get_h 0 4 534 21 DriveInterface::get_h 0 1 76 0</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_h(void) const;</span>

<span class="s0">338 5 get_p 0 4 534 21 DriveInterface::get_p 0 1 77 0</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_p(void) const;</span>

<span class="s0">339 5 get_r 0 4 534 21 DriveInterface::get_r 0 1 78 0</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat DriveInterface::get_r(void) const;</span>

<span class="s0">340 7 set_hpr 0 4 534 23 DriveInterface::set_hpr 0 2 79 80 50</span>
<span class="s0">/**</span>
 <span class="s0">* Directly sets the driver's orientation.</span>
 <span class="s0">*/</span>
<span class="s0">140</span>
<span class="s0">inline void DriveInterface::set_hpr(LVecBase3 const &amp;hpr);</span>
<span class="s0">inline void DriveInterface::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>

<span class="s0">341 5 set_h 0 4 534 21 DriveInterface::set_h 0 1 81 0</span>
<span class="s0">49</span>
<span class="s0">inline void DriveInterface::set_h(PN_stdfloat h);</span>

<span class="s0">342 5 set_p 0 4 534 21 DriveInterface::set_p 0 1 82 0</span>
<span class="s0">49</span>
<span class="s0">inline void DriveInterface::set_p(PN_stdfloat p);</span>

<span class="s0">343 5 set_r 0 4 534 21 DriveInterface::set_r 0 1 83 0</span>
<span class="s0">49</span>
<span class="s0">inline void DriveInterface::set_r(PN_stdfloat r);</span>

<span class="s0">344 14 set_force_roll 0 4 534 30 DriveInterface::set_force_roll 0 1 84 86</span>
<span class="s0">/**</span>
 <span class="s0">* This function is no longer used and does nothing.  It will be removed soon.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void DriveInterface::set_force_roll(PN_stdfloat force_roll);</span>

<span class="s0">345 16 set_ignore_mouse 0 4 534 32 DriveInterface::set_ignore_mouse 0 1 85 411</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the state of the ignore_mouse flag.  If this flag is true, the</span>
 <span class="s0">* DriveInterface will ignore mouse down button events (but still recognize</span>
 <span class="s0">* mouse up button events); the user will not be able to start the</span>
 <span class="s0">* DriveInterface going again if it is stopped, but if the user is currently</span>
 <span class="s0">* holding down a mouse button it will not stop immediately until the user</span>
 <span class="s0">* eventually releases the button.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void DriveInterface::set_ignore_mouse(bool ignore_mouse);</span>

<span class="s0">346 16 get_ignore_mouse 0 4 534 32 DriveInterface::get_ignore_mouse 0 1 86 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the ignore_mouse flag.  See</span>
 <span class="s0">* set_ignore_mouse().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool DriveInterface::get_ignore_mouse(void) const;</span>

<span class="s0">347 15 set_force_mouse 0 4 534 31 DriveInterface::set_force_mouse 0 1 87 155</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the state of the force_mouse flag.  If this flag is true, the mouse</span>
 <span class="s0">* button need not be held down in order to drive the avatar around.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void DriveInterface::set_force_mouse(bool force_mouse);</span>

<span class="s0">348 15 get_force_mouse 0 4 534 31 DriveInterface::get_force_mouse 0 1 88 90</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the force_mouse flag.  See</span>
 <span class="s0">* set_force_mouse().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool DriveInterface::get_force_mouse(void) const;</span>

<span class="s0">349 19 set_stop_this_frame 0 4 534 35 DriveInterface::set_stop_this_frame 0 1 89 335</span>
<span class="s0">/**</span>
 <span class="s0">* If stop_this_frame is true, the next time the frame is computed no motion</span>
 <span class="s0">* will be allowed, and then the flag is reset to false.  This can be used to</span>
 <span class="s0">* prevent too much movement when we know a long time has artificially</span>
 <span class="s0">* elapsed, for instance when we take a screenshot, without munging the clock</span>
 <span class="s0">* for everything else.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void DriveInterface::set_stop_this_frame(bool stop_this_frame);</span>

<span class="s0">350 19 get_stop_this_frame 0 4 534 35 DriveInterface::get_stop_this_frame 0 1 90 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current setting of the stop_this_frame flag.  See</span>
 <span class="s0">* set_stop_this_frame().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool DriveInterface::get_stop_this_frame(void) const;</span>

<span class="s0">351 7 set_mat 0 4 534 23 DriveInterface::set_mat 0 1 91 64</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the indicated transform in the DriveInterface.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void DriveInterface::set_mat(LMatrix4 const &amp;mat);</span>

<span class="s0">352 7 get_mat 0 4 534 23 DriveInterface::get_mat 0 1 92 41</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current transform.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">LMatrix4 const &amp;DriveInterface::get_mat(void);</span>

<span class="s0">353 12 force_dgraph 0 4 534 28 DriveInterface::force_dgraph 0 1 93 287</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special kludge for DriveInterface to allow us to avoid the one-</span>
 <span class="s0">* frame latency after a collision.  It forces an immediate partial data flow</span>
 <span class="s0">* for all data graph nodes below this node, causing all data nodes that</span>
 <span class="s0">* depend on this matrix to be updated immediately.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void DriveInterface::force_dgraph(void);</span>

<span class="s0">354 14 get_class_type 0 4 534 30 DriveInterface::get_class_type 0 1 94 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle DriveInterface::get_class_type(void);</span>

<span class="s0">355 14 MouseSubregion 0 260 535 30 MouseSubregion::MouseSubregion 0 2 95 96 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">138</span>
<span class="s0">explicit MouseSubregion::MouseSubregion(std::string const &amp;name);</span>
<span class="s0">inline MouseSubregion::MouseSubregion(MouseSubregion const &amp;) = default;</span>

<span class="s0">356 8 get_left 0 4 535 24 MouseSubregion::get_left 0 1 97 135</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the x coordinate of the left edge of the rectangle within the</span>
 <span class="s0">* window.  This number will be in the range [0..1].</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline PN_stdfloat MouseSubregion::get_left(void) const;</span>

<span class="s0">357 9 get_right 0 4 535 25 MouseSubregion::get_right 0 1 98 136</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the x coordinate of the right edge of the rectangle within the</span>
 <span class="s0">* window.  This number will be in the range [0..1].</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat MouseSubregion::get_right(void) const;</span>

<span class="s0">358 10 get_bottom 0 4 535 26 MouseSubregion::get_bottom 0 1 99 137</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the y coordinate of the bottom edge of the rectangle within the</span>
 <span class="s0">* window.  This number will be in the range [0..1].</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline PN_stdfloat MouseSubregion::get_bottom(void) const;</span>

<span class="s0">359 7 get_top 0 4 535 23 MouseSubregion::get_top 0 1 100 134</span>
<span class="s0">/**</span>
 <span class="s0">* Retrieves the y coordinate of the top edge of the rectangle within the</span>
 <span class="s0">* window.  This number will be in the range [0..1].</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PN_stdfloat MouseSubregion::get_top(void) const;</span>

<span class="s0">360 14 set_dimensions 0 4 535 30 MouseSubregion::set_dimensions 0 1 101 288</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the region of the window in which the mouse is considered to be</span>
 <span class="s0">* active.  The parameters are identical to those for a DisplayRegion: they</span>
 <span class="s0">* range from 0 to 1, where 0,0 is the lower left corner and 1,1 is the upper</span>
 <span class="s0">* right; (0, 1, 0, 1) represents the whole window.</span>
 <span class="s0">*/</span>
<span class="s0">103</span>
<span class="s0">inline void MouseSubregion::set_dimensions(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t);</span>

<span class="s0">361 14 get_class_type 0 4 535 30 MouseSubregion::get_class_type 0 1 102 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle MouseSubregion::get_class_type(void);</span>

<span class="s0">362 37 upcast_to_TypedWritableReferenceCount 0 12 536 57 MouseWatcherRegion::upcast_to_TypedWritableReferenceCount 0 1 121 61</span>
<span class="s0">upcast from MouseWatcherRegion to TypedWritableReferenceCount</span>
<span class="s0">93</span>
<span class="s0">TypedWritableReferenceCount *MouseWatcherRegion::upcast_to_TypedWritableReferenceCount(void);</span>

<span class="s0">363 30 downcast_to_MouseWatcherRegion 0 12 537 59 TypedWritableReferenceCount::downcast_to_MouseWatcherRegion 0 0 63</span>
<span class="s0">downcast from TypedWritableReferenceCount to MouseWatcherRegion</span>
<span class="s0">86</span>
<span class="s0">MouseWatcherRegion *TypedWritableReferenceCount::downcast_to_MouseWatcherRegion(void);</span>

<span class="s0">364 17 upcast_to_Namable 0 12 536 37 MouseWatcherRegion::upcast_to_Namable 0 1 122 41</span>
<span class="s0">upcast from MouseWatcherRegion to Namable</span>
<span class="s0">53</span>
<span class="s0">Namable *MouseWatcherRegion::upcast_to_Namable(void);</span>

<span class="s0">365 30 downcast_to_MouseWatcherRegion 0 12 538 39 Namable::downcast_to_MouseWatcherRegion 0 0 43</span>
<span class="s0">downcast from Namable to MouseWatcherRegion</span>
<span class="s0">66</span>
<span class="s0">MouseWatcherRegion *Namable::downcast_to_MouseWatcherRegion(void);</span>

<span class="s0">366 18 MouseWatcherRegion 0 260 536 38 MouseWatcherRegion::MouseWatcherRegion 0 3 103 104 105 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">344</span>
<span class="s0">inline explicit MouseWatcherRegion::MouseWatcherRegion(std::string const &amp;name, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);</span>
<span class="s0">inline explicit MouseWatcherRegion::MouseWatcherRegion(std::string const &amp;name, LVecBase4 const &amp;frame);</span>
<span class="s0">inline MouseWatcherRegion::MouseWatcherRegion(MouseWatcherRegion const &amp;) = default;</span>

<span class="s0">367 9 set_frame 0 4 536 29 MouseWatcherRegion::set_frame 0 2 106 107 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">183</span>
<span class="s0">inline void MouseWatcherRegion::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);</span>
<span class="s0">inline void MouseWatcherRegion::set_frame(LVecBase4 const &amp;frame);</span>

<span class="s0">368 9 get_frame 0 4 536 29 MouseWatcherRegion::get_frame 0 1 108 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline LVecBase4 const &amp;MouseWatcherRegion::get_frame(void) const;</span>

<span class="s0">369 8 get_area 0 4 536 28 MouseWatcherRegion::get_area 0 1 109 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the area of the rectangular region.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PN_stdfloat MouseWatcherRegion::get_area(void) const;</span>

<span class="s0">370 8 set_sort 0 4 536 28 MouseWatcherRegion::set_sort 0 1 110 366</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the sorting order of this particular region.  The sorting order is</span>
 <span class="s0">* used to resolve conflicts in the case of overlapping region; the region</span>
 <span class="s0">* with the highest sort value will be preferred, and between regions of the</span>
 <span class="s0">* same sort value, the smallest region will be preferred.  The default</span>
 <span class="s0">* sorting order, if none is explicitly specified, is 0.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void MouseWatcherRegion::set_sort(int sort);</span>

<span class="s0">371 8 get_sort 0 4 536 28 MouseWatcherRegion::get_sort 0 1 111 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current sorting order of this region.  See set_sort().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int MouseWatcherRegion::get_sort(void) const;</span>

<span class="s0">372 10 set_active 0 4 536 30 MouseWatcherRegion::set_active 0 1 112 237</span>
<span class="s0">/**</span>
 <span class="s0">* Sets whether the region is active or not.  If it is not active, the</span>
 <span class="s0">* MouseWatcher will never consider the mouse to be over the region.  The</span>
 <span class="s0">* region might still receive keypress events if its set_keyboard() flag is</span>
 <span class="s0">* true.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void MouseWatcherRegion::set_active(bool active);</span>

<span class="s0">373 10 get_active 0 4 536 30 MouseWatcherRegion::get_active 0 1 113 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether the region is active or not.  See set_active().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool MouseWatcherRegion::get_active(void) const;</span>

<span class="s0">374 12 set_keyboard 0 4 536 32 MouseWatcherRegion::set_keyboard 0 1 114 301</span>
<span class="s0">/**</span>
 <span class="s0">* Sets whether the region is interested in global keyboard events.  If this</span>
 <span class="s0">* is true, then any keyboard button events will be passed to press() and</span>
 <span class="s0">* release() regardless of the position of the mouse onscreen; otherwise,</span>
 <span class="s0">* these events will only be passed if the mouse is over the region.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void MouseWatcherRegion::set_keyboard(bool keyboard);</span>

<span class="s0">375 12 get_keyboard 0 4 536 32 MouseWatcherRegion::get_keyboard 0 1 115 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether the region is interested in global keyboard events; see</span>
 <span class="s0">* set_keyboard().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool MouseWatcherRegion::get_keyboard(void) const;</span>

<span class="s0">376 18 set_suppress_flags 0 4 536 38 MouseWatcherRegion::set_suppress_flags 0 1 116 394</span>
<span class="s0">/**</span>
 <span class="s0">* Sets which events are suppressed when the mouse is over the region.  This</span>
 <span class="s0">* is the union of zero or more various SF_* values.  Normally, this is 0,</span>
 <span class="s0">* indicating that no events are suppressed.</span>
 <span class="s0">*</span>
 <span class="s0">* If you set this to a non-zero value, for instance SF_mouse_position, then</span>
 <span class="s0">* the mouse position will not be sent along the data graph when the mouse is</span>
 <span class="s0">* over this particular region.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void MouseWatcherRegion::set_suppress_flags(int suppress_flags);</span>

<span class="s0">377 18 get_suppress_flags 0 4 536 38 MouseWatcherRegion::get_suppress_flags 0 1 117 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current suppress_flags.  See set_suppress_flags().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int MouseWatcherRegion::get_suppress_flags(void) const;</span>

<span class="s0">378 6 output 0 4 536 26 MouseWatcherRegion::output 0 1 118 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">void MouseWatcherRegion::output(std::ostream &amp;out) const;</span>

<span class="s0">379 5 write 0 4 536 25 MouseWatcherRegion::write 0 1 119 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void MouseWatcherRegion::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">380 14 get_class_type 0 4 536 34 MouseWatcherRegion::get_class_type 0 1 120 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle MouseWatcherRegion::get_class_type(void);</span>

<span class="s0">381 19 ~MouseWatcherRegion 0 516 536 39 MouseWatcherRegion::~MouseWatcherRegion 0 0 0</span>
<span class="s0">46</span>
<span class="s0">MouseWatcherRegion::~MouseWatcherRegion(void);</span>

<span class="s0">382 17 ~MouseWatcherBase 0 518 546 35 MouseWatcherBase::~MouseWatcherBase 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">virtual MouseWatcherBase::~MouseWatcherBase(void);</span>

<span class="s0">383 10 add_region 0 4 546 28 MouseWatcherBase::add_region 0 1 123 150</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated region to the set of regions in the group.  It is no</span>
 <span class="s0">* longer an error to call this for the same region more than once.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void MouseWatcherBase::add_region(PointerTo&lt; MouseWatcherRegion &gt; region);</span>

<span class="s0">384 10 has_region 0 4 546 28 MouseWatcherBase::has_region 0 1 124 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated region has already been added to the</span>
 <span class="s0">* MouseWatcherBase, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">bool MouseWatcherBase::has_region(MouseWatcherRegion *region) const;</span>

<span class="s0">385 13 remove_region 0 4 546 31 MouseWatcherBase::remove_region 0 1 125 152</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated region from the group.  Returns true if it was</span>
 <span class="s0">* successfully removed, or false if it wasn't there in the first place.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool MouseWatcherBase::remove_region(MouseWatcherRegion *region);</span>

<span class="s0">386 11 find_region 0 4 546 29 MouseWatcherBase::find_region 0 1 126 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the first region found with the indicated name.  If</span>
 <span class="s0">* multiple regions share the same name, the one that is returned is</span>
 <span class="s0">* indeterminate.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">MouseWatcherRegion *MouseWatcherBase::find_region(std::string const &amp;name) const;</span>

<span class="s0">387 13 clear_regions 0 4 546 31 MouseWatcherBase::clear_regions 0 1 127 50</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the regions from the group.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void MouseWatcherBase::clear_regions(void);</span>

<span class="s0">388 12 sort_regions 0 4 546 30 MouseWatcherBase::sort_regions 0 1 128 66</span>
<span class="s0">/**</span>
 <span class="s0">* Sorts all the regions in this group into pointer order.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void MouseWatcherBase::sort_regions(void);</span>

<span class="s0">389 9 is_sorted 0 4 546 27 MouseWatcherBase::is_sorted 0 1 129 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the group has already been sorted, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool MouseWatcherBase::is_sorted(void) const;</span>

<span class="s0">390 15 get_num_regions 0 4 546 33 MouseWatcherBase::get_num_regions 0 1 130 54</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of regions in the group.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">std::size_t MouseWatcherBase::get_num_regions(void) const;</span>

<span class="s0">391 10 get_region 0 4 546 28 MouseWatcherBase::get_region 0 1 131 209</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth region of the group; returns NULL if there is no nth</span>
 <span class="s0">* region.  Note that this is not thread-safe; another thread might have</span>
 <span class="s0">* removed the nth region before you called this method.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">MouseWatcherRegion *MouseWatcherBase::get_region(std::size_t n) const;</span>

<span class="s0">392 6 output 0 4 546 24 MouseWatcherBase::output 0 1 132 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void MouseWatcherBase::output(std::ostream &amp;out) const;</span>

<span class="s0">393 5 write 0 4 546 23 MouseWatcherBase::write 0 1 133 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void MouseWatcherBase::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">394 12 show_regions 0 4 546 30 MouseWatcherBase::show_regions 0 1 134 179</span>
<span class="s0">/**</span>
 <span class="s0">* Enables the visualization of all of the regions handled by this</span>
 <span class="s0">* MouseWatcherBase.  The supplied NodePath should be the root of the 2-d</span>
 <span class="s0">* scene graph for the window.</span>
 <span class="s0">*/</span>
<span class="s0">107</span>
<span class="s0">void MouseWatcherBase::show_regions(NodePath const &amp;render2d, std::string const &amp;bin_name, int draw_order);</span>

<span class="s0">395 9 set_color 0 4 546 27 MouseWatcherBase::set_color 0 1 135 114</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the color used to draw the region rectangles for the regions</span>
 <span class="s0">* visualized by show_regions().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">void MouseWatcherBase::set_color(LColor const &amp;color);</span>

<span class="s0">396 12 hide_regions 0 4 546 30 MouseWatcherBase::hide_regions 0 1 136 80</span>
<span class="s0">/**</span>
 <span class="s0">* Stops the visualization created by a previous call to show_regions().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void MouseWatcherBase::hide_regions(void);</span>

<span class="s0">397 14 update_regions 0 4 546 32 MouseWatcherBase::update_regions 0 1 137 65</span>
<span class="s0">/**</span>
 <span class="s0">* Refreshes the visualization created by show_regions().</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">void MouseWatcherBase::update_regions(void);</span>

<span class="s0">398 14 get_class_type 0 4 546 32 MouseWatcherBase::get_class_type 0 1 138 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle MouseWatcherBase::get_class_type(void);</span>

<span class="s0">399 26 upcast_to_MouseWatcherBase 0 12 548 45 MouseWatcherGroup::upcast_to_MouseWatcherBase 0 1 140 49</span>
<span class="s0">upcast from MouseWatcherGroup to MouseWatcherBase</span>
<span class="s0">70</span>
<span class="s0">MouseWatcherBase *MouseWatcherGroup::upcast_to_MouseWatcherBase(void);</span>

<span class="s0">400 29 downcast_to_MouseWatcherGroup 0 12 546 47 MouseWatcherBase::downcast_to_MouseWatcherGroup 0 0 51</span>
<span class="s0">downcast from MouseWatcherBase to MouseWatcherGroup</span>
<span class="s0">73</span>
<span class="s0">MouseWatcherGroup *MouseWatcherBase::downcast_to_MouseWatcherGroup(void);</span>

<span class="s0">401 24 upcast_to_ReferenceCount 0 12 548 43 MouseWatcherGroup::upcast_to_ReferenceCount 0 1 141 47</span>
<span class="s0">upcast from MouseWatcherGroup to ReferenceCount</span>
<span class="s0">66</span>
<span class="s0">ReferenceCount *MouseWatcherGroup::upcast_to_ReferenceCount(void);</span>

<span class="s0">402 29 downcast_to_MouseWatcherGroup 0 12 549 45 ReferenceCount::downcast_to_MouseWatcherGroup 0 0 49</span>
<span class="s0">downcast from ReferenceCount to MouseWatcherGroup</span>
<span class="s0">71</span>
<span class="s0">MouseWatcherGroup *ReferenceCount::downcast_to_MouseWatcherGroup(void);</span>

<span class="s0">403 14 get_class_type 0 4 548 33 MouseWatcherGroup::get_class_type 0 1 139 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle MouseWatcherGroup::get_class_type(void);</span>

<span class="s0">404 18 ~MouseWatcherGroup 0 516 548 37 MouseWatcherGroup::~MouseWatcherGroup 0 0 0</span>
<span class="s0">44</span>
<span class="s0">MouseWatcherGroup::~MouseWatcherGroup(void);</span>

<span class="s0">405 18 upcast_to_DataNode 0 12 550 32 MouseWatcher::upcast_to_DataNode 0 1 204 36</span>
<span class="s0">upcast from MouseWatcher to DataNode</span>
<span class="s0">49</span>
<span class="s0">DataNode *MouseWatcher::upcast_to_DataNode(void);</span>

<span class="s0">406 24 downcast_to_MouseWatcher 0 12 525 34 DataNode::downcast_to_MouseWatcher 0 0 38</span>
<span class="s0">downcast from DataNode to MouseWatcher</span>
<span class="s0">55</span>
<span class="s0">MouseWatcher *DataNode::downcast_to_MouseWatcher(void);</span>

<span class="s0">407 26 upcast_to_MouseWatcherBase 0 12 550 40 MouseWatcher::upcast_to_MouseWatcherBase 0 1 205 44</span>
<span class="s0">upcast from MouseWatcher to MouseWatcherBase</span>
<span class="s0">65</span>
<span class="s0">MouseWatcherBase *MouseWatcher::upcast_to_MouseWatcherBase(void);</span>

<span class="s0">408 24 downcast_to_MouseWatcher 0 12 546 42 MouseWatcherBase::downcast_to_MouseWatcher 0 0 46</span>
<span class="s0">downcast from MouseWatcherBase to MouseWatcher</span>
<span class="s0">63</span>
<span class="s0">MouseWatcher *MouseWatcherBase::downcast_to_MouseWatcher(void);</span>

<span class="s0">409 12 MouseWatcher 0 260 550 26 MouseWatcher::MouseWatcher 0 1 142 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">explicit MouseWatcher::MouseWatcher(std::string const &amp;name = &quot;&quot;);</span>

<span class="s0">410 13 ~MouseWatcher 0 518 550 27 MouseWatcher::~MouseWatcher 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">virtual MouseWatcher::~MouseWatcher(void);</span>

<span class="s0">411 13 remove_region 0 4 550 27 MouseWatcher::remove_region 0 1 143 152</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated region from the group.  Returns true if it was</span>
 <span class="s0">* successfully removed, or false if it wasn't there in the first place.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">bool MouseWatcher::remove_region(MouseWatcherRegion *region);</span>

<span class="s0">412 9 has_mouse 0 4 550 23 MouseWatcher::has_mouse 0 1 144 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the mouse is anywhere within the window, false otherwise.</span>
 <span class="s0">* Also see is_mouse_open().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool MouseWatcher::has_mouse(void) const;</span>

<span class="s0">413 13 is_mouse_open 0 4 550 27 MouseWatcher::is_mouse_open 0 1 145 212</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the mouse is within the window and not over some particular</span>
 <span class="s0">* MouseWatcherRegion that is marked to suppress mouse events; that is, that</span>
 <span class="s0">* the mouse is in open space within the window.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline bool MouseWatcher::is_mouse_open(void) const;</span>

<span class="s0">414 9 get_mouse 0 4 550 23 MouseWatcher::get_mouse 0 1 146 146</span>
<span class="s0">/**</span>
 <span class="s0">* It is only valid to call this if has_mouse() returns true.  If so, this</span>
 <span class="s0">* returns the current position of the mouse within the window.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline LPoint2 const &amp;MouseWatcher::get_mouse(void) const;</span>

<span class="s0">415 11 get_mouse_x 0 4 550 25 MouseWatcher::get_mouse_x 0 1 147 148</span>
<span class="s0">/**</span>
 <span class="s0">* It is only valid to call this if has_mouse() returns true.  If so, this</span>
 <span class="s0">* returns the current X position of the mouse within the window.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat MouseWatcher::get_mouse_x(void) const;</span>

<span class="s0">416 11 get_mouse_y 0 4 550 25 MouseWatcher::get_mouse_y 0 1 148 148</span>
<span class="s0">/**</span>
 <span class="s0">* It is only valid to call this if has_mouse() returns true.  If so, this</span>
 <span class="s0">* returns the current Y position of the mouse within the window.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat MouseWatcher::get_mouse_y(void) const;</span>

<span class="s0">417 9 set_frame 0 4 550 23 MouseWatcher::set_frame 0 2 149 150 686</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the frame of the MouseWatcher.  See the next flavor of this method for</span>
 <span class="s0">* a more verbose explanation.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the frame of the MouseWatcher.  This determines the coordinate space</span>
 <span class="s0">* in which the MouseWatcherRegions should be expected to live.  Normally,</span>
 <span class="s0">* this is left at -1, 1, -1, 1, which is the default setting, and matches the</span>
 <span class="s0">* mouse coordinate range.</span>
 <span class="s0">*</span>
 <span class="s0">* Whatever values you specify here indicate the shape of the full screen, and</span>
 <span class="s0">* the MouseWatcherRegions will be given in coordinate space matching it.  For</span>
 <span class="s0">* instance, if you specify (0, 1, 0, 1), then a MouseWatcherRegion with the</span>
 <span class="s0">* frame (0, 1, 0, .5) will cover the lower half of the screen.</span>
 <span class="s0">*/</span>
<span class="s0">171</span>
<span class="s0">inline void MouseWatcher::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);</span>
<span class="s0">inline void MouseWatcher::set_frame(LVecBase4 const &amp;frame);</span>

<span class="s0">418 9 get_frame 0 4 550 23 MouseWatcher::get_frame 0 1 151 67</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the frame of the MouseWatcher.  See set_frame().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LVecBase4 const &amp;MouseWatcher::get_frame(void) const;</span>

<span class="s0">419 14 is_over_region 0 4 550 28 MouseWatcher::is_over_region 0 3 152 153 154 259</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the mouse is over any rectangular region, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the mouse is over any rectangular region, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns true if the mouse is over any rectangular region, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">199</span>
<span class="s0">inline bool MouseWatcher::is_over_region(void) const;</span>
<span class="s0">inline bool MouseWatcher::is_over_region(PN_stdfloat x, PN_stdfloat y) const;</span>
<span class="s0">inline bool MouseWatcher::is_over_region(LPoint2 const &amp;pos) const;</span>

<span class="s0">420 15 get_over_region 0 4 550 29 MouseWatcher::get_over_region 0 3 155 156 157 443</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the smallest region the mouse is currently over, or NULL if it is</span>
 <span class="s0">* over no region.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the smallest region the indicated point is over, or NULL if it is</span>
 <span class="s0">* over no region.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the preferred region the mouse is over.  In the case of overlapping</span>
 <span class="s0">* regions, the region with the largest sort order is preferred; if two</span>
 <span class="s0">* regions have the same sort order, then the smaller region is preferred.</span>
 <span class="s0">*/</span>
<span class="s0">240</span>
<span class="s0">inline MouseWatcherRegion *MouseWatcher::get_over_region(void) const;</span>
<span class="s0">inline MouseWatcherRegion *MouseWatcher::get_over_region(PN_stdfloat x, PN_stdfloat y) const;</span>
<span class="s0">MouseWatcherRegion *MouseWatcher::get_over_region(LPoint2 const &amp;pos) const;</span>

<span class="s0">421 14 is_button_down 0 4 550 28 MouseWatcher::is_button_down 0 1 158 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated button is currently being held down, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline bool MouseWatcher::is_button_down(ButtonHandle button) const;</span>

<span class="s0">422 23 set_button_down_pattern 0 4 550 37 MouseWatcher::set_button_down_pattern 0 1 159 432</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a button is depressed.  This is a string that may contain any of the</span>
 <span class="s0">* following:</span>
 <span class="s0">*</span>
 <span class="s0">* %r  - the name of the region the mouse is over %b  - the name of the button</span>
 <span class="s0">* pressed.</span>
 <span class="s0">*</span>
 <span class="s0">* The event name will be based on the in_pattern string specified here, with</span>
 <span class="s0">* all occurrences of the above strings replaced with the corresponding</span>
 <span class="s0">* values.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline void MouseWatcher::set_button_down_pattern(std::string const &amp;pattern);</span>

<span class="s0">423 23 get_button_down_pattern 0 4 550 37 MouseWatcher::get_button_down_pattern 0 1 160 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when a</span>
 <span class="s0">* button is depressed.  See set_button_down_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline std::string const &amp;MouseWatcher::get_button_down_pattern(void) const;</span>

<span class="s0">424 21 set_button_up_pattern 0 4 550 35 MouseWatcher::set_button_up_pattern 0 1 161 145</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a button is released.  See set_button_down_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void MouseWatcher::set_button_up_pattern(std::string const &amp;pattern);</span>

<span class="s0">425 21 get_button_up_pattern 0 4 550 35 MouseWatcher::get_button_up_pattern 0 1 162 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when a</span>
 <span class="s0">* button is released.  See set_button_down_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline std::string const &amp;MouseWatcher::get_button_up_pattern(void) const;</span>

<span class="s0">426 25 set_button_repeat_pattern 0 4 550 39 MouseWatcher::set_button_repeat_pattern 0 1 163 477</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a button is continuously held and generates keyrepeat &quot;down&quot; events.</span>
 <span class="s0">* This is a string that may contain any of the following:</span>
 <span class="s0">*</span>
 <span class="s0">* %r  - the name of the region the mouse is over %b  - the name of the button</span>
 <span class="s0">* pressed.</span>
 <span class="s0">*</span>
 <span class="s0">* The event name will be based on the in_pattern string specified here, with</span>
 <span class="s0">* all occurrences of the above strings replaced with the corresponding</span>
 <span class="s0">* values.</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline void MouseWatcher::set_button_repeat_pattern(std::string const &amp;pattern);</span>

<span class="s0">427 25 get_button_repeat_pattern 0 4 550 39 MouseWatcher::get_button_repeat_pattern 0 1 164 197</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string that indicates how event names are names are generated</span>
 <span class="s0">* when a button is continuously held and generates keyrepeat &quot;down&quot; events.</span>
 <span class="s0">* See set_button_repeat_pattern().</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline std::string const &amp;MouseWatcher::get_button_repeat_pattern(void) const;</span>

<span class="s0">428 17 set_enter_pattern 0 4 550 31 MouseWatcher::set_enter_pattern 0 1 165 289</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when the mouse enters a region.  This is different from within_pattern, in</span>
 <span class="s0">* that a mouse is only &quot;entered&quot; in the topmost region at a given time, while</span>
 <span class="s0">* it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void MouseWatcher::set_enter_pattern(std::string const &amp;pattern);</span>

<span class="s0">429 17 get_enter_pattern 0 4 550 31 MouseWatcher::get_enter_pattern 0 1 166 280</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when the</span>
 <span class="s0">* mouse enters a region.  This is different from within_pattern, in that a</span>
 <span class="s0">* mouse is only &quot;entered&quot; in the topmost region at a given time, while it</span>
 <span class="s0">* might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline std::string const &amp;MouseWatcher::get_enter_pattern(void) const;</span>

<span class="s0">430 17 set_leave_pattern 0 4 550 31 MouseWatcher::set_leave_pattern 0 1 167 290</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when the mouse leaves a region.  This is different from without_pattern, in</span>
 <span class="s0">* that a mouse is only &quot;entered&quot; in the topmost region at a given time, while</span>
 <span class="s0">* it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void MouseWatcher::set_leave_pattern(std::string const &amp;pattern);</span>

<span class="s0">431 17 get_leave_pattern 0 4 550 31 MouseWatcher::get_leave_pattern 0 1 168 281</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when the</span>
 <span class="s0">* mouse leaves a region.  This is different from without_pattern, in that a</span>
 <span class="s0">* mouse is only &quot;entered&quot; in the topmost region at a given time, while it</span>
 <span class="s0">* might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline std::string const &amp;MouseWatcher::get_leave_pattern(void) const;</span>

<span class="s0">432 18 set_within_pattern 0 4 550 32 MouseWatcher::set_within_pattern 0 1 169 294</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when the mouse wanders over a region.  This is different from</span>
 <span class="s0">* enter_pattern, in that a mouse is only &quot;entered&quot; in the topmost region at a</span>
 <span class="s0">* given time, while it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline void MouseWatcher::set_within_pattern(std::string const &amp;pattern);</span>

<span class="s0">433 18 get_within_pattern 0 4 550 32 MouseWatcher::get_within_pattern 0 1 170 285</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when the</span>
 <span class="s0">* mouse wanders over a region.  This is different from enter_pattern, in that</span>
 <span class="s0">* a mouse is only &quot;entered&quot; in the topmost region at a given time, while it</span>
 <span class="s0">* might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline std::string const &amp;MouseWatcher::get_within_pattern(void) const;</span>

<span class="s0">434 19 set_without_pattern 0 4 550 33 MouseWatcher::set_without_pattern 0 1 171 296</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when the mouse wanders out of a region.  This is different from</span>
 <span class="s0">* leave_pattern, in that a mouse is only &quot;entered&quot; in the topmost region at a</span>
 <span class="s0">* given time, while it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void MouseWatcher::set_without_pattern(std::string const &amp;pattern);</span>

<span class="s0">435 19 get_without_pattern 0 4 550 33 MouseWatcher::get_without_pattern 0 1 172 287</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when the</span>
 <span class="s0">* mouse wanders out of a region.  This is different from leave_pattern, in</span>
 <span class="s0">* that a mouse is only &quot;entered&quot; in the topmost region at a given time, while</span>
 <span class="s0">* it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline std::string const &amp;MouseWatcher::get_without_pattern(void) const;</span>

<span class="s0">436 12 set_geometry 0 4 550 26 MouseWatcher::set_geometry 0 1 173 279</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the node that will be transformed each frame by the mouse's</span>
 <span class="s0">* coordinates.  It will also be hidden when the mouse goes outside the</span>
 <span class="s0">* window.  This can be used to implement a software mouse pointer for when a</span>
 <span class="s0">* hardware (or system) mouse pointer is unavailable.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void MouseWatcher::set_geometry(PandaNode *node);</span>

<span class="s0">437 12 has_geometry 0 4 550 26 MouseWatcher::has_geometry 0 1 174 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if a software mouse pointer has been setup via set_geometry(),</span>
 <span class="s0">* or false otherwise.  See set_geometry().</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool MouseWatcher::has_geometry(void) const;</span>

<span class="s0">438 12 get_geometry 0 4 550 26 MouseWatcher::get_geometry 0 1 175 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node that has been set as the software mouse pointer, or NULL</span>
 <span class="s0">* if no node has been set.  See has_geometry() and set_geometry().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PandaNode *MouseWatcher::get_geometry(void) const;</span>

<span class="s0">439 14 clear_geometry 0 4 550 28 MouseWatcher::clear_geometry 0 1 176 74</span>
<span class="s0">/**</span>
 <span class="s0">* Stops the use of the software cursor set up via set_geometry().</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void MouseWatcher::clear_geometry(void);</span>

<span class="s0">440 17 set_extra_handler 0 4 550 31 MouseWatcher::set_extra_handler 0 1 177 150</span>
<span class="s0">/**</span>
 <span class="s0">* As an optimization for the C++ Gui, an extra handler can be registered with</span>
 <span class="s0">* a mouseWatcher so that events can be dealt with much sooner.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void MouseWatcher::set_extra_handler(EventHandler *eh);</span>

<span class="s0">441 17 get_extra_handler 0 4 550 31 MouseWatcher::get_extra_handler 0 1 178 150</span>
<span class="s0">/**</span>
 <span class="s0">* As an optimization for the C++ Gui, an extra handler can be registered with</span>
 <span class="s0">* a mouseWatcher so that events can be dealt with much sooner.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline EventHandler *MouseWatcher::get_extra_handler(void) const;</span>

<span class="s0">442 20 set_modifier_buttons 0 4 550 34 MouseWatcher::set_modifier_buttons 0 1 179 125</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the buttons that should be monitored as modifier buttons for</span>
 <span class="s0">* generating events to the MouseWatcherRegions.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void MouseWatcher::set_modifier_buttons(ModifierButtons const &amp;mods);</span>

<span class="s0">443 20 get_modifier_buttons 0 4 550 34 MouseWatcher::get_modifier_buttons 0 1 180 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of buttons that are being monitored as modifier buttons, as</span>
 <span class="s0">* well as their current state.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline ModifierButtons MouseWatcher::get_modifier_buttons(void) const;</span>

<span class="s0">444 18 set_display_region 0 4 550 32 MouseWatcher::set_display_region 0 1 181 402</span>
<span class="s0">/**</span>
 <span class="s0">* Constrains the MouseWatcher to watching the mouse within a particular</span>
 <span class="s0">* indicated region of the screen.  DataNodes parented under the MouseWatcher</span>
 <span class="s0">* will observe the mouse and keyboard events only when the mouse is within</span>
 <span class="s0">* the indicated region, and the observed range will be from -1 .. 1 across</span>
 <span class="s0">* the region.</span>
 <span class="s0">*</span>
 <span class="s0">* Do not delete the DisplayRegion while it is owned by the MouseWatcher.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void MouseWatcher::set_display_region(DisplayRegion *dr);</span>

<span class="s0">445 20 clear_display_region 0 4 550 34 MouseWatcher::clear_display_region 0 1 182 144</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the display region constraint from the MouseWatcher, and restores</span>
 <span class="s0">* it to the default behavior of watching the whole window.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void MouseWatcher::clear_display_region(void);</span>

<span class="s0">446 18 get_display_region 0 4 550 32 MouseWatcher::get_display_region 0 1 183 134</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the display region the MouseWatcher is constrained to by</span>
 <span class="s0">* set_display_region(), or NULL if it is not constrained.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline DisplayRegion *MouseWatcher::get_display_region(void) const;</span>

<span class="s0">447 18 has_display_region 0 4 550 32 MouseWatcher::has_display_region 0 1 184 245</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the MouseWatcher has been constrained to a particular</span>
 <span class="s0">* region of the screen via set_display_region(), or false otherwise.  If this</span>
 <span class="s0">* returns true, get_display_region() may be used to return the particular</span>
 <span class="s0">* region.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool MouseWatcher::has_display_region(void) const;</span>

<span class="s0">448 9 add_group 0 4 550 23 MouseWatcher::add_group 0 1 185 496</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated group of regions to the set of regions the MouseWatcher</span>
 <span class="s0">* will monitor each frame.</span>
 <span class="s0">*</span>
 <span class="s0">* Since the MouseWatcher itself inherits from MouseWatcherBase, this</span>
 <span class="s0">* operation is normally not necessary--you can simply add the Regions you</span>
 <span class="s0">* care about one at a time.  Adding a complete group is useful when you may</span>
 <span class="s0">* want to explicitly remove the regions as a group later.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the group was successfully added, or false if it was</span>
 <span class="s0">* already on the list.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool MouseWatcher::add_group(MouseWatcherGroup *group);</span>

<span class="s0">449 12 remove_group 0 4 550 26 MouseWatcher::remove_group 0 1 186 214</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the indicated group from the set of extra groups associated with</span>
 <span class="s0">* the MouseWatcher.  Returns true if successful, or false if the group was</span>
 <span class="s0">* already removed or was never added via add_group().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">bool MouseWatcher::remove_group(MouseWatcherGroup *group);</span>

<span class="s0">450 13 replace_group 0 4 550 27 MouseWatcher::replace_group 0 1 187 362</span>
<span class="s0">/**</span>
 <span class="s0">* Atomically removes old_group from the MouseWatcher, and replaces it with</span>
 <span class="s0">* new_group.  Presumably old_group and new_group might have some regions in</span>
 <span class="s0">* common; these are handled properly.</span>
 <span class="s0">*</span>
 <span class="s0">* If old_group is not already present, simply adds new_group and returns</span>
 <span class="s0">* false.  Otherwise, removes old_group and adds new_group, and then returns</span>
 <span class="s0">* true.</span>
 <span class="s0">*/</span>
<span class="s0">93</span>
<span class="s0">bool MouseWatcher::replace_group(MouseWatcherGroup *old_group, MouseWatcherGroup *new_group);</span>

<span class="s0">451 14 get_num_groups 0 4 550 28 MouseWatcher::get_num_groups 0 1 188 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of separate groups added to the MouseWatcher via</span>
 <span class="s0">* add_group().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">int MouseWatcher::get_num_groups(void) const;</span>

<span class="s0">452 9 get_group 0 4 550 23 MouseWatcher::get_group 0 1 189 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth group added to the MouseWatcher via add_group().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">MouseWatcherGroup *MouseWatcher::get_group(int n) const;</span>

<span class="s0">453 22 set_inactivity_timeout 0 4 550 36 MouseWatcher::set_inactivity_timeout 0 1 190 480</span>
<span class="s0">/**</span>
 <span class="s0">* Sets an inactivity timeout on the mouse activity.  When this timeout (in</span>
 <span class="s0">* seconds) is exceeded with no keyboard or mouse activity, all currently-held</span>
 <span class="s0">* buttons are automatically released.  This is intended to help protect</span>
 <span class="s0">* against people who inadvertently (or intentionally) leave a keyboard key</span>
 <span class="s0">* stuck down and then wander away from the keyboard.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, when this timeout expires, the event specified by</span>
 <span class="s0">* set_inactivity_timeout_event() will be generated.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void MouseWatcher::set_inactivity_timeout(double timeout);</span>

<span class="s0">454 22 has_inactivity_timeout 0 4 550 36 MouseWatcher::has_inactivity_timeout 0 1 191 79</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if an inactivity timeout has been set, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool MouseWatcher::has_inactivity_timeout(void) const;</span>

<span class="s0">455 22 get_inactivity_timeout 0 4 550 36 MouseWatcher::get_inactivity_timeout 0 1 192 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the inactivity timeout that has been set.  It is an error to call</span>
 <span class="s0">* this if has_inactivity_timeout() returns false.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline double MouseWatcher::get_inactivity_timeout(void) const;</span>

<span class="s0">456 24 clear_inactivity_timeout 0 4 550 38 MouseWatcher::clear_inactivity_timeout 0 1 193 141</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the inactivity timeout and restores the MouseWatcher to its default</span>
 <span class="s0">* behavior of allowing a key to be held indefinitely.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void MouseWatcher::clear_inactivity_timeout(void);</span>

<span class="s0">457 28 set_inactivity_timeout_event 0 4 550 42 MouseWatcher::set_inactivity_timeout_event 0 1 194 139</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the event string that will be generated when the inactivity</span>
 <span class="s0">* timeout counter expires.  See set_inactivity_timeout().</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline void MouseWatcher::set_inactivity_timeout_event(std::string const &amp;event);</span>

<span class="s0">458 28 get_inactivity_timeout_event 0 4 550 42 MouseWatcher::get_inactivity_timeout_event 0 1 195 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the event string that will be generated when the inactivity timeout</span>
 <span class="s0">* counter expires.  See set_inactivity_timeout().</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline std::string const &amp;MouseWatcher::get_inactivity_timeout_event(void) const;</span>

<span class="s0">459 13 get_trail_log 0 4 550 27 MouseWatcher::get_trail_log 0 1 196 395</span>
<span class="s0">/**</span>
 <span class="s0">* Obtain the mouse trail log.  This is a PointerEventList.  Does not make a</span>
 <span class="s0">* copy, therefore, this PointerEventList will be updated each time</span>
 <span class="s0">* process_events gets called.</span>
 <span class="s0">*</span>
 <span class="s0">* To use trail logging, you need to enable the generation of pointer events</span>
 <span class="s0">* in the GraphicsWindowInputDevice and set the trail log duration in the</span>
 <span class="s0">* MouseWatcher.  Otherwise, the trail log will be empty.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline ConstPointerTo&lt; PointerEventList &gt; MouseWatcher::get_trail_log(void) const;</span>

<span class="s0">460 16 num_trail_recent 0 4 550 30 MouseWatcher::num_trail_recent 0 1 197 174</span>
<span class="s0">/**</span>
 <span class="s0">* This counter indicates how many events were added to the trail log this</span>
 <span class="s0">* frame.  The trail log is updated once per frame, during the process_events</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t MouseWatcher::num_trail_recent(void) const;</span>

<span class="s0">461 22 set_trail_log_duration 0 4 550 36 MouseWatcher::set_trail_log_duration 0 1 198 198</span>
<span class="s0">/**</span>
 <span class="s0">* If the duration is nonzero, causes the MouseWatcher to log the mouse's</span>
 <span class="s0">* trail.  Events older than the specified duration are discarded.  If the</span>
 <span class="s0">* duration is zero, logging is disabled.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void MouseWatcher::set_trail_log_duration(double duration);</span>

<span class="s0">462 14 get_trail_node 0 4 550 28 MouseWatcher::get_trail_node 0 1 199 618</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a GeomNode that represents the mouse trail.  The intent is that you</span>
 <span class="s0">* should reparent this GeomNode to Render2D, and then forget about it.  The</span>
 <span class="s0">* MouseWatcher will continually update the trail node.  There is only one</span>
 <span class="s0">* trail node, it does not create a new one each time you call get_trail_node.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not a particularly beautiful way to render a mouse trail.  It is</span>
 <span class="s0">* intended more for debugging purposes than for finished applications.  Even</span>
 <span class="s0">* so, It is suggested that you might want to apply a line thickness and</span>
 <span class="s0">* antialias mode to the line --- doing so makes it look a lot better.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">PointerTo&lt; GeomNode &gt; MouseWatcher::get_trail_node(void);</span>

<span class="s0">463 16 clear_trail_node 0 4 550 30 MouseWatcher::clear_trail_node 0 1 200 256</span>
<span class="s0">/**</span>
 <span class="s0">* If you have previously fetched the trail node using get_trail_node, then</span>
 <span class="s0">* the MouseWatcher is continually updating the trail node every frame.  Using</span>
 <span class="s0">* clear_trail_node causes the MouseWatcher to forget the trail node and stop</span>
 <span class="s0">* updating it.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void MouseWatcher::clear_trail_node(void);</span>

<span class="s0">464 15 clear_trail_log 0 4 550 29 MouseWatcher::clear_trail_log 0 1 201 117</span>
<span class="s0">/**</span>
 <span class="s0">* Clears the mouse trail log.  This does not prevent further accumulation of</span>
 <span class="s0">* the log given future events.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void MouseWatcher::clear_trail_log(void);</span>

<span class="s0">465 13 note_activity 0 4 550 27 MouseWatcher::note_activity 0 1 202 586</span>
<span class="s0">/**</span>
 <span class="s0">* Can be used in conjunction with the inactivity timeout to inform the</span>
 <span class="s0">* MouseWatcher that the user has just performed some action which proves</span>
 <span class="s0">* he/she is present.  It may be necessary to call this for external events,</span>
 <span class="s0">* such as joystick action, that the MouseWatcher might otherwise not know</span>
 <span class="s0">* about.  This will reset the current inactivity timer.  When the inactivity</span>
 <span class="s0">* timer reaches the length of time specified by set_inactivity_timeout(),</span>
 <span class="s0">* with no keyboard or mouse activity and no calls to note_activity(), then</span>
 <span class="s0">* any buttons held will be automatically released.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">void MouseWatcher::note_activity(void);</span>

<span class="s0">466 14 get_class_type 0 4 550 28 MouseWatcher::get_class_type 0 1 203 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle MouseWatcher::get_class_type(void);</span>

<span class="s0">467 22 ~MouseWatcherParameter 0 516 551 45 MouseWatcherParameter::~MouseWatcherParameter 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline MouseWatcherParameter::~MouseWatcherParameter(void);</span>

<span class="s0">468 10 has_button 0 4 551 33 MouseWatcherParameter::has_button 0 1 206 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this parameter has an associated mouse or keyboard button,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool MouseWatcherParameter::has_button(void) const;</span>

<span class="s0">469 10 get_button 0 4 551 33 MouseWatcherParameter::get_button 0 1 207 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the mouse or keyboard button associated with this event.  If</span>
 <span class="s0">* has_button(), above, returns false, this returns ButtonHandle::none().</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline ButtonHandle MouseWatcherParameter::get_button(void) const;</span>

<span class="s0">470 12 is_keyrepeat 0 4 551 35 MouseWatcherParameter::is_keyrepeat 0 1 208 126</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the button-down even was generated due to keyrepeat, or</span>
 <span class="s0">* false if it was an original button down.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool MouseWatcherParameter::is_keyrepeat(void) const;</span>

<span class="s0">471 11 has_keycode 0 4 551 34 MouseWatcherParameter::has_keycode 0 1 209 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this parameter has an associated keycode, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool MouseWatcherParameter::has_keycode(void) const;</span>

<span class="s0">472 11 get_keycode 0 4 551 34 MouseWatcherParameter::get_keycode 0 1 210 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the keycode associated with this event.  If has_keycode(), above,</span>
 <span class="s0">* returns false, this returns 0.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int MouseWatcherParameter::get_keycode(void) const;</span>

<span class="s0">473 13 has_candidate 0 4 551 36 MouseWatcherParameter::has_candidate 0 1 211 97</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this parameter has an associated candidate string, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline bool MouseWatcherParameter::has_candidate(void) const;</span>

<span class="s0">474 28 get_candidate_string_encoded 0 4 551 51 MouseWatcherParameter::get_candidate_string_encoded 0 2 212 213 290</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the candidate string associated with this event.  If</span>
 <span class="s0">* has_candidate(), above, returns false, this returns the empty string.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the candidate string associated with this event.  If</span>
 <span class="s0">* has_candidate(), above, returns false, this returns the empty string.</span>
 <span class="s0">*/</span>
<span class="s0">193</span>
<span class="s0">inline std::string MouseWatcherParameter::get_candidate_string_encoded(void) const;</span>
<span class="s0">inline std::string MouseWatcherParameter::get_candidate_string_encoded(TextEncoder::Encoding encoding) const;</span>

<span class="s0">475 19 get_highlight_start 0 4 551 42 MouseWatcherParameter::get_highlight_start 0 1 214 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first highlighted character in the candidate string.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline std::size_t MouseWatcherParameter::get_highlight_start(void) const;</span>

<span class="s0">476 17 get_highlight_end 0 4 551 40 MouseWatcherParameter::get_highlight_end 0 1 215 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns one more than the last highlighted character in the candidate</span>
 <span class="s0">* string.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline std::size_t MouseWatcherParameter::get_highlight_end(void) const;</span>

<span class="s0">477 14 get_cursor_pos 0 4 551 37 MouseWatcherParameter::get_cursor_pos 0 1 216 86</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the position of the user's edit cursor within the candidate string.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline std::size_t MouseWatcherParameter::get_cursor_pos(void) const;</span>

<span class="s0">478 20 get_modifier_buttons 0 4 551 43 MouseWatcherParameter::get_modifier_buttons 0 1 217 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of modifier buttons that were being held down while the</span>
 <span class="s0">* event was generated.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline ModifierButtons const &amp;MouseWatcherParameter::get_modifier_buttons(void) const;</span>

<span class="s0">479 9 has_mouse 0 4 551 32 MouseWatcherParameter::has_mouse 0 1 218 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this parameter has an associated mouse position, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline bool MouseWatcherParameter::has_mouse(void) const;</span>

<span class="s0">480 9 get_mouse 0 4 551 32 MouseWatcherParameter::get_mouse 0 1 219 176</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the mouse position at the time the event was generated, in the</span>
 <span class="s0">* normalized range (-1 .. 1).  It is valid to call this only if has_mouse()</span>
 <span class="s0">* returned true.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline LPoint2 const &amp;MouseWatcherParameter::get_mouse(void) const;</span>

<span class="s0">481 10 is_outside 0 4 551 33 MouseWatcherParameter::is_outside 0 1 220 163</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the mouse was outside the region at the time the event was</span>
 <span class="s0">* generated, false otherwise.  This is only valid for &quot;release&quot; type events.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool MouseWatcherParameter::is_outside(void) const;</span>

<span class="s0">482 6 output 0 4 551 29 MouseWatcherParameter::output 0 1 221 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void MouseWatcherParameter::output(std::ostream &amp;out) const;</span>

<span class="s0">483 9 Trackball 0 260 552 20 Trackball::Trackball 0 2 222 223 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">113</span>
<span class="s0">explicit Trackball::Trackball(std::string const &amp;name);</span>
<span class="s0">inline Trackball::Trackball(Trackball const &amp;) = default;</span>

<span class="s0">484 5 reset 0 4 552 16 Trackball::reset 0 1 224 52</span>
<span class="s0">/**</span>
 <span class="s0">* Reinitializes all transforms to identity.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">void Trackball::reset(void);</span>

<span class="s0">485 17 get_forward_scale 0 4 552 28 Trackball::get_forward_scale 0 1 225 104</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the scale factor applied to forward and backward motion.  See</span>
 <span class="s0">* set_forward_scale().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">PN_stdfloat Trackball::get_forward_scale(void) const;</span>

<span class="s0">486 17 set_forward_scale 0 4 552 28 Trackball::set_forward_scale 0 1 226 173</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the scale factor applied to forward and backward motion.  The</span>
 <span class="s0">* larger this number, the faster the model will move in response to dollying</span>
 <span class="s0">* in and out.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void Trackball::set_forward_scale(PN_stdfloat fwdscale);</span>

<span class="s0">487 7 get_pos 0 4 552 18 Trackball::get_pos 0 1 227 57</span>
<span class="s0">/**</span>
 <span class="s0">* Return the offset from the center of rotation.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">LPoint3 const &amp;Trackball::get_pos(void) const;</span>

<span class="s0">488 5 get_x 0 4 552 16 Trackball::get_x 0 1 228 0</span>
<span class="s0">41</span>
<span class="s0">PN_stdfloat Trackball::get_x(void) const;</span>

<span class="s0">489 5 get_y 0 4 552 16 Trackball::get_y 0 1 229 0</span>
<span class="s0">41</span>
<span class="s0">PN_stdfloat Trackball::get_y(void) const;</span>

<span class="s0">490 5 get_z 0 4 552 16 Trackball::get_z 0 1 230 0</span>
<span class="s0">41</span>
<span class="s0">PN_stdfloat Trackball::get_z(void) const;</span>

<span class="s0">491 7 set_pos 0 4 552 18 Trackball::set_pos 0 2 231 232 62</span>
<span class="s0">/**</span>
 <span class="s0">* Directly set the offset from the rotational origin.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">void Trackball::set_pos(LVecBase3 const &amp;vec);</span>
<span class="s0">void Trackball::set_pos(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">492 5 set_x 0 4 552 16 Trackball::set_x 0 1 233 0</span>
<span class="s0">37</span>
<span class="s0">void Trackball::set_x(PN_stdfloat x);</span>

<span class="s0">493 5 set_y 0 4 552 16 Trackball::set_y 0 1 234 0</span>
<span class="s0">37</span>
<span class="s0">void Trackball::set_y(PN_stdfloat y);</span>

<span class="s0">494 5 set_z 0 4 552 16 Trackball::set_z 0 1 235 0</span>
<span class="s0">37</span>
<span class="s0">void Trackball::set_z(PN_stdfloat z);</span>

<span class="s0">495 7 get_hpr 0 4 552 18 Trackball::get_hpr 0 1 236 46</span>
<span class="s0">/**</span>
 <span class="s0">* Return the trackball's orientation.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">LVecBase3 Trackball::get_hpr(void) const;</span>

<span class="s0">496 5 get_h 0 4 552 16 Trackball::get_h 0 1 237 0</span>
<span class="s0">41</span>
<span class="s0">PN_stdfloat Trackball::get_h(void) const;</span>

<span class="s0">497 5 get_p 0 4 552 16 Trackball::get_p 0 1 238 0</span>
<span class="s0">41</span>
<span class="s0">PN_stdfloat Trackball::get_p(void) const;</span>

<span class="s0">498 5 get_r 0 4 552 16 Trackball::get_r 0 1 239 0</span>
<span class="s0">41</span>
<span class="s0">PN_stdfloat Trackball::get_r(void) const;</span>

<span class="s0">499 7 set_hpr 0 4 552 18 Trackball::set_hpr 0 2 240 241 48</span>
<span class="s0">/**</span>
 <span class="s0">* Directly set the mover's orientation.</span>
 <span class="s0">*/</span>
<span class="s0">116</span>
<span class="s0">void Trackball::set_hpr(LVecBase3 const &amp;hpr);</span>
<span class="s0">void Trackball::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);</span>

<span class="s0">500 5 set_h 0 4 552 16 Trackball::set_h 0 1 242 0</span>
<span class="s0">37</span>
<span class="s0">void Trackball::set_h(PN_stdfloat h);</span>

<span class="s0">501 5 set_p 0 4 552 16 Trackball::set_p 0 1 243 0</span>
<span class="s0">37</span>
<span class="s0">void Trackball::set_p(PN_stdfloat p);</span>

<span class="s0">502 5 set_r 0 4 552 16 Trackball::set_r 0 1 244 0</span>
<span class="s0">37</span>
<span class="s0">void Trackball::set_r(PN_stdfloat r);</span>

<span class="s0">503 17 reset_origin_here 0 4 552 28 Trackball::reset_origin_here 0 1 245 148</span>
<span class="s0">/**</span>
 <span class="s0">* Reposition the center of rotation to coincide with the current translation</span>
 <span class="s0">* offset.  Future rotations will be about the current origin.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">void Trackball::reset_origin_here(void);</span>

<span class="s0">504 11 move_origin 0 4 552 22 Trackball::move_origin 0 1 246 60</span>
<span class="s0">/**</span>
 <span class="s0">* Moves the center of rotation by the given amount.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">void Trackball::move_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);</span>

<span class="s0">505 10 get_origin 0 4 552 21 Trackball::get_origin 0 1 247 50</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current center of rotation.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">LPoint3 Trackball::get_origin(void) const;</span>

<span class="s0">506 10 set_origin 0 4 552 21 Trackball::set_origin 0 1 248 48</span>
<span class="s0">/**</span>
 <span class="s0">* Directly sets the center of rotation.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void Trackball::set_origin(LVecBase3 const &amp;origin);</span>

<span class="s0">507 16 set_control_mode 0 4 552 27 Trackball::set_control_mode 0 1 249 348</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the control mode.  Normally this is CM_default, which means each mouse</span>
 <span class="s0">* button serves its normal function.  When it is CM_truck, CM_pan, CM_dolly,</span>
 <span class="s0">* or CM_roll, all of the mouse buttons serve the indicated function instead</span>
 <span class="s0">* of their normal function.  This can be used in conjunction with some</span>
 <span class="s0">* external way of changing modes.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">void Trackball::set_control_mode(Trackball::ControlMode control_mode);</span>

<span class="s0">508 16 get_control_mode 0 4 552 27 Trackball::get_control_mode 0 1 250 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the control mode.  See set_control_mode().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">Trackball::ControlMode Trackball::get_control_mode(void) const;</span>

<span class="s0">509 10 set_invert 0 4 552 21 Trackball::set_invert 0 1 251 162</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the invert flag.  When this is set, the inverse matrix is generated,</span>
 <span class="s0">* suitable for joining to a camera, instead of parenting the scene under it.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void Trackball::set_invert(bool flag);</span>

<span class="s0">510 10 get_invert 0 4 552 21 Trackball::get_invert 0 1 252 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the invert flag.  When this is set, the inverse matrix is</span>
 <span class="s0">* generated, suitable for joining to a camera, instead of parenting the scene</span>
 <span class="s0">* under it.</span>
 <span class="s0">*/</span>
<span class="s0">39</span>
<span class="s0">bool Trackball::get_invert(void) const;</span>

<span class="s0">511 10 set_rel_to 0 4 552 21 Trackball::set_rel_to 0 1 253 275</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the NodePath that all trackball manipulations are to be assumed to be</span>
 <span class="s0">* relative to.  For instance, set your camera node here to make the trackball</span>
 <span class="s0">* motion camera relative.  The default is the empty path, which means</span>
 <span class="s0">* trackball motion is in global space.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void Trackball::set_rel_to(NodePath const &amp;rel_to);</span>

<span class="s0">512 10 get_rel_to 0 4 552 21 Trackball::get_rel_to 0 1 254 103</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the NodePath that all trackball manipulations are relative to, or</span>
 <span class="s0">* the empty path.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">NodePath const &amp;Trackball::get_rel_to(void) const;</span>

<span class="s0">513 21 set_coordinate_system 0 4 552 32 Trackball::set_coordinate_system 0 1 255 243</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the coordinate system of the Trackball.  Normally, this is the default</span>
 <span class="s0">* coordinate system.  This changes the axes the Trackball manipulates so that</span>
 <span class="s0">* the user interface remains consistent across different coordinate systems.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void Trackball::set_coordinate_system(CoordinateSystem cs);</span>

<span class="s0">514 21 get_coordinate_system 0 4 552 32 Trackball::get_coordinate_system 0 1 256 91</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the coordinate system of the Trackball.  See</span>
 <span class="s0">* set_coordinate_system().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">CoordinateSystem Trackball::get_coordinate_system(void) const;</span>

<span class="s0">515 7 set_mat 0 4 552 18 Trackball::set_mat 0 1 257 131</span>
<span class="s0">/**</span>
 <span class="s0">* Stores the indicated transform in the trackball.  This is a transform in</span>
 <span class="s0">* global space, regardless of the rel_to node.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void Trackball::set_mat(LMatrix4 const &amp;mat);</span>

<span class="s0">516 7 get_mat 0 4 552 18 Trackball::get_mat 0 1 258 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the matrix represented by the trackball rotation.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">LMatrix4 const &amp;Trackball::get_mat(void) const;</span>

<span class="s0">517 13 get_trans_mat 0 4 552 24 Trackball::get_trans_mat 0 1 259 143</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the actual transform that will be applied to the scene graph.  This</span>
 <span class="s0">* is the same as get_mat(), unless invert is in effect.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">LMatrix4 const &amp;Trackball::get_trans_mat(void) const;</span>

<span class="s0">518 14 get_class_type 0 4 552 25 Trackball::get_class_type 0 1 260 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle Trackball::get_class_type(void);</span>

<span class="s0">519 12 Transform2SG 0 260 554 26 Transform2SG::Transform2SG 0 2 261 262 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">128</span>
<span class="s0">explicit Transform2SG::Transform2SG(std::string const &amp;name);</span>
<span class="s0">inline Transform2SG::Transform2SG(Transform2SG const &amp;) = default;</span>

<span class="s0">520 8 set_node 0 4 554 22 Transform2SG::set_node 0 1 263 54</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the node that this object will adjust.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void Transform2SG::set_node(PandaNode *node);</span>

<span class="s0">521 8 get_node 0 4 554 22 Transform2SG::get_node 0 1 264 102</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the node that this object will adjust, or NULL if the node has not</span>
 <span class="s0">* yet been set.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">PandaNode *Transform2SG::get_node(void) const;</span>

<span class="s0">522 14 get_class_type 0 4 554 28 Transform2SG::get_class_type 0 1 265 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle Transform2SG::get_class_type(void);</span>

<span class="s0">523 13 ~Transform2SG 0 516 554 27 Transform2SG::~Transform2SG 0 0 0</span>
<span class="s0">34</span>
<span class="s0">Transform2SG::~Transform2SG(void);</span>

<span class="s0">265</span>
<span class="s0">1 0 0 15 3 557 0 0 0 1 6 param0 0 555  </span>
<span class="s0">2 0 0 7 3 557 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 558  </span>
<span class="s0">3 0 0 4 4 559 0 0 510 /**</span>
 <span class="s0">* Specifies the generic event that is generated (if any) each time a key or</span>
 <span class="s0">* button is depressed.  Unlike the specific events that are unique to each</span>
 <span class="s0">* key, this same event name is used for *all* button events, and the name of</span>
 <span class="s0">* the button pressed (possibly with modifier prefixes) will be sent as a</span>
 <span class="s0">* parameter.</span>
 <span class="s0">*</span>
 <span class="s0">* If this string is empty, no event is generated.  It is possible to generate</span>
 <span class="s0">* both generic events and specific events for the same button.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_keystroke_event().</span>
 <span class="s0">*/ 2 4 this 3 557  17 button_down_event 1 558  </span>
<span class="s0">4 0 0 6 5 558 0 0 114 /**</span>
 <span class="s0">* Returns the button_down_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_button_down_event().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">5 0 0 4 6 559 0 0 137 /**</span>
 <span class="s0">* Specifies the generic event that is generated (if any) each time a key or</span>
 <span class="s0">* button is released.  See set_button_down_event().</span>
 <span class="s0">*/ 2 4 this 3 557  15 button_up_event 1 558  </span>
<span class="s0">6 0 0 6 7 558 0 0 110 /**</span>
 <span class="s0">* Returns the button_up_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_button_up_event().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">7 0 0 4 8 559 0 0 517 /**</span>
 <span class="s0">* Specifies the generic event that is generated (if any) repeatedly while a</span>
 <span class="s0">* key or button is held down.  Unlike the specific events that are unique to</span>
 <span class="s0">* each key, this same event name is used for *all* button events, and the</span>
 <span class="s0">* name of the button pressed (possibly with modifier prefixes) will be sent</span>
 <span class="s0">* as a parameter.</span>
 <span class="s0">*</span>
 <span class="s0">* If this string is empty, no event is generated.  It is possible to generate</span>
 <span class="s0">* both generic events and specific events for the same button.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_keystroke_event().</span>
 <span class="s0">*/ 2 4 this 3 557  19 button_repeat_event 1 558  </span>
<span class="s0">8 0 0 6 9 558 0 0 117 /**</span>
 <span class="s0">* Returns the button_repeat_event that has been set on this ButtonThrower.</span>
 <span class="s0">* See set_button_repeat_event().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">9 0 0 4 10 559 0 0 846 /**</span>
 <span class="s0">* Specifies the event that is generated (if any) for each keystroke that is</span>
 <span class="s0">* received.  A keystroke is different than a button event: it represents the</span>
 <span class="s0">* semantic meaning of the sequence of keys that have been pressed.  For</span>
 <span class="s0">* instance, pressing shift and 4 together will generate the button event</span>
 <span class="s0">* &quot;shift-4&quot;, but it will generate the keystroke &quot;$&quot;.</span>
 <span class="s0">*</span>
 <span class="s0">* If a key is held down, keyrepeat will cause the same keystroke event to be</span>
 <span class="s0">* generated repeatedly.  This is different from the corresponding down event,</span>
 <span class="s0">* which will only be generated once, followed by a number of button repeat</span>
 <span class="s0">* events.</span>
 <span class="s0">*</span>
 <span class="s0">* This event is generated with a single wstring parameter, which is a one-</span>
 <span class="s0">* character string that contains the keystroke generated.  If this event</span>
 <span class="s0">* string is empty, no event is generated.</span>
 <span class="s0">*</span>
 <span class="s0">* See also set_button_down_event().</span>
 <span class="s0">*/ 2 4 this 3 557  15 keystroke_event 1 558  </span>
<span class="s0">10 0 0 6 11 558 0 0 110 /**</span>
 <span class="s0">* Returns the keystroke_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_keystroke_event().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">11 0 0 4 12 559 0 0 804 /**</span>
 <span class="s0">* Specifies the event that is generated (if any) for each IME candidate</span>
 <span class="s0">* string event received.  Events of this nature are received only when the</span>
 <span class="s0">* user is entering data using a Microsoft Input Method Editor, typically used</span>
 <span class="s0">* for Asian languages such as Japanese or Korean.</span>
 <span class="s0">*</span>
 <span class="s0">* If you are designing a typing user interface, you should track this event</span>
 <span class="s0">* to support the use of the IME.  In response to this event, you should</span>
 <span class="s0">* display the candidate string in the entry box, with the appropriate</span>
 <span class="s0">* sections highlighted, so the user can scroll through the available choices.</span>
 <span class="s0">*</span>
 <span class="s0">* This event is generated with four parameters, in order: the candidate</span>
 <span class="s0">* string, the character at which to start the highlight, the character at</span>
 <span class="s0">* which to end the highlight, and the current cursor position.</span>
 <span class="s0">*/ 2 4 this 3 557  15 candidate_event 1 558  </span>
<span class="s0">12 0 0 6 13 558 0 0 110 /**</span>
 <span class="s0">* Returns the candidate_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_candidate_event().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">13 0 0 4 14 559 0 0 108 /**</span>
 <span class="s0">* Specifies the event that is generated (if any) each time the mouse is moved</span>
 <span class="s0">* within the window.</span>
 <span class="s0">*/ 2 4 this 3 557  10 move_event 1 558  </span>
<span class="s0">14 0 0 6 15 558 0 0 100 /**</span>
 <span class="s0">* Returns the move_event that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_move_event().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">15 0 0 4 16 559 0 0 192 /**</span>
 <span class="s0">* Like set_button_down_event, but uses the raw, untransformed scan key from</span>
 <span class="s0">* the operating system.  This uses buttons that are independent of the user's</span>
 <span class="s0">* selected keyboard layout.</span>
 <span class="s0">*/ 2 4 this 3 557  21 raw_button_down_event 1 558  </span>
<span class="s0">16 0 0 6 17 558 0 0 121 /**</span>
 <span class="s0">* Returns the raw_button_down_event that has been set on this ButtonThrower.</span>
 <span class="s0">* See set_raw_button_down_event().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">17 0 0 4 18 559 0 0 141 /**</span>
 <span class="s0">* Specifies the generic event that is generated (if any) each time a key or</span>
 <span class="s0">* button is released.  See set_raw_button_down_event().</span>
 <span class="s0">*/ 2 4 this 3 557  19 raw_button_up_event 1 558  </span>
<span class="s0">18 0 0 6 19 558 0 0 117 /**</span>
 <span class="s0">* Returns the raw_button_up_event that has been set on this ButtonThrower.</span>
 <span class="s0">* See set_raw_button_up_event().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">19 0 0 4 31 559 0 0 229 /**</span>
 <span class="s0">* Sets the prefix which is prepended to all specific event names (that is,</span>
 <span class="s0">* event names generated from the button name itself, as opposed to the</span>
 <span class="s0">* generic event names like set_button_down_event) thrown by this object.</span>
 <span class="s0">*/ 2 4 this 3 557  6 prefix 1 558  </span>
<span class="s0">20 0 0 6 32 558 0 0 92 /**</span>
 <span class="s0">* Returns the prefix that has been set on this ButtonThrower.  See</span>
 <span class="s0">* set_prefix().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">21 0 0 4 33 559 0 0 307 /**</span>
 <span class="s0">* Sets the flag that indicates whether specific events (events prefixed by</span>
 <span class="s0">* set_prefix, and based on the event name) should be generated at all.  This</span>
 <span class="s0">* is true by default, but may be disabled if you are only interested in the</span>
 <span class="s0">* generic events (for instance, events like set_button_down_event).</span>
 <span class="s0">*/ 2 4 this 3 557  13 specific_flag 1 529  </span>
<span class="s0">22 0 0 6 34 529 0 0 116 /**</span>
 <span class="s0">* Returns the flag that indicates whether specific events should be</span>
 <span class="s0">* generated.  See set_specific_flag().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">23 0 0 4 38 559 0 0 400 /**</span>
 <span class="s0">* Sets the flag that indicates whether the time of the button event should be</span>
 <span class="s0">* passed as a parameter or not.  When this is true, an additional parameter</span>
 <span class="s0">* is generated on each event (before all the parameters named by</span>
 <span class="s0">* add_parameter) that consists of a single double value, and reflects the</span>
 <span class="s0">* time the button was pressed or released, as a value from</span>
 <span class="s0">* ClockObject::get_global_clock().</span>
 <span class="s0">*/ 2 4 this 3 557  9 time_flag 1 529  </span>
<span class="s0">24 0 0 6 39 529 0 0 115 /**</span>
 <span class="s0">* Returns the flag that indicates whether the time of the button event should</span>
 <span class="s0">* be passed as a parameter.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">25 0 0 4 41 559 0 0 137 /**</span>
 <span class="s0">* Adds the indicated parameter to the list of parameters that will be passed</span>
 <span class="s0">* with each event generated by this ButtonThrower.</span>
 <span class="s0">*/ 2 4 this 3 557  3 obj 1 560  </span>
<span class="s0">26 0 0 6 42 545 0 0 155 /**</span>
 <span class="s0">* Returns the number of parameters that have been added to the list of</span>
 <span class="s0">* parameters to be passed with each event generated by this ButtonThrower.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">27 0 0 7 43 562 0 0 141 /**</span>
 <span class="s0">* Returns the nth parameter that has been added to the list of parameters</span>
 <span class="s0">* passed with each event generated by this ButtonThrower.</span>
 <span class="s0">*/ 2 4 this 3 555  1 n 1 545  </span>
<span class="s0">28 0 0 6 47 563 0 0 463 /**</span>
 <span class="s0">* Returns the set of ModifierButtons that the ButtonThrower will consider</span>
 <span class="s0">* important enough to prepend the event name with.  Normally, this set will</span>
 <span class="s0">* be empty, and the ButtonThrower will therefore ignore all ModifierButtons</span>
 <span class="s0">* attached to the key events, but if one or more buttons have been added to</span>
 <span class="s0">* this set, and those modifier buttons are set on the button event, then the</span>
 <span class="s0">* event name will be prepended with the names of the modifier buttons.</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">29 0 0 4 48 559 0 0 653 /**</span>
 <span class="s0">* Changes the set of ModifierButtons that the ButtonThrower will consider</span>
 <span class="s0">* important enough to prepend the event name with.  Normally, this set will</span>
 <span class="s0">* be empty, and the ButtonThrower will therefore ignore all ModifierButtons</span>
 <span class="s0">* attached to the key events, but if one or more buttons have been added to</span>
 <span class="s0">* this set, then the event name will be prepended with the names of the</span>
 <span class="s0">* modifier buttons.</span>
 <span class="s0">*</span>
 <span class="s0">* It is recommended that you change this setting by first calling</span>
 <span class="s0">* get_modifier_buttons(), making adjustments, and passing the new value to</span>
 <span class="s0">* set_modifier_buttons().  This way the current state of the modifier buttons</span>
 <span class="s0">* will not be lost.</span>
 <span class="s0">*/ 2 4 this 3 557  4 mods 1 563  </span>
<span class="s0">30 0 0 4 52 559 0 0 293 /**</span>
 <span class="s0">* Sets the flag that indicates whether the ButtonThrower will only process</span>
 <span class="s0">* events for the explicitly named buttons or not.  Normally this is false,</span>
 <span class="s0">* meaning all buttons are processed; set it true to indicate that only some</span>
 <span class="s0">* buttons should be processed.  See add_throw_button().</span>
 <span class="s0">*/ 2 4 this 3 557  4 flag 1 529  </span>
<span class="s0">31 0 0 6 53 529 0 0 173 /**</span>
 <span class="s0">* Returns the flag that indicates whether the ButtonThrower will only process</span>
 <span class="s0">* events for the explicitly named buttons or not.  See</span>
 <span class="s0">* set_throw_buttons_active().</span>
 <span class="s0">*/ 1 4 this 3 555  </span>
<span class="s0">32 0 0 6 55 529 0 0 663 /**</span>
 <span class="s0">* Adds a new button to the set of buttons that the ButtonThrower explicitly</span>
 <span class="s0">* processes.</span>
 <span class="s0">*</span>
 <span class="s0">* If set_throw_buttons_active is false (which is the default), the</span>
 <span class="s0">* ButtonThrower will process all buttons.  Otherwise, the ButtonThrower will</span>
 <span class="s0">* only process events for the button(s) explicitly named by this function;</span>
 <span class="s0">* buttons not on the list will be ignored by this object and passed on</span>
 <span class="s0">* downstream to the child node(s) in the data graph.  A button that *is* on</span>
 <span class="s0">* the list will be processed by the ButtonThrower and not passed on to the</span>
 <span class="s0">* child node(s).</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the button is added, or false if it was already</span>
 <span class="s0">* in the set.</span>
 <span class="s0">*/ 3 4 this 3 557  4 mods 1 563  6 button 1 564  </span>
<span class="s0">33 0 0 6 56 529 0 0 231 /**</span>
 <span class="s0">* Removes the indicated button from the set of buttons that the ButtonThrower</span>
 <span class="s0">* explicitly processes.  See add_throw_button().</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the button is removed, or false if it was not</span>
 <span class="s0">* on the set.</span>
 <span class="s0">*/ 3 4 this 3 557  4 mods 1 563  6 button 1 564  </span>
<span class="s0">34 0 0 6 57 529 0 0 334 /**</span>
 <span class="s0">* Returns true if the indicated button, in conjunction with any nonspecified</span>
 <span class="s0">* modifier buttons, is on the set of buttons that will be processed by the</span>
 <span class="s0">* ButtonThrower.  That is to say, returns true if this button was ever passed</span>
 <span class="s0">* as the second parameter add_throw_button(), regardless of what the first</span>
 <span class="s0">* parameter was.</span>
 <span class="s0">*/ 2 4 this 3 555  6 button 1 564  </span>
<span class="s0">35 0 0 6 57 529 0 0 162 /**</span>
 <span class="s0">* Returns true if the indicated button is on the set of buttons that will be</span>
 <span class="s0">* processed by the ButtonThrower, false otherwise.  See add_throw_button().</span>
 <span class="s0">*/ 3 4 this 3 555  4 mods 1 563  6 button 1 564  </span>
<span class="s0">36 0 0 4 58 559 0 0 105 /**</span>
 <span class="s0">* Empties the set of buttons that were added via add_throw_button().  See</span>
 <span class="s0">* add_throw_button().</span>
 <span class="s0">*/ 1 4 this 3 557  </span>
<span class="s0">37 0 0 7 59 568 0 0 0 0 </span>
<span class="s0">38 0 0 15 65 571 0 0 0 1 6 param0 0 569  </span>
<span class="s0">39 0 0 4 61 559 0 0 289 /**</span>
 <span class="s0">* Indicates that the indicated button must be in the required state (either</span>
 <span class="s0">* up or down) in order for this particular MouseInterfaceNode to do anything.</span>
 <span class="s0">* For instance, this may be called to make a Trackball object respect mouse</span>
 <span class="s0">* input only when the control key is held down.</span>
 <span class="s0">*/ 3 4 this 3 571  6 button 1 564  7 is_down 1 529  </span>
<span class="s0">40 0 0 4 62 559 0 0 105 /**</span>
 <span class="s0">* Removes any requirement on the indicated button set by an earlier call to</span>
 <span class="s0">* require_button().</span>
 <span class="s0">*/ 2 4 this 3 571  6 button 1 564  </span>
<span class="s0">41 0 0 4 63 559 0 0 93 /**</span>
 <span class="s0">* Removes all requirements on buttons set by an earlier call to</span>
 <span class="s0">* require_button().</span>
 <span class="s0">*/ 1 4 this 3 571  </span>
<span class="s0">42 0 0 7 64 568 0 0 0 0 </span>
<span class="s0">43 0 0 15 67 574 0 0 0 1 6 param0 0 572  </span>
<span class="s0">44 0 0 7 67 574 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 5 558  </span>
<span class="s0">45 0 0 4 68 559 0 0 144 /**</span>
 <span class="s0">* Sets the speed of full forward motion, when the mouse is at the very top of</span>
 <span class="s0">* the window.  This is in units (e.g.  feet) per second.</span>
 <span class="s0">*/ 2 4 this 3 574  5 speed 1 543  </span>
<span class="s0">46 0 0 6 69 543 0 0 147 /**</span>
 <span class="s0">* Returns the speed of full forward motion, when the mouse is at the very top</span>
 <span class="s0">* of the window.  This is in units (e.g.  feet) per second.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">47 0 0 4 70 559 0 0 147 /**</span>
 <span class="s0">* Sets the speed of full reverse motion, when the mouse is at the very bottom</span>
 <span class="s0">* of the window.  This is in units (e.g.  feet) per second.</span>
 <span class="s0">*/ 2 4 this 3 574  5 speed 1 543  </span>
<span class="s0">48 0 0 6 71 543 0 0 150 /**</span>
 <span class="s0">* Returns the speed of full reverse motion, when the mouse is at the very</span>
 <span class="s0">* bottom of the window.  This is in units (e.g.  feet) per second.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">49 0 0 4 72 559 0 0 161 /**</span>
 <span class="s0">* Sets the maximum rate at which the user can rotate left or right, when the</span>
 <span class="s0">* mouse is at the very edge of the window.  This is in degrees per second.</span>
 <span class="s0">*/ 2 4 this 3 574  5 speed 1 543  </span>
<span class="s0">50 0 0 6 73 543 0 0 167 /**</span>
 <span class="s0">* Returns the maximum rate at which the user can rotate left or right, when</span>
 <span class="s0">* the mouse is at the very edge of the window.  This is in degrees per</span>
 <span class="s0">* second.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">51 0 0 4 74 559 0 0 300 /**</span>
 <span class="s0">* Sets the size of the horizontal bar in the center of the screen that</span>
 <span class="s0">* represents the &quot;dead zone&quot; of vertical motion: the region in which the</span>
 <span class="s0">* mouse does not report vertical motion.  This is in a fraction of the window</span>
 <span class="s0">* height, so 0.5 will set a dead zone as large as half the screen.</span>
 <span class="s0">*/ 2 4 this 3 574  4 zone 1 543  </span>
<span class="s0">52 0 0 6 75 543 0 0 303 /**</span>
 <span class="s0">* Returns the size of the horizontal bar in the center of the screen that</span>
 <span class="s0">* represents the &quot;dead zone&quot; of vertical motion: the region in which the</span>
 <span class="s0">* mouse does not report vertical motion.  This is in a fraction of the window</span>
 <span class="s0">* height, so 0.5 will set a dead zone as large as half the screen.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">53 0 0 4 76 559 0 0 301 /**</span>
 <span class="s0">* Sets the size of the vertical bar in the center of the screen that</span>
 <span class="s0">* represents the &quot;dead zone&quot; of horizontal motion: the region in which the</span>
 <span class="s0">* mouse does not report horizontal motion.  This is in a fraction of the</span>
 <span class="s0">* window width, so 0.5 will set a dead zone as large as half the screen.</span>
 <span class="s0">*/ 2 4 this 3 574  4 zone 1 543  </span>
<span class="s0">54 0 0 6 77 543 0 0 304 /**</span>
 <span class="s0">* Returns the size of the vertical bar in the center of the screen that</span>
 <span class="s0">* represents the &quot;dead zone&quot; of horizontal motion: the region in which the</span>
 <span class="s0">* mouse does not report horizontal motion.  This is in a fraction of the</span>
 <span class="s0">* window width, so 0.5 will set a dead zone as large as half the screen.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">55 0 0 4 78 559 0 0 173 /**</span>
 <span class="s0">* Sets the amount of time, in seconds, it takes between the time an up or</span>
 <span class="s0">* down arrow key is pressed and the time it registers full forward or</span>
 <span class="s0">* backward motion.</span>
 <span class="s0">*/ 2 4 this 3 574  12 ramp_up_time 1 543  </span>
<span class="s0">56 0 0 6 79 543 0 0 176 /**</span>
 <span class="s0">* Returns the amount of time, in seconds, it takes between the time an up or</span>
 <span class="s0">* down arrow key is pressed and the time it registers full forward or</span>
 <span class="s0">* backward motion.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">57 0 0 4 80 559 0 0 149 /**</span>
 <span class="s0">* Sets the amount of time, in seconds, it takes between the time an up or</span>
 <span class="s0">* down arrow key is released and the time it registers no motion.</span>
 <span class="s0">*/ 2 4 this 3 574  14 ramp_down_time 1 543  </span>
<span class="s0">58 0 0 6 81 543 0 0 152 /**</span>
 <span class="s0">* Returns the amount of time, in seconds, it takes between the time an up or</span>
 <span class="s0">* down arrow key is released and the time it registers no motion.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">59 0 0 4 82 559 0 0 154 /**</span>
 <span class="s0">* Sets the amount of time, in seconds, it takes between the time a left or</span>
 <span class="s0">* right arrow key is pressed and the time it registers full rotation.</span>
 <span class="s0">*/ 2 4 this 3 574  12 ramp_up_time 1 543  </span>
<span class="s0">60 0 0 6 83 543 0 0 157 /**</span>
 <span class="s0">* Returns the amount of time, in seconds, it takes between the time a left or</span>
 <span class="s0">* right arrow key is pressed and the time it registers full rotation.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">61 0 0 4 84 559 0 0 151 /**</span>
 <span class="s0">* Sets the amount of time, in seconds, it takes between the time a left or</span>
 <span class="s0">* right arrow key is released and the time it registers no motion.</span>
 <span class="s0">*/ 2 4 this 3 574  14 ramp_down_time 1 543  </span>
<span class="s0">62 0 0 6 85 543 0 0 154 /**</span>
 <span class="s0">* Returns the amount of time, in seconds, it takes between the time a left or</span>
 <span class="s0">* right arrow key is released and the time it registers no motion.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">63 0 0 6 86 543 0 0 64 /**</span>
 <span class="s0">* Returns the speed of the previous update in units/sec</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">64 0 0 6 87 543 0 0 68 /**</span>
 <span class="s0">* Returns the rot_speed of the previous update in units/sec</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">65 0 0 4 88 559 0 0 108 /**</span>
 <span class="s0">* Reinitializes the driver to the origin and resets any knowledge about</span>
 <span class="s0">* buttons being held down.</span>
 <span class="s0">*/ 1 4 this 3 574  </span>
<span class="s0">66 0 0 6 89 575 0 0 41 /**</span>
 <span class="s0">* Returns the driver's position.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">67 0 0 6 90 543 0 0 0 1 4 this 3 572  </span>
<span class="s0">68 0 0 6 91 543 0 0 0 1 4 this 3 572  </span>
<span class="s0">69 0 0 6 92 543 0 0 0 1 4 this 3 572  </span>
<span class="s0">70 0 0 4 93 559 0 0 47 /**</span>
 <span class="s0">* Directly sets the driver's position.</span>
 <span class="s0">*/ 2 4 this 3 574  3 vec 1 579  </span>
<span class="s0">71 0 0 4 93 559 0 0 0 4 4 this 3 574  1 x 1 543  1 y 1 543  1 z 1 543  </span>
<span class="s0">72 0 0 4 94 559 0 0 0 2 4 this 3 574  1 x 1 543  </span>
<span class="s0">73 0 0 4 95 559 0 0 0 2 4 this 3 574  1 y 1 543  </span>
<span class="s0">74 0 0 4 96 559 0 0 0 2 4 this 3 574  1 z 1 543  </span>
<span class="s0">75 0 0 6 97 579 0 0 44 /**</span>
 <span class="s0">* Returns the driver's orientation.</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">76 0 0 6 98 543 0 0 0 1 4 this 3 572  </span>
<span class="s0">77 0 0 6 99 543 0 0 0 1 4 this 3 572  </span>
<span class="s0">78 0 0 6 100 543 0 0 0 1 4 this 3 572  </span>
<span class="s0">79 0 0 4 101 559 0 0 50 /**</span>
 <span class="s0">* Directly sets the driver's orientation.</span>
 <span class="s0">*/ 2 4 this 3 574  3 hpr 1 579  </span>
<span class="s0">80 0 0 4 101 559 0 0 0 4 4 this 3 574  1 h 1 543  1 p 1 543  1 r 1 543  </span>
<span class="s0">81 0 0 4 102 559 0 0 0 2 4 this 3 574  1 h 1 543  </span>
<span class="s0">82 0 0 4 103 559 0 0 0 2 4 this 3 574  1 p 1 543  </span>
<span class="s0">83 0 0 4 104 559 0 0 0 2 4 this 3 574  1 r 1 543  </span>
<span class="s0">84 0 0 4 105 559 0 0 86 /**</span>
 <span class="s0">* This function is no longer used and does nothing.  It will be removed soon.</span>
 <span class="s0">*/ 2 4 this 3 574  10 force_roll 1 543  </span>
<span class="s0">85 0 0 4 106 559 0 0 411 /**</span>
 <span class="s0">* Changes the state of the ignore_mouse flag.  If this flag is true, the</span>
 <span class="s0">* DriveInterface will ignore mouse down button events (but still recognize</span>
 <span class="s0">* mouse up button events); the user will not be able to start the</span>
 <span class="s0">* DriveInterface going again if it is stopped, but if the user is currently</span>
 <span class="s0">* holding down a mouse button it will not stop immediately until the user</span>
 <span class="s0">* eventually releases the button.</span>
 <span class="s0">*/ 2 4 this 3 574  12 ignore_mouse 1 529  </span>
<span class="s0">86 0 0 6 107 529 0 0 92 /**</span>
 <span class="s0">* Returns the current setting of the ignore_mouse flag.  See</span>
 <span class="s0">* set_ignore_mouse().</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">87 0 0 4 108 559 0 0 155 /**</span>
 <span class="s0">* Changes the state of the force_mouse flag.  If this flag is true, the mouse</span>
 <span class="s0">* button need not be held down in order to drive the avatar around.</span>
 <span class="s0">*/ 2 4 this 3 574  11 force_mouse 1 529  </span>
<span class="s0">88 0 0 6 109 529 0 0 90 /**</span>
 <span class="s0">* Returns the current setting of the force_mouse flag.  See</span>
 <span class="s0">* set_force_mouse().</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">89 0 0 4 110 559 0 0 335 /**</span>
 <span class="s0">* If stop_this_frame is true, the next time the frame is computed no motion</span>
 <span class="s0">* will be allowed, and then the flag is reset to false.  This can be used to</span>
 <span class="s0">* prevent too much movement when we know a long time has artificially</span>
 <span class="s0">* elapsed, for instance when we take a screenshot, without munging the clock</span>
 <span class="s0">* for everything else.</span>
 <span class="s0">*/ 2 4 this 3 574  15 stop_this_frame 1 529  </span>
<span class="s0">90 0 0 6 111 529 0 0 98 /**</span>
 <span class="s0">* Returns the current setting of the stop_this_frame flag.  See</span>
 <span class="s0">* set_stop_this_frame().</span>
 <span class="s0">*/ 1 4 this 3 572  </span>
<span class="s0">91 0 0 4 112 559 0 0 64 /**</span>
 <span class="s0">* Stores the indicated transform in the DriveInterface.</span>
 <span class="s0">*/ 2 4 this 3 574  3 mat 1 583  </span>
<span class="s0">92 0 0 6 113 583 0 0 41 /**</span>
 <span class="s0">* Returns the current transform.</span>
 <span class="s0">*/ 1 4 this 3 574  </span>
<span class="s0">93 0 0 4 114 559 0 0 287 /**</span>
 <span class="s0">* This is a special kludge for DriveInterface to allow us to avoid the one-</span>
 <span class="s0">* frame latency after a collision.  It forces an immediate partial data flow</span>
 <span class="s0">* for all data graph nodes below this node, causing all data nodes that</span>
 <span class="s0">* depend on this matrix to be updated immediately.</span>
 <span class="s0">*/ 1 4 this 3 574  </span>
<span class="s0">94 0 0 7 115 568 0 0 0 0 </span>
<span class="s0">95 0 0 15 117 589 0 0 0 1 6 param0 0 587  </span>
<span class="s0">96 0 0 7 117 589 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 558  </span>
<span class="s0">97 0 0 6 118 543 0 0 135 /**</span>
 <span class="s0">* Retrieves the x coordinate of the left edge of the rectangle within the</span>
 <span class="s0">* window.  This number will be in the range [0..1].</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">98 0 0 6 119 543 0 0 136 /**</span>
 <span class="s0">* Retrieves the x coordinate of the right edge of the rectangle within the</span>
 <span class="s0">* window.  This number will be in the range [0..1].</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">99 0 0 6 120 543 0 0 137 /**</span>
 <span class="s0">* Retrieves the y coordinate of the bottom edge of the rectangle within the</span>
 <span class="s0">* window.  This number will be in the range [0..1].</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">100 0 0 6 121 543 0 0 134 /**</span>
 <span class="s0">* Retrieves the y coordinate of the top edge of the rectangle within the</span>
 <span class="s0">* window.  This number will be in the range [0..1].</span>
 <span class="s0">*/ 1 4 this 3 587  </span>
<span class="s0">101 0 0 4 122 559 0 0 288 /**</span>
 <span class="s0">* Changes the region of the window in which the mouse is considered to be</span>
 <span class="s0">* active.  The parameters are identical to those for a DisplayRegion: they</span>
 <span class="s0">* range from 0 to 1, where 0,0 is the lower left corner and 1,1 is the upper</span>
 <span class="s0">* right; (0, 1, 0, 1) represents the whole window.</span>
 <span class="s0">*/ 5 4 this 3 589  1 l 1 543  1 r 1 543  1 b 1 543  1 t 1 543  </span>
<span class="s0">102 0 0 7 123 568 0 0 0 0 </span>
<span class="s0">103 0 0 15 131 547 381 0 0 1 6 param0 0 590  </span>
<span class="s0">104 0 0 7 131 547 381 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 name 1 558  5 frame 1 592  </span>
<span class="s0">105 0 0 7 131 547 381 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 name 1 558  4 left 1 543  5 right 1 543  6 bottom 1 543  3 top 1 543  </span>
<span class="s0">106 0 0 4 132 559 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 547  5 frame 1 592  </span>
<span class="s0">107 0 0 4 132 559 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 this 3 547  4 left 1 543  5 right 1 543  6 bottom 1 543  3 top 1 543  </span>
<span class="s0">108 0 0 6 133 592 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 590  </span>
<span class="s0">109 0 0 6 134 543 0 0 54 /**</span>
 <span class="s0">* Returns the area of the rectangular region.</span>
 <span class="s0">*/ 1 4 this 3 590  </span>
<span class="s0">110 0 0 4 135 559 0 0 366 /**</span>
 <span class="s0">* Changes the sorting order of this particular region.  The sorting order is</span>
 <span class="s0">* used to resolve conflicts in the case of overlapping region; the region</span>
 <span class="s0">* with the highest sort value will be preferred, and between regions of the</span>
 <span class="s0">* same sort value, the smallest region will be preferred.  The default</span>
 <span class="s0">* sorting order, if none is explicitly specified, is 0.</span>
 <span class="s0">*/ 2 4 this 3 547  4 sort 1 545  </span>
<span class="s0">111 0 0 6 136 545 0 0 77 /**</span>
 <span class="s0">* Returns the current sorting order of this region.  See set_sort().</span>
 <span class="s0">*/ 1 4 this 3 590  </span>
<span class="s0">112 0 0 4 137 559 0 0 237 /**</span>
 <span class="s0">* Sets whether the region is active or not.  If it is not active, the</span>
 <span class="s0">* MouseWatcher will never consider the mouse to be over the region.  The</span>
 <span class="s0">* region might still receive keypress events if its set_keyboard() flag is</span>
 <span class="s0">* true.</span>
 <span class="s0">*/ 2 4 this 3 547  6 active 1 529  </span>
<span class="s0">113 0 0 6 138 529 0 0 74 /**</span>
 <span class="s0">* Returns whether the region is active or not.  See set_active().</span>
 <span class="s0">*/ 1 4 this 3 590  </span>
<span class="s0">114 0 0 4 139 559 0 0 301 /**</span>
 <span class="s0">* Sets whether the region is interested in global keyboard events.  If this</span>
 <span class="s0">* is true, then any keyboard button events will be passed to press() and</span>
 <span class="s0">* release() regardless of the position of the mouse onscreen; otherwise,</span>
 <span class="s0">* these events will only be passed if the mouse is over the region.</span>
 <span class="s0">*/ 2 4 this 3 547  8 keyboard 1 529  </span>
<span class="s0">115 0 0 6 140 529 0 0 101 /**</span>
 <span class="s0">* Returns whether the region is interested in global keyboard events; see</span>
 <span class="s0">* set_keyboard().</span>
 <span class="s0">*/ 1 4 this 3 590  </span>
<span class="s0">116 0 0 4 142 559 0 0 394 /**</span>
 <span class="s0">* Sets which events are suppressed when the mouse is over the region.  This</span>
 <span class="s0">* is the union of zero or more various SF_* values.  Normally, this is 0,</span>
 <span class="s0">* indicating that no events are suppressed.</span>
 <span class="s0">*</span>
 <span class="s0">* If you set this to a non-zero value, for instance SF_mouse_position, then</span>
 <span class="s0">* the mouse position will not be sent along the data graph when the mouse is</span>
 <span class="s0">* over this particular region.</span>
 <span class="s0">*/ 2 4 this 3 547  14 suppress_flags 1 545  </span>
<span class="s0">117 0 0 6 143 545 0 0 73 /**</span>
 <span class="s0">* Returns the current suppress_flags.  See set_suppress_flags().</span>
 <span class="s0">*/ 1 4 this 3 590  </span>
<span class="s0">118 0 0 4 144 559 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 590  3 out 1 593  </span>
<span class="s0">119 0 0 4 145 559 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 590  3 out 1 593  12 indent_level 5 545  </span>
<span class="s0">120 0 0 7 158 568 0 0 0 0 </span>
<span class="s0">121 0 0 7 126 595 0 0 0 1 4 this 3 547  </span>
<span class="s0">122 0 0 6 129 596 0 0 0 1 4 this 3 547  </span>
<span class="s0">123 0 0 4 162 559 0 0 150 /**</span>
 <span class="s0">* Adds the indicated region to the set of regions in the group.  It is no</span>
 <span class="s0">* longer an error to call this for the same region more than once.</span>
 <span class="s0">*/ 2 4 this 3 597  6 region 1 547  </span>
<span class="s0">124 0 0 6 163 529 0 0 115 /**</span>
 <span class="s0">* Returns true if the indicated region has already been added to the</span>
 <span class="s0">* MouseWatcherBase, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 598  6 region 1 547  </span>
<span class="s0">125 0 0 6 164 529 0 0 152 /**</span>
 <span class="s0">* Removes the indicated region from the group.  Returns true if it was</span>
 <span class="s0">* successfully removed, or false if it wasn't there in the first place.</span>
 <span class="s0">*/ 2 4 this 3 597  6 region 1 547  </span>
<span class="s0">126 0 0 7 165 547 381 0 170 /**</span>
 <span class="s0">* Returns a pointer to the first region found with the indicated name.  If</span>
 <span class="s0">* multiple regions share the same name, the one that is returned is</span>
 <span class="s0">* indeterminate.</span>
 <span class="s0">*/ 2 4 this 3 598  4 name 1 558  </span>
<span class="s0">127 0 0 4 166 559 0 0 50 /**</span>
 <span class="s0">* Removes all the regions from the group.</span>
 <span class="s0">*/ 1 4 this 3 597  </span>
<span class="s0">128 0 0 4 167 559 0 0 66 /**</span>
 <span class="s0">* Sorts all the regions in this group into pointer order.</span>
 <span class="s0">*/ 1 4 this 3 597  </span>
<span class="s0">129 0 0 6 168 529 0 0 78 /**</span>
 <span class="s0">* Returns true if the group has already been sorted, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">130 0 0 6 170 600 0 0 54 /**</span>
 <span class="s0">* Returns the number of regions in the group.</span>
 <span class="s0">*/ 1 4 this 3 598  </span>
<span class="s0">131 0 0 7 171 547 381 0 209 /**</span>
 <span class="s0">* Returns the nth region of the group; returns NULL if there is no nth</span>
 <span class="s0">* region.  Note that this is not thread-safe; another thread might have</span>
 <span class="s0">* removed the nth region before you called this method.</span>
 <span class="s0">*/ 2 4 this 3 598  1 n 1 600  </span>
<span class="s0">132 0 0 4 175 559 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 598  3 out 1 593  </span>
<span class="s0">133 0 0 4 176 559 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 598  3 out 1 593  12 indent_level 5 545  </span>
<span class="s0">134 0 0 4 177 559 0 0 179 /**</span>
 <span class="s0">* Enables the visualization of all of the regions handled by this</span>
 <span class="s0">* MouseWatcherBase.  The supplied NodePath should be the root of the 2-d</span>
 <span class="s0">* scene graph for the window.</span>
 <span class="s0">*/ 4 4 this 3 597  8 render2d 1 602  8 bin_name 1 558  10 draw_order 1 545  </span>
<span class="s0">135 0 0 4 178 559 0 0 114 /**</span>
 <span class="s0">* Specifies the color used to draw the region rectangles for the regions</span>
 <span class="s0">* visualized by show_regions().</span>
 <span class="s0">*/ 2 4 this 3 597  5 color 1 605  </span>
<span class="s0">136 0 0 4 179 559 0 0 80 /**</span>
 <span class="s0">* Stops the visualization created by a previous call to show_regions().</span>
 <span class="s0">*/ 1 4 this 3 597  </span>
<span class="s0">137 0 0 4 180 559 0 0 65 /**</span>
 <span class="s0">* Refreshes the visualization created by show_regions().</span>
 <span class="s0">*/ 1 4 this 3 597  </span>
<span class="s0">138 0 0 7 181 568 0 0 0 0 </span>
<span class="s0">139 0 0 7 188 568 0 0 0 0 </span>
<span class="s0">140 0 0 6 183 597 0 0 0 1 4 this 3 609  </span>
<span class="s0">141 0 0 7 186 610 0 0 0 1 4 this 3 609  </span>
<span class="s0">142 0 0 7 195 611 410 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 5 558  </span>
<span class="s0">143 0 0 6 197 529 0 0 152 /**</span>
 <span class="s0">* Removes the indicated region from the group.  Returns true if it was</span>
 <span class="s0">* successfully removed, or false if it wasn't there in the first place.</span>
 <span class="s0">*/ 2 4 this 3 611  6 region 1 547  </span>
<span class="s0">144 0 0 6 198 529 0 0 113 /**</span>
 <span class="s0">* Returns true if the mouse is anywhere within the window, false otherwise.</span>
 <span class="s0">* Also see is_mouse_open().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">145 0 0 6 199 529 0 0 212 /**</span>
 <span class="s0">* Returns true if the mouse is within the window and not over some particular</span>
 <span class="s0">* MouseWatcherRegion that is marked to suppress mouse events; that is, that</span>
 <span class="s0">* the mouse is in open space within the window.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">146 0 0 6 200 614 0 0 146 /**</span>
 <span class="s0">* It is only valid to call this if has_mouse() returns true.  If so, this</span>
 <span class="s0">* returns the current position of the mouse within the window.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">147 0 0 6 201 543 0 0 148 /**</span>
 <span class="s0">* It is only valid to call this if has_mouse() returns true.  If so, this</span>
 <span class="s0">* returns the current X position of the mouse within the window.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">148 0 0 6 202 543 0 0 148 /**</span>
 <span class="s0">* It is only valid to call this if has_mouse() returns true.  If so, this</span>
 <span class="s0">* returns the current Y position of the mouse within the window.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">149 0 0 4 203 559 0 0 567 /**</span>
 <span class="s0">* Sets the frame of the MouseWatcher.  This determines the coordinate space</span>
 <span class="s0">* in which the MouseWatcherRegions should be expected to live.  Normally,</span>
 <span class="s0">* this is left at -1, 1, -1, 1, which is the default setting, and matches the</span>
 <span class="s0">* mouse coordinate range.</span>
 <span class="s0">*</span>
 <span class="s0">* Whatever values you specify here indicate the shape of the full screen, and</span>
 <span class="s0">* the MouseWatcherRegions will be given in coordinate space matching it.  For</span>
 <span class="s0">* instance, if you specify (0, 1, 0, 1), then a MouseWatcherRegion with the</span>
 <span class="s0">* frame (0, 1, 0, .5) will cover the lower half of the screen.</span>
 <span class="s0">*/ 2 4 this 3 611  5 frame 1 592  </span>
<span class="s0">150 0 0 4 203 559 0 0 117 /**</span>
 <span class="s0">* Sets the frame of the MouseWatcher.  See the next flavor of this method for</span>
 <span class="s0">* a more verbose explanation.</span>
 <span class="s0">*/ 5 4 this 3 611  4 left 1 543  5 right 1 543  6 bottom 1 543  3 top 1 543  </span>
<span class="s0">151 0 0 6 204 592 0 0 67 /**</span>
 <span class="s0">* Returns the frame of the MouseWatcher.  See set_frame().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">152 0 0 6 205 529 0 0 85 /**</span>
 <span class="s0">* Returns true if the mouse is over any rectangular region, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">153 0 0 6 205 529 0 0 85 /**</span>
 <span class="s0">* Returns true if the mouse is over any rectangular region, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 612  3 pos 1 614  </span>
<span class="s0">154 0 0 6 205 529 0 0 85 /**</span>
 <span class="s0">* Returns true if the mouse is over any rectangular region, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 612  1 x 1 543  1 y 1 543  </span>
<span class="s0">155 0 0 7 206 547 381 0 103 /**</span>
 <span class="s0">* Returns the smallest region the mouse is currently over, or NULL if it is</span>
 <span class="s0">* over no region.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">156 0 0 7 206 547 381 0 233 /**</span>
 <span class="s0">* Returns the preferred region the mouse is over.  In the case of overlapping</span>
 <span class="s0">* regions, the region with the largest sort order is preferred; if two</span>
 <span class="s0">* regions have the same sort order, then the smaller region is preferred.</span>
 <span class="s0">*/ 2 4 this 3 612  3 pos 1 614  </span>
<span class="s0">157 0 0 7 206 547 381 0 103 /**</span>
 <span class="s0">* Returns the smallest region the indicated point is over, or NULL if it is</span>
 <span class="s0">* over no region.</span>
 <span class="s0">*/ 3 4 this 3 612  1 x 1 543  1 y 1 543  </span>
<span class="s0">158 0 0 6 207 529 0 0 97 /**</span>
 <span class="s0">* Returns true if the indicated button is currently being held down, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 612  6 button 1 618  </span>
<span class="s0">159 0 0 4 208 559 0 0 432 /**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a button is depressed.  This is a string that may contain any of the</span>
 <span class="s0">* following:</span>
 <span class="s0">*</span>
 <span class="s0">* %r  - the name of the region the mouse is over %b  - the name of the button</span>
 <span class="s0">* pressed.</span>
 <span class="s0">*</span>
 <span class="s0">* The event name will be based on the in_pattern string specified here, with</span>
 <span class="s0">* all occurrences of the above strings replaced with the corresponding</span>
 <span class="s0">* values.</span>
 <span class="s0">*/ 2 4 this 3 611  7 pattern 1 558  </span>
<span class="s0">160 0 0 6 209 558 0 0 137 /**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when a</span>
 <span class="s0">* button is depressed.  See set_button_down_pattern().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">161 0 0 4 210 559 0 0 145 /**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a button is released.  See set_button_down_pattern().</span>
 <span class="s0">*/ 2 4 this 3 611  7 pattern 1 558  </span>
<span class="s0">162 0 0 6 211 558 0 0 136 /**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when a</span>
 <span class="s0">* button is released.  See set_button_down_pattern().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">163 0 0 4 212 559 0 0 477 /**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when a button is continuously held and generates keyrepeat &quot;down&quot; events.</span>
 <span class="s0">* This is a string that may contain any of the following:</span>
 <span class="s0">*</span>
 <span class="s0">* %r  - the name of the region the mouse is over %b  - the name of the button</span>
 <span class="s0">* pressed.</span>
 <span class="s0">*</span>
 <span class="s0">* The event name will be based on the in_pattern string specified here, with</span>
 <span class="s0">* all occurrences of the above strings replaced with the corresponding</span>
 <span class="s0">* values.</span>
 <span class="s0">*/ 2 4 this 3 611  7 pattern 1 558  </span>
<span class="s0">164 0 0 6 213 558 0 0 197 /**</span>
 <span class="s0">* Returns the string that indicates how event names are names are generated</span>
 <span class="s0">* when a button is continuously held and generates keyrepeat &quot;down&quot; events.</span>
 <span class="s0">* See set_button_repeat_pattern().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">165 0 0 4 214 559 0 0 289 /**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when the mouse enters a region.  This is different from within_pattern, in</span>
 <span class="s0">* that a mouse is only &quot;entered&quot; in the topmost region at a given time, while</span>
 <span class="s0">* it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/ 2 4 this 3 611  7 pattern 1 558  </span>
<span class="s0">166 0 0 6 215 558 0 0 280 /**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when the</span>
 <span class="s0">* mouse enters a region.  This is different from within_pattern, in that a</span>
 <span class="s0">* mouse is only &quot;entered&quot; in the topmost region at a given time, while it</span>
 <span class="s0">* might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">167 0 0 4 216 559 0 0 290 /**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when the mouse leaves a region.  This is different from without_pattern, in</span>
 <span class="s0">* that a mouse is only &quot;entered&quot; in the topmost region at a given time, while</span>
 <span class="s0">* it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/ 2 4 this 3 611  7 pattern 1 558  </span>
<span class="s0">168 0 0 6 217 558 0 0 281 /**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when the</span>
 <span class="s0">* mouse leaves a region.  This is different from without_pattern, in that a</span>
 <span class="s0">* mouse is only &quot;entered&quot; in the topmost region at a given time, while it</span>
 <span class="s0">* might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">169 0 0 4 218 559 0 0 294 /**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when the mouse wanders over a region.  This is different from</span>
 <span class="s0">* enter_pattern, in that a mouse is only &quot;entered&quot; in the topmost region at a</span>
 <span class="s0">* given time, while it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/ 2 4 this 3 611  7 pattern 1 558  </span>
<span class="s0">170 0 0 6 219 558 0 0 285 /**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when the</span>
 <span class="s0">* mouse wanders over a region.  This is different from enter_pattern, in that</span>
 <span class="s0">* a mouse is only &quot;entered&quot; in the topmost region at a given time, while it</span>
 <span class="s0">* might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">171 0 0 4 220 559 0 0 296 /**</span>
 <span class="s0">* Sets the pattern string that indicates how the event names are generated</span>
 <span class="s0">* when the mouse wanders out of a region.  This is different from</span>
 <span class="s0">* leave_pattern, in that a mouse is only &quot;entered&quot; in the topmost region at a</span>
 <span class="s0">* given time, while it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/ 2 4 this 3 611  7 pattern 1 558  </span>
<span class="s0">172 0 0 6 221 558 0 0 287 /**</span>
 <span class="s0">* Returns the string that indicates how event names are generated when the</span>
 <span class="s0">* mouse wanders out of a region.  This is different from leave_pattern, in</span>
 <span class="s0">* that a mouse is only &quot;entered&quot; in the topmost region at a given time, while</span>
 <span class="s0">* it might be &quot;within&quot; multiple nested regions.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">173 0 0 4 222 559 0 0 279 /**</span>
 <span class="s0">* Sets the node that will be transformed each frame by the mouse's</span>
 <span class="s0">* coordinates.  It will also be hidden when the mouse goes outside the</span>
 <span class="s0">* window.  This can be used to implement a software mouse pointer for when a</span>
 <span class="s0">* hardware (or system) mouse pointer is unavailable.</span>
 <span class="s0">*/ 2 4 this 3 611  4 node 1 619  </span>
<span class="s0">174 0 0 6 223 529 0 0 130 /**</span>
 <span class="s0">* Returns true if a software mouse pointer has been setup via set_geometry(),</span>
 <span class="s0">* or false otherwise.  See set_geometry().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">175 0 0 7 224 619 0 0 152 /**</span>
 <span class="s0">* Returns the node that has been set as the software mouse pointer, or NULL</span>
 <span class="s0">* if no node has been set.  See has_geometry() and set_geometry().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">176 0 0 4 225 559 0 0 74 /**</span>
 <span class="s0">* Stops the use of the software cursor set up via set_geometry().</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">177 0 0 4 226 559 0 0 150 /**</span>
 <span class="s0">* As an optimization for the C++ Gui, an extra handler can be registered with</span>
 <span class="s0">* a mouseWatcher so that events can be dealt with much sooner.</span>
 <span class="s0">*/ 2 4 this 3 611  2 eh 1 621  </span>
<span class="s0">178 0 0 6 227 621 0 0 150 /**</span>
 <span class="s0">* As an optimization for the C++ Gui, an extra handler can be registered with</span>
 <span class="s0">* a mouseWatcher so that events can be dealt with much sooner.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">179 0 0 4 228 559 0 0 125 /**</span>
 <span class="s0">* Sets the buttons that should be monitored as modifier buttons for</span>
 <span class="s0">* generating events to the MouseWatcherRegions.</span>
 <span class="s0">*/ 2 4 this 3 611  4 mods 1 563  </span>
<span class="s0">180 0 0 7 229 623 0 0 118 /**</span>
 <span class="s0">* Returns the set of buttons that are being monitored as modifier buttons, as</span>
 <span class="s0">* well as their current state.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">181 0 0 4 230 559 0 0 402 /**</span>
 <span class="s0">* Constrains the MouseWatcher to watching the mouse within a particular</span>
 <span class="s0">* indicated region of the screen.  DataNodes parented under the MouseWatcher</span>
 <span class="s0">* will observe the mouse and keyboard events only when the mouse is within</span>
 <span class="s0">* the indicated region, and the observed range will be from -1 .. 1 across</span>
 <span class="s0">* the region.</span>
 <span class="s0">*</span>
 <span class="s0">* Do not delete the DisplayRegion while it is owned by the MouseWatcher.</span>
 <span class="s0">*/ 2 4 this 3 611  2 dr 1 624  </span>
<span class="s0">182 0 0 4 231 559 0 0 144 /**</span>
 <span class="s0">* Removes the display region constraint from the MouseWatcher, and restores</span>
 <span class="s0">* it to the default behavior of watching the whole window.</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">183 0 0 7 232 624 0 0 134 /**</span>
 <span class="s0">* Returns the display region the MouseWatcher is constrained to by</span>
 <span class="s0">* set_display_region(), or NULL if it is not constrained.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">184 0 0 6 233 529 0 0 245 /**</span>
 <span class="s0">* Returns true if the MouseWatcher has been constrained to a particular</span>
 <span class="s0">* region of the screen via set_display_region(), or false otherwise.  If this</span>
 <span class="s0">* returns true, get_display_region() may be used to return the particular</span>
 <span class="s0">* region.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">185 0 0 6 234 529 0 0 496 /**</span>
 <span class="s0">* Adds the indicated group of regions to the set of regions the MouseWatcher</span>
 <span class="s0">* will monitor each frame.</span>
 <span class="s0">*</span>
 <span class="s0">* Since the MouseWatcher itself inherits from MouseWatcherBase, this</span>
 <span class="s0">* operation is normally not necessary--you can simply add the Regions you</span>
 <span class="s0">* care about one at a time.  Adding a complete group is useful when you may</span>
 <span class="s0">* want to explicitly remove the regions as a group later.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if the group was successfully added, or false if it was</span>
 <span class="s0">* already on the list.</span>
 <span class="s0">*/ 2 4 this 3 611  5 group 1 609  </span>
<span class="s0">186 0 0 6 235 529 0 0 214 /**</span>
 <span class="s0">* Removes the indicated group from the set of extra groups associated with</span>
 <span class="s0">* the MouseWatcher.  Returns true if successful, or false if the group was</span>
 <span class="s0">* already removed or was never added via add_group().</span>
 <span class="s0">*/ 2 4 this 3 611  5 group 1 609  </span>
<span class="s0">187 0 0 6 236 529 0 0 362 /**</span>
 <span class="s0">* Atomically removes old_group from the MouseWatcher, and replaces it with</span>
 <span class="s0">* new_group.  Presumably old_group and new_group might have some regions in</span>
 <span class="s0">* common; these are handled properly.</span>
 <span class="s0">*</span>
 <span class="s0">* If old_group is not already present, simply adds new_group and returns</span>
 <span class="s0">* false.  Otherwise, removes old_group and adds new_group, and then returns</span>
 <span class="s0">* true.</span>
 <span class="s0">*/ 3 4 this 3 611  9 old_group 1 609  9 new_group 1 609  </span>
<span class="s0">188 0 0 6 237 545 0 0 94 /**</span>
 <span class="s0">* Returns the number of separate groups added to the MouseWatcher via</span>
 <span class="s0">* add_group().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">189 0 0 7 238 609 404 0 75 /**</span>
 <span class="s0">* Returns the nth group added to the MouseWatcher via add_group().</span>
 <span class="s0">*/ 2 4 this 3 612  1 n 1 545  </span>
<span class="s0">190 0 0 4 240 559 0 0 480 /**</span>
 <span class="s0">* Sets an inactivity timeout on the mouse activity.  When this timeout (in</span>
 <span class="s0">* seconds) is exceeded with no keyboard or mouse activity, all currently-held</span>
 <span class="s0">* buttons are automatically released.  This is intended to help protect</span>
 <span class="s0">* against people who inadvertently (or intentionally) leave a keyboard key</span>
 <span class="s0">* stuck down and then wander away from the keyboard.</span>
 <span class="s0">*</span>
 <span class="s0">* Also, when this timeout expires, the event specified by</span>
 <span class="s0">* set_inactivity_timeout_event() will be generated.</span>
 <span class="s0">*/ 2 4 this 3 611  7 timeout 1 626  </span>
<span class="s0">191 0 0 6 241 529 0 0 79 /**</span>
 <span class="s0">* Returns true if an inactivity timeout has been set, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">192 0 0 6 242 626 0 0 135 /**</span>
 <span class="s0">* Returns the inactivity timeout that has been set.  It is an error to call</span>
 <span class="s0">* this if has_inactivity_timeout() returns false.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">193 0 0 4 243 559 0 0 141 /**</span>
 <span class="s0">* Removes the inactivity timeout and restores the MouseWatcher to its default</span>
 <span class="s0">* behavior of allowing a key to be held indefinitely.</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">194 0 0 4 244 559 0 0 139 /**</span>
 <span class="s0">* Specifies the event string that will be generated when the inactivity</span>
 <span class="s0">* timeout counter expires.  See set_inactivity_timeout().</span>
 <span class="s0">*/ 2 4 this 3 611  5 event 1 558  </span>
<span class="s0">195 0 0 6 245 558 0 0 137 /**</span>
 <span class="s0">* Returns the event string that will be generated when the inactivity timeout</span>
 <span class="s0">* counter expires.  See set_inactivity_timeout().</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">196 0 0 7 246 629 0 0 395 /**</span>
 <span class="s0">* Obtain the mouse trail log.  This is a PointerEventList.  Does not make a</span>
 <span class="s0">* copy, therefore, this PointerEventList will be updated each time</span>
 <span class="s0">* process_events gets called.</span>
 <span class="s0">*</span>
 <span class="s0">* To use trail logging, you need to enable the generation of pointer events</span>
 <span class="s0">* in the GraphicsWindowInputDevice and set the trail log duration in the</span>
 <span class="s0">* MouseWatcher.  Otherwise, the trail log will be empty.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">197 0 0 6 247 600 0 0 174 /**</span>
 <span class="s0">* This counter indicates how many events were added to the trail log this</span>
 <span class="s0">* frame.  The trail log is updated once per frame, during the process_events</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/ 1 4 this 3 612  </span>
<span class="s0">198 0 0 4 248 559 0 0 198 /**</span>
 <span class="s0">* If the duration is nonzero, causes the MouseWatcher to log the mouse's</span>
 <span class="s0">* trail.  Events older than the specified duration are discarded.  If the</span>
 <span class="s0">* duration is zero, logging is disabled.</span>
 <span class="s0">*/ 2 4 this 3 611  8 duration 1 626  </span>
<span class="s0">199 0 0 7 249 631 0 0 618 /**</span>
 <span class="s0">* Returns a GeomNode that represents the mouse trail.  The intent is that you</span>
 <span class="s0">* should reparent this GeomNode to Render2D, and then forget about it.  The</span>
 <span class="s0">* MouseWatcher will continually update the trail node.  There is only one</span>
 <span class="s0">* trail node, it does not create a new one each time you call get_trail_node.</span>
 <span class="s0">*</span>
 <span class="s0">* This is not a particularly beautiful way to render a mouse trail.  It is</span>
 <span class="s0">* intended more for debugging purposes than for finished applications.  Even</span>
 <span class="s0">* so, It is suggested that you might want to apply a line thickness and</span>
 <span class="s0">* antialias mode to the line --- doing so makes it look a lot better.</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">200 0 0 4 250 559 0 0 256 /**</span>
 <span class="s0">* If you have previously fetched the trail node using get_trail_node, then</span>
 <span class="s0">* the MouseWatcher is continually updating the trail node every frame.  Using</span>
 <span class="s0">* clear_trail_node causes the MouseWatcher to forget the trail node and stop</span>
 <span class="s0">* updating it.</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">201 0 0 4 251 559 0 0 117 /**</span>
 <span class="s0">* Clears the mouse trail log.  This does not prevent further accumulation of</span>
 <span class="s0">* the log given future events.</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">202 0 0 4 252 559 0 0 586 /**</span>
 <span class="s0">* Can be used in conjunction with the inactivity timeout to inform the</span>
 <span class="s0">* MouseWatcher that the user has just performed some action which proves</span>
 <span class="s0">* he/she is present.  It may be necessary to call this for external events,</span>
 <span class="s0">* such as joystick action, that the MouseWatcher might otherwise not know</span>
 <span class="s0">* about.  This will reset the current inactivity timer.  When the inactivity</span>
 <span class="s0">* timer reaches the length of time specified by set_inactivity_timeout(),</span>
 <span class="s0">* with no keyboard or mouse activity and no calls to note_activity(), then</span>
 <span class="s0">* any buttons held will be automatically released.</span>
 <span class="s0">*/ 1 4 this 3 611  </span>
<span class="s0">203 0 0 7 253 568 0 0 0 0 </span>
<span class="s0">204 0 0 7 191 632 0 0 0 1 4 this 3 611  </span>
<span class="s0">205 0 0 6 193 597 0 0 0 1 4 this 3 611  </span>
<span class="s0">206 0 0 6 256 529 0 0 105 /**</span>
 <span class="s0">* Returns true if this parameter has an associated mouse or keyboard button,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">207 0 0 7 257 618 0 0 153 /**</span>
 <span class="s0">* Returns the mouse or keyboard button associated with this event.  If</span>
 <span class="s0">* has_button(), above, returns false, this returns ButtonHandle::none().</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">208 0 0 6 258 529 0 0 126 /**</span>
 <span class="s0">* Returns true if the button-down even was generated due to keyrepeat, or</span>
 <span class="s0">* false if it was an original button down.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">209 0 0 6 259 529 0 0 85 /**</span>
 <span class="s0">* Returns true if this parameter has an associated keycode, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">210 0 0 6 260 545 0 0 118 /**</span>
 <span class="s0">* Returns the keycode associated with this event.  If has_keycode(), above,</span>
 <span class="s0">* returns false, this returns 0.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">211 0 0 6 261 529 0 0 97 /**</span>
 <span class="s0">* Returns true if this parameter has an associated candidate string, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">212 0 0 6 262 558 0 0 144 /**</span>
 <span class="s0">* Returns the candidate string associated with this event.  If</span>
 <span class="s0">* has_candidate(), above, returns false, this returns the empty string.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">213 0 0 6 262 558 0 0 144 /**</span>
 <span class="s0">* Returns the candidate string associated with this event.  If</span>
 <span class="s0">* has_candidate(), above, returns false, this returns the empty string.</span>
 <span class="s0">*/ 2 4 this 3 633  8 encoding 1 635  </span>
<span class="s0">214 0 0 6 263 600 0 0 75 /**</span>
 <span class="s0">* Returns the first highlighted character in the candidate string.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">215 0 0 6 264 600 0 0 91 /**</span>
 <span class="s0">* Returns one more than the last highlighted character in the candidate</span>
 <span class="s0">* string.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">216 0 0 6 265 600 0 0 86 /**</span>
 <span class="s0">* Returns the position of the user's edit cursor within the candidate string.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">217 0 0 6 266 563 0 0 106 /**</span>
 <span class="s0">* Returns the set of modifier buttons that were being held down while the</span>
 <span class="s0">* event was generated.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">218 0 0 6 267 529 0 0 95 /**</span>
 <span class="s0">* Returns true if this parameter has an associated mouse position, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">219 0 0 6 268 614 0 0 176 /**</span>
 <span class="s0">* Returns the mouse position at the time the event was generated, in the</span>
 <span class="s0">* normalized range (-1 .. 1).  It is valid to call this only if has_mouse()</span>
 <span class="s0">* returned true.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">220 0 0 6 269 529 0 0 163 /**</span>
 <span class="s0">* Returns true if the mouse was outside the region at the time the event was</span>
 <span class="s0">* generated, false otherwise.  This is only valid for &quot;release&quot; type events.</span>
 <span class="s0">*/ 1 4 this 3 633  </span>
<span class="s0">221 0 0 4 270 559 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 633  3 out 1 593  </span>
<span class="s0">222 0 0 15 272 639 0 0 0 1 6 param0 0 637  </span>
<span class="s0">223 0 0 7 272 639 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 558  </span>
<span class="s0">224 0 0 4 273 559 0 0 52 /**</span>
 <span class="s0">* Reinitializes all transforms to identity.</span>
 <span class="s0">*/ 1 4 this 3 639  </span>
<span class="s0">225 0 0 6 274 543 0 0 104 /**</span>
 <span class="s0">* Returns the scale factor applied to forward and backward motion.  See</span>
 <span class="s0">* set_forward_scale().</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">226 0 0 4 275 559 0 0 173 /**</span>
 <span class="s0">* Changes the scale factor applied to forward and backward motion.  The</span>
 <span class="s0">* larger this number, the faster the model will move in response to dollying</span>
 <span class="s0">* in and out.</span>
 <span class="s0">*/ 2 4 this 3 639  8 fwdscale 1 543  </span>
<span class="s0">227 0 0 6 276 575 0 0 57 /**</span>
 <span class="s0">* Return the offset from the center of rotation.</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">228 0 0 6 277 543 0 0 0 1 4 this 3 637  </span>
<span class="s0">229 0 0 6 278 543 0 0 0 1 4 this 3 637  </span>
<span class="s0">230 0 0 6 279 543 0 0 0 1 4 this 3 637  </span>
<span class="s0">231 0 0 4 280 559 0 0 62 /**</span>
 <span class="s0">* Directly set the offset from the rotational origin.</span>
 <span class="s0">*/ 2 4 this 3 639  3 vec 1 579  </span>
<span class="s0">232 0 0 4 280 559 0 0 0 4 4 this 3 639  1 x 1 543  1 y 1 543  1 z 1 543  </span>
<span class="s0">233 0 0 4 281 559 0 0 0 2 4 this 3 639  1 x 1 543  </span>
<span class="s0">234 0 0 4 282 559 0 0 0 2 4 this 3 639  1 y 1 543  </span>
<span class="s0">235 0 0 4 283 559 0 0 0 2 4 this 3 639  1 z 1 543  </span>
<span class="s0">236 0 0 7 284 640 0 0 46 /**</span>
 <span class="s0">* Return the trackball's orientation.</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">237 0 0 6 285 543 0 0 0 1 4 this 3 637  </span>
<span class="s0">238 0 0 6 286 543 0 0 0 1 4 this 3 637  </span>
<span class="s0">239 0 0 6 287 543 0 0 0 1 4 this 3 637  </span>
<span class="s0">240 0 0 4 288 559 0 0 48 /**</span>
 <span class="s0">* Directly set the mover's orientation.</span>
 <span class="s0">*/ 2 4 this 3 639  3 hpr 1 579  </span>
<span class="s0">241 0 0 4 288 559 0 0 0 4 4 this 3 639  1 h 1 543  1 p 1 543  1 r 1 543  </span>
<span class="s0">242 0 0 4 289 559 0 0 0 2 4 this 3 639  1 h 1 543  </span>
<span class="s0">243 0 0 4 290 559 0 0 0 2 4 this 3 639  1 p 1 543  </span>
<span class="s0">244 0 0 4 291 559 0 0 0 2 4 this 3 639  1 r 1 543  </span>
<span class="s0">245 0 0 4 292 559 0 0 148 /**</span>
 <span class="s0">* Reposition the center of rotation to coincide with the current translation</span>
 <span class="s0">* offset.  Future rotations will be about the current origin.</span>
 <span class="s0">*/ 1 4 this 3 639  </span>
<span class="s0">246 0 0 4 293 559 0 0 60 /**</span>
 <span class="s0">* Moves the center of rotation by the given amount.</span>
 <span class="s0">*/ 4 4 this 3 639  1 x 1 543  1 y 1 543  1 z 1 543  </span>
<span class="s0">247 0 0 7 294 641 0 0 50 /**</span>
 <span class="s0">* Returns the current center of rotation.</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">248 0 0 4 295 559 0 0 48 /**</span>
 <span class="s0">* Directly sets the center of rotation.</span>
 <span class="s0">*/ 2 4 this 3 639  6 origin 1 579  </span>
<span class="s0">249 0 0 4 297 559 0 0 348 /**</span>
 <span class="s0">* Sets the control mode.  Normally this is CM_default, which means each mouse</span>
 <span class="s0">* button serves its normal function.  When it is CM_truck, CM_pan, CM_dolly,</span>
 <span class="s0">* or CM_roll, all of the mouse buttons serve the indicated function instead</span>
 <span class="s0">* of their normal function.  This can be used in conjunction with some</span>
 <span class="s0">* external way of changing modes.</span>
 <span class="s0">*/ 2 4 this 3 639  12 control_mode 1 553  </span>
<span class="s0">250 0 0 6 298 553 0 0 61 /**</span>
 <span class="s0">* Returns the control mode.  See set_control_mode().</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">251 0 0 4 299 559 0 0 162 /**</span>
 <span class="s0">* Sets the invert flag.  When this is set, the inverse matrix is generated,</span>
 <span class="s0">* suitable for joining to a camera, instead of parenting the scene under it.</span>
 <span class="s0">*/ 2 4 this 3 639  4 flag 1 529  </span>
<span class="s0">252 0 0 6 300 529 0 0 168 /**</span>
 <span class="s0">* Returns the invert flag.  When this is set, the inverse matrix is</span>
 <span class="s0">* generated, suitable for joining to a camera, instead of parenting the scene</span>
 <span class="s0">* under it.</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">253 0 0 4 301 559 0 0 275 /**</span>
 <span class="s0">* Sets the NodePath that all trackball manipulations are to be assumed to be</span>
 <span class="s0">* relative to.  For instance, set your camera node here to make the trackball</span>
 <span class="s0">* motion camera relative.  The default is the empty path, which means</span>
 <span class="s0">* trackball motion is in global space.</span>
 <span class="s0">*/ 2 4 this 3 639  6 rel_to 1 602  </span>
<span class="s0">254 0 0 6 302 602 0 0 103 /**</span>
 <span class="s0">* Returns the NodePath that all trackball manipulations are relative to, or</span>
 <span class="s0">* the empty path.</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">255 0 0 4 303 559 0 0 243 /**</span>
 <span class="s0">* Sets the coordinate system of the Trackball.  Normally, this is the default</span>
 <span class="s0">* coordinate system.  This changes the axes the Trackball manipulates so that</span>
 <span class="s0">* the user interface remains consistent across different coordinate systems.</span>
 <span class="s0">*/ 2 4 this 3 639  2 cs 1 642  </span>
<span class="s0">256 0 0 6 304 642 0 0 91 /**</span>
 <span class="s0">* Returns the coordinate system of the Trackball.  See</span>
 <span class="s0">* set_coordinate_system().</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">257 0 0 4 305 559 0 0 131 /**</span>
 <span class="s0">* Stores the indicated transform in the trackball.  This is a transform in</span>
 <span class="s0">* global space, regardless of the rel_to node.</span>
 <span class="s0">*/ 2 4 this 3 639  3 mat 1 583  </span>
<span class="s0">258 0 0 6 306 583 0 0 68 /**</span>
 <span class="s0">* Returns the matrix represented by the trackball rotation.</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">259 0 0 6 307 583 0 0 143 /**</span>
 <span class="s0">* Returns the actual transform that will be applied to the scene graph.  This</span>
 <span class="s0">* is the same as get_mat(), unless invert is in effect.</span>
 <span class="s0">*/ 1 4 this 3 637  </span>
<span class="s0">260 0 0 7 308 568 0 0 0 0 </span>
<span class="s0">261 0 0 15 310 645 523 0 0 1 6 param0 0 643  </span>
<span class="s0">262 0 0 7 310 645 523 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 558  </span>
<span class="s0">263 0 0 4 311 559 0 0 54 /**</span>
 <span class="s0">* Sets the node that this object will adjust.</span>
 <span class="s0">*/ 2 4 this 3 645  4 node 1 619  </span>
<span class="s0">264 0 0 7 312 619 0 0 102 /**</span>
 <span class="s0">* Returns the node that this object will adjust, or NULL if the node has not</span>
 <span class="s0">* yet been set.</span>
 <span class="s0">*/ 1 4 this 3 643  </span>
<span class="s0">265 0 0 7 313 568 0 0 0 0 </span>
<span class="s0">122</span>
<span class="s0">524 13 ButtonThrower 0 75777 13 ButtonThrower 13 ButtonThrower 0 0 0 1 266 0 14 646 647 648 649 650 651 652 653 654 655 656 657 658 659 34 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 1 668 0 1 0 525 0 0 0 0 397</span>
<span class="s0">/**</span>
 <span class="s0">* Throws Panda Events for button down/up events generated within the data</span>
 <span class="s0">* graph.</span>
 <span class="s0">*</span>
 <span class="s0">* This is a DataNode which is intended to be parented to the data graph below</span>
 <span class="s0">* a device which is generating a sequence of button events, like a</span>
 <span class="s0">* MouseAndKeyboard device.  It simply takes each button it finds and throws a</span>
 <span class="s0">* corresponding event based on the button name via the throw_event() call.</span>
 <span class="s0">*/</span>

<span class="s0">525 8 DataNode 0 2048 8 DataNode 8 DataNode 0 0 0 0 0 0 0 0 0 0 0 0 422</span>
<span class="s0">/**</span>
 <span class="s0">* The fundamental type of node for the data graph.  The DataNode class is</span>
 <span class="s0">* itself primarily intended as an abstract class; it defines no inputs and no</span>
 <span class="s0">* outputs.  Most kinds of data nodes will derive from this to specify the</span>
 <span class="s0">* inputs and outputs in the constructor.</span>
 <span class="s0">*</span>
 <span class="s0">* DataNode does not attempt to cycle its data with a PipelineCycler.  The</span>
 <span class="s0">* data graph is intended to be used only within a single thread.</span>
 <span class="s0">*/</span>

<span class="s0">526 12 string const 0 8832 17 std::string const 17 std::string const 0 0 527 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">527 6 string 0 2105344 11 std::string 11 std::string 0 0 528 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">528 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">529 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">530 14 EventParameter 0 2048 14 EventParameter 14 EventParameter 0 0 0 0 0 0 0 0 0 0 0 0 389</span>
<span class="s0">/**</span>
 <span class="s0">* An optional parameter associated with an event.  Each event may have zero</span>
 <span class="s0">* or more of these.  Each parameter stores a pointer to a</span>
 <span class="s0">* TypedWritableReferenceCount object, which of course could be pretty much</span>
 <span class="s0">* anything.  To store a simple value like a double or a string, the</span>
 <span class="s0">* EventParameter constructors transparently use the ParamValue template class</span>
 <span class="s0">* from paramValue.h.</span>
 <span class="s0">*/</span>

<span class="s0">531 21 ModifierButtons const 0 8832 21 ModifierButtons const 21 ModifierButtons const 0 0 532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">532 15 ModifierButtons 0 2048 15 ModifierButtons 15 ModifierButtons 0 0 0 0 0 0 0 0 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* This class monitors the state of a number of individual buttons and tracks</span>
 <span class="s0">* whether each button is known to be down or up.</span>
 <span class="s0">*/</span>

<span class="s0">533 18 MouseInterfaceNode 0 75777 18 MouseInterfaceNode 18 MouseInterfaceNode 0 0 0 1 305 0 0 4 301 302 303 304 0 0 1 0 525 0 0 0 0 249</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for some classes that monitor the mouse and keyboard</span>
 <span class="s0">* input and perform some action due to their state.</span>
 <span class="s0">*</span>
 <span class="s0">* It collects together some common interface; in particular, the</span>
 <span class="s0">* require_button() and related methods.</span>
 <span class="s0">*/</span>

<span class="s0">534 14 DriveInterface 0 75777 14 DriveInterface 14 DriveInterface 0 0 0 1 306 0 0 48 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 0 0 1 0 533 0 0 0 0 191</span>
<span class="s0">/**</span>
 <span class="s0">* This is a TFormer, similar to Trackball, that moves around a transform</span>
 <span class="s0">* matrix in response to mouse input.  The basic motion is on a horizontal</span>
 <span class="s0">* plane, as if driving a vehicle.</span>
 <span class="s0">*/</span>

<span class="s0">535 14 MouseSubregion 0 75777 14 MouseSubregion 14 MouseSubregion 0 0 0 1 355 0 0 6 356 357 358 359 360 361 0 0 1 0 533 0 0 0 0 321</span>
<span class="s0">/**</span>
 <span class="s0">* The MouseSubregion object scales the mouse inputs from within a rectangular</span>
 <span class="s0">* region of the screen, as if they were the full-screen inputs.</span>
 <span class="s0">*</span>
 <span class="s0">* If you choose your MouseSubregion coordinates to exactly match a</span>
 <span class="s0">* DisplayRegion within your window, you end up with a virtual mouse within</span>
 <span class="s0">* your DisplayRegion.</span>
 <span class="s0">*/</span>

<span class="s0">536 18 MouseWatcherRegion 0 141313 18 MouseWatcherRegion 18 MouseWatcherRegion 0 0 0 1 366 381 6 660 661 662 663 664 665 14 367 368 369 370 371 372 373 374 375 376 377 378 379 380 0 0 2 3 537 362 363 3 538 364 365 0 1 539 101</span>
<span class="s0">/**</span>
 <span class="s0">* This is the class that defines a rectangular region on the screen for the</span>
 <span class="s0">* MouseWatcher.</span>
 <span class="s0">*/</span>

<span class="s0">537 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedWritable and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedWritables and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">538 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">539 13 SuppressFlags 0 794624 33 MouseWatcherRegion::SuppressFlags 33 MouseWatcherRegion::SuppressFlags 536 0 0 0 0 0 0 0 0 0 4 15 SF_mouse_button 35 MouseWatcherRegion::SF_mouse_button 0</span>
<span class="s0">1 15 SF_other_button 35 MouseWatcherRegion::SF_other_button 0</span>
<span class="s0">2 13 SF_any_button 33 MouseWatcherRegion::SF_any_button 0</span>
<span class="s0">3 17 SF_mouse_position 37 MouseWatcherRegion::SF_mouse_position 0</span>
<span class="s0">4 0 0</span>

<span class="s0">540 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 541 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">541 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 542 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">542 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">543 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 544 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">544 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">545 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">546 16 MouseWatcherBase 0 26625 16 MouseWatcherBase 16 MouseWatcherBase 0 0 0 0 382 2 666 667 16 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 1 669 0 0 0 0 270</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a collection of MouseWatcherRegions that may be managed as</span>
 <span class="s0">* a group.  This is the base class for both MouseWatcherGroup and</span>
 <span class="s0">* MouseWatcher, and exists so that we don't have to make MouseWatcher inherit</span>
 <span class="s0">* from ReferenceCount more than once.</span>
 <span class="s0">*/</span>

<span class="s0">547 20 MouseWatcherRegion * 0 8576 20 MouseWatcherRegion * 20 MouseWatcherRegion * 0 0 536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">548 17 MouseWatcherGroup 0 141313 17 MouseWatcherGroup 17 MouseWatcherGroup 0 0 0 0 404 0 1 403 0 0 2 3 546 399 400 3 549 401 402 0 0 215</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a collection of MouseWatcherRegions that may be managed as</span>
 <span class="s0">* a group.  The implementation for this is in MouseWatcherBase; this class</span>
 <span class="s0">* exists so that we can inherit from ReferenceCount.</span>
 <span class="s0">*/</span>

<span class="s0">549 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">550 12 MouseWatcher 0 26625 12 MouseWatcher 12 MouseWatcher 0 0 0 1 409 410 0 56 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 1 670 0 2 3 525 405 406 3 546 407 408 0 0 1142</span>
<span class="s0">/**</span>
 <span class="s0">* This TFormer maintains a list of rectangular regions on the screen that are</span>
 <span class="s0">* considered special mouse regions; typically these will be click buttons.</span>
 <span class="s0">* When the mouse passes in or out of one of these regions, or when a button</span>
 <span class="s0">* is clicked while the mouse is in one of these regions, an event is thrown.</span>
 <span class="s0">*</span>
 <span class="s0">* Mouse events may also be suppressed from the rest of the datagraph in these</span>
 <span class="s0">* special regions.</span>
 <span class="s0">*</span>
 <span class="s0">* This class can also implement a software mouse pointer by automatically</span>
 <span class="s0">* generating a transform to apply to a piece of geometry placed under the 2-d</span>
 <span class="s0">* scene graph.  It will move the geometry around according to the mouse's</span>
 <span class="s0">* known position.</span>
 <span class="s0">*</span>
 <span class="s0">* Finally, this class can keep a record of the mouse trail.  This is useful</span>
 <span class="s0">* if you want to know, not just where the mouse is, but the exact sequence of</span>
 <span class="s0">* movements it took to get there.  This information is mainly useful for</span>
 <span class="s0">* gesture-recognition code.  To use trail logging, you need to enable the</span>
 <span class="s0">* generation of pointer events in the GraphicsWindowInputDevice and set the</span>
 <span class="s0">* trail log duration in the MouseWatcher.  Otherwise, the trail log will be</span>
 <span class="s0">* empty.</span>
 <span class="s0">*/</span>

<span class="s0">551 21 MouseWatcherParameter 0 26625 21 MouseWatcherParameter 21 MouseWatcherParameter 0 0 0 0 467 0 15 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 0 0 0 0 0 139</span>
<span class="s0">/**</span>
 <span class="s0">* This is sent along as a parameter to most events generated for a region to</span>
 <span class="s0">* indicate the mouse and button state for the event.</span>
 <span class="s0">*/</span>

<span class="s0">552 9 Trackball 0 75777 9 Trackball 9 Trackball 0 0 0 1 483 0 0 35 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 0 0 1 0 533 0 0 0 1 553 410</span>
<span class="s0">/**</span>
 <span class="s0">* Trackball acts like Performer in trackball mode.  It can either spin around</span>
 <span class="s0">* a piece of geometry directly, or it can spin around a camera with the</span>
 <span class="s0">* inverse transform to make it appear that the whole world is spinning.</span>
 <span class="s0">*</span>
 <span class="s0">* The Trackball object actually just places a transform in the data graph;</span>
 <span class="s0">* parent a Transform2SG node under it to actually transform objects (or</span>
 <span class="s0">* cameras) in the world.</span>
 <span class="s0">*/</span>

<span class="s0">553 11 ControlMode 0 794624 22 Trackball::ControlMode 22 Trackball::ControlMode 552 0 0 0 0 0 0 0 0 0 5 10 CM_default 21 Trackball::CM_default 0</span>
<span class="s0">0 8 CM_truck 19 Trackball::CM_truck 19</span>
<span class="s0">// Normally mouse 1</span>
<span class="s0">1 6 CM_pan 17 Trackball::CM_pan 19</span>
<span class="s0">// Normally mouse 2</span>
<span class="s0">2 8 CM_dolly 19 Trackball::CM_dolly 19</span>
<span class="s0">// Normally mouse 3</span>
<span class="s0">3 7 CM_roll 18 Trackball::CM_roll 23</span>
<span class="s0">// Normally mouse 2 + 3</span>
<span class="s0">4 0 0</span>

<span class="s0">554 12 Transform2SG 0 141313 12 Transform2SG 12 Transform2SG 0 0 0 1 519 523 0 3 520 521 522 0 0 1 0 525 0 0 0 0 146</span>
<span class="s0">/**</span>
 <span class="s0">* input: Transform (matrix)</span>
 <span class="s0">*</span>
 <span class="s0">* output: none, but applies the matrix as the transform transition for a</span>
 <span class="s0">* given arc of the scene graph.</span>
 <span class="s0">*/</span>

<span class="s0">555 21 ButtonThrower const * 0 8576 21 ButtonThrower const * 21 ButtonThrower const * 0 0 556 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">556 19 ButtonThrower const 0 8832 19 ButtonThrower const 19 ButtonThrower const 0 0 524 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">557 15 ButtonThrower * 0 8576 15 ButtonThrower * 15 ButtonThrower * 0 0 524 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">558 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">559 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">560 22 EventParameter const * 0 8576 22 EventParameter const * 22 EventParameter const * 0 0 561 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">561 20 EventParameter const 0 8832 20 EventParameter const 20 EventParameter const 0 0 530 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">562 16 EventParameter * 0 8576 16 EventParameter * 16 EventParameter * 0 0 530 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">563 23 ModifierButtons const * 0 8576 23 ModifierButtons const * 23 ModifierButtons const * 0 0 531 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">564 20 ButtonHandle const * 0 8576 20 ButtonHandle const * 20 ButtonHandle const * 0 0 565 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">565 18 ButtonHandle const 0 8832 18 ButtonHandle const 18 ButtonHandle const 0 0 566 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">566 12 ButtonHandle 0 16779264 12 ButtonHandle 12 ButtonHandle 0 0 0 0 0 0 0 0 0 0 0 0 162</span>
<span class="s0">/**</span>
 <span class="s0">* A ButtonHandle represents a single button from any device, including</span>
 <span class="s0">* keyboard buttons and mouse buttons (but see KeyboardButton and</span>
 <span class="s0">* MouseButton).</span>
 <span class="s0">*/</span>

<span class="s0">567 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">568 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 567 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">569 26 MouseInterfaceNode const * 0 8576 26 MouseInterfaceNode const * 26 MouseInterfaceNode const * 0 0 570 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">570 24 MouseInterfaceNode const 0 8832 24 MouseInterfaceNode const 24 MouseInterfaceNode const 0 0 533 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">571 20 MouseInterfaceNode * 0 8576 20 MouseInterfaceNode * 20 MouseInterfaceNode * 0 0 533 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">572 22 DriveInterface const * 0 8576 22 DriveInterface const * 22 DriveInterface const * 0 0 573 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">573 20 DriveInterface const 0 8832 20 DriveInterface const 20 DriveInterface const 0 0 534 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">574 16 DriveInterface * 0 8576 16 DriveInterface * 16 DriveInterface * 0 0 534 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">575 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 576 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">576 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 577 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">577 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 578 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">578 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">579 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">580 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 581 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">581 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 582 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">582 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">583 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 584 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">584 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 585 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">585 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 586 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">586 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45</span>
<span class="s0">/**</span>
 <span class="s0">* This is a 4-by-4 transform matrix.</span>
 <span class="s0">*/</span>

<span class="s0">587 22 MouseSubregion const * 0 8576 22 MouseSubregion const * 22 MouseSubregion const * 0 0 588 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">588 20 MouseSubregion const 0 8832 20 MouseSubregion const 20 MouseSubregion const 0 0 535 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">589 16 MouseSubregion * 0 8576 16 MouseSubregion * 16 MouseSubregion * 0 0 535 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">590 26 MouseWatcherRegion const * 0 8576 26 MouseWatcherRegion const * 26 MouseWatcherRegion const * 0 0 591 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">591 24 MouseWatcherRegion const 0 8832 24 MouseWatcherRegion const 24 MouseWatcherRegion const 0 0 536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">592 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 540 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">593 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 594 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">594 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">595 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 537 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">596 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 538 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">597 18 MouseWatcherBase * 0 8576 18 MouseWatcherBase * 18 MouseWatcherBase * 0 0 546 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">598 24 MouseWatcherBase const * 0 8576 24 MouseWatcherBase const * 24 MouseWatcherBase const * 0 0 599 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">599 22 MouseWatcherBase const 0 8832 22 MouseWatcherBase const 22 MouseWatcherBase const 0 0 546 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">600 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 601 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">601 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">602 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 603 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">603 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 604 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">604 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762</span>
<span class="s0">/**</span>
 <span class="s0">* NodePath is the fundamental system for disambiguating instances, and also</span>
 <span class="s0">* provides a higher-level interface for manipulating the scene graph.</span>
 <span class="s0">*</span>
 <span class="s0">* A NodePath is a list of connected nodes from the root of the graph to any</span>
 <span class="s0">* sub-node.  Each NodePath therefore uniquely describes one instance of a</span>
 <span class="s0">* node.</span>
 <span class="s0">*</span>
 <span class="s0">* NodePaths themselves are lightweight objects that may easily be copied and</span>
 <span class="s0">* passed by value.  Their data is stored as a series of NodePathComponents</span>
 <span class="s0">* that are stored on the nodes.  Holding a NodePath will keep a reference</span>
 <span class="s0">* count to all the nodes in the path.  However, if any node in the path is</span>
 <span class="s0">* removed or reparented (perhaps through a different NodePath), the NodePath</span>
 <span class="s0">* will automatically be updated to reflect the changes.</span>
 <span class="s0">*/</span>

<span class="s0">605 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">606 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 607 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">607 6 LColor 0 2105344 6 LColor 6 LColor 0 0 608 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">608 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 542 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">609 19 MouseWatcherGroup * 0 8576 19 MouseWatcherGroup * 19 MouseWatcherGroup * 0 0 548 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">610 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">611 14 MouseWatcher * 0 8576 14 MouseWatcher * 14 MouseWatcher * 0 0 550 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">612 20 MouseWatcher const * 0 8576 20 MouseWatcher const * 20 MouseWatcher const * 0 0 613 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">613 18 MouseWatcher const 0 8832 18 MouseWatcher const 18 MouseWatcher const 0 0 550 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">614 15 LPoint2 const * 0 8576 15 LPoint2 const * 15 LPoint2 const * 0 0 615 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">615 13 LPoint2 const 0 8832 13 LPoint2 const 13 LPoint2 const 0 0 616 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">616 7 LPoint2 0 2105344 7 LPoint2 7 LPoint2 0 0 617 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">617 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50</span>
<span class="s0">/**</span>
 <span class="s0">* This is a two-component point in space.</span>
 <span class="s0">*/</span>

<span class="s0">618 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 566 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">619 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 620 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">620 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A basic node of the scene graph or data graph.  This is the base class of</span>
 <span class="s0">* all specialized nodes, and also serves as a generic node with no special</span>
 <span class="s0">* properties.</span>
 <span class="s0">*/</span>

<span class="s0">621 14 EventHandler * 0 8576 14 EventHandler * 14 EventHandler * 0 0 622 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">622 12 EventHandler 0 2048 12 EventHandler 12 EventHandler 0 0 0 0 0 0 0 0 0 0 0 0 384</span>
<span class="s0">/**</span>
 <span class="s0">* A class to monitor events from the C++ side of things.  It maintains a set</span>
 <span class="s0">* of &quot;hooks&quot;, function pointers assigned to event names, and calls the</span>
 <span class="s0">* appropriate hooks when the matching event is detected.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is not necessary when the hooks are detected and processed</span>
 <span class="s0">* entirely by the scripting language, e.g.  via Scheme hooks or the messenger</span>
 <span class="s0">* in Python.</span>
 <span class="s0">*/</span>

<span class="s0">623 17 ModifierButtons * 0 8576 17 ModifierButtons * 17 ModifierButtons * 0 0 532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">624 15 DisplayRegion * 0 8576 15 DisplayRegion * 15 DisplayRegion * 0 0 625 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">625 13 DisplayRegion 0 2048 13 DisplayRegion 13 DisplayRegion 0 0 0 0 0 0 0 0 0 0 0 0 399</span>
<span class="s0">/**</span>
 <span class="s0">* A rectangular subregion within a window for rendering into.  Typically,</span>
 <span class="s0">* there is one DisplayRegion that covers the whole window, but you may also</span>
 <span class="s0">* create smaller DisplayRegions for having different regions within the</span>
 <span class="s0">* window that represent different scenes.  You may also stack up</span>
 <span class="s0">* DisplayRegions like panes of glass, usually for layering 2-d interfaces on</span>
 <span class="s0">* top of a 3-d scene.</span>
 <span class="s0">*/</span>

<span class="s0">626 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">627 22 PointerEventList const 0 8832 22 PointerEventList const 22 PointerEventList const 0 0 628 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">628 16 PointerEventList 0 2048 16 PointerEventList 16 PointerEventList 0 0 0 0 0 0 0 0 0 0 0 0 228</span>
<span class="s0">/**</span>
 <span class="s0">* Records a set of pointer events that happened recently.  This class is</span>
 <span class="s0">* usually used only in the data graph, to transmit the recent pointer</span>
 <span class="s0">* presses, but it may be used anywhere a list of PointerEvents is desired.</span>
 <span class="s0">*/</span>

<span class="s0">629 24 PointerEventList const * 0 8576 24 PointerEventList const * 24 PointerEventList const * 0 0 627 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">630 8 GeomNode 0 2048 8 GeomNode 8 GeomNode 0 0 0 0 0 0 0 0 0 0 0 0 208</span>
<span class="s0">/**</span>
 <span class="s0">* A node that holds Geom objects, renderable pieces of geometry.  This is the</span>
 <span class="s0">* primary kind of leaf node in the scene graph; almost all visible objects</span>
 <span class="s0">* will be contained in a GeomNode somewhere.</span>
 <span class="s0">*/</span>

<span class="s0">631 10 GeomNode * 0 8576 10 GeomNode * 10 GeomNode * 0 0 630 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">632 10 DataNode * 0 8576 10 DataNode * 10 DataNode * 0 0 525 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">633 29 MouseWatcherParameter const * 0 8576 29 MouseWatcherParameter const * 29 MouseWatcherParameter const * 0 0 634 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">634 27 MouseWatcherParameter const 0 8832 27 MouseWatcherParameter const 27 MouseWatcherParameter const 0 0 551 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">635 8 Encoding 0 794624 21 TextEncoder::Encoding 21 TextEncoder::Encoding 636 0 0 0 0 0 0 0 0 0 4 9 E_iso8859 22 TextEncoder::E_iso8859 0</span>
<span class="s0">0 6 E_utf8 19 TextEncoder::E_utf8 0</span>
<span class="s0">1 9 E_utf16be 22 TextEncoder::E_utf16be 0</span>
<span class="s0">2 9 E_unicode 22 TextEncoder::E_unicode 33</span>
<span class="s0">// Deprecated alias for E_utf16be</span>
<span class="s0">2 0 0</span>

<span class="s0">636 11 TextEncoder 0 2048 11 TextEncoder 11 TextEncoder 0 0 0 0 0 0 0 0 0 0 0 0 399</span>
<span class="s0">/**</span>
 <span class="s0">* This class can be used to convert text between multiple representations,</span>
 <span class="s0">* e.g.  UTF-8 to UTF-16.  You may use it as a static class object, passing</span>
 <span class="s0">* the encoding each time, or you may create an instance and use that object,</span>
 <span class="s0">* which will record the current encoding and retain the current string.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is also a base class of TextNode, which inherits this</span>
 <span class="s0">* functionality.</span>
 <span class="s0">*/</span>

<span class="s0">637 17 Trackball const * 0 8576 17 Trackball const * 17 Trackball const * 0 0 638 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">638 15 Trackball const 0 8832 15 Trackball const 15 Trackball const 0 0 552 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">639 11 Trackball * 0 8576 11 Trackball * 11 Trackball * 0 0 552 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">640 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 581 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">641 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 577 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">642 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210</span>
<span class="s0">// The CS_default entry does not refer to a particular coordinate system,</span>
<span class="s0">// but rather to the value stored in default_coordinate_system, which in</span>
<span class="s0">// turn is loaded from the config variable &quot;coordinate-system&quot;.</span>
<span class="s0">0 12 CS_zup_right 12 CS_zup_right 21</span>
<span class="s0">// Z-Up, Right-handed</span>
<span class="s0">1 12 CS_yup_right 12 CS_yup_right 21</span>
<span class="s0">// Y-Up, Right-handed</span>
<span class="s0">2 11 CS_zup_left 11 CS_zup_left 20</span>
<span class="s0">// Z-Up, Left-handed</span>
<span class="s0">3 11 CS_yup_left 11 CS_yup_left 20</span>
<span class="s0">// Y-Up, Left-handed</span>
<span class="s0">4 10 CS_invalid 10 CS_invalid 156</span>
<span class="s0">// CS_invalid is not a coordinate system at all.  It can be used in user-</span>
<span class="s0">// input processing code to indicate a contradictory coordinate system</span>
<span class="s0">// request.</span>
<span class="s0">5 0 0</span>

<span class="s0">643 20 Transform2SG const * 0 8576 20 Transform2SG const * 20 Transform2SG const * 0 0 644 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">644 18 Transform2SG const 0 8832 18 Transform2SG const 18 Transform2SG const 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">645 14 Transform2SG * 0 8576 14 Transform2SG * 14 Transform2SG * 0 0 554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">22</span>
<span class="s0">646 17 button_down_event 0 6 526 268 267 0 0 0 0 0 0 32 ButtonThrower::button_down_event 0</span>

<span class="s0">647 15 button_up_event 0 6 526 270 269 0 0 0 0 0 0 30 ButtonThrower::button_up_event 0</span>

<span class="s0">648 19 button_repeat_event 0 6 526 272 271 0 0 0 0 0 0 34 ButtonThrower::button_repeat_event 0</span>

<span class="s0">649 15 keystroke_event 0 6 526 274 273 0 0 0 0 0 0 30 ButtonThrower::keystroke_event 0</span>

<span class="s0">650 15 candidate_event 0 6 526 276 275 0 0 0 0 0 0 30 ButtonThrower::candidate_event 0</span>

<span class="s0">651 10 move_event 0 6 526 278 277 0 0 0 0 0 0 25 ButtonThrower::move_event 0</span>

<span class="s0">652 21 raw_button_down_event 0 6 526 280 279 0 0 0 0 0 0 36 ButtonThrower::raw_button_down_event 0</span>

<span class="s0">653 19 raw_button_up_event 0 6 526 282 281 0 0 0 0 0 0 34 ButtonThrower::raw_button_up_event 0</span>

<span class="s0">654 6 prefix 0 6 526 284 283 0 0 0 0 0 0 21 ButtonThrower::prefix 0</span>

<span class="s0">655 13 specific_flag 0 6 529 286 285 0 0 0 0 0 0 28 ButtonThrower::specific_flag 0</span>

<span class="s0">656 9 time_flag 0 6 529 288 287 0 0 0 0 0 0 24 ButtonThrower::time_flag 0</span>

<span class="s0">657 10 parameters 0 66 530 291 0 0 0 0 290 0 0 25 ButtonThrower::parameters 0</span>

<span class="s0">658 16 modifier_buttons 0 6 531 292 293 0 0 0 0 0 0 31 ButtonThrower::modifier_buttons 0</span>

<span class="s0">659 20 throw_buttons_active 0 6 529 295 294 0 0 0 0 0 0 35 ButtonThrower::throw_buttons_active 0</span>

<span class="s0">660 5 frame 0 6 540 368 367 0 0 0 0 0 0 25 MouseWatcherRegion::frame 0</span>

<span class="s0">661 4 area 0 2 543 369 0 0 0 0 0 0 0 24 MouseWatcherRegion::area 0</span>

<span class="s0">662 4 sort 0 6 545 371 370 0 0 0 0 0 0 24 MouseWatcherRegion::sort 0</span>

<span class="s0">663 6 active 0 6 529 373 372 0 0 0 0 0 0 26 MouseWatcherRegion::active 0</span>

<span class="s0">664 8 keyboard 0 6 529 375 374 0 0 0 0 0 0 28 MouseWatcherRegion::keyboard 0</span>

<span class="s0">665 14 suppress_flags 0 6 545 377 376 0 0 0 0 0 0 34 MouseWatcherRegion::suppress_flags 0</span>

<span class="s0">666 6 sorted 0 2 529 389 0 0 0 0 0 0 0 24 MouseWatcherBase::sorted 0</span>

<span class="s0">667 7 regions 0 66 547 391 0 0 0 0 390 0 0 25 MouseWatcherBase::regions 0</span>

<span class="s0">3</span>
<span class="s0">668 14 get_parameters 0 290 291 29 ButtonThrower::get_parameters 0</span>

<span class="s0">669 11 get_regions 0 390 391 29 MouseWatcherBase::get_regions 0</span>

<span class="s0">670 10 get_groups 0 451 452 24 MouseWatcher::get_groups 0</span>

</pre>
</body>
</html>