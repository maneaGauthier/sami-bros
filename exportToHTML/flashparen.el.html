<html>
<head>
<title>flashparen.el</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
flashparen.el</font>
</center></td></tr></table>
<pre><span class="s0">;;; flashparen.el --- flash matching parens a la Zmacs</span>

<span class="s0">;; Copyright (C) 1995 Noah S. Friedman</span>

<span class="s0">;; Author: Noah Friedman &lt;friedman@prep.ai.mit.edu&gt;</span>
<span class="s0">;; Maintainer: friedman@prep.ai.mit.edu</span>
<span class="s0">;; Keywords: extensions</span>
<span class="s0">;; Status: Works in Emacs 19</span>
<span class="s0">;; Created: 1995-03-03</span>

<span class="s0">;; LCD Archive Entry:</span>
<span class="s0">;; flashparen|Noah Friedman|friedman@prep.ai.mit.edu|</span>
<span class="s0">;; flash matching parens a la Zmacs|</span>
<span class="s0">;; 12-Nov-1995|1.8|~/misc/flashparen.el.gz|</span>

<span class="s0">;; $Id$</span>

<span class="s0">;; This program is free software; you can redistribute it and/or modify</span>
<span class="s0">;; it under the terms of the GNU General Public License as published by</span>
<span class="s0">;; the Free Software Foundation; either version 2, or (at your option)</span>
<span class="s0">;; any later version.</span>
<span class="s0">;;</span>
<span class="s0">;; This program is distributed in the hope that it will be useful,</span>
<span class="s0">;; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s0">;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="s0">;; GNU General Public License for more details.</span>
<span class="s0">;;</span>
<span class="s0">;; You should have received a copy of the GNU General Public License</span>
<span class="s0">;; along with this program; if not, you can either send email to this</span>
<span class="s0">;; program's maintainer or write to: The Free Software Foundation,</span>
<span class="s0">;; Inc.; 675 Massachusetts Avenue; Cambridge, MA 02139, USA.</span>

<span class="s0">;;; Commentary:</span>

<span class="s0">;; Loading this makes emacs's paren blinking behavior more closely</span>
<span class="s0">;; approximate the behavior of Zmacs.  It should work under X or on ascii</span>
<span class="s0">;; terminals.</span>

<span class="s0">;; Note that in XEmacs, blink-paren.el implements this functionality in a</span>
<span class="s0">;; more reliable manner, so use that instead of this program.</span>

<span class="s0">;; To use this program, load this file and do</span>
<span class="s0">;;</span>
<span class="s0">;;    (flash-matching-mode 1)</span>
<span class="s0">;;</span>
<span class="s0">;; It is vitally important that flash-matching-char be the *last* hook on</span>
<span class="s0">;; post-command-hook.  If anything comes after it, it won't get run until</span>
<span class="s0">;; flash-matching-char is interrupted by user input, which is almost</span>
<span class="s0">;; certainly undesirable.  As a consequence, the function</span>
<span class="s0">;; flash-matching-mode will make sure this is the case whenever it is run.</span>
<span class="s0">;; The real solution is to get the flashing function off the command hook</span>
<span class="s0">;; entirely, but since emacs has no builtin timers there seems to be no</span>
<span class="s0">;; readily apparent way to accomplish this efficiently.</span>

<span class="s0">;;; Code:</span>

<span class="s0">(defvar flash-matching-mode nil</span>
  <span class="s0">&quot;*If non-nil, then flash corresponding matching character on display.</span>
<span class="s0">It's best to call the function of the same name, since there are other</span>
<span class="s0">things to be done by side effect when enabling this feature.&quot;)</span>

<span class="s0">(defvar flash-matching-delay</span>
  <span class="s0">(cond (window-system 0.2)</span>
        <span class="s0">((&gt; baud-rate 19200) 0.2)</span>
        <span class="s0">((&gt;= baud-rate 9600) 0.5)</span>
        <span class="s0">(t 1))</span>
  <span class="s0">&quot;Interval (in seconds) for flash delay.</span>
<span class="s0">This number may be a floating-point number in instances of emacs that</span>
<span class="s0">support floating point arguments to `sit-for'.&quot;)</span>


<span class="s0">;;;###autoload</span>
<span class="s0">(defun flash-matching-mode (&amp;optional prefix)</span>
  <span class="s0">&quot;*If non-nil, then flash corresponding matching character on display.&quot;</span>
  <span class="s0">(interactive &quot;P&quot;)</span>

  <span class="s0">;; Make sure flash-matching-char is last on post-command-hook or</span>
  <span class="s0">;; post-command-idle-hook.  The latter is defined in Emacs 19.30 and later.</span>
  <span class="s0">(let* ((hook (if (boundp 'post-command-idle-hook)</span>
                   <span class="s0">'post-command-idle-hook</span>
                 <span class="s0">'post-command-hook))</span>
         <span class="s0">(h (memq 'flash-matching-char (symbol-value hook))))</span>
    <span class="s0">(cond ((null h)</span>
           <span class="s0">(add-hook hook 'flash-matching-char 'append))</span>
          <span class="s0">((cdr h)</span>
           <span class="s0">(remove-hook hook 'flash-matching-char)</span>
           <span class="s0">(add-hook hook 'flash-matching-char 'append))))</span>

  <span class="s0">(setq flash-matching-mode</span>
        <span class="s0">(&gt;= (prefix-numeric-value prefix) 0))</span>
  <span class="s0">(and (interactive-p)</span>
       <span class="s0">(if flash-matching-mode</span>
           <span class="s0">(message &quot;flash-matching-mode is enabled&quot;)</span>
         <span class="s0">(message &quot;flash-matching-mode is disabled&quot;)))</span>
  <span class="s0">flash-matching-mode)</span>

<span class="s0">;; Verify that an even number of quoting characters precede char at point.</span>
<span class="s0">(defsubst flash-matching-even-quoting-p (point)</span>
  <span class="s0">(let ((p (point)))</span>
    <span class="s0">(if (= point (point-min))</span>
        <span class="s0">t</span>
      <span class="s0">(= 1 (logand 1 (- point</span>
                        <span class="s0">(progn</span>
                          <span class="s0">(goto-char point)</span>
                          <span class="s0">(forward-char -1)</span>
                          <span class="s0">(skip-syntax-backward &quot;/\\&quot; (point-min))</span>
                          <span class="s0">(prog1</span>
                              <span class="s0">(point)</span>
                            <span class="s0">(goto-char p)))))))))</span>

<span class="s0">(defun flash-matching-char ()</span>
  <span class="s0">(and flash-matching-mode</span>
       <span class="s0">;; prefix args do strange things with commands; it seems that</span>
       <span class="s0">;; running post-command-hook after invoking one of these is delayed</span>
       <span class="s0">;; until the command is finished, then the hook is run twice.</span>
       <span class="s0">;; It's undesirable to wait for user input twice before returning to</span>
       <span class="s0">;; the top command loop, so skip this the first time.</span>
       <span class="s0">(not (memq this-command '(digit-argument universal-argument)))</span>
       <span class="s0">;; keyboard macros run a sequence of interactive commands, each one</span>
       <span class="s0">;; of which will cause a call to post-command-hook; so as long as</span>
       <span class="s0">;; the keyboard macro is still executing, do nothing.</span>
       <span class="s0">(null executing-macro)</span>
       <span class="s0">(let* ((saved-point (point))</span>
              <span class="s0">(cho (char-after saved-point))</span>
              <span class="s0">(chc (char-after (1- saved-point)))</span>
              <span class="s0">ch)</span>
         <span class="s0">(cond</span>
          <span class="s0">((or (and (numberp cho)</span>
                    <span class="s0">(= (char-syntax cho) ?\()</span>
                    <span class="s0">(&lt; saved-point (window-end))</span>
                    <span class="s0">(flash-matching-even-quoting-p saved-point)</span>
                    <span class="s0">(setq ch cho))</span>
               <span class="s0">(and (numberp chc)</span>
                    <span class="s0">(= (char-syntax chc) ?\))</span>
                    <span class="s0">(&gt; saved-point (window-start))</span>
                    <span class="s0">(flash-matching-even-quoting-p saved-point)</span>
                    <span class="s0">(setq ch chc)))</span>

           <span class="s0">(let ((parse-sexp-ignore-comments t)</span>
                 <span class="s0">;; this beginning of line is not necessarily the same as</span>
                 <span class="s0">;; the one of the matching char `line-beg', below.</span>
                 <span class="s0">(bol-point (progn</span>
                              <span class="s0">(beginning-of-line)</span>
                              <span class="s0">(point)))</span>
                 <span class="s0">match-point)</span>

             <span class="s0">;; should be at bol now</span>
             <span class="s0">;; If we're inside a comment already, turn off ignoring comments.</span>
             <span class="s0">(and comment-start</span>
                  <span class="s0">(looking-at (concat &quot;^[ \t]*&quot; (regexp-quote comment-start)))</span>
                  <span class="s0">(setq parse-sexp-ignore-comments nil))</span>

             <span class="s0">;; Find matching paren position, but don't search any further</span>
             <span class="s0">;; than the visible window.</span>
             <span class="s0">(save-restriction</span>
               <span class="s0">(condition-case ()</span>
                   <span class="s0">(progn</span>
                     <span class="s0">(narrow-to-region (window-start) (window-end))</span>
                     <span class="s0">(cond</span>
                      <span class="s0">((= (char-syntax ch) ?\()</span>
                       <span class="s0">(setq match-point (1- (scan-sexps saved-point 1))))</span>
                      <span class="s0">(t</span>
                       <span class="s0">(setq match-point (scan-sexps saved-point -1)))))</span>
                 <span class="s0">(error nil)))</span>

             <span class="s0">;; Matched char must be the corresponding character for the</span>
             <span class="s0">;; char at the saved point, not just another paired delimiter.</span>
             <span class="s0">;; This can happen when parens and brackets are mismatched,</span>
             <span class="s0">;; for example.  Also don't be fooled by things in an</span>
             <span class="s0">;; open/close syntax class but with no defined matching</span>
             <span class="s0">;; character.</span>
             <span class="s0">(and match-point</span>
                  <span class="s0">(flashparen-matching-paren ch)</span>
                  <span class="s0">(not (= (char-after match-point)</span>
                          <span class="s0">(flashparen-matching-paren ch)))</span>
                  <span class="s0">(setq match-point nil))</span>

             <span class="s0">;; match char must be horizontally visible on display.</span>
             <span class="s0">;; Unfortunately we cannot just use pos-visible-in-window-p</span>
             <span class="s0">;; since that returns t for things that are actually off the</span>
             <span class="s0">;; display horizontally.</span>
             <span class="s0">(and truncate-lines</span>
                  <span class="s0">match-point</span>
                  <span class="s0">(let ((window-hstart (window-hscroll))</span>
                        <span class="s0">(match-column (progn</span>
                                        <span class="s0">(goto-char match-point)</span>
                                        <span class="s0">(current-column))))</span>
                    <span class="s0">(if (or (&lt; match-column window-hstart)</span>
                            <span class="s0">(&gt; match-column (+ window-hstart (window-width))))</span>
                        <span class="s0">(setq match-point nil))))</span>

             <span class="s0">(cond (match-point</span>
                    <span class="s0">;; I added this to remove messages left over from</span>
                    <span class="s0">;; blink-matching-open, but it also causes messages</span>
                    <span class="s0">;; returned by eval-expression, etc. not to appear if</span>
                    <span class="s0">;; point is right after a sexp, which is too annoying.</span>
                    <span class="s0">;;(message nil)</span>
                    <span class="s0">(flash-matching-do-flash saved-point match-point))</span>
                   <span class="s0">(t</span>
                    <span class="s0">(goto-char saved-point)</span>
                    <span class="s0">(and chc</span>
                         <span class="s0">(= (char-syntax chc) ?\))</span>
                         <span class="s0">;; blink-matching-open can sometimes signal an</span>
                         <span class="s0">;; error if the function name is outside of a</span>
                         <span class="s0">;; narrowed region---this can happen in C, perl,</span>
                         <span class="s0">;; and other languages where the function label is</span>
                         <span class="s0">;; outside the starting block character, depending</span>
                         <span class="s0">;; on how one's narrow-to-defun function is defined.</span>
                         <span class="s0">(condition-case ()</span>
                             <span class="s0">(blink-matching-open)</span>
                           <span class="s0">(error nil)))))))))))</span>

<span class="s0">(defun flash-matching-do-flash (flash-matching-opoint flash-matching-mpoint)</span>
  <span class="s0">;; Deactivate the mark now if deactivate-mark is set in transient mark</span>
  <span class="s0">;; mode.  Normally the command loop does this itself, but because this</span>
  <span class="s0">;; function is on post-command-hook, deactivation is delayed and causes</span>
  <span class="s0">;; noticable, undesirable effects on the display.</span>
  <span class="s0">;; The only time I've noticed this to be of consequence is when point is</span>
  <span class="s0">;; right before a sexp and you insert a character.  Otherwise, this</span>
  <span class="s0">;; function doesn't get called again because after modifying the buffer,</span>
  <span class="s0">;; point is no longer at the beginning or end of a sexp.</span>
  <span class="s0">(and transient-mark-mode</span>
       <span class="s0">deactivate-mark</span>
       <span class="s0">(deactivate-mark))</span>

  <span class="s0">(let ((modp (buffer-modified-p))</span>
        <span class="s0">(buffer-file-name buffer-file-name)</span>
        <span class="s0">(buffer-auto-save-file-name buffer-auto-save-file-name)</span>
        <span class="s0">(auto-save-hook (and (boundp 'auto-save-hook)</span>
                             <span class="s0">auto-save-hook))</span>

        <span class="s0">;; Don't make any undo records while flashing.</span>
        <span class="s0">;; If this is nil, new undo records are appended.</span>
        <span class="s0">;; Setting it to t avoids consing any records at all.</span>
        <span class="s0">(buffer-undo-list t)</span>

        <span class="s0">(before-change-function nil)</span>
        <span class="s0">(after-change-function nil)</span>
        <span class="s0">;; buffer modification messes with transient mark mode.</span>
        <span class="s0">(deactivate-mark nil)</span>

        <span class="s0">;; These variables have long names because they may be referenced</span>
        <span class="s0">;; by a function in the auto-save-hook even if the current buffer</span>
        <span class="s0">;; isn't this one (e.g. because a process filter was running at the</span>
        <span class="s0">;; time).</span>
        <span class="s0">(flash-matching-buffer (current-buffer))</span>
        <span class="s0">(flash-matching-char (char-after flash-matching-mpoint))</span>
        <span class="s0">(flash-matching-visible-p t))</span>

    <span class="s0">(cond</span>
     <span class="s0">((null buffer-file-name))</span>
     <span class="s0">(modp</span>
      <span class="s0">;; If buffer is already modified, do not try to disable locking or</span>
      <span class="s0">;; autosaving, but make sure flashed char is in the buffer exactly</span>
      <span class="s0">;; when autosaving occurs.</span>
      <span class="s0">(add-hook 'auto-save-hook</span>
                <span class="s0">(function</span>
                 <span class="s0">(lambda ()</span>
                   <span class="s0">(or flash-matching-visible-p</span>
                       <span class="s0">(save-excursion</span>
                         <span class="s0">(set-buffer flash-matching-buffer)</span>
                         <span class="s0">(let ((buffer-read-only nil))</span>
                           <span class="s0">(goto-char flash-matching-mpoint)</span>
                           <span class="s0">(insert-before-markers-and-inherit</span>
                            <span class="s0">flash-matching-char)</span>
                           <span class="s0">(goto-char flash-matching-mpoint)</span>
                           <span class="s0">(delete-char -1)</span>
                           <span class="s0">(setq flash-matching-visible-p t)</span>
                           <span class="s0">(goto-char flash-matching-opoint))))))))</span>
     <span class="s0">(t</span>
      <span class="s0">;; Defeat file locking.  Don't try this at home, kids!</span>
      <span class="s0">(setq buffer-file-name nil)</span>
      <span class="s0">(setq buffer-auto-save-file-name nil)))</span>

    <span class="s0">;; We insert-before-markers-and-inherit one char after the one to</span>
    <span class="s0">;; delete, just in case things like window-start, process-mark,</span>
    <span class="s0">;; etc. are at the point of interest.</span>
    <span class="s0">(setq flash-matching-mpoint (1+ flash-matching-mpoint))</span>
    <span class="s0">(goto-char flash-matching-opoint)</span>
    <span class="s0">(unwind-protect</span>
        <span class="s0">(while (sit-for flash-matching-delay)</span>
          <span class="s0">(let ((buffer-read-only nil))</span>
            <span class="s0">(goto-char flash-matching-mpoint)</span>
            <span class="s0">;; Insert char before deleting existing one, to avoid</span>
            <span class="s0">;; complications having to do with overlays and text</span>
            <span class="s0">;; properties on a region.</span>
            <span class="s0">(if flash-matching-visible-p</span>
                <span class="s0">(insert-before-markers-and-inherit 32)</span>
              <span class="s0">(insert-before-markers-and-inherit flash-matching-char))</span>
            <span class="s0">(goto-char flash-matching-mpoint)</span>
            <span class="s0">(delete-char -1)</span>
            <span class="s0">(setq flash-matching-visible-p</span>
                  <span class="s0">(not flash-matching-visible-p))</span>

            <span class="s0">;; Hide fact of temporary modification during redisplay, if</span>
            <span class="s0">;; buffer was unmodified originally.</span>
            <span class="s0">(or modp</span>
                <span class="s0">(set-buffer-modified-p modp))</span>

            <span class="s0">(goto-char flash-matching-opoint)))</span>
      <span class="s0">(or flash-matching-visible-p</span>
          <span class="s0">(let ((buffer-read-only nil))</span>
            <span class="s0">(goto-char flash-matching-mpoint)</span>
            <span class="s0">(insert-before-markers-and-inherit flash-matching-char)</span>
            <span class="s0">(goto-char flash-matching-mpoint)</span>
            <span class="s0">(delete-char -1)</span>
            <span class="s0">(or modp</span>
                <span class="s0">(set-buffer-modified-p modp))</span>
            <span class="s0">(goto-char flash-matching-opoint))))))</span>

<span class="s0">;; matching-paren wasn't defined in emacs until version 19.26.</span>
<span class="s0">(if (fboundp 'matching-paren)</span>
    <span class="s0">(defalias 'flashparen-matching-paren 'matching-paren)</span>
  <span class="s0">(defun flashparen-matching-paren (c)</span>
    <span class="s0">(and (memq (char-syntax c) '(?\( ?\)))</span>
         <span class="s0">(lsh (aref (syntax-table) c) -8))))</span>

<span class="s0">(provide 'flashparen)</span>

<span class="s0">;; local variables:</span>
<span class="s0">;; vc-make-backup-files: t</span>
<span class="s0">;; end:</span>

<span class="s0">;;; flashparen.el ends here</span>
</pre>
</body>
</html>