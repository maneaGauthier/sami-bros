<html>
<head>
<title>libp3express.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3express.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">12 libp3express 4 vDgf 12 panda3d.core </span>
<span class="s0">655</span>
<span class="s0">666 7 is_null 0 4 1325 22 PointerToVoid::is_null 0 1 20 130</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the PointerTo is a NULL pointer, false otherwise.  (Direct</span>
 <span class="s0">* comparison to a NULL pointer also works.)</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">constexpr bool PointerToVoid::is_null(void) const;</span>

<span class="s0">667 8 get_hash 0 4 1325 23 PointerToVoid::get_hash 0 1 21 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline std::size_t PointerToVoid::get_hash(void) const;</span>

<span class="s0">668 14 ~PointerToVoid 0 516 1325 29 PointerToVoid::~PointerToVoid 0 0 0</span>
<span class="s0">36</span>
<span class="s0">PointerToVoid::~PointerToVoid(void);</span>

<span class="s0">669 5 clear 0 4 1324 56 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt;::clear 0 1 18 0</span>
<span class="s0">75</span>
<span class="s0">inline void PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt;::clear(void);</span>

<span class="s0">670 6 output 0 4 1324 57 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt;::output 0 1 19 0</span>
<span class="s0">88</span>
<span class="s0">void PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">671 19 ~PointerToArrayBase 0 516 1323 49 PointerToArrayBase&lt; double &gt;::~PointerToArrayBase 0 0 0</span>
<span class="s0">63</span>
<span class="s0">inline PointerToArrayBase&lt; double &gt;::~PointerToArrayBase(void);</span>

<span class="s0">672 11 operator == 0 4 1323 41 PointerToArrayBase&lt; double &gt;::operator == 0 1 16 64</span>
<span class="s0">// These are implemented in PointerToVoid, but expose them here.</span>
<span class="s0">103</span>
<span class="s0">inline bool PointerToArrayBase&lt; double &gt;::operator ==(PointerToArrayBase&lt; double &gt; const &amp;other) const;</span>

<span class="s0">673 11 operator != 0 4 1323 41 PointerToArrayBase&lt; double &gt;::operator != 0 1 17 0</span>
<span class="s0">103</span>
<span class="s0">inline bool PointerToArrayBase&lt; double &gt;::operator !=(PointerToArrayBase&lt; double &gt; const &amp;other) const;</span>

<span class="s0">674 19 ConstPointerToArray 0 260 1322 50 ConstPointerToArray&lt; double &gt;::ConstPointerToArray 0 2 1 2 0</span>
<span class="s0">198</span>
<span class="s0">inline ConstPointerToArray&lt; double &gt;::ConstPointerToArray(PointerToArray&lt; double &gt; const &amp;copy);</span>
<span class="s0">inline ConstPointerToArray&lt; double &gt;::ConstPointerToArray(ConstPointerToArray&lt; double &gt; const &amp;copy);</span>

<span class="s0">675 5 clear 0 4 1322 36 ConstPointerToArray&lt; double &gt;::clear 0 1 3 0</span>
<span class="s0">55</span>
<span class="s0">inline void ConstPointerToArray&lt; double &gt;::clear(void);</span>

<span class="s0">676 4 size 0 4 1322 35 ConstPointerToArray&lt; double &gt;::size 0 1 4 0</span>
<span class="s0">78</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; double &gt;::size(void) const;</span>

<span class="s0">677 11 get_element 0 4 1322 42 ConstPointerToArray&lt; double &gt;::get_element 0 1 5 0</span>
<span class="s0">96</span>
<span class="s0">inline double const &amp;ConstPointerToArray&lt; double &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">678 11 __getitem__ 0 4 1322 42 ConstPointerToArray&lt; double &gt;::__getitem__ 0 1 6 0</span>
<span class="s0">89</span>
<span class="s0">double const &amp;ConstPointerToArray&lt; double &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">679 8 get_data 0 4 1322 39 ConstPointerToArray&lt; double &gt;::get_data 0 1 7 0</span>
<span class="s0">62</span>
<span class="s0">PyObject *ConstPointerToArray&lt; double &gt;::get_data(void) const;</span>

<span class="s0">680 11 get_subdata 0 4 1322 42 ConstPointerToArray&lt; double &gt;::get_subdata 0 1 8 0</span>
<span class="s0">115</span>
<span class="s0">PyObject *ConstPointerToArray&lt; double &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">681 13 get_ref_count 0 4 1322 44 ConstPointerToArray&lt; double &gt;::get_ref_count 0 1 9 0</span>
<span class="s0">68</span>
<span class="s0">inline int ConstPointerToArray&lt; double &gt;::get_ref_count(void) const;</span>

<span class="s0">682 18 get_node_ref_count 0 4 1322 49 ConstPointerToArray&lt; double &gt;::get_node_ref_count 0 1 10 0</span>
<span class="s0">73</span>
<span class="s0">inline int ConstPointerToArray&lt; double &gt;::get_node_ref_count(void) const;</span>

<span class="s0">683 5 count 0 4 1322 36 ConstPointerToArray&lt; double &gt;::count 0 1 11 0</span>
<span class="s0">89</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; double &gt;::count(double const &amp;) const;</span>

<span class="s0">684 10 __reduce__ 0 4 1322 41 ConstPointerToArray&lt; double &gt;::__reduce__ 0 1 12 0</span>
<span class="s0">74</span>
<span class="s0">PyObject *ConstPointerToArray&lt; double &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">685 13 __getbuffer__ 0 4 1322 44 ConstPointerToArray&lt; double &gt;::__getbuffer__ 0 1 13 0</span>
<span class="s0">99</span>
<span class="s0">int ConstPointerToArray&lt; double &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;</span>

<span class="s0">686 17 __releasebuffer__ 0 4 1322 48 ConstPointerToArray&lt; double &gt;::__releasebuffer__ 0 1 14 0</span>
<span class="s0">93</span>
<span class="s0">void ConstPointerToArray&lt; double &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">687 12 __deepcopy__ 0 4 1322 43 ConstPointerToArray&lt; double &gt;::__deepcopy__ 0 1 15 0</span>
<span class="s0">96</span>
<span class="s0">ConstPointerToArray&lt; double &gt; ConstPointerToArray&lt; double &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">688 20 ~ConstPointerToArray 0 516 1322 51 ConstPointerToArray&lt; double &gt;::~ConstPointerToArray 0 0 0</span>
<span class="s0">58</span>
<span class="s0">ConstPointerToArray&lt; double &gt;::~ConstPointerToArray(void);</span>

<span class="s0">689 5 clear 0 4 1330 55 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt;::clear 0 1 39 0</span>
<span class="s0">74</span>
<span class="s0">inline void PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt;::clear(void);</span>

<span class="s0">690 6 output 0 4 1330 56 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt;::output 0 1 40 0</span>
<span class="s0">87</span>
<span class="s0">void PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">691 19 ~PointerToArrayBase 0 516 1329 48 PointerToArrayBase&lt; float &gt;::~PointerToArrayBase 0 0 0</span>
<span class="s0">62</span>
<span class="s0">inline PointerToArrayBase&lt; float &gt;::~PointerToArrayBase(void);</span>

<span class="s0">692 11 operator == 0 4 1329 40 PointerToArrayBase&lt; float &gt;::operator == 0 1 37 64</span>
<span class="s0">// These are implemented in PointerToVoid, but expose them here.</span>
<span class="s0">101</span>
<span class="s0">inline bool PointerToArrayBase&lt; float &gt;::operator ==(PointerToArrayBase&lt; float &gt; const &amp;other) const;</span>

<span class="s0">693 11 operator != 0 4 1329 40 PointerToArrayBase&lt; float &gt;::operator != 0 1 38 0</span>
<span class="s0">101</span>
<span class="s0">inline bool PointerToArrayBase&lt; float &gt;::operator !=(PointerToArrayBase&lt; float &gt; const &amp;other) const;</span>

<span class="s0">694 19 ConstPointerToArray 0 260 1328 49 ConstPointerToArray&lt; float &gt;::ConstPointerToArray 0 2 22 23 0</span>
<span class="s0">194</span>
<span class="s0">inline ConstPointerToArray&lt; float &gt;::ConstPointerToArray(PointerToArray&lt; float &gt; const &amp;copy);</span>
<span class="s0">inline ConstPointerToArray&lt; float &gt;::ConstPointerToArray(ConstPointerToArray&lt; float &gt; const &amp;copy);</span>

<span class="s0">695 5 clear 0 4 1328 35 ConstPointerToArray&lt; float &gt;::clear 0 1 24 0</span>
<span class="s0">54</span>
<span class="s0">inline void ConstPointerToArray&lt; float &gt;::clear(void);</span>

<span class="s0">696 4 size 0 4 1328 34 ConstPointerToArray&lt; float &gt;::size 0 1 25 0</span>
<span class="s0">77</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; float &gt;::size(void) const;</span>

<span class="s0">697 11 get_element 0 4 1328 41 ConstPointerToArray&lt; float &gt;::get_element 0 1 26 0</span>
<span class="s0">94</span>
<span class="s0">inline float const &amp;ConstPointerToArray&lt; float &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">698 11 __getitem__ 0 4 1328 41 ConstPointerToArray&lt; float &gt;::__getitem__ 0 1 27 0</span>
<span class="s0">87</span>
<span class="s0">float const &amp;ConstPointerToArray&lt; float &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">699 8 get_data 0 4 1328 38 ConstPointerToArray&lt; float &gt;::get_data 0 1 28 0</span>
<span class="s0">61</span>
<span class="s0">PyObject *ConstPointerToArray&lt; float &gt;::get_data(void) const;</span>

<span class="s0">700 11 get_subdata 0 4 1328 41 ConstPointerToArray&lt; float &gt;::get_subdata 0 1 29 0</span>
<span class="s0">114</span>
<span class="s0">PyObject *ConstPointerToArray&lt; float &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">701 13 get_ref_count 0 4 1328 43 ConstPointerToArray&lt; float &gt;::get_ref_count 0 1 30 0</span>
<span class="s0">67</span>
<span class="s0">inline int ConstPointerToArray&lt; float &gt;::get_ref_count(void) const;</span>

<span class="s0">702 18 get_node_ref_count 0 4 1328 48 ConstPointerToArray&lt; float &gt;::get_node_ref_count 0 1 31 0</span>
<span class="s0">72</span>
<span class="s0">inline int ConstPointerToArray&lt; float &gt;::get_node_ref_count(void) const;</span>

<span class="s0">703 5 count 0 4 1328 35 ConstPointerToArray&lt; float &gt;::count 0 1 32 0</span>
<span class="s0">87</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; float &gt;::count(float const &amp;) const;</span>

<span class="s0">704 10 __reduce__ 0 4 1328 40 ConstPointerToArray&lt; float &gt;::__reduce__ 0 1 33 0</span>
<span class="s0">73</span>
<span class="s0">PyObject *ConstPointerToArray&lt; float &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">705 13 __getbuffer__ 0 4 1328 43 ConstPointerToArray&lt; float &gt;::__getbuffer__ 0 1 34 0</span>
<span class="s0">98</span>
<span class="s0">int ConstPointerToArray&lt; float &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;</span>

<span class="s0">706 17 __releasebuffer__ 0 4 1328 47 ConstPointerToArray&lt; float &gt;::__releasebuffer__ 0 1 35 0</span>
<span class="s0">92</span>
<span class="s0">void ConstPointerToArray&lt; float &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">707 12 __deepcopy__ 0 4 1328 42 ConstPointerToArray&lt; float &gt;::__deepcopy__ 0 1 36 0</span>
<span class="s0">94</span>
<span class="s0">ConstPointerToArray&lt; float &gt; ConstPointerToArray&lt; float &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">708 20 ~ConstPointerToArray 0 516 1328 50 ConstPointerToArray&lt; float &gt;::~ConstPointerToArray 0 0 0</span>
<span class="s0">57</span>
<span class="s0">ConstPointerToArray&lt; float &gt;::~ConstPointerToArray(void);</span>

<span class="s0">709 5 clear 0 4 1334 53 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt;::clear 0 1 58 0</span>
<span class="s0">72</span>
<span class="s0">inline void PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt;::clear(void);</span>

<span class="s0">710 6 output 0 4 1334 54 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt;::output 0 1 59 0</span>
<span class="s0">85</span>
<span class="s0">void PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">711 19 ~PointerToArrayBase 0 516 1333 46 PointerToArrayBase&lt; int &gt;::~PointerToArrayBase 0 0 0</span>
<span class="s0">60</span>
<span class="s0">inline PointerToArrayBase&lt; int &gt;::~PointerToArrayBase(void);</span>

<span class="s0">712 11 operator == 0 4 1333 38 PointerToArrayBase&lt; int &gt;::operator == 0 1 56 64</span>
<span class="s0">// These are implemented in PointerToVoid, but expose them here.</span>
<span class="s0">97</span>
<span class="s0">inline bool PointerToArrayBase&lt; int &gt;::operator ==(PointerToArrayBase&lt; int &gt; const &amp;other) const;</span>

<span class="s0">713 11 operator != 0 4 1333 38 PointerToArrayBase&lt; int &gt;::operator != 0 1 57 0</span>
<span class="s0">97</span>
<span class="s0">inline bool PointerToArrayBase&lt; int &gt;::operator !=(PointerToArrayBase&lt; int &gt; const &amp;other) const;</span>

<span class="s0">714 19 ConstPointerToArray 0 260 1332 47 ConstPointerToArray&lt; int &gt;::ConstPointerToArray 0 2 41 42 0</span>
<span class="s0">186</span>
<span class="s0">inline ConstPointerToArray&lt; int &gt;::ConstPointerToArray(PointerToArray&lt; int &gt; const &amp;copy);</span>
<span class="s0">inline ConstPointerToArray&lt; int &gt;::ConstPointerToArray(ConstPointerToArray&lt; int &gt; const &amp;copy);</span>

<span class="s0">715 5 clear 0 4 1332 33 ConstPointerToArray&lt; int &gt;::clear 0 1 43 0</span>
<span class="s0">52</span>
<span class="s0">inline void ConstPointerToArray&lt; int &gt;::clear(void);</span>

<span class="s0">716 4 size 0 4 1332 32 ConstPointerToArray&lt; int &gt;::size 0 1 44 0</span>
<span class="s0">75</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; int &gt;::size(void) const;</span>

<span class="s0">717 11 get_element 0 4 1332 39 ConstPointerToArray&lt; int &gt;::get_element 0 1 45 0</span>
<span class="s0">90</span>
<span class="s0">inline int const &amp;ConstPointerToArray&lt; int &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">718 11 __getitem__ 0 4 1332 39 ConstPointerToArray&lt; int &gt;::__getitem__ 0 1 46 0</span>
<span class="s0">83</span>
<span class="s0">int const &amp;ConstPointerToArray&lt; int &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">719 8 get_data 0 4 1332 36 ConstPointerToArray&lt; int &gt;::get_data 0 1 47 0</span>
<span class="s0">59</span>
<span class="s0">PyObject *ConstPointerToArray&lt; int &gt;::get_data(void) const;</span>

<span class="s0">720 11 get_subdata 0 4 1332 39 ConstPointerToArray&lt; int &gt;::get_subdata 0 1 48 0</span>
<span class="s0">112</span>
<span class="s0">PyObject *ConstPointerToArray&lt; int &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">721 13 get_ref_count 0 4 1332 41 ConstPointerToArray&lt; int &gt;::get_ref_count 0 1 49 0</span>
<span class="s0">65</span>
<span class="s0">inline int ConstPointerToArray&lt; int &gt;::get_ref_count(void) const;</span>

<span class="s0">722 18 get_node_ref_count 0 4 1332 46 ConstPointerToArray&lt; int &gt;::get_node_ref_count 0 1 50 0</span>
<span class="s0">70</span>
<span class="s0">inline int ConstPointerToArray&lt; int &gt;::get_node_ref_count(void) const;</span>

<span class="s0">723 5 count 0 4 1332 33 ConstPointerToArray&lt; int &gt;::count 0 1 51 0</span>
<span class="s0">83</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; int &gt;::count(int const &amp;) const;</span>

<span class="s0">724 10 __reduce__ 0 4 1332 38 ConstPointerToArray&lt; int &gt;::__reduce__ 0 1 52 0</span>
<span class="s0">71</span>
<span class="s0">PyObject *ConstPointerToArray&lt; int &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">725 13 __getbuffer__ 0 4 1332 41 ConstPointerToArray&lt; int &gt;::__getbuffer__ 0 1 53 0</span>
<span class="s0">96</span>
<span class="s0">int ConstPointerToArray&lt; int &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;</span>

<span class="s0">726 17 __releasebuffer__ 0 4 1332 45 ConstPointerToArray&lt; int &gt;::__releasebuffer__ 0 1 54 0</span>
<span class="s0">90</span>
<span class="s0">void ConstPointerToArray&lt; int &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">727 12 __deepcopy__ 0 4 1332 40 ConstPointerToArray&lt; int &gt;::__deepcopy__ 0 1 55 0</span>
<span class="s0">90</span>
<span class="s0">ConstPointerToArray&lt; int &gt; ConstPointerToArray&lt; int &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">728 20 ~ConstPointerToArray 0 516 1332 48 ConstPointerToArray&lt; int &gt;::~ConstPointerToArray 0 0 0</span>
<span class="s0">55</span>
<span class="s0">ConstPointerToArray&lt; int &gt;::~ConstPointerToArray(void);</span>

<span class="s0">729 5 clear 0 4 1338 63 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt;::clear 0 1 77 0</span>
<span class="s0">82</span>
<span class="s0">inline void PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt;::clear(void);</span>

<span class="s0">730 6 output 0 4 1338 64 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt;::output 0 1 78 0</span>
<span class="s0">95</span>
<span class="s0">void PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">731 19 ~PointerToArrayBase 0 516 1337 56 PointerToArrayBase&lt; unsigned char &gt;::~PointerToArrayBase 0 0 0</span>
<span class="s0">70</span>
<span class="s0">inline PointerToArrayBase&lt; unsigned char &gt;::~PointerToArrayBase(void);</span>

<span class="s0">732 11 operator == 0 4 1337 48 PointerToArrayBase&lt; unsigned char &gt;::operator == 0 1 75 64</span>
<span class="s0">// These are implemented in PointerToVoid, but expose them here.</span>
<span class="s0">117</span>
<span class="s0">inline bool PointerToArrayBase&lt; unsigned char &gt;::operator ==(PointerToArrayBase&lt; unsigned char &gt; const &amp;other) const;</span>

<span class="s0">733 11 operator != 0 4 1337 48 PointerToArrayBase&lt; unsigned char &gt;::operator != 0 1 76 0</span>
<span class="s0">117</span>
<span class="s0">inline bool PointerToArrayBase&lt; unsigned char &gt;::operator !=(PointerToArrayBase&lt; unsigned char &gt; const &amp;other) const;</span>

<span class="s0">734 19 ConstPointerToArray 0 260 1336 57 ConstPointerToArray&lt; unsigned char &gt;::ConstPointerToArray 0 2 60 61 0</span>
<span class="s0">226</span>
<span class="s0">inline ConstPointerToArray&lt; unsigned char &gt;::ConstPointerToArray(PointerToArray&lt; unsigned char &gt; const &amp;copy);</span>
<span class="s0">inline ConstPointerToArray&lt; unsigned char &gt;::ConstPointerToArray(ConstPointerToArray&lt; unsigned char &gt; const &amp;copy);</span>

<span class="s0">735 5 clear 0 4 1336 43 ConstPointerToArray&lt; unsigned char &gt;::clear 0 1 62 0</span>
<span class="s0">62</span>
<span class="s0">inline void ConstPointerToArray&lt; unsigned char &gt;::clear(void);</span>

<span class="s0">736 4 size 0 4 1336 42 ConstPointerToArray&lt; unsigned char &gt;::size 0 1 63 0</span>
<span class="s0">85</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; unsigned char &gt;::size(void) const;</span>

<span class="s0">737 11 get_element 0 4 1336 49 ConstPointerToArray&lt; unsigned char &gt;::get_element 0 1 64 0</span>
<span class="s0">110</span>
<span class="s0">inline unsigned char const &amp;ConstPointerToArray&lt; unsigned char &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">738 11 __getitem__ 0 4 1336 49 ConstPointerToArray&lt; unsigned char &gt;::__getitem__ 0 1 65 0</span>
<span class="s0">103</span>
<span class="s0">unsigned char const &amp;ConstPointerToArray&lt; unsigned char &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">739 8 get_data 0 4 1336 46 ConstPointerToArray&lt; unsigned char &gt;::get_data 0 1 66 0</span>
<span class="s0">69</span>
<span class="s0">PyObject *ConstPointerToArray&lt; unsigned char &gt;::get_data(void) const;</span>

<span class="s0">740 11 get_subdata 0 4 1336 49 ConstPointerToArray&lt; unsigned char &gt;::get_subdata 0 1 67 0</span>
<span class="s0">122</span>
<span class="s0">PyObject *ConstPointerToArray&lt; unsigned char &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">741 13 get_ref_count 0 4 1336 51 ConstPointerToArray&lt; unsigned char &gt;::get_ref_count 0 1 68 0</span>
<span class="s0">75</span>
<span class="s0">inline int ConstPointerToArray&lt; unsigned char &gt;::get_ref_count(void) const;</span>

<span class="s0">742 18 get_node_ref_count 0 4 1336 56 ConstPointerToArray&lt; unsigned char &gt;::get_node_ref_count 0 1 69 0</span>
<span class="s0">80</span>
<span class="s0">inline int ConstPointerToArray&lt; unsigned char &gt;::get_node_ref_count(void) const;</span>

<span class="s0">743 5 count 0 4 1336 43 ConstPointerToArray&lt; unsigned char &gt;::count 0 1 70 0</span>
<span class="s0">103</span>
<span class="s0">inline unsigned long long int ConstPointerToArray&lt; unsigned char &gt;::count(unsigned char const &amp;) const;</span>

<span class="s0">744 10 __reduce__ 0 4 1336 48 ConstPointerToArray&lt; unsigned char &gt;::__reduce__ 0 1 71 0</span>
<span class="s0">81</span>
<span class="s0">PyObject *ConstPointerToArray&lt; unsigned char &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">745 13 __getbuffer__ 0 4 1336 51 ConstPointerToArray&lt; unsigned char &gt;::__getbuffer__ 0 1 72 0</span>
<span class="s0">106</span>
<span class="s0">int ConstPointerToArray&lt; unsigned char &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;</span>

<span class="s0">746 17 __releasebuffer__ 0 4 1336 55 ConstPointerToArray&lt; unsigned char &gt;::__releasebuffer__ 0 1 73 0</span>
<span class="s0">100</span>
<span class="s0">void ConstPointerToArray&lt; unsigned char &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">747 12 __deepcopy__ 0 4 1336 50 ConstPointerToArray&lt; unsigned char &gt;::__deepcopy__ 0 1 74 0</span>
<span class="s0">110</span>
<span class="s0">ConstPointerToArray&lt; unsigned char &gt; ConstPointerToArray&lt; unsigned char &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">748 20 ~ConstPointerToArray 0 516 1336 58 ConstPointerToArray&lt; unsigned char &gt;::~ConstPointerToArray 0 0 0</span>
<span class="s0">65</span>
<span class="s0">ConstPointerToArray&lt; unsigned char &gt;::~ConstPointerToArray(void);</span>

<span class="s0">749 14 PointerToArray 0 260 1340 40 PointerToArray&lt; double &gt;::PointerToArray 0 3 79 80 81 0</span>
<span class="s0">279</span>
<span class="s0">inline PointerToArray&lt; double &gt;::PointerToArray(TypeHandle type_handle = (::_get_type_handle((double const *)(0))));</span>
<span class="s0">inline PointerToArray&lt; double &gt;::PointerToArray(PointerToArray&lt; double &gt; const &amp;copy);</span>
<span class="s0">PointerToArray&lt; double &gt;::PointerToArray(PyObject *self, PyObject *source);</span>

<span class="s0">750 11 empty_array 0 4 1340 37 PointerToArray&lt; double &gt;::empty_array 0 1 82 0</span>
<span class="s0">171</span>
<span class="s0">static inline PointerToArray&lt; double &gt; PointerToArray&lt; double &gt;::empty_array(unsigned long long int n, TypeHandle type_handle = (::_get_type_handle((double const *)(0))));</span>

<span class="s0">751 5 clear 0 4 1340 31 PointerToArray&lt; double &gt;::clear 0 1 83 0</span>
<span class="s0">50</span>
<span class="s0">inline void PointerToArray&lt; double &gt;::clear(void);</span>

<span class="s0">752 4 size 0 4 1340 30 PointerToArray&lt; double &gt;::size 0 1 84 0</span>
<span class="s0">73</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; double &gt;::size(void) const;</span>

<span class="s0">753 9 push_back 0 4 1340 35 PointerToArray&lt; double &gt;::push_back 0 1 85 0</span>
<span class="s0">65</span>
<span class="s0">inline void PointerToArray&lt; double &gt;::push_back(double const &amp;x);</span>

<span class="s0">754 8 pop_back 0 4 1340 34 PointerToArray&lt; double &gt;::pop_back 0 1 86 0</span>
<span class="s0">53</span>
<span class="s0">inline void PointerToArray&lt; double &gt;::pop_back(void);</span>

<span class="s0">755 11 get_element 0 4 1340 37 PointerToArray&lt; double &gt;::get_element 0 1 87 0</span>
<span class="s0">91</span>
<span class="s0">inline double const &amp;PointerToArray&lt; double &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">756 11 set_element 0 4 1340 37 PointerToArray&lt; double &gt;::set_element 0 1 88 0</span>
<span class="s0">97</span>
<span class="s0">inline void PointerToArray&lt; double &gt;::set_element(unsigned long long int n, double const &amp;value);</span>

<span class="s0">757 11 __getitem__ 0 4 1340 37 PointerToArray&lt; double &gt;::__getitem__ 0 1 89 0</span>
<span class="s0">84</span>
<span class="s0">double const &amp;PointerToArray&lt; double &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">758 11 __setitem__ 0 4 1340 37 PointerToArray&lt; double &gt;::__setitem__ 0 1 90 0</span>
<span class="s0">90</span>
<span class="s0">void PointerToArray&lt; double &gt;::__setitem__(unsigned long long int n, double const &amp;value);</span>

<span class="s0">759 8 get_data 0 4 1340 34 PointerToArray&lt; double &gt;::get_data 0 1 91 0</span>
<span class="s0">57</span>
<span class="s0">PyObject *PointerToArray&lt; double &gt;::get_data(void) const;</span>

<span class="s0">760 8 set_data 0 4 1340 34 PointerToArray&lt; double &gt;::set_data 0 1 92 0</span>
<span class="s0">56</span>
<span class="s0">void PointerToArray&lt; double &gt;::set_data(PyObject *data);</span>

<span class="s0">761 11 get_subdata 0 4 1340 37 PointerToArray&lt; double &gt;::get_subdata 0 1 93 0</span>
<span class="s0">110</span>
<span class="s0">PyObject *PointerToArray&lt; double &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">762 11 set_subdata 0 4 1340 37 PointerToArray&lt; double &gt;::set_subdata 0 1 94 0</span>
<span class="s0">145</span>
<span class="s0">inline void PointerToArray&lt; double &gt;::set_subdata(unsigned long long int n, unsigned long long int count, std::basic_string&lt; char &gt; const &amp;data);</span>

<span class="s0">763 13 get_ref_count 0 4 1340 39 PointerToArray&lt; double &gt;::get_ref_count 0 1 95 0</span>
<span class="s0">63</span>
<span class="s0">inline int PointerToArray&lt; double &gt;::get_ref_count(void) const;</span>

<span class="s0">764 18 get_node_ref_count 0 4 1340 44 PointerToArray&lt; double &gt;::get_node_ref_count 0 1 96 0</span>
<span class="s0">68</span>
<span class="s0">inline int PointerToArray&lt; double &gt;::get_node_ref_count(void) const;</span>

<span class="s0">765 5 count 0 4 1340 31 PointerToArray&lt; double &gt;::count 0 1 97 0</span>
<span class="s0">84</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; double &gt;::count(double const &amp;) const;</span>

<span class="s0">766 10 __reduce__ 0 4 1340 36 PointerToArray&lt; double &gt;::__reduce__ 0 1 98 0</span>
<span class="s0">69</span>
<span class="s0">PyObject *PointerToArray&lt; double &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">767 13 __getbuffer__ 0 4 1340 39 PointerToArray&lt; double &gt;::__getbuffer__ 0 1 99 0</span>
<span class="s0">88</span>
<span class="s0">int PointerToArray&lt; double &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags);</span>

<span class="s0">768 17 __releasebuffer__ 0 4 1340 43 PointerToArray&lt; double &gt;::__releasebuffer__ 0 1 100 0</span>
<span class="s0">88</span>
<span class="s0">void PointerToArray&lt; double &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">769 12 __deepcopy__ 0 4 1340 38 PointerToArray&lt; double &gt;::__deepcopy__ 0 1 101 0</span>
<span class="s0">86</span>
<span class="s0">PointerToArray&lt; double &gt; PointerToArray&lt; double &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">770 15 ~PointerToArray 0 516 1340 41 PointerToArray&lt; double &gt;::~PointerToArray 0 0 0</span>
<span class="s0">48</span>
<span class="s0">PointerToArray&lt; double &gt;::~PointerToArray(void);</span>

<span class="s0">771 14 PointerToArray 0 260 1342 39 PointerToArray&lt; float &gt;::PointerToArray 0 3 102 103 104 0</span>
<span class="s0">274</span>
<span class="s0">inline PointerToArray&lt; float &gt;::PointerToArray(TypeHandle type_handle = (::_get_type_handle((float const *)(0))));</span>
<span class="s0">inline PointerToArray&lt; float &gt;::PointerToArray(PointerToArray&lt; float &gt; const &amp;copy);</span>
<span class="s0">PointerToArray&lt; float &gt;::PointerToArray(PyObject *self, PyObject *source);</span>

<span class="s0">772 11 empty_array 0 4 1342 36 PointerToArray&lt; float &gt;::empty_array 0 1 105 0</span>
<span class="s0">168</span>
<span class="s0">static inline PointerToArray&lt; float &gt; PointerToArray&lt; float &gt;::empty_array(unsigned long long int n, TypeHandle type_handle = (::_get_type_handle((float const *)(0))));</span>

<span class="s0">773 5 clear 0 4 1342 30 PointerToArray&lt; float &gt;::clear 0 1 106 0</span>
<span class="s0">49</span>
<span class="s0">inline void PointerToArray&lt; float &gt;::clear(void);</span>

<span class="s0">774 4 size 0 4 1342 29 PointerToArray&lt; float &gt;::size 0 1 107 0</span>
<span class="s0">72</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; float &gt;::size(void) const;</span>

<span class="s0">775 9 push_back 0 4 1342 34 PointerToArray&lt; float &gt;::push_back 0 1 108 0</span>
<span class="s0">63</span>
<span class="s0">inline void PointerToArray&lt; float &gt;::push_back(float const &amp;x);</span>

<span class="s0">776 8 pop_back 0 4 1342 33 PointerToArray&lt; float &gt;::pop_back 0 1 109 0</span>
<span class="s0">52</span>
<span class="s0">inline void PointerToArray&lt; float &gt;::pop_back(void);</span>

<span class="s0">777 11 get_element 0 4 1342 36 PointerToArray&lt; float &gt;::get_element 0 1 110 0</span>
<span class="s0">89</span>
<span class="s0">inline float const &amp;PointerToArray&lt; float &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">778 11 set_element 0 4 1342 36 PointerToArray&lt; float &gt;::set_element 0 1 111 0</span>
<span class="s0">95</span>
<span class="s0">inline void PointerToArray&lt; float &gt;::set_element(unsigned long long int n, float const &amp;value);</span>

<span class="s0">779 11 __getitem__ 0 4 1342 36 PointerToArray&lt; float &gt;::__getitem__ 0 1 112 0</span>
<span class="s0">82</span>
<span class="s0">float const &amp;PointerToArray&lt; float &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">780 11 __setitem__ 0 4 1342 36 PointerToArray&lt; float &gt;::__setitem__ 0 1 113 0</span>
<span class="s0">88</span>
<span class="s0">void PointerToArray&lt; float &gt;::__setitem__(unsigned long long int n, float const &amp;value);</span>

<span class="s0">781 8 get_data 0 4 1342 33 PointerToArray&lt; float &gt;::get_data 0 1 114 0</span>
<span class="s0">56</span>
<span class="s0">PyObject *PointerToArray&lt; float &gt;::get_data(void) const;</span>

<span class="s0">782 8 set_data 0 4 1342 33 PointerToArray&lt; float &gt;::set_data 0 1 115 0</span>
<span class="s0">55</span>
<span class="s0">void PointerToArray&lt; float &gt;::set_data(PyObject *data);</span>

<span class="s0">783 11 get_subdata 0 4 1342 36 PointerToArray&lt; float &gt;::get_subdata 0 1 116 0</span>
<span class="s0">109</span>
<span class="s0">PyObject *PointerToArray&lt; float &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">784 11 set_subdata 0 4 1342 36 PointerToArray&lt; float &gt;::set_subdata 0 1 117 0</span>
<span class="s0">144</span>
<span class="s0">inline void PointerToArray&lt; float &gt;::set_subdata(unsigned long long int n, unsigned long long int count, std::basic_string&lt; char &gt; const &amp;data);</span>

<span class="s0">785 13 get_ref_count 0 4 1342 38 PointerToArray&lt; float &gt;::get_ref_count 0 1 118 0</span>
<span class="s0">62</span>
<span class="s0">inline int PointerToArray&lt; float &gt;::get_ref_count(void) const;</span>

<span class="s0">786 18 get_node_ref_count 0 4 1342 43 PointerToArray&lt; float &gt;::get_node_ref_count 0 1 119 0</span>
<span class="s0">67</span>
<span class="s0">inline int PointerToArray&lt; float &gt;::get_node_ref_count(void) const;</span>

<span class="s0">787 5 count 0 4 1342 30 PointerToArray&lt; float &gt;::count 0 1 120 0</span>
<span class="s0">82</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; float &gt;::count(float const &amp;) const;</span>

<span class="s0">788 10 __reduce__ 0 4 1342 35 PointerToArray&lt; float &gt;::__reduce__ 0 1 121 0</span>
<span class="s0">68</span>
<span class="s0">PyObject *PointerToArray&lt; float &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">789 13 __getbuffer__ 0 4 1342 38 PointerToArray&lt; float &gt;::__getbuffer__ 0 1 122 0</span>
<span class="s0">87</span>
<span class="s0">int PointerToArray&lt; float &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags);</span>

<span class="s0">790 17 __releasebuffer__ 0 4 1342 42 PointerToArray&lt; float &gt;::__releasebuffer__ 0 1 123 0</span>
<span class="s0">87</span>
<span class="s0">void PointerToArray&lt; float &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">791 12 __deepcopy__ 0 4 1342 37 PointerToArray&lt; float &gt;::__deepcopy__ 0 1 124 0</span>
<span class="s0">84</span>
<span class="s0">PointerToArray&lt; float &gt; PointerToArray&lt; float &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">792 15 ~PointerToArray 0 516 1342 40 PointerToArray&lt; float &gt;::~PointerToArray 0 0 0</span>
<span class="s0">47</span>
<span class="s0">PointerToArray&lt; float &gt;::~PointerToArray(void);</span>

<span class="s0">793 14 PointerToArray 0 260 1344 37 PointerToArray&lt; int &gt;::PointerToArray 0 3 125 126 127 0</span>
<span class="s0">264</span>
<span class="s0">inline PointerToArray&lt; int &gt;::PointerToArray(TypeHandle type_handle = (::_get_type_handle((int const *)(0))));</span>
<span class="s0">inline PointerToArray&lt; int &gt;::PointerToArray(PointerToArray&lt; int &gt; const &amp;copy);</span>
<span class="s0">PointerToArray&lt; int &gt;::PointerToArray(PyObject *self, PyObject *source);</span>

<span class="s0">794 11 empty_array 0 4 1344 34 PointerToArray&lt; int &gt;::empty_array 0 1 128 0</span>
<span class="s0">162</span>
<span class="s0">static inline PointerToArray&lt; int &gt; PointerToArray&lt; int &gt;::empty_array(unsigned long long int n, TypeHandle type_handle = (::_get_type_handle((int const *)(0))));</span>

<span class="s0">795 5 clear 0 4 1344 28 PointerToArray&lt; int &gt;::clear 0 1 129 0</span>
<span class="s0">47</span>
<span class="s0">inline void PointerToArray&lt; int &gt;::clear(void);</span>

<span class="s0">796 4 size 0 4 1344 27 PointerToArray&lt; int &gt;::size 0 1 130 0</span>
<span class="s0">70</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; int &gt;::size(void) const;</span>

<span class="s0">797 9 push_back 0 4 1344 32 PointerToArray&lt; int &gt;::push_back 0 1 131 0</span>
<span class="s0">59</span>
<span class="s0">inline void PointerToArray&lt; int &gt;::push_back(int const &amp;x);</span>

<span class="s0">798 8 pop_back 0 4 1344 31 PointerToArray&lt; int &gt;::pop_back 0 1 132 0</span>
<span class="s0">50</span>
<span class="s0">inline void PointerToArray&lt; int &gt;::pop_back(void);</span>

<span class="s0">799 11 get_element 0 4 1344 34 PointerToArray&lt; int &gt;::get_element 0 1 133 0</span>
<span class="s0">85</span>
<span class="s0">inline int const &amp;PointerToArray&lt; int &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">800 11 set_element 0 4 1344 34 PointerToArray&lt; int &gt;::set_element 0 1 134 0</span>
<span class="s0">91</span>
<span class="s0">inline void PointerToArray&lt; int &gt;::set_element(unsigned long long int n, int const &amp;value);</span>

<span class="s0">801 11 __getitem__ 0 4 1344 34 PointerToArray&lt; int &gt;::__getitem__ 0 1 135 0</span>
<span class="s0">78</span>
<span class="s0">int const &amp;PointerToArray&lt; int &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">802 11 __setitem__ 0 4 1344 34 PointerToArray&lt; int &gt;::__setitem__ 0 1 136 0</span>
<span class="s0">84</span>
<span class="s0">void PointerToArray&lt; int &gt;::__setitem__(unsigned long long int n, int const &amp;value);</span>

<span class="s0">803 8 get_data 0 4 1344 31 PointerToArray&lt; int &gt;::get_data 0 1 137 0</span>
<span class="s0">54</span>
<span class="s0">PyObject *PointerToArray&lt; int &gt;::get_data(void) const;</span>

<span class="s0">804 8 set_data 0 4 1344 31 PointerToArray&lt; int &gt;::set_data 0 1 138 0</span>
<span class="s0">53</span>
<span class="s0">void PointerToArray&lt; int &gt;::set_data(PyObject *data);</span>

<span class="s0">805 11 get_subdata 0 4 1344 34 PointerToArray&lt; int &gt;::get_subdata 0 1 139 0</span>
<span class="s0">107</span>
<span class="s0">PyObject *PointerToArray&lt; int &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">806 11 set_subdata 0 4 1344 34 PointerToArray&lt; int &gt;::set_subdata 0 1 140 0</span>
<span class="s0">142</span>
<span class="s0">inline void PointerToArray&lt; int &gt;::set_subdata(unsigned long long int n, unsigned long long int count, std::basic_string&lt; char &gt; const &amp;data);</span>

<span class="s0">807 13 get_ref_count 0 4 1344 36 PointerToArray&lt; int &gt;::get_ref_count 0 1 141 0</span>
<span class="s0">60</span>
<span class="s0">inline int PointerToArray&lt; int &gt;::get_ref_count(void) const;</span>

<span class="s0">808 18 get_node_ref_count 0 4 1344 41 PointerToArray&lt; int &gt;::get_node_ref_count 0 1 142 0</span>
<span class="s0">65</span>
<span class="s0">inline int PointerToArray&lt; int &gt;::get_node_ref_count(void) const;</span>

<span class="s0">809 5 count 0 4 1344 28 PointerToArray&lt; int &gt;::count 0 1 143 0</span>
<span class="s0">78</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; int &gt;::count(int const &amp;) const;</span>

<span class="s0">810 10 __reduce__ 0 4 1344 33 PointerToArray&lt; int &gt;::__reduce__ 0 1 144 0</span>
<span class="s0">66</span>
<span class="s0">PyObject *PointerToArray&lt; int &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">811 13 __getbuffer__ 0 4 1344 36 PointerToArray&lt; int &gt;::__getbuffer__ 0 1 145 0</span>
<span class="s0">85</span>
<span class="s0">int PointerToArray&lt; int &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags);</span>

<span class="s0">812 17 __releasebuffer__ 0 4 1344 40 PointerToArray&lt; int &gt;::__releasebuffer__ 0 1 146 0</span>
<span class="s0">85</span>
<span class="s0">void PointerToArray&lt; int &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">813 12 __deepcopy__ 0 4 1344 35 PointerToArray&lt; int &gt;::__deepcopy__ 0 1 147 0</span>
<span class="s0">80</span>
<span class="s0">PointerToArray&lt; int &gt; PointerToArray&lt; int &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">814 15 ~PointerToArray 0 516 1344 38 PointerToArray&lt; int &gt;::~PointerToArray 0 0 0</span>
<span class="s0">45</span>
<span class="s0">PointerToArray&lt; int &gt;::~PointerToArray(void);</span>

<span class="s0">815 14 PointerToArray 0 260 1346 47 PointerToArray&lt; unsigned char &gt;::PointerToArray 0 3 148 149 150 0</span>
<span class="s0">314</span>
<span class="s0">inline PointerToArray&lt; unsigned char &gt;::PointerToArray(TypeHandle type_handle = (::_get_type_handle((unsigned char const *)(0))));</span>
<span class="s0">inline PointerToArray&lt; unsigned char &gt;::PointerToArray(PointerToArray&lt; unsigned char &gt; const &amp;copy);</span>
<span class="s0">PointerToArray&lt; unsigned char &gt;::PointerToArray(PyObject *self, PyObject *source);</span>

<span class="s0">816 11 empty_array 0 4 1346 44 PointerToArray&lt; unsigned char &gt;::empty_array 0 1 151 0</span>
<span class="s0">192</span>
<span class="s0">static inline PointerToArray&lt; unsigned char &gt; PointerToArray&lt; unsigned char &gt;::empty_array(unsigned long long int n, TypeHandle type_handle = (::_get_type_handle((unsigned char const *)(0))));</span>

<span class="s0">817 5 clear 0 4 1346 38 PointerToArray&lt; unsigned char &gt;::clear 0 1 152 0</span>
<span class="s0">57</span>
<span class="s0">inline void PointerToArray&lt; unsigned char &gt;::clear(void);</span>

<span class="s0">818 4 size 0 4 1346 37 PointerToArray&lt; unsigned char &gt;::size 0 1 153 0</span>
<span class="s0">80</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; unsigned char &gt;::size(void) const;</span>

<span class="s0">819 9 push_back 0 4 1346 42 PointerToArray&lt; unsigned char &gt;::push_back 0 1 154 0</span>
<span class="s0">79</span>
<span class="s0">inline void PointerToArray&lt; unsigned char &gt;::push_back(unsigned char const &amp;x);</span>

<span class="s0">820 8 pop_back 0 4 1346 41 PointerToArray&lt; unsigned char &gt;::pop_back 0 1 155 0</span>
<span class="s0">60</span>
<span class="s0">inline void PointerToArray&lt; unsigned char &gt;::pop_back(void);</span>

<span class="s0">821 11 get_element 0 4 1346 44 PointerToArray&lt; unsigned char &gt;::get_element 0 1 156 0</span>
<span class="s0">105</span>
<span class="s0">inline unsigned char const &amp;PointerToArray&lt; unsigned char &gt;::get_element(unsigned long long int n) const;</span>

<span class="s0">822 11 set_element 0 4 1346 44 PointerToArray&lt; unsigned char &gt;::set_element 0 1 157 0</span>
<span class="s0">111</span>
<span class="s0">inline void PointerToArray&lt; unsigned char &gt;::set_element(unsigned long long int n, unsigned char const &amp;value);</span>

<span class="s0">823 11 __getitem__ 0 4 1346 44 PointerToArray&lt; unsigned char &gt;::__getitem__ 0 1 158 0</span>
<span class="s0">98</span>
<span class="s0">unsigned char const &amp;PointerToArray&lt; unsigned char &gt;::__getitem__(unsigned long long int n) const;</span>

<span class="s0">824 11 __setitem__ 0 4 1346 44 PointerToArray&lt; unsigned char &gt;::__setitem__ 0 1 159 0</span>
<span class="s0">104</span>
<span class="s0">void PointerToArray&lt; unsigned char &gt;::__setitem__(unsigned long long int n, unsigned char const &amp;value);</span>

<span class="s0">825 8 get_data 0 4 1346 41 PointerToArray&lt; unsigned char &gt;::get_data 0 1 160 0</span>
<span class="s0">64</span>
<span class="s0">PyObject *PointerToArray&lt; unsigned char &gt;::get_data(void) const;</span>

<span class="s0">826 8 set_data 0 4 1346 41 PointerToArray&lt; unsigned char &gt;::set_data 0 1 161 0</span>
<span class="s0">63</span>
<span class="s0">void PointerToArray&lt; unsigned char &gt;::set_data(PyObject *data);</span>

<span class="s0">827 11 get_subdata 0 4 1346 44 PointerToArray&lt; unsigned char &gt;::get_subdata 0 1 162 0</span>
<span class="s0">117</span>
<span class="s0">PyObject *PointerToArray&lt; unsigned char &gt;::get_subdata(unsigned long long int n, unsigned long long int count) const;</span>

<span class="s0">828 11 set_subdata 0 4 1346 44 PointerToArray&lt; unsigned char &gt;::set_subdata 0 1 163 0</span>
<span class="s0">152</span>
<span class="s0">inline void PointerToArray&lt; unsigned char &gt;::set_subdata(unsigned long long int n, unsigned long long int count, std::basic_string&lt; char &gt; const &amp;data);</span>

<span class="s0">829 13 get_ref_count 0 4 1346 46 PointerToArray&lt; unsigned char &gt;::get_ref_count 0 1 164 0</span>
<span class="s0">70</span>
<span class="s0">inline int PointerToArray&lt; unsigned char &gt;::get_ref_count(void) const;</span>

<span class="s0">830 18 get_node_ref_count 0 4 1346 51 PointerToArray&lt; unsigned char &gt;::get_node_ref_count 0 1 165 0</span>
<span class="s0">75</span>
<span class="s0">inline int PointerToArray&lt; unsigned char &gt;::get_node_ref_count(void) const;</span>

<span class="s0">831 5 count 0 4 1346 38 PointerToArray&lt; unsigned char &gt;::count 0 1 166 0</span>
<span class="s0">98</span>
<span class="s0">inline unsigned long long int PointerToArray&lt; unsigned char &gt;::count(unsigned char const &amp;) const;</span>

<span class="s0">832 10 __reduce__ 0 4 1346 43 PointerToArray&lt; unsigned char &gt;::__reduce__ 0 1 167 0</span>
<span class="s0">76</span>
<span class="s0">PyObject *PointerToArray&lt; unsigned char &gt;::__reduce__(PyObject *self) const;</span>

<span class="s0">833 13 __getbuffer__ 0 4 1346 46 PointerToArray&lt; unsigned char &gt;::__getbuffer__ 0 1 168 0</span>
<span class="s0">95</span>
<span class="s0">int PointerToArray&lt; unsigned char &gt;::__getbuffer__(PyObject *self, Py_buffer *view, int flags);</span>

<span class="s0">834 17 __releasebuffer__ 0 4 1346 50 PointerToArray&lt; unsigned char &gt;::__releasebuffer__ 0 1 169 0</span>
<span class="s0">95</span>
<span class="s0">void PointerToArray&lt; unsigned char &gt;::__releasebuffer__(PyObject *self, Py_buffer *view) const;</span>

<span class="s0">835 12 __deepcopy__ 0 4 1346 45 PointerToArray&lt; unsigned char &gt;::__deepcopy__ 0 1 170 0</span>
<span class="s0">100</span>
<span class="s0">PointerToArray&lt; unsigned char &gt; PointerToArray&lt; unsigned char &gt;::__deepcopy__(PyObject *memo) const;</span>

<span class="s0">836 15 ~PointerToArray 0 516 1346 48 PointerToArray&lt; unsigned char &gt;::~PointerToArray 0 0 0</span>
<span class="s0">55</span>
<span class="s0">PointerToArray&lt; unsigned char &gt;::~PointerToArray(void);</span>

<span class="s0">837 11 is_tracking 0 4 1347 24 MemoryUsage::is_tracking 0 1 172 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the MemoryUsage object is currently tracking memory (e.g.</span>
 <span class="s0">* track-memory-usage is configured #t).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static inline bool MemoryUsage::is_tracking(void);</span>

<span class="s0">838 11 is_counting 0 4 1347 24 MemoryUsage::is_counting 0 1 173 168</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the MemoryUsage object is currently at least counting</span>
 <span class="s0">* memory (e.g.  this is a Windows debug build), even if it's not fully</span>
 <span class="s0">* tracking it.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">static inline bool MemoryUsage::is_counting(void);</span>

<span class="s0">839 20 get_current_cpp_size 0 4 1347 33 MemoryUsage::get_current_cpp_size 0 1 174 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes of allocated memory consumed by C++</span>
 <span class="s0">* objects, not including the memory previously frozen.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline std::size_t MemoryUsage::get_current_cpp_size(void);</span>

<span class="s0">840 18 get_total_cpp_size 0 4 1347 31 MemoryUsage::get_total_cpp_size 0 1 175 132</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes of allocated memory consumed by C++</span>
 <span class="s0">* objects, including the memory previously frozen.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">static inline std::size_t MemoryUsage::get_total_cpp_size(void);</span>

<span class="s0">841 26 get_panda_heap_single_size 0 4 1347 39 MemoryUsage::get_panda_heap_single_size 0 1 176 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes allocated from the heap from code within</span>
 <span class="s0">* Panda, for individual objects.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">static inline std::size_t MemoryUsage::get_panda_heap_single_size(void);</span>

<span class="s0">842 25 get_panda_heap_array_size 0 4 1347 38 MemoryUsage::get_panda_heap_array_size 0 1 177 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes allocated from the heap from code within</span>
 <span class="s0">* Panda, for arrays.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">static inline std::size_t MemoryUsage::get_panda_heap_array_size(void);</span>

<span class="s0">843 23 get_panda_heap_overhead 0 4 1347 36 MemoryUsage::get_panda_heap_overhead 0 1 178 190</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the extra bytes allocated from the system that are not immediately</span>
 <span class="s0">* used for holding allocated objects.  This can only be determined if</span>
 <span class="s0">* ALTERNATIVE_MALLOC is enabled.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static inline std::size_t MemoryUsage::get_panda_heap_overhead(void);</span>

<span class="s0">844 19 get_panda_mmap_size 0 4 1347 32 MemoryUsage::get_panda_mmap_size 0 1 179 110</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes allocated from the virtual memory pool</span>
 <span class="s0">* from code within Panda.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">static inline std::size_t MemoryUsage::get_panda_mmap_size(void);</span>

<span class="s0">845 17 get_external_size 0 4 1347 30 MemoryUsage::get_external_size 0 1 180 496</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total number of bytes of allocated memory in the heap that</span>
 <span class="s0">* Panda didn't seem to be responsible for.  This includes a few bytes for</span>
 <span class="s0">* very low-level objects (like ConfigVariables) that cannot use Panda memory</span>
 <span class="s0">* tracking because they are so very low-level.</span>
 <span class="s0">*</span>
 <span class="s0">* This also includes all of the memory that might have been allocated by a</span>
 <span class="s0">* high-level interpreter, like Python.</span>
 <span class="s0">*</span>
 <span class="s0">* This number is only available if Panda is able to hook into the actual heap</span>
 <span class="s0">* callback.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">static inline std::size_t MemoryUsage::get_external_size(void);</span>

<span class="s0">846 14 get_total_size 0 4 1347 27 MemoryUsage::get_total_size 0 1 181 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the total size of allocated memory consumed by the process, as</span>
 <span class="s0">* nearly as can be determined.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">static inline std::size_t MemoryUsage::get_total_size(void);</span>

<span class="s0">847 16 get_num_pointers 0 4 1347 29 MemoryUsage::get_num_pointers 0 1 182 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of pointers currently active.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">static inline int MemoryUsage::get_num_pointers(void);</span>

<span class="s0">848 12 get_pointers 0 4 1347 25 MemoryUsage::get_pointers 0 1 183 100</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the indicated MemoryUsagePointers with the set of all pointers</span>
 <span class="s0">* currently active.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">static inline void MemoryUsage::get_pointers(MemoryUsagePointers &amp;result);</span>

<span class="s0">849 20 get_pointers_of_type 0 4 1347 33 MemoryUsage::get_pointers_of_type 0 1 184 122</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the indicated MemoryUsagePointers with the set of all pointers of the</span>
 <span class="s0">* indicated type currently active.</span>
 <span class="s0">*/</span>
<span class="s0">99</span>
<span class="s0">static inline void MemoryUsage::get_pointers_of_type(MemoryUsagePointers &amp;result, TypeHandle type);</span>

<span class="s0">850 19 get_pointers_of_age 0 4 1347 32 MemoryUsage::get_pointers_of_age 0 1 185 159</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the indicated MemoryUsagePointers with the set of all pointers that</span>
 <span class="s0">* were allocated within the range of the indicated number of seconds ago.</span>
 <span class="s0">*/</span>
<span class="s0">105</span>
<span class="s0">static inline void MemoryUsage::get_pointers_of_age(MemoryUsagePointers &amp;result, double from, double to);</span>

<span class="s0">851 28 get_pointers_with_zero_count 0 4 1347 41 MemoryUsage::get_pointers_with_zero_count 0 1 186 852</span>
<span class="s0">/**</span>
 <span class="s0">* Fills the indicated MemoryUsagePointers with the set of all currently</span>
 <span class="s0">* active pointers (that is, pointers allocated since the last call to</span>
 <span class="s0">* freeze(), and not yet freed) that have a zero reference count.</span>
 <span class="s0">*</span>
 <span class="s0">* Generally, an undeleted pointer with a zero reference count means its</span>
 <span class="s0">* reference count has never been incremented beyond zero (since once it has</span>
 <span class="s0">* been incremented, the only way it can return to zero would free the</span>
 <span class="s0">* pointer).  This may include objects that are allocated statically or on the</span>
 <span class="s0">* stack, which are never intended to be deleted.  Or, it might represent a</span>
 <span class="s0">* programmer or compiler error.</span>
 <span class="s0">*</span>
 <span class="s0">* This function has the side-effect of incrementing each of their reference</span>
 <span class="s0">* counts by one, thus preventing them from ever being freed--but since they</span>
 <span class="s0">* hadn't been freed anyway, probably no additional harm is done.</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">static inline void MemoryUsage::get_pointers_with_zero_count(MemoryUsagePointers &amp;result);</span>

<span class="s0">852 6 freeze 0 4 1347 19 MemoryUsage::freeze 0 1 187 285</span>
<span class="s0">/**</span>
 <span class="s0">* 'Freezes' all pointers currently stored so that they are no longer</span>
 <span class="s0">* reported; only newly allocate pointers from this point on will appear in</span>
 <span class="s0">* future information requests.  This makes it easier to differentiate between</span>
 <span class="s0">* continuous leaks and one-time memory allocations.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">static inline void MemoryUsage::freeze(void);</span>

<span class="s0">853 18 show_current_types 0 4 1347 31 MemoryUsage::show_current_types 0 1 188 70</span>
<span class="s0">/**</span>
 <span class="s0">* Shows the breakdown of types of all of the active pointers.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline void MemoryUsage::show_current_types(void);</span>

<span class="s0">854 16 show_trend_types 0 4 1347 29 MemoryUsage::show_trend_types 0 1 189 118</span>
<span class="s0">/**</span>
 <span class="s0">* Shows the breakdown of types of all of the pointers allocated and freed</span>
 <span class="s0">* since the last call to freeze().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">static inline void MemoryUsage::show_trend_types(void);</span>

<span class="s0">855 17 show_current_ages 0 4 1347 30 MemoryUsage::show_current_ages 0 1 190 69</span>
<span class="s0">/**</span>
 <span class="s0">* Shows the breakdown of ages of all of the active pointers.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">static inline void MemoryUsage::show_current_ages(void);</span>

<span class="s0">856 15 show_trend_ages 0 4 1347 28 MemoryUsage::show_trend_ages 0 1 191 117</span>
<span class="s0">/**</span>
 <span class="s0">* Shows the breakdown of ages of all of the pointers allocated and freed</span>
 <span class="s0">* since the last call to freeze().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">static inline void MemoryUsage::show_trend_ages(void);</span>

<span class="s0">857 11 MemoryUsage 0 260 1347 24 MemoryUsage::MemoryUsage 0 1 171 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline MemoryUsage::MemoryUsage(MemoryUsage const &amp;) = default;</span>

<span class="s0">858 12 ~MemoryUsage 0 516 1347 25 MemoryUsage::~MemoryUsage 0 0 0</span>
<span class="s0">32</span>
<span class="s0">MemoryUsage::~MemoryUsage(void);</span>

<span class="s0">859 20 upcast_to_MemoryBase 0 12 1352 36 ReferenceCount::upcast_to_MemoryBase 0 1 198 40</span>
<span class="s0">upcast from ReferenceCount to MemoryBase</span>
<span class="s0">55</span>
<span class="s0">MemoryBase *ReferenceCount::upcast_to_MemoryBase(void);</span>

<span class="s0">860 26 downcast_to_ReferenceCount 0 12 1326 38 MemoryBase::downcast_to_ReferenceCount 0 0 42</span>
<span class="s0">downcast from MemoryBase to ReferenceCount</span>
<span class="s0">61</span>
<span class="s0">ReferenceCount *MemoryBase::downcast_to_ReferenceCount(void);</span>

<span class="s0">861 15 ~ReferenceCount 0 518 1352 31 ReferenceCount::~ReferenceCount 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">virtual inline ReferenceCount::~ReferenceCount(void);</span>

<span class="s0">862 13 get_ref_count 0 4 1352 29 ReferenceCount::get_ref_count 0 1 192 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current reference count.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline int ReferenceCount::get_ref_count(void) const;</span>

<span class="s0">863 3 ref 0 4 1352 19 ReferenceCount::ref 0 1 193 538</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly increments the reference count.  User code should avoid using</span>
 <span class="s0">* ref() and unref() directly, which can result in missed reference counts.</span>
 <span class="s0">* Instead, let a PointerTo object manage the reference counting</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is const, even though it changes the object, because</span>
 <span class="s0">* generally fiddling with an object's reference count isn't considered part</span>
 <span class="s0">* of fiddling with the object.  An object might be const in other ways, but</span>
 <span class="s0">* we still need to accurately count the number of references to it.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">inline void ReferenceCount::ref(void) const;</span>

<span class="s0">864 5 unref 0 6 1352 21 ReferenceCount::unref 0 1 194 865</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly decrements the reference count.  Note that the object will not</span>
 <span class="s0">* be implicitly deleted by unref() simply because the reference count drops</span>
 <span class="s0">* to zero.  (Having a member function delete itself is problematic.) However,</span>
 <span class="s0">* see the helper function unref_delete().</span>
 <span class="s0">*</span>
 <span class="s0">* User code should avoid using ref() and unref() directly, which can result</span>
 <span class="s0">* in missed reference counts.  Instead, let a PointerTo object manage the</span>
 <span class="s0">* reference counting automatically.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is const, even though it changes the object, because</span>
 <span class="s0">* generally fiddling with an object's reference count isn't considered part</span>
 <span class="s0">* of fiddling with the object.  An object might be const in other ways, but</span>
 <span class="s0">* we still need to accurately count the number of references to it.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the new reference count is nonzero, false if it</span>
 <span class="s0">* is zero.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">virtual inline bool ReferenceCount::unref(void) const;</span>

<span class="s0">865 24 test_ref_count_integrity 0 4 1352 40 ReferenceCount::test_ref_count_integrity 0 1 195 135</span>
<span class="s0">/**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't</span>
 <span class="s0">* completely bogus.  Returns true if ok, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool ReferenceCount::test_ref_count_integrity(void) const;</span>

<span class="s0">866 22 test_ref_count_nonzero 0 4 1352 38 ReferenceCount::test_ref_count_nonzero 0 1 196 144</span>
<span class="s0">/**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't zero, or</span>
 <span class="s0">* completely bogus.  Returns true if ok, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline bool ReferenceCount::test_ref_count_nonzero(void) const;</span>

<span class="s0">867 14 get_class_type 0 4 1352 30 ReferenceCount::get_class_type 0 1 197 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle ReferenceCount::get_class_type(void);</span>

<span class="s0">868 10 get_length 0 4 1354 18 Buffer::get_length 0 1 200 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline int Buffer::get_length(void) const;</span>

<span class="s0">869 6 Buffer 0 260 1354 14 Buffer::Buffer 0 1 199 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline Buffer::Buffer(Buffer const &amp;) = default;</span>

<span class="s0">870 15 compress_string 0 1 0 15 compress_string 0 1 648 0</span>
<span class="s0">78</span>
<span class="s0">std::string compress_string(std::string const &amp;source, int compression_level);</span>

<span class="s0">871 17 decompress_string 0 1 0 17 decompress_string 0 1 649 0</span>
<span class="s0">57</span>
<span class="s0">std::string decompress_string(std::string const &amp;source);</span>

<span class="s0">872 13 compress_file 0 1 0 13 compress_file 0 1 650 0</span>
<span class="s0">88</span>
<span class="s0">bool compress_file(Filename const &amp;source, Filename const &amp;dest, int compression_level);</span>

<span class="s0">873 15 decompress_file 0 1 0 15 decompress_file 0 1 651 0</span>
<span class="s0">67</span>
<span class="s0">bool decompress_file(Filename const &amp;source, Filename const &amp;dest);</span>

<span class="s0">874 15 compress_stream 0 1 0 15 compress_stream 0 1 652 0</span>
<span class="s0">86</span>
<span class="s0">bool compress_stream(std::istream &amp;source, std::ostream &amp;dest, int compression_level);</span>

<span class="s0">875 17 decompress_stream 0 1 0 17 decompress_stream 0 1 653 0</span>
<span class="s0">65</span>
<span class="s0">bool decompress_stream(std::istream &amp;source, std::ostream &amp;dest);</span>

<span class="s0">876 11 copy_stream 0 1 0 11 copy_stream 0 1 654 0</span>
<span class="s0">59</span>
<span class="s0">bool copy_stream(std::istream &amp;source, std::ostream &amp;dest);</span>

<span class="s0">877 9 add_level 0 6 1355 36 PStatCollectorForwardBase::add_level 0 1 201 0</span>
<span class="s0">68</span>
<span class="s0">virtual void PStatCollectorForwardBase::add_level(double level) = 0;</span>

<span class="s0">878 18 get_node_ref_count 0 4 1356 38 NodeReferenceCount::get_node_ref_count 0 1 202 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current reference count.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int NodeReferenceCount::get_node_ref_count(void) const;</span>

<span class="s0">879 8 node_ref 0 4 1356 28 NodeReferenceCount::node_ref 0 1 203 107</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly increments the node reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void NodeReferenceCount::node_ref(void) const;</span>

<span class="s0">880 10 node_unref 0 4 1356 30 NodeReferenceCount::node_unref 0 1 204 201</span>
<span class="s0">/**</span>
 <span class="s0">* Explicitly decrements the node reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the new reference count is nonzero, false if it</span>
 <span class="s0">* is zero.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool NodeReferenceCount::node_unref(void) const;</span>

<span class="s0">881 24 test_ref_count_integrity 0 4 1356 44 NodeReferenceCount::test_ref_count_integrity 0 1 205 97</span>
<span class="s0">/**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't</span>
 <span class="s0">* completely bogus.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline bool NodeReferenceCount::test_ref_count_integrity(void) const;</span>

<span class="s0">882 15 node_unref_only 0 4 1356 35 NodeReferenceCount::node_unref_only 0 1 206 186</span>
<span class="s0">/**</span>
 <span class="s0">* Decrements the node reference count without affecting the normal reference</span>
 <span class="s0">* count.  Intended to be called by derived classes only, presumably to</span>
 <span class="s0">* reimplement node_unref().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void NodeReferenceCount::node_unref_only(void) const;</span>

<span class="s0">883 14 get_class_type 0 4 1356 34 NodeReferenceCount::get_class_type 0 1 207 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle NodeReferenceCount::get_class_type(void);</span>

<span class="s0">884 8 Datagram 0 260 1357 18 Datagram::Datagram 0 3 208 209 210 130</span>
<span class="s0">/**</span>
 <span class="s0">* Constructs a datagram from an existing block of data.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Constructs a datagram from an existing block of data.</span>
 <span class="s0">*/</span>
<span class="s0">212</span>
<span class="s0">inline Datagram::Datagram(void) = default;</span>
<span class="s0">inline Datagram::Datagram(void const *data, std::size_t size);</span>
<span class="s0">inline explicit Datagram::Datagram(vector_uchar data);</span>
<span class="s0">Datagram::Datagram(Datagram const &amp;copy) = default;</span>

<span class="s0">885 10 operator = 0 4 1357 20 Datagram::operator = 0 1 211 0</span>
<span class="s0">58</span>
<span class="s0">void Datagram::operator =(Datagram const &amp;copy) = default;</span>

<span class="s0">886 5 clear 0 6 1357 15 Datagram::clear 0 1 212 90</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the datagram to empty, in preparation for building up a new</span>
 <span class="s0">* datagram.</span>
 <span class="s0">*/</span>
<span class="s0">35</span>
<span class="s0">virtual void Datagram::clear(void);</span>

<span class="s0">887 8 dump_hex 0 4 1357 18 Datagram::dump_hex 0 1 213 111</span>
<span class="s0">/**</span>
 <span class="s0">* Writes a representation of the entire datagram contents, as a sequence of</span>
 <span class="s0">* hex (and ASCII) values.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">void Datagram::dump_hex(std::ostream &amp;out, unsigned int indent = 0) const;</span>

<span class="s0">888 8 add_bool 0 4 1357 18 Datagram::add_bool 0 1 214 48</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a boolean value to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void Datagram::add_bool(bool value);</span>

<span class="s0">889 8 add_int8 0 4 1357 18 Datagram::add_int8 0 1 215 55</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a signed 8-bit integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void Datagram::add_int8(int8_t value);</span>

<span class="s0">890 9 add_uint8 0 4 1357 19 Datagram::add_uint8 0 1 216 58</span>
<span class="s0">/**</span>
 <span class="s0">* Adds an unsigned 8-bit integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void Datagram::add_uint8(uint8_t value);</span>

<span class="s0">891 9 add_int16 0 4 1357 19 Datagram::add_int16 0 1 217 106</span>
<span class="s0">// The default numeric packing is little-endian.</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a signed 16-bit integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void Datagram::add_int16(int16_t value);</span>

<span class="s0">892 9 add_int32 0 4 1357 19 Datagram::add_int32 0 1 218 56</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a signed 32-bit integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void Datagram::add_int32(int32_t value);</span>

<span class="s0">893 9 add_int64 0 4 1357 19 Datagram::add_int64 0 1 219 56</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a signed 64-bit integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline void Datagram::add_int64(int64_t value);</span>

<span class="s0">894 10 add_uint16 0 4 1357 20 Datagram::add_uint16 0 1 220 59</span>
<span class="s0">/**</span>
 <span class="s0">* Adds an unsigned 16-bit integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void Datagram::add_uint16(uint16_t value);</span>

<span class="s0">895 10 add_uint32 0 4 1357 20 Datagram::add_uint32 0 1 221 59</span>
<span class="s0">/**</span>
 <span class="s0">* Adds an unsigned 32-bit integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void Datagram::add_uint32(uint32_t value);</span>

<span class="s0">896 10 add_uint64 0 4 1357 20 Datagram::add_uint64 0 1 222 59</span>
<span class="s0">/**</span>
 <span class="s0">* Adds an unsigned 64-bit integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void Datagram::add_uint64(uint64_t value);</span>

<span class="s0">897 11 add_float32 0 4 1357 21 Datagram::add_float32 0 1 223 197</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a 32-bit single-precision floating-point number to the datagram.</span>
 <span class="s0">* Since this kind of float is not necessarily portable across different</span>
 <span class="s0">* architectures, special care is required.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void Datagram::add_float32(PN_float32 value);</span>

<span class="s0">898 11 add_float64 0 4 1357 21 Datagram::add_float64 0 1 224 63</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a 64-bit floating-point number to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void Datagram::add_float64(PN_float64 value);</span>

<span class="s0">899 12 add_stdfloat 0 4 1357 22 Datagram::add_stdfloat 0 1 225 105</span>
<span class="s0">/**</span>
 <span class="s0">* Adds either a 32-bit or a 64-bit floating-point number, according to</span>
 <span class="s0">* set_stdfloat_double().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void Datagram::add_stdfloat(PN_stdfloat value);</span>

<span class="s0">900 12 add_be_int16 0 4 1357 22 Datagram::add_be_int16 0 1 226 136</span>
<span class="s0">// These functions pack numbers big-endian, in case that's desired.</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a signed 16-bit big-endian integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void Datagram::add_be_int16(int16_t value);</span>

<span class="s0">901 12 add_be_int32 0 4 1357 22 Datagram::add_be_int32 0 1 227 67</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a signed 32-bit big-endian integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void Datagram::add_be_int32(int32_t value);</span>

<span class="s0">902 12 add_be_int64 0 4 1357 22 Datagram::add_be_int64 0 1 228 67</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a signed 64-bit big-endian integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void Datagram::add_be_int64(int64_t value);</span>

<span class="s0">903 13 add_be_uint16 0 4 1357 23 Datagram::add_be_uint16 0 1 229 70</span>
<span class="s0">/**</span>
 <span class="s0">* Adds an unsigned 16-bit big-endian integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void Datagram::add_be_uint16(uint16_t value);</span>

<span class="s0">904 13 add_be_uint32 0 4 1357 23 Datagram::add_be_uint32 0 1 230 70</span>
<span class="s0">/**</span>
 <span class="s0">* Adds an unsigned 32-bit big-endian integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void Datagram::add_be_uint32(uint32_t value);</span>

<span class="s0">905 13 add_be_uint64 0 4 1357 23 Datagram::add_be_uint64 0 1 231 70</span>
<span class="s0">/**</span>
 <span class="s0">* Adds an unsigned 64-bit big-endian integer to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void Datagram::add_be_uint64(uint64_t value);</span>

<span class="s0">906 14 add_be_float32 0 4 1357 24 Datagram::add_be_float32 0 1 232 94</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a 32-bit single-precision big-endian floating-point number to the</span>
 <span class="s0">* datagram.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void Datagram::add_be_float32(PN_float32 value);</span>

<span class="s0">907 14 add_be_float64 0 4 1357 24 Datagram::add_be_float64 0 1 233 74</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a 64-bit big-endian floating-point number to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void Datagram::add_be_float64(PN_float64 value);</span>

<span class="s0">908 10 add_string 0 4 1357 20 Datagram::add_string 0 1 234 109</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a variable-length string to the datagram.  This actually adds a count</span>
 <span class="s0">* followed by n bytes.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void Datagram::add_string(std::string const &amp;str);</span>

<span class="s0">909 12 add_string32 0 4 1357 22 Datagram::add_string32 0 1 235 116</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a variable-length string to the datagram, using a 32-bit length field</span>
 <span class="s0">* to allow very long strings.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void Datagram::add_string32(std::string const &amp;str);</span>

<span class="s0">910 12 add_z_string 0 4 1357 22 Datagram::add_z_string 0 1 236 86</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a variable-length string to the datagram, as a NULL-terminated string.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void Datagram::add_z_string(std::string const &amp;str);</span>

<span class="s0">911 16 add_fixed_string 0 4 1357 26 Datagram::add_fixed_string 0 1 237 238</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a fixed-length string to the datagram.  If the string given is less</span>
 <span class="s0">* than the requested size, this will pad the string out with zeroes; if it is</span>
 <span class="s0">* greater than the requested size, this will silently truncate the string.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline void Datagram::add_fixed_string(std::string const &amp;str, std::size_t size);</span>

<span class="s0">912 11 add_wstring 0 4 1357 21 Datagram::add_wstring 0 1 238 58</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a variable-length wstring to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void Datagram::add_wstring(std::wstring const &amp;str);</span>

<span class="s0">913 8 add_blob 0 4 1357 18 Datagram::add_blob 0 1 239 114</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a variable-length binary blob to the datagram.  This actually adds a</span>
 <span class="s0">* count followed by n bytes.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void Datagram::add_blob(vector_uchar const &amp;);</span>

<span class="s0">914 10 add_blob32 0 4 1357 20 Datagram::add_blob32 0 1 240 119</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a variable-length binary blob to the datagram, using a 32-bit length</span>
 <span class="s0">* field to allow very long blobs.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void Datagram::add_blob32(vector_uchar const &amp;);</span>

<span class="s0">915 9 pad_bytes 0 4 1357 19 Datagram::pad_bytes 0 1 241 67</span>
<span class="s0">/**</span>
 <span class="s0">* Adds the indicated number of zero bytes to the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">void Datagram::pad_bytes(std::size_t size);</span>

<span class="s0">916 11 append_data 0 4 1357 21 Datagram::append_data 0 1 242 132</span>
<span class="s0">/**</span>
 <span class="s0">* Appends some more raw data to the end of the datagram.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Appends some more raw data to the end of the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">124</span>
<span class="s0">void Datagram::append_data(void const *data, std::size_t size);</span>
<span class="s0">inline void Datagram::append_data(vector_uchar const &amp;data);</span>

<span class="s0">917 11 get_message 0 4 1357 21 Datagram::get_message 0 1 243 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the datagram's data as a string.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline PyObject *Datagram::get_message(void) const;</span>

<span class="s0">918 9 __bytes__ 0 4 1357 19 Datagram::__bytes__ 0 1 244 0</span>
<span class="s0">49</span>
<span class="s0">inline PyObject *Datagram::__bytes__(void) const;</span>

<span class="s0">919 10 __reduce__ 0 4 1357 20 Datagram::__reduce__ 0 1 245 0</span>
<span class="s0">43</span>
<span class="s0">PyObject *Datagram::__reduce__(void) const;</span>

<span class="s0">920 10 get_length 0 4 1357 20 Datagram::get_length 0 1 246 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes in the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline std::size_t Datagram::get_length(void) const;</span>

<span class="s0">921 9 set_array 0 4 1357 19 Datagram::set_array 0 1 247 199</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the data in the Datagram with the data in the indicated PTA_uchar.</span>
 <span class="s0">* This is assignment by reference: subsequent changes to the Datagram will</span>
 <span class="s0">* also change the source PTA_uchar.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void Datagram::set_array(PTA_uchar data);</span>

<span class="s0">922 10 copy_array 0 4 1357 20 Datagram::copy_array 0 1 248 237</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the data in the Datagram with a copy of the data in the indicated</span>
 <span class="s0">* CPTA_uchar.  Unlike set_array(), a complete copy is made of the data;</span>
 <span class="s0">* subsequent changes to the Datagram will *not* change the source CPTA_uchar.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void Datagram::copy_array(CPTA_uchar data);</span>

<span class="s0">923 9 get_array 0 4 1357 19 Datagram::get_array 0 1 249 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a const pointer to the actual data in the Datagram.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline CPTA_uchar Datagram::get_array(void) const;</span>

<span class="s0">924 12 modify_array 0 4 1357 22 Datagram::modify_array 0 1 250 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a modifiable pointer to the actual data in the Datagram.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline PTA_uchar Datagram::modify_array(void);</span>

<span class="s0">925 19 set_stdfloat_double 0 4 1357 29 Datagram::set_stdfloat_double 0 1 251 343</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the stdfloat_double flag, which defines the operation performed by</span>
 <span class="s0">* add_stdfloat() and DatagramIterator::get_stdfloat().  When this is true,</span>
 <span class="s0">* add_stdfloat() adds a 64-bit floating-point number; when it is false, it</span>
 <span class="s0">* adds a 32-bit floating-point number.  The default is based on the</span>
 <span class="s0">* STDFLOAT_DOUBLE compilation flag.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void Datagram::set_stdfloat_double(bool stdfloat_double);</span>

<span class="s0">926 19 get_stdfloat_double 0 4 1357 29 Datagram::get_stdfloat_double 0 1 252 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the stdfloat_double flag.  See set_stdfloat_double().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline bool Datagram::get_stdfloat_double(void) const;</span>

<span class="s0">927 11 operator == 0 4 1357 21 Datagram::operator == 0 1 253 0</span>
<span class="s0">63</span>
<span class="s0">inline bool Datagram::operator ==(Datagram const &amp;other) const;</span>

<span class="s0">928 11 operator != 0 4 1357 21 Datagram::operator != 0 1 254 0</span>
<span class="s0">63</span>
<span class="s0">inline bool Datagram::operator !=(Datagram const &amp;other) const;</span>

<span class="s0">929 10 operator &lt; 0 4 1357 20 Datagram::operator &lt; 0 1 255 0</span>
<span class="s0">62</span>
<span class="s0">inline bool Datagram::operator &lt;(Datagram const &amp;other) const;</span>

<span class="s0">930 6 output 0 4 1357 16 Datagram::output 0 1 256 67</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">void Datagram::output(std::ostream &amp;out) const;</span>

<span class="s0">931 5 write 0 4 1357 15 Datagram::write 0 1 257 67</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">void Datagram::write(std::ostream &amp;out, unsigned int indent = 0) const;</span>

<span class="s0">932 14 get_class_type 0 4 1357 24 Datagram::get_class_type 0 1 258 0</span>
<span class="s0">49</span>
<span class="s0">static TypeHandle Datagram::get_class_type(void);</span>

<span class="s0">933 18 ~DatagramGenerator 0 518 1359 37 DatagramGenerator::~DatagramGenerator 0 0 82</span>
<span class="s0">/**</span>
 <span class="s0">* Does nothing since this is class is just the definition of an interface</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">virtual DatagramGenerator::~DatagramGenerator(void);</span>

<span class="s0">934 12 get_datagram 0 6 1359 31 DatagramGenerator::get_datagram 0 1 259 0</span>
<span class="s0">65</span>
<span class="s0">virtual bool DatagramGenerator::get_datagram(Datagram &amp;data) = 0;</span>

<span class="s0">935 13 save_datagram 0 6 1359 32 DatagramGenerator::save_datagram 0 1 260 391</span>
<span class="s0">/**</span>
 <span class="s0">* Skips over the next datagram without extracting it, but saves the relevant</span>
 <span class="s0">* file information in the SubfileInfo object so that its data may be read</span>
 <span class="s0">* later.  For non-file-based datagram generators, this may mean creating a</span>
 <span class="s0">* temporary file and copying the contents of the datagram to disk.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure or if this method is</span>
 <span class="s0">* unimplemented.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">virtual bool DatagramGenerator::save_datagram(SubfileInfo &amp;info);</span>

<span class="s0">936 6 is_eof 0 6 1359 25 DatagramGenerator::is_eof 0 1 261 0</span>
<span class="s0">49</span>
<span class="s0">virtual bool DatagramGenerator::is_eof(void) = 0;</span>

<span class="s0">937 8 is_error 0 6 1359 27 DatagramGenerator::is_error 0 1 262 0</span>
<span class="s0">51</span>
<span class="s0">virtual bool DatagramGenerator::is_error(void) = 0;</span>

<span class="s0">938 12 get_filename 0 6 1359 31 DatagramGenerator::get_filename 0 1 263 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename that provides the source for these datagrams, if any,</span>
 <span class="s0">* or empty string if the datagrams do not originate from a file on disk.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">virtual Filename const &amp;DatagramGenerator::get_filename(void);</span>

<span class="s0">939 13 get_timestamp 0 6 1359 32 DatagramGenerator::get_timestamp 0 1 264 138</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the on-disk timestamp of the file that was read, at the time it was</span>
 <span class="s0">* opened, if that is available, or 0 if it is not.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual time_t DatagramGenerator::get_timestamp(void) const;</span>

<span class="s0">940 8 get_file 0 6 1359 27 DatagramGenerator::get_file 0 1 265 156</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the FileReference that provides the source for these datagrams, if</span>
 <span class="s0">* any, or NULL if the datagrams do not originate from a file on disk.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">virtual FileReference const *DatagramGenerator::get_file(void);</span>

<span class="s0">941 9 get_vfile 0 6 1359 28 DatagramGenerator::get_vfile 0 1 266 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the VirtualFile that provides the source for these datagrams, if</span>
 <span class="s0">* any, or NULL if the datagrams do not originate from a VirtualFile.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual VirtualFile *DatagramGenerator::get_vfile(void);</span>

<span class="s0">942 12 get_file_pos 0 6 1359 31 DatagramGenerator::get_file_pos 0 1 267 327</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current file position within the data stream, if any, or 0 if</span>
 <span class="s0">* the file position is not meaningful or cannot be determined.</span>
 <span class="s0">*</span>
 <span class="s0">* For DatagramGenerators that return a meaningful file position, this will be</span>
 <span class="s0">* pointing to the first byte following the datagram returned after a call to</span>
 <span class="s0">* get_datagram().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual std::streamoff DatagramGenerator::get_file_pos(void);</span>

<span class="s0">943 16 DatagramIterator 0 260 1360 34 DatagramIterator::DatagramIterator 0 3 268 269 270 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">220</span>
<span class="s0">inline DatagramIterator::DatagramIterator(void);</span>
<span class="s0">inline DatagramIterator::DatagramIterator(Datagram const &amp;datagram, std::size_t offset = 0);</span>
<span class="s0">inline DatagramIterator::DatagramIterator(DatagramIterator const &amp;) = default;</span>

<span class="s0">944 8 get_bool 0 4 1360 26 DatagramIterator::get_bool 0 1 271 36</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a boolean value.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline bool DatagramIterator::get_bool(void);</span>

<span class="s0">945 8 get_int8 0 4 1360 26 DatagramIterator::get_int8 0 1 272 43</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a signed 8-bit integer.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int8_t DatagramIterator::get_int8(void);</span>

<span class="s0">946 9 get_uint8 0 4 1360 27 DatagramIterator::get_uint8 0 1 273 46</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts an unsigned 8-bit integer.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline uint8_t DatagramIterator::get_uint8(void);</span>

<span class="s0">947 9 get_int16 0 4 1360 27 DatagramIterator::get_int16 0 1 274 44</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a signed 16-bit integer.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int16_t DatagramIterator::get_int16(void);</span>

<span class="s0">948 9 get_int32 0 4 1360 27 DatagramIterator::get_int32 0 1 275 44</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a signed 32-bit integer.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int32_t DatagramIterator::get_int32(void);</span>

<span class="s0">949 9 get_int64 0 4 1360 27 DatagramIterator::get_int64 0 1 276 44</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a signed 64-bit integer.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int64_t DatagramIterator::get_int64(void);</span>

<span class="s0">950 10 get_uint16 0 4 1360 28 DatagramIterator::get_uint16 0 1 277 47</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts an unsigned 16-bit integer.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline uint16_t DatagramIterator::get_uint16(void);</span>

<span class="s0">951 10 get_uint32 0 4 1360 28 DatagramIterator::get_uint32 0 1 278 47</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts an unsigned 32-bit integer.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline uint32_t DatagramIterator::get_uint32(void);</span>

<span class="s0">952 10 get_uint64 0 4 1360 28 DatagramIterator::get_uint64 0 1 279 47</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts an unsigned 64-bit integer.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline uint64_t DatagramIterator::get_uint64(void);</span>

<span class="s0">953 11 get_float32 0 4 1360 29 DatagramIterator::get_float32 0 1 280 68</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a 32-bit single-precision floating-point number.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PN_float32 DatagramIterator::get_float32(void);</span>

<span class="s0">954 11 get_float64 0 4 1360 29 DatagramIterator::get_float64 0 1 281 51</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a 64-bit floating-point number.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PN_float64 DatagramIterator::get_float64(void);</span>

<span class="s0">955 12 get_stdfloat 0 4 1360 30 DatagramIterator::get_stdfloat 0 1 282 119</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts either a 32-bit or a 64-bit floating-point number, according to</span>
 <span class="s0">* Datagram::set_stdfloat_double().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline PN_stdfloat DatagramIterator::get_stdfloat(void);</span>

<span class="s0">956 12 get_be_int16 0 4 1360 30 DatagramIterator::get_be_int16 0 1 283 55</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a signed 16-bit big-endian integer.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int16_t DatagramIterator::get_be_int16(void);</span>

<span class="s0">957 12 get_be_int32 0 4 1360 30 DatagramIterator::get_be_int32 0 1 284 55</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a signed 32-bit big-endian integer.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int32_t DatagramIterator::get_be_int32(void);</span>

<span class="s0">958 12 get_be_int64 0 4 1360 30 DatagramIterator::get_be_int64 0 1 285 55</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a signed 64-bit big-endian integer.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline int64_t DatagramIterator::get_be_int64(void);</span>

<span class="s0">959 13 get_be_uint16 0 4 1360 31 DatagramIterator::get_be_uint16 0 1 286 58</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts an unsigned 16-bit big-endian integer.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline uint16_t DatagramIterator::get_be_uint16(void);</span>

<span class="s0">960 13 get_be_uint32 0 4 1360 31 DatagramIterator::get_be_uint32 0 1 287 58</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts an unsigned 32-bit big-endian integer.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline uint32_t DatagramIterator::get_be_uint32(void);</span>

<span class="s0">961 13 get_be_uint64 0 4 1360 31 DatagramIterator::get_be_uint64 0 1 288 58</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts an unsigned 64-bit big-endian integer.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline uint64_t DatagramIterator::get_be_uint64(void);</span>

<span class="s0">962 14 get_be_float32 0 4 1360 32 DatagramIterator::get_be_float32 0 1 289 79</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a 32-bit big-endian single-precision floating-point number.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_float32 DatagramIterator::get_be_float32(void);</span>

<span class="s0">963 14 get_be_float64 0 4 1360 32 DatagramIterator::get_be_float64 0 1 290 62</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a 64-bit big-endian floating-point number.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_float64 DatagramIterator::get_be_float64(void);</span>

<span class="s0">964 10 get_string 0 4 1360 28 DatagramIterator::get_string 0 1 291 45</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a variable-length string.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">std::string DatagramIterator::get_string(void);</span>

<span class="s0">965 12 get_string32 0 4 1360 30 DatagramIterator::get_string32 0 1 292 72</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a variable-length string with a 32-bit length field.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">std::string DatagramIterator::get_string32(void);</span>

<span class="s0">966 12 get_z_string 0 4 1360 30 DatagramIterator::get_z_string 0 1 293 74</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a variable-length string, as a NULL-terminated string.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">std::string DatagramIterator::get_z_string(void);</span>

<span class="s0">967 16 get_fixed_string 0 4 1360 34 DatagramIterator::get_fixed_string 0 1 294 128</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a fixed-length string.  However, if a zero byte occurs within the</span>
 <span class="s0">* string, it marks the end of the string.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">std::string DatagramIterator::get_fixed_string(std::size_t size);</span>

<span class="s0">968 11 get_wstring 0 4 1360 29 DatagramIterator::get_wstring 0 1 295 75</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a variable-length wstring (with a 32-bit length field).</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">std::wstring DatagramIterator::get_wstring(void);</span>

<span class="s0">969 8 get_blob 0 4 1360 26 DatagramIterator::get_blob 0 1 296 50</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a variable-length binary blob.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline vector_uchar DatagramIterator::get_blob(void);</span>

<span class="s0">970 10 get_blob32 0 4 1360 28 DatagramIterator::get_blob32 0 1 297 75</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts a variable-length binary blob with a 32-bit size field.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline vector_uchar DatagramIterator::get_blob32(void);</span>

<span class="s0">971 10 skip_bytes 0 4 1360 28 DatagramIterator::skip_bytes 0 1 298 68</span>
<span class="s0">/**</span>
 <span class="s0">* Skips over the indicated number of bytes in the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void DatagramIterator::skip_bytes(std::size_t size);</span>

<span class="s0">972 13 extract_bytes 0 4 1360 31 DatagramIterator::extract_bytes 0 1 299 346</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts the indicated number of bytes in the datagram and returns them as</span>
 <span class="s0">* a string.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Extracts the indicated number of bytes in the datagram into the given</span>
 <span class="s0">* character buffer.  Assumes that the buffer is big enough to hold the</span>
 <span class="s0">* requested number of bytes.  Returns the number of bytes that were</span>
 <span class="s0">* successfully written.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">vector_uchar DatagramIterator::extract_bytes(std::size_t size);</span>
<span class="s0">std::size_t DatagramIterator::extract_bytes(unsigned char *into, std::size_t size);</span>

<span class="s0">973 19 get_remaining_bytes 0 4 1360 37 DatagramIterator::get_remaining_bytes 0 1 300 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the remaining bytes in the datagram as a string, but does not</span>
 <span class="s0">* extract them from the iterator.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline vector_uchar DatagramIterator::get_remaining_bytes(void) const;</span>

<span class="s0">974 18 get_remaining_size 0 4 1360 36 DatagramIterator::get_remaining_size 0 1 301 49</span>
<span class="s0">/**</span>
 <span class="s0">* Return the bytes left in the datagram.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline std::size_t DatagramIterator::get_remaining_size(void) const;</span>

<span class="s0">975 12 get_datagram 0 4 1360 30 DatagramIterator::get_datagram 0 1 302 48</span>
<span class="s0">/**</span>
 <span class="s0">* Return the datagram of this iterator.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline Datagram const &amp;DatagramIterator::get_datagram(void) const;</span>

<span class="s0">976 17 get_current_index 0 4 1360 35 DatagramIterator::get_current_index 0 1 303 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current position within the datagram of the next piece of data</span>
 <span class="s0">* to extract.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline std::size_t DatagramIterator::get_current_index(void) const;</span>

<span class="s0">977 6 output 0 4 1360 24 DatagramIterator::output 0 1 304 67</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void DatagramIterator::output(std::ostream &amp;out) const;</span>

<span class="s0">978 5 write 0 4 1360 23 DatagramIterator::write 0 1 305 67</span>
<span class="s0">/**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">void DatagramIterator::write(std::ostream &amp;out, unsigned int indent = 0) const;</span>

<span class="s0">979 14 get_class_type 0 4 1360 32 DatagramIterator::get_class_type 0 1 306 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle DatagramIterator::get_class_type(void);</span>

<span class="s0">980 17 ~DatagramIterator 0 516 1360 35 DatagramIterator::~DatagramIterator 0 0 0</span>
<span class="s0">42</span>
<span class="s0">DatagramIterator::~DatagramIterator(void);</span>

<span class="s0">981 13 ~DatagramSink 0 518 1361 27 DatagramSink::~DatagramSink 0 0 82</span>
<span class="s0">/**</span>
 <span class="s0">* Does nothing since this is class is just the definition of an interface</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">virtual DatagramSink::~DatagramSink(void);</span>

<span class="s0">982 12 put_datagram 0 6 1361 26 DatagramSink::put_datagram 0 1 307 0</span>
<span class="s0">66</span>
<span class="s0">virtual bool DatagramSink::put_datagram(Datagram const &amp;data) = 0;</span>

<span class="s0">983 13 copy_datagram 0 6 1361 27 DatagramSink::copy_datagram 0 2 308 309 713</span>
<span class="s0">/**</span>
 <span class="s0">* Copies the file data from the entire indicated file (via the vfs) as the</span>
 <span class="s0">* next datagram.  This is intended to support potentially very large</span>
 <span class="s0">* datagrams.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure or if this method is</span>
 <span class="s0">* unimplemented.  On true, fills &quot;result&quot; with the information that</span>
 <span class="s0">* references the copied file, if possible.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Copies the file data from the range of the indicated file (outside of the</span>
 <span class="s0">* vfs) as the next datagram.  This is intended to support potentially very</span>
 <span class="s0">* large datagrams.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure or if this method is</span>
 <span class="s0">* unimplemented.  On true, fills &quot;result&quot; with the information that</span>
 <span class="s0">* references the copied file, if possible.</span>
 <span class="s0">*/</span>
<span class="s0">178</span>
<span class="s0">virtual bool DatagramSink::copy_datagram(SubfileInfo &amp;result, Filename const &amp;filename);</span>
<span class="s0">virtual bool DatagramSink::copy_datagram(SubfileInfo &amp;result, SubfileInfo const &amp;source);</span>

<span class="s0">984 8 is_error 0 6 1361 22 DatagramSink::is_error 0 1 310 0</span>
<span class="s0">46</span>
<span class="s0">virtual bool DatagramSink::is_error(void) = 0;</span>

<span class="s0">985 5 flush 0 6 1361 19 DatagramSink::flush 0 1 311 0</span>
<span class="s0">43</span>
<span class="s0">virtual void DatagramSink::flush(void) = 0;</span>

<span class="s0">986 12 get_filename 0 6 1361 26 DatagramSink::get_filename 0 1 312 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename that provides the target for these datagrams, if any,</span>
 <span class="s0">* or empty string if the datagrams do not get written to a file on disk.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">virtual Filename const &amp;DatagramSink::get_filename(void);</span>

<span class="s0">987 8 get_file 0 6 1361 22 DatagramSink::get_file 0 1 313 152</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the FileReference that provides the target for these datagrams, if</span>
 <span class="s0">* any, or NULL if the datagrams do not written to a file on disk.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual FileReference const *DatagramSink::get_file(void);</span>

<span class="s0">988 12 get_file_pos 0 6 1361 26 DatagramSink::get_file_pos 0 1 314 322</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current file position within the data stream, if any, or 0 if</span>
 <span class="s0">* the file position is not meaningful or cannot be determined.</span>
 <span class="s0">*</span>
 <span class="s0">* For DatagramSinks that return a meaningful file position, this will be</span>
 <span class="s0">* pointing to the first byte following the datagram returned after a call to</span>
 <span class="s0">* put_datagram().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual std::streamoff DatagramSink::get_file_pos(void);</span>

<span class="s0">989 21 upcast_to_TypedObject 0 12 1367 42 TypedReferenceCount::upcast_to_TypedObject 0 1 320 46</span>
<span class="s0">upcast from TypedReferenceCount to TypedObject</span>
<span class="s0">62</span>
<span class="s0">TypedObject *TypedReferenceCount::upcast_to_TypedObject(void);</span>

<span class="s0">990 31 downcast_to_TypedReferenceCount 0 12 1358 44 TypedObject::downcast_to_TypedReferenceCount 0 0 48</span>
<span class="s0">downcast from TypedObject to TypedReferenceCount</span>
<span class="s0">72</span>
<span class="s0">TypedReferenceCount *TypedObject::downcast_to_TypedReferenceCount(void);</span>

<span class="s0">991 24 upcast_to_ReferenceCount 0 12 1367 45 TypedReferenceCount::upcast_to_ReferenceCount 0 1 321 49</span>
<span class="s0">upcast from TypedReferenceCount to ReferenceCount</span>
<span class="s0">68</span>
<span class="s0">ReferenceCount *TypedReferenceCount::upcast_to_ReferenceCount(void);</span>

<span class="s0">992 31 downcast_to_TypedReferenceCount 0 12 1352 47 ReferenceCount::downcast_to_TypedReferenceCount 0 0 51</span>
<span class="s0">downcast from ReferenceCount to TypedReferenceCount</span>
<span class="s0">75</span>
<span class="s0">TypedReferenceCount *ReferenceCount::downcast_to_TypedReferenceCount(void);</span>

<span class="s0">993 14 get_class_type 0 4 1367 35 TypedReferenceCount::get_class_type 0 1 319 0</span>
<span class="s0">60</span>
<span class="s0">static TypeHandle TypedReferenceCount::get_class_type(void);</span>

<span class="s0">994 20 ~TypedReferenceCount 0 516 1367 41 TypedReferenceCount::~TypedReferenceCount 0 0 0</span>
<span class="s0">48</span>
<span class="s0">TypedReferenceCount::~TypedReferenceCount(void);</span>

<span class="s0">995 13 FileReference 0 260 1366 28 FileReference::FileReference 0 2 315 316 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">132</span>
<span class="s0">inline FileReference::FileReference(Filename const &amp;filename);</span>
<span class="s0">inline FileReference::FileReference(FileReference const &amp;) = default;</span>

<span class="s0">996 12 get_filename 0 4 1366 27 FileReference::get_filename 0 1 317 49</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename of the reference.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline Filename const &amp;FileReference::get_filename(void) const;</span>

<span class="s0">997 14 get_class_type 0 4 1366 29 FileReference::get_class_type 0 1 318 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle FileReference::get_class_type(void);</span>

<span class="s0">998 14 ~FileReference 0 516 1366 29 FileReference::~FileReference 0 0 0</span>
<span class="s0">36</span>
<span class="s0">FileReference::~FileReference(void);</span>

<span class="s0">999 14 encrypt_string 0 1 0 14 encrypt_string 0 1 655 0</span>
<span class="s0">171</span>
<span class="s0">std::string encrypt_string(std::string const &amp;source, std::string const &amp;password, std::string const &amp;algorithm = string(), int key_length = -1, int iteration_count = -1);</span>

<span class="s0">1000 14 decrypt_string 0 1 0 14 decrypt_string 0 1 656 0</span>
<span class="s0">83</span>
<span class="s0">std::string decrypt_string(std::string const &amp;source, std::string const &amp;password);</span>

<span class="s0">1001 12 encrypt_file 0 1 0 12 encrypt_file 0 1 657 0</span>
<span class="s0">181</span>
<span class="s0">bool encrypt_file(Filename const &amp;source, Filename const &amp;dest, std::string const &amp;password, std::string const &amp;algorithm = string(), int key_length = -1, int iteration_count = -1);</span>

<span class="s0">1002 12 decrypt_file 0 1 0 12 decrypt_file 0 1 658 0</span>
<span class="s0">93</span>
<span class="s0">bool decrypt_file(Filename const &amp;source, Filename const &amp;dest, std::string const &amp;password);</span>

<span class="s0">1003 14 encrypt_stream 0 1 0 14 encrypt_stream 0 1 659 0</span>
<span class="s0">179</span>
<span class="s0">bool encrypt_stream(std::istream &amp;source, std::ostream &amp;dest, std::string const &amp;password, std::string const &amp;algorithm = string(), int key_length = -1, int iteration_count = -1);</span>

<span class="s0">1004 14 decrypt_stream 0 1 0 14 decrypt_stream 0 1 660 0</span>
<span class="s0">91</span>
<span class="s0">bool decrypt_stream(std::istream &amp;source, std::ostream &amp;dest, std::string const &amp;password);</span>

<span class="s0">1005 13 error_to_text 0 1 0 13 error_to_text 0 1 661 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">std::string error_to_text(ErrorUtilCode err);</span>

<span class="s0">1006 15 get_write_error 0 1 0 15 get_write_error 0 1 662 0</span>
<span class="s0">26</span>
<span class="s0">int get_write_error(void);</span>

<span class="s0">1007 19 handle_socket_error 0 1 0 19 handle_socket_error 0 1 663 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">std::string handle_socket_error(void);</span>

<span class="s0">1008 17 get_network_error 0 1 0 17 get_network_error 0 1 664 0</span>
<span class="s0">28</span>
<span class="s0">int get_network_error(void);</span>

<span class="s0">1009 7 Ramfile 0 260 1371 16 Ramfile::Ramfile 0 2 322 323 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline Ramfile::Ramfile(void);</span>
<span class="s0">inline Ramfile::Ramfile(Ramfile const &amp;) = default;</span>

<span class="s0">1010 4 seek 0 4 1371 13 Ramfile::seek 0 1 324 130</span>
<span class="s0">/**</span>
 <span class="s0">* Moves the data pointer to the indicated byte position.  It is not an error</span>
 <span class="s0">* to move the pointer past the end of data.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline void Ramfile::seek(std::size_t pos);</span>

<span class="s0">1011 4 tell 0 4 1371 13 Ramfile::tell 0 1 325 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current data pointer position as a byte offset from the</span>
 <span class="s0">* beginning of the stream.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline std::size_t Ramfile::tell(void) const;</span>

<span class="s0">1012 4 read 0 4 1371 13 Ramfile::read 0 1 326 319</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts and returns the indicated number of characters from the current</span>
 <span class="s0">* data pointer, and advances the data pointer.  If the data pointer exceeds</span>
 <span class="s0">* the end of the buffer, returns empty string.</span>
 <span class="s0">*</span>
 <span class="s0">* The interface here is intentionally designed to be similar to that for</span>
 <span class="s0">* Python's file.read() function.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">PyObject *Ramfile::read(std::size_t length);</span>

<span class="s0">1013 8 readline 0 4 1371 17 Ramfile::readline 0 1 327 303</span>
<span class="s0">/**</span>
 <span class="s0">* Assumes the stream represents a text file, and extracts one line up to and</span>
 <span class="s0">* including the trailing newline character.  Returns empty string when the</span>
 <span class="s0">* end of file is reached.</span>
 <span class="s0">*</span>
 <span class="s0">* The interface here is intentionally designed to be similar to that for</span>
 <span class="s0">* Python's file.readline() function.</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">PyObject *Ramfile::readline(void);</span>

<span class="s0">1014 9 readlines 0 4 1371 18 Ramfile::readlines 0 1 328 0</span>
<span class="s0">35</span>
<span class="s0">PyObject *Ramfile::readlines(void);</span>

<span class="s0">1015 8 get_data 0 4 1371 17 Ramfile::get_data 0 1 329 101</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the entire buffer contents as a string, regardless of the current</span>
 <span class="s0">* data pointer.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">PyObject *Ramfile::get_data(void) const;</span>

<span class="s0">1016 13 get_data_size 0 4 1371 22 Ramfile::get_data_size 0 1 330 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of the entire buffer contents.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline std::size_t Ramfile::get_data_size(void) const;</span>

<span class="s0">1017 5 clear 0 4 1371 14 Ramfile::clear 0 1 331 47</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the current buffer contents.</span>
 <span class="s0">*/</span>
<span class="s0">33</span>
<span class="s0">inline void Ramfile::clear(void);</span>

<span class="s0">1018 8 ~Ramfile 0 516 1371 17 Ramfile::~Ramfile 0 0 0</span>
<span class="s0">24</span>
<span class="s0">Ramfile::~Ramfile(void);</span>

<span class="s0">1019 7 HashVal 0 260 1372 16 HashVal::HashVal 0 2 332 333 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline HashVal::HashVal(void);</span>
<span class="s0">inline HashVal::HashVal(HashVal const &amp;copy);</span>

<span class="s0">1020 10 operator = 0 4 1372 19 HashVal::operator = 0 1 334 0</span>
<span class="s0">53</span>
<span class="s0">inline void HashVal::operator =(HashVal const &amp;copy);</span>

<span class="s0">1021 11 operator == 0 4 1372 20 HashVal::operator == 0 1 335 0</span>
<span class="s0">61</span>
<span class="s0">inline bool HashVal::operator ==(HashVal const &amp;other) const;</span>

<span class="s0">1022 11 operator != 0 4 1372 20 HashVal::operator != 0 1 336 0</span>
<span class="s0">61</span>
<span class="s0">inline bool HashVal::operator !=(HashVal const &amp;other) const;</span>

<span class="s0">1023 10 operator &lt; 0 4 1372 19 HashVal::operator &lt; 0 1 337 0</span>
<span class="s0">60</span>
<span class="s0">inline bool HashVal::operator &lt;(HashVal const &amp;other) const;</span>

<span class="s0">1024 10 compare_to 0 4 1372 19 HashVal::compare_to 0 1 338 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int HashVal::compare_to(HashVal const &amp;other) const;</span>

<span class="s0">1025 10 merge_with 0 4 1372 19 HashVal::merge_with 0 1 339 86</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a new HashVal representing the xor of this one and the other one.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void HashVal::merge_with(HashVal const &amp;other);</span>

<span class="s0">1026 10 output_dec 0 4 1372 19 HashVal::output_dec 0 1 340 65</span>
<span class="s0">/**</span>
 <span class="s0">* Outputs the HashVal as four unsigned decimal integers.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void HashVal::output_dec(std::ostream &amp;out) const;</span>

<span class="s0">1027 9 input_dec 0 4 1372 18 HashVal::input_dec 0 1 341 64</span>
<span class="s0">/**</span>
 <span class="s0">* Inputs the HashVal as four unsigned decimal integers.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline void HashVal::input_dec(std::istream &amp;in);</span>

<span class="s0">1028 10 output_hex 0 4 1372 19 HashVal::output_hex 0 1 342 64</span>
<span class="s0">/**</span>
 <span class="s0">* Outputs the HashVal as a 32-digit hexadecimal number.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void HashVal::output_hex(std::ostream &amp;out) const;</span>

<span class="s0">1029 9 input_hex 0 4 1372 18 HashVal::input_hex 0 1 343 63</span>
<span class="s0">/**</span>
 <span class="s0">* Inputs the HashVal as a 32-digit hexadecimal number.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">void HashVal::input_hex(std::istream &amp;in);</span>

<span class="s0">1030 13 output_binary 0 4 1372 22 HashVal::output_binary 0 1 344 128</span>
<span class="s0">/**</span>
 <span class="s0">* Outputs the HashVal as a binary stream of bytes in order.  This is not the</span>
 <span class="s0">* same order generated by write_stream().</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void HashVal::output_binary(std::ostream &amp;out) const;</span>

<span class="s0">1031 12 input_binary 0 4 1372 21 HashVal::input_binary 0 1 345 125</span>
<span class="s0">/**</span>
 <span class="s0">* Inputs the HashVal as a binary stream of bytes in order.  This is not the</span>
 <span class="s0">* same order expected by read_stream().</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void HashVal::input_binary(std::istream &amp;in);</span>

<span class="s0">1032 6 output 0 4 1372 15 HashVal::output 0 1 346 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void HashVal::output(std::ostream &amp;out) const;</span>

<span class="s0">1033 6 as_dec 0 4 1372 15 HashVal::as_dec 0 1 347 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HashVal as a string with four decimal numbers.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">std::string HashVal::as_dec(void) const;</span>

<span class="s0">1034 12 set_from_dec 0 4 1372 21 HashVal::set_from_dec 0 1 348 112</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the HashVal from a string with four decimal numbers.  Returns true if</span>
 <span class="s0">* valid, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">bool HashVal::set_from_dec(std::string const &amp;text);</span>

<span class="s0">1035 6 as_hex 0 4 1372 15 HashVal::as_hex 0 1 349 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HashVal as a 32-byte hexadecimal string.</span>
 <span class="s0">*/</span>
<span class="s0">40</span>
<span class="s0">std::string HashVal::as_hex(void) const;</span>

<span class="s0">1036 12 set_from_hex 0 4 1372 21 HashVal::set_from_hex 0 1 350 111</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the HashVal from a 32-byte hexademical string.  Returns true if</span>
 <span class="s0">* successful, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">bool HashVal::set_from_hex(std::string const &amp;text);</span>

<span class="s0">1037 6 as_bin 0 4 1372 15 HashVal::as_bin 0 1 351 58</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the HashVal as a 16-byte binary string.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">vector_uchar HashVal::as_bin(void) const;</span>

<span class="s0">1038 12 set_from_bin 0 4 1372 21 HashVal::set_from_bin 0 1 352 106</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the HashVal from a 16-byte binary string.  Returns true if successful,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">bool HashVal::set_from_bin(vector_uchar const &amp;text);</span>

<span class="s0">1039 14 write_datagram 0 4 1372 23 HashVal::write_datagram 0 1 353 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void HashVal::write_datagram(Datagram &amp;destination) const;</span>

<span class="s0">1040 13 read_datagram 0 4 1372 22 HashVal::read_datagram 0 1 354 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline void HashVal::read_datagram(DatagramIterator &amp;source);</span>

<span class="s0">1041 12 write_stream 0 4 1372 21 HashVal::write_stream 0 1 355 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void HashVal::write_stream(StreamWriter &amp;destination) const;</span>

<span class="s0">1042 11 read_stream 0 4 1372 20 HashVal::read_stream 0 1 356 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void HashVal::read_stream(StreamReader &amp;source);</span>

<span class="s0">1043 9 hash_file 0 4 1372 18 HashVal::hash_file 0 1 357 232</span>
<span class="s0">/**</span>
 <span class="s0">* Generates the hash value from the indicated file.  Returns true on success,</span>
 <span class="s0">* false if the file cannot be read.  This method is only defined if we have</span>
 <span class="s0">* the OpenSSL library (which provides md5 functionality) available.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">bool HashVal::hash_file(Filename const &amp;filename);</span>

<span class="s0">1044 11 hash_stream 0 4 1372 20 HashVal::hash_stream 0 1 358 232</span>
<span class="s0">/**</span>
 <span class="s0">* Generates the hash value from the indicated file.  Returns true on success,</span>
 <span class="s0">* false if the file cannot be read.  This method is only defined if we have</span>
 <span class="s0">* the OpenSSL library (which provides md5 functionality) available.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">bool HashVal::hash_stream(std::istream &amp;stream);</span>

<span class="s0">1045 12 hash_ramfile 0 4 1372 21 HashVal::hash_ramfile 0 1 359 178</span>
<span class="s0">/**</span>
 <span class="s0">* Generates the hash value by hashing the indicated data.  This method is</span>
 <span class="s0">* only defined if we have the OpenSSL library (which provides md5</span>
 <span class="s0">* functionality) available.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void HashVal::hash_ramfile(Ramfile const &amp;ramfile);</span>

<span class="s0">1046 11 hash_string 0 4 1372 20 HashVal::hash_string 0 1 360 178</span>
<span class="s0">/**</span>
 <span class="s0">* Generates the hash value by hashing the indicated data.  This method is</span>
 <span class="s0">* only defined if we have the OpenSSL library (which provides md5</span>
 <span class="s0">* functionality) available.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void HashVal::hash_string(std::string const &amp;data);</span>

<span class="s0">1047 10 hash_bytes 0 4 1372 19 HashVal::hash_bytes 0 1 361 178</span>
<span class="s0">/**</span>
 <span class="s0">* Generates the hash value by hashing the indicated data.  This method is</span>
 <span class="s0">* only defined if we have the OpenSSL library (which provides md5</span>
 <span class="s0">* functionality) available.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void HashVal::hash_bytes(vector_uchar const &amp;data);</span>

<span class="s0">1048 11 hash_buffer 0 4 1372 20 HashVal::hash_buffer 0 1 362 178</span>
<span class="s0">/**</span>
 <span class="s0">* Generates the hash value by hashing the indicated data.  This method is</span>
 <span class="s0">* only defined if we have the OpenSSL library (which provides md5</span>
 <span class="s0">* functionality) available.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void HashVal::hash_buffer(char const *buffer, int length);</span>

<span class="s0">1049 8 ~HashVal 0 516 1372 17 HashVal::~HashVal 0 0 0</span>
<span class="s0">24</span>
<span class="s0">HashVal::~HashVal(void);</span>

<span class="s0">1050 19 MemoryUsagePointers 0 260 1373 40 MemoryUsagePointers::MemoryUsagePointers 0 2 363 364 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">135</span>
<span class="s0">MemoryUsagePointers::MemoryUsagePointers(void);</span>
<span class="s0">inline MemoryUsagePointers::MemoryUsagePointers(MemoryUsagePointers const &amp;) = default;</span>

<span class="s0">1051 20 ~MemoryUsagePointers 0 516 1373 41 MemoryUsagePointers::~MemoryUsagePointers 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">MemoryUsagePointers::~MemoryUsagePointers(void);</span>

<span class="s0">1052 16 get_num_pointers 0 4 1373 37 MemoryUsagePointers::get_num_pointers 0 1 365 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of pointers in the set.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">std::size_t MemoryUsagePointers::get_num_pointers(void) const;</span>

<span class="s0">1053 11 get_pointer 0 4 1373 32 MemoryUsagePointers::get_pointer 0 1 366 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth pointer of the set.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">ReferenceCount *MemoryUsagePointers::get_pointer(std::size_t n) const;</span>

<span class="s0">1054 17 get_typed_pointer 0 4 1373 38 MemoryUsagePointers::get_typed_pointer 0 1 367 175</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth pointer of the set, typecast to a TypedObject if possible.</span>
 <span class="s0">* If the pointer is not a TypedObject or if the cast cannot be made, returns</span>
 <span class="s0">* nullptr.</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">TypedObject *MemoryUsagePointers::get_typed_pointer(std::size_t n) const;</span>

<span class="s0">1055 8 get_type 0 4 1373 29 MemoryUsagePointers::get_type 0 1 368 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the actual type of the nth pointer, if it is known.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">TypeHandle MemoryUsagePointers::get_type(std::size_t n) const;</span>

<span class="s0">1056 13 get_type_name 0 4 1373 34 MemoryUsagePointers::get_type_name 0 1 369 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type name of the nth pointer, if it is known.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">std::string MemoryUsagePointers::get_type_name(std::size_t n) const;</span>

<span class="s0">1057 7 get_age 0 4 1373 28 MemoryUsagePointers::get_age 0 1 370 197</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the age of the nth pointer: the number of seconds elapsed between</span>
 <span class="s0">* the time it was allocated and the time it was added to this set via a call</span>
 <span class="s0">* to MemoryUsage::get_pointers().</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">double MemoryUsagePointers::get_age(std::size_t n) const;</span>

<span class="s0">1058 18 get_python_pointer 0 4 1373 39 MemoryUsagePointers::get_python_pointer 0 1 371 0</span>
<span class="s0">71</span>
<span class="s0">PyObject *MemoryUsagePointers::get_python_pointer(std::size_t n) const;</span>

<span class="s0">1059 5 clear 0 4 1373 26 MemoryUsagePointers::clear 0 1 372 39</span>
<span class="s0">/**</span>
 <span class="s0">* Empties the set of pointers.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void MemoryUsagePointers::clear(void);</span>

<span class="s0">1060 6 output 0 4 1373 27 MemoryUsagePointers::output 0 1 373 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void MemoryUsagePointers::output(std::ostream &amp;out) const;</span>

<span class="s0">1061 10 ISubStream 0 260 1374 22 ISubStream::ISubStream 0 2 374 375 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">142</span>
<span class="s0">inline ISubStream::ISubStream(void);</span>
<span class="s0">inline explicit ISubStream::ISubStream(IStreamWrapper *source, std::streamoff start, std::streamoff end);</span>

<span class="s0">1062 4 open 0 4 1374 16 ISubStream::open 0 1 376 391</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the SubStream reading from the indicated source, with the first</span>
 <span class="s0">* character being the character at position &quot;start&quot; within the source, for</span>
 <span class="s0">* end - start total characters.  The character at &quot;end&quot; within the source</span>
 <span class="s0">* will never be read; this will appear to be EOF.</span>
 <span class="s0">*</span>
 <span class="s0">* If end is zero, it indicates that the ISubStream will continue until the</span>
 <span class="s0">* end of the source stream.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline ISubStream &amp;ISubStream::open(IStreamWrapper *source, std::streamoff start, std::streamoff end);</span>

<span class="s0">1063 5 close 0 4 1374 17 ISubStream::close 0 1 377 92</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the SubStream to empty, but does not actually close the source</span>
 <span class="s0">* istream.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline ISubStream &amp;ISubStream::close(void);</span>

<span class="s0">1064 11 ~ISubStream 0 516 1374 23 ISubStream::~ISubStream 0 0 0</span>
<span class="s0">30</span>
<span class="s0">ISubStream::~ISubStream(void);</span>

<span class="s0">1065 10 OSubStream 0 260 1376 22 OSubStream::OSubStream 0 2 378 379 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">inline OSubStream::OSubStream(void);</span>
<span class="s0">inline explicit OSubStream::OSubStream(OStreamWrapper *dest, std::streamoff start, std::streamoff end, bool append = false);</span>

<span class="s0">1066 4 open 0 4 1376 16 OSubStream::open 0 1 380 383</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the SubStream reading from the indicated dest, with the first</span>
 <span class="s0">* character being the character at position &quot;start&quot; within the dest, for end</span>
 <span class="s0">* - start total characters.  The character at &quot;end&quot; within the dest will</span>
 <span class="s0">* never be read; this will appear to be EOF.</span>
 <span class="s0">*</span>
 <span class="s0">* If end is zero, it indicates that the OSubStream will continue until the</span>
 <span class="s0">* end of the dest stream.</span>
 <span class="s0">*/</span>
<span class="s0">121</span>
<span class="s0">inline OSubStream &amp;OSubStream::open(OStreamWrapper *dest, std::streamoff start, std::streamoff end, bool append = false);</span>

<span class="s0">1067 5 close 0 4 1376 17 OSubStream::close 0 1 381 90</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the SubStream to empty, but does not actually close the dest</span>
 <span class="s0">* ostream.</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">inline OSubStream &amp;OSubStream::close(void);</span>

<span class="s0">1068 11 ~OSubStream 0 516 1376 23 OSubStream::~OSubStream 0 0 0</span>
<span class="s0">30</span>
<span class="s0">OSubStream::~OSubStream(void);</span>

<span class="s0">1069 9 SubStream 0 260 1378 20 SubStream::SubStream 0 2 382 383 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">158</span>
<span class="s0">inline SubStream::SubStream(void);</span>
<span class="s0">inline explicit SubStream::SubStream(StreamWrapper *nested, std::streamoff start, std::streamoff end, bool append = false);</span>

<span class="s0">1070 4 open 0 4 1378 15 SubStream::open 0 1 384 278</span>
<span class="s0">/**</span>
 <span class="s0">* Starts the SubStream reading and writing from the indicated nested stream,</span>
 <span class="s0">* within the indicated range.  &quot;end&quot; is the first character outside of the</span>
 <span class="s0">* range.</span>
 <span class="s0">*</span>
 <span class="s0">* If end is zero, it indicates that the SubStream will continue until the end</span>
 <span class="s0">* of the nested stream.</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">inline SubStream &amp;SubStream::open(StreamWrapper *nested, std::streamoff start, std::streamoff end, bool append = false);</span>

<span class="s0">1071 5 close 0 4 1378 16 SubStream::close 0 1 385 92</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the SubStream to empty, but does not actually close the nested</span>
 <span class="s0">* ostream.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline SubStream &amp;SubStream::close(void);</span>

<span class="s0">1072 10 ~SubStream 0 516 1378 21 SubStream::~SubStream 0 0 0</span>
<span class="s0">28</span>
<span class="s0">SubStream::~SubStream(void);</span>

<span class="s0">1073 9 Multifile 0 260 1380 20 Multifile::Multifile 0 1 386 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">27</span>
<span class="s0">Multifile::Multifile(void);</span>

<span class="s0">1074 9 open_read 0 4 1380 20 Multifile::open_read 0 2 387 388 687</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the named Multifile on disk for reading.  The Multifile index is read</span>
 <span class="s0">* in, and the list of subfiles becomes available; individual subfiles may</span>
 <span class="s0">* then be extracted or read, but the list of subfiles may not be modified.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see the version of open_read() which accepts an istream.  Returns true</span>
 <span class="s0">* on success, false on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Opens an anonymous Multifile for reading using an istream.  There must be</span>
 <span class="s0">* seek functionality via seekg() and tellg() on the istream.</span>
 <span class="s0">*</span>
 <span class="s0">* If owns_pointer is true, then the Multifile assumes ownership of the stream</span>
 <span class="s0">* pointer and will delete it when the multifile is closed, including if this</span>
 <span class="s0">* function returns false.</span>
 <span class="s0">*/</span>
<span class="s0">214</span>
<span class="s0">bool Multifile::open_read(Filename const &amp;multifile_name, std::streamoff const &amp;offset = 0);</span>
<span class="s0">bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = false, std::streamoff const &amp;offset = 0);</span>

<span class="s0">1075 10 open_write 0 4 1380 21 Multifile::open_write 0 2 389 390 755</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the named Multifile on disk for writing.  If there already exists a</span>
 <span class="s0">* file by that name, it is truncated.  The Multifile is then prepared for</span>
 <span class="s0">* accepting a brand new set of subfiles, which will be written to the</span>
 <span class="s0">* indicated filename.  Individual subfiles may not be extracted or read.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see the version of open_write() which accepts an ostream.  Returns</span>
 <span class="s0">* true on success, false on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Opens an anonymous Multifile for writing using an ostream.  There must be</span>
 <span class="s0">* seek functionality via seekp() and tellp() on the pstream.</span>
 <span class="s0">*</span>
 <span class="s0">* If owns_pointer is true, then the Multifile assumes ownership of the stream</span>
 <span class="s0">* pointer and will delete it when the multifile is closed, including if this</span>
 <span class="s0">* function returns false.</span>
 <span class="s0">*/</span>
<span class="s0">146</span>
<span class="s0">bool Multifile::open_write(Filename const &amp;multifile_name);</span>
<span class="s0">bool Multifile::open_write(std::ostream *multifile_stream, bool owns_pointer = false);</span>

<span class="s0">1076 15 open_read_write 0 4 1380 26 Multifile::open_read_write 0 2 391 392 727</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the named Multifile on disk for reading and writing.  If there</span>
 <span class="s0">* already exists a file by that name, its index is read.  Subfiles may be</span>
 <span class="s0">* added or removed, and the resulting changes will be written to the named</span>
 <span class="s0">* file.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see the version of open_read_write() which accepts an iostream.</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Opens an anonymous Multifile for reading and writing using an iostream.</span>
 <span class="s0">* There must be seek functionality via seekg()/seekp() and tellg()/tellp() on</span>
 <span class="s0">* the iostream.</span>
 <span class="s0">*</span>
 <span class="s0">* If owns_pointer is true, then the Multifile assumes ownership of the stream</span>
 <span class="s0">* pointer and will delete it when the multifile is closed, including if this</span>
 <span class="s0">* function returns false.</span>
 <span class="s0">*/</span>
<span class="s0">157</span>
<span class="s0">bool Multifile::open_read_write(Filename const &amp;multifile_name);</span>
<span class="s0">bool Multifile::open_read_write(std::iostream *multifile_stream, bool owns_pointer = false);</span>

<span class="s0">1077 5 close 0 4 1380 16 Multifile::close 0 1 393 169</span>
<span class="s0">/**</span>
 <span class="s0">* Closes the Multifile if it is open.  All changes are flushed to disk, and</span>
 <span class="s0">* the file becomes invalid for further operations until the next call to</span>
 <span class="s0">* open().</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">void Multifile::close(void);</span>

<span class="s0">1078 18 get_multifile_name 0 4 1380 29 Multifile::get_multifile_name 0 1 394 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the filename of the Multifile, if it is available.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline Filename const &amp;Multifile::get_multifile_name(void) const;</span>

<span class="s0">1079 18 set_multifile_name 0 4 1380 29 Multifile::set_multifile_name 0 1 395 209</span>
<span class="s0">/**</span>
 <span class="s0">* Replaces the filename of the Multifile.  This is primarily used for</span>
 <span class="s0">* documentation purposes only; changing this name does not open the indicated</span>
 <span class="s0">* file.  See open_read() or open_write() for that.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void Multifile::set_multifile_name(Filename const &amp;multifile_name);</span>

<span class="s0">1080 13 is_read_valid 0 4 1380 24 Multifile::is_read_valid 0 1 396 154</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Multifile has been opened for read mode and there have</span>
 <span class="s0">* been no errors, and individual Subfile contents may be extracted.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool Multifile::is_read_valid(void) const;</span>

<span class="s0">1081 14 is_write_valid 0 4 1380 25 Multifile::is_write_valid 0 1 397 162</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Multifile has been opened for write mode and there have</span>
 <span class="s0">* been no errors, and Subfiles may be added or removed from the Multifile.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline bool Multifile::is_write_valid(void) const;</span>

<span class="s0">1082 12 needs_repack 0 4 1380 23 Multifile::needs_repack 0 1 398 118</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Multifile index is suboptimal and should be repacked.</span>
 <span class="s0">* Call repack() to achieve this.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline bool Multifile::needs_repack(void) const;</span>

<span class="s0">1083 13 get_timestamp 0 4 1380 24 Multifile::get_timestamp 0 1 399 299</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the modification timestamp of the overall Multifile.  This</span>
 <span class="s0">* indicates the most recent date at which subfiles were added or removed from</span>
 <span class="s0">* the Multifile.  Note that it is logically possible for an individual</span>
 <span class="s0">* subfile to have a more recent timestamp than the overall timestamp.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline time_t Multifile::get_timestamp(void) const;</span>

<span class="s0">1084 13 set_timestamp 0 4 1380 24 Multifile::set_timestamp 0 1 400 206</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the overall mudification timestamp of the multifile.  Note that this</span>
 <span class="s0">* will be reset to the current time every time you modify a subfile.</span>
 <span class="s0">* Only set this if you know what you are doing!</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void Multifile::set_timestamp(time_t timestamp);</span>

<span class="s0">1085 20 set_record_timestamp 0 4 1380 31 Multifile::set_record_timestamp 0 1 401 529</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating whether timestamps should be recorded within the</span>
 <span class="s0">* Multifile or not.  The default is true, indicating the Multifile will</span>
 <span class="s0">* record timestamps for the overall file and also for each subfile.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is false, the Multifile will not record timestamps internally.  In</span>
 <span class="s0">* this case, the return value from get_timestamp() or get_subfile_timestamp()</span>
 <span class="s0">* will be estimations.</span>
 <span class="s0">*</span>
 <span class="s0">* You may want to set this false to minimize the bitwise difference between</span>
 <span class="s0">* independently-generated Multifiles.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void Multifile::set_record_timestamp(bool record_timestamp);</span>

<span class="s0">1086 20 get_record_timestamp 0 4 1380 31 Multifile::get_record_timestamp 0 1 402 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag indicating whether timestamps should be recorded within</span>
 <span class="s0">* the Multifile or not.  See set_record_timestamp().</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool Multifile::get_record_timestamp(void) const;</span>

<span class="s0">1087 16 set_scale_factor 0 4 1380 27 Multifile::set_scale_factor 0 1 403 782</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the internal scale factor for this Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* This is normally 1, but it may be set to any arbitrary value (greater than</span>
 <span class="s0">* zero) to support Multifile archives that exceed 4GB, if necessary.</span>
 <span class="s0">* (Individual subfiles may still not exceed 4GB.)</span>
 <span class="s0">*</span>
 <span class="s0">* All addresses within the file are rounded up to the next multiple of</span>
 <span class="s0">* _scale_factor, and zeros are written to the file to fill the resulting</span>
 <span class="s0">* gaps.  Then the address is divided by _scale_factor and written out as a</span>
 <span class="s0">* 32-bit integer.  Thus, setting a scale factor of 2 supports up to 8GB</span>
 <span class="s0">* files, 3 supports 12GB files, etc.</span>
 <span class="s0">*</span>
 <span class="s0">* Calling this function on an already-existing Multifile will have no</span>
 <span class="s0">* immediate effect until a future call to repack() or close() (or until the</span>
 <span class="s0">* Multifile is destructed).</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">void Multifile::set_scale_factor(std::size_t scale_factor);</span>

<span class="s0">1088 16 get_scale_factor 0 4 1380 27 Multifile::get_scale_factor 0 1 404 92</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the internal scale factor for this Multifile.  See</span>
 <span class="s0">* set_scale_factor().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline std::size_t Multifile::get_scale_factor(void) const;</span>

<span class="s0">1089 19 set_encryption_flag 0 4 1380 30 Multifile::set_encryption_flag 0 1 405 461</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating whether subsequently-added subfiles should be</span>
 <span class="s0">* encrypted before writing them to the multifile.  If true, subfiles will be</span>
 <span class="s0">* encrypted; if false (the default), they will be written without encryption.</span>
 <span class="s0">*</span>
 <span class="s0">* When true, subfiles will be encrypted with the password specified by</span>
 <span class="s0">* set_encryption_password().  It is possible to apply a different password to</span>
 <span class="s0">* different files, but the resulting file can't be mounted via VFS.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void Multifile::set_encryption_flag(bool flag);</span>

<span class="s0">1090 19 get_encryption_flag 0 4 1380 30 Multifile::get_encryption_flag 0 1 406 163</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the flag indicating whether subsequently-added subfiles should be</span>
 <span class="s0">* encrypted before writing them to the multifile.  See set_encryption_flag().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool Multifile::get_encryption_flag(void) const;</span>

<span class="s0">1091 23 set_encryption_password 0 4 1380 34 Multifile::set_encryption_password 0 1 407 369</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the password that will be used to encrypt subfiles subsequently</span>
 <span class="s0">* added to the multifile, if the encryption flag is also set true (see</span>
 <span class="s0">* set_encryption_flag()).</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible to apply a different password to different files, but the</span>
 <span class="s0">* resulting file can't be mounted via VFS.  Changing this value may cause an</span>
 <span class="s0">* implicit call to flush().</span>
 <span class="s0">*/</span>
<span class="s0">87</span>
<span class="s0">inline void Multifile::set_encryption_password(std::string const &amp;encryption_password);</span>

<span class="s0">1092 23 get_encryption_password 0 4 1380 34 Multifile::get_encryption_password 0 1 408 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the password that will be used to encrypt subfiles subsequently</span>
 <span class="s0">* added to the multifile.  See set_encryption_password().</span>
 <span class="s0">*/</span>
<span class="s0">73</span>
<span class="s0">inline std::string const &amp;Multifile::get_encryption_password(void) const;</span>

<span class="s0">1093 24 set_encryption_algorithm 0 4 1380 35 Multifile::set_encryption_algorithm 0 1 409 659</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the encryption algorithm that should be used for future calls to</span>
 <span class="s0">* add_subfile().  The default is whatever is specified by the encryption-</span>
 <span class="s0">* algorithm config variable.  The complete set of available algorithms is</span>
 <span class="s0">* defined by the current version of OpenSSL.</span>
 <span class="s0">*</span>
 <span class="s0">* If an invalid algorithm is specified, there is no immediate error return</span>
 <span class="s0">* code, but flush() will fail and the file will be invalid.</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible to apply a different encryption algorithm to different</span>
 <span class="s0">* files, and unlike the password, this does not interfere with mounting the</span>
 <span class="s0">* multifile via VFS.  Changing this value may cause an implicit call to</span>
 <span class="s0">* flush().</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline void Multifile::set_encryption_algorithm(std::string const &amp;encryption_algorithm);</span>

<span class="s0">1094 24 get_encryption_algorithm 0 4 1380 35 Multifile::get_encryption_algorithm 0 1 410 96</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the encryption algorithm that was specified by</span>
 <span class="s0">* set_encryption_algorithm().</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline std::string const &amp;Multifile::get_encryption_algorithm(void) const;</span>

<span class="s0">1095 25 set_encryption_key_length 0 4 1380 36 Multifile::set_encryption_key_length 0 1 411 611</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the length of the key, in bits, that should be used to encrypt</span>
 <span class="s0">* the stream in future calls to add_subfile().  The default is whatever is</span>
 <span class="s0">* specified by the encryption-key-length config variable.</span>
 <span class="s0">*</span>
 <span class="s0">* If an invalid key_length for the chosen algorithm is specified, there is no</span>
 <span class="s0">* immediate error return code, but flush() will fail and the file will be</span>
 <span class="s0">* invalid.</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible to apply a different key length to different files, and</span>
 <span class="s0">* unlike the password, this does not interfere with mounting the multifile</span>
 <span class="s0">* via VFS. Changing this value may cause an implicit call to flush().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline void Multifile::set_encryption_key_length(int encryption_key_length);</span>

<span class="s0">1096 25 get_encryption_key_length 0 4 1380 36 Multifile::get_encryption_key_length 0 1 412 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the encryption key length, in bits, that was specified by</span>
 <span class="s0">* set_encryption_key_length().</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int Multifile::get_encryption_key_length(void) const;</span>

<span class="s0">1097 30 set_encryption_iteration_count 0 4 1380 41 Multifile::set_encryption_iteration_count 0 1 413 740</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the number of times to repeatedly hash the key before writing it</span>
 <span class="s0">* to the stream in future calls to add_subfile().  Its purpose is to make it</span>
 <span class="s0">* computationally more expensive for an attacker to search the key space</span>
 <span class="s0">* exhaustively.  This should be a multiple of 1,000 and should not exceed</span>
 <span class="s0">* about 65 million; the value 0 indicates just one application of the hashing</span>
 <span class="s0">* algorithm.</span>
 <span class="s0">*</span>
 <span class="s0">* The default is whatever is specified by the multifile-encryption-iteration-</span>
 <span class="s0">* count config variable.</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible to apply a different iteration count to different files, and</span>
 <span class="s0">* unlike the password, this does not interfere with mounting the multifile</span>
 <span class="s0">* via VFS.  Changing this value causes an implicit call to flush().</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void Multifile::set_encryption_iteration_count(int encryption_iteration_count);</span>

<span class="s0">1098 30 get_encryption_iteration_count 0 4 1380 41 Multifile::get_encryption_iteration_count 0 1 414 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value that was specified by set_encryption_iteration_count().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int Multifile::get_encryption_iteration_count(void) const;</span>

<span class="s0">1099 11 add_subfile 0 4 1380 22 Multifile::add_subfile 0 2 415 416 1397</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a file on disk as a subfile to the Multifile.  The file named by</span>
 <span class="s0">* filename will be read and added to the Multifile at the next call to</span>
 <span class="s0">* flush().  If there already exists a subfile with the indicated name, it is</span>
 <span class="s0">* replaced without examining its contents (but see also update_subfile).</span>
 <span class="s0">*</span>
 <span class="s0">* Either Filename:::set_binary() or set_text() must have been called</span>
 <span class="s0">* previously to specify the nature of the source file.  If set_text() was</span>
 <span class="s0">* called, the text flag will be set on the subfile.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the subfile name on success (it might have been modified slightly),</span>
 <span class="s0">* or empty string on failure.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a file from a stream as a subfile to the Multifile.  The indicated</span>
 <span class="s0">* istream will be read and its contents added to the Multifile at the next</span>
 <span class="s0">* call to flush(). The file will be added as a binary subfile.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the istream must remain untouched and unused by any other code</span>
 <span class="s0">* until flush() is called.  At that time, the Multifile will read the entire</span>
 <span class="s0">* contents of the istream from the current file position to the end of the</span>
 <span class="s0">* file.  Subsequently, the Multifile will *not* close or delete the istream.</span>
 <span class="s0">* It is the caller's responsibility to ensure that the istream pointer does</span>
 <span class="s0">* not destruct during the lifetime of the Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the subfile name on success (it might have been modified slightly),</span>
 <span class="s0">* or empty string on failure.</span>
 <span class="s0">*/</span>
<span class="s0">237</span>
<span class="s0">std::string Multifile::add_subfile(std::string const &amp;subfile_name, Filename const &amp;filename, int compression_level);</span>
<span class="s0">std::string Multifile::add_subfile(std::string const &amp;subfile_name, std::istream *subfile_data, int compression_level);</span>

<span class="s0">1100 14 update_subfile 0 4 1380 25 Multifile::update_subfile 0 1 417 451</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a file on disk to the subfile.  If a subfile already exists with the</span>
 <span class="s0">* same name, its contents are compared byte-for-byte to the disk file, and it</span>
 <span class="s0">* is replaced only if it is different; otherwise, the multifile is left</span>
 <span class="s0">* unchanged.</span>
 <span class="s0">*</span>
 <span class="s0">* Either Filename:::set_binary() or set_text() must have been called</span>
 <span class="s0">* previously to specify the nature of the source file.  If set_text() was</span>
 <span class="s0">* called, the text flag will be set on the subfile.</span>
 <span class="s0">*/</span>
<span class="s0">120</span>
<span class="s0">std::string Multifile::update_subfile(std::string const &amp;subfile_name, Filename const &amp;filename, int compression_level);</span>

<span class="s0">1101 13 add_signature 0 4 1380 24 Multifile::add_signature 0 2 418 419 3062</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new signature to the Multifile.  This signature associates the</span>
 <span class="s0">* indicated certificate with the current contents of the Multifile.  When the</span>
 <span class="s0">* Multifile is read later, the signature will still be present only if the</span>
 <span class="s0">* Multifile is unchanged; any subsequent changes to the Multifile will</span>
 <span class="s0">* automatically invalidate and remove the signature.</span>
 <span class="s0">*</span>
 <span class="s0">* The chain filename may be empty if the certificate does not require an</span>
 <span class="s0">* authenticating certificate chain (e.g.  because it is self-signed).</span>
 <span class="s0">*</span>
 <span class="s0">* The specified private key must match the certificate, and the Multifile</span>
 <span class="s0">* must be open in read-write mode.  The private key is only used for</span>
 <span class="s0">* generating the signature; it is not written to the Multifile and cannot be</span>
 <span class="s0">* retrieved from the Multifile later.  (However, the certificate *can* be</span>
 <span class="s0">* retrieved from the Multifile later, to identify the entity that created the</span>
 <span class="s0">* signature.)</span>
 <span class="s0">*</span>
 <span class="s0">* This implicitly causes a repack() operation if one is needed.  Returns true</span>
 <span class="s0">* on success, false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of add_signature() reads the certificate and private key from a</span>
 <span class="s0">* PEM-formatted file, for instance as generated by the openssl command.  If</span>
 <span class="s0">* the private key file is password-encrypted, the third parameter will be</span>
 <span class="s0">* used as the password to decrypt it.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new signature to the Multifile.  This signature associates the</span>
 <span class="s0">* indicated certificate with the current contents of the Multifile.  When the</span>
 <span class="s0">* Multifile is read later, the signature will still be present only if the</span>
 <span class="s0">* Multifile is unchanged; any subsequent changes to the Multifile will</span>
 <span class="s0">* automatically invalidate and remove the signature.</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of add_signature() reads the certificate, private key, and</span>
 <span class="s0">* certificate chain from the same PEM-formatted file.  It takes the first</span>
 <span class="s0">* private key found as the intended key, and then uses the first certificate</span>
 <span class="s0">* found that matches that key as the signing certificate.  Any other</span>
 <span class="s0">* certificates in the file are taken to be part of the chain.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a new signature to the Multifile.  This signature associates the</span>
 <span class="s0">* indicated certificate with the current contents of the Multifile.  When the</span>
 <span class="s0">* Multifile is read later, the signature will still be present only if the</span>
 <span class="s0">* Multifile is unchanged; any subsequent changes to the Multifile will</span>
 <span class="s0">* automatically invalidate and remove the signature.</span>
 <span class="s0">*</span>
 <span class="s0">* The signature certificate is the first certificate on the CertChain object.</span>
 <span class="s0">* Any remaining certificates are support certificates to authenticate the</span>
 <span class="s0">* first one.</span>
 <span class="s0">*</span>
 <span class="s0">* The specified private key must match the certificate, and the Multifile</span>
 <span class="s0">* must be open in read-write mode.  The private key is only used for</span>
 <span class="s0">* generating the signature; it is not written to the Multifile and cannot be</span>
 <span class="s0">* retrieved from the Multifile later.  (However, the certificate *can* be</span>
 <span class="s0">* retrieved from the Multifile later, to identify the entity that created the</span>
 <span class="s0">* signature.)</span>
 <span class="s0">*</span>
 <span class="s0">* This implicitly causes a repack() operation if one is needed.  Returns true</span>
 <span class="s0">* on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">230</span>
<span class="s0">bool Multifile::add_signature(Filename const &amp;certificate, Filename const &amp;chain, Filename const &amp;pkey, std::string const &amp;password = &quot;&quot;);</span>
<span class="s0">bool Multifile::add_signature(Filename const &amp;composite, std::string const &amp;password = &quot;&quot;);</span>

<span class="s0">1102 18 get_num_signatures 0 4 1380 29 Multifile::get_num_signatures 0 1 420 555</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of matching signatures found on the Multifile.  These</span>
 <span class="s0">* signatures may be iterated via get_signature() and related methods.</span>
 <span class="s0">*</span>
 <span class="s0">* A signature on this list is guaranteed to match the Multifile contents,</span>
 <span class="s0">* proving that the Multifile has been unmodified since the signature was</span>
 <span class="s0">* applied.  However, this does not guarantee that the certificate itself is</span>
 <span class="s0">* actually from who it says it is from; only that it matches the Multifile</span>
 <span class="s0">* contents.  See validate_signature_certificate() to authenticate a</span>
 <span class="s0">* particular certificate.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">int Multifile::get_num_signatures(void) const;</span>

<span class="s0">1103 26 get_signature_subject_name 0 4 1380 37 Multifile::get_signature_subject_name 0 1 421 352</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;subject name&quot; for the nth signature found on the Multifile.</span>
 <span class="s0">* This is a string formatted according to RFC2253 that should more-or-less</span>
 <span class="s0">* identify a particular certificate; when paired with the public key (see</span>
 <span class="s0">* get_signature_public_key()), it can uniquely identify a certificate.  See</span>
 <span class="s0">* the comments in get_num_signatures().</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">std::string Multifile::get_signature_subject_name(int n) const;</span>

<span class="s0">1104 27 get_signature_friendly_name 0 4 1380 38 Multifile::get_signature_friendly_name 0 1 422 299</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a &quot;friendly name&quot; for the nth signature found on the Multifile.</span>
 <span class="s0">* This attempts to extract out the most meaningful part of the subject name.</span>
 <span class="s0">* It returns the emailAddress, if it is defined; otherwise, it returns the</span>
 <span class="s0">* commonName.</span>
 <span class="s0">*</span>
 <span class="s0">* See the comments in get_num_signatures().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">std::string Multifile::get_signature_friendly_name(int n) const;</span>

<span class="s0">1105 24 get_signature_public_key 0 4 1380 35 Multifile::get_signature_public_key 0 1 423 379</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the public key used for the nth signature found on the Multifile.</span>
 <span class="s0">* This is encoded in DER form and returned as a string of hex digits.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used, in conjunction with the subject name (see</span>
 <span class="s0">* get_signature_subject_name()), to uniquely identify a particular</span>
 <span class="s0">* certificate and its subsequent reissues.  See the comments in</span>
 <span class="s0">* get_num_signatures().</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">std::string Multifile::get_signature_public_key(int n) const;</span>

<span class="s0">1106 27 print_signature_certificate 0 4 1380 38 Multifile::print_signature_certificate 0 1 424 158</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the certificate for the nth signature, in user-readable verbose</span>
 <span class="s0">* form, to the indicated stream.  See the comments in get_num_signatures().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void Multifile::print_signature_certificate(int n, std::ostream &amp;out) const;</span>

<span class="s0">1107 27 write_signature_certificate 0 4 1380 38 Multifile::write_signature_certificate 0 1 425 140</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the certificate for the nth signature, in PEM form, to the indicated</span>
 <span class="s0">* stream.  See the comments in get_num_signatures().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">void Multifile::write_signature_certificate(int n, std::ostream &amp;out) const;</span>

<span class="s0">1108 30 validate_signature_certificate 0 4 1380 41 Multifile::validate_signature_certificate 0 1 426 289</span>
<span class="s0">/**</span>
 <span class="s0">* Checks that the certificate used for the nth signature is a valid,</span>
 <span class="s0">* authorized certificate with some known certificate authority.  Returns 0 if</span>
 <span class="s0">* it is valid, -1 if there is some error, or the corresponding OpenSSL error</span>
 <span class="s0">* code if it is invalid, out-of-date, or self-signed.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">int Multifile::validate_signature_certificate(int n) const;</span>

<span class="s0">1109 5 flush 0 4 1380 16 Multifile::flush 0 1 427 691</span>
<span class="s0">/**</span>
 <span class="s0">* Writes all contents of the Multifile to disk.  Until flush() is called,</span>
 <span class="s0">* add_subfile() and remove_subfile() do not actually do anything to disk.  At</span>
 <span class="s0">* this point, all of the recently-added subfiles are read and their contents</span>
 <span class="s0">* are added to the end of the Multifile, and the recently-removed subfiles</span>
 <span class="s0">* are marked gone from the Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* This may result in a suboptimal index.  To guarantee that the index is</span>
 <span class="s0">* written at the beginning of the file, call repack() instead of flush().</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call flush() explicitly unless you are concerned</span>
 <span class="s0">* about reading the recently-added subfiles immediately.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">bool Multifile::flush(void);</span>

<span class="s0">1110 6 repack 0 4 1380 17 Multifile::repack 0 1 428 587</span>
<span class="s0">/**</span>
 <span class="s0">* Forces a complete rewrite of the Multifile and all of its contents, so that</span>
 <span class="s0">* its index will appear at the beginning of the file with all of the subfiles</span>
 <span class="s0">* listed in alphabetical order.  This is considered optimal for reading, and</span>
 <span class="s0">* is the standard configuration; but it is not essential to do this.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the Multifile was opened using</span>
 <span class="s0">* open_read_write() and an explicit filename, rather than an iostream.  Also,</span>
 <span class="s0">* we must have write permission to the directory containing the Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">29</span>
<span class="s0">bool Multifile::repack(void);</span>

<span class="s0">1111 16 get_num_subfiles 0 4 1380 27 Multifile::get_num_subfiles 0 1 429 169</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of subfiles within the Multifile.  The subfiles may be</span>
 <span class="s0">* accessed in alphabetical order by iterating through [0 ..</span>
 <span class="s0">* get_num_subfiles()).</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">int Multifile::get_num_subfiles(void) const;</span>

<span class="s0">1112 12 find_subfile 0 4 1380 23 Multifile::find_subfile 0 1 430 127</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the subfile with the indicated name, or -1 if the</span>
 <span class="s0">* named subfile is not within the Multifile.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">int Multifile::find_subfile(std::string const &amp;subfile_name) const;</span>

<span class="s0">1113 13 has_directory 0 4 1380 24 Multifile::has_directory 0 1 431 203</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated subfile name is the directory prefix to one</span>
 <span class="s0">* or more files within the Multifile.  That is, the Multifile contains at</span>
 <span class="s0">* least one file named &quot;subfile_name/...&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool Multifile::has_directory(std::string const &amp;subfile_name) const;</span>

<span class="s0">1114 14 scan_directory 0 4 1380 25 Multifile::scan_directory 0 1 432 420</span>
<span class="s0">/**</span>
 <span class="s0">* Considers subfile_name to be the name of a subdirectory within the</span>
 <span class="s0">* Multifile, but not a file itself; fills the given vector up with the sorted</span>
 <span class="s0">* list of subdirectories or files within the named directory.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that directories do not exist explicitly within a Multifile; this just</span>
 <span class="s0">* checks for the existence of files with the given initial prefix.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">bool Multifile::scan_directory(vector_string &amp;contents, std::string const &amp;subfile_name) const;</span>

<span class="s0">1115 14 remove_subfile 0 4 1380 25 Multifile::remove_subfile 0 2 433 434 912</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the named subfile from the Multifile, if it exists; returns true if</span>
 <span class="s0">* successfully removed, or false if it did not exist in the first place.  The</span>
 <span class="s0">* file will not actually be removed from the disk until the next call to</span>
 <span class="s0">* flush().</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this does not actually remove the data from the indicated</span>
 <span class="s0">* subfile; it simply removes it from the index.  The Multifile will not be</span>
 <span class="s0">* reduced in size after this operation, until the next call to repack().</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Removes the nth subfile from the Multifile.  This will cause all subsequent</span>
 <span class="s0">* index numbers to decrease by one.  The file will not actually be removed</span>
 <span class="s0">* from the disk until the next call to flush().</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this does not actually remove the data from the indicated</span>
 <span class="s0">* subfile; it simply removes it from the index.  The Multifile will not be</span>
 <span class="s0">* reduced in size after this operation, until the next call to repack().</span>
 <span class="s0">*/</span>
<span class="s0">114</span>
<span class="s0">void Multifile::remove_subfile(int index);</span>
<span class="s0">inline bool Multifile::remove_subfile(std::string const &amp;subfile_name);</span>

<span class="s0">1116 16 get_subfile_name 0 4 1380 27 Multifile::get_subfile_name 0 1 435 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the nth subfile.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">std::string const &amp;Multifile::get_subfile_name(int index) const;</span>

<span class="s0">1117 18 get_subfile_length 0 4 1380 29 Multifile::get_subfile_length 0 1 436 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the uncompressed data length of the nth subfile.  This might return</span>
 <span class="s0">* 0 if the subfile has recently been added and flush() has not yet been</span>
 <span class="s0">* called.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">std::size_t Multifile::get_subfile_length(int index) const;</span>

<span class="s0">1118 21 get_subfile_timestamp 0 4 1380 32 Multifile::get_subfile_timestamp 0 1 437 270</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the modification time of the nth subfile.  If this is called on an</span>
 <span class="s0">* older .mf file, which did not store individual timestamps in the file (or</span>
 <span class="s0">* if get_record_timestamp() is false), this will return the modification time</span>
 <span class="s0">* of the overall multifile.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">time_t Multifile::get_subfile_timestamp(int index) const;</span>

<span class="s0">1119 21 is_subfile_compressed 0 4 1380 32 Multifile::is_subfile_compressed 0 1 438 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated subfile has been compressed when stored</span>
 <span class="s0">* within the archive, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">bool Multifile::is_subfile_compressed(int index) const;</span>

<span class="s0">1120 20 is_subfile_encrypted 0 4 1380 31 Multifile::is_subfile_encrypted 0 1 439 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated subfile has been encrypted when stored within</span>
 <span class="s0">* the archive, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">bool Multifile::is_subfile_encrypted(int index) const;</span>

<span class="s0">1121 15 is_subfile_text 0 4 1380 26 Multifile::is_subfile_text 0 1 440 343</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated subfile represents text data, or false if it</span>
 <span class="s0">* represents binary data.  If the file is text data, it may have been</span>
 <span class="s0">* processed by end-of-line conversion when it was added.  (But the actual</span>
 <span class="s0">* bits in the multifile will represent the standard Unix end-of-line</span>
 <span class="s0">* convention, e.g.  \n instead of \r\n.)</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">bool Multifile::is_subfile_text(int index) const;</span>

<span class="s0">1122 13 get_index_end 0 4 1380 24 Multifile::get_index_end 0 1 441 371</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the first byte that is guaranteed to follow any index byte already</span>
 <span class="s0">* written to disk in the Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* This number is largely meaningless in many cases, but if needs_repack() is</span>
 <span class="s0">* false, and the file is flushed, this will indicate the number of bytes in</span>
 <span class="s0">* the header + index.  Everything at this byte position and later will be</span>
 <span class="s0">* actual data.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">std::streamoff Multifile::get_index_end(void) const;</span>

<span class="s0">1123 26 get_subfile_internal_start 0 4 1380 37 Multifile::get_subfile_internal_start 0 1 442 338</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the starting byte position within the Multifile at which the</span>
 <span class="s0">* indicated subfile begins.  This may be used, with</span>
 <span class="s0">* get_subfile_internal_length(), for low-level access to the subfile, but</span>
 <span class="s0">* usually it is better to use open_read_subfile() instead (which</span>
 <span class="s0">* automatically decrypts and/or uncompresses the subfile data).</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">std::streamoff Multifile::get_subfile_internal_start(int index) const;</span>

<span class="s0">1124 27 get_subfile_internal_length 0 4 1380 38 Multifile::get_subfile_internal_length 0 1 443 322</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of bytes the indicated subfile consumes within the</span>
 <span class="s0">* archive.  For compressed subfiles, this will generally be smaller than</span>
 <span class="s0">* get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be</span>
 <span class="s0">* slightly different, for noncompressed and nonencrypted subfiles, it will be</span>
 <span class="s0">* equal.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">std::size_t Multifile::get_subfile_internal_length(int index) const;</span>

<span class="s0">1125 12 read_subfile 0 4 1380 23 Multifile::read_subfile 0 1 444 253</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a vector_uchar that contains the entire contents of the indicated</span>
 <span class="s0">* subfile.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills a string with the entire contents of the indicated subfile.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills a pvector with the entire contents of the indicated subfile.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline vector_uchar Multifile::read_subfile(int index);</span>

<span class="s0">1126 17 open_read_subfile 0 4 1380 28 Multifile::open_read_subfile 0 1 445 937</span>
<span class="s0">/**</span>
 <span class="s0">* Returns an istream that may be used to read the indicated subfile.  You may</span>
 <span class="s0">* seek() within this istream to your heart's content; even though it will be</span>
 <span class="s0">* a reference to the already-opened pfstream of the Multifile itself, byte 0</span>
 <span class="s0">* appears to be the beginning of the subfile and EOF appears to be the end of</span>
 <span class="s0">* the subfile.</span>
 <span class="s0">*</span>
 <span class="s0">* The returned istream will have been allocated via new; you should pass the</span>
 <span class="s0">* pointer to close_read_subfile() when you are finished with it to delete it</span>
 <span class="s0">* and release its resources.</span>
 <span class="s0">*</span>
 <span class="s0">* Any future calls to repack() or close() (or the Multifile destructor) will</span>
 <span class="s0">* invalidate all currently open subfile pointers.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value will be NULL if the stream cannot be opened for some</span>
 <span class="s0">* reason.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This variant of open_read_subfile() is used internally only, and accepts a</span>
 <span class="s0">* pointer to the internal Subfile object, which is assumed to be valid and</span>
 <span class="s0">* written to the multifile.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">std::istream *Multifile::open_read_subfile(int index);</span>

<span class="s0">1127 18 close_read_subfile 0 4 1380 29 Multifile::close_read_subfile 0 1 446 246</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_subfile().  This</span>
 <span class="s0">* really just deletes the istream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">static void Multifile::close_read_subfile(std::istream *stream);</span>

<span class="s0">1128 15 extract_subfile 0 4 1380 26 Multifile::extract_subfile 0 1 447 68</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts the nth subfile into a file with the given name.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool Multifile::extract_subfile(int index, Filename const &amp;filename);</span>

<span class="s0">1129 18 extract_subfile_to 0 4 1380 29 Multifile::extract_subfile_to 0 1 448 61</span>
<span class="s0">/**</span>
 <span class="s0">* Extracts the nth subfile to the indicated ostream.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool Multifile::extract_subfile_to(int index, std::ostream &amp;out);</span>

<span class="s0">1130 15 compare_subfile 0 4 1380 26 Multifile::compare_subfile 0 1 449 509</span>
<span class="s0">/**</span>
 <span class="s0">* Performs a byte-for-byte comparison of the indicated file on disk with the</span>
 <span class="s0">* nth subfile.  Returns true if the files are equivalent, or false if they</span>
 <span class="s0">* are different (or the file is missing).</span>
 <span class="s0">*</span>
 <span class="s0">* If Filename::set_binary() or set_text() has already been called, it</span>
 <span class="s0">* specifies the nature of the source file.  If this is different from the</span>
 <span class="s0">* text flag of the subfile, the comparison will always return false.  If this</span>
 <span class="s0">* has not been specified, it will be set from the text flag of the subfile.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">bool Multifile::compare_subfile(int index, Filename const &amp;filename);</span>

<span class="s0">1131 6 output 0 4 1380 17 Multifile::output 0 1 450 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">void Multifile::output(std::ostream &amp;out) const;</span>

<span class="s0">1132 2 ls 0 4 1380 13 Multifile::ls 0 1 451 61</span>
<span class="s0">/**</span>
 <span class="s0">* Shows a list of all subfiles within the Multifile.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">void Multifile::ls(std::ostream &amp;out = ::std::cout) const;</span>

<span class="s0">1133 16 get_magic_number 0 4 1380 27 Multifile::get_magic_number 0 1 452 108</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a string with the first n bytes written to a Multifile, to identify</span>
 <span class="s0">* it as a Multifile.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">static inline std::string Multifile::get_magic_number(void);</span>

<span class="s0">1134 17 set_header_prefix 0 4 1380 28 Multifile::set_header_prefix 0 1 453 644</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the string which is written to the Multifile before the Multifile</span>
 <span class="s0">* header.  This string must begin with a hash mark and end with a newline</span>
 <span class="s0">* character; and if it includes embedded newline characters, each one must be</span>
 <span class="s0">* followed by a hash mark.  If these conditions are not initially true, the</span>
 <span class="s0">* string will be modified as necessary to make it so.</span>
 <span class="s0">*</span>
 <span class="s0">* This is primarily useful as a simple hack to allow p3d applications to be</span>
 <span class="s0">* run directly from the command line on Unix-like systems.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if successful, or false on failure (for instance,</span>
 <span class="s0">* because the header prefix violates the above rules).</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">void Multifile::set_header_prefix(std::string const &amp;header_prefix);</span>

<span class="s0">1135 17 get_header_prefix 0 4 1380 28 Multifile::get_header_prefix 0 1 454 113</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the string that preceded the Multifile header on the file, if any.</span>
 <span class="s0">* See set_header_prefix().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline std::string const &amp;Multifile::get_header_prefix(void) const;</span>

<span class="s0">1136 7 Namable 0 260 1383 16 Namable::Namable 0 2 455 456 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">123</span>
<span class="s0">inline explicit Namable::Namable(std::string const &amp;initial_name = &quot;&quot;);</span>
<span class="s0">inline Namable::Namable(Namable const &amp;) = default;</span>

<span class="s0">1137 8 set_name 0 4 1383 17 Namable::set_name 0 1 457 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void Namable::set_name(std::string const &amp;name);</span>

<span class="s0">1138 10 clear_name 0 4 1383 19 Namable::clear_name 0 1 458 46</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the Namable's name to empty.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">inline void Namable::clear_name(void);</span>

<span class="s0">1139 8 has_name 0 4 1383 17 Namable::has_name 0 1 459 94</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the Namable has a nonempty name set, false if the name is</span>
 <span class="s0">* empty.</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline bool Namable::has_name(void) const;</span>

<span class="s0">1140 8 get_name 0 4 1383 17 Namable::get_name 0 1 460 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline std::string const &amp;Namable::get_name(void) const;</span>

<span class="s0">1141 6 output 0 4 1383 15 Namable::output 0 1 461 251</span>
<span class="s0">// In the absence of any definition to the contrary, outputting a Namable</span>
<span class="s0">// will write out its name.</span>

<span class="s0">/**</span>
 <span class="s0">* Outputs the Namable.  This function simply writes the name to the output</span>
 <span class="s0">* stream; most Namable derivatives will probably redefine this.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void Namable::output(std::ostream &amp;out) const;</span>

<span class="s0">1142 14 get_class_type 0 4 1383 23 Namable::get_class_type 0 1 462 0</span>
<span class="s0">48</span>
<span class="s0">static TypeHandle Namable::get_class_type(void);</span>

<span class="s0">1143 8 ~Namable 0 516 1383 17 Namable::~Namable 0 0 0</span>
<span class="s0">24</span>
<span class="s0">Namable::~Namable(void);</span>

<span class="s0">1144 18 clear_certificates 0 4 1385 34 OpenSSLWrapper::clear_certificates 0 1 463 200</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all the certificates from the global store, including the compiled-</span>
 <span class="s0">* in certificates loaded from ca_bundle_data.c.  You can add new certificates</span>
 <span class="s0">* by calling load_certificates().</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">void OpenSSLWrapper::clear_certificates(void);</span>

<span class="s0">1145 17 load_certificates 0 4 1385 33 OpenSSLWrapper::load_certificates 0 1 464 436</span>
<span class="s0">/**</span>
 <span class="s0">* Reads the PEM-formatted certificate(s) (delimited by -----BEGIN</span>
 <span class="s0">* CERTIFICATE----- and -----END CERTIFICATE-----) from the indicated file and</span>
 <span class="s0">* adds them to the global store object, retrieved via get_x509_store().</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the number of certificates read on success, or 0 on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">int OpenSSLWrapper::load_certificates(Filename const &amp;filename);</span>

<span class="s0">1146 30 load_certificates_from_pem_ram 0 4 1385 46 OpenSSLWrapper::load_certificates_from_pem_ram 0 2 465 466 754</span>
<span class="s0">/**</span>
 <span class="s0">* Reads a chain of trusted certificates from the indicated data buffer and</span>
 <span class="s0">* adds them to the X509_STORE object.  The data buffer should be PEM-</span>
 <span class="s0">* formatted.  Returns the number of certificates read on success, or 0 on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads a chain of trusted certificates from the indicated data buffer and</span>
 <span class="s0">* adds them to the X509_STORE object.  The data buffer should be PEM-</span>
 <span class="s0">* formatted.  Returns the number of certificates read on success, or 0 on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/</span>
<span class="s0">176</span>
<span class="s0">int OpenSSLWrapper::load_certificates_from_pem_ram(char const *data, std::size_t data_size);</span>
<span class="s0">inline int OpenSSLWrapper::load_certificates_from_pem_ram(std::string const &amp;data);</span>

<span class="s0">1147 30 load_certificates_from_der_ram 0 4 1385 46 OpenSSLWrapper::load_certificates_from_der_ram 0 2 467 468 754</span>
<span class="s0">/**</span>
 <span class="s0">* Reads a chain of trusted certificates from the indicated data buffer and</span>
 <span class="s0">* adds them to the X509_STORE object.  The data buffer should be DER-</span>
 <span class="s0">* formatted.  Returns the number of certificates read on success, or 0 on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Reads a chain of trusted certificates from the indicated data buffer and</span>
 <span class="s0">* adds them to the X509_STORE object.  The data buffer should be DER-</span>
 <span class="s0">* formatted.  Returns the number of certificates read on success, or 0 on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/</span>
<span class="s0">176</span>
<span class="s0">int OpenSSLWrapper::load_certificates_from_der_ram(char const *data, std::size_t data_size);</span>
<span class="s0">inline int OpenSSLWrapper::load_certificates_from_der_ram(std::string const &amp;data);</span>

<span class="s0">1148 14 get_x509_store 0 4 1385 30 OpenSSLWrapper::get_x509_store 0 1 469 378</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the global X509_STORE object.</span>
 <span class="s0">*</span>
 <span class="s0">* It has to be a global object, because OpenSSL seems to store some global</span>
 <span class="s0">* pointers associated with this object whether you want it to or not, and</span>
 <span class="s0">* keeping independent copies of a local X509_STORE object doesn't seem to</span>
 <span class="s0">* work that well.  So, we have one store that keeps all certificates the</span>
 <span class="s0">* application might need.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">X509_STORE *OpenSSLWrapper::get_x509_store(void);</span>

<span class="s0">1149 17 notify_ssl_errors 0 4 1385 33 OpenSSLWrapper::notify_ssl_errors 0 1 470 277</span>
<span class="s0">/**</span>
 <span class="s0">* A convenience function that is itself a wrapper around the OpenSSL</span>
 <span class="s0">* convenience function to output the recent OpenSSL errors.  This function</span>
 <span class="s0">* sends the error string to express_cat.warning().  If REPORT_OPENSSL_ERRORS</span>
 <span class="s0">* is not defined, the function does nothing.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">void OpenSSLWrapper::notify_ssl_errors(void);</span>

<span class="s0">1150 23 notify_debug_ssl_errors 0 4 1385 39 OpenSSLWrapper::notify_debug_ssl_errors 0 1 471 84</span>
<span class="s0">/**</span>
 <span class="s0">* As notify_ssl_errors(), but sends the output to debug instead of warning.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void OpenSSLWrapper::notify_debug_ssl_errors(void);</span>

<span class="s0">1151 14 get_global_ptr 0 4 1385 30 OpenSSLWrapper::get_global_ptr 0 1 472 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">static OpenSSLWrapper *OpenSSLWrapper::get_global_ptr(void);</span>

<span class="s0">1152 11 SubfileInfo 0 260 1386 24 SubfileInfo::SubfileInfo 0 4 473 474 475 476 46</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">321</span>
<span class="s0">inline SubfileInfo::SubfileInfo(void);</span>
<span class="s0">inline explicit SubfileInfo::SubfileInfo(FileReference const *file, std::streamoff start, std::streamsize size);</span>
<span class="s0">inline explicit SubfileInfo::SubfileInfo(Filename const &amp;filename, std::streamoff start, std::streamsize size);</span>
<span class="s0">inline SubfileInfo::SubfileInfo(SubfileInfo const &amp;copy);</span>

<span class="s0">1153 10 operator = 0 4 1386 23 SubfileInfo::operator = 0 1 477 0</span>
<span class="s0">61</span>
<span class="s0">inline void SubfileInfo::operator =(SubfileInfo const &amp;copy);</span>

<span class="s0">1154 8 is_empty 0 4 1386 21 SubfileInfo::is_empty 0 1 478 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this SubfileInfo doesn't define any file, false if it has</span>
 <span class="s0">* real data.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool SubfileInfo::is_empty(void) const;</span>

<span class="s0">1155 8 get_file 0 4 1386 21 SubfileInfo::get_file 0 1 479 63</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the FileReference that represents this file.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline FileReference const *SubfileInfo::get_file(void) const;</span>

<span class="s0">1156 12 get_filename 0 4 1386 25 SubfileInfo::get_filename 0 1 480 38</span>
<span class="s0">/**</span>
 <span class="s0">* A shortcut to the filename.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline Filename const &amp;SubfileInfo::get_filename(void) const;</span>

<span class="s0">1157 9 get_start 0 4 1386 22 SubfileInfo::get_start 0 1 481 77</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the offset within the file at which this file data begins.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline std::streamoff SubfileInfo::get_start(void) const;</span>

<span class="s0">1158 8 get_size 0 4 1386 21 SubfileInfo::get_size 0 1 482 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of consecutive bytes, beginning at get_start(), that</span>
 <span class="s0">* correspond to this file data.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline std::streamsize SubfileInfo::get_size(void) const;</span>

<span class="s0">1159 6 output 0 4 1386 19 SubfileInfo::output 0 1 483 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void SubfileInfo::output(std::ostream &amp;out) const;</span>

<span class="s0">1160 12 ~SubfileInfo 0 516 1386 25 SubfileInfo::~SubfileInfo 0 0 0</span>
<span class="s0">32</span>
<span class="s0">SubfileInfo::~SubfileInfo(void);</span>

<span class="s0">1161 15 get_file_system 0 6 1387 28 VirtualFile::get_file_system 0 1 484 0</span>
<span class="s0">72</span>
<span class="s0">virtual VirtualFileSystem *VirtualFile::get_file_system(void) const = 0;</span>

<span class="s0">1162 12 get_filename 0 6 1387 25 VirtualFile::get_filename 0 1 485 0</span>
<span class="s0">59</span>
<span class="s0">virtual Filename VirtualFile::get_filename(void) const = 0;</span>

<span class="s0">1163 21 get_original_filename 0 4 1387 34 VirtualFile::get_original_filename 0 1 486 166</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the original filename as it was used to locate this VirtualFile.</span>
 <span class="s0">* This is usually, but not always, the same string returned by</span>
 <span class="s0">* get_filename().</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline Filename const &amp;VirtualFile::get_original_filename(void) const;</span>

<span class="s0">1164 8 has_file 0 6 1387 21 VirtualFile::has_file 0 1 487 61</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this file exists, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">virtual bool VirtualFile::has_file(void) const;</span>

<span class="s0">1165 12 is_directory 0 6 1387 25 VirtualFile::is_directory 0 1 488 117</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this file represents a directory (and scan_directory() may</span>
 <span class="s0">* be called), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">virtual bool VirtualFile::is_directory(void) const;</span>

<span class="s0">1166 15 is_regular_file 0 6 1387 28 VirtualFile::is_regular_file 0 1 489 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this file represents a regular file (and read_file() may be</span>
 <span class="s0">* called), false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">virtual bool VirtualFile::is_regular_file(void) const;</span>

<span class="s0">1167 11 is_writable 0 6 1387 24 VirtualFile::is_writable 0 1 490 153</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this file may be written to, which implies write_file() may</span>
 <span class="s0">* be called (unless it is a directory instead of a regular file).</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">virtual bool VirtualFile::is_writable(void) const;</span>

<span class="s0">1168 11 delete_file 0 6 1387 24 VirtualFile::delete_file 0 1 491 199</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to delete this file or directory.  This can remove a single file</span>
 <span class="s0">* or an empty directory.  It will not remove a nonempty directory.  Returns</span>
 <span class="s0">* true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual bool VirtualFile::delete_file(void);</span>

<span class="s0">1169 11 rename_file 0 6 1387 24 VirtualFile::rename_file 0 1 492 589</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to move or rename this file or directory.  If the original file is</span>
 <span class="s0">* an ordinary file, it will quietly replace any already-existing file in the</span>
 <span class="s0">* new filename (but not a directory).  If the original file is a directory,</span>
 <span class="s0">* the new filename must not already exist.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is a directory, the new filename must be within the same mount</span>
 <span class="s0">* point.  If the file is an ordinary file, the new filename may be anywhere;</span>
 <span class="s0">* but if it is not within the same mount point then the rename operation is</span>
 <span class="s0">* automatically performed as a two-step copy-and-delete operation.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual bool VirtualFile::rename_file(VirtualFile *new_file);</span>

<span class="s0">1170 9 copy_file 0 6 1387 22 VirtualFile::copy_file 0 1 493 123</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to copy the contents of this file to the indicated file.  Returns</span>
 <span class="s0">* true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">virtual bool VirtualFile::copy_file(VirtualFile *new_file);</span>

<span class="s0">1171 14 scan_directory 0 4 1387 27 VirtualFile::scan_directory 0 1 494 247</span>
<span class="s0">/**</span>
 <span class="s0">* If the file represents a directory (that is, is_directory() returns true),</span>
 <span class="s0">* this returns the list of files within the directory at the current time.</span>
 <span class="s0">* Returns NULL if the file is not a directory or if the directory cannot be</span>
 <span class="s0">* read.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">PointerTo&lt; VirtualFileList &gt; VirtualFile::scan_directory(void) const;</span>

<span class="s0">1172 6 output 0 4 1387 19 VirtualFile::output 0 1 495 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">void VirtualFile::output(std::ostream &amp;out) const;</span>

<span class="s0">1173 2 ls 0 4 1387 15 VirtualFile::ls 0 1 496 66</span>
<span class="s0">/**</span>
 <span class="s0">* If the file represents a directory, lists its contents.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">void VirtualFile::ls(std::ostream &amp;out = ::std::cout) const;</span>

<span class="s0">1174 6 ls_all 0 4 1387 19 VirtualFile::ls_all 0 1 497 113</span>
<span class="s0">/**</span>
 <span class="s0">* If the file represents a directory, recursively lists its contents and</span>
 <span class="s0">* those of all subdirectories.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">void VirtualFile::ls_all(std::ostream &amp;out = ::std::cout) const;</span>

<span class="s0">1175 9 read_file 0 4 1387 22 VirtualFile::read_file 0 1 498 352</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the entire contents of the file as a string.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills up the indicated string with the contents of the file, if it is a</span>
 <span class="s0">* regular file.  Returns true on success, false otherwise.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Fills up the indicated pvector with the contents of the file, if it is a</span>
 <span class="s0">* regular file.  Returns true on success, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">PyObject *VirtualFile::read_file(bool auto_unwrap) const;</span>

<span class="s0">1176 14 open_read_file 0 6 1387 27 VirtualFile::open_read_file 0 1 499 179</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the file for reading.  Returns a newly allocated istream on success</span>
 <span class="s0">* (which you should eventually delete when you are done reading). Returns</span>
 <span class="s0">* NULL on failure.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">virtual std::istream *VirtualFile::open_read_file(bool auto_unwrap) const;</span>

<span class="s0">1177 15 close_read_file 0 6 1387 28 VirtualFile::close_read_file 0 1 500 243</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_file().  This really</span>
 <span class="s0">* just deletes the istream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">virtual void VirtualFile::close_read_file(std::istream *stream) const;</span>

<span class="s0">1178 19 was_read_successful 0 6 1387 32 VirtualFile::was_read_successful 0 1 501 324</span>
<span class="s0">/**</span>
 <span class="s0">* Call this method after a reading the istream returned by open_read_file()</span>
 <span class="s0">* to completion.  If it returns true, the file was read completely and</span>
 <span class="s0">* without error; if it returns false, there may have been some errors or a</span>
 <span class="s0">* truncated file read.  This is particularly likely if the stream is a</span>
 <span class="s0">* VirtualFileHTTP.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual bool VirtualFile::was_read_successful(void) const;</span>

<span class="s0">1179 10 write_file 0 4 1387 23 VirtualFile::write_file 0 1 502 197</span>
<span class="s0">/**</span>
 <span class="s0">* Writes the entire contents of the file as a string, if it is writable.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Writes the indicated data to the file, if it is writable.  Returns true on</span>
 <span class="s0">* success, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">PyObject *VirtualFile::write_file(PyObject *data, bool auto_wrap);</span>

<span class="s0">1180 15 open_write_file 0 6 1387 28 VirtualFile::open_write_file 0 1 503 179</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the file for writing.  Returns a newly allocated ostream on success</span>
 <span class="s0">* (which you should eventually delete when you are done writing). Returns</span>
 <span class="s0">* NULL on failure.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">virtual std::ostream *VirtualFile::open_write_file(bool auto_wrap, bool truncate);</span>

<span class="s0">1181 16 open_append_file 0 6 1387 29 VirtualFile::open_append_file 0 1 504 180</span>
<span class="s0">/**</span>
 <span class="s0">* Works like open_write_file(), but the file is opened in append mode.  Like</span>
 <span class="s0">* open_write_file, the returned pointer should eventually be passed to</span>
 <span class="s0">* close_write_file().</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">virtual std::ostream *VirtualFile::open_append_file(void);</span>

<span class="s0">1182 16 close_write_file 0 6 1387 29 VirtualFile::close_write_file 0 1 505 244</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a file opened by a previous call to open_write_file().  This really</span>
 <span class="s0">* just deletes the ostream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">virtual void VirtualFile::close_write_file(std::ostream *stream);</span>

<span class="s0">1183 20 open_read_write_file 0 6 1387 33 VirtualFile::open_read_write_file 0 1 506 180</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the file for writing.  Returns a newly allocated iostream on success</span>
 <span class="s0">* (which you should eventually delete when you are done writing). Returns</span>
 <span class="s0">* NULL on failure.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">virtual std::iostream *VirtualFile::open_read_write_file(bool truncate);</span>

<span class="s0">1184 21 open_read_append_file 0 6 1387 34 VirtualFile::open_read_append_file 0 1 507 194</span>
<span class="s0">/**</span>
 <span class="s0">* Works like open_read_write_file(), but the file is opened in append mode.</span>
 <span class="s0">* Like open_read_write_file, the returned pointer should eventually be passed</span>
 <span class="s0">* to close_read_write_file().</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">virtual std::iostream *VirtualFile::open_read_append_file(void);</span>

<span class="s0">1185 21 close_read_write_file 0 6 1387 34 VirtualFile::close_read_write_file 0 1 508 250</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_write_file().  This</span>
 <span class="s0">* really just deletes the iostream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">virtual void VirtualFile::close_read_write_file(std::iostream *stream);</span>

<span class="s0">1186 13 get_file_size 0 6 1387 26 VirtualFile::get_file_size 0 2 509 510 329</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current size on disk (or wherever it is) of the already-open</span>
 <span class="s0">* file.  Pass in the stream that was returned by open_read_file(); some</span>
 <span class="s0">* implementations may require this stream to determine the size.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the current size on disk (or wherever it is) of the file before it</span>
 <span class="s0">* has been opened.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">virtual std::streamsize VirtualFile::get_file_size(std::istream *stream) const;</span>
<span class="s0">virtual std::streamsize VirtualFile::get_file_size(void) const;</span>

<span class="s0">1187 13 get_timestamp 0 6 1387 26 VirtualFile::get_timestamp 0 1 511 434</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a time_t value that represents the time the file was last modified,</span>
 <span class="s0">* to within whatever precision the operating system records this information</span>
 <span class="s0">* (on a Windows95 system, for instance, this may only be accurate to within 2</span>
 <span class="s0">* seconds).</span>
 <span class="s0">*</span>
 <span class="s0">* If the timestamp cannot be determined, either because it is not supported</span>
 <span class="s0">* by the operating system or because there is some error (such as file not</span>
 <span class="s0">* found), returns 0.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">virtual time_t VirtualFile::get_timestamp(void) const;</span>

<span class="s0">1188 15 get_system_info 0 6 1387 28 VirtualFile::get_system_info 0 1 512 330</span>
<span class="s0">/**</span>
 <span class="s0">* Populates the SubfileInfo structure with the data representing where the</span>
 <span class="s0">* file actually resides on disk, if this is knowable.  Returns true if the</span>
 <span class="s0">* file might reside on disk, and the info is populated, or false if it does</span>
 <span class="s0">* not (or it is not known where the file resides), in which case the info is</span>
 <span class="s0">* meaningless.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">virtual bool VirtualFile::get_system_info(SubfileInfo &amp;info);</span>

<span class="s0">1189 14 get_class_type 0 4 1387 27 VirtualFile::get_class_type 0 1 513 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle VirtualFile::get_class_type(void);</span>

<span class="s0">1190 12 ~VirtualFile 0 516 1387 25 VirtualFile::~VirtualFile 0 0 0</span>
<span class="s0">32</span>
<span class="s0">VirtualFile::~VirtualFile(void);</span>

<span class="s0">1191 14 get_class_type 0 4 1388 36 VirtualFileComposite::get_class_type 0 1 514 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle VirtualFileComposite::get_class_type(void);</span>

<span class="s0">1192 21 ~VirtualFileComposite 0 516 1388 43 VirtualFileComposite::~VirtualFileComposite 0 0 0</span>
<span class="s0">50</span>
<span class="s0">VirtualFileComposite::~VirtualFileComposite(void);</span>

<span class="s0">1193 15 get_file_system 0 4 1389 33 VirtualFileMount::get_file_system 0 1 515 68</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the file system this mount object is attached to.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline VirtualFileSystem *VirtualFileMount::get_file_system(void) const;</span>

<span class="s0">1194 15 get_mount_point 0 4 1389 33 VirtualFileMount::get_mount_point 0 1 516 161</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the directory within the virtual file system that this</span>
 <span class="s0">* mount object is attached to.  This directory name will end with a slash.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline Filename const &amp;VirtualFileMount::get_mount_point(void) const;</span>

<span class="s0">1195 15 get_mount_flags 0 4 1389 33 VirtualFileMount::get_mount_flags 0 1 517 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the set of flags passed by the user to the</span>
 <span class="s0">* VirtualFileSystem::mount() command.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int VirtualFileMount::get_mount_flags(void) const;</span>

<span class="s0">1196 6 output 0 6 1389 24 VirtualFileMount::output 0 1 518 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">virtual void VirtualFileMount::output(std::ostream &amp;out) const;</span>

<span class="s0">1197 5 write 0 6 1389 23 VirtualFileMount::write 0 1 519 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">virtual void VirtualFileMount::write(std::ostream &amp;out) const;</span>

<span class="s0">1198 14 get_class_type 0 4 1389 32 VirtualFileMount::get_class_type 0 1 520 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle VirtualFileMount::get_class_type(void);</span>

<span class="s0">1199 25 VirtualFileMountMultifile 0 260 1390 52 VirtualFileMountMultifile::VirtualFileMountMultifile 0 1 521 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile);</span>

<span class="s0">1200 13 get_multifile 0 4 1390 40 VirtualFileMountMultifile::get_multifile 0 1 522 76</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the Multifile pointer that this mount object is based on.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline Multifile *VirtualFileMountMultifile::get_multifile(void) const;</span>

<span class="s0">1201 14 get_class_type 0 4 1390 41 VirtualFileMountMultifile::get_class_type 0 1 523 0</span>
<span class="s0">66</span>
<span class="s0">static TypeHandle VirtualFileMountMultifile::get_class_type(void);</span>

<span class="s0">1202 23 VirtualFileMountRamdisk 0 260 1391 48 VirtualFileMountRamdisk::VirtualFileMountRamdisk 0 1 524 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">VirtualFileMountRamdisk::VirtualFileMountRamdisk(void);</span>

<span class="s0">1203 14 get_class_type 0 4 1391 39 VirtualFileMountRamdisk::get_class_type 0 1 525 0</span>
<span class="s0">64</span>
<span class="s0">static TypeHandle VirtualFileMountRamdisk::get_class_type(void);</span>

<span class="s0">1204 24 ~VirtualFileMountRamdisk 0 516 1391 49 VirtualFileMountRamdisk::~VirtualFileMountRamdisk 0 0 0</span>
<span class="s0">56</span>
<span class="s0">VirtualFileMountRamdisk::~VirtualFileMountRamdisk(void);</span>

<span class="s0">1205 22 VirtualFileMountSystem 0 260 1392 46 VirtualFileMountSystem::VirtualFileMountSystem 0 1 526 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &amp;physical_filename);</span>

<span class="s0">1206 21 get_physical_filename 0 4 1392 45 VirtualFileMountSystem::get_physical_filename 0 1 527 112</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the name of the source file on the OS filesystem of the directory</span>
 <span class="s0">* or file that is mounted.</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">inline Filename const &amp;VirtualFileMountSystem::get_physical_filename(void) const;</span>

<span class="s0">1207 14 get_class_type 0 4 1392 38 VirtualFileMountSystem::get_class_type 0 1 528 0</span>
<span class="s0">63</span>
<span class="s0">static TypeHandle VirtualFileMountSystem::get_class_type(void);</span>

<span class="s0">1208 23 ~VirtualFileMountSystem 0 516 1392 47 VirtualFileMountSystem::~VirtualFileMountSystem 0 0 0</span>
<span class="s0">54</span>
<span class="s0">VirtualFileMountSystem::~VirtualFileMountSystem(void);</span>

<span class="s0">1209 9 get_mount 0 4 1393 28 VirtualFileSimple::get_mount 0 1 529 69</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the VirtualFileMount this file is associated with.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline VirtualFileMount *VirtualFileSimple::get_mount(void) const;</span>

<span class="s0">1210 19 is_implicit_pz_file 0 4 1393 38 VirtualFileSimple::is_implicit_pz_file 0 1 530 174</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this file is a .pz file that should be implicitly</span>
 <span class="s0">* decompressed on load, or false if it is not a .pz file or if it should not</span>
 <span class="s0">* be decompressed.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline bool VirtualFileSimple::is_implicit_pz_file(void) const;</span>

<span class="s0">1211 14 get_class_type 0 4 1393 33 VirtualFileSimple::get_class_type 0 1 531 0</span>
<span class="s0">58</span>
<span class="s0">static TypeHandle VirtualFileSimple::get_class_type(void);</span>

<span class="s0">1212 18 ~VirtualFileSimple 0 516 1393 37 VirtualFileSimple::~VirtualFileSimple 0 0 0</span>
<span class="s0">44</span>
<span class="s0">VirtualFileSimple::~VirtualFileSimple(void);</span>

<span class="s0">1213 13 TemporaryFile 0 260 1394 28 TemporaryFile::TemporaryFile 0 2 532 533 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">141</span>
<span class="s0">inline explicit TemporaryFile::TemporaryFile(Filename const &amp;filename);</span>
<span class="s0">inline TemporaryFile::TemporaryFile(TemporaryFile const &amp;) = default;</span>

<span class="s0">1214 14 get_class_type 0 4 1394 29 TemporaryFile::get_class_type 0 1 534 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle TemporaryFile::get_class_type(void);</span>

<span class="s0">1215 17 IDecompressStream 0 260 1395 36 IDecompressStream::IDecompressStream 0 2 535 536 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">144</span>
<span class="s0">inline IDecompressStream::IDecompressStream(void);</span>
<span class="s0">inline explicit IDecompressStream::IDecompressStream(std::istream *source, bool owns_source);</span>

<span class="s0">1216 4 open 0 4 1395 23 IDecompressStream::open 0 1 537 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">90</span>
<span class="s0">inline IDecompressStream &amp;IDecompressStream::open(std::istream *source, bool owns_source);</span>

<span class="s0">1217 5 close 0 4 1395 24 IDecompressStream::close 0 1 538 118</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the ZStream to empty, but does not actually close the source istream</span>
 <span class="s0">* unless owns_source was true.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline IDecompressStream &amp;IDecompressStream::close(void);</span>

<span class="s0">1218 18 ~IDecompressStream 0 516 1395 37 IDecompressStream::~IDecompressStream 0 0 0</span>
<span class="s0">44</span>
<span class="s0">IDecompressStream::~IDecompressStream(void);</span>

<span class="s0">1219 15 OCompressStream 0 260 1396 32 OCompressStream::OCompressStream 0 2 539 540 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">159</span>
<span class="s0">inline OCompressStream::OCompressStream(void);</span>
<span class="s0">inline explicit OCompressStream::OCompressStream(std::ostream *dest, bool owns_dest, int compression_level = 6);</span>

<span class="s0">1220 4 open 0 4 1396 21 OCompressStream::open 0 1 541 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">109</span>
<span class="s0">inline OCompressStream &amp;OCompressStream::open(std::ostream *dest, bool owns_dest, int compression_level = 6);</span>

<span class="s0">1221 5 close 0 4 1396 22 OCompressStream::close 0 1 542 114</span>
<span class="s0">/**</span>
 <span class="s0">* Resets the ZStream to empty, but does not actually close the dest ostream</span>
 <span class="s0">* unless owns_dest was true.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline OCompressStream &amp;OCompressStream::close(void);</span>

<span class="s0">1222 16 ~OCompressStream 0 516 1396 33 OCompressStream::~OCompressStream 0 0 0</span>
<span class="s0">40</span>
<span class="s0">OCompressStream::~OCompressStream(void);</span>

<span class="s0">1223 13 get_num_files 0 4 1397 30 VirtualFileList::get_num_files 0 1 544 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of files in the list.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline std::size_t VirtualFileList::get_num_files(void) const;</span>

<span class="s0">1224 8 get_file 0 4 1397 25 VirtualFileList::get_file 0 1 545 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth file in the list.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline VirtualFile *VirtualFileList::get_file(std::size_t n) const;</span>

<span class="s0">1225 11 operator [] 0 4 1397 28 VirtualFileList::operator [] 0 1 546 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth file in the list.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline VirtualFile *VirtualFileList::operator [](std::size_t n) const;</span>

<span class="s0">1226 4 size 0 4 1397 21 VirtualFileList::size 0 1 547 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of files in the list.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline std::size_t VirtualFileList::size(void) const;</span>

<span class="s0">1227 11 operator += 0 4 1397 28 VirtualFileList::operator += 0 1 548 0</span>
<span class="s0">71</span>
<span class="s0">inline void VirtualFileList::operator +=(VirtualFileList const &amp;other);</span>

<span class="s0">1228 10 operator + 0 4 1397 27 VirtualFileList::operator + 0 1 549 0</span>
<span class="s0">87</span>
<span class="s0">inline VirtualFileList VirtualFileList::operator +(VirtualFileList const &amp;other) const;</span>

<span class="s0">1229 15 VirtualFileList 0 260 1397 32 VirtualFileList::VirtualFileList 0 1 543 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline VirtualFileList::VirtualFileList(VirtualFileList const &amp;) = default;</span>

<span class="s0">1230 17 VirtualFileSystem 0 260 1398 36 VirtualFileSystem::VirtualFileSystem 0 1 550 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">VirtualFileSystem::VirtualFileSystem(void);</span>

<span class="s0">1231 18 ~VirtualFileSystem 0 516 1398 37 VirtualFileSystem::~VirtualFileSystem 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">VirtualFileSystem::~VirtualFileSystem(void);</span>

<span class="s0">1232 5 mount 0 4 1398 24 VirtualFileSystem::mount 0 3 551 552 553 1288</span>
<span class="s0">/**</span>
 <span class="s0">* Mounts the indicated Multifile at the given mount point.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Mounts the indicated system file or directory at the given mount point.  If</span>
 <span class="s0">* the named file is a directory, mounts the directory.  If the named file is</span>
 <span class="s0">* a Multifile, mounts it as a Multifile.  Returns true on success, false on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* A given system directory may be mounted to multiple different mount point,</span>
 <span class="s0">* and the same mount point may share multiple system directories.  In the</span>
 <span class="s0">* case of ambiguities (that is, two different files with exactly the same</span>
 <span class="s0">* full pathname), the most-recently mounted system wins.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename specified as the first parameter must refer to a real,</span>
 <span class="s0">* physical filename on disk; it cannot be a virtual file already appearing</span>
 <span class="s0">* within the vfs filespace.  However, it is possible to mount such a file;</span>
 <span class="s0">* see mount_loop() for this.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that a mounted VirtualFileSystem directory is fully case-sensitive,</span>
 <span class="s0">* unlike the native Windows file system, so you must refer to files within</span>
 <span class="s0">* the virtual file system with exactly the right case.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds the given VirtualFileMount object to the mount list.  This is a lower-</span>
 <span class="s0">* level function than the other flavors of mount(); it requires you to create</span>
 <span class="s0">* a VirtualFileMount object specifically.</span>
 <span class="s0">*/</span>
<span class="s0">328</span>
<span class="s0">bool VirtualFileSystem::mount(Multifile *multifile, Filename const &amp;mount_point, int flags);</span>
<span class="s0">bool VirtualFileSystem::mount(Filename const &amp;physical_filename, Filename const &amp;mount_point, int flags, std::string const &amp;password = &quot;&quot;);</span>
<span class="s0">bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &amp;mount_point, int flags);</span>

<span class="s0">1233 10 mount_loop 0 4 1398 29 VirtualFileSystem::mount_loop 0 1 554 587</span>
<span class="s0">/**</span>
 <span class="s0">* This is similar to mount(), but it receives the name of a Multifile that</span>
 <span class="s0">* already appears within the virtual file system.  It can be used to mount a</span>
 <span class="s0">* Multifile that is itself hosted within a virtually-mounted Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* This interface can also be used to mount physical files (that appear within</span>
 <span class="s0">* the virtual filespace), but it cannot be used to mount directories.  Use</span>
 <span class="s0">* mount() if you need to mount a directory.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that there is additional overhead, in the form of additional buffer</span>
 <span class="s0">* copies of the data, for recursively mounting a multifile like this.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">bool VirtualFileSystem::mount_loop(Filename const &amp;virtual_filename, Filename const &amp;mount_point, int flags, std::string const &amp;password = &quot;&quot;);</span>

<span class="s0">1234 7 unmount 0 4 1398 26 VirtualFileSystem::unmount 0 3 555 556 557 419</span>
<span class="s0">/**</span>
 <span class="s0">* Unmounts all appearances of the indicated Multifile from the file system.</span>
 <span class="s0">* Returns the number of appearances unmounted.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unmounts all appearances of the indicated directory name or multifile name</span>
 <span class="s0">* from the file system.  Returns the number of appearances unmounted.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Unmounts the indicated VirtualFileMount object from the file system.</span>
 <span class="s0">* Returns the number of appearances unmounted.</span>
 <span class="s0">*/</span>
<span class="s0">177</span>
<span class="s0">int VirtualFileSystem::unmount(Multifile *multifile);</span>
<span class="s0">int VirtualFileSystem::unmount(Filename const &amp;physical_filename);</span>
<span class="s0">int VirtualFileSystem::unmount(VirtualFileMount *mount);</span>

<span class="s0">1235 13 unmount_point 0 4 1398 32 VirtualFileSystem::unmount_point 0 1 558 136</span>
<span class="s0">/**</span>
 <span class="s0">* Unmounts all systems attached to the given mount point from the file</span>
 <span class="s0">* system.  Returns the number of appearances unmounted.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">int VirtualFileSystem::unmount_point(Filename const &amp;mount_point);</span>

<span class="s0">1236 11 unmount_all 0 4 1398 30 VirtualFileSystem::unmount_all 0 1 559 96</span>
<span class="s0">/**</span>
 <span class="s0">* Unmounts all files from the file system.  Returns the number of systems</span>
 <span class="s0">* unmounted.</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">int VirtualFileSystem::unmount_all(void);</span>

<span class="s0">1237 14 get_num_mounts 0 4 1398 33 VirtualFileSystem::get_num_mounts 0 1 560 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of individual mounts in the system.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">int VirtualFileSystem::get_num_mounts(void) const;</span>

<span class="s0">1238 9 get_mount 0 4 1398 28 VirtualFileSystem::get_mount 0 1 561 47</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the nth mount in the system.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">PointerTo&lt; VirtualFileMount &gt; VirtualFileSystem::get_mount(int n) const;</span>

<span class="s0">1239 5 clear 0 4 1401 40 PointerToBase&lt; VirtualFileMount &gt;::clear 0 1 601 0</span>
<span class="s0">59</span>
<span class="s0">inline void PointerToBase&lt; VirtualFileMount &gt;::clear(void);</span>

<span class="s0">1240 6 output 0 4 1401 41 PointerToBase&lt; VirtualFileMount &gt;::output 0 1 602 0</span>
<span class="s0">72</span>
<span class="s0">void PointerToBase&lt; VirtualFileMount &gt;::output(std::ostream &amp;out) const;</span>

<span class="s0">1241 9 PointerTo 0 260 1400 40 PointerTo&lt; VirtualFileMount &gt;::PointerTo 0 4 592 593 594 595 0</span>
<span class="s0">353</span>
<span class="s0">inline constexpr PointerTo&lt; VirtualFileMount &gt;::PointerTo(void) noexcept = default;</span>
<span class="s0">inline explicit constexpr PointerTo&lt; VirtualFileMount &gt;::PointerTo(decltype(nullptr) ) noexcept;</span>
<span class="s0">inline PointerTo&lt; VirtualFileMount &gt;::PointerTo(VirtualFileMount *ptr) noexcept;</span>
<span class="s0">inline PointerTo&lt; VirtualFileMount &gt;::PointerTo(PointerTo&lt; VirtualFileMount &gt; const &amp;copy);</span>

<span class="s0">1242 1 p 0 4 1400 32 PointerTo&lt; VirtualFileMount &gt;::p 0 1 596 289</span>
<span class="s0">// If your base class is a derivative of TypedObject, you might want to use</span>
<span class="s0">// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,</span>
<span class="s0">// ptr).  This provides a clean downcast that doesn't require .p() or any</span>
<span class="s0">// double-casting, and it can be run-time checked for correctness.</span>
<span class="s0">82</span>
<span class="s0">constexpr VirtualFileMount *PointerTo&lt; VirtualFileMount &gt;::p(void) const noexcept;</span>

<span class="s0">1243 10 operator = 0 4 1400 41 PointerTo&lt; VirtualFileMount &gt;::operator = 0 2 597 598 0</span>
<span class="s0">175</span>
<span class="s0">inline void PointerTo&lt; VirtualFileMount &gt;::operator =(VirtualFileMount *ptr);</span>
<span class="s0">inline void PointerTo&lt; VirtualFileMount &gt;::operator =(PointerTo&lt; VirtualFileMount &gt; const &amp;copy);</span>

<span class="s0">1244 7 is_null 0 4 1400 38 PointerTo&lt; VirtualFileMount &gt;::is_null 0 1 599 0</span>
<span class="s0">63</span>
<span class="s0">inline bool PointerTo&lt; VirtualFileMount &gt;::is_null(void) const;</span>

<span class="s0">1245 5 clear 0 4 1400 36 PointerTo&lt; VirtualFileMount &gt;::clear 0 1 600 0</span>
<span class="s0">55</span>
<span class="s0">inline void PointerTo&lt; VirtualFileMount &gt;::clear(void);</span>

<span class="s0">1246 10 ~PointerTo 0 516 1400 41 PointerTo&lt; VirtualFileMount &gt;::~PointerTo 0 0 0</span>
<span class="s0">48</span>
<span class="s0">PointerTo&lt; VirtualFileMount &gt;::~PointerTo(void);</span>

<span class="s0">1247 5 chdir 0 4 1398 24 VirtualFileSystem::chdir 0 1 562 171</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the current directory.  This is used to resolve relative pathnames</span>
 <span class="s0">* in get_file() and/or find_file().  Returns true if successful, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">bool VirtualFileSystem::chdir(Filename const &amp;new_directory);</span>

<span class="s0">1248 7 get_cwd 0 4 1398 26 VirtualFileSystem::get_cwd 0 1 563 60</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the current directory name.  See chdir().</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">Filename VirtualFileSystem::get_cwd(void) const;</span>

<span class="s0">1249 14 make_directory 0 4 1398 33 VirtualFileSystem::make_directory 0 1 564 263</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to create a directory within the file system.  Returns true on</span>
 <span class="s0">* success, false on failure (for instance, because the parent directory does</span>
 <span class="s0">* not exist, or is read-only).  If the directory already existed prior to</span>
 <span class="s0">* this call, returns true.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">bool VirtualFileSystem::make_directory(Filename const &amp;filename);</span>

<span class="s0">1250 19 make_directory_full 0 4 1398 38 VirtualFileSystem::make_directory_full 0 1 565 169</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to create a directory within the file system.  Will also create</span>
 <span class="s0">* any intervening directories needed.  Returns true on success, false on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">bool VirtualFileSystem::make_directory_full(Filename const &amp;filename);</span>

<span class="s0">1251 8 get_file 0 4 1398 27 VirtualFileSystem::get_file 0 1 566 537</span>
<span class="s0">/**</span>
 <span class="s0">* Looks up the file by the indicated name in the file system.  Returns a</span>
 <span class="s0">* VirtualFile pointer representing the file if it is found, or NULL if it is</span>
 <span class="s0">* not.</span>
 <span class="s0">*</span>
 <span class="s0">* If status_only is true, the file will be checked for existence and length</span>
 <span class="s0">* and so on, but the returned file's contents cannot be read.  This is an</span>
 <span class="s0">* optimization which is especially important for certain mount types, for</span>
 <span class="s0">* instance HTTP, for which opening a file to determine its status is</span>
 <span class="s0">* substantially less expensive than opening it to read its contents.</span>
 <span class="s0">*/</span>
<span class="s0">111</span>
<span class="s0">PointerTo&lt; VirtualFile &gt; VirtualFileSystem::get_file(Filename const &amp;filename, bool status_only = false) const;</span>

<span class="s0">1252 11 create_file 0 4 1398 30 VirtualFileSystem::create_file 0 1 567 298</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to create a file by the indicated name in the filesystem, if</span>
 <span class="s0">* possible, and returns it.  If a file by this name already exists, returns</span>
 <span class="s0">* the same thing as get_file().  If the filename is located within a read-</span>
 <span class="s0">* only directory, or the directory doesn't exist, returns NULL.</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">PointerTo&lt; VirtualFile &gt; VirtualFileSystem::create_file(Filename const &amp;filename);</span>

<span class="s0">1253 9 find_file 0 4 1398 28 VirtualFileSystem::find_file 0 1 568 173</span>
<span class="s0">/**</span>
 <span class="s0">* Uses the indicated search path to find the file within the file system.</span>
 <span class="s0">* Returns the first occurrence of the file found, or NULL if the file cannot</span>
 <span class="s0">* be found.</span>
 <span class="s0">*/</span>
<span class="s0">143</span>
<span class="s0">PointerTo&lt; VirtualFile &gt; VirtualFileSystem::find_file(Filename const &amp;filename, DSearchPath const &amp;searchpath, bool status_only = false) const;</span>

<span class="s0">1254 11 delete_file 0 4 1398 30 VirtualFileSystem::delete_file 0 1 569 208</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to delete the indicated file or directory.  This can remove a</span>
 <span class="s0">* single file or an empty directory.  It will not remove a nonempty</span>
 <span class="s0">* directory.  Returns true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">bool VirtualFileSystem::delete_file(Filename const &amp;filename);</span>

<span class="s0">1255 11 rename_file 0 4 1398 30 VirtualFileSystem::rename_file 0 1 570 599</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to move or rename the indicated file or directory.  If the</span>
 <span class="s0">* original file is an ordinary file, it will quietly replace any already-</span>
 <span class="s0">* existing file in the new filename (but not a directory).  If the original</span>
 <span class="s0">* file is a directory, the new filename must not already exist.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is a directory, the new filename must be within the same mount</span>
 <span class="s0">* point.  If the file is an ordinary file, the new filename may be anywhere;</span>
 <span class="s0">* but if it is not within the same mount point then the rename operation is</span>
 <span class="s0">* automatically performed as a two-step copy-and-delete operation.</span>
 <span class="s0">*/</span>
<span class="s0">97</span>
<span class="s0">bool VirtualFileSystem::rename_file(Filename const &amp;orig_filename, Filename const &amp;new_filename);</span>

<span class="s0">1256 9 copy_file 0 4 1398 28 VirtualFileSystem::copy_file 0 1 571 131</span>
<span class="s0">/**</span>
 <span class="s0">* Attempts to copy the contents of the indicated file to the indicated file.</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/</span>
<span class="s0">95</span>
<span class="s0">bool VirtualFileSystem::copy_file(Filename const &amp;orig_filename, Filename const &amp;new_filename);</span>

<span class="s0">1257 16 resolve_filename 0 4 1398 35 VirtualFileSystem::resolve_filename 0 1 572 174</span>
<span class="s0">/**</span>
 <span class="s0">* Searches the given search path for the filename.  If it is found, updates</span>
 <span class="s0">* the filename to the full pathname found and returns true; otherwise,</span>
 <span class="s0">* returns false.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">bool VirtualFileSystem::resolve_filename(Filename &amp;filename, DSearchPath const &amp;searchpath, std::string const &amp;default_extension = string()) const;</span>

<span class="s0">1258 14 find_all_files 0 4 1398 33 VirtualFileSystem::find_all_files 0 1 573 363</span>
<span class="s0">/**</span>
 <span class="s0">* Searches all the directories in the search list for the indicated file, in</span>
 <span class="s0">* order.  Fills up the results list with *all* of the matching filenames</span>
 <span class="s0">* found, if any.  Returns the number of matches found.</span>
 <span class="s0">*</span>
 <span class="s0">* It is the responsibility of the the caller to clear the results list first;</span>
 <span class="s0">* otherwise, the newly-found files will be appended to the list.</span>
 <span class="s0">*/</span>
<span class="s0">132</span>
<span class="s0">int VirtualFileSystem::find_all_files(Filename const &amp;filename, DSearchPath const &amp;searchpath, DSearchPath::Results &amp;results) const;</span>

<span class="s0">1259 6 exists 0 4 1398 25 VirtualFileSystem::exists 0 1 574 71</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; returns true if the named file exists.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline bool VirtualFileSystem::exists(Filename const &amp;filename) const;</span>

<span class="s0">1260 12 is_directory 0 4 1398 31 VirtualFileSystem::is_directory 0 1 575 93</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; returns true if the named file exists and is a</span>
 <span class="s0">* directory.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline bool VirtualFileSystem::is_directory(Filename const &amp;filename) const;</span>

<span class="s0">1261 15 is_regular_file 0 4 1398 34 VirtualFileSystem::is_regular_file 0 1 576 96</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; returns true if the named file exists and is a</span>
 <span class="s0">* regular file.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">inline bool VirtualFileSystem::is_regular_file(Filename const &amp;filename) const;</span>

<span class="s0">1262 14 scan_directory 0 4 1398 33 VirtualFileSystem::scan_directory 0 1 577 247</span>
<span class="s0">/**</span>
 <span class="s0">* If the file represents a directory (that is, is_directory() returns true),</span>
 <span class="s0">* this returns the list of files within the directory at the current time.</span>
 <span class="s0">* Returns NULL if the file is not a directory or if the directory cannot be</span>
 <span class="s0">* read.</span>
 <span class="s0">*/</span>
<span class="s0">102</span>
<span class="s0">inline PointerTo&lt; VirtualFileList &gt; VirtualFileSystem::scan_directory(Filename const &amp;filename) const;</span>

<span class="s0">1263 2 ls 0 4 1398 21 VirtualFileSystem::ls 0 1 578 80</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; lists the files within the indicated directory.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void VirtualFileSystem::ls(Filename const &amp;filename) const;</span>

<span class="s0">1264 6 ls_all 0 4 1398 25 VirtualFileSystem::ls_all 0 1 579 117</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; lists the files within the indicated directory, and</span>
 <span class="s0">* all files below, recursively.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void VirtualFileSystem::ls_all(Filename const &amp;filename) const;</span>

<span class="s0">1265 5 write 0 4 1398 24 VirtualFileSystem::write 0 1 580 75</span>
<span class="s0">/**</span>
 <span class="s0">* Print debugging information.  (e.g.  from Python or gdb prompt).</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">void VirtualFileSystem::write(std::ostream &amp;out) const;</span>

<span class="s0">1266 14 get_global_ptr 0 4 1398 33 VirtualFileSystem::get_global_ptr 0 1 581 423</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the default global VirtualFileSystem.  You may create your own</span>
 <span class="s0">* personal VirtualFileSystem objects and use them for whatever you like, but</span>
 <span class="s0">* Panda will attempt to load models and stuff from this default object.</span>
 <span class="s0">*</span>
 <span class="s0">* Initially, the global VirtualFileSystem is set up to mount the OS</span>
 <span class="s0">* filesystem to root; i.e.  it is equivalent to the OS filesystem.  This may</span>
 <span class="s0">* be subsequently adjusted by the user.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static VirtualFileSystem *VirtualFileSystem::get_global_ptr(void);</span>

<span class="s0">1267 9 read_file 0 4 1398 28 VirtualFileSystem::read_file 0 1 582 1244</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; returns the entire contents of the indicated file as</span>
 <span class="s0">* a string.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically</span>
 <span class="s0">* decompressed and the decompressed contents are returned.  This is different</span>
 <span class="s0">* than vfs-implicit-pz, which will automatically decompress a file if the</span>
 <span class="s0">* extension .pz is *not* given.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Convenience function; fills the string up with the data from the indicated</span>
 <span class="s0">* file, if it exists and can be read.  Returns true on success, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically</span>
 <span class="s0">* decompressed and the decompressed contents are returned.  This is different</span>
 <span class="s0">* than vfs-implicit-pz, which will automatically decompress a file if the</span>
 <span class="s0">* extension .pz is *not* given.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Convenience function; fills the pvector up with the data from the indicated</span>
 <span class="s0">* file, if it exists and can be read.  Returns true on success, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically</span>
 <span class="s0">* decompressed and the decompressed contents are returned.  This is different</span>
 <span class="s0">* than vfs-implicit-pz, which will automatically decompress a file if the</span>
 <span class="s0">* extension .pz is *not* given.</span>
 <span class="s0">*/</span>
<span class="s0">89</span>
<span class="s0">PyObject *VirtualFileSystem::read_file(Filename const &amp;filename, bool auto_unwrap) const;</span>

<span class="s0">1268 14 open_read_file 0 4 1398 33 VirtualFileSystem::open_read_file 0 1 583 424</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; returns a newly allocated istream if the file exists</span>
 <span class="s0">* and can be read, or NULL otherwise.  Does not return an invalid istream.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_unwrap is true, an explicitly-named .pz file is automatically</span>
 <span class="s0">* decompressed and the decompressed contents are returned.  This is different</span>
 <span class="s0">* than vfs-implicit-pz, which will automatically decompress a file if the</span>
 <span class="s0">* extension .pz is *not* given.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">std::istream *VirtualFileSystem::open_read_file(Filename const &amp;filename, bool auto_unwrap) const;</span>

<span class="s0">1269 15 close_read_file 0 4 1398 34 VirtualFileSystem::close_read_file 0 1 584 243</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_file().  This really</span>
 <span class="s0">* just deletes the istream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">static void VirtualFileSystem::close_read_file(std::istream *stream);</span>

<span class="s0">1270 10 write_file 0 4 1398 29 VirtualFileSystem::write_file 0 1 585 409</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; writes the entire contents of the indicated file as a</span>
 <span class="s0">* string.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_wrap is true, an explicitly-named .pz file is automatically</span>
 <span class="s0">* compressed while writing.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Convenience function; writes the entire contents of the indicated file as a</span>
 <span class="s0">* block of data.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_wrap is true, an explicitly-named .pz file is automatically</span>
 <span class="s0">* compressed while writing.</span>
 <span class="s0">*/</span>
<span class="s0">98</span>
<span class="s0">PyObject *VirtualFileSystem::write_file(Filename const &amp;filename, PyObject *data, bool auto_wrap);</span>

<span class="s0">1271 15 open_write_file 0 4 1398 34 VirtualFileSystem::open_write_file 0 1 586 345</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; returns a newly allocated ostream if the file exists</span>
 <span class="s0">* and can be written, or NULL otherwise.  Does not return an invalid ostream.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_wrap is true, an explicitly-named .pz file is automatically</span>
 <span class="s0">* compressed while writing.  If truncate is true, the file is truncated to</span>
 <span class="s0">* zero length before writing.</span>
 <span class="s0">*/</span>
<span class="s0">106</span>
<span class="s0">std::ostream *VirtualFileSystem::open_write_file(Filename const &amp;filename, bool auto_wrap, bool truncate);</span>

<span class="s0">1272 16 open_append_file 0 4 1398 35 VirtualFileSystem::open_append_file 0 1 587 180</span>
<span class="s0">/**</span>
 <span class="s0">* Works like open_write_file(), but the file is opened in append mode.  Like</span>
 <span class="s0">* open_write_file, the returned pointer should eventually be passed to</span>
 <span class="s0">* close_write_file().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">std::ostream *VirtualFileSystem::open_append_file(Filename const &amp;filename);</span>

<span class="s0">1273 16 close_write_file 0 4 1398 35 VirtualFileSystem::close_write_file 0 1 588 244</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a file opened by a previous call to open_write_file().  This really</span>
 <span class="s0">* just deletes the ostream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">static void VirtualFileSystem::close_write_file(std::ostream *stream);</span>

<span class="s0">1274 20 open_read_write_file 0 4 1398 39 VirtualFileSystem::open_read_write_file 0 1 589 169</span>
<span class="s0">/**</span>
 <span class="s0">* Convenience function; returns a newly allocated iostream if the file exists</span>
 <span class="s0">* and can be written, or NULL otherwise.  Does not return an invalid</span>
 <span class="s0">* iostream.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">std::iostream *VirtualFileSystem::open_read_write_file(Filename const &amp;filename, bool truncate);</span>

<span class="s0">1275 21 open_read_append_file 0 4 1398 40 VirtualFileSystem::open_read_append_file 0 1 590 194</span>
<span class="s0">/**</span>
 <span class="s0">* Works like open_read_write_file(), but the file is opened in append mode.</span>
 <span class="s0">* Like open_read_write_file, the returned pointer should eventually be passed</span>
 <span class="s0">* to close_read_write_file().</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">std::iostream *VirtualFileSystem::open_read_append_file(Filename const &amp;filename);</span>

<span class="s0">1276 21 close_read_write_file 0 4 1398 40 VirtualFileSystem::close_read_write_file 0 1 591 250</span>
<span class="s0">/**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_write_file().  This</span>
 <span class="s0">* really just deletes the iostream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">static void VirtualFileSystem::close_read_write_file(std::iostream *stream);</span>

<span class="s0">1277 13 get_long_time 0 4 1402 24 TrueClock::get_long_time 0 1 603 420</span>
<span class="s0">// get_long_time() returns the most accurate timer we have over a long</span>
<span class="s0">// interval.  It may not be very precise for measuring short intervals, but</span>
<span class="s0">// it should not drift substantially over the long haul.</span>

<span class="s0">// get_long_time() returns the most accurate timer we have over a long</span>
<span class="s0">// interval.  It may not be very precise for measuring short intervals, but</span>
<span class="s0">// it should not drift substantially over the long haul.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">double TrueClock::get_long_time(void);</span>

<span class="s0">1278 14 get_short_time 0 4 1402 25 TrueClock::get_short_time 0 1 604 426</span>
<span class="s0">// get_short_time() returns the most precise timer we have over a short</span>
<span class="s0">// interval.  It may tend to drift over the long haul, but it should have</span>
<span class="s0">// lots of digits to measure short intervals very precisely.</span>

<span class="s0">// get_short_time() returns the most precise timer we have over a short</span>
<span class="s0">// interval.  It may tend to drift over the long haul, but it should have</span>
<span class="s0">// lots of digits to measure short intervals very precisely.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline double TrueClock::get_short_time(void);</span>

<span class="s0">1279 18 get_short_raw_time 0 4 1402 29 TrueClock::get_short_raw_time 0 1 605 302</span>
<span class="s0">// get_short_raw_time() is like get_short_time(), but does not apply any</span>
<span class="s0">// corrections (e.g.  paranoid-clock) to the result returned by the OS.</span>

<span class="s0">// get_short_raw_time() is like get_short_time(), but does not apply any</span>
<span class="s0">// corrections (e.g.  paranoid-clock) to the result returned by the OS.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">43</span>
<span class="s0">double TrueClock::get_short_raw_time(void);</span>

<span class="s0">1280 15 get_error_count 0 4 1402 26 TrueClock::get_error_count 0 1 606 369</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of clock errors that have been detected.  Each time a</span>
 <span class="s0">* clock error is detected, in which the value returned by either of the above</span>
 <span class="s0">* methods is suspect, the value returned by this method will be incremented.</span>
 <span class="s0">* Applications can monitor this value and react, for instance, by</span>
 <span class="s0">* resynchronizing their clocks each time this value changes.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int TrueClock::get_error_count(void) const;</span>

<span class="s0">1281 14 get_global_ptr 0 4 1402 25 TrueClock::get_global_ptr 0 1 607 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a pointer to the one TrueClock object in the world.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">static inline TrueClock *TrueClock::get_global_ptr(void);</span>

<span class="s0">1282 16 set_cpu_affinity 0 4 1402 27 TrueClock::set_cpu_affinity 0 1 608 0</span>
<span class="s0">54</span>
<span class="s0">bool TrueClock::set_cpu_affinity(uint32_t mask) const;</span>

<span class="s0">1283 9 Patchfile 0 260 1404 20 Patchfile::Patchfile 0 2 609 610 111</span>
<span class="s0">/**</span>
 <span class="s0">* Create a patch file and initializes internal data</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Create patch file with buffer to patch</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">Patchfile::Patchfile(void);</span>
<span class="s0">explicit Patchfile::Patchfile(PointerTo&lt; Buffer &gt; buffer);</span>

<span class="s0">1284 10 ~Patchfile 0 516 1404 21 Patchfile::~Patchfile 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">28</span>
<span class="s0">Patchfile::~Patchfile(void);</span>

<span class="s0">1285 5 build 0 4 1404 16 Patchfile::build 0 1 611 359</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">* This implementation uses the &quot;greedy differencing algorithm&quot; described in</span>
 <span class="s0">* the masters thesis &quot;Differential Compression: A Generalized Solution for</span>
 <span class="s0">* Binary Files&quot; by Randal C. Burns (p.13). For an original file of size M and</span>
 <span class="s0">* a new file of size N, this algorithm is O(M) in space and O(M*N) (worst-</span>
 <span class="s0">* case) in time.  return false on error</span>
 <span class="s0">*/</span>
<span class="s0">82</span>
<span class="s0">bool Patchfile::build(Filename file_orig, Filename file_new, Filename patch_name);</span>

<span class="s0">1286 11 read_header 0 4 1404 22 Patchfile::read_header 0 1 612 193</span>
<span class="s0">/**</span>
 <span class="s0">* Opens the patch file for reading, and gets the header information from the</span>
 <span class="s0">* file but does not begin to do any real work.  This can be used to query the</span>
 <span class="s0">* data stored in the patch.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">int Patchfile::read_header(Filename const &amp;patch_file);</span>

<span class="s0">1287 8 initiate 0 4 1404 19 Patchfile::initiate 0 2 613 614 236</span>
<span class="s0">/**</span>
 <span class="s0">* Set up to apply the patch to the file (original file and patch are</span>
 <span class="s0">* destroyed in the process).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Set up to apply the patch to the file.  In this form, neither the original</span>
 <span class="s0">* file nor the patch file are destroyed.</span>
 <span class="s0">*/</span>
<span class="s0">183</span>
<span class="s0">int Patchfile::initiate(Filename const &amp;patch_file, Filename const &amp;file);</span>
<span class="s0">int Patchfile::initiate(Filename const &amp;patch_file, Filename const &amp;orig_file, Filename const &amp;target_file);</span>

<span class="s0">1288 3 run 0 4 1404 14 Patchfile::run 0 1 615 390</span>
<span class="s0">/**</span>
 <span class="s0">* Perform one buffer's worth of patching.</span>
 <span class="s0">* Returns one of the following values:</span>
 <span class="s0">* @li @c EU_ok : while patching</span>
 <span class="s0">* @li @c EU_success : when done</span>
 <span class="s0">* @li @c EU_error_abort : Patching has not been initiated</span>
 <span class="s0">* @li @c EU_error_file_invalid : file is corrupted</span>
 <span class="s0">* @li @c EU_error_invalid_checksum : incompatible patch file</span>
 <span class="s0">* @li @c EU_error_write_file_rename : could not rename file</span>
 <span class="s0">*/</span>
<span class="s0">25</span>
<span class="s0">int Patchfile::run(void);</span>

<span class="s0">1289 5 apply 0 4 1404 16 Patchfile::apply 0 2 616 617 311</span>
<span class="s0">/**</span>
 <span class="s0">* Patches the entire file in one call returns true on success and false on</span>
 <span class="s0">* error</span>
 <span class="s0">*</span>
 <span class="s0">* This version will delete the patch file and overwrite the original file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Patches the entire file in one call returns true on success and false on</span>
 <span class="s0">* error</span>
 <span class="s0">*</span>
 <span class="s0">* This version will not delete any files.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">bool Patchfile::apply(Filename &amp;patch_file, Filename &amp;file);</span>
<span class="s0">bool Patchfile::apply(Filename &amp;patch_file, Filename &amp;orig_file, Filename const &amp;target_file);</span>

<span class="s0">1290 12 get_progress 0 4 1404 23 Patchfile::get_progress 0 1 618 125</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a value in the range 0..1, representing the amount of progress</span>
 <span class="s0">* through the patchfile, during a session.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PN_stdfloat Patchfile::get_progress(void) const;</span>

<span class="s0">1291 19 set_allow_multifile 0 4 1404 30 Patchfile::set_allow_multifile 0 1 619 362</span>
<span class="s0">/**</span>
 <span class="s0">* If this flag is set true, the Patchfile will make a special case for</span>
 <span class="s0">* patching Panda Multifiles, if detected, and attempt to patch them on a</span>
 <span class="s0">* subfile-by-subfile basis.  If this flag is false, the Patchfile will always</span>
 <span class="s0">* patch the file on a full-file basis.</span>
 <span class="s0">*</span>
 <span class="s0">* This has effect only when building patches; it is not used for applying</span>
 <span class="s0">* patches.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void Patchfile::set_allow_multifile(bool allow_multifile);</span>

<span class="s0">1292 19 get_allow_multifile 0 4 1404 30 Patchfile::get_allow_multifile 0 1 620 37</span>
<span class="s0">/**</span>
 <span class="s0">* See set_allow_multifile().</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline bool Patchfile::get_allow_multifile(void);</span>

<span class="s0">1293 20 set_footprint_length 0 4 1404 31 Patchfile::set_footprint_length 0 1 621 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void Patchfile::set_footprint_length(int length);</span>

<span class="s0">1294 20 get_footprint_length 0 4 1404 31 Patchfile::get_footprint_length 0 1 622 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int Patchfile::get_footprint_length(void);</span>

<span class="s0">1295 22 reset_footprint_length 0 4 1404 33 Patchfile::reset_footprint_length 0 1 623 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void Patchfile::reset_footprint_length(void);</span>

<span class="s0">1296 15 has_source_hash 0 4 1404 26 Patchfile::has_source_hash 0 1 624 145</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the MD5 hash for the source file is known.  (Some early</span>
 <span class="s0">* versions of the patch file did not store this information.)</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline bool Patchfile::has_source_hash(void) const;</span>

<span class="s0">1297 15 get_source_hash 0 4 1404 26 Patchfile::get_source_hash 0 1 625 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the MD5 hash for the source file.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline HashVal const &amp;Patchfile::get_source_hash(void) const;</span>

<span class="s0">1298 15 get_result_hash 0 4 1404 26 Patchfile::get_result_hash 0 1 626 78</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the MD5 hash for the file after the patch has been applied.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline HashVal const &amp;Patchfile::get_result_hash(void) const;</span>

<span class="s0">1299 13 password_hash 0 1 0 13 password_hash 0 1 665 0</span>
<span class="s0">103</span>
<span class="s0">std::string password_hash(std::string const &amp;password, std::string const &amp;salt, int iters, int keylen);</span>

<span class="s0">1300 12 ProfileTimer 0 260 1408 26 ProfileTimer::ProfileTimer 0 2 627 628 0</span>
<span class="s0">136</span>
<span class="s0">explicit ProfileTimer::ProfileTimer(char const *name = 0, int maxEntries = 4096);</span>
<span class="s0">ProfileTimer::ProfileTimer(ProfileTimer const &amp;other);</span>

<span class="s0">1301 13 ~ProfileTimer 0 516 1408 27 ProfileTimer::~ProfileTimer 0 0 0</span>
<span class="s0">34</span>
<span class="s0">ProfileTimer::~ProfileTimer(void);</span>

<span class="s0">1302 4 init 0 4 1408 18 ProfileTimer::init 0 1 629 0</span>
<span class="s0">65</span>
<span class="s0">void ProfileTimer::init(char const *name, int maxEntries = 4096);</span>

<span class="s0">1303 2 on 0 4 1408 16 ProfileTimer::on 0 1 630 0</span>
<span class="s0">28</span>
<span class="s0">void ProfileTimer::on(void);</span>

<span class="s0">1304 4 mark 0 4 1408 18 ProfileTimer::mark 0 1 631 0</span>
<span class="s0">41</span>
<span class="s0">void ProfileTimer::mark(char const *tag);</span>

<span class="s0">1305 3 off 0 4 1408 17 ProfileTimer::off 0 2 632 633 0</span>
<span class="s0">70</span>
<span class="s0">void ProfileTimer::off(void);</span>
<span class="s0">void ProfileTimer::off(char const *tag);</span>

<span class="s0">1306 12 getTotalTime 0 4 1408 26 ProfileTimer::getTotalTime 0 1 634 110</span>
<span class="s0">// Don't call any of the following during timing: (Because they are slow,</span>
<span class="s0">// not because anything will break).</span>
<span class="s0">46</span>
<span class="s0">double ProfileTimer::getTotalTime(void) const;</span>

<span class="s0">1307 16 consolidateAllTo 0 4 1408 30 ProfileTimer::consolidateAllTo 0 1 635 0</span>
<span class="s0">76</span>
<span class="s0">static void ProfileTimer::consolidateAllTo(std::ostream &amp;out = ::std::cout);</span>

<span class="s0">1308 13 consolidateTo 0 4 1408 27 ProfileTimer::consolidateTo 0 1 636 0</span>
<span class="s0">72</span>
<span class="s0">void ProfileTimer::consolidateTo(std::ostream &amp;out = ::std::cout) const;</span>

<span class="s0">1309 10 printAllTo 0 4 1408 24 ProfileTimer::printAllTo 0 1 637 0</span>
<span class="s0">70</span>
<span class="s0">static void ProfileTimer::printAllTo(std::ostream &amp;out = ::std::cout);</span>

<span class="s0">1310 7 printTo 0 4 1408 21 ProfileTimer::printTo 0 1 638 0</span>
<span class="s0">66</span>
<span class="s0">void ProfileTimer::printTo(std::ostream &amp;out = ::std::cout) const;</span>

<span class="s0">1311 11 was_deleted 0 4 1409 30 WeakPointerToVoid::was_deleted 0 1 639 384</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the object we are pointing to has been deleted, false</span>
 <span class="s0">* otherwise.  If this returns true, it means that the pointer can not yet be</span>
 <span class="s0">* reused, but it does not guarantee that it can be safely accessed.  See the</span>
 <span class="s0">* lock() method for a safe way to access the underlying pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* This will always return true for a null pointer, unlike is_valid_pointer().</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline bool WeakPointerToVoid::was_deleted(void) const;</span>

<span class="s0">1312 16 is_valid_pointer 0 4 1409 35 WeakPointerToVoid::is_valid_pointer 0 1 640 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the pointer is not null and the object has not been</span>
 <span class="s0">* deleted.  See was_deleted() for caveats.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline bool WeakPointerToVoid::is_valid_pointer(void) const;</span>

<span class="s0">1313 18 ~WeakPointerToVoid 0 516 1409 37 WeakPointerToVoid::~WeakPointerToVoid 0 0 0</span>
<span class="s0">44</span>
<span class="s0">WeakPointerToVoid::~WeakPointerToVoid(void);</span>

<span class="s0">1314 16 set_string_value 0 4 1410 33 WindowsRegistry::set_string_value 0 1 643 302</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the registry key to the indicated value as a string.  The supplied</span>
 <span class="s0">* string value is automatically converted from whatever encoding is set by</span>
 <span class="s0">* TextEncoder::set_default_encoding() and written as a Unicode string.  The</span>
 <span class="s0">* registry key must already exist prior to calling this function.</span>
 <span class="s0">*/</span>
<span class="s0">183</span>
<span class="s0">static bool WindowsRegistry::set_string_value(std::string const &amp;key, std::string const &amp;name, std::string const &amp;value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine);</span>

<span class="s0">1315 13 set_int_value 0 4 1410 30 WindowsRegistry::set_int_value 0 1 644 142</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the registry key to the indicated value as an integer.  The registry</span>
 <span class="s0">* key must already exist prior to calling this function.</span>
 <span class="s0">*/</span>
<span class="s0">165</span>
<span class="s0">static bool WindowsRegistry::set_int_value(std::string const &amp;key, std::string const &amp;name, int value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine);</span>

<span class="s0">1316 12 get_key_type 0 4 1410 29 WindowsRegistry::get_key_type 0 1 645 115</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the type of the indicated key, or T_none if the key is not known or</span>
 <span class="s0">* is some unsupported type.</span>
 <span class="s0">*/</span>
<span class="s0">170</span>
<span class="s0">static WindowsRegistry::Type WindowsRegistry::get_key_type(std::string const &amp;key, std::string const &amp;name, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine);</span>

<span class="s0">1317 16 get_string_value 0 4 1410 33 WindowsRegistry::get_string_value 0 1 646 291</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value associated with the indicated registry key, assuming it</span>
 <span class="s0">* is a string value.  The string value is automatically encoded using</span>
 <span class="s0">* TextEncoder::get_default_encoding().  If the key is not defined or is not a</span>
 <span class="s0">* string type value, default_value is returned instead.</span>
 <span class="s0">*/</span>
<span class="s0">198</span>
<span class="s0">static std::string WindowsRegistry::get_string_value(std::string const &amp;key, std::string const &amp;name, std::string const &amp;default_value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine);</span>

<span class="s0">1318 13 get_int_value 0 4 1410 30 WindowsRegistry::get_int_value 0 1 647 206</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value associated with the indicated registry key, assuming it</span>
 <span class="s0">* is an integer value.  If the key is not defined or is not an integer type</span>
 <span class="s0">* value, default_value is returned instead.</span>
 <span class="s0">*/</span>
<span class="s0">172</span>
<span class="s0">static int WindowsRegistry::get_int_value(std::string const &amp;key, std::string const &amp;name, int default_value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine);</span>

<span class="s0">1319 15 WindowsRegistry 0 260 1410 32 WindowsRegistry::WindowsRegistry 0 2 641 642 0</span>
<span class="s0">132</span>
<span class="s0">inline WindowsRegistry::WindowsRegistry(void) = default;</span>
<span class="s0">inline WindowsRegistry::WindowsRegistry(WindowsRegistry const &amp;) = default;</span>

<span class="s0">1320 16 ~WindowsRegistry 0 516 1410 33 WindowsRegistry::~WindowsRegistry 0 0 0</span>
<span class="s0">40</span>
<span class="s0">WindowsRegistry::~WindowsRegistry(void);</span>

<span class="s0">665</span>
<span class="s0">1 0 0 15 15 1417 688 0 0 1 4 copy 1 1415  </span>
<span class="s0">2 0 0 23 15 1417 688 0 0 1 4 copy 1 1418  </span>
<span class="s0">3 0 0 4 16 1420 0 0 0 1 4 this 3 1417  </span>
<span class="s0">4 0 0 6 17 1351 0 0 0 1 4 this 3 1415  </span>
<span class="s0">5 0 0 6 18 1403 0 0 0 2 4 this 3 1415  1 n 1 1351  </span>
<span class="s0">6 0 0 38 19 1403 0 0 0 2 4 this 3 1415  1 n 1 1351  </span>
<span class="s0">7 0 0 38 20 1421 0 0 0 1 4 this 3 1415  </span>
<span class="s0">8 0 0 38 21 1421 0 0 0 3 4 this 3 1415  1 n 1 1351  5 count 1 1351  </span>
<span class="s0">9 0 0 6 22 1353 0 0 0 1 4 this 3 1415  </span>
<span class="s0">10 0 0 6 23 1353 0 0 0 1 4 this 3 1415  </span>
<span class="s0">11 0 0 6 24 1351 0 0 0 2 4 this 3 1415  6 param0 0 1403  </span>
<span class="s0">12 0 0 38 25 1421 0 0 0 1 4 this 3 1415  </span>
<span class="s0">13 0 0 38 26 1353 0 0 0 3 4 this 3 1415  4 view 1 1424  5 flags 1 1353  </span>
<span class="s0">14 0 0 36 27 1420 0 0 0 2 4 this 3 1415  4 view 1 1424  </span>
<span class="s0">15 0 0 39 28 1417 688 0 0 2 4 this 3 1415  4 memo 1 1421  </span>
<span class="s0">16 0 0 6 13 1349 0 0 64 // These are implemented in PointerToVoid, but expose them here. 2 4 this 3 1427  5 other 1 1427  </span>
<span class="s0">17 0 0 6 14 1349 0 0 0 2 4 this 3 1427  5 other 1 1427  </span>
<span class="s0">18 0 0 4 10 1420 0 0 0 1 4 this 3 1429  </span>
<span class="s0">19 0 0 4 11 1420 0 0 0 2 4 this 3 1430  3 out 1 1432  </span>
<span class="s0">20 0 0 6 7 1349 0 0 130 /**</span>
 <span class="s0">* Returns true if the PointerTo is a NULL pointer, false otherwise.  (Direct</span>
 <span class="s0">* comparison to a NULL pointer also works.)</span>
 <span class="s0">*/ 1 4 this 3 1433  </span>
<span class="s0">21 0 0 6 8 1350 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 1433  </span>
<span class="s0">22 0 0 15 39 1437 708 0 0 1 4 copy 1 1435  </span>
<span class="s0">23 0 0 23 39 1437 708 0 0 1 4 copy 1 1438  </span>
<span class="s0">24 0 0 4 40 1420 0 0 0 1 4 this 3 1437  </span>
<span class="s0">25 0 0 6 41 1351 0 0 0 1 4 this 3 1435  </span>
<span class="s0">26 0 0 6 42 1406 0 0 0 2 4 this 3 1435  1 n 1 1351  </span>
<span class="s0">27 0 0 38 43 1406 0 0 0 2 4 this 3 1435  1 n 1 1351  </span>
<span class="s0">28 0 0 38 44 1421 0 0 0 1 4 this 3 1435  </span>
<span class="s0">29 0 0 38 45 1421 0 0 0 3 4 this 3 1435  1 n 1 1351  5 count 1 1351  </span>
<span class="s0">30 0 0 6 46 1353 0 0 0 1 4 this 3 1435  </span>
<span class="s0">31 0 0 6 47 1353 0 0 0 1 4 this 3 1435  </span>
<span class="s0">32 0 0 6 48 1351 0 0 0 2 4 this 3 1435  6 param0 0 1406  </span>
<span class="s0">33 0 0 38 49 1421 0 0 0 1 4 this 3 1435  </span>
<span class="s0">34 0 0 38 50 1353 0 0 0 3 4 this 3 1435  4 view 1 1424  5 flags 1 1353  </span>
<span class="s0">35 0 0 36 51 1420 0 0 0 2 4 this 3 1435  4 view 1 1424  </span>
<span class="s0">36 0 0 39 52 1437 708 0 0 2 4 this 3 1435  4 memo 1 1421  </span>
<span class="s0">37 0 0 6 37 1349 0 0 64 // These are implemented in PointerToVoid, but expose them here. 2 4 this 3 1440  5 other 1 1440  </span>
<span class="s0">38 0 0 6 38 1349 0 0 0 2 4 this 3 1440  5 other 1 1440  </span>
<span class="s0">39 0 0 4 34 1420 0 0 0 1 4 this 3 1442  </span>
<span class="s0">40 0 0 4 35 1420 0 0 0 2 4 this 3 1443  3 out 1 1432  </span>
<span class="s0">41 0 0 15 63 1447 728 0 0 1 4 copy 1 1445  </span>
<span class="s0">42 0 0 23 63 1447 728 0 0 1 4 copy 1 1448  </span>
<span class="s0">43 0 0 4 64 1420 0 0 0 1 4 this 3 1447  </span>
<span class="s0">44 0 0 6 65 1351 0 0 0 1 4 this 3 1445  </span>
<span class="s0">45 0 0 6 66 1353 0 0 0 2 4 this 3 1445  1 n 1 1351  </span>
<span class="s0">46 0 0 38 67 1353 0 0 0 2 4 this 3 1445  1 n 1 1351  </span>
<span class="s0">47 0 0 38 68 1421 0 0 0 1 4 this 3 1445  </span>
<span class="s0">48 0 0 38 69 1421 0 0 0 3 4 this 3 1445  1 n 1 1351  5 count 1 1351  </span>
<span class="s0">49 0 0 6 70 1353 0 0 0 1 4 this 3 1445  </span>
<span class="s0">50 0 0 6 71 1353 0 0 0 1 4 this 3 1445  </span>
<span class="s0">51 0 0 6 72 1351 0 0 0 2 4 this 3 1445  6 param0 0 1353  </span>
<span class="s0">52 0 0 38 73 1421 0 0 0 1 4 this 3 1445  </span>
<span class="s0">53 0 0 38 74 1353 0 0 0 3 4 this 3 1445  4 view 1 1424  5 flags 1 1353  </span>
<span class="s0">54 0 0 36 75 1420 0 0 0 2 4 this 3 1445  4 view 1 1424  </span>
<span class="s0">55 0 0 39 76 1447 728 0 0 2 4 this 3 1445  4 memo 1 1421  </span>
<span class="s0">56 0 0 6 61 1349 0 0 64 // These are implemented in PointerToVoid, but expose them here. 2 4 this 3 1450  5 other 1 1450  </span>
<span class="s0">57 0 0 6 62 1349 0 0 0 2 4 this 3 1450  5 other 1 1450  </span>
<span class="s0">58 0 0 4 58 1420 0 0 0 1 4 this 3 1452  </span>
<span class="s0">59 0 0 4 59 1420 0 0 0 2 4 this 3 1453  3 out 1 1432  </span>
<span class="s0">60 0 0 15 87 1457 748 0 0 1 4 copy 1 1455  </span>
<span class="s0">61 0 0 23 87 1457 748 0 0 1 4 copy 1 1458  </span>
<span class="s0">62 0 0 4 88 1420 0 0 0 1 4 this 3 1457  </span>
<span class="s0">63 0 0 6 89 1351 0 0 0 1 4 this 3 1455  </span>
<span class="s0">64 0 0 6 90 1460 0 0 0 2 4 this 3 1455  1 n 1 1351  </span>
<span class="s0">65 0 0 38 91 1460 0 0 0 2 4 this 3 1455  1 n 1 1351  </span>
<span class="s0">66 0 0 38 92 1421 0 0 0 1 4 this 3 1455  </span>
<span class="s0">67 0 0 38 93 1421 0 0 0 3 4 this 3 1455  1 n 1 1351  5 count 1 1351  </span>
<span class="s0">68 0 0 6 94 1353 0 0 0 1 4 this 3 1455  </span>
<span class="s0">69 0 0 6 95 1353 0 0 0 1 4 this 3 1455  </span>
<span class="s0">70 0 0 6 96 1351 0 0 0 2 4 this 3 1455  6 param0 0 1460  </span>
<span class="s0">71 0 0 38 97 1421 0 0 0 1 4 this 3 1455  </span>
<span class="s0">72 0 0 38 98 1353 0 0 0 3 4 this 3 1455  4 view 1 1424  5 flags 1 1353  </span>
<span class="s0">73 0 0 36 99 1420 0 0 0 2 4 this 3 1455  4 view 1 1424  </span>
<span class="s0">74 0 0 39 100 1457 748 0 0 2 4 this 3 1455  4 memo 1 1421  </span>
<span class="s0">75 0 0 6 85 1349 0 0 64 // These are implemented in PointerToVoid, but expose them here. 2 4 this 3 1461  5 other 1 1461  </span>
<span class="s0">76 0 0 6 86 1349 0 0 0 2 4 this 3 1461  5 other 1 1461  </span>
<span class="s0">77 0 0 4 82 1420 0 0 0 1 4 this 3 1463  </span>
<span class="s0">78 0 0 4 83 1420 0 0 0 2 4 this 3 1464  3 out 1 1432  </span>
<span class="s0">79 0 0 15 104 1466 770 0 0 1 4 copy 1 1418  </span>
<span class="s0">80 0 0 55 104 1466 770 0 0 1 6 source 1 1421  </span>
<span class="s0">81 0 0 23 104 1466 770 0 0 1 11 type_handle 5 1467  </span>
<span class="s0">82 0 0 7 105 1466 770 0 0 2 1 n 1 1351  11 type_handle 5 1467  </span>
<span class="s0">83 0 0 4 106 1420 0 0 0 1 4 this 3 1466  </span>
<span class="s0">84 0 0 6 107 1351 0 0 0 1 4 this 3 1418  </span>
<span class="s0">85 0 0 4 108 1420 0 0 0 2 4 this 3 1466  1 x 1 1403  </span>
<span class="s0">86 0 0 4 109 1420 0 0 0 1 4 this 3 1466  </span>
<span class="s0">87 0 0 6 110 1403 0 0 0 2 4 this 3 1418  1 n 1 1351  </span>
<span class="s0">88 0 0 4 111 1420 0 0 0 3 4 this 3 1466  1 n 1 1351  5 value 1 1403  </span>
<span class="s0">89 0 0 38 112 1403 0 0 0 2 4 this 3 1418  1 n 1 1351  </span>
<span class="s0">90 0 0 36 113 1420 0 0 0 3 4 this 3 1466  1 n 1 1351  5 value 1 1403  </span>
<span class="s0">91 0 0 38 114 1421 0 0 0 1 4 this 3 1418  </span>
<span class="s0">92 0 0 36 115 1420 0 0 0 2 4 this 3 1466  4 data 1 1421  </span>
<span class="s0">93 0 0 38 116 1421 0 0 0 3 4 this 3 1418  1 n 1 1351  5 count 1 1351  </span>
<span class="s0">94 0 0 4 117 1420 0 0 0 4 4 this 3 1466  1 n 1 1351  5 count 1 1351  4 data 1 1469  </span>
<span class="s0">95 0 0 6 118 1353 0 0 0 1 4 this 3 1418  </span>
<span class="s0">96 0 0 6 119 1353 0 0 0 1 4 this 3 1418  </span>
<span class="s0">97 0 0 6 120 1351 0 0 0 2 4 this 3 1418  6 param0 0 1403  </span>
<span class="s0">98 0 0 38 121 1421 0 0 0 1 4 this 3 1418  </span>
<span class="s0">99 0 0 38 122 1353 0 0 0 3 4 this 3 1466  4 view 1 1424  5 flags 1 1353  </span>
<span class="s0">100 0 0 36 123 1420 0 0 0 2 4 this 3 1418  4 view 1 1424  </span>
<span class="s0">101 0 0 39 124 1466 770 0 0 2 4 this 3 1418  4 memo 1 1421  </span>
<span class="s0">102 0 0 15 128 1470 792 0 0 1 4 copy 1 1438  </span>
<span class="s0">103 0 0 55 128 1470 792 0 0 1 6 source 1 1421  </span>
<span class="s0">104 0 0 23 128 1470 792 0 0 1 11 type_handle 5 1467  </span>
<span class="s0">105 0 0 7 129 1470 792 0 0 2 1 n 1 1351  11 type_handle 5 1467  </span>
<span class="s0">106 0 0 4 130 1420 0 0 0 1 4 this 3 1470  </span>
<span class="s0">107 0 0 6 131 1351 0 0 0 1 4 this 3 1438  </span>
<span class="s0">108 0 0 4 132 1420 0 0 0 2 4 this 3 1470  1 x 1 1406  </span>
<span class="s0">109 0 0 4 133 1420 0 0 0 1 4 this 3 1470  </span>
<span class="s0">110 0 0 6 134 1406 0 0 0 2 4 this 3 1438  1 n 1 1351  </span>
<span class="s0">111 0 0 4 135 1420 0 0 0 3 4 this 3 1470  1 n 1 1351  5 value 1 1406  </span>
<span class="s0">112 0 0 38 136 1406 0 0 0 2 4 this 3 1438  1 n 1 1351  </span>
<span class="s0">113 0 0 36 137 1420 0 0 0 3 4 this 3 1470  1 n 1 1351  5 value 1 1406  </span>
<span class="s0">114 0 0 38 138 1421 0 0 0 1 4 this 3 1438  </span>
<span class="s0">115 0 0 36 139 1420 0 0 0 2 4 this 3 1470  4 data 1 1421  </span>
<span class="s0">116 0 0 38 140 1421 0 0 0 3 4 this 3 1438  1 n 1 1351  5 count 1 1351  </span>
<span class="s0">117 0 0 4 141 1420 0 0 0 4 4 this 3 1470  1 n 1 1351  5 count 1 1351  4 data 1 1469  </span>
<span class="s0">118 0 0 6 142 1353 0 0 0 1 4 this 3 1438  </span>
<span class="s0">119 0 0 6 143 1353 0 0 0 1 4 this 3 1438  </span>
<span class="s0">120 0 0 6 144 1351 0 0 0 2 4 this 3 1438  6 param0 0 1406  </span>
<span class="s0">121 0 0 38 145 1421 0 0 0 1 4 this 3 1438  </span>
<span class="s0">122 0 0 38 146 1353 0 0 0 3 4 this 3 1470  4 view 1 1424  5 flags 1 1353  </span>
<span class="s0">123 0 0 36 147 1420 0 0 0 2 4 this 3 1438  4 view 1 1424  </span>
<span class="s0">124 0 0 39 148 1470 792 0 0 2 4 this 3 1438  4 memo 1 1421  </span>
<span class="s0">125 0 0 15 152 1471 814 0 0 1 4 copy 1 1448  </span>
<span class="s0">126 0 0 55 152 1471 814 0 0 1 6 source 1 1421  </span>
<span class="s0">127 0 0 23 152 1471 814 0 0 1 11 type_handle 5 1467  </span>
<span class="s0">128 0 0 7 153 1471 814 0 0 2 1 n 1 1351  11 type_handle 5 1467  </span>
<span class="s0">129 0 0 4 154 1420 0 0 0 1 4 this 3 1471  </span>
<span class="s0">130 0 0 6 155 1351 0 0 0 1 4 this 3 1448  </span>
<span class="s0">131 0 0 4 156 1420 0 0 0 2 4 this 3 1471  1 x 1 1353  </span>
<span class="s0">132 0 0 4 157 1420 0 0 0 1 4 this 3 1471  </span>
<span class="s0">133 0 0 6 158 1353 0 0 0 2 4 this 3 1448  1 n 1 1351  </span>
<span class="s0">134 0 0 4 159 1420 0 0 0 3 4 this 3 1471  1 n 1 1351  5 value 1 1353  </span>
<span class="s0">135 0 0 38 160 1353 0 0 0 2 4 this 3 1448  1 n 1 1351  </span>
<span class="s0">136 0 0 36 161 1420 0 0 0 3 4 this 3 1471  1 n 1 1351  5 value 1 1353  </span>
<span class="s0">137 0 0 38 162 1421 0 0 0 1 4 this 3 1448  </span>
<span class="s0">138 0 0 36 163 1420 0 0 0 2 4 this 3 1471  4 data 1 1421  </span>
<span class="s0">139 0 0 38 164 1421 0 0 0 3 4 this 3 1448  1 n 1 1351  5 count 1 1351  </span>
<span class="s0">140 0 0 4 165 1420 0 0 0 4 4 this 3 1471  1 n 1 1351  5 count 1 1351  4 data 1 1469  </span>
<span class="s0">141 0 0 6 166 1353 0 0 0 1 4 this 3 1448  </span>
<span class="s0">142 0 0 6 167 1353 0 0 0 1 4 this 3 1448  </span>
<span class="s0">143 0 0 6 168 1351 0 0 0 2 4 this 3 1448  6 param0 0 1353  </span>
<span class="s0">144 0 0 38 169 1421 0 0 0 1 4 this 3 1448  </span>
<span class="s0">145 0 0 38 170 1353 0 0 0 3 4 this 3 1471  4 view 1 1424  5 flags 1 1353  </span>
<span class="s0">146 0 0 36 171 1420 0 0 0 2 4 this 3 1448  4 view 1 1424  </span>
<span class="s0">147 0 0 39 172 1471 814 0 0 2 4 this 3 1448  4 memo 1 1421  </span>
<span class="s0">148 0 0 15 176 1472 836 0 0 1 4 copy 1 1458  </span>
<span class="s0">149 0 0 55 176 1472 836 0 0 1 6 source 1 1421  </span>
<span class="s0">150 0 0 23 176 1472 836 0 0 1 11 type_handle 5 1467  </span>
<span class="s0">151 0 0 7 177 1472 836 0 0 2 1 n 1 1351  11 type_handle 5 1467  </span>
<span class="s0">152 0 0 4 178 1420 0 0 0 1 4 this 3 1472  </span>
<span class="s0">153 0 0 6 179 1351 0 0 0 1 4 this 3 1458  </span>
<span class="s0">154 0 0 4 180 1420 0 0 0 2 4 this 3 1472  1 x 1 1460  </span>
<span class="s0">155 0 0 4 181 1420 0 0 0 1 4 this 3 1472  </span>
<span class="s0">156 0 0 6 182 1460 0 0 0 2 4 this 3 1458  1 n 1 1351  </span>
<span class="s0">157 0 0 4 183 1420 0 0 0 3 4 this 3 1472  1 n 1 1351  5 value 1 1460  </span>
<span class="s0">158 0 0 38 184 1460 0 0 0 2 4 this 3 1458  1 n 1 1351  </span>
<span class="s0">159 0 0 36 185 1420 0 0 0 3 4 this 3 1472  1 n 1 1351  5 value 1 1460  </span>
<span class="s0">160 0 0 38 186 1421 0 0 0 1 4 this 3 1458  </span>
<span class="s0">161 0 0 36 187 1420 0 0 0 2 4 this 3 1472  4 data 1 1421  </span>
<span class="s0">162 0 0 38 188 1421 0 0 0 3 4 this 3 1458  1 n 1 1351  5 count 1 1351  </span>
<span class="s0">163 0 0 4 189 1420 0 0 0 4 4 this 3 1472  1 n 1 1351  5 count 1 1351  4 data 1 1469  </span>
<span class="s0">164 0 0 6 190 1353 0 0 0 1 4 this 3 1458  </span>
<span class="s0">165 0 0 6 191 1353 0 0 0 1 4 this 3 1458  </span>
<span class="s0">166 0 0 6 192 1351 0 0 0 2 4 this 3 1458  6 param0 0 1460  </span>
<span class="s0">167 0 0 38 193 1421 0 0 0 1 4 this 3 1458  </span>
<span class="s0">168 0 0 38 194 1353 0 0 0 3 4 this 3 1472  4 view 1 1424  5 flags 1 1353  </span>
<span class="s0">169 0 0 36 195 1420 0 0 0 2 4 this 3 1458  4 view 1 1424  </span>
<span class="s0">170 0 0 39 196 1472 836 0 0 2 4 this 3 1458  4 memo 1 1421  </span>
<span class="s0">171 0 0 15 233 1475 858 0 0 1 6 param0 0 1473  </span>
<span class="s0">172 0 0 6 200 1349 0 0 125 /**</span>
 <span class="s0">* Returns true if the MemoryUsage object is currently tracking memory (e.g.</span>
 <span class="s0">* track-memory-usage is configured #t).</span>
 <span class="s0">*/ 0 </span>
<span class="s0">173 0 0 6 201 1349 0 0 168 /**</span>
 <span class="s0">* Returns true if the MemoryUsage object is currently at least counting</span>
 <span class="s0">* memory (e.g.  this is a Windows debug build), even if it's not fully</span>
 <span class="s0">* tracking it.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">174 0 0 6 202 1350 0 0 136 /**</span>
 <span class="s0">* Returns the total number of bytes of allocated memory consumed by C++</span>
 <span class="s0">* objects, not including the memory previously frozen.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">175 0 0 6 203 1350 0 0 132 /**</span>
 <span class="s0">* Returns the total number of bytes of allocated memory consumed by C++</span>
 <span class="s0">* objects, including the memory previously frozen.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">176 0 0 6 204 1350 0 0 119 /**</span>
 <span class="s0">* Returns the total number of bytes allocated from the heap from code within</span>
 <span class="s0">* Panda, for individual objects.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">177 0 0 6 205 1350 0 0 107 /**</span>
 <span class="s0">* Returns the total number of bytes allocated from the heap from code within</span>
 <span class="s0">* Panda, for arrays.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">178 0 0 6 206 1350 0 0 190 /**</span>
 <span class="s0">* Returns the extra bytes allocated from the system that are not immediately</span>
 <span class="s0">* used for holding allocated objects.  This can only be determined if</span>
 <span class="s0">* ALTERNATIVE_MALLOC is enabled.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">179 0 0 6 207 1350 0 0 110 /**</span>
 <span class="s0">* Returns the total number of bytes allocated from the virtual memory pool</span>
 <span class="s0">* from code within Panda.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">180 0 0 6 208 1350 0 0 496 /**</span>
 <span class="s0">* Returns the total number of bytes of allocated memory in the heap that</span>
 <span class="s0">* Panda didn't seem to be responsible for.  This includes a few bytes for</span>
 <span class="s0">* very low-level objects (like ConfigVariables) that cannot use Panda memory</span>
 <span class="s0">* tracking because they are so very low-level.</span>
 <span class="s0">*</span>
 <span class="s0">* This also includes all of the memory that might have been allocated by a</span>
 <span class="s0">* high-level interpreter, like Python.</span>
 <span class="s0">*</span>
 <span class="s0">* This number is only available if Panda is able to hook into the actual heap</span>
 <span class="s0">* callback.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">181 0 0 6 209 1350 0 0 113 /**</span>
 <span class="s0">* Returns the total size of allocated memory consumed by the process, as</span>
 <span class="s0">* nearly as can be determined.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">182 0 0 6 210 1353 0 0 59 /**</span>
 <span class="s0">* Returns the number of pointers currently active.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">183 0 0 4 211 1420 0 0 100 /**</span>
 <span class="s0">* Fills the indicated MemoryUsagePointers with the set of all pointers</span>
 <span class="s0">* currently active.</span>
 <span class="s0">*/ 1 6 result 1 1476  </span>
<span class="s0">184 0 0 4 212 1420 0 0 122 /**</span>
 <span class="s0">* Fills the indicated MemoryUsagePointers with the set of all pointers of the</span>
 <span class="s0">* indicated type currently active.</span>
 <span class="s0">*/ 2 6 result 1 1476  4 type 1 1467  </span>
<span class="s0">185 0 0 4 213 1420 0 0 159 /**</span>
 <span class="s0">* Fills the indicated MemoryUsagePointers with the set of all pointers that</span>
 <span class="s0">* were allocated within the range of the indicated number of seconds ago.</span>
 <span class="s0">*/ 3 6 result 1 1476  4 from 1 1403  2 to 1 1403  </span>
<span class="s0">186 0 0 4 214 1420 0 0 852 /**</span>
 <span class="s0">* Fills the indicated MemoryUsagePointers with the set of all currently</span>
 <span class="s0">* active pointers (that is, pointers allocated since the last call to</span>
 <span class="s0">* freeze(), and not yet freed) that have a zero reference count.</span>
 <span class="s0">*</span>
 <span class="s0">* Generally, an undeleted pointer with a zero reference count means its</span>
 <span class="s0">* reference count has never been incremented beyond zero (since once it has</span>
 <span class="s0">* been incremented, the only way it can return to zero would free the</span>
 <span class="s0">* pointer).  This may include objects that are allocated statically or on the</span>
 <span class="s0">* stack, which are never intended to be deleted.  Or, it might represent a</span>
 <span class="s0">* programmer or compiler error.</span>
 <span class="s0">*</span>
 <span class="s0">* This function has the side-effect of incrementing each of their reference</span>
 <span class="s0">* counts by one, thus preventing them from ever being freed--but since they</span>
 <span class="s0">* hadn't been freed anyway, probably no additional harm is done.</span>
 <span class="s0">*/ 1 6 result 1 1476  </span>
<span class="s0">187 0 0 4 215 1420 0 0 285 /**</span>
 <span class="s0">* 'Freezes' all pointers currently stored so that they are no longer</span>
 <span class="s0">* reported; only newly allocate pointers from this point on will appear in</span>
 <span class="s0">* future information requests.  This makes it easier to differentiate between</span>
 <span class="s0">* continuous leaks and one-time memory allocations.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">188 0 0 4 216 1420 0 0 70 /**</span>
 <span class="s0">* Shows the breakdown of types of all of the active pointers.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">189 0 0 4 217 1420 0 0 118 /**</span>
 <span class="s0">* Shows the breakdown of types of all of the pointers allocated and freed</span>
 <span class="s0">* since the last call to freeze().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">190 0 0 4 218 1420 0 0 69 /**</span>
 <span class="s0">* Shows the breakdown of ages of all of the active pointers.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">191 0 0 4 219 1420 0 0 117 /**</span>
 <span class="s0">* Shows the breakdown of ages of all of the pointers allocated and freed</span>
 <span class="s0">* since the last call to freeze().</span>
 <span class="s0">*/ 0 </span>
<span class="s0">192 0 0 6 239 1353 0 0 47 /**</span>
 <span class="s0">* Returns the current reference count.</span>
 <span class="s0">*/ 1 4 this 3 1477  </span>
<span class="s0">193 0 0 4 240 1420 0 0 538 /**</span>
 <span class="s0">* Explicitly increments the reference count.  User code should avoid using</span>
 <span class="s0">* ref() and unref() directly, which can result in missed reference counts.</span>
 <span class="s0">* Instead, let a PointerTo object manage the reference counting</span>
 <span class="s0">* automatically.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is const, even though it changes the object, because</span>
 <span class="s0">* generally fiddling with an object's reference count isn't considered part</span>
 <span class="s0">* of fiddling with the object.  An object might be const in other ways, but</span>
 <span class="s0">* we still need to accurately count the number of references to it.</span>
 <span class="s0">*/ 1 4 this 3 1477  </span>
<span class="s0">194 0 0 6 241 1349 0 0 865 /**</span>
 <span class="s0">* Explicitly decrements the reference count.  Note that the object will not</span>
 <span class="s0">* be implicitly deleted by unref() simply because the reference count drops</span>
 <span class="s0">* to zero.  (Having a member function delete itself is problematic.) However,</span>
 <span class="s0">* see the helper function unref_delete().</span>
 <span class="s0">*</span>
 <span class="s0">* User code should avoid using ref() and unref() directly, which can result</span>
 <span class="s0">* in missed reference counts.  Instead, let a PointerTo object manage the</span>
 <span class="s0">* reference counting automatically.</span>
 <span class="s0">*</span>
 <span class="s0">* This function is const, even though it changes the object, because</span>
 <span class="s0">* generally fiddling with an object's reference count isn't considered part</span>
 <span class="s0">* of fiddling with the object.  An object might be const in other ways, but</span>
 <span class="s0">* we still need to accurately count the number of references to it.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the new reference count is nonzero, false if it</span>
 <span class="s0">* is zero.</span>
 <span class="s0">*/ 1 4 this 3 1477  </span>
<span class="s0">195 0 0 6 244 1349 0 0 135 /**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't</span>
 <span class="s0">* completely bogus.  Returns true if ok, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 1477  </span>
<span class="s0">196 0 0 6 245 1349 0 0 144 /**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't zero, or</span>
 <span class="s0">* completely bogus.  Returns true if ok, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 1477  </span>
<span class="s0">197 0 0 7 246 1467 0 0 0 0 </span>
<span class="s0">198 0 0 6 236 1480 0 0 0 1 4 this 3 1479  </span>
<span class="s0">199 0 0 15 249 1483 861 0 0 1 6 param0 0 1481  </span>
<span class="s0">200 0 0 6 248 1353 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 1481  </span>
<span class="s0">201 0 0 4 258 1420 0 0 0 2 4 this 3 1484  5 level 1 1403  </span>
<span class="s0">202 0 0 6 260 1353 0 0 47 /**</span>
 <span class="s0">* Returns the current reference count.</span>
 <span class="s0">*/ 1 4 this 3 1485  </span>
<span class="s0">203 0 0 4 261 1420 0 0 107 /**</span>
 <span class="s0">* Explicitly increments the node reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*/ 1 4 this 3 1485  </span>
<span class="s0">204 0 0 6 262 1349 0 0 201 /**</span>
 <span class="s0">* Explicitly decrements the node reference count and the normal reference</span>
 <span class="s0">* count simultaneously.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if the new reference count is nonzero, false if it</span>
 <span class="s0">* is zero.</span>
 <span class="s0">*/ 1 4 this 3 1485  </span>
<span class="s0">205 0 0 6 263 1349 0 0 97 /**</span>
 <span class="s0">* Does some easy checks to make sure that the reference count isn't</span>
 <span class="s0">* completely bogus.</span>
 <span class="s0">*/ 1 4 this 3 1485  </span>
<span class="s0">206 0 0 4 264 1420 0 0 186 /**</span>
 <span class="s0">* Decrements the node reference count without affecting the normal reference</span>
 <span class="s0">* count.  Intended to be called by derived classes only, presumably to</span>
 <span class="s0">* reimplement node_unref().</span>
 <span class="s0">*/ 1 4 this 3 1485  </span>
<span class="s0">207 0 0 7 265 1467 0 0 0 0 </span>
<span class="s0">208 0 0 7 268 1487 0 0 0 0 </span>
<span class="s0">209 0 0 15 268 1487 0 0 0 1 4 copy 1 1488  </span>
<span class="s0">210 0 0 7 268 1487 0 0 64 /**</span>
 <span class="s0">* Constructs a datagram from an existing block of data.</span>
 <span class="s0">*/ 1 4 data 1 1490  </span>
<span class="s0">211 0 0 6 269 1487 0 0 0 2 4 this 3 1487  4 copy 1 1488  </span>
<span class="s0">212 0 0 4 270 1420 0 0 90 /**</span>
 <span class="s0">* Resets the datagram to empty, in preparation for building up a new</span>
 <span class="s0">* datagram.</span>
 <span class="s0">*/ 1 4 this 3 1487  </span>
<span class="s0">213 0 0 4 271 1420 0 0 111 /**</span>
 <span class="s0">* Writes a representation of the entire datagram contents, as a sequence of</span>
 <span class="s0">* hex (and ASCII) values.</span>
 <span class="s0">*/ 3 4 this 3 1488  3 out 1 1432  6 indent 5 1492  </span>
<span class="s0">214 0 0 4 272 1420 0 0 48 /**</span>
 <span class="s0">* Adds a boolean value to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1349  </span>
<span class="s0">215 0 0 4 273 1420 0 0 55 /**</span>
 <span class="s0">* Adds a signed 8-bit integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1493  </span>
<span class="s0">216 0 0 4 274 1420 0 0 58 /**</span>
 <span class="s0">* Adds an unsigned 8-bit integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1495  </span>
<span class="s0">217 0 0 4 275 1420 0 0 56 /**</span>
 <span class="s0">* Adds a signed 16-bit integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1496  </span>
<span class="s0">218 0 0 4 276 1420 0 0 56 /**</span>
 <span class="s0">* Adds a signed 32-bit integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1498  </span>
<span class="s0">219 0 0 4 277 1420 0 0 56 /**</span>
 <span class="s0">* Adds a signed 64-bit integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1499  </span>
<span class="s0">220 0 0 4 278 1420 0 0 59 /**</span>
 <span class="s0">* Adds an unsigned 16-bit integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1500  </span>
<span class="s0">221 0 0 4 279 1420 0 0 59 /**</span>
 <span class="s0">* Adds an unsigned 32-bit integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1502  </span>
<span class="s0">222 0 0 4 280 1420 0 0 59 /**</span>
 <span class="s0">* Adds an unsigned 64-bit integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1503  </span>
<span class="s0">223 0 0 4 281 1420 0 0 197 /**</span>
 <span class="s0">* Adds a 32-bit single-precision floating-point number to the datagram.</span>
 <span class="s0">* Since this kind of float is not necessarily portable across different</span>
 <span class="s0">* architectures, special care is required.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1504  </span>
<span class="s0">224 0 0 4 282 1420 0 0 63 /**</span>
 <span class="s0">* Adds a 64-bit floating-point number to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1505  </span>
<span class="s0">225 0 0 4 283 1420 0 0 105 /**</span>
 <span class="s0">* Adds either a 32-bit or a 64-bit floating-point number, according to</span>
 <span class="s0">* set_stdfloat_double().</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1405  </span>
<span class="s0">226 0 0 4 284 1420 0 0 67 // These functions pack numbers big-endian, in case that's desired. 2 4 this 3 1487  5 value 1 1496  </span>
<span class="s0">227 0 0 4 285 1420 0 0 67 /**</span>
 <span class="s0">* Adds a signed 32-bit big-endian integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1498  </span>
<span class="s0">228 0 0 4 286 1420 0 0 67 /**</span>
 <span class="s0">* Adds a signed 64-bit big-endian integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1499  </span>
<span class="s0">229 0 0 4 287 1420 0 0 70 /**</span>
 <span class="s0">* Adds an unsigned 16-bit big-endian integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1500  </span>
<span class="s0">230 0 0 4 288 1420 0 0 70 /**</span>
 <span class="s0">* Adds an unsigned 32-bit big-endian integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1502  </span>
<span class="s0">231 0 0 4 289 1420 0 0 70 /**</span>
 <span class="s0">* Adds an unsigned 64-bit big-endian integer to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1503  </span>
<span class="s0">232 0 0 4 290 1420 0 0 94 /**</span>
 <span class="s0">* Adds a 32-bit single-precision big-endian floating-point number to the</span>
 <span class="s0">* datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1504  </span>
<span class="s0">233 0 0 4 291 1420 0 0 74 /**</span>
 <span class="s0">* Adds a 64-bit big-endian floating-point number to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  5 value 1 1505  </span>
<span class="s0">234 0 0 4 292 1420 0 0 109 /**</span>
 <span class="s0">* Adds a variable-length string to the datagram.  This actually adds a count</span>
 <span class="s0">* followed by n bytes.</span>
 <span class="s0">*/ 2 4 this 3 1487  3 str 1 1469  </span>
<span class="s0">235 0 0 4 293 1420 0 0 116 /**</span>
 <span class="s0">* Adds a variable-length string to the datagram, using a 32-bit length field</span>
 <span class="s0">* to allow very long strings.</span>
 <span class="s0">*/ 2 4 this 3 1487  3 str 1 1469  </span>
<span class="s0">236 0 0 4 294 1420 0 0 86 /**</span>
 <span class="s0">* Adds a variable-length string to the datagram, as a NULL-terminated string.</span>
 <span class="s0">*/ 2 4 this 3 1487  3 str 1 1469  </span>
<span class="s0">237 0 0 4 295 1420 0 0 238 /**</span>
 <span class="s0">* Adds a fixed-length string to the datagram.  If the string given is less</span>
 <span class="s0">* than the requested size, this will pad the string out with zeroes; if it is</span>
 <span class="s0">* greater than the requested size, this will silently truncate the string.</span>
 <span class="s0">*/ 3 4 this 3 1487  3 str 1 1469  4 size 1 1350  </span>
<span class="s0">238 0 0 4 296 1420 0 0 58 /**</span>
 <span class="s0">* Adds a variable-length wstring to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  3 str 1 1469  </span>
<span class="s0">239 0 0 4 297 1420 0 0 114 /**</span>
 <span class="s0">* Adds a variable-length binary blob to the datagram.  This actually adds a</span>
 <span class="s0">* count followed by n bytes.</span>
 <span class="s0">*/ 2 4 this 3 1487  6 param0 0 1490  </span>
<span class="s0">240 0 0 4 298 1420 0 0 119 /**</span>
 <span class="s0">* Adds a variable-length binary blob to the datagram, using a 32-bit length</span>
 <span class="s0">* field to allow very long blobs.</span>
 <span class="s0">*/ 2 4 this 3 1487  6 param0 0 1490  </span>
<span class="s0">241 0 0 4 299 1420 0 0 67 /**</span>
 <span class="s0">* Adds the indicated number of zero bytes to the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  4 size 1 1350  </span>
<span class="s0">242 0 0 4 300 1420 0 0 65 /**</span>
 <span class="s0">* Appends some more raw data to the end of the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1487  4 data 1 1490  </span>
<span class="s0">243 0 0 38 301 1421 0 0 51 /**</span>
 <span class="s0">* Returns the datagram's data as a string.</span>
 <span class="s0">*/ 1 4 this 3 1488  </span>
<span class="s0">244 0 0 38 302 1421 0 0 0 1 4 this 3 1488  </span>
<span class="s0">245 0 0 38 303 1421 0 0 0 1 4 this 3 1488  </span>
<span class="s0">246 0 0 6 304 1350 0 0 55 /**</span>
 <span class="s0">* Returns the number of bytes in the datagram.</span>
 <span class="s0">*/ 1 4 this 3 1488  </span>
<span class="s0">247 0 0 4 305 1420 0 0 199 /**</span>
 <span class="s0">* Replaces the data in the Datagram with the data in the indicated PTA_uchar.</span>
 <span class="s0">* This is assignment by reference: subsequent changes to the Datagram will</span>
 <span class="s0">* also change the source PTA_uchar.</span>
 <span class="s0">*/ 2 4 this 3 1487  4 data 1 1506  </span>
<span class="s0">248 0 0 4 306 1420 0 0 237 /**</span>
 <span class="s0">* Replaces the data in the Datagram with a copy of the data in the indicated</span>
 <span class="s0">* CPTA_uchar.  Unlike set_array(), a complete copy is made of the data;</span>
 <span class="s0">* subsequent changes to the Datagram will *not* change the source CPTA_uchar.</span>
 <span class="s0">*/ 2 4 this 3 1487  4 data 1 1507  </span>
<span class="s0">249 0 0 7 307 1507 0 0 70 /**</span>
 <span class="s0">* Returns a const pointer to the actual data in the Datagram.</span>
 <span class="s0">*/ 1 4 this 3 1488  </span>
<span class="s0">250 0 0 7 308 1506 0 0 75 /**</span>
 <span class="s0">* Returns a modifiable pointer to the actual data in the Datagram.</span>
 <span class="s0">*/ 1 4 this 3 1487  </span>
<span class="s0">251 0 0 4 309 1420 0 0 343 /**</span>
 <span class="s0">* Changes the stdfloat_double flag, which defines the operation performed by</span>
 <span class="s0">* add_stdfloat() and DatagramIterator::get_stdfloat().  When this is true,</span>
 <span class="s0">* add_stdfloat() adds a 64-bit floating-point number; when it is false, it</span>
 <span class="s0">* adds a 32-bit floating-point number.  The default is based on the</span>
 <span class="s0">* STDFLOAT_DOUBLE compilation flag.</span>
 <span class="s0">*/ 2 4 this 3 1487  15 stdfloat_double 1 1349  </span>
<span class="s0">252 0 0 6 310 1349 0 0 72 /**</span>
 <span class="s0">* Returns the stdfloat_double flag.  See set_stdfloat_double().</span>
 <span class="s0">*/ 1 4 this 3 1488  </span>
<span class="s0">253 0 0 6 311 1349 0 0 0 2 4 this 3 1488  5 other 1 1488  </span>
<span class="s0">254 0 0 6 312 1349 0 0 0 2 4 this 3 1488  5 other 1 1488  </span>
<span class="s0">255 0 0 6 313 1349 0 0 0 2 4 this 3 1488  5 other 1 1488  </span>
<span class="s0">256 0 0 4 314 1420 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 2 4 this 3 1488  3 out 1 1432  </span>
<span class="s0">257 0 0 4 315 1420 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 3 4 this 3 1488  3 out 1 1432  6 indent 5 1492  </span>
<span class="s0">258 0 0 7 316 1467 0 0 0 0 </span>
<span class="s0">259 0 0 6 319 1349 0 0 0 2 4 this 3 1508  4 data 1 1487  </span>
<span class="s0">260 0 0 6 320 1349 0 0 391 /**</span>
 <span class="s0">* Skips over the next datagram without extracting it, but saves the relevant</span>
 <span class="s0">* file information in the SubfileInfo object so that its data may be read</span>
 <span class="s0">* later.  For non-file-based datagram generators, this may mean creating a</span>
 <span class="s0">* temporary file and copying the contents of the datagram to disk.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure or if this method is</span>
 <span class="s0">* unimplemented.</span>
 <span class="s0">*/ 2 4 this 3 1508  4 info 1 1509  </span>
<span class="s0">261 0 0 6 321 1349 0 0 0 1 4 this 3 1508  </span>
<span class="s0">262 0 0 6 322 1349 0 0 0 1 4 this 3 1508  </span>
<span class="s0">263 0 0 6 323 1510 0 0 159 /**</span>
 <span class="s0">* Returns the filename that provides the source for these datagrams, if any,</span>
 <span class="s0">* or empty string if the datagrams do not originate from a file on disk.</span>
 <span class="s0">*/ 1 4 this 3 1508  </span>
<span class="s0">264 0 0 6 324 1513 0 0 138 /**</span>
 <span class="s0">* Returns the on-disk timestamp of the file that was read, at the time it was</span>
 <span class="s0">* opened, if that is available, or 0 if it is not.</span>
 <span class="s0">*/ 1 4 this 3 1511  </span>
<span class="s0">265 0 0 7 325 1364 0 0 156 /**</span>
 <span class="s0">* Returns the FileReference that provides the source for these datagrams, if</span>
 <span class="s0">* any, or NULL if the datagrams do not originate from a file on disk.</span>
 <span class="s0">*/ 1 4 this 3 1508  </span>
<span class="s0">266 0 0 7 326 1515 1190 0 153 /**</span>
 <span class="s0">* Returns the VirtualFile that provides the source for these datagrams, if</span>
 <span class="s0">* any, or NULL if the datagrams do not originate from a VirtualFile.</span>
 <span class="s0">*/ 1 4 this 3 1508  </span>
<span class="s0">267 0 0 6 327 1368 0 0 327 /**</span>
 <span class="s0">* Returns the current file position within the data stream, if any, or 0 if</span>
 <span class="s0">* the file position is not meaningful or cannot be determined.</span>
 <span class="s0">*</span>
 <span class="s0">* For DatagramGenerators that return a meaningful file position, this will be</span>
 <span class="s0">* pointing to the first byte following the datagram returned after a call to</span>
 <span class="s0">* get_datagram().</span>
 <span class="s0">*/ 1 4 this 3 1508  </span>
<span class="s0">268 0 0 7 329 1516 980 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">269 0 0 23 329 1516 980 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 8 datagram 1 1488  6 offset 5 1350  </span>
<span class="s0">270 0 0 15 329 1516 980 0 0 1 6 param0 0 1517  </span>
<span class="s0">271 0 0 6 330 1349 0 0 36 /**</span>
 <span class="s0">* Extracts a boolean value.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">272 0 0 6 331 1493 0 0 43 /**</span>
 <span class="s0">* Extracts a signed 8-bit integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">273 0 0 6 332 1495 0 0 46 /**</span>
 <span class="s0">* Extracts an unsigned 8-bit integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">274 0 0 6 333 1496 0 0 44 /**</span>
 <span class="s0">* Extracts a signed 16-bit integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">275 0 0 6 334 1498 0 0 44 /**</span>
 <span class="s0">* Extracts a signed 32-bit integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">276 0 0 6 335 1499 0 0 44 /**</span>
 <span class="s0">* Extracts a signed 64-bit integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">277 0 0 6 336 1500 0 0 47 /**</span>
 <span class="s0">* Extracts an unsigned 16-bit integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">278 0 0 6 337 1502 0 0 47 /**</span>
 <span class="s0">* Extracts an unsigned 32-bit integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">279 0 0 6 338 1503 0 0 47 /**</span>
 <span class="s0">* Extracts an unsigned 64-bit integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">280 0 0 6 339 1504 0 0 68 /**</span>
 <span class="s0">* Extracts a 32-bit single-precision floating-point number.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">281 0 0 6 340 1505 0 0 51 /**</span>
 <span class="s0">* Extracts a 64-bit floating-point number.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">282 0 0 6 341 1405 0 0 119 /**</span>
 <span class="s0">* Extracts either a 32-bit or a 64-bit floating-point number, according to</span>
 <span class="s0">* Datagram::set_stdfloat_double().</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">283 0 0 6 342 1496 0 0 55 /**</span>
 <span class="s0">* Extracts a signed 16-bit big-endian integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">284 0 0 6 343 1498 0 0 55 /**</span>
 <span class="s0">* Extracts a signed 32-bit big-endian integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">285 0 0 6 344 1499 0 0 55 /**</span>
 <span class="s0">* Extracts a signed 64-bit big-endian integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">286 0 0 6 345 1500 0 0 58 /**</span>
 <span class="s0">* Extracts an unsigned 16-bit big-endian integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">287 0 0 6 346 1502 0 0 58 /**</span>
 <span class="s0">* Extracts an unsigned 32-bit big-endian integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">288 0 0 6 347 1503 0 0 58 /**</span>
 <span class="s0">* Extracts an unsigned 64-bit big-endian integer.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">289 0 0 6 348 1504 0 0 79 /**</span>
 <span class="s0">* Extracts a 32-bit big-endian single-precision floating-point number.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">290 0 0 6 349 1505 0 0 62 /**</span>
 <span class="s0">* Extracts a 64-bit big-endian floating-point number.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">291 0 0 6 350 1469 0 0 45 /**</span>
 <span class="s0">* Extracts a variable-length string.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">292 0 0 6 351 1469 0 0 72 /**</span>
 <span class="s0">* Extracts a variable-length string with a 32-bit length field.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">293 0 0 6 352 1469 0 0 74 /**</span>
 <span class="s0">* Extracts a variable-length string, as a NULL-terminated string.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">294 0 0 6 353 1469 0 0 128 /**</span>
 <span class="s0">* Extracts a fixed-length string.  However, if a zero byte occurs within the</span>
 <span class="s0">* string, it marks the end of the string.</span>
 <span class="s0">*/ 2 4 this 3 1516  4 size 1 1350  </span>
<span class="s0">295 0 0 6 354 1469 0 0 75 /**</span>
 <span class="s0">* Extracts a variable-length wstring (with a 32-bit length field).</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">296 0 0 6 355 1490 0 0 50 /**</span>
 <span class="s0">* Extracts a variable-length binary blob.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">297 0 0 6 356 1490 0 0 75 /**</span>
 <span class="s0">* Extracts a variable-length binary blob with a 32-bit size field.</span>
 <span class="s0">*/ 1 4 this 3 1516  </span>
<span class="s0">298 0 0 4 357 1420 0 0 68 /**</span>
 <span class="s0">* Skips over the indicated number of bytes in the datagram.</span>
 <span class="s0">*/ 2 4 this 3 1516  4 size 1 1350  </span>
<span class="s0">299 0 0 6 358 1490 0 0 98 /**</span>
 <span class="s0">* Extracts the indicated number of bytes in the datagram and returns them as</span>
 <span class="s0">* a string.</span>
 <span class="s0">*/ 2 4 this 3 1516  4 size 1 1350  </span>
<span class="s0">300 0 0 6 359 1490 0 0 115 /**</span>
 <span class="s0">* Returns the remaining bytes in the datagram as a string, but does not</span>
 <span class="s0">* extract them from the iterator.</span>
 <span class="s0">*/ 1 4 this 3 1517  </span>
<span class="s0">301 0 0 6 360 1350 0 0 49 /**</span>
 <span class="s0">* Return the bytes left in the datagram.</span>
 <span class="s0">*/ 1 4 this 3 1517  </span>
<span class="s0">302 0 0 6 361 1488 0 0 48 /**</span>
 <span class="s0">* Return the datagram of this iterator.</span>
 <span class="s0">*/ 1 4 this 3 1517  </span>
<span class="s0">303 0 0 6 362 1350 0 0 100 /**</span>
 <span class="s0">* Returns the current position within the datagram of the next piece of data</span>
 <span class="s0">* to extract.</span>
 <span class="s0">*/ 1 4 this 3 1517  </span>
<span class="s0">304 0 0 4 363 1420 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 2 4 this 3 1517  3 out 1 1432  </span>
<span class="s0">305 0 0 4 364 1420 0 0 67 /**</span>
 <span class="s0">* Write a string representation of this instance to &lt;out&gt;.</span>
 <span class="s0">*/ 3 4 this 3 1517  3 out 1 1432  6 indent 5 1492  </span>
<span class="s0">306 0 0 7 365 1467 0 0 0 0 </span>
<span class="s0">307 0 0 6 369 1349 0 0 0 2 4 this 3 1519  4 data 1 1488  </span>
<span class="s0">308 0 0 6 370 1349 0 0 349 /**</span>
 <span class="s0">* Copies the file data from the entire indicated file (via the vfs) as the</span>
 <span class="s0">* next datagram.  This is intended to support potentially very large</span>
 <span class="s0">* datagrams.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure or if this method is</span>
 <span class="s0">* unimplemented.  On true, fills &quot;result&quot; with the information that</span>
 <span class="s0">* references the copied file, if possible.</span>
 <span class="s0">*/ 3 4 this 3 1519  6 result 1 1509  8 filename 1 1510  </span>
<span class="s0">309 0 0 6 370 1349 0 0 362 /**</span>
 <span class="s0">* Copies the file data from the range of the indicated file (outside of the</span>
 <span class="s0">* vfs) as the next datagram.  This is intended to support potentially very</span>
 <span class="s0">* large datagrams.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure or if this method is</span>
 <span class="s0">* unimplemented.  On true, fills &quot;result&quot; with the information that</span>
 <span class="s0">* references the copied file, if possible.</span>
 <span class="s0">*/ 3 4 this 3 1519  6 result 1 1509  6 source 1 1520  </span>
<span class="s0">310 0 0 6 371 1349 0 0 0 1 4 this 3 1519  </span>
<span class="s0">311 0 0 4 372 1420 0 0 0 1 4 this 3 1519  </span>
<span class="s0">312 0 0 6 373 1510 0 0 159 /**</span>
 <span class="s0">* Returns the filename that provides the target for these datagrams, if any,</span>
 <span class="s0">* or empty string if the datagrams do not get written to a file on disk.</span>
 <span class="s0">*/ 1 4 this 3 1519  </span>
<span class="s0">313 0 0 7 374 1364 0 0 152 /**</span>
 <span class="s0">* Returns the FileReference that provides the target for these datagrams, if</span>
 <span class="s0">* any, or NULL if the datagrams do not written to a file on disk.</span>
 <span class="s0">*/ 1 4 this 3 1519  </span>
<span class="s0">314 0 0 6 375 1368 0 0 322 /**</span>
 <span class="s0">* Returns the current file position within the data stream, if any, or 0 if</span>
 <span class="s0">* the file position is not meaningful or cannot be determined.</span>
 <span class="s0">*</span>
 <span class="s0">* For DatagramSinks that return a meaningful file position, this will be</span>
 <span class="s0">* pointing to the first byte following the datagram returned after a call to</span>
 <span class="s0">* put_datagram().</span>
 <span class="s0">*/ 1 4 this 3 1519  </span>
<span class="s0">315 0 0 15 390 1522 998 0 0 1 6 param0 0 1364  </span>
<span class="s0">316 0 0 23 390 1522 998 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 8 filename 1 1510  </span>
<span class="s0">317 0 0 6 391 1510 0 0 49 /**</span>
 <span class="s0">* Returns the filename of the reference.</span>
 <span class="s0">*/ 1 4 this 3 1364  </span>
<span class="s0">318 0 0 7 392 1467 0 0 0 0 </span>
<span class="s0">319 0 0 7 388 1467 0 0 0 0 </span>
<span class="s0">320 0 0 6 384 1524 0 0 0 1 4 this 3 1523  </span>
<span class="s0">321 0 0 7 386 1479 861 0 0 1 4 this 3 1523  </span>
<span class="s0">322 0 0 7 409 1525 1018 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">323 0 0 15 409 1525 1018 0 0 1 6 param0 0 1526  </span>
<span class="s0">324 0 0 4 410 1420 0 0 130 /**</span>
 <span class="s0">* Moves the data pointer to the indicated byte position.  It is not an error</span>
 <span class="s0">* to move the pointer past the end of data.</span>
 <span class="s0">*/ 2 4 this 3 1525  3 pos 1 1350  </span>
<span class="s0">325 0 0 6 411 1350 0 0 106 /**</span>
 <span class="s0">* Returns the current data pointer position as a byte offset from the</span>
 <span class="s0">* beginning of the stream.</span>
 <span class="s0">*/ 1 4 this 3 1526  </span>
<span class="s0">326 0 0 38 412 1421 0 0 319 /**</span>
 <span class="s0">* Extracts and returns the indicated number of characters from the current</span>
 <span class="s0">* data pointer, and advances the data pointer.  If the data pointer exceeds</span>
 <span class="s0">* the end of the buffer, returns empty string.</span>
 <span class="s0">*</span>
 <span class="s0">* The interface here is intentionally designed to be similar to that for</span>
 <span class="s0">* Python's file.read() function.</span>
 <span class="s0">*/ 2 4 this 3 1525  6 length 1 1350  </span>
<span class="s0">327 0 0 38 413 1421 0 0 303 /**</span>
 <span class="s0">* Assumes the stream represents a text file, and extracts one line up to and</span>
 <span class="s0">* including the trailing newline character.  Returns empty string when the</span>
 <span class="s0">* end of file is reached.</span>
 <span class="s0">*</span>
 <span class="s0">* The interface here is intentionally designed to be similar to that for</span>
 <span class="s0">* Python's file.readline() function.</span>
 <span class="s0">*/ 1 4 this 3 1525  </span>
<span class="s0">328 0 0 38 414 1421 0 0 0 1 4 this 3 1525  </span>
<span class="s0">329 0 0 38 415 1421 0 0 101 /**</span>
 <span class="s0">* Returns the entire buffer contents as a string, regardless of the current</span>
 <span class="s0">* data pointer.</span>
 <span class="s0">*/ 1 4 this 3 1526  </span>
<span class="s0">330 0 0 6 416 1350 0 0 58 /**</span>
 <span class="s0">* Returns the size of the entire buffer contents.</span>
 <span class="s0">*/ 1 4 this 3 1526  </span>
<span class="s0">331 0 0 4 417 1420 0 0 47 /**</span>
 <span class="s0">* Empties the current buffer contents.</span>
 <span class="s0">*/ 1 4 this 3 1525  </span>
<span class="s0">332 0 0 7 420 1528 1049 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">333 0 0 15 420 1528 1049 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 1529  </span>
<span class="s0">334 0 0 6 421 1528 0 0 0 2 4 this 3 1528  4 copy 1 1529  </span>
<span class="s0">335 0 0 6 422 1349 0 0 0 2 4 this 3 1529  5 other 1 1529  </span>
<span class="s0">336 0 0 6 423 1349 0 0 0 2 4 this 3 1529  5 other 1 1529  </span>
<span class="s0">337 0 0 6 424 1349 0 0 0 2 4 this 3 1529  5 other 1 1529  </span>
<span class="s0">338 0 0 6 425 1353 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1529  5 other 1 1529  </span>
<span class="s0">339 0 0 4 426 1420 0 0 86 /**</span>
 <span class="s0">* Generates a new HashVal representing the xor of this one and the other one.</span>
 <span class="s0">*/ 2 4 this 3 1528  5 other 1 1529  </span>
<span class="s0">340 0 0 4 427 1420 0 0 65 /**</span>
 <span class="s0">* Outputs the HashVal as four unsigned decimal integers.</span>
 <span class="s0">*/ 2 4 this 3 1529  3 out 1 1432  </span>
<span class="s0">341 0 0 4 428 1420 0 0 64 /**</span>
 <span class="s0">* Inputs the HashVal as four unsigned decimal integers.</span>
 <span class="s0">*/ 2 4 this 3 1528  2 in 1 1530  </span>
<span class="s0">342 0 0 4 429 1420 0 0 64 /**</span>
 <span class="s0">* Outputs the HashVal as a 32-digit hexadecimal number.</span>
 <span class="s0">*/ 2 4 this 3 1529  3 out 1 1432  </span>
<span class="s0">343 0 0 4 430 1420 0 0 63 /**</span>
 <span class="s0">* Inputs the HashVal as a 32-digit hexadecimal number.</span>
 <span class="s0">*/ 2 4 this 3 1528  2 in 1 1530  </span>
<span class="s0">344 0 0 4 431 1420 0 0 128 /**</span>
 <span class="s0">* Outputs the HashVal as a binary stream of bytes in order.  This is not the</span>
 <span class="s0">* same order generated by write_stream().</span>
 <span class="s0">*/ 2 4 this 3 1529  3 out 1 1432  </span>
<span class="s0">345 0 0 4 432 1420 0 0 125 /**</span>
 <span class="s0">* Inputs the HashVal as a binary stream of bytes in order.  This is not the</span>
 <span class="s0">* same order expected by read_stream().</span>
 <span class="s0">*/ 2 4 this 3 1528  2 in 1 1530  </span>
<span class="s0">346 0 0 4 433 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1529  3 out 1 1432  </span>
<span class="s0">347 0 0 6 434 1469 0 0 69 /**</span>
 <span class="s0">* Returns the HashVal as a string with four decimal numbers.</span>
 <span class="s0">*/ 1 4 this 3 1529  </span>
<span class="s0">348 0 0 6 435 1349 0 0 112 /**</span>
 <span class="s0">* Sets the HashVal from a string with four decimal numbers.  Returns true if</span>
 <span class="s0">* valid, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 1528  4 text 1 1469  </span>
<span class="s0">349 0 0 6 436 1469 0 0 63 /**</span>
 <span class="s0">* Returns the HashVal as a 32-byte hexadecimal string.</span>
 <span class="s0">*/ 1 4 this 3 1529  </span>
<span class="s0">350 0 0 6 437 1349 0 0 111 /**</span>
 <span class="s0">* Sets the HashVal from a 32-byte hexademical string.  Returns true if</span>
 <span class="s0">* successful, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 1528  4 text 1 1469  </span>
<span class="s0">351 0 0 6 438 1490 0 0 58 /**</span>
 <span class="s0">* Returns the HashVal as a 16-byte binary string.</span>
 <span class="s0">*/ 1 4 this 3 1529  </span>
<span class="s0">352 0 0 6 439 1349 0 0 106 /**</span>
 <span class="s0">* Sets the HashVal from a 16-byte binary string.  Returns true if successful,</span>
 <span class="s0">* false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 1528  4 text 1 1490  </span>
<span class="s0">353 0 0 4 440 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1529  11 destination 1 1487  </span>
<span class="s0">354 0 0 4 441 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1528  6 source 1 1516  </span>
<span class="s0">355 0 0 4 442 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1529  11 destination 1 1531  </span>
<span class="s0">356 0 0 4 443 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1528  6 source 1 1533  </span>
<span class="s0">357 0 0 6 444 1349 0 0 232 /**</span>
 <span class="s0">* Generates the hash value from the indicated file.  Returns true on success,</span>
 <span class="s0">* false if the file cannot be read.  This method is only defined if we have</span>
 <span class="s0">* the OpenSSL library (which provides md5 functionality) available.</span>
 <span class="s0">*/ 2 4 this 3 1528  8 filename 1 1510  </span>
<span class="s0">358 0 0 6 445 1349 0 0 232 /**</span>
 <span class="s0">* Generates the hash value from the indicated file.  Returns true on success,</span>
 <span class="s0">* false if the file cannot be read.  This method is only defined if we have</span>
 <span class="s0">* the OpenSSL library (which provides md5 functionality) available.</span>
 <span class="s0">*/ 2 4 this 3 1528  6 stream 1 1530  </span>
<span class="s0">359 0 0 4 446 1420 0 0 178 /**</span>
 <span class="s0">* Generates the hash value by hashing the indicated data.  This method is</span>
 <span class="s0">* only defined if we have the OpenSSL library (which provides md5</span>
 <span class="s0">* functionality) available.</span>
 <span class="s0">*/ 2 4 this 3 1528  7 ramfile 1 1526  </span>
<span class="s0">360 0 0 4 447 1420 0 0 178 /**</span>
 <span class="s0">* Generates the hash value by hashing the indicated data.  This method is</span>
 <span class="s0">* only defined if we have the OpenSSL library (which provides md5</span>
 <span class="s0">* functionality) available.</span>
 <span class="s0">*/ 2 4 this 3 1528  4 data 1 1469  </span>
<span class="s0">361 0 0 4 448 1420 0 0 178 /**</span>
 <span class="s0">* Generates the hash value by hashing the indicated data.  This method is</span>
 <span class="s0">* only defined if we have the OpenSSL library (which provides md5</span>
 <span class="s0">* functionality) available.</span>
 <span class="s0">*/ 2 4 this 3 1528  4 data 1 1490  </span>
<span class="s0">362 0 0 4 449 1420 0 0 178 /**</span>
 <span class="s0">* Generates the hash value by hashing the indicated data.  This method is</span>
 <span class="s0">* only defined if we have the OpenSSL library (which provides md5</span>
 <span class="s0">* functionality) available.</span>
 <span class="s0">*/ 3 4 this 3 1528  6 buffer 1 1469  6 length 1 1353  </span>
<span class="s0">363 0 0 7 452 1476 1051 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">364 0 0 15 452 1476 1051 0 0 1 6 param0 0 1535  </span>
<span class="s0">365 0 0 6 454 1350 0 0 53 /**</span>
 <span class="s0">* Returns the number of pointers in the set.</span>
 <span class="s0">*/ 1 4 this 3 1535  </span>
<span class="s0">366 0 0 7 455 1479 861 0 46 /**</span>
 <span class="s0">* Returns the nth pointer of the set.</span>
 <span class="s0">*/ 2 4 this 3 1535  1 n 1 1350  </span>
<span class="s0">367 0 0 6 457 1524 0 0 175 /**</span>
 <span class="s0">* Returns the nth pointer of the set, typecast to a TypedObject if possible.</span>
 <span class="s0">* If the pointer is not a TypedObject or if the cast cannot be made, returns</span>
 <span class="s0">* nullptr.</span>
 <span class="s0">*/ 2 4 this 3 1535  1 n 1 1350  </span>
<span class="s0">368 0 0 7 459 1467 0 0 70 /**</span>
 <span class="s0">* Returns the actual type of the nth pointer, if it is known.</span>
 <span class="s0">*/ 2 4 this 3 1535  1 n 1 1350  </span>
<span class="s0">369 0 0 6 460 1469 0 0 68 /**</span>
 <span class="s0">* Returns the type name of the nth pointer, if it is known.</span>
 <span class="s0">*/ 2 4 this 3 1535  1 n 1 1350  </span>
<span class="s0">370 0 0 6 461 1403 0 0 197 /**</span>
 <span class="s0">* Returns the age of the nth pointer: the number of seconds elapsed between</span>
 <span class="s0">* the time it was allocated and the time it was added to this set via a call</span>
 <span class="s0">* to MemoryUsage::get_pointers().</span>
 <span class="s0">*/ 2 4 this 3 1535  1 n 1 1350  </span>
<span class="s0">371 0 0 38 462 1421 0 0 0 2 4 this 3 1535  1 n 1 1350  </span>
<span class="s0">372 0 0 4 463 1420 0 0 39 /**</span>
 <span class="s0">* Empties the set of pointers.</span>
 <span class="s0">*/ 1 4 this 3 1476  </span>
<span class="s0">373 0 0 4 464 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1535  3 out 1 1432  </span>
<span class="s0">374 0 0 7 467 1537 1064 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">375 0 0 7 467 1537 1064 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 6 source 1 1538  5 start 1 1368  3 end 1 1368  </span>
<span class="s0">376 0 0 6 468 1537 0 0 391 /**</span>
 <span class="s0">* Starts the SubStream reading from the indicated source, with the first</span>
 <span class="s0">* character being the character at position &quot;start&quot; within the source, for</span>
 <span class="s0">* end - start total characters.  The character at &quot;end&quot; within the source</span>
 <span class="s0">* will never be read; this will appear to be EOF.</span>
 <span class="s0">*</span>
 <span class="s0">* If end is zero, it indicates that the ISubStream will continue until the</span>
 <span class="s0">* end of the source stream.</span>
 <span class="s0">*/ 4 4 this 3 1537  6 source 1 1538  5 start 1 1368  3 end 1 1368  </span>
<span class="s0">377 0 0 6 469 1537 0 0 92 /**</span>
 <span class="s0">* Resets the SubStream to empty, but does not actually close the source</span>
 <span class="s0">* istream.</span>
 <span class="s0">*/ 1 4 this 3 1537  </span>
<span class="s0">378 0 0 7 473 1540 1068 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">379 0 0 7 473 1540 1068 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 dest 1 1541  5 start 1 1368  3 end 1 1368  6 append 5 1349  </span>
<span class="s0">380 0 0 6 474 1540 0 0 383 /**</span>
 <span class="s0">* Starts the SubStream reading from the indicated dest, with the first</span>
 <span class="s0">* character being the character at position &quot;start&quot; within the dest, for end</span>
 <span class="s0">* - start total characters.  The character at &quot;end&quot; within the dest will</span>
 <span class="s0">* never be read; this will appear to be EOF.</span>
 <span class="s0">*</span>
 <span class="s0">* If end is zero, it indicates that the OSubStream will continue until the</span>
 <span class="s0">* end of the dest stream.</span>
 <span class="s0">*/ 5 4 this 3 1540  4 dest 1 1541  5 start 1 1368  3 end 1 1368  6 append 5 1349  </span>
<span class="s0">381 0 0 6 475 1540 0 0 90 /**</span>
 <span class="s0">* Resets the SubStream to empty, but does not actually close the dest</span>
 <span class="s0">* ostream.</span>
 <span class="s0">*/ 1 4 this 3 1540  </span>
<span class="s0">382 0 0 7 479 1543 1072 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">383 0 0 7 479 1543 1072 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 6 nested 1 1544  5 start 1 1368  3 end 1 1368  6 append 5 1349  </span>
<span class="s0">384 0 0 6 480 1543 0 0 278 /**</span>
 <span class="s0">* Starts the SubStream reading and writing from the indicated nested stream,</span>
 <span class="s0">* within the indicated range.  &quot;end&quot; is the first character outside of the</span>
 <span class="s0">* range.</span>
 <span class="s0">*</span>
 <span class="s0">* If end is zero, it indicates that the SubStream will continue until the end</span>
 <span class="s0">* of the nested stream.</span>
 <span class="s0">*/ 5 4 this 3 1543  6 nested 1 1544  5 start 1 1368  3 end 1 1368  6 append 5 1349  </span>
<span class="s0">385 0 0 6 481 1543 0 0 92 /**</span>
 <span class="s0">* Resets the SubStream to empty, but does not actually close the nested</span>
 <span class="s0">* ostream.</span>
 <span class="s0">*/ 1 4 this 3 1543  </span>
<span class="s0">386 0 0 7 484 1546 861 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">387 0 0 6 485 1349 0 0 352 /**</span>
 <span class="s0">* Opens the named Multifile on disk for reading.  The Multifile index is read</span>
 <span class="s0">* in, and the list of subfiles becomes available; individual subfiles may</span>
 <span class="s0">* then be extracted or read, but the list of subfiles may not be modified.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see the version of open_read() which accepts an istream.  Returns true</span>
 <span class="s0">* on success, false on failure.</span>
 <span class="s0">*/ 3 4 this 3 1546  14 multifile_name 1 1510  6 offset 5 1368  </span>
<span class="s0">388 0 0 6 485 1349 0 0 333 /**</span>
 <span class="s0">* Opens an anonymous Multifile for reading using an istream.  There must be</span>
 <span class="s0">* seek functionality via seekg() and tellg() on the istream.</span>
 <span class="s0">*</span>
 <span class="s0">* If owns_pointer is true, then the Multifile assumes ownership of the stream</span>
 <span class="s0">* pointer and will delete it when the multifile is closed, including if this</span>
 <span class="s0">* function returns false.</span>
 <span class="s0">*/ 4 4 this 3 1546  16 multifile_stream 1 1538  12 owns_pointer 5 1349  6 offset 5 1368  </span>
<span class="s0">389 0 0 6 486 1349 0 0 420 /**</span>
 <span class="s0">* Opens the named Multifile on disk for writing.  If there already exists a</span>
 <span class="s0">* file by that name, it is truncated.  The Multifile is then prepared for</span>
 <span class="s0">* accepting a brand new set of subfiles, which will be written to the</span>
 <span class="s0">* indicated filename.  Individual subfiles may not be extracted or read.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see the version of open_write() which accepts an ostream.  Returns</span>
 <span class="s0">* true on success, false on failure.</span>
 <span class="s0">*/ 2 4 this 3 1546  14 multifile_name 1 1510  </span>
<span class="s0">390 0 0 6 486 1349 0 0 333 /**</span>
 <span class="s0">* Opens an anonymous Multifile for writing using an ostream.  There must be</span>
 <span class="s0">* seek functionality via seekp() and tellp() on the pstream.</span>
 <span class="s0">*</span>
 <span class="s0">* If owns_pointer is true, then the Multifile assumes ownership of the stream</span>
 <span class="s0">* pointer and will delete it when the multifile is closed, including if this</span>
 <span class="s0">* function returns false.</span>
 <span class="s0">*/ 3 4 this 3 1546  16 multifile_stream 1 1432  12 owns_pointer 5 1349  </span>
<span class="s0">391 0 0 6 487 1349 0 0 360 /**</span>
 <span class="s0">* Opens the named Multifile on disk for reading and writing.  If there</span>
 <span class="s0">* already exists a file by that name, its index is read.  Subfiles may be</span>
 <span class="s0">* added or removed, and the resulting changes will be written to the named</span>
 <span class="s0">* file.</span>
 <span class="s0">*</span>
 <span class="s0">* Also see the version of open_read_write() which accepts an iostream.</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/ 2 4 this 3 1546  14 multifile_name 1 1510  </span>
<span class="s0">392 0 0 6 487 1349 0 0 365 /**</span>
 <span class="s0">* Opens an anonymous Multifile for reading and writing using an iostream.</span>
 <span class="s0">* There must be seek functionality via seekg()/seekp() and tellg()/tellp() on</span>
 <span class="s0">* the iostream.</span>
 <span class="s0">*</span>
 <span class="s0">* If owns_pointer is true, then the Multifile assumes ownership of the stream</span>
 <span class="s0">* pointer and will delete it when the multifile is closed, including if this</span>
 <span class="s0">* function returns false.</span>
 <span class="s0">*/ 3 4 this 3 1546  16 multifile_stream 1 1547  12 owns_pointer 5 1349  </span>
<span class="s0">393 0 0 4 488 1420 0 0 169 /**</span>
 <span class="s0">* Closes the Multifile if it is open.  All changes are flushed to disk, and</span>
 <span class="s0">* the file becomes invalid for further operations until the next call to</span>
 <span class="s0">* open().</span>
 <span class="s0">*/ 1 4 this 3 1546  </span>
<span class="s0">394 0 0 6 489 1510 0 0 69 /**</span>
 <span class="s0">* Returns the filename of the Multifile, if it is available.</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">395 0 0 4 490 1420 0 0 209 /**</span>
 <span class="s0">* Replaces the filename of the Multifile.  This is primarily used for</span>
 <span class="s0">* documentation purposes only; changing this name does not open the indicated</span>
 <span class="s0">* file.  See open_read() or open_write() for that.</span>
 <span class="s0">*/ 2 4 this 3 1546  14 multifile_name 1 1510  </span>
<span class="s0">396 0 0 6 491 1349 0 0 154 /**</span>
 <span class="s0">* Returns true if the Multifile has been opened for read mode and there have</span>
 <span class="s0">* been no errors, and individual Subfile contents may be extracted.</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">397 0 0 6 492 1349 0 0 162 /**</span>
 <span class="s0">* Returns true if the Multifile has been opened for write mode and there have</span>
 <span class="s0">* been no errors, and Subfiles may be added or removed from the Multifile.</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">398 0 0 6 493 1349 0 0 118 /**</span>
 <span class="s0">* Returns true if the Multifile index is suboptimal and should be repacked.</span>
 <span class="s0">* Call repack() to achieve this.</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">399 0 0 6 494 1513 0 0 299 /**</span>
 <span class="s0">* Returns the modification timestamp of the overall Multifile.  This</span>
 <span class="s0">* indicates the most recent date at which subfiles were added or removed from</span>
 <span class="s0">* the Multifile.  Note that it is logically possible for an individual</span>
 <span class="s0">* subfile to have a more recent timestamp than the overall timestamp.</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">400 0 0 4 495 1420 0 0 206 /**</span>
 <span class="s0">* Changes the overall mudification timestamp of the multifile.  Note that this</span>
 <span class="s0">* will be reset to the current time every time you modify a subfile.</span>
 <span class="s0">* Only set this if you know what you are doing!</span>
 <span class="s0">*/ 2 4 this 3 1546  9 timestamp 1 1513  </span>
<span class="s0">401 0 0 4 496 1420 0 0 529 /**</span>
 <span class="s0">* Sets the flag indicating whether timestamps should be recorded within the</span>
 <span class="s0">* Multifile or not.  The default is true, indicating the Multifile will</span>
 <span class="s0">* record timestamps for the overall file and also for each subfile.</span>
 <span class="s0">*</span>
 <span class="s0">* If this is false, the Multifile will not record timestamps internally.  In</span>
 <span class="s0">* this case, the return value from get_timestamp() or get_subfile_timestamp()</span>
 <span class="s0">* will be estimations.</span>
 <span class="s0">*</span>
 <span class="s0">* You may want to set this false to minimize the bitwise difference between</span>
 <span class="s0">* independently-generated Multifiles.</span>
 <span class="s0">*/ 2 4 this 3 1546  16 record_timestamp 1 1349  </span>
<span class="s0">402 0 0 6 497 1349 0 0 137 /**</span>
 <span class="s0">* Returns the flag indicating whether timestamps should be recorded within</span>
 <span class="s0">* the Multifile or not.  See set_record_timestamp().</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">403 0 0 4 498 1420 0 0 782 /**</span>
 <span class="s0">* Changes the internal scale factor for this Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* This is normally 1, but it may be set to any arbitrary value (greater than</span>
 <span class="s0">* zero) to support Multifile archives that exceed 4GB, if necessary.</span>
 <span class="s0">* (Individual subfiles may still not exceed 4GB.)</span>
 <span class="s0">*</span>
 <span class="s0">* All addresses within the file are rounded up to the next multiple of</span>
 <span class="s0">* _scale_factor, and zeros are written to the file to fill the resulting</span>
 <span class="s0">* gaps.  Then the address is divided by _scale_factor and written out as a</span>
 <span class="s0">* 32-bit integer.  Thus, setting a scale factor of 2 supports up to 8GB</span>
 <span class="s0">* files, 3 supports 12GB files, etc.</span>
 <span class="s0">*</span>
 <span class="s0">* Calling this function on an already-existing Multifile will have no</span>
 <span class="s0">* immediate effect until a future call to repack() or close() (or until the</span>
 <span class="s0">* Multifile is destructed).</span>
 <span class="s0">*/ 2 4 this 3 1546  12 scale_factor 1 1350  </span>
<span class="s0">404 0 0 6 499 1350 0 0 92 /**</span>
 <span class="s0">* Returns the internal scale factor for this Multifile.  See</span>
 <span class="s0">* set_scale_factor().</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">405 0 0 4 500 1420 0 0 461 /**</span>
 <span class="s0">* Sets the flag indicating whether subsequently-added subfiles should be</span>
 <span class="s0">* encrypted before writing them to the multifile.  If true, subfiles will be</span>
 <span class="s0">* encrypted; if false (the default), they will be written without encryption.</span>
 <span class="s0">*</span>
 <span class="s0">* When true, subfiles will be encrypted with the password specified by</span>
 <span class="s0">* set_encryption_password().  It is possible to apply a different password to</span>
 <span class="s0">* different files, but the resulting file can't be mounted via VFS.</span>
 <span class="s0">*/ 2 4 this 3 1546  4 flag 1 1349  </span>
<span class="s0">406 0 0 6 501 1349 0 0 163 /**</span>
 <span class="s0">* Returns the flag indicating whether subsequently-added subfiles should be</span>
 <span class="s0">* encrypted before writing them to the multifile.  See set_encryption_flag().</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">407 0 0 4 502 1420 0 0 369 /**</span>
 <span class="s0">* Specifies the password that will be used to encrypt subfiles subsequently</span>
 <span class="s0">* added to the multifile, if the encryption flag is also set true (see</span>
 <span class="s0">* set_encryption_flag()).</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible to apply a different password to different files, but the</span>
 <span class="s0">* resulting file can't be mounted via VFS.  Changing this value may cause an</span>
 <span class="s0">* implicit call to flush().</span>
 <span class="s0">*/ 2 4 this 3 1546  19 encryption_password 1 1469  </span>
<span class="s0">408 0 0 6 503 1469 0 0 141 /**</span>
 <span class="s0">* Returns the password that will be used to encrypt subfiles subsequently</span>
 <span class="s0">* added to the multifile.  See set_encryption_password().</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">409 0 0 4 504 1420 0 0 659 /**</span>
 <span class="s0">* Specifies the encryption algorithm that should be used for future calls to</span>
 <span class="s0">* add_subfile().  The default is whatever is specified by the encryption-</span>
 <span class="s0">* algorithm config variable.  The complete set of available algorithms is</span>
 <span class="s0">* defined by the current version of OpenSSL.</span>
 <span class="s0">*</span>
 <span class="s0">* If an invalid algorithm is specified, there is no immediate error return</span>
 <span class="s0">* code, but flush() will fail and the file will be invalid.</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible to apply a different encryption algorithm to different</span>
 <span class="s0">* files, and unlike the password, this does not interfere with mounting the</span>
 <span class="s0">* multifile via VFS.  Changing this value may cause an implicit call to</span>
 <span class="s0">* flush().</span>
 <span class="s0">*/ 2 4 this 3 1546  20 encryption_algorithm 1 1469  </span>
<span class="s0">410 0 0 6 505 1469 0 0 96 /**</span>
 <span class="s0">* Returns the encryption algorithm that was specified by</span>
 <span class="s0">* set_encryption_algorithm().</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">411 0 0 4 506 1420 0 0 611 /**</span>
 <span class="s0">* Specifies the length of the key, in bits, that should be used to encrypt</span>
 <span class="s0">* the stream in future calls to add_subfile().  The default is whatever is</span>
 <span class="s0">* specified by the encryption-key-length config variable.</span>
 <span class="s0">*</span>
 <span class="s0">* If an invalid key_length for the chosen algorithm is specified, there is no</span>
 <span class="s0">* immediate error return code, but flush() will fail and the file will be</span>
 <span class="s0">* invalid.</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible to apply a different key length to different files, and</span>
 <span class="s0">* unlike the password, this does not interfere with mounting the multifile</span>
 <span class="s0">* via VFS. Changing this value may cause an implicit call to flush().</span>
 <span class="s0">*/ 2 4 this 3 1546  21 encryption_key_length 1 1353  </span>
<span class="s0">412 0 0 6 507 1353 0 0 108 /**</span>
 <span class="s0">* Returns the encryption key length, in bits, that was specified by</span>
 <span class="s0">* set_encryption_key_length().</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">413 0 0 4 508 1420 0 0 740 /**</span>
 <span class="s0">* Specifies the number of times to repeatedly hash the key before writing it</span>
 <span class="s0">* to the stream in future calls to add_subfile().  Its purpose is to make it</span>
 <span class="s0">* computationally more expensive for an attacker to search the key space</span>
 <span class="s0">* exhaustively.  This should be a multiple of 1,000 and should not exceed</span>
 <span class="s0">* about 65 million; the value 0 indicates just one application of the hashing</span>
 <span class="s0">* algorithm.</span>
 <span class="s0">*</span>
 <span class="s0">* The default is whatever is specified by the multifile-encryption-iteration-</span>
 <span class="s0">* count config variable.</span>
 <span class="s0">*</span>
 <span class="s0">* It is possible to apply a different iteration count to different files, and</span>
 <span class="s0">* unlike the password, this does not interfere with mounting the multifile</span>
 <span class="s0">* via VFS.  Changing this value causes an implicit call to flush().</span>
 <span class="s0">*/ 2 4 this 3 1546  26 encryption_iteration_count 1 1353  </span>
<span class="s0">414 0 0 6 509 1353 0 0 84 /**</span>
 <span class="s0">* Returns the value that was specified by set_encryption_iteration_count().</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">415 0 0 6 510 1469 0 0 618 /**</span>
 <span class="s0">* Adds a file on disk as a subfile to the Multifile.  The file named by</span>
 <span class="s0">* filename will be read and added to the Multifile at the next call to</span>
 <span class="s0">* flush().  If there already exists a subfile with the indicated name, it is</span>
 <span class="s0">* replaced without examining its contents (but see also update_subfile).</span>
 <span class="s0">*</span>
 <span class="s0">* Either Filename:::set_binary() or set_text() must have been called</span>
 <span class="s0">* previously to specify the nature of the source file.  If set_text() was</span>
 <span class="s0">* called, the text flag will be set on the subfile.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the subfile name on success (it might have been modified slightly),</span>
 <span class="s0">* or empty string on failure.</span>
 <span class="s0">*/ 4 4 this 3 1546  12 subfile_name 1 1469  8 filename 1 1510  17 compression_level 1 1353  </span>
<span class="s0">416 0 0 6 510 1469 0 0 777 /**</span>
 <span class="s0">* Adds a file from a stream as a subfile to the Multifile.  The indicated</span>
 <span class="s0">* istream will be read and its contents added to the Multifile at the next</span>
 <span class="s0">* call to flush(). The file will be added as a binary subfile.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the istream must remain untouched and unused by any other code</span>
 <span class="s0">* until flush() is called.  At that time, the Multifile will read the entire</span>
 <span class="s0">* contents of the istream from the current file position to the end of the</span>
 <span class="s0">* file.  Subsequently, the Multifile will *not* close or delete the istream.</span>
 <span class="s0">* It is the caller's responsibility to ensure that the istream pointer does</span>
 <span class="s0">* not destruct during the lifetime of the Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the subfile name on success (it might have been modified slightly),</span>
 <span class="s0">* or empty string on failure.</span>
 <span class="s0">*/ 4 4 this 3 1546  12 subfile_name 1 1469  12 subfile_data 1 1530  17 compression_level 1 1353  </span>
<span class="s0">417 0 0 6 511 1469 0 0 451 /**</span>
 <span class="s0">* Adds a file on disk to the subfile.  If a subfile already exists with the</span>
 <span class="s0">* same name, its contents are compared byte-for-byte to the disk file, and it</span>
 <span class="s0">* is replaced only if it is different; otherwise, the multifile is left</span>
 <span class="s0">* unchanged.</span>
 <span class="s0">*</span>
 <span class="s0">* Either Filename:::set_binary() or set_text() must have been called</span>
 <span class="s0">* previously to specify the nature of the source file.  If set_text() was</span>
 <span class="s0">* called, the text flag will be set on the subfile.</span>
 <span class="s0">*/ 4 4 this 3 1546  12 subfile_name 1 1469  8 filename 1 1510  17 compression_level 1 1353  </span>
<span class="s0">418 0 0 6 512 1349 0 0 1292 /**</span>
 <span class="s0">* Adds a new signature to the Multifile.  This signature associates the</span>
 <span class="s0">* indicated certificate with the current contents of the Multifile.  When the</span>
 <span class="s0">* Multifile is read later, the signature will still be present only if the</span>
 <span class="s0">* Multifile is unchanged; any subsequent changes to the Multifile will</span>
 <span class="s0">* automatically invalidate and remove the signature.</span>
 <span class="s0">*</span>
 <span class="s0">* The chain filename may be empty if the certificate does not require an</span>
 <span class="s0">* authenticating certificate chain (e.g.  because it is self-signed).</span>
 <span class="s0">*</span>
 <span class="s0">* The specified private key must match the certificate, and the Multifile</span>
 <span class="s0">* must be open in read-write mode.  The private key is only used for</span>
 <span class="s0">* generating the signature; it is not written to the Multifile and cannot be</span>
 <span class="s0">* retrieved from the Multifile later.  (However, the certificate *can* be</span>
 <span class="s0">* retrieved from the Multifile later, to identify the entity that created the</span>
 <span class="s0">* signature.)</span>
 <span class="s0">*</span>
 <span class="s0">* This implicitly causes a repack() operation if one is needed.  Returns true</span>
 <span class="s0">* on success, false on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of add_signature() reads the certificate and private key from a</span>
 <span class="s0">* PEM-formatted file, for instance as generated by the openssl command.  If</span>
 <span class="s0">* the private key file is password-encrypted, the third parameter will be</span>
 <span class="s0">* used as the password to decrypt it.</span>
 <span class="s0">*/ 5 4 this 3 1546  11 certificate 1 1510  5 chain 1 1510  4 pkey 1 1510  8 password 5 1469  </span>
<span class="s0">419 0 0 6 512 1349 0 0 724 /**</span>
 <span class="s0">* Adds a new signature to the Multifile.  This signature associates the</span>
 <span class="s0">* indicated certificate with the current contents of the Multifile.  When the</span>
 <span class="s0">* Multifile is read later, the signature will still be present only if the</span>
 <span class="s0">* Multifile is unchanged; any subsequent changes to the Multifile will</span>
 <span class="s0">* automatically invalidate and remove the signature.</span>
 <span class="s0">*</span>
 <span class="s0">* This flavor of add_signature() reads the certificate, private key, and</span>
 <span class="s0">* certificate chain from the same PEM-formatted file.  It takes the first</span>
 <span class="s0">* private key found as the intended key, and then uses the first certificate</span>
 <span class="s0">* found that matches that key as the signing certificate.  Any other</span>
 <span class="s0">* certificates in the file are taken to be part of the chain.</span>
 <span class="s0">*/ 3 4 this 3 1546  9 composite 1 1510  8 password 5 1469  </span>
<span class="s0">420 0 0 6 513 1353 0 0 555 /**</span>
 <span class="s0">* Returns the number of matching signatures found on the Multifile.  These</span>
 <span class="s0">* signatures may be iterated via get_signature() and related methods.</span>
 <span class="s0">*</span>
 <span class="s0">* A signature on this list is guaranteed to match the Multifile contents,</span>
 <span class="s0">* proving that the Multifile has been unmodified since the signature was</span>
 <span class="s0">* applied.  However, this does not guarantee that the certificate itself is</span>
 <span class="s0">* actually from who it says it is from; only that it matches the Multifile</span>
 <span class="s0">* contents.  See validate_signature_certificate() to authenticate a</span>
 <span class="s0">* particular certificate.</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">421 0 0 6 514 1469 0 0 352 /**</span>
 <span class="s0">* Returns the &quot;subject name&quot; for the nth signature found on the Multifile.</span>
 <span class="s0">* This is a string formatted according to RFC2253 that should more-or-less</span>
 <span class="s0">* identify a particular certificate; when paired with the public key (see</span>
 <span class="s0">* get_signature_public_key()), it can uniquely identify a certificate.  See</span>
 <span class="s0">* the comments in get_num_signatures().</span>
 <span class="s0">*/ 2 4 this 3 1548  1 n 1 1353  </span>
<span class="s0">422 0 0 6 515 1469 0 0 299 /**</span>
 <span class="s0">* Returns a &quot;friendly name&quot; for the nth signature found on the Multifile.</span>
 <span class="s0">* This attempts to extract out the most meaningful part of the subject name.</span>
 <span class="s0">* It returns the emailAddress, if it is defined; otherwise, it returns the</span>
 <span class="s0">* commonName.</span>
 <span class="s0">*</span>
 <span class="s0">* See the comments in get_num_signatures().</span>
 <span class="s0">*/ 2 4 this 3 1548  1 n 1 1353  </span>
<span class="s0">423 0 0 6 516 1469 0 0 379 /**</span>
 <span class="s0">* Returns the public key used for the nth signature found on the Multifile.</span>
 <span class="s0">* This is encoded in DER form and returned as a string of hex digits.</span>
 <span class="s0">*</span>
 <span class="s0">* This can be used, in conjunction with the subject name (see</span>
 <span class="s0">* get_signature_subject_name()), to uniquely identify a particular</span>
 <span class="s0">* certificate and its subsequent reissues.  See the comments in</span>
 <span class="s0">* get_num_signatures().</span>
 <span class="s0">*/ 2 4 this 3 1548  1 n 1 1353  </span>
<span class="s0">424 0 0 4 517 1420 0 0 158 /**</span>
 <span class="s0">* Writes the certificate for the nth signature, in user-readable verbose</span>
 <span class="s0">* form, to the indicated stream.  See the comments in get_num_signatures().</span>
 <span class="s0">*/ 3 4 this 3 1548  1 n 1 1353  3 out 1 1432  </span>
<span class="s0">425 0 0 4 518 1420 0 0 140 /**</span>
 <span class="s0">* Writes the certificate for the nth signature, in PEM form, to the indicated</span>
 <span class="s0">* stream.  See the comments in get_num_signatures().</span>
 <span class="s0">*/ 3 4 this 3 1548  1 n 1 1353  3 out 1 1432  </span>
<span class="s0">426 0 0 6 519 1353 0 0 289 /**</span>
 <span class="s0">* Checks that the certificate used for the nth signature is a valid,</span>
 <span class="s0">* authorized certificate with some known certificate authority.  Returns 0 if</span>
 <span class="s0">* it is valid, -1 if there is some error, or the corresponding OpenSSL error</span>
 <span class="s0">* code if it is invalid, out-of-date, or self-signed.</span>
 <span class="s0">*/ 2 4 this 3 1548  1 n 1 1353  </span>
<span class="s0">427 0 0 6 520 1349 0 0 691 /**</span>
 <span class="s0">* Writes all contents of the Multifile to disk.  Until flush() is called,</span>
 <span class="s0">* add_subfile() and remove_subfile() do not actually do anything to disk.  At</span>
 <span class="s0">* this point, all of the recently-added subfiles are read and their contents</span>
 <span class="s0">* are added to the end of the Multifile, and the recently-removed subfiles</span>
 <span class="s0">* are marked gone from the Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* This may result in a suboptimal index.  To guarantee that the index is</span>
 <span class="s0">* written at the beginning of the file, call repack() instead of flush().</span>
 <span class="s0">*</span>
 <span class="s0">* It is not necessary to call flush() explicitly unless you are concerned</span>
 <span class="s0">* about reading the recently-added subfiles immediately.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/ 1 4 this 3 1546  </span>
<span class="s0">428 0 0 6 521 1349 0 0 587 /**</span>
 <span class="s0">* Forces a complete rewrite of the Multifile and all of its contents, so that</span>
 <span class="s0">* its index will appear at the beginning of the file with all of the subfiles</span>
 <span class="s0">* listed in alphabetical order.  This is considered optimal for reading, and</span>
 <span class="s0">* is the standard configuration; but it is not essential to do this.</span>
 <span class="s0">*</span>
 <span class="s0">* It is only valid to call this if the Multifile was opened using</span>
 <span class="s0">* open_read_write() and an explicit filename, rather than an iostream.  Also,</span>
 <span class="s0">* we must have write permission to the directory containing the Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/ 1 4 this 3 1546  </span>
<span class="s0">429 0 0 6 522 1353 0 0 169 /**</span>
 <span class="s0">* Returns the number of subfiles within the Multifile.  The subfiles may be</span>
 <span class="s0">* accessed in alphabetical order by iterating through [0 ..</span>
 <span class="s0">* get_num_subfiles()).</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">430 0 0 6 523 1353 0 0 127 /**</span>
 <span class="s0">* Returns the index of the subfile with the indicated name, or -1 if the</span>
 <span class="s0">* named subfile is not within the Multifile.</span>
 <span class="s0">*/ 2 4 this 3 1548  12 subfile_name 1 1469  </span>
<span class="s0">431 0 0 6 524 1349 0 0 203 /**</span>
 <span class="s0">* Returns true if the indicated subfile name is the directory prefix to one</span>
 <span class="s0">* or more files within the Multifile.  That is, the Multifile contains at</span>
 <span class="s0">* least one file named &quot;subfile_name/...&quot;.</span>
 <span class="s0">*/ 2 4 this 3 1548  12 subfile_name 1 1469  </span>
<span class="s0">432 0 0 6 525 1349 0 0 420 /**</span>
 <span class="s0">* Considers subfile_name to be the name of a subdirectory within the</span>
 <span class="s0">* Multifile, but not a file itself; fills the given vector up with the sorted</span>
 <span class="s0">* list of subdirectories or files within the named directory.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that directories do not exist explicitly within a Multifile; this just</span>
 <span class="s0">* checks for the existence of files with the given initial prefix.</span>
 <span class="s0">*</span>
 <span class="s0">* Returns true if successful, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 1548  8 contents 1 1550  12 subfile_name 1 1469  </span>
<span class="s0">433 0 0 4 526 1420 0 0 435 /**</span>
 <span class="s0">* Removes the nth subfile from the Multifile.  This will cause all subsequent</span>
 <span class="s0">* index numbers to decrease by one.  The file will not actually be removed</span>
 <span class="s0">* from the disk until the next call to flush().</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this does not actually remove the data from the indicated</span>
 <span class="s0">* subfile; it simply removes it from the index.  The Multifile will not be</span>
 <span class="s0">* reduced in size after this operation, until the next call to repack().</span>
 <span class="s0">*/ 2 4 this 3 1546  5 index 1 1353  </span>
<span class="s0">434 0 0 6 526 1349 0 0 475 /**</span>
 <span class="s0">* Removes the named subfile from the Multifile, if it exists; returns true if</span>
 <span class="s0">* successfully removed, or false if it did not exist in the first place.  The</span>
 <span class="s0">* file will not actually be removed from the disk until the next call to</span>
 <span class="s0">* flush().</span>
 <span class="s0">*</span>
 <span class="s0">* Note that this does not actually remove the data from the indicated</span>
 <span class="s0">* subfile; it simply removes it from the index.  The Multifile will not be</span>
 <span class="s0">* reduced in size after this operation, until the next call to repack().</span>
 <span class="s0">*/ 2 4 this 3 1546  12 subfile_name 1 1469  </span>
<span class="s0">435 0 0 6 527 1469 0 0 47 /**</span>
 <span class="s0">* Returns the name of the nth subfile.</span>
 <span class="s0">*/ 2 4 this 3 1548  5 index 1 1353  </span>
<span class="s0">436 0 0 6 529 1350 0 0 170 /**</span>
 <span class="s0">* Returns the uncompressed data length of the nth subfile.  This might return</span>
 <span class="s0">* 0 if the subfile has recently been added and flush() has not yet been</span>
 <span class="s0">* called.</span>
 <span class="s0">*/ 2 4 this 3 1548  5 index 1 1353  </span>
<span class="s0">437 0 0 6 530 1513 0 0 270 /**</span>
 <span class="s0">* Returns the modification time of the nth subfile.  If this is called on an</span>
 <span class="s0">* older .mf file, which did not store individual timestamps in the file (or</span>
 <span class="s0">* if get_record_timestamp() is false), this will return the modification time</span>
 <span class="s0">* of the overall multifile.</span>
 <span class="s0">*/ 2 4 this 3 1548  5 index 1 1353  </span>
<span class="s0">438 0 0 6 531 1349 0 0 120 /**</span>
 <span class="s0">* Returns true if the indicated subfile has been compressed when stored</span>
 <span class="s0">* within the archive, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 1548  5 index 1 1353  </span>
<span class="s0">439 0 0 6 532 1349 0 0 119 /**</span>
 <span class="s0">* Returns true if the indicated subfile has been encrypted when stored within</span>
 <span class="s0">* the archive, false otherwise.</span>
 <span class="s0">*/ 2 4 this 3 1548  5 index 1 1353  </span>
<span class="s0">440 0 0 6 533 1349 0 0 343 /**</span>
 <span class="s0">* Returns true if the indicated subfile represents text data, or false if it</span>
 <span class="s0">* represents binary data.  If the file is text data, it may have been</span>
 <span class="s0">* processed by end-of-line conversion when it was added.  (But the actual</span>
 <span class="s0">* bits in the multifile will represent the standard Unix end-of-line</span>
 <span class="s0">* convention, e.g.  \n instead of \r\n.)</span>
 <span class="s0">*/ 2 4 this 3 1548  5 index 1 1353  </span>
<span class="s0">441 0 0 6 534 1368 0 0 371 /**</span>
 <span class="s0">* Returns the first byte that is guaranteed to follow any index byte already</span>
 <span class="s0">* written to disk in the Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* This number is largely meaningless in many cases, but if needs_repack() is</span>
 <span class="s0">* false, and the file is flushed, this will indicate the number of bytes in</span>
 <span class="s0">* the header + index.  Everything at this byte position and later will be</span>
 <span class="s0">* actual data.</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">442 0 0 6 535 1368 0 0 338 /**</span>
 <span class="s0">* Returns the starting byte position within the Multifile at which the</span>
 <span class="s0">* indicated subfile begins.  This may be used, with</span>
 <span class="s0">* get_subfile_internal_length(), for low-level access to the subfile, but</span>
 <span class="s0">* usually it is better to use open_read_subfile() instead (which</span>
 <span class="s0">* automatically decrypts and/or uncompresses the subfile data).</span>
 <span class="s0">*/ 2 4 this 3 1548  5 index 1 1353  </span>
<span class="s0">443 0 0 6 536 1350 0 0 322 /**</span>
 <span class="s0">* Returns the number of bytes the indicated subfile consumes within the</span>
 <span class="s0">* archive.  For compressed subfiles, this will generally be smaller than</span>
 <span class="s0">* get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be</span>
 <span class="s0">* slightly different, for noncompressed and nonencrypted subfiles, it will be</span>
 <span class="s0">* equal.</span>
 <span class="s0">*/ 2 4 this 3 1548  5 index 1 1353  </span>
<span class="s0">444 0 0 6 537 1490 0 0 96 /**</span>
 <span class="s0">* Returns a vector_uchar that contains the entire contents of the indicated</span>
 <span class="s0">* subfile.</span>
 <span class="s0">*/ 2 4 this 3 1546  5 index 1 1353  </span>
<span class="s0">445 0 0 6 538 1530 0 0 745 /**</span>
 <span class="s0">* Returns an istream that may be used to read the indicated subfile.  You may</span>
 <span class="s0">* seek() within this istream to your heart's content; even though it will be</span>
 <span class="s0">* a reference to the already-opened pfstream of the Multifile itself, byte 0</span>
 <span class="s0">* appears to be the beginning of the subfile and EOF appears to be the end of</span>
 <span class="s0">* the subfile.</span>
 <span class="s0">*</span>
 <span class="s0">* The returned istream will have been allocated via new; you should pass the</span>
 <span class="s0">* pointer to close_read_subfile() when you are finished with it to delete it</span>
 <span class="s0">* and release its resources.</span>
 <span class="s0">*</span>
 <span class="s0">* Any future calls to repack() or close() (or the Multifile destructor) will</span>
 <span class="s0">* invalidate all currently open subfile pointers.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value will be NULL if the stream cannot be opened for some</span>
 <span class="s0">* reason.</span>
 <span class="s0">*/ 2 4 this 3 1546  5 index 1 1353  </span>
<span class="s0">446 0 0 4 539 1420 0 0 246 /**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_subfile().  This</span>
 <span class="s0">* really just deletes the istream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/ 1 6 stream 1 1530  </span>
<span class="s0">447 0 0 6 540 1349 0 0 68 /**</span>
 <span class="s0">* Extracts the nth subfile into a file with the given name.</span>
 <span class="s0">*/ 3 4 this 3 1546  5 index 1 1353  8 filename 1 1510  </span>
<span class="s0">448 0 0 6 541 1349 0 0 61 /**</span>
 <span class="s0">* Extracts the nth subfile to the indicated ostream.</span>
 <span class="s0">*/ 3 4 this 3 1546  5 index 1 1353  3 out 1 1432  </span>
<span class="s0">449 0 0 6 542 1349 0 0 509 /**</span>
 <span class="s0">* Performs a byte-for-byte comparison of the indicated file on disk with the</span>
 <span class="s0">* nth subfile.  Returns true if the files are equivalent, or false if they</span>
 <span class="s0">* are different (or the file is missing).</span>
 <span class="s0">*</span>
 <span class="s0">* If Filename::set_binary() or set_text() has already been called, it</span>
 <span class="s0">* specifies the nature of the source file.  If this is different from the</span>
 <span class="s0">* text flag of the subfile, the comparison will always return false.  If this</span>
 <span class="s0">* has not been specified, it will be set from the text flag of the subfile.</span>
 <span class="s0">*/ 3 4 this 3 1546  5 index 1 1353  8 filename 1 1510  </span>
<span class="s0">450 0 0 4 543 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1548  3 out 1 1432  </span>
<span class="s0">451 0 0 4 544 1420 0 0 61 /**</span>
 <span class="s0">* Shows a list of all subfiles within the Multifile.</span>
 <span class="s0">*/ 2 4 this 3 1548  3 out 5 1432  </span>
<span class="s0">452 0 0 6 545 1469 0 0 108 /**</span>
 <span class="s0">* Returns a string with the first n bytes written to a Multifile, to identify</span>
 <span class="s0">* it as a Multifile.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">453 0 0 4 549 1420 0 0 644 /**</span>
 <span class="s0">* Sets the string which is written to the Multifile before the Multifile</span>
 <span class="s0">* header.  This string must begin with a hash mark and end with a newline</span>
 <span class="s0">* character; and if it includes embedded newline characters, each one must be</span>
 <span class="s0">* followed by a hash mark.  If these conditions are not initially true, the</span>
 <span class="s0">* string will be modified as necessary to make it so.</span>
 <span class="s0">*</span>
 <span class="s0">* This is primarily useful as a simple hack to allow p3d applications to be</span>
 <span class="s0">* run directly from the command line on Unix-like systems.</span>
 <span class="s0">*</span>
 <span class="s0">* The return value is true if successful, or false on failure (for instance,</span>
 <span class="s0">* because the header prefix violates the above rules).</span>
 <span class="s0">*/ 2 4 this 3 1546  13 header_prefix 1 1469  </span>
<span class="s0">454 0 0 6 550 1469 0 0 113 /**</span>
 <span class="s0">* Returns the string that preceded the Multifile header on the file, if any.</span>
 <span class="s0">* See set_header_prefix().</span>
 <span class="s0">*/ 1 4 this 3 1548  </span>
<span class="s0">455 0 0 15 552 1555 1143 0 0 1 6 param0 0 1553  </span>
<span class="s0">456 0 0 7 552 1555 1143 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 12 initial_name 5 1469  </span>
<span class="s0">457 0 0 4 553 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1555  4 name 1 1469  </span>
<span class="s0">458 0 0 4 554 1420 0 0 46 /**</span>
 <span class="s0">* Resets the Namable's name to empty.</span>
 <span class="s0">*/ 1 4 this 3 1555  </span>
<span class="s0">459 0 0 6 555 1349 0 0 94 /**</span>
 <span class="s0">* Returns true if the Namable has a nonempty name set, false if the name is</span>
 <span class="s0">* empty.</span>
 <span class="s0">*/ 1 4 this 3 1553  </span>
<span class="s0">460 0 0 6 556 1469 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 1553  </span>
<span class="s0">461 0 0 4 559 1420 0 0 148 /**</span>
 <span class="s0">* Outputs the Namable.  This function simply writes the name to the output</span>
 <span class="s0">* stream; most Namable derivatives will probably redefine this.</span>
 <span class="s0">*/ 2 4 this 3 1553  3 out 1 1432  </span>
<span class="s0">462 0 0 7 560 1467 0 0 0 0 </span>
<span class="s0">463 0 0 4 563 1420 0 0 200 /**</span>
 <span class="s0">* Removes all the certificates from the global store, including the compiled-</span>
 <span class="s0">* in certificates loaded from ca_bundle_data.c.  You can add new certificates</span>
 <span class="s0">* by calling load_certificates().</span>
 <span class="s0">*/ 1 4 this 3 1556  </span>
<span class="s0">464 0 0 6 564 1353 0 0 436 /**</span>
 <span class="s0">* Reads the PEM-formatted certificate(s) (delimited by -----BEGIN</span>
 <span class="s0">* CERTIFICATE----- and -----END CERTIFICATE-----) from the indicated file and</span>
 <span class="s0">* adds them to the global store object, retrieved via get_x509_store().</span>
 <span class="s0">*</span>
 <span class="s0">* Returns the number of certificates read on success, or 0 on failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/ 2 4 this 3 1556  8 filename 1 1510  </span>
<span class="s0">465 0 0 6 565 1353 0 0 376 /**</span>
 <span class="s0">* Reads a chain of trusted certificates from the indicated data buffer and</span>
 <span class="s0">* adds them to the X509_STORE object.  The data buffer should be PEM-</span>
 <span class="s0">* formatted.  Returns the number of certificates read on success, or 0 on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/ 3 4 this 3 1556  4 data 1 1469  9 data_size 1 1350  </span>
<span class="s0">466 0 0 6 565 1353 0 0 376 /**</span>
 <span class="s0">* Reads a chain of trusted certificates from the indicated data buffer and</span>
 <span class="s0">* adds them to the X509_STORE object.  The data buffer should be PEM-</span>
 <span class="s0">* formatted.  Returns the number of certificates read on success, or 0 on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/ 2 4 this 3 1556  4 data 1 1469  </span>
<span class="s0">467 0 0 6 566 1353 0 0 376 /**</span>
 <span class="s0">* Reads a chain of trusted certificates from the indicated data buffer and</span>
 <span class="s0">* adds them to the X509_STORE object.  The data buffer should be DER-</span>
 <span class="s0">* formatted.  Returns the number of certificates read on success, or 0 on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/ 3 4 this 3 1556  4 data 1 1469  9 data_size 1 1350  </span>
<span class="s0">468 0 0 6 566 1353 0 0 376 /**</span>
 <span class="s0">* Reads a chain of trusted certificates from the indicated data buffer and</span>
 <span class="s0">* adds them to the X509_STORE object.  The data buffer should be DER-</span>
 <span class="s0">* formatted.  Returns the number of certificates read on success, or 0 on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* You should call this only with trusted, locally-stored certificates; not</span>
 <span class="s0">* with certificates received from an untrusted source.</span>
 <span class="s0">*/ 2 4 this 3 1556  4 data 1 1469  </span>
<span class="s0">469 0 0 6 567 1557 0 0 378 /**</span>
 <span class="s0">* Returns the global X509_STORE object.</span>
 <span class="s0">*</span>
 <span class="s0">* It has to be a global object, because OpenSSL seems to store some global</span>
 <span class="s0">* pointers associated with this object whether you want it to or not, and</span>
 <span class="s0">* keeping independent copies of a local X509_STORE object doesn't seem to</span>
 <span class="s0">* work that well.  So, we have one store that keeps all certificates the</span>
 <span class="s0">* application might need.</span>
 <span class="s0">*/ 1 4 this 3 1556  </span>
<span class="s0">470 0 0 4 568 1420 0 0 277 /**</span>
 <span class="s0">* A convenience function that is itself a wrapper around the OpenSSL</span>
 <span class="s0">* convenience function to output the recent OpenSSL errors.  This function</span>
 <span class="s0">* sends the error string to express_cat.warning().  If REPORT_OPENSSL_ERRORS</span>
 <span class="s0">* is not defined, the function does nothing.</span>
 <span class="s0">*/ 1 4 this 3 1556  </span>
<span class="s0">471 0 0 4 569 1420 0 0 84 /**</span>
 <span class="s0">* As notify_ssl_errors(), but sends the output to debug instead of warning.</span>
 <span class="s0">*/ 1 4 this 3 1556  </span>
<span class="s0">472 0 0 6 570 1556 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">473 0 0 7 572 1509 1160 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">474 0 0 7 572 1509 1160 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 file 1 1364  5 start 1 1368  4 size 1 1560  </span>
<span class="s0">475 0 0 7 572 1509 1160 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 8 filename 1 1510  5 start 1 1368  4 size 1 1560  </span>
<span class="s0">476 0 0 15 572 1509 1160 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 1520  </span>
<span class="s0">477 0 0 6 573 1509 0 0 0 2 4 this 3 1509  4 copy 1 1520  </span>
<span class="s0">478 0 0 6 574 1349 0 0 98 /**</span>
 <span class="s0">* Returns true if this SubfileInfo doesn't define any file, false if it has</span>
 <span class="s0">* real data.</span>
 <span class="s0">*/ 1 4 this 3 1520  </span>
<span class="s0">479 0 0 7 575 1364 0 0 63 /**</span>
 <span class="s0">* Returns the FileReference that represents this file.</span>
 <span class="s0">*/ 1 4 this 3 1520  </span>
<span class="s0">480 0 0 6 576 1510 0 0 38 /**</span>
 <span class="s0">* A shortcut to the filename.</span>
 <span class="s0">*/ 1 4 this 3 1520  </span>
<span class="s0">481 0 0 6 577 1368 0 0 77 /**</span>
 <span class="s0">* Returns the offset within the file at which this file data begins.</span>
 <span class="s0">*/ 1 4 this 3 1520  </span>
<span class="s0">482 0 0 6 578 1560 0 0 115 /**</span>
 <span class="s0">* Returns the number of consecutive bytes, beginning at get_start(), that</span>
 <span class="s0">* correspond to this file data.</span>
 <span class="s0">*/ 1 4 this 3 1520  </span>
<span class="s0">483 0 0 4 579 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1520  3 out 1 1432  </span>
<span class="s0">484 0 0 6 582 1563 0 0 0 1 4 this 3 1561  </span>
<span class="s0">485 0 0 7 583 1564 0 0 0 1 4 this 3 1561  </span>
<span class="s0">486 0 0 6 584 1510 0 0 166 /**</span>
 <span class="s0">* Returns the original filename as it was used to locate this VirtualFile.</span>
 <span class="s0">* This is usually, but not always, the same string returned by</span>
 <span class="s0">* get_filename().</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">487 0 0 6 585 1349 0 0 61 /**</span>
 <span class="s0">* Returns true if this file exists, false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">488 0 0 6 586 1349 0 0 117 /**</span>
 <span class="s0">* Returns true if this file represents a directory (and scan_directory() may</span>
 <span class="s0">* be called), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">489 0 0 6 587 1349 0 0 115 /**</span>
 <span class="s0">* Returns true if this file represents a regular file (and read_file() may be</span>
 <span class="s0">* called), false otherwise.</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">490 0 0 6 588 1349 0 0 153 /**</span>
 <span class="s0">* Returns true if this file may be written to, which implies write_file() may</span>
 <span class="s0">* be called (unless it is a directory instead of a regular file).</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">491 0 0 6 589 1349 0 0 199 /**</span>
 <span class="s0">* Attempts to delete this file or directory.  This can remove a single file</span>
 <span class="s0">* or an empty directory.  It will not remove a nonempty directory.  Returns</span>
 <span class="s0">* true on success, false on failure.</span>
 <span class="s0">*/ 1 4 this 3 1515  </span>
<span class="s0">492 0 0 6 590 1349 0 0 589 /**</span>
 <span class="s0">* Attempts to move or rename this file or directory.  If the original file is</span>
 <span class="s0">* an ordinary file, it will quietly replace any already-existing file in the</span>
 <span class="s0">* new filename (but not a directory).  If the original file is a directory,</span>
 <span class="s0">* the new filename must not already exist.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is a directory, the new filename must be within the same mount</span>
 <span class="s0">* point.  If the file is an ordinary file, the new filename may be anywhere;</span>
 <span class="s0">* but if it is not within the same mount point then the rename operation is</span>
 <span class="s0">* automatically performed as a two-step copy-and-delete operation.</span>
 <span class="s0">*/ 2 4 this 3 1515  8 new_file 1 1515  </span>
<span class="s0">493 0 0 6 591 1349 0 0 123 /**</span>
 <span class="s0">* Attempts to copy the contents of this file to the indicated file.  Returns</span>
 <span class="s0">* true on success, false on failure.</span>
 <span class="s0">*/ 2 4 this 3 1515  8 new_file 1 1515  </span>
<span class="s0">494 0 0 7 592 1565 861 0 247 /**</span>
 <span class="s0">* If the file represents a directory (that is, is_directory() returns true),</span>
 <span class="s0">* this returns the list of files within the directory at the current time.</span>
 <span class="s0">* Returns NULL if the file is not a directory or if the directory cannot be</span>
 <span class="s0">* read.</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">495 0 0 4 593 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1561  3 out 1 1432  </span>
<span class="s0">496 0 0 4 594 1420 0 0 66 /**</span>
 <span class="s0">* If the file represents a directory, lists its contents.</span>
 <span class="s0">*/ 2 4 this 3 1561  3 out 5 1432  </span>
<span class="s0">497 0 0 4 595 1420 0 0 113 /**</span>
 <span class="s0">* If the file represents a directory, recursively lists its contents and</span>
 <span class="s0">* those of all subdirectories.</span>
 <span class="s0">*/ 2 4 this 3 1561  3 out 5 1432  </span>
<span class="s0">498 0 0 38 596 1421 0 0 63 /**</span>
 <span class="s0">* Returns the entire contents of the file as a string.</span>
 <span class="s0">*/ 2 4 this 3 1561  11 auto_unwrap 1 1349  </span>
<span class="s0">499 0 0 6 597 1530 0 0 179 /**</span>
 <span class="s0">* Opens the file for reading.  Returns a newly allocated istream on success</span>
 <span class="s0">* (which you should eventually delete when you are done reading). Returns</span>
 <span class="s0">* NULL on failure.</span>
 <span class="s0">*/ 2 4 this 3 1561  11 auto_unwrap 1 1349  </span>
<span class="s0">500 0 0 4 598 1420 0 0 243 /**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_file().  This really</span>
 <span class="s0">* just deletes the istream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/ 2 4 this 3 1561  6 stream 1 1530  </span>
<span class="s0">501 0 0 6 599 1349 0 0 324 /**</span>
 <span class="s0">* Call this method after a reading the istream returned by open_read_file()</span>
 <span class="s0">* to completion.  If it returns true, the file was read completely and</span>
 <span class="s0">* without error; if it returns false, there may have been some errors or a</span>
 <span class="s0">* truncated file read.  This is particularly likely if the stream is a</span>
 <span class="s0">* VirtualFileHTTP.</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">502 0 0 38 600 1421 0 0 0 3 4 this 3 1515  4 data 1 1421  9 auto_wrap 1 1349  </span>
<span class="s0">503 0 0 6 601 1432 0 0 179 /**</span>
 <span class="s0">* Opens the file for writing.  Returns a newly allocated ostream on success</span>
 <span class="s0">* (which you should eventually delete when you are done writing). Returns</span>
 <span class="s0">* NULL on failure.</span>
 <span class="s0">*/ 3 4 this 3 1515  9 auto_wrap 1 1349  8 truncate 1 1349  </span>
<span class="s0">504 0 0 6 602 1432 0 0 180 /**</span>
 <span class="s0">* Works like open_write_file(), but the file is opened in append mode.  Like</span>
 <span class="s0">* open_write_file, the returned pointer should eventually be passed to</span>
 <span class="s0">* close_write_file().</span>
 <span class="s0">*/ 1 4 this 3 1515  </span>
<span class="s0">505 0 0 4 603 1420 0 0 244 /**</span>
 <span class="s0">* Closes a file opened by a previous call to open_write_file().  This really</span>
 <span class="s0">* just deletes the ostream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/ 2 4 this 3 1515  6 stream 1 1432  </span>
<span class="s0">506 0 0 6 604 1547 0 0 180 /**</span>
 <span class="s0">* Opens the file for writing.  Returns a newly allocated iostream on success</span>
 <span class="s0">* (which you should eventually delete when you are done writing). Returns</span>
 <span class="s0">* NULL on failure.</span>
 <span class="s0">*/ 2 4 this 3 1515  8 truncate 1 1349  </span>
<span class="s0">507 0 0 6 605 1547 0 0 194 /**</span>
 <span class="s0">* Works like open_read_write_file(), but the file is opened in append mode.</span>
 <span class="s0">* Like open_read_write_file, the returned pointer should eventually be passed</span>
 <span class="s0">* to close_read_write_file().</span>
 <span class="s0">*/ 1 4 this 3 1515  </span>
<span class="s0">508 0 0 4 606 1420 0 0 250 /**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_write_file().  This</span>
 <span class="s0">* really just deletes the iostream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/ 2 4 this 3 1515  6 stream 1 1547  </span>
<span class="s0">509 0 0 6 607 1560 0 0 105 /**</span>
 <span class="s0">* Returns the current size on disk (or wherever it is) of the file before it</span>
 <span class="s0">* has been opened.</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">510 0 0 6 607 1560 0 0 222 /**</span>
 <span class="s0">* Returns the current size on disk (or wherever it is) of the already-open</span>
 <span class="s0">* file.  Pass in the stream that was returned by open_read_file(); some</span>
 <span class="s0">* implementations may require this stream to determine the size.</span>
 <span class="s0">*/ 2 4 this 3 1561  6 stream 1 1530  </span>
<span class="s0">511 0 0 6 608 1513 0 0 434 /**</span>
 <span class="s0">* Returns a time_t value that represents the time the file was last modified,</span>
 <span class="s0">* to within whatever precision the operating system records this information</span>
 <span class="s0">* (on a Windows95 system, for instance, this may only be accurate to within 2</span>
 <span class="s0">* seconds).</span>
 <span class="s0">*</span>
 <span class="s0">* If the timestamp cannot be determined, either because it is not supported</span>
 <span class="s0">* by the operating system or because there is some error (such as file not</span>
 <span class="s0">* found), returns 0.</span>
 <span class="s0">*/ 1 4 this 3 1561  </span>
<span class="s0">512 0 0 6 609 1349 0 0 330 /**</span>
 <span class="s0">* Populates the SubfileInfo structure with the data representing where the</span>
 <span class="s0">* file actually resides on disk, if this is knowable.  Returns true if the</span>
 <span class="s0">* file might reside on disk, and the info is populated, or false if it does</span>
 <span class="s0">* not (or it is not known where the file resides), in which case the info is</span>
 <span class="s0">* meaningless.</span>
 <span class="s0">*/ 2 4 this 3 1515  4 info 1 1509  </span>
<span class="s0">513 0 0 7 610 1467 0 0 0 0 </span>
<span class="s0">514 0 0 7 613 1467 0 0 0 0 </span>
<span class="s0">515 0 0 6 616 1563 0 0 68 /**</span>
 <span class="s0">* Returns the file system this mount object is attached to.</span>
 <span class="s0">*/ 1 4 this 3 1566  </span>
<span class="s0">516 0 0 6 617 1510 0 0 161 /**</span>
 <span class="s0">* Returns the name of the directory within the virtual file system that this</span>
 <span class="s0">* mount object is attached to.  This directory name will end with a slash.</span>
 <span class="s0">*/ 1 4 this 3 1566  </span>
<span class="s0">517 0 0 6 618 1353 0 0 100 /**</span>
 <span class="s0">* Returns the set of flags passed by the user to the</span>
 <span class="s0">* VirtualFileSystem::mount() command.</span>
 <span class="s0">*/ 1 4 this 3 1566  </span>
<span class="s0">518 0 0 4 619 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1566  3 out 1 1432  </span>
<span class="s0">519 0 0 4 620 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1566  3 out 1 1432  </span>
<span class="s0">520 0 0 7 621 1467 0 0 0 0 </span>
<span class="s0">521 0 0 23 623 1568 994 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 9 multifile 1 1546  </span>
<span class="s0">522 0 0 7 624 1546 861 0 76 /**</span>
 <span class="s0">* Returns the Multifile pointer that this mount object is based on.</span>
 <span class="s0">*/ 1 4 this 3 1569  </span>
<span class="s0">523 0 0 7 625 1467 0 0 0 0 </span>
<span class="s0">524 0 0 7 627 1571 1204 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">525 0 0 7 628 1467 0 0 0 0 </span>
<span class="s0">526 0 0 23 631 1572 1208 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 17 physical_filename 1 1510  </span>
<span class="s0">527 0 0 6 632 1510 0 0 112 /**</span>
 <span class="s0">* Returns the name of the source file on the OS filesystem of the directory</span>
 <span class="s0">* or file that is mounted.</span>
 <span class="s0">*/ 1 4 this 3 1573  </span>
<span class="s0">528 0 0 7 633 1467 0 0 0 0 </span>
<span class="s0">529 0 0 7 636 1577 994 0 69 /**</span>
 <span class="s0">* Returns the VirtualFileMount this file is associated with.</span>
 <span class="s0">*/ 1 4 this 3 1575  </span>
<span class="s0">530 0 0 6 637 1349 0 0 174 /**</span>
 <span class="s0">* Returns true if this file is a .pz file that should be implicitly</span>
 <span class="s0">* decompressed on load, or false if it is not a .pz file or if it should not</span>
 <span class="s0">* be decompressed.</span>
 <span class="s0">*/ 1 4 this 3 1575  </span>
<span class="s0">531 0 0 7 638 1467 0 0 0 0 </span>
<span class="s0">532 0 0 7 641 1578 998 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 8 filename 1 1510  </span>
<span class="s0">533 0 0 15 641 1578 998 0 0 1 6 param0 0 1579  </span>
<span class="s0">534 0 0 7 642 1467 0 0 0 0 </span>
<span class="s0">535 0 0 7 644 1581 1218 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">536 0 0 7 644 1581 1218 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 6 source 1 1530  11 owns_source 1 1349  </span>
<span class="s0">537 0 0 6 645 1581 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 1581  6 source 1 1530  11 owns_source 1 1349  </span>
<span class="s0">538 0 0 6 646 1581 0 0 118 /**</span>
 <span class="s0">* Resets the ZStream to empty, but does not actually close the source istream</span>
 <span class="s0">* unless owns_source was true.</span>
 <span class="s0">*/ 1 4 this 3 1581  </span>
<span class="s0">539 0 0 7 649 1582 1222 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">540 0 0 7 649 1582 1222 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 dest 1 1432  9 owns_dest 1 1349  17 compression_level 5 1353  </span>
<span class="s0">541 0 0 6 650 1582 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 4 4 this 3 1582  4 dest 1 1432  9 owns_dest 1 1349  17 compression_level 5 1353  </span>
<span class="s0">542 0 0 6 651 1582 0 0 114 /**</span>
 <span class="s0">* Resets the ZStream to empty, but does not actually close the dest ostream</span>
 <span class="s0">* unless owns_dest was true.</span>
 <span class="s0">*/ 1 4 this 3 1582  </span>
<span class="s0">543 0 0 15 661 1565 861 0 0 1 6 param0 0 1583  </span>
<span class="s0">544 0 0 6 654 1350 0 0 51 /**</span>
 <span class="s0">* Returns the number of files in the list.</span>
 <span class="s0">*/ 1 4 this 3 1583  </span>
<span class="s0">545 0 0 7 655 1515 1190 0 44 /**</span>
 <span class="s0">* Returns the nth file in the list.</span>
 <span class="s0">*/ 2 4 this 3 1583  1 n 1 1350  </span>
<span class="s0">546 0 0 7 657 1515 1190 0 44 /**</span>
 <span class="s0">* Returns the nth file in the list.</span>
 <span class="s0">*/ 2 4 this 3 1583  1 n 1 1350  </span>
<span class="s0">547 0 0 6 658 1350 0 0 51 /**</span>
 <span class="s0">* Returns the number of files in the list.</span>
 <span class="s0">*/ 1 4 this 3 1583  </span>
<span class="s0">548 0 0 7 659 1565 861 0 0 2 4 this 3 1565  5 other 1 1583  </span>
<span class="s0">549 0 0 7 660 1565 861 0 0 2 4 this 3 1583  5 other 1 1583  </span>
<span class="s0">550 0 0 7 663 1563 1231 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">551 0 0 6 666 1349 0 0 1009 /**</span>
 <span class="s0">* Mounts the indicated system file or directory at the given mount point.  If</span>
 <span class="s0">* the named file is a directory, mounts the directory.  If the named file is</span>
 <span class="s0">* a Multifile, mounts it as a Multifile.  Returns true on success, false on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*</span>
 <span class="s0">* A given system directory may be mounted to multiple different mount point,</span>
 <span class="s0">* and the same mount point may share multiple system directories.  In the</span>
 <span class="s0">* case of ambiguities (that is, two different files with exactly the same</span>
 <span class="s0">* full pathname), the most-recently mounted system wins.</span>
 <span class="s0">*</span>
 <span class="s0">* The filename specified as the first parameter must refer to a real,</span>
 <span class="s0">* physical filename on disk; it cannot be a virtual file already appearing</span>
 <span class="s0">* within the vfs filespace.  However, it is possible to mount such a file;</span>
 <span class="s0">* see mount_loop() for this.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that a mounted VirtualFileSystem directory is fully case-sensitive,</span>
 <span class="s0">* unlike the native Windows file system, so you must refer to files within</span>
 <span class="s0">* the virtual file system with exactly the right case.</span>
 <span class="s0">*/ 5 4 this 3 1563  17 physical_filename 1 1510  11 mount_point 1 1510  5 flags 1 1353  8 password 5 1469  </span>
<span class="s0">552 0 0 6 666 1349 0 0 67 /**</span>
 <span class="s0">* Mounts the indicated Multifile at the given mount point.</span>
 <span class="s0">*/ 4 4 this 3 1563  9 multifile 1 1546  11 mount_point 1 1510  5 flags 1 1353  </span>
<span class="s0">553 0 0 6 666 1349 0 0 208 /**</span>
 <span class="s0">* Adds the given VirtualFileMount object to the mount list.  This is a lower-</span>
 <span class="s0">* level function than the other flavors of mount(); it requires you to create</span>
 <span class="s0">* a VirtualFileMount object specifically.</span>
 <span class="s0">*/ 4 4 this 3 1563  5 mount 1 1577  11 mount_point 1 1510  5 flags 1 1353  </span>
<span class="s0">554 0 0 6 667 1349 0 0 587 /**</span>
 <span class="s0">* This is similar to mount(), but it receives the name of a Multifile that</span>
 <span class="s0">* already appears within the virtual file system.  It can be used to mount a</span>
 <span class="s0">* Multifile that is itself hosted within a virtually-mounted Multifile.</span>
 <span class="s0">*</span>
 <span class="s0">* This interface can also be used to mount physical files (that appear within</span>
 <span class="s0">* the virtual filespace), but it cannot be used to mount directories.  Use</span>
 <span class="s0">* mount() if you need to mount a directory.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that there is additional overhead, in the form of additional buffer</span>
 <span class="s0">* copies of the data, for recursively mounting a multifile like this.</span>
 <span class="s0">*/ 5 4 this 3 1563  16 virtual_filename 1 1510  11 mount_point 1 1510  5 flags 1 1353  8 password 5 1469  </span>
<span class="s0">555 0 0 6 668 1353 0 0 156 /**</span>
 <span class="s0">* Unmounts all appearances of the indicated directory name or multifile name</span>
 <span class="s0">* from the file system.  Returns the number of appearances unmounted.</span>
 <span class="s0">*/ 2 4 this 3 1563  17 physical_filename 1 1510  </span>
<span class="s0">556 0 0 6 668 1353 0 0 132 /**</span>
 <span class="s0">* Unmounts all appearances of the indicated Multifile from the file system.</span>
 <span class="s0">* Returns the number of appearances unmounted.</span>
 <span class="s0">*/ 2 4 this 3 1563  9 multifile 1 1546  </span>
<span class="s0">557 0 0 6 668 1353 0 0 127 /**</span>
 <span class="s0">* Unmounts the indicated VirtualFileMount object from the file system.</span>
 <span class="s0">* Returns the number of appearances unmounted.</span>
 <span class="s0">*/ 2 4 this 3 1563  5 mount 1 1577  </span>
<span class="s0">558 0 0 6 669 1353 0 0 136 /**</span>
 <span class="s0">* Unmounts all systems attached to the given mount point from the file</span>
 <span class="s0">* system.  Returns the number of appearances unmounted.</span>
 <span class="s0">*/ 2 4 this 3 1563  11 mount_point 1 1510  </span>
<span class="s0">559 0 0 6 670 1353 0 0 96 /**</span>
 <span class="s0">* Unmounts all files from the file system.  Returns the number of systems</span>
 <span class="s0">* unmounted.</span>
 <span class="s0">*/ 1 4 this 3 1563  </span>
<span class="s0">560 0 0 6 671 1353 0 0 65 /**</span>
 <span class="s0">* Returns the number of individual mounts in the system.</span>
 <span class="s0">*/ 1 4 this 3 1585  </span>
<span class="s0">561 0 0 7 672 1577 994 0 47 /**</span>
 <span class="s0">* Returns the nth mount in the system.</span>
 <span class="s0">*/ 2 4 this 3 1585  1 n 1 1353  </span>
<span class="s0">562 0 0 6 685 1349 0 0 171 /**</span>
 <span class="s0">* Changes the current directory.  This is used to resolve relative pathnames</span>
 <span class="s0">* in get_file() and/or find_file().  Returns true if successful, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 2 4 this 3 1563  13 new_directory 1 1510  </span>
<span class="s0">563 0 0 7 686 1564 0 0 60 /**</span>
 <span class="s0">* Returns the current directory name.  See chdir().</span>
 <span class="s0">*/ 1 4 this 3 1585  </span>
<span class="s0">564 0 0 6 687 1349 0 0 263 /**</span>
 <span class="s0">* Attempts to create a directory within the file system.  Returns true on</span>
 <span class="s0">* success, false on failure (for instance, because the parent directory does</span>
 <span class="s0">* not exist, or is read-only).  If the directory already existed prior to</span>
 <span class="s0">* this call, returns true.</span>
 <span class="s0">*/ 2 4 this 3 1563  8 filename 1 1510  </span>
<span class="s0">565 0 0 6 688 1349 0 0 169 /**</span>
 <span class="s0">* Attempts to create a directory within the file system.  Will also create</span>
 <span class="s0">* any intervening directories needed.  Returns true on success, false on</span>
 <span class="s0">* failure.</span>
 <span class="s0">*/ 2 4 this 3 1563  8 filename 1 1510  </span>
<span class="s0">566 0 0 7 689 1515 1190 0 537 /**</span>
 <span class="s0">* Looks up the file by the indicated name in the file system.  Returns a</span>
 <span class="s0">* VirtualFile pointer representing the file if it is found, or NULL if it is</span>
 <span class="s0">* not.</span>
 <span class="s0">*</span>
 <span class="s0">* If status_only is true, the file will be checked for existence and length</span>
 <span class="s0">* and so on, but the returned file's contents cannot be read.  This is an</span>
 <span class="s0">* optimization which is especially important for certain mount types, for</span>
 <span class="s0">* instance HTTP, for which opening a file to determine its status is</span>
 <span class="s0">* substantially less expensive than opening it to read its contents.</span>
 <span class="s0">*/ 3 4 this 3 1585  8 filename 1 1510  11 status_only 5 1349  </span>
<span class="s0">567 0 0 7 690 1515 1190 0 298 /**</span>
 <span class="s0">* Attempts to create a file by the indicated name in the filesystem, if</span>
 <span class="s0">* possible, and returns it.  If a file by this name already exists, returns</span>
 <span class="s0">* the same thing as get_file().  If the filename is located within a read-</span>
 <span class="s0">* only directory, or the directory doesn't exist, returns NULL.</span>
 <span class="s0">*/ 2 4 this 3 1563  8 filename 1 1510  </span>
<span class="s0">568 0 0 7 691 1515 1190 0 173 /**</span>
 <span class="s0">* Uses the indicated search path to find the file within the file system.</span>
 <span class="s0">* Returns the first occurrence of the file found, or NULL if the file cannot</span>
 <span class="s0">* be found.</span>
 <span class="s0">*/ 4 4 this 3 1585  8 filename 1 1510  10 searchpath 1 1587  11 status_only 5 1349  </span>
<span class="s0">569 0 0 6 692 1349 0 0 208 /**</span>
 <span class="s0">* Attempts to delete the indicated file or directory.  This can remove a</span>
 <span class="s0">* single file or an empty directory.  It will not remove a nonempty</span>
 <span class="s0">* directory.  Returns true on success, false on failure.</span>
 <span class="s0">*/ 2 4 this 3 1563  8 filename 1 1510  </span>
<span class="s0">570 0 0 6 693 1349 0 0 599 /**</span>
 <span class="s0">* Attempts to move or rename the indicated file or directory.  If the</span>
 <span class="s0">* original file is an ordinary file, it will quietly replace any already-</span>
 <span class="s0">* existing file in the new filename (but not a directory).  If the original</span>
 <span class="s0">* file is a directory, the new filename must not already exist.</span>
 <span class="s0">*</span>
 <span class="s0">* If the file is a directory, the new filename must be within the same mount</span>
 <span class="s0">* point.  If the file is an ordinary file, the new filename may be anywhere;</span>
 <span class="s0">* but if it is not within the same mount point then the rename operation is</span>
 <span class="s0">* automatically performed as a two-step copy-and-delete operation.</span>
 <span class="s0">*/ 3 4 this 3 1563  13 orig_filename 1 1510  12 new_filename 1 1510  </span>
<span class="s0">571 0 0 6 694 1349 0 0 131 /**</span>
 <span class="s0">* Attempts to copy the contents of the indicated file to the indicated file.</span>
 <span class="s0">* Returns true on success, false on failure.</span>
 <span class="s0">*/ 3 4 this 3 1563  13 orig_filename 1 1510  12 new_filename 1 1510  </span>
<span class="s0">572 0 0 6 695 1349 0 0 174 /**</span>
 <span class="s0">* Searches the given search path for the filename.  If it is found, updates</span>
 <span class="s0">* the filename to the full pathname found and returns true; otherwise,</span>
 <span class="s0">* returns false.</span>
 <span class="s0">*/ 4 4 this 3 1585  8 filename 1 1564  10 searchpath 1 1587  17 default_extension 5 1469  </span>
<span class="s0">573 0 0 6 696 1353 0 0 363 /**</span>
 <span class="s0">* Searches all the directories in the search list for the indicated file, in</span>
 <span class="s0">* order.  Fills up the results list with *all* of the matching filenames</span>
 <span class="s0">* found, if any.  Returns the number of matches found.</span>
 <span class="s0">*</span>
 <span class="s0">* It is the responsibility of the the caller to clear the results list first;</span>
 <span class="s0">* otherwise, the newly-found files will be appended to the list.</span>
 <span class="s0">*/ 4 4 this 3 1585  8 filename 1 1510  10 searchpath 1 1587  7 results 1 1590  </span>
<span class="s0">574 0 0 6 697 1349 0 0 71 /**</span>
 <span class="s0">* Convenience function; returns true if the named file exists.</span>
 <span class="s0">*/ 2 4 this 3 1585  8 filename 1 1510  </span>
<span class="s0">575 0 0 6 698 1349 0 0 93 /**</span>
 <span class="s0">* Convenience function; returns true if the named file exists and is a</span>
 <span class="s0">* directory.</span>
 <span class="s0">*/ 2 4 this 3 1585  8 filename 1 1510  </span>
<span class="s0">576 0 0 6 699 1349 0 0 96 /**</span>
 <span class="s0">* Convenience function; returns true if the named file exists and is a</span>
 <span class="s0">* regular file.</span>
 <span class="s0">*/ 2 4 this 3 1585  8 filename 1 1510  </span>
<span class="s0">577 0 0 7 700 1565 861 0 247 /**</span>
 <span class="s0">* If the file represents a directory (that is, is_directory() returns true),</span>
 <span class="s0">* this returns the list of files within the directory at the current time.</span>
 <span class="s0">* Returns NULL if the file is not a directory or if the directory cannot be</span>
 <span class="s0">* read.</span>
 <span class="s0">*/ 2 4 this 3 1585  8 filename 1 1510  </span>
<span class="s0">578 0 0 4 701 1420 0 0 80 /**</span>
 <span class="s0">* Convenience function; lists the files within the indicated directory.</span>
 <span class="s0">*/ 2 4 this 3 1585  8 filename 1 1510  </span>
<span class="s0">579 0 0 4 702 1420 0 0 117 /**</span>
 <span class="s0">* Convenience function; lists the files within the indicated directory, and</span>
 <span class="s0">* all files below, recursively.</span>
 <span class="s0">*/ 2 4 this 3 1585  8 filename 1 1510  </span>
<span class="s0">580 0 0 4 703 1420 0 0 75 /**</span>
 <span class="s0">* Print debugging information.  (e.g.  from Python or gdb prompt).</span>
 <span class="s0">*/ 2 4 this 3 1585  3 out 1 1432  </span>
<span class="s0">581 0 0 6 704 1563 0 0 423 /**</span>
 <span class="s0">* Returns the default global VirtualFileSystem.  You may create your own</span>
 <span class="s0">* personal VirtualFileSystem objects and use them for whatever you like, but</span>
 <span class="s0">* Panda will attempt to load models and stuff from this default object.</span>
 <span class="s0">*</span>
 <span class="s0">* Initially, the global VirtualFileSystem is set up to mount the OS</span>
 <span class="s0">* filesystem to root; i.e.  it is equivalent to the OS filesystem.  This may</span>
 <span class="s0">* be subsequently adjusted by the user.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">582 0 0 38 705 1421 0 0 365 /**</span>
 <span class="s0">* Convenience function; returns the entire contents of the indicated file as</span>
 <span class="s0">* a string.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically</span>
 <span class="s0">* decompressed and the decompressed contents are returned.  This is different</span>
 <span class="s0">* than vfs-implicit-pz, which will automatically decompress a file if the</span>
 <span class="s0">* extension .pz is *not* given.</span>
 <span class="s0">*/ 3 4 this 3 1585  8 filename 1 1510  11 auto_unwrap 1 1349  </span>
<span class="s0">583 0 0 6 706 1530 0 0 424 /**</span>
 <span class="s0">* Convenience function; returns a newly allocated istream if the file exists</span>
 <span class="s0">* and can be read, or NULL otherwise.  Does not return an invalid istream.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_unwrap is true, an explicitly-named .pz file is automatically</span>
 <span class="s0">* decompressed and the decompressed contents are returned.  This is different</span>
 <span class="s0">* than vfs-implicit-pz, which will automatically decompress a file if the</span>
 <span class="s0">* extension .pz is *not* given.</span>
 <span class="s0">*/ 3 4 this 3 1585  8 filename 1 1510  11 auto_unwrap 1 1349  </span>
<span class="s0">584 0 0 4 707 1420 0 0 243 /**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_file().  This really</span>
 <span class="s0">* just deletes the istream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/ 1 6 stream 1 1530  </span>
<span class="s0">585 0 0 38 708 1421 0 0 0 4 4 this 3 1563  8 filename 1 1510  4 data 1 1421  9 auto_wrap 1 1349  </span>
<span class="s0">586 0 0 6 709 1432 0 0 345 /**</span>
 <span class="s0">* Convenience function; returns a newly allocated ostream if the file exists</span>
 <span class="s0">* and can be written, or NULL otherwise.  Does not return an invalid ostream.</span>
 <span class="s0">*</span>
 <span class="s0">* If auto_wrap is true, an explicitly-named .pz file is automatically</span>
 <span class="s0">* compressed while writing.  If truncate is true, the file is truncated to</span>
 <span class="s0">* zero length before writing.</span>
 <span class="s0">*/ 4 4 this 3 1563  8 filename 1 1510  9 auto_wrap 1 1349  8 truncate 1 1349  </span>
<span class="s0">587 0 0 6 710 1432 0 0 180 /**</span>
 <span class="s0">* Works like open_write_file(), but the file is opened in append mode.  Like</span>
 <span class="s0">* open_write_file, the returned pointer should eventually be passed to</span>
 <span class="s0">* close_write_file().</span>
 <span class="s0">*/ 2 4 this 3 1563  8 filename 1 1510  </span>
<span class="s0">588 0 0 4 711 1420 0 0 244 /**</span>
 <span class="s0">* Closes a file opened by a previous call to open_write_file().  This really</span>
 <span class="s0">* just deletes the ostream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/ 1 6 stream 1 1432  </span>
<span class="s0">589 0 0 6 712 1547 0 0 169 /**</span>
 <span class="s0">* Convenience function; returns a newly allocated iostream if the file exists</span>
 <span class="s0">* and can be written, or NULL otherwise.  Does not return an invalid</span>
 <span class="s0">* iostream.</span>
 <span class="s0">*/ 3 4 this 3 1563  8 filename 1 1510  8 truncate 1 1349  </span>
<span class="s0">590 0 0 6 713 1547 0 0 194 /**</span>
 <span class="s0">* Works like open_read_write_file(), but the file is opened in append mode.</span>
 <span class="s0">* Like open_read_write_file, the returned pointer should eventually be passed</span>
 <span class="s0">* to close_read_write_file().</span>
 <span class="s0">*/ 2 4 this 3 1563  8 filename 1 1510  </span>
<span class="s0">591 0 0 4 714 1420 0 0 250 /**</span>
 <span class="s0">* Closes a file opened by a previous call to open_read_write_file().  This</span>
 <span class="s0">* really just deletes the iostream pointer, but it is recommended to use this</span>
 <span class="s0">* interface instead of deleting it explicitly, to help work around compiler</span>
 <span class="s0">* issues.</span>
 <span class="s0">*/ 1 6 stream 1 1547  </span>
<span class="s0">592 0 0 7 679 1592 1246 0 0 0 </span>
<span class="s0">593 0 0 15 679 1592 1246 0 0 1 4 copy 1 1577  </span>
<span class="s0">594 0 0 23 679 1592 1246 0 0 1 3 ptr 1 1577  </span>
<span class="s0">595 0 0 7 679 1592 1246 0 0 1 6 param0 0 1593  </span>
<span class="s0">596 0 0 7 680 1577 994 0 289 // If your base class is a derivative of TypedObject, you might want to use</span>
<span class="s0">// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,</span>
<span class="s0">// ptr).  This provides a clean downcast that doesn't require .p() or any</span>
<span class="s0">// double-casting, and it can be run-time checked for correctness. 1 4 this 3 1594  </span>
<span class="s0">597 0 0 6 681 1592 0 0 0 2 4 this 3 1592  4 copy 1 1577  </span>
<span class="s0">598 0 0 6 681 1592 0 0 0 2 4 this 3 1592  3 ptr 1 1577  </span>
<span class="s0">599 0 0 6 682 1349 0 0 0 1 4 this 3 1594  </span>
<span class="s0">600 0 0 4 683 1420 0 0 0 1 4 this 3 1592  </span>
<span class="s0">601 0 0 4 677 1420 0 0 0 1 4 this 3 1596  </span>
<span class="s0">602 0 0 4 678 1420 0 0 0 2 4 this 3 1597  3 out 1 1432  </span>
<span class="s0">603 0 0 6 716 1403 0 0 203 // get_long_time() returns the most accurate timer we have over a long</span>
<span class="s0">// interval.  It may not be very precise for measuring short intervals, but</span>
<span class="s0">// it should not drift substantially over the long haul. 1 4 this 3 1599  </span>
<span class="s0">604 0 0 6 719 1403 0 0 206 // get_short_time() returns the most precise timer we have over a short</span>
<span class="s0">// interval.  It may tend to drift over the long haul, but it should have</span>
<span class="s0">// lots of digits to measure short intervals very precisely. 1 4 this 3 1599  </span>
<span class="s0">605 0 0 6 721 1403 0 0 144 // get_short_raw_time() is like get_short_time(), but does not apply any</span>
<span class="s0">// corrections (e.g.  paranoid-clock) to the result returned by the OS. 1 4 this 3 1599  </span>
<span class="s0">606 0 0 6 723 1353 0 0 369 /**</span>
 <span class="s0">* Returns the number of clock errors that have been detected.  Each time a</span>
 <span class="s0">* clock error is detected, in which the value returned by either of the above</span>
 <span class="s0">* methods is suspect, the value returned by this method will be incremented.</span>
 <span class="s0">* Applications can monitor this value and react, for instance, by</span>
 <span class="s0">* resynchronizing their clocks each time this value changes.</span>
 <span class="s0">*/ 1 4 this 3 1600  </span>
<span class="s0">607 0 0 6 725 1599 0 0 70 /**</span>
 <span class="s0">* Returns a pointer to the one TrueClock object in the world.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">608 0 0 6 726 1349 0 0 0 2 4 this 3 1600  4 mask 1 1502  </span>
<span class="s0">609 0 0 7 728 1602 1284 0 60 /**</span>
 <span class="s0">* Create a patch file and initializes internal data</span>
 <span class="s0">*/ 0 </span>
<span class="s0">610 0 0 7 728 1602 1284 0 49 /**</span>
 <span class="s0">* Create patch file with buffer to patch</span>
 <span class="s0">*/ 1 6 buffer 1 1483  </span>
<span class="s0">611 0 0 6 730 1349 0 0 359 /**</span>
 <span class="s0">*</span>
 <span class="s0">* This implementation uses the &quot;greedy differencing algorithm&quot; described in</span>
 <span class="s0">* the masters thesis &quot;Differential Compression: A Generalized Solution for</span>
 <span class="s0">* Binary Files&quot; by Randal C. Burns (p.13). For an original file of size M and</span>
 <span class="s0">* a new file of size N, this algorithm is O(M) in space and O(M*N) (worst-</span>
 <span class="s0">* case) in time.  return false on error</span>
 <span class="s0">*/ 4 4 this 3 1602  9 file_orig 1 1564  8 file_new 1 1564  10 patch_name 1 1564  </span>
<span class="s0">612 0 0 6 731 1353 0 0 193 /**</span>
 <span class="s0">* Opens the patch file for reading, and gets the header information from the</span>
 <span class="s0">* file but does not begin to do any real work.  This can be used to query the</span>
 <span class="s0">* data stored in the patch.</span>
 <span class="s0">*/ 2 4 this 3 1602  10 patch_file 1 1510  </span>
<span class="s0">613 0 0 6 732 1353 0 0 107 /**</span>
 <span class="s0">* Set up to apply the patch to the file (original file and patch are</span>
 <span class="s0">* destroyed in the process).</span>
 <span class="s0">*/ 3 4 this 3 1602  10 patch_file 1 1510  4 file 1 1510  </span>
<span class="s0">614 0 0 6 732 1353 0 0 127 /**</span>
 <span class="s0">* Set up to apply the patch to the file.  In this form, neither the original</span>
 <span class="s0">* file nor the patch file are destroyed.</span>
 <span class="s0">*/ 4 4 this 3 1602  10 patch_file 1 1510  9 orig_file 1 1510  11 target_file 1 1510  </span>
<span class="s0">615 0 0 6 733 1353 0 0 390 /**</span>
 <span class="s0">* Perform one buffer's worth of patching.</span>
 <span class="s0">* Returns one of the following values:</span>
 <span class="s0">* @li @c EU_ok : while patching</span>
 <span class="s0">* @li @c EU_success : when done</span>
 <span class="s0">* @li @c EU_error_abort : Patching has not been initiated</span>
 <span class="s0">* @li @c EU_error_file_invalid : file is corrupted</span>
 <span class="s0">* @li @c EU_error_invalid_checksum : incompatible patch file</span>
 <span class="s0">* @li @c EU_error_write_file_rename : could not rename file</span>
 <span class="s0">*/ 1 4 this 3 1602  </span>
<span class="s0">616 0 0 6 734 1349 0 0 171 /**</span>
 <span class="s0">* Patches the entire file in one call returns true on success and false on</span>
 <span class="s0">* error</span>
 <span class="s0">*</span>
 <span class="s0">* This version will delete the patch file and overwrite the original file.</span>
 <span class="s0">*/ 3 4 this 3 1602  10 patch_file 1 1564  4 file 1 1564  </span>
<span class="s0">617 0 0 6 734 1349 0 0 138 /**</span>
 <span class="s0">* Patches the entire file in one call returns true on success and false on</span>
 <span class="s0">* error</span>
 <span class="s0">*</span>
 <span class="s0">* This version will not delete any files.</span>
 <span class="s0">*/ 4 4 this 3 1602  10 patch_file 1 1564  9 orig_file 1 1564  11 target_file 1 1510  </span>
<span class="s0">618 0 0 6 735 1405 0 0 125 /**</span>
 <span class="s0">* Returns a value in the range 0..1, representing the amount of progress</span>
 <span class="s0">* through the patchfile, during a session.</span>
 <span class="s0">*/ 1 4 this 3 1603  </span>
<span class="s0">619 0 0 4 739 1420 0 0 362 /**</span>
 <span class="s0">* If this flag is set true, the Patchfile will make a special case for</span>
 <span class="s0">* patching Panda Multifiles, if detected, and attempt to patch them on a</span>
 <span class="s0">* subfile-by-subfile basis.  If this flag is false, the Patchfile will always</span>
 <span class="s0">* patch the file on a full-file basis.</span>
 <span class="s0">*</span>
 <span class="s0">* This has effect only when building patches; it is not used for applying</span>
 <span class="s0">* patches.</span>
 <span class="s0">*/ 2 4 this 3 1602  15 allow_multifile 1 1349  </span>
<span class="s0">620 0 0 6 740 1349 0 0 37 /**</span>
 <span class="s0">* See set_allow_multifile().</span>
 <span class="s0">*/ 1 4 this 3 1602  </span>
<span class="s0">621 0 0 4 742 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 1602  6 length 1 1353  </span>
<span class="s0">622 0 0 6 743 1353 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 1602  </span>
<span class="s0">623 0 0 4 744 1420 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 1602  </span>
<span class="s0">624 0 0 6 746 1349 0 0 145 /**</span>
 <span class="s0">* Returns true if the MD5 hash for the source file is known.  (Some early</span>
 <span class="s0">* versions of the patch file did not store this information.)</span>
 <span class="s0">*/ 1 4 this 3 1603  </span>
<span class="s0">625 0 0 6 747 1529 0 0 52 /**</span>
 <span class="s0">* Returns the MD5 hash for the source file.</span>
 <span class="s0">*/ 1 4 this 3 1603  </span>
<span class="s0">626 0 0 6 748 1529 0 0 78 /**</span>
 <span class="s0">* Returns the MD5 hash for the file after the patch has been applied.</span>
 <span class="s0">*/ 1 4 this 3 1603  </span>
<span class="s0">627 0 0 15 754 1607 1301 0 0 1 5 other 1 1605  </span>
<span class="s0">628 0 0 7 754 1607 1301 0 0 2 4 name 5 1469  10 maxEntries 5 1353  </span>
<span class="s0">629 0 0 4 756 1420 0 0 0 3 4 this 3 1607  4 name 1 1469  10 maxEntries 5 1353  </span>
<span class="s0">630 0 0 4 757 1420 0 0 0 1 4 this 3 1607  </span>
<span class="s0">631 0 0 4 758 1420 0 0 0 2 4 this 3 1607  3 tag 1 1469  </span>
<span class="s0">632 0 0 4 759 1420 0 0 0 1 4 this 3 1607  </span>
<span class="s0">633 0 0 4 759 1420 0 0 0 2 4 this 3 1607  3 tag 1 1469  </span>
<span class="s0">634 0 0 6 760 1403 0 0 110 // Don't call any of the following during timing: (Because they are slow,</span>
<span class="s0">// not because anything will break). 1 4 this 3 1605  </span>
<span class="s0">635 0 0 4 761 1420 0 0 0 1 3 out 5 1432  </span>
<span class="s0">636 0 0 4 762 1420 0 0 0 2 4 this 3 1605  3 out 5 1432  </span>
<span class="s0">637 0 0 4 763 1420 0 0 0 1 3 out 5 1432  </span>
<span class="s0">638 0 0 4 764 1420 0 0 0 2 4 this 3 1605  3 out 5 1432  </span>
<span class="s0">639 0 0 6 766 1349 0 0 384 /**</span>
 <span class="s0">* Returns true if the object we are pointing to has been deleted, false</span>
 <span class="s0">* otherwise.  If this returns true, it means that the pointer can not yet be</span>
 <span class="s0">* reused, but it does not guarantee that it can be safely accessed.  See the</span>
 <span class="s0">* lock() method for a safe way to access the underlying pointer.</span>
 <span class="s0">*</span>
 <span class="s0">* This will always return true for a null pointer, unlike is_valid_pointer().</span>
 <span class="s0">*/ 1 4 this 3 1608  </span>
<span class="s0">640 0 0 6 767 1349 0 0 122 /**</span>
 <span class="s0">* Returns true if the pointer is not null and the object has not been</span>
 <span class="s0">* deleted.  See was_deleted() for caveats.</span>
 <span class="s0">*/ 1 4 this 3 1608  </span>
<span class="s0">641 0 0 7 777 1610 1320 0 0 0 </span>
<span class="s0">642 0 0 15 777 1610 1320 0 0 1 6 param0 0 1611  </span>
<span class="s0">643 0 0 6 771 1349 0 0 302 /**</span>
 <span class="s0">* Sets the registry key to the indicated value as a string.  The supplied</span>
 <span class="s0">* string value is automatically converted from whatever encoding is set by</span>
 <span class="s0">* TextEncoder::set_default_encoding() and written as a Unicode string.  The</span>
 <span class="s0">* registry key must already exist prior to calling this function.</span>
 <span class="s0">*/ 4 3 key 1 1469  4 name 1 1469  5 value 1 1469  2 rl 5 1411  </span>
<span class="s0">644 0 0 6 772 1349 0 0 142 /**</span>
 <span class="s0">* Sets the registry key to the indicated value as an integer.  The registry</span>
 <span class="s0">* key must already exist prior to calling this function.</span>
 <span class="s0">*/ 4 3 key 1 1469  4 name 1 1469  5 value 1 1353  2 rl 5 1411  </span>
<span class="s0">645 0 0 6 774 1412 0 0 115 /**</span>
 <span class="s0">* Returns the type of the indicated key, or T_none if the key is not known or</span>
 <span class="s0">* is some unsupported type.</span>
 <span class="s0">*/ 3 3 key 1 1469  4 name 1 1469  2 rl 5 1411  </span>
<span class="s0">646 0 0 6 775 1469 0 0 291 /**</span>
 <span class="s0">* Returns the value associated with the indicated registry key, assuming it</span>
 <span class="s0">* is a string value.  The string value is automatically encoded using</span>
 <span class="s0">* TextEncoder::get_default_encoding().  If the key is not defined or is not a</span>
 <span class="s0">* string type value, default_value is returned instead.</span>
 <span class="s0">*/ 4 3 key 1 1469  4 name 1 1469  13 default_value 1 1469  2 rl 5 1411  </span>
<span class="s0">647 0 0 6 776 1353 0 0 206 /**</span>
 <span class="s0">* Returns the value associated with the indicated registry key, assuming it</span>
 <span class="s0">* is an integer value.  If the key is not defined or is not an integer type</span>
 <span class="s0">* value, default_value is returned instead.</span>
 <span class="s0">*/ 4 3 key 1 1469  4 name 1 1469  13 default_value 1 1353  2 rl 5 1411  </span>
<span class="s0">648 0 0 6 250 1469 0 0 0 2 6 source 1 1469  17 compression_level 1 1353  </span>
<span class="s0">649 0 0 6 251 1469 0 0 0 1 6 source 1 1469  </span>
<span class="s0">650 0 0 6 252 1349 0 0 0 3 6 source 1 1510  4 dest 1 1510  17 compression_level 1 1353  </span>
<span class="s0">651 0 0 6 253 1349 0 0 0 2 6 source 1 1510  4 dest 1 1510  </span>
<span class="s0">652 0 0 6 254 1349 0 0 0 3 6 source 1 1530  4 dest 1 1432  17 compression_level 1 1353  </span>
<span class="s0">653 0 0 6 255 1349 0 0 0 2 6 source 1 1530  4 dest 1 1432  </span>
<span class="s0">654 0 0 6 256 1349 0 0 0 2 6 source 1 1530  4 dest 1 1432  </span>
<span class="s0">655 0 0 6 397 1469 0 0 0 5 6 source 1 1469  8 password 1 1469  9 algorithm 5 1469  10 key_length 5 1353  15 iteration_count 5 1353  </span>
<span class="s0">656 0 0 6 398 1469 0 0 0 2 6 source 1 1469  8 password 1 1469  </span>
<span class="s0">657 0 0 6 399 1349 0 0 0 6 6 source 1 1510  4 dest 1 1510  8 password 1 1469  9 algorithm 5 1469  10 key_length 5 1353  15 iteration_count 5 1353  </span>
<span class="s0">658 0 0 6 400 1349 0 0 0 3 6 source 1 1510  4 dest 1 1510  8 password 1 1469  </span>
<span class="s0">659 0 0 6 401 1349 0 0 0 6 6 source 1 1530  4 dest 1 1432  8 password 1 1469  9 algorithm 5 1469  10 key_length 5 1353  15 iteration_count 5 1353  </span>
<span class="s0">660 0 0 6 402 1349 0 0 0 3 6 source 1 1530  4 dest 1 1432  8 password 1 1469  </span>
<span class="s0">661 0 0 6 404 1469 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 3 err 1 1370  </span>
<span class="s0">662 0 0 6 405 1353 0 0 0 0 </span>
<span class="s0">663 0 0 6 406 1469 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">664 0 0 6 407 1353 0 0 0 0 </span>
<span class="s0">665 0 0 6 752 1469 0 0 0 4 8 password 1 1469  4 salt 1 1469  5 iters 1 1353  6 keylen 1 1353  </span>
<span class="s0">292</span>
<span class="s0">1321 11 CPTA_double 0 2105345 11 CPTA_double 11 CPTA_double 0 0 1322 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1322 29 ConstPointerToArray&lt; double &gt; 0 141313 29 ConstPointerToArray&lt; double &gt; 29 ConstPointerToArray&lt; double &gt; 0 0 0 1 674 688 0 13 675 676 677 678 679 680 681 682 683 684 685 686 687 0 0 1 0 1323 0 0 0 0 0</span>

<span class="s0">1323 28 PointerToArrayBase&lt; double &gt; 0 26625 28 PointerToArrayBase&lt; double &gt; 28 PointerToArrayBase&lt; double &gt; 0 0 0 0 671 0 2 672 673 0 0 1 0 1324 0 0 0 0 0</span>

<span class="s0">1324 49 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; 0 43009 49 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; 49 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; 0 0 0 0 0 0 2 669 670 0 0 1 0 1325 0 0 0 0 0</span>

<span class="s0">1325 13 PointerToVoid 0 141313 13 PointerToVoid 13 PointerToVoid 0 0 0 0 668 0 2 666 667 0 0 1 0 1326 0 0 0 0 373</span>
<span class="s0">/**</span>
 <span class="s0">* This is the non-template part of the base class for PointerTo and</span>
 <span class="s0">* ConstPointerTo.  It is necessary so we can keep a pointer to a non-template</span>
 <span class="s0">* class within the ReferenceCount object, to implement weak reference</span>
 <span class="s0">* pointers--we need to have something to clean up when the ReferenceCount</span>
 <span class="s0">* object destructs.</span>
 <span class="s0">*</span>
 <span class="s0">* This is the base class for PointerToBase&lt;T&gt;.</span>
 <span class="s0">*/</span>

<span class="s0">1326 10 MemoryBase 0 2048 10 MemoryBase 10 MemoryBase 0 0 0 0 0 0 0 0 0 0 0 0 428</span>
<span class="s0">/**</span>
 <span class="s0">* This class is intended to be the base class of all objects in Panda that</span>
 <span class="s0">* might be allocated and deleted via the new and delete operators.  It</span>
 <span class="s0">* redefines these operators to provide some memory tracking support.</span>
 <span class="s0">*</span>
 <span class="s0">* We used to try to override the global operator new and delete methods, but</span>
 <span class="s0">* that seems to cause problems when including header files for C++-based</span>
 <span class="s0">* system libraries (such as are found on OSX).</span>
 <span class="s0">*/</span>

<span class="s0">1327 10 CPTA_float 0 2105345 10 CPTA_float 10 CPTA_float 0 0 1328 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1328 28 ConstPointerToArray&lt; float &gt; 0 141313 28 ConstPointerToArray&lt; float &gt; 28 ConstPointerToArray&lt; float &gt; 0 0 0 1 694 708 0 13 695 696 697 698 699 700 701 702 703 704 705 706 707 0 0 1 0 1329 0 0 0 0 0</span>

<span class="s0">1329 27 PointerToArrayBase&lt; float &gt; 0 26625 27 PointerToArrayBase&lt; float &gt; 27 PointerToArrayBase&lt; float &gt; 0 0 0 0 691 0 2 692 693 0 0 1 0 1330 0 0 0 0 0</span>

<span class="s0">1330 48 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; 0 43009 48 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; 48 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; 0 0 0 0 0 0 2 689 690 0 0 1 0 1325 0 0 0 0 0</span>

<span class="s0">1331 8 CPTA_int 0 2105345 8 CPTA_int 8 CPTA_int 0 0 1332 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1332 26 ConstPointerToArray&lt; int &gt; 0 141313 26 ConstPointerToArray&lt; int &gt; 26 ConstPointerToArray&lt; int &gt; 0 0 0 1 714 728 0 13 715 716 717 718 719 720 721 722 723 724 725 726 727 0 0 1 0 1333 0 0 0 0 0</span>

<span class="s0">1333 25 PointerToArrayBase&lt; int &gt; 0 26625 25 PointerToArrayBase&lt; int &gt; 25 PointerToArrayBase&lt; int &gt; 0 0 0 0 711 0 2 712 713 0 0 1 0 1334 0 0 0 0 0</span>

<span class="s0">1334 46 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; 0 43009 46 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; 46 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; 0 0 0 0 0 0 2 709 710 0 0 1 0 1325 0 0 0 0 0</span>

<span class="s0">1335 10 CPTA_uchar 0 2105345 10 CPTA_uchar 10 CPTA_uchar 0 0 1336 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1336 36 ConstPointerToArray&lt; unsigned char &gt; 0 141313 36 ConstPointerToArray&lt; unsigned char &gt; 36 ConstPointerToArray&lt; unsigned char &gt; 0 0 0 1 734 748 0 13 735 736 737 738 739 740 741 742 743 744 745 746 747 0 0 1 0 1337 0 0 0 0 0</span>

<span class="s0">1337 35 PointerToArrayBase&lt; unsigned char &gt; 0 26625 35 PointerToArrayBase&lt; unsigned char &gt; 35 PointerToArrayBase&lt; unsigned char &gt; 0 0 0 0 731 0 2 732 733 0 0 1 0 1338 0 0 0 0 0</span>

<span class="s0">1338 56 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; 0 43009 56 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; 56 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; 0 0 0 0 0 0 2 729 730 0 0 1 0 1325 0 0 0 0 0</span>

<span class="s0">1339 10 PTA_double 0 2105345 10 PTA_double 10 PTA_double 0 0 1340 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1340 24 PointerToArray&lt; double &gt; 0 141313 24 PointerToArray&lt; double &gt; 24 PointerToArray&lt; double &gt; 0 0 0 1 749 770 0 20 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 0 0 1 0 1323 0 0 0 0 0</span>

<span class="s0">1341 9 PTA_float 0 2105345 9 PTA_float 9 PTA_float 0 0 1342 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1342 23 PointerToArray&lt; float &gt; 0 141313 23 PointerToArray&lt; float &gt; 23 PointerToArray&lt; float &gt; 0 0 0 1 771 792 0 20 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 0 0 1 0 1329 0 0 0 0 0</span>

<span class="s0">1343 7 PTA_int 0 2105345 7 PTA_int 7 PTA_int 0 0 1344 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1344 21 PointerToArray&lt; int &gt; 0 141313 21 PointerToArray&lt; int &gt; 21 PointerToArray&lt; int &gt; 0 0 0 1 793 814 0 20 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 0 0 1 0 1333 0 0 0 0 0</span>

<span class="s0">1345 9 PTA_uchar 0 2105345 9 PTA_uchar 9 PTA_uchar 0 0 1346 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1346 31 PointerToArray&lt; unsigned char &gt; 0 141313 31 PointerToArray&lt; unsigned char &gt; 31 PointerToArray&lt; unsigned char &gt; 0 0 0 1 815 836 0 20 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 0 0 1 0 1337 0 0 0 0 0</span>

<span class="s0">1347 11 MemoryUsage 0 141313 11 MemoryUsage 11 MemoryUsage 0 0 0 1 857 858 10 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 20 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 0 0 1 0 1348 0 0 0 0 292</span>
<span class="s0">/**</span>
 <span class="s0">* This class is used strictly for debugging purposes, specifically for</span>
 <span class="s0">* tracking memory leaks of reference-counted objects: it keeps a record of</span>
 <span class="s0">* every such object currently allocated.</span>
 <span class="s0">*</span>
 <span class="s0">* When compiled with NDEBUG set, this entire class does nothing and compiles</span>
 <span class="s0">* to a stub.</span>
 <span class="s0">*/</span>

<span class="s0">1348 10 MemoryHook 0 2048 10 MemoryHook 10 MemoryHook 0 0 0 0 0 0 0 0 0 0 0 0 641</span>
<span class="s0">/**</span>
 <span class="s0">* This class provides a wrapper around the various possible malloc schemes</span>
 <span class="s0">* Panda might employ.  It also exists to allow the MemoryUsage class in Panda</span>
 <span class="s0">* to insert callback hooks to track the size of allocated pointers.</span>
 <span class="s0">*</span>
 <span class="s0">* The PANDA_MALLOC_* and PANDA_FREE_* macros are defined to vector through</span>
 <span class="s0">* through this class (except in production builds) to facilitate that.  Every</span>
 <span class="s0">* memory allocation call in Panda should therefore use these macros instead</span>
 <span class="s0">* of direct calls to malloc or free.  (C++ new and delete operators may be</span>
 <span class="s0">* employed for classes which inherit from MemoryBase; otherwise, use the</span>
 <span class="s0">* PANDA_MALLOC macros.)</span>
 <span class="s0">*/</span>

<span class="s0">1349 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1350 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 1351 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1351 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1352 14 ReferenceCount 0 26625 14 ReferenceCount 14 ReferenceCount 0 0 0 0 861 1 1623 6 862 863 864 865 866 867 0 0 1 3 1326 859 860 0 0 203</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things that want to be reference-counted.</span>
 <span class="s0">* ReferenceCount works in conjunction with PointerTo to automatically delete</span>
 <span class="s0">* objects when the last pointer to them goes away.</span>
 <span class="s0">*/</span>

<span class="s0">1353 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1354 6 Buffer 0 75777 6 Buffer 6 Buffer 0 0 0 1 869 861 0 1 868 0 0 1 0 1352 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">1355 25 PStatCollectorForwardBase 0 75777 25 PStatCollectorForwardBase 25 PStatCollectorForwardBase 0 0 0 0 861 0 1 877 0 0 1 0 1352 0 0 0 0 282</span>
<span class="s0">/**</span>
 <span class="s0">* This class serves as a cheap forward reference to a PStatCollector, which</span>
 <span class="s0">* is defined in the pstatclient module (and is not directly accessible here</span>
 <span class="s0">* in the express module).</span>
 <span class="s0">*</span>
 <span class="s0">* This is subclassed as PStatCollectorForward, which defines the actual</span>
 <span class="s0">* functionality.</span>
 <span class="s0">*/</span>

<span class="s0">1356 18 NodeReferenceCount 0 43009 18 NodeReferenceCount 18 NodeReferenceCount 0 0 0 0 0 0 6 878 879 880 881 882 883 0 0 1 0 1352 0 0 0 0 603</span>
<span class="s0">/**</span>
 <span class="s0">* This class specializes ReferenceCount to add an additional counter, called</span>
 <span class="s0">* node_ref_count, for the purposes of counting the number of times the object</span>
 <span class="s0">* is referenced by a &quot;node&quot;, whatever that may mean in context.</span>
 <span class="s0">*</span>
 <span class="s0">* The new methods node_ref() and node_unref() automatically increment and</span>
 <span class="s0">* decrement the primary reference count as well.  There also exists a</span>
 <span class="s0">* NodePointerTo&lt;&gt; class to maintain the node_ref counters automatically.</span>
 <span class="s0">*</span>
 <span class="s0">* See also CachedTypedWritableReferenceCount, which is similar in principle,</span>
 <span class="s0">* as well as NodeCachedReferenceCount, which combines both of these.</span>
 <span class="s0">*/</span>

<span class="s0">1357 8 Datagram 0 75777 8 Datagram 8 Datagram 0 0 0 1 884 0 0 48 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 0 0 1 0 1358 0 0 0 0 565</span>
<span class="s0">/**</span>
 <span class="s0">* An ordered list of data elements, formatted in memory for transmission over</span>
 <span class="s0">* a socket or writing to a data file.</span>
 <span class="s0">*</span>
 <span class="s0">* Data elements should be added one at a time, in order, to the Datagram.</span>
 <span class="s0">* The nature and contents of the data elements are totally up to the user.</span>
 <span class="s0">* When a Datagram has been transmitted and received, its data elements may be</span>
 <span class="s0">* extracted using a DatagramIterator; it is up to the caller to know the</span>
 <span class="s0">* correct type of each data element in order.</span>
 <span class="s0">*</span>
 <span class="s0">* A Datagram is itself headerless; it is simply a collection of data</span>
 <span class="s0">* elements.</span>
 <span class="s0">*/</span>

<span class="s0">1358 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508</span>
<span class="s0">/**</span>
 <span class="s0">* This is an abstract class that all classes which use TypeHandle, and also</span>
 <span class="s0">* provide virtual functions to support polymorphism, should inherit from.</span>
 <span class="s0">* Each derived class should define get_type(), which should return the</span>
 <span class="s0">* specific type of the derived class.  Inheriting from this automatically</span>
 <span class="s0">* provides support for is_of_type() and is_exact_type().</span>
 <span class="s0">*</span>
 <span class="s0">* All classes that inherit directly or indirectly from TypedObject should</span>
 <span class="s0">* redefine get_type() and force_init_type(), as shown below.  Some classes</span>
 <span class="s0">* that do not inherit from TypedObject may still declare TypeHandles for</span>
 <span class="s0">* themselves by defining methods called get_class_type() and init_type().</span>
 <span class="s0">* Classes such as these may serve as base classes, but the dynamic type</span>
 <span class="s0">* identification system will be limited.  Classes that do not inherit from</span>
 <span class="s0">* TypedObject need not define the virtual functions get_type() and</span>
 <span class="s0">* force_init_type() (or any other virtual functions).</span>
 <span class="s0">*</span>
 <span class="s0">* There is a specific layout for defining the overrides from this class.</span>
 <span class="s0">* Keeping the definitions formatted just like these examples will allow</span>
 <span class="s0">* someone in the future to use a sed (or similar) script to make global</span>
 <span class="s0">* changes, if necessary.  Avoid rearranging the braces or the order of the</span>
 <span class="s0">* functions unless you're ready to change them in every file all at once.</span>
 <span class="s0">*</span>
 <span class="s0">* What follows are some examples that can be used in new classes that you</span>
 <span class="s0">* create.</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class definition (.h file):</span>
 <span class="s0">* @code</span>
 <span class="s0">* public:</span>
 <span class="s0">*   static TypeHandle get_class_type() {</span>
 <span class="s0">*     return _type_handle;</span>
 <span class="s0">*   }</span>
 <span class="s0">*   static void init_type() {</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*     register_type(_type_handle, &quot;&lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;&quot;,</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassOne&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassTwo&gt;&gt;&gt;::get_class_type(),</span>
 <span class="s0">*                   &lt;&lt;&lt;BaseClassN&gt;&gt;&gt;::get_class_type());</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle get_type() const {</span>
 <span class="s0">*     return get_class_type();</span>
 <span class="s0">*   }</span>
 <span class="s0">*   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}</span>
 <span class="s0">*</span>
 <span class="s0">* private:</span>
 <span class="s0">*   static TypeHandle _type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class .cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* TypeHandle &lt;&lt;&lt;ThisClassStringName&gt;&gt;&gt;::_type_handle;</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*</span>
 <span class="s0">* @par In the class config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;.cxx file:</span>
 <span class="s0">* @code</span>
 <span class="s0">* ConfigureFn(config_&lt;&lt;&lt;PackageName&gt;&gt;&gt;) {</span>
 <span class="s0">*   &lt;&lt;&lt;ClassOne&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassTwo&gt;&gt;&gt;::init_type();</span>
 <span class="s0">*   &lt;&lt;&lt;ClassN&gt;&gt;&gt;::init_type();</span>
 <span class="s0">* }</span>
 <span class="s0">* @endcode</span>
 <span class="s0">*/</span>

<span class="s0">1359 17 DatagramGenerator 0 26625 17 DatagramGenerator 17 DatagramGenerator 0 0 0 0 933 0 9 934 935 936 937 938 939 940 941 942 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* This class defines the abstract interace to any source of datagrams,</span>
 <span class="s0">* whether it be from a file or from the net.</span>
 <span class="s0">*/</span>

<span class="s0">1360 16 DatagramIterator 0 141313 16 DatagramIterator 16 DatagramIterator 0 0 0 1 943 980 0 36 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 0 0 0 0 0 365</span>
<span class="s0">/**</span>
 <span class="s0">* A class to retrieve the individual data elements previously stored in a</span>
 <span class="s0">* Datagram.  Elements may be retrieved one at a time; it is up to the caller</span>
 <span class="s0">* to know the correct type and order of each element.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that it is the responsibility of the caller to ensure that the datagram</span>
 <span class="s0">* object is not destructed while this DatagramIterator is in use.</span>
 <span class="s0">*/</span>

<span class="s0">1361 12 DatagramSink 0 26625 12 DatagramSink 12 DatagramSink 0 0 0 0 981 3 1624 1625 1626 7 982 983 984 985 986 987 988 0 0 0 0 0 135</span>
<span class="s0">/**</span>
 <span class="s0">* This class defines the abstract interface to sending datagrams to any</span>
 <span class="s0">* target, whether it be into a file or across the net</span>
 <span class="s0">*/</span>

<span class="s0">1362 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 1363 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1363 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">1364 21 FileReference const * 0 8576 21 FileReference const * 21 FileReference const * 0 0 1365 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1365 19 FileReference const 0 8832 19 FileReference const 19 FileReference const 0 0 1366 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1366 13 FileReference 0 141313 13 FileReference 13 FileReference 0 0 0 1 995 998 0 2 996 997 0 0 1 0 1367 0 0 0 0 149</span>
<span class="s0">/**</span>
 <span class="s0">* Keeps a reference-counted pointer to a file on disk.  As long as the</span>
 <span class="s0">* FileReference is held, someone presumably has a use for this file.</span>
 <span class="s0">*/</span>

<span class="s0">1367 19 TypedReferenceCount 0 141313 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 994 0 1 993 0 0 2 3 1358 989 990 3 1352 991 992 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">1368 9 streamoff 0 2105344 14 std::streamoff 14 std::streamoff 0 0 1369 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1369 13 long long int 0 8226 13 long long int 13 long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1370 13 ErrorUtilCode 0 532481 13 ErrorUtilCode 13 ErrorUtilCode 0 0 0 0 0 0 0 0 0 0 37 16 EU_http_redirect 16 EU_http_redirect 0</span>
<span class="s0">7 6 EU_eof 6 EU_eof 0</span>
<span class="s0">6 18 EU_network_no_data 18 EU_network_no_data 0</span>
<span class="s0">5 12 EU_write_ram 12 EU_write_ram 0</span>
<span class="s0">4 8 EU_write 8 EU_write 0</span>
<span class="s0">3 5 EU_ok 5 EU_ok 0</span>
<span class="s0">2 10 EU_success 10 EU_success 0</span>
<span class="s0">1 14 EU_error_abort 14 EU_error_abort 17</span>
<span class="s0">// General errors</span>
<span class="s0">-1 19 EU_error_file_empty 19 EU_error_file_empty 0</span>
<span class="s0">-2 21 EU_error_file_invalid 21 EU_error_file_invalid 0</span>
<span class="s0">-3 25 EU_error_invalid_checksum 25 EU_error_invalid_checksum 0</span>
<span class="s0">-4 21 EU_error_network_dead 21 EU_error_network_dead 25</span>
<span class="s0">// General network errors</span>
<span class="s0">-30 28 EU_error_network_unreachable 28 EU_error_network_unreachable 0</span>
<span class="s0">-31 29 EU_error_network_disconnected 29 EU_error_network_disconnected 0</span>
<span class="s0">-32 24 EU_error_network_timeout 24 EU_error_network_timeout 0</span>
<span class="s0">-33 24 EU_error_network_no_data 24 EU_error_network_no_data 0</span>
<span class="s0">-34 37 EU_error_network_disconnected_locally 37 EU_error_network_disconnected_locally 23</span>
<span class="s0">// Local network errors</span>
<span class="s0">-40 32 EU_error_network_buffer_overflow 32 EU_error_network_buffer_overflow 0</span>
<span class="s0">-41 36 EU_error_network_disk_quota_exceeded 36 EU_error_network_disk_quota_exceeded 0</span>
<span class="s0">-42 41 EU_error_network_remote_host_disconnected 41 EU_error_network_remote_host_disconnected 29</span>
<span class="s0">// Remote host network errors</span>
<span class="s0">-50 33 EU_error_network_remote_host_down 33 EU_error_network_remote_host_down 0</span>
<span class="s0">-51 40 EU_error_network_remote_host_unreachable 40 EU_error_network_remote_host_unreachable 0</span>
<span class="s0">-52 38 EU_error_network_remote_host_not_found 38 EU_error_network_remote_host_not_found 0</span>
<span class="s0">-53 40 EU_error_network_remote_host_no_response 40 EU_error_network_remote_host_no_response 0</span>
<span class="s0">-54 27 EU_error_write_out_of_files 27 EU_error_write_out_of_files 23</span>
<span class="s0">// General local errors</span>
<span class="s0">-60 28 EU_error_write_out_of_memory 28 EU_error_write_out_of_memory 0</span>
<span class="s0">-61 32 EU_error_write_sharing_violation 32 EU_error_write_sharing_violation 0</span>
<span class="s0">-62 24 EU_error_write_disk_full 24 EU_error_write_disk_full 0</span>
<span class="s0">-63 29 EU_error_write_disk_not_found 29 EU_error_write_disk_not_found 0</span>
<span class="s0">-64 36 EU_error_write_disk_sector_not_found 36 EU_error_write_disk_sector_not_found 0</span>
<span class="s0">-65 25 EU_error_write_disk_fault 25 EU_error_write_disk_fault 0</span>
<span class="s0">-66 26 EU_error_write_file_rename 26 EU_error_write_file_rename 0</span>
<span class="s0">-67 28 EU_error_http_server_timeout 28 EU_error_http_server_timeout 14</span>
<span class="s0">// HTTP errors</span>
<span class="s0">-70 29 EU_error_http_gateway_timeout 29 EU_error_http_gateway_timeout 0</span>
<span class="s0">-71 33 EU_error_http_service_unavailable 33 EU_error_http_service_unavailable 0</span>
<span class="s0">-72 34 EU_error_http_proxy_authentication 34 EU_error_http_proxy_authentication 0</span>
<span class="s0">-73 13 EU_error_zlib 13 EU_error_zlib 14</span>
<span class="s0">// Zlib errors</span>
<span class="s0">-80 0 0</span>

<span class="s0">1371 7 Ramfile 0 141313 7 Ramfile 7 Ramfile 0 0 0 1 1009 1018 0 8 1010 1011 1012 1013 1014 1015 1016 1017 0 0 0 0 0 85</span>
<span class="s0">/**</span>
 <span class="s0">* An in-memory buffer specifically designed for downloading files to memory.</span>
 <span class="s0">*/</span>

<span class="s0">1372 7 HashVal 0 141313 7 HashVal 7 HashVal 0 0 0 1 1019 1049 0 29 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 0 0 0 0 0 109</span>
<span class="s0">/**</span>
 <span class="s0">* Stores a 128-bit value that represents the hashed contents (typically MD5)</span>
 <span class="s0">* of a file or buffer.</span>
 <span class="s0">*/</span>

<span class="s0">1373 19 MemoryUsagePointers 0 26625 19 MemoryUsagePointers 19 MemoryUsagePointers 0 0 0 1 1050 1051 0 9 1052 1053 1054 1055 1056 1057 1058 1059 1060 2 1639 1640 0 0 0 0 785</span>
<span class="s0">/**</span>
 <span class="s0">* This is a list of pointers returned by a MemoryUsage object in response to</span>
 <span class="s0">* some query.</span>
 <span class="s0">*</span>
 <span class="s0">* Warning: once pointers are stored in a MemoryUsagePointers object, they are</span>
 <span class="s0">* reference-counted, and will not be freed until the MemoryUsagePointers</span>
 <span class="s0">* object is freed (or clear() is called on the object).  However, they may</span>
 <span class="s0">* not even be freed then; pointers may leak once they have been added to this</span>
 <span class="s0">* structure.  This is because we don't store enough information in this</span>
 <span class="s0">* structure to correctly free the pointers that have been added.  Since this</span>
 <span class="s0">* is intended primarily as a debugging tool, this is not a major issue.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is just a user interface to talk about pointers stored in a</span>
 <span class="s0">* MemoryUsage object.  It doesn't even exist when compiled with NDEBUG.</span>
 <span class="s0">*/</span>

<span class="s0">1374 10 ISubStream 0 141313 10 ISubStream 10 ISubStream 0 0 0 1 1061 1064 0 2 1062 1063 0 0 1 0 1375 0 0 0 0 392</span>
<span class="s0">/**</span>
 <span class="s0">* An istream object that presents a subwindow into another istream.  The</span>
 <span class="s0">* first character read from this stream will be the &quot;start&quot; character from</span>
 <span class="s0">* the source istream; just before the file pointer reaches the &quot;end&quot;</span>
 <span class="s0">* character, eof is returned.</span>
 <span class="s0">*</span>
 <span class="s0">* The source stream must be one that we can randomly seek within.  The</span>
 <span class="s0">* resulting ISubStream will also support arbitrary seeks.</span>
 <span class="s0">*/</span>

<span class="s0">1375 7 istream 0 2048 12 std::istream 12 std::istream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1376 10 OSubStream 0 141313 10 OSubStream 10 OSubStream 0 0 0 1 1065 1068 0 2 1066 1067 0 0 1 0 1377 0 0 0 0 391</span>
<span class="s0">/**</span>
 <span class="s0">* An ostream object that presents a subwindow into another ostream.  The</span>
 <span class="s0">* first character written to this stream will be the &quot;start&quot; character in the</span>
 <span class="s0">* dest istream; no characters may be written to character &quot;end&quot; or later</span>
 <span class="s0">* (unless end is zero).</span>
 <span class="s0">*</span>
 <span class="s0">* The dest stream must be one that we can randomly seek within.  The</span>
 <span class="s0">* resulting OSubStream will also support arbitrary seeks.</span>
 <span class="s0">*/</span>

<span class="s0">1377 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1378 9 SubStream 0 141313 9 SubStream 9 SubStream 0 0 0 1 1069 1072 0 2 1070 1071 0 0 1 0 1379 0 0 0 0 68</span>
<span class="s0">/**</span>
 <span class="s0">* Combined ISubStream and OSubStream for bidirectional I/O.</span>
 <span class="s0">*/</span>

<span class="s0">1379 8 iostream 0 2048 13 std::iostream 13 std::iostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1380 9 Multifile 0 75777 9 Multifile 9 Multifile 0 0 0 1 1073 861 1 1627 62 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1 1641 0 1 0 1352 0 0 0 0 47</span>
<span class="s0">/**</span>
 <span class="s0">* A file that contains a set of files.</span>
 <span class="s0">*/</span>

<span class="s0">1381 6 string 0 2105344 11 std::string 11 std::string 0 0 1382 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1382 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1383 7 Namable 0 141313 7 Namable 7 Namable 0 0 0 1 1136 1143 1 1628 6 1137 1138 1139 1140 1141 1142 0 0 1 0 1326 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">1384 12 string const 0 8832 17 std::string const 17 std::string const 0 0 1381 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1385 14 OpenSSLWrapper 0 43009 14 OpenSSLWrapper 14 OpenSSLWrapper 0 0 0 0 0 0 8 1144 1145 1146 1147 1148 1149 1150 1151 0 0 0 0 0 205</span>
<span class="s0">/**</span>
 <span class="s0">* Provides an interface wrapper around the OpenSSL library, to ensure that</span>
 <span class="s0">* the library is properly initialized in the application, and to provide some</span>
 <span class="s0">* hooks into global OpenSSL context data.</span>
 <span class="s0">*/</span>

<span class="s0">1386 11 SubfileInfo 0 141313 11 SubfileInfo 11 SubfileInfo 0 0 0 1 1152 1160 0 7 1153 1154 1155 1156 1157 1158 1159 0 0 0 0 0 200</span>
<span class="s0">/**</span>
 <span class="s0">* This class records a particular byte sub-range within an existing file on</span>
 <span class="s0">* disk.  Generally, the filename is understood as a physical file on disk,</span>
 <span class="s0">* and not to be looked up via the vfs.</span>
 <span class="s0">*/</span>

<span class="s0">1387 11 VirtualFile 0 141313 11 VirtualFile 11 VirtualFile 0 0 0 0 1190 0 29 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 0 0 1 0 1367 0 0 0 0 91</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract base class for a file or directory within the</span>
 <span class="s0">* VirtualFileSystem.</span>
 <span class="s0">*/</span>

<span class="s0">1388 20 VirtualFileComposite 0 141313 20 VirtualFileComposite 20 VirtualFileComposite 0 0 0 0 1192 0 1 1191 0 0 1 0 1387 0 0 0 0 223</span>
<span class="s0">/**</span>
 <span class="s0">* A composite directory within the VirtualFileSystem: this maps to more than</span>
 <span class="s0">* one directory on different mount points.  The resulting directory appears</span>
 <span class="s0">* to be the union of all the individual simple directories.</span>
 <span class="s0">*/</span>

<span class="s0">1389 16 VirtualFileMount 0 75777 16 VirtualFileMount 16 VirtualFileMount 0 0 0 0 994 0 6 1193 1194 1195 1196 1197 1198 0 0 1 0 1367 0 0 0 0 159</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract base class for a mount definition used within a</span>
 <span class="s0">* VirtualFileSystem.  Normally users don't need to monkey with this class</span>
 <span class="s0">* directly.</span>
 <span class="s0">*/</span>

<span class="s0">1390 25 VirtualFileMountMultifile 0 75777 25 VirtualFileMountMultifile 25 VirtualFileMountMultifile 0 0 0 1 1199 994 0 2 1200 1201 0 0 1 0 1389 0 0 0 0 66</span>
<span class="s0">/**</span>
 <span class="s0">* Maps a Multifile's contents into the VirtualFileSystem.</span>
 <span class="s0">*/</span>

<span class="s0">1391 23 VirtualFileMountRamdisk 0 141313 23 VirtualFileMountRamdisk 23 VirtualFileMountRamdisk 0 0 0 1 1202 1204 0 1 1203 0 0 1 0 1389 0 0 0 0 384</span>
<span class="s0">/**</span>
 <span class="s0">* Simulates an actual directory on disk with in-memory storage.  This is</span>
 <span class="s0">* useful mainly for performing high level functions that expect disk I/O</span>
 <span class="s0">* without actually writing files to disk.  Naturally, there are significant</span>
 <span class="s0">* limits to the size of the files that may be written with this system; and</span>
 <span class="s0">* &quot;files&quot; written here are not automatically persistent between sessions.</span>
 <span class="s0">*/</span>

<span class="s0">1392 22 VirtualFileMountSystem 0 141313 22 VirtualFileMountSystem 22 VirtualFileMountSystem 0 0 0 1 1205 1208 0 2 1206 1207 0 0 1 0 1389 0 0 0 0 66</span>
<span class="s0">/**</span>
 <span class="s0">* Maps an actual OS directory into the VirtualFileSystem.</span>
 <span class="s0">*/</span>

<span class="s0">1393 17 VirtualFileSimple 0 141313 17 VirtualFileSimple 17 VirtualFileSimple 0 0 0 0 1212 0 3 1209 1210 1211 0 0 1 0 1387 0 0 0 0 183</span>
<span class="s0">/**</span>
 <span class="s0">* A simple file or directory within the VirtualFileSystem: this maps to</span>
 <span class="s0">* exactly one file on one mount point.  Most directories, and all regular</span>
 <span class="s0">* files, are of this kind.</span>
 <span class="s0">*/</span>

<span class="s0">1394 13 TemporaryFile 0 75777 13 TemporaryFile 13 TemporaryFile 0 0 0 1 1213 998 0 1 1214 0 0 1 0 1366 0 0 0 0 206</span>
<span class="s0">/**</span>
 <span class="s0">* This is a special kind of FileReference class that automatically deletes</span>
 <span class="s0">* the file in question when it is deleted.  It is not responsible for</span>
 <span class="s0">* creating, opening, or closing the file, however.</span>
 <span class="s0">*/</span>

<span class="s0">1395 17 IDecompressStream 0 141313 17 IDecompressStream 17 IDecompressStream 0 0 0 1 1215 1218 0 2 1216 1217 0 0 1 0 1375 0 0 0 0 323</span>
<span class="s0">/**</span>
 <span class="s0">* An input stream object that uses zlib to decompress (inflate) the input</span>
 <span class="s0">* from another source stream on-the-fly.</span>
 <span class="s0">*</span>
 <span class="s0">* Attach an IDecompressStream to an existing istream that provides compressed</span>
 <span class="s0">* data, and read the corresponding uncompressed data from the</span>
 <span class="s0">* IDecompressStream.</span>
 <span class="s0">*</span>
 <span class="s0">* Seeking is not supported.</span>
 <span class="s0">*/</span>

<span class="s0">1396 15 OCompressStream 0 141313 15 OCompressStream 15 OCompressStream 0 0 0 1 1219 1222 0 2 1220 1221 0 0 1 0 1377 0 0 0 0 311</span>
<span class="s0">/**</span>
 <span class="s0">* An input stream object that uses zlib to compress (deflate) data to another</span>
 <span class="s0">* destination stream on-the-fly.</span>
 <span class="s0">*</span>
 <span class="s0">* Attach an OCompressStream to an existing ostream that will accept</span>
 <span class="s0">* compressed data, and write your uncompressed source data to the</span>
 <span class="s0">* OCompressStream.</span>
 <span class="s0">*</span>
 <span class="s0">* Seeking is not supported.</span>
 <span class="s0">*/</span>

<span class="s0">1397 15 VirtualFileList 0 75777 15 VirtualFileList 15 VirtualFileList 0 0 0 1 1229 861 0 6 1223 1224 1225 1226 1227 1228 1 1642 0 1 0 1352 0 0 0 0 80</span>
<span class="s0">/**</span>
 <span class="s0">* A list of VirtualFiles, as returned by VirtualFile::scan_directory().</span>
 <span class="s0">*/</span>

<span class="s0">1398 17 VirtualFileSystem 0 26625 17 VirtualFileSystem 17 VirtualFileSystem 0 0 0 1 1230 1231 1 1629 37 1232 1233 1234 1235 1236 1237 1238 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1 1643 0 0 0 1 1399 352</span>
<span class="s0">/**</span>
 <span class="s0">* A hierarchy of directories and files that appears to be one continuous file</span>
 <span class="s0">* system, even though the files may originate from several different sources</span>
 <span class="s0">* that may not be related to the actual OS's file system.</span>
 <span class="s0">*</span>
 <span class="s0">* For instance, a VirtualFileSystem can transparently mount one or more</span>
 <span class="s0">* Multifiles as their own subdirectory hierarchies.</span>
 <span class="s0">*/</span>

<span class="s0">1399 10 MountFlags 0 794624 29 VirtualFileSystem::MountFlags 29 VirtualFileSystem::MountFlags 1398 0 0 0 0 0 0 0 0 0 1 12 MF_read_only 31 VirtualFileSystem::MF_read_only 0</span>
<span class="s0">2 0 0</span>

<span class="s0">1400 29 PointerTo&lt; VirtualFileMount &gt; 0 141313 29 PointerTo&lt; VirtualFileMount &gt; 29 PointerTo&lt; VirtualFileMount &gt; 0 0 0 1 1241 1246 0 4 1242 1243 1244 1245 0 0 1 0 1401 0 0 0 0 0</span>

<span class="s0">1401 33 PointerToBase&lt; VirtualFileMount &gt; 0 43009 33 PointerToBase&lt; VirtualFileMount &gt; 33 PointerToBase&lt; VirtualFileMount &gt; 0 0 0 0 0 0 2 1239 1240 0 0 1 0 1325 0 0 0 0 0</span>

<span class="s0">1402 9 TrueClock 0 43009 9 TrueClock 9 TrueClock 0 0 0 0 0 4 1630 1631 1632 1633 6 1277 1278 1279 1280 1281 1282 0 0 0 0 0 467</span>
<span class="s0">/**</span>
 <span class="s0">* An interface to whatever real-time clock we might have available in the</span>
 <span class="s0">* current environment.  There is only one TrueClock in existence, and it</span>
 <span class="s0">* constructs itself.</span>
 <span class="s0">*</span>
 <span class="s0">* The TrueClock returns elapsed real time in seconds since some undefined</span>
 <span class="s0">* epoch.  Since it is not defined at what time precisely the clock indicates</span>
 <span class="s0">* zero, this value can only be meaningfully used to measure elapsed time, by</span>
 <span class="s0">* sampling it at two different times and subtracting.</span>
 <span class="s0">*/</span>

<span class="s0">1403 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1404 9 Patchfile 0 26625 9 Patchfile 9 Patchfile 0 0 0 1 1283 1284 5 1634 1635 1636 1637 1638 14 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 0 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">1405 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 1406 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1406 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1407 13 HashVal const 0 8832 13 HashVal const 13 HashVal const 0 0 1372 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1408 12 ProfileTimer 0 26625 12 ProfileTimer 12 ProfileTimer 0 0 0 1 1300 1301 0 9 1302 1303 1304 1305 1306 1307 1308 1309 1310 0 0 0 0 0 713</span>
<span class="s0">/*</span>
    <span class="s0">ProfileTimer</span>

    <span class="s0">HowTo:</span>
      <span class="s0">Create a ProfileTimer and hold onto it.</span>
      <span class="s0">Call init() whenever you like (the timer doesn't</span>
        <span class="s0">start yet).</span>
      <span class="s0">Call on() to start the timer.</span>
      <span class="s0">While the timer is on, call mark() at each point of interest,</span>
        <span class="s0">in the code you are timing.</span>
      <span class="s0">You can turn the timer off() and on() to skip things you</span>
        <span class="s0">don't want to time.</span>
      <span class="s0">When your timing is finished, call printTo() to see the</span>
        <span class="s0">results (e.g. myTimer.printTo(cerr)).</span>

    <span class="s0">Notes:</span>
      <span class="s0">You should be able to time things down to the millisecond</span>
      <span class="s0">well enough, but if you call on() and off() within micro-</span>
      <span class="s0">seconds of each other, I don't think you'll get very good</span>
      <span class="s0">results.</span>
<span class="s0">*/</span>

<span class="s0">1409 17 WeakPointerToVoid 0 141313 17 WeakPointerToVoid 17 WeakPointerToVoid 0 0 0 0 1313 0 2 1311 1312 0 0 1 0 1325 0 0 0 0 152</span>
<span class="s0">/**</span>
 <span class="s0">* This is the specialization of PointerToVoid for weak pointers.  It needs an</span>
 <span class="s0">* additional flag to indicate that the pointer has been deleted.</span>
 <span class="s0">*/</span>

<span class="s0">1410 15 WindowsRegistry 0 141313 15 WindowsRegistry 15 WindowsRegistry 0 0 0 1 1319 1320 0 5 1314 1315 1316 1317 1318 0 0 0 0 2 1411 1412 249</span>
<span class="s0">/**</span>
 <span class="s0">* This class provides a hook to Python to read and write strings and integers</span>
 <span class="s0">* to the windows registry.  It automatically converts strings from utf-8</span>
 <span class="s0">* encoding and stores them in Unicode (and conversely reconverts them on</span>
 <span class="s0">* retrieval).</span>
 <span class="s0">*/</span>

<span class="s0">1411 8 RegLevel 0 794624 25 WindowsRegistry::RegLevel 25 WindowsRegistry::RegLevel 1410 0 0 0 0 0 0 0 0 0 2 10 rl_machine 27 WindowsRegistry::rl_machine 0</span>
<span class="s0">0 7 rl_user 24 WindowsRegistry::rl_user 0</span>
<span class="s0">1 0 0</span>

<span class="s0">1412 4 Type 0 794624 21 WindowsRegistry::Type 21 WindowsRegistry::Type 1410 0 0 0 0 0 0 0 0 0 3 6 T_none 23 WindowsRegistry::T_none 0</span>
<span class="s0">0 5 T_int 22 WindowsRegistry::T_int 0</span>
<span class="s0">1 8 T_string 25 WindowsRegistry::T_string 0</span>
<span class="s0">2 0 0</span>

<span class="s0">1413 12 PTA_stdfloat 0 2105345 12 PTA_stdfloat 12 PTA_stdfloat 0 0 1341 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1414 13 CPTA_stdfloat 0 2105345 13 CPTA_stdfloat 13 CPTA_stdfloat 0 0 1327 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1415 37 ConstPointerToArray&lt; double &gt; const * 0 8576 37 ConstPointerToArray&lt; double &gt; const * 37 ConstPointerToArray&lt; double &gt; const * 0 0 1416 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1416 35 ConstPointerToArray&lt; double &gt; const 0 8832 35 ConstPointerToArray&lt; double &gt; const 35 ConstPointerToArray&lt; double &gt; const 0 0 1322 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1417 31 ConstPointerToArray&lt; double &gt; * 0 8576 31 ConstPointerToArray&lt; double &gt; * 31 ConstPointerToArray&lt; double &gt; * 0 0 1322 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1418 32 PointerToArray&lt; double &gt; const * 0 8576 32 PointerToArray&lt; double &gt; const * 32 PointerToArray&lt; double &gt; const * 0 0 1419 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1419 30 PointerToArray&lt; double &gt; const 0 8832 30 PointerToArray&lt; double &gt; const 30 PointerToArray&lt; double &gt; const 0 0 1340 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1420 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1421 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 1422 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1422 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 1423 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1423 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1424 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 1425 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1425 9 Py_buffer 0 2105344 9 Py_buffer 9 Py_buffer 0 0 1426 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1426 10 bufferinfo 0 1024 10 bufferinfo 10 bufferinfo 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1427 36 PointerToArrayBase&lt; double &gt; const * 0 8576 36 PointerToArrayBase&lt; double &gt; const * 36 PointerToArrayBase&lt; double &gt; const * 0 0 1428 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1428 34 PointerToArrayBase&lt; double &gt; const 0 8832 34 PointerToArrayBase&lt; double &gt; const 34 PointerToArrayBase&lt; double &gt; const 0 0 1323 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1429 51 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; * 0 8576 51 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; * 51 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; * 0 0 1324 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1430 57 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; const * 0 8576 57 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; const * 57 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; const * 0 0 1431 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1431 55 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; const 0 8832 55 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; const 55 PointerToBase&lt; ReferenceCountedVector&lt; double &gt; &gt; const 0 0 1324 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1432 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 1377 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1433 21 PointerToVoid const * 0 8576 21 PointerToVoid const * 21 PointerToVoid const * 0 0 1434 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1434 19 PointerToVoid const 0 8832 19 PointerToVoid const 19 PointerToVoid const 0 0 1325 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1435 36 ConstPointerToArray&lt; float &gt; const * 0 8576 36 ConstPointerToArray&lt; float &gt; const * 36 ConstPointerToArray&lt; float &gt; const * 0 0 1436 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1436 34 ConstPointerToArray&lt; float &gt; const 0 8832 34 ConstPointerToArray&lt; float &gt; const 34 ConstPointerToArray&lt; float &gt; const 0 0 1328 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1437 30 ConstPointerToArray&lt; float &gt; * 0 8576 30 ConstPointerToArray&lt; float &gt; * 30 ConstPointerToArray&lt; float &gt; * 0 0 1328 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1438 31 PointerToArray&lt; float &gt; const * 0 8576 31 PointerToArray&lt; float &gt; const * 31 PointerToArray&lt; float &gt; const * 0 0 1439 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1439 29 PointerToArray&lt; float &gt; const 0 8832 29 PointerToArray&lt; float &gt; const 29 PointerToArray&lt; float &gt; const 0 0 1342 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1440 35 PointerToArrayBase&lt; float &gt; const * 0 8576 35 PointerToArrayBase&lt; float &gt; const * 35 PointerToArrayBase&lt; float &gt; const * 0 0 1441 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1441 33 PointerToArrayBase&lt; float &gt; const 0 8832 33 PointerToArrayBase&lt; float &gt; const 33 PointerToArrayBase&lt; float &gt; const 0 0 1329 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1442 50 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; * 0 8576 50 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; * 50 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; * 0 0 1330 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1443 56 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; const * 0 8576 56 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; const * 56 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; const * 0 0 1444 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1444 54 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; const 0 8832 54 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; const 54 PointerToBase&lt; ReferenceCountedVector&lt; float &gt; &gt; const 0 0 1330 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1445 34 ConstPointerToArray&lt; int &gt; const * 0 8576 34 ConstPointerToArray&lt; int &gt; const * 34 ConstPointerToArray&lt; int &gt; const * 0 0 1446 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1446 32 ConstPointerToArray&lt; int &gt; const 0 8832 32 ConstPointerToArray&lt; int &gt; const 32 ConstPointerToArray&lt; int &gt; const 0 0 1332 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1447 28 ConstPointerToArray&lt; int &gt; * 0 8576 28 ConstPointerToArray&lt; int &gt; * 28 ConstPointerToArray&lt; int &gt; * 0 0 1332 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1448 29 PointerToArray&lt; int &gt; const * 0 8576 29 PointerToArray&lt; int &gt; const * 29 PointerToArray&lt; int &gt; const * 0 0 1449 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1449 27 PointerToArray&lt; int &gt; const 0 8832 27 PointerToArray&lt; int &gt; const 27 PointerToArray&lt; int &gt; const 0 0 1344 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1450 33 PointerToArrayBase&lt; int &gt; const * 0 8576 33 PointerToArrayBase&lt; int &gt; const * 33 PointerToArrayBase&lt; int &gt; const * 0 0 1451 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1451 31 PointerToArrayBase&lt; int &gt; const 0 8832 31 PointerToArrayBase&lt; int &gt; const 31 PointerToArrayBase&lt; int &gt; const 0 0 1333 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1452 48 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; * 0 8576 48 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; * 48 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; * 0 0 1334 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1453 54 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; const * 0 8576 54 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; const * 54 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; const * 0 0 1454 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1454 52 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; const 0 8832 52 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; const 52 PointerToBase&lt; ReferenceCountedVector&lt; int &gt; &gt; const 0 0 1334 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1455 44 ConstPointerToArray&lt; unsigned char &gt; const * 0 8576 44 ConstPointerToArray&lt; unsigned char &gt; const * 44 ConstPointerToArray&lt; unsigned char &gt; const * 0 0 1456 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1456 42 ConstPointerToArray&lt; unsigned char &gt; const 0 8832 42 ConstPointerToArray&lt; unsigned char &gt; const 42 ConstPointerToArray&lt; unsigned char &gt; const 0 0 1336 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1457 38 ConstPointerToArray&lt; unsigned char &gt; * 0 8576 38 ConstPointerToArray&lt; unsigned char &gt; * 38 ConstPointerToArray&lt; unsigned char &gt; * 0 0 1336 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1458 39 PointerToArray&lt; unsigned char &gt; const * 0 8576 39 PointerToArray&lt; unsigned char &gt; const * 39 PointerToArray&lt; unsigned char &gt; const * 0 0 1459 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1459 37 PointerToArray&lt; unsigned char &gt; const 0 8832 37 PointerToArray&lt; unsigned char &gt; const 37 PointerToArray&lt; unsigned char &gt; const 0 0 1346 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1460 13 unsigned char 0 8198 13 unsigned char 13 unsigned char 0 5 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1461 43 PointerToArrayBase&lt; unsigned char &gt; const * 0 8576 43 PointerToArrayBase&lt; unsigned char &gt; const * 43 PointerToArrayBase&lt; unsigned char &gt; const * 0 0 1462 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1462 41 PointerToArrayBase&lt; unsigned char &gt; const 0 8832 41 PointerToArrayBase&lt; unsigned char &gt; const 41 PointerToArrayBase&lt; unsigned char &gt; const 0 0 1337 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1463 58 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; * 0 8576 58 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; * 58 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; * 0 0 1338 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1464 64 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; const * 0 8576 64 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; const * 64 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; const * 0 0 1465 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1465 62 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; const 0 8832 62 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; const 62 PointerToBase&lt; ReferenceCountedVector&lt; unsigned char &gt; &gt; const 0 0 1338 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1466 26 PointerToArray&lt; double &gt; * 0 8576 26 PointerToArray&lt; double &gt; * 26 PointerToArray&lt; double &gt; * 0 0 1340 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1467 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 1468 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1468 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">1469 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1470 25 PointerToArray&lt; float &gt; * 0 8576 25 PointerToArray&lt; float &gt; * 25 PointerToArray&lt; float &gt; * 0 0 1342 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1471 23 PointerToArray&lt; int &gt; * 0 8576 23 PointerToArray&lt; int &gt; * 23 PointerToArray&lt; int &gt; * 0 0 1344 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1472 33 PointerToArray&lt; unsigned char &gt; * 0 8576 33 PointerToArray&lt; unsigned char &gt; * 33 PointerToArray&lt; unsigned char &gt; * 0 0 1346 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1473 19 MemoryUsage const * 0 8576 19 MemoryUsage const * 19 MemoryUsage const * 0 0 1474 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1474 17 MemoryUsage const 0 8832 17 MemoryUsage const 17 MemoryUsage const 0 0 1347 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1475 13 MemoryUsage * 0 8576 13 MemoryUsage * 13 MemoryUsage * 0 0 1347 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1476 21 MemoryUsagePointers * 0 8576 21 MemoryUsagePointers * 21 MemoryUsagePointers * 0 0 1373 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1477 22 ReferenceCount const * 0 8576 22 ReferenceCount const * 22 ReferenceCount const * 0 0 1478 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1478 20 ReferenceCount const 0 8832 20 ReferenceCount const 20 ReferenceCount const 0 0 1352 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1479 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 1352 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1480 12 MemoryBase * 0 8576 12 MemoryBase * 12 MemoryBase * 0 0 1326 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1481 14 Buffer const * 0 8576 14 Buffer const * 14 Buffer const * 0 0 1482 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1482 12 Buffer const 0 8832 12 Buffer const 12 Buffer const 0 0 1354 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1483 8 Buffer * 0 8576 8 Buffer * 8 Buffer * 0 0 1354 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1484 27 PStatCollectorForwardBase * 0 8576 27 PStatCollectorForwardBase * 27 PStatCollectorForwardBase * 0 0 1355 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1485 26 NodeReferenceCount const * 0 8576 26 NodeReferenceCount const * 26 NodeReferenceCount const * 0 0 1486 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1486 24 NodeReferenceCount const 0 8832 24 NodeReferenceCount const 24 NodeReferenceCount const 0 0 1356 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1487 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 1357 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1488 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 1489 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1489 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 1357 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1490 12 vector_uchar 0 2105344 12 vector_uchar 12 vector_uchar 0 0 1491 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1491 24 pvector&lt; unsigned char &gt; 0 2048 24 pvector&lt; unsigned char &gt; 24 pvector&lt; unsigned char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1492 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1493 6 int8_t 0 2105344 6 int8_t 6 int8_t 0 0 1494 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1494 11 signed char 0 8202 11 signed char 11 signed char 0 5 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1495 7 uint8_t 0 2105344 7 uint8_t 7 uint8_t 0 0 1460 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1496 7 int16_t 0 2105344 7 int16_t 7 int16_t 0 0 1497 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1497 9 short int 0 8258 9 short int 9 short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1498 7 int32_t 0 2105344 7 int32_t 7 int32_t 0 0 1353 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1499 7 int64_t 0 2105344 7 int64_t 7 int64_t 0 0 1369 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1500 8 uint16_t 0 2105344 8 uint16_t 8 uint16_t 0 0 1501 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1501 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1502 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 1492 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1503 8 uint64_t 0 2105344 8 uint64_t 8 uint64_t 0 0 1351 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1504 10 PN_float32 0 2105344 10 PN_float32 10 PN_float32 0 0 1406 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1505 10 PN_float64 0 2105344 10 PN_float64 10 PN_float64 0 0 1403 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1506 11 PTA_uchar * 0 8576 11 PTA_uchar * 11 PTA_uchar * 0 0 1345 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1507 12 CPTA_uchar * 0 8576 12 CPTA_uchar * 12 CPTA_uchar * 0 0 1335 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1508 19 DatagramGenerator * 0 8576 19 DatagramGenerator * 19 DatagramGenerator * 0 0 1359 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1509 13 SubfileInfo * 0 8576 13 SubfileInfo * 13 SubfileInfo * 0 0 1386 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1510 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 1362 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1511 25 DatagramGenerator const * 0 8576 25 DatagramGenerator const * 25 DatagramGenerator const * 0 0 1512 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1512 23 DatagramGenerator const 0 8832 23 DatagramGenerator const 23 DatagramGenerator const 0 0 1359 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1513 6 time_t 0 2105344 6 time_t 6 time_t 0 0 1514 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1514 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1515 13 VirtualFile * 0 8576 13 VirtualFile * 13 VirtualFile * 0 0 1387 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1516 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 1360 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1517 24 DatagramIterator const * 0 8576 24 DatagramIterator const * 24 DatagramIterator const * 0 0 1518 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1518 22 DatagramIterator const 0 8832 22 DatagramIterator const 22 DatagramIterator const 0 0 1360 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1519 14 DatagramSink * 0 8576 14 DatagramSink * 14 DatagramSink * 0 0 1361 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1520 19 SubfileInfo const * 0 8576 19 SubfileInfo const * 19 SubfileInfo const * 0 0 1521 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1521 17 SubfileInfo const 0 8832 17 SubfileInfo const 17 SubfileInfo const 0 0 1386 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1522 15 FileReference * 0 8576 15 FileReference * 15 FileReference * 0 0 1366 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1523 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 1367 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1524 13 TypedObject * 0 8576 13 TypedObject * 13 TypedObject * 0 0 1358 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1525 9 Ramfile * 0 8576 9 Ramfile * 9 Ramfile * 0 0 1371 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1526 15 Ramfile const * 0 8576 15 Ramfile const * 15 Ramfile const * 0 0 1527 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1527 13 Ramfile const 0 8832 13 Ramfile const 13 Ramfile const 0 0 1371 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1528 9 HashVal * 0 8576 9 HashVal * 9 HashVal * 0 0 1372 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1529 15 HashVal const * 0 8576 15 HashVal const * 15 HashVal const * 0 0 1407 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1530 9 istream * 0 8576 14 std::istream * 14 std::istream * 0 0 1375 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1531 14 StreamWriter * 0 8576 14 StreamWriter * 14 StreamWriter * 0 0 1532 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1532 12 StreamWriter 0 2048 12 StreamWriter 12 StreamWriter 0 0 0 0 0 0 0 0 0 0 0 0 300</span>
<span class="s0">/**</span>
 <span class="s0">* A StreamWriter object is used to write sequential binary data directly to</span>
 <span class="s0">* an ostream.  Its interface is very similar to Datagram by design; it's</span>
 <span class="s0">* primarily intended as a convenience to eliminate the overhead of writing</span>
 <span class="s0">* bytes to a Datagram and then writing the Datagram to a stream.</span>
 <span class="s0">*/</span>

<span class="s0">1533 14 StreamReader * 0 8576 14 StreamReader * 14 StreamReader * 0 0 1534 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1534 12 StreamReader 0 2048 12 StreamReader 12 StreamReader 0 0 0 0 0 0 0 0 0 0 0 0 158</span>
<span class="s0">/**</span>
 <span class="s0">* A class to read sequential binary data directly from an istream.  Its</span>
 <span class="s0">* interface is similar to DatagramIterator by design; see also StreamWriter.</span>
 <span class="s0">*/</span>

<span class="s0">1535 27 MemoryUsagePointers const * 0 8576 27 MemoryUsagePointers const * 27 MemoryUsagePointers const * 0 0 1536 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1536 25 MemoryUsagePointers const 0 8832 25 MemoryUsagePointers const 25 MemoryUsagePointers const 0 0 1373 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1537 12 ISubStream * 0 8576 12 ISubStream * 12 ISubStream * 0 0 1374 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1538 16 IStreamWrapper * 0 8576 16 IStreamWrapper * 16 IStreamWrapper * 0 0 1539 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1539 14 IStreamWrapper 0 2048 14 IStreamWrapper 14 IStreamWrapper 0 0 0 0 0 0 0 0 0 0 0 0 168</span>
<span class="s0">/**</span>
 <span class="s0">* This class provides a locking wrapper around an arbitrary istream pointer.</span>
 <span class="s0">* A thread may use this class to perform an atomic seek/read/gcount</span>
 <span class="s0">* operation.</span>
 <span class="s0">*/</span>

<span class="s0">1540 12 OSubStream * 0 8576 12 OSubStream * 12 OSubStream * 0 0 1376 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1541 16 OStreamWrapper * 0 8576 16 OStreamWrapper * 16 OStreamWrapper * 0 0 1542 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1542 14 OStreamWrapper 0 2048 14 OStreamWrapper 14 OStreamWrapper 0 0 0 0 0 0 0 0 0 0 0 0 159</span>
<span class="s0">/**</span>
 <span class="s0">* This class provides a locking wrapper around an arbitrary ostream pointer.</span>
 <span class="s0">* A thread may use this class to perform an atomic seek/write operation.</span>
 <span class="s0">*/</span>

<span class="s0">1543 11 SubStream * 0 8576 11 SubStream * 11 SubStream * 0 0 1378 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1544 15 StreamWrapper * 0 8576 15 StreamWrapper * 15 StreamWrapper * 0 0 1545 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1545 13 StreamWrapper 0 2048 13 StreamWrapper 13 StreamWrapper 0 0 0 0 0 0 0 0 0 0 0 0 97</span>
<span class="s0">/**</span>
 <span class="s0">* This class provides a locking wrapper around a combination ostream/istream</span>
 <span class="s0">* pointer.</span>
 <span class="s0">*/</span>

<span class="s0">1546 11 Multifile * 0 8576 11 Multifile * 11 Multifile * 0 0 1380 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1547 10 iostream * 0 8576 15 std::iostream * 15 std::iostream * 0 0 1379 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1548 17 Multifile const * 0 8576 17 Multifile const * 17 Multifile const * 0 0 1549 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1549 15 Multifile const 0 8832 15 Multifile const 15 Multifile const 0 0 1380 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1550 15 vector_string * 0 8576 15 vector_string * 15 vector_string * 0 0 1551 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1551 13 vector_string 0 2105344 13 vector_string 13 vector_string 0 0 1552 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1552 17 pvector&lt; string &gt; 0 2048 22 pvector&lt; std::string &gt; 22 pvector&lt; std::string &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1553 15 Namable const * 0 8576 15 Namable const * 15 Namable const * 0 0 1554 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1554 13 Namable const 0 8832 13 Namable const 13 Namable const 0 0 1383 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1555 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 1383 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1556 16 OpenSSLWrapper * 0 8576 16 OpenSSLWrapper * 16 OpenSSLWrapper * 0 0 1385 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1557 12 X509_STORE * 0 8576 12 X509_STORE * 12 X509_STORE * 0 0 1558 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1558 10 X509_STORE 0 2105344 10 X509_STORE 10 X509_STORE 0 0 1559 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1559 13 x509_store_st 0 1024 13 x509_store_st 13 x509_store_st 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1560 10 streamsize 0 2105344 15 std::streamsize 15 std::streamsize 0 0 1369 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1561 19 VirtualFile const * 0 8576 19 VirtualFile const * 19 VirtualFile const * 0 0 1562 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1562 17 VirtualFile const 0 8832 17 VirtualFile const 17 VirtualFile const 0 0 1387 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1563 19 VirtualFileSystem * 0 8576 19 VirtualFileSystem * 19 VirtualFileSystem * 0 0 1398 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1564 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 1363 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1565 17 VirtualFileList * 0 8576 17 VirtualFileList * 17 VirtualFileList * 0 0 1397 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1566 24 VirtualFileMount const * 0 8576 24 VirtualFileMount const * 24 VirtualFileMount const * 0 0 1567 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1567 22 VirtualFileMount const 0 8832 22 VirtualFileMount const 22 VirtualFileMount const 0 0 1389 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1568 27 VirtualFileMountMultifile * 0 8576 27 VirtualFileMountMultifile * 27 VirtualFileMountMultifile * 0 0 1390 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1569 33 VirtualFileMountMultifile const * 0 8576 33 VirtualFileMountMultifile const * 33 VirtualFileMountMultifile const * 0 0 1570 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1570 31 VirtualFileMountMultifile const 0 8832 31 VirtualFileMountMultifile const 31 VirtualFileMountMultifile const 0 0 1390 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1571 25 VirtualFileMountRamdisk * 0 8576 25 VirtualFileMountRamdisk * 25 VirtualFileMountRamdisk * 0 0 1391 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1572 24 VirtualFileMountSystem * 0 8576 24 VirtualFileMountSystem * 24 VirtualFileMountSystem * 0 0 1392 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1573 30 VirtualFileMountSystem const * 0 8576 30 VirtualFileMountSystem const * 30 VirtualFileMountSystem const * 0 0 1574 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1574 28 VirtualFileMountSystem const 0 8832 28 VirtualFileMountSystem const 28 VirtualFileMountSystem const 0 0 1392 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1575 25 VirtualFileSimple const * 0 8576 25 VirtualFileSimple const * 25 VirtualFileSimple const * 0 0 1576 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1576 23 VirtualFileSimple const 0 8832 23 VirtualFileSimple const 23 VirtualFileSimple const 0 0 1393 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1577 18 VirtualFileMount * 0 8576 18 VirtualFileMount * 18 VirtualFileMount * 0 0 1389 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1578 15 TemporaryFile * 0 8576 15 TemporaryFile * 15 TemporaryFile * 0 0 1394 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1579 21 TemporaryFile const * 0 8576 21 TemporaryFile const * 21 TemporaryFile const * 0 0 1580 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1580 19 TemporaryFile const 0 8832 19 TemporaryFile const 19 TemporaryFile const 0 0 1394 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1581 19 IDecompressStream * 0 8576 19 IDecompressStream * 19 IDecompressStream * 0 0 1395 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1582 17 OCompressStream * 0 8576 17 OCompressStream * 17 OCompressStream * 0 0 1396 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1583 23 VirtualFileList const * 0 8576 23 VirtualFileList const * 23 VirtualFileList const * 0 0 1584 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1584 21 VirtualFileList const 0 8832 21 VirtualFileList const 21 VirtualFileList const 0 0 1397 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1585 25 VirtualFileSystem const * 0 8576 25 VirtualFileSystem const * 25 VirtualFileSystem const * 0 0 1586 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1586 23 VirtualFileSystem const 0 8832 23 VirtualFileSystem const 23 VirtualFileSystem const 0 0 1398 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1587 19 DSearchPath const * 0 8576 19 DSearchPath const * 19 DSearchPath const * 0 0 1588 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1588 17 DSearchPath const 0 8832 17 DSearchPath const 17 DSearchPath const 0 0 1589 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1589 11 DSearchPath 0 2048 11 DSearchPath 11 DSearchPath 0 0 0 0 0 0 0 0 0 0 0 0 304</span>
<span class="s0">/**</span>
 <span class="s0">* This class stores a list of directories that can be searched, in order, to</span>
 <span class="s0">* locate a particular file.  It is normally constructed by passing it a</span>
 <span class="s0">* traditional searchpath-style string, e.g.  a list of directory names</span>
 <span class="s0">* delimited by spaces or colons, but it can also be built up explicitly.</span>
 <span class="s0">*/</span>

<span class="s0">1590 9 Results * 0 8576 22 DSearchPath::Results * 22 DSearchPath::Results * 0 0 1591 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1591 7 Results 0 264192 20 DSearchPath::Results 20 DSearchPath::Results 1589 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1592 31 PointerTo&lt; VirtualFileMount &gt; * 0 8576 31 PointerTo&lt; VirtualFileMount &gt; * 31 PointerTo&lt; VirtualFileMount &gt; * 0 0 1400 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1593 17 decltype(nullptr) 0 8194 17 decltype(nullptr) 17 decltype(nullptr) 0 9 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1594 37 PointerTo&lt; VirtualFileMount &gt; const * 0 8576 37 PointerTo&lt; VirtualFileMount &gt; const * 37 PointerTo&lt; VirtualFileMount &gt; const * 0 0 1595 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1595 35 PointerTo&lt; VirtualFileMount &gt; const 0 8832 35 PointerTo&lt; VirtualFileMount &gt; const 35 PointerTo&lt; VirtualFileMount &gt; const 0 0 1400 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1596 35 PointerToBase&lt; VirtualFileMount &gt; * 0 8576 35 PointerToBase&lt; VirtualFileMount &gt; * 35 PointerToBase&lt; VirtualFileMount &gt; * 0 0 1401 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1597 41 PointerToBase&lt; VirtualFileMount &gt; const * 0 8576 41 PointerToBase&lt; VirtualFileMount &gt; const * 41 PointerToBase&lt; VirtualFileMount &gt; const * 0 0 1598 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1598 39 PointerToBase&lt; VirtualFileMount &gt; const 0 8832 39 PointerToBase&lt; VirtualFileMount &gt; const 39 PointerToBase&lt; VirtualFileMount &gt; const 0 0 1401 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1599 11 TrueClock * 0 8576 11 TrueClock * 11 TrueClock * 0 0 1402 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1600 17 TrueClock const * 0 8576 17 TrueClock const * 17 TrueClock const * 0 0 1601 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1601 15 TrueClock const 0 8832 15 TrueClock const 15 TrueClock const 0 0 1402 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1602 11 Patchfile * 0 8576 11 Patchfile * 11 Patchfile * 0 0 1404 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1603 17 Patchfile const * 0 8576 17 Patchfile const * 17 Patchfile const * 0 0 1604 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1604 15 Patchfile const 0 8832 15 Patchfile const 15 Patchfile const 0 0 1404 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1605 20 ProfileTimer const * 0 8576 20 ProfileTimer const * 20 ProfileTimer const * 0 0 1606 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1606 18 ProfileTimer const 0 8832 18 ProfileTimer const 18 ProfileTimer const 0 0 1408 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1607 14 ProfileTimer * 0 8576 14 ProfileTimer * 14 ProfileTimer * 0 0 1408 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1608 25 WeakPointerToVoid const * 0 8576 25 WeakPointerToVoid const * 25 WeakPointerToVoid const * 0 0 1609 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1609 23 WeakPointerToVoid const 0 8832 23 WeakPointerToVoid const 23 WeakPointerToVoid const 0 0 1409 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1610 17 WindowsRegistry * 0 8576 17 WindowsRegistry * 17 WindowsRegistry * 0 0 1410 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1611 23 WindowsRegistry const * 0 8576 23 WindowsRegistry const * 23 WindowsRegistry const * 0 0 1612 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">1612 21 WindowsRegistry const 0 8832 21 WindowsRegistry const 21 WindowsRegistry const 0 0 1410 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">26</span>
<span class="s0">1613 8 tracking 0 2 1349 837 0 0 0 0 0 0 0 21 MemoryUsage::tracking 0</span>

<span class="s0">1614 8 counting 0 2 1349 838 0 0 0 0 0 0 0 21 MemoryUsage::counting 0</span>

<span class="s0">1615 16 current_cpp_size 0 2 1350 839 0 0 0 0 0 0 0 29 MemoryUsage::current_cpp_size 0</span>

<span class="s0">1616 14 total_cpp_size 0 2 1350 840 0 0 0 0 0 0 0 27 MemoryUsage::total_cpp_size 0</span>

<span class="s0">1617 22 panda_heap_single_size 0 2 1350 841 0 0 0 0 0 0 0 35 MemoryUsage::panda_heap_single_size 0</span>

<span class="s0">1618 21 panda_heap_array_size 0 2 1350 842 0 0 0 0 0 0 0 34 MemoryUsage::panda_heap_array_size 0</span>

<span class="s0">1619 19 panda_heap_overhead 0 2 1350 843 0 0 0 0 0 0 0 32 MemoryUsage::panda_heap_overhead 0</span>

<span class="s0">1620 15 panda_mmap_size 0 2 1350 844 0 0 0 0 0 0 0 28 MemoryUsage::panda_mmap_size 0</span>

<span class="s0">1621 13 external_size 0 2 1350 845 0 0 0 0 0 0 0 26 MemoryUsage::external_size 0</span>

<span class="s0">1622 10 total_size 0 2 1350 846 0 0 0 0 0 0 0 23 MemoryUsage::total_size 0</span>

<span class="s0">1623 9 ref_count 0 2 1353 862 0 0 0 0 0 0 0 25 ReferenceCount::ref_count 31</span>
<span class="s0">// The current reference count.</span>

<span class="s0">1624 8 filename 0 2 1362 986 0 0 0 0 0 0 0 22 DatagramSink::filename 0</span>

<span class="s0">1625 4 file 0 2 1364 987 0 0 0 0 0 0 0 18 DatagramSink::file 0</span>

<span class="s0">1626 8 file_pos 0 2 1368 988 0 0 0 0 0 0 0 22 DatagramSink::file_pos 0</span>

<span class="s0">1627 12 magic_number 0 2 1381 1133 0 0 0 0 0 0 0 23 Multifile::magic_number 0</span>

<span class="s0">1628 4 name 0 6 1384 1140 1137 0 0 0 0 0 0 13 Namable::name 0</span>

<span class="s0">1629 6 mounts 0 66 1400 1238 0 0 0 0 1237 0 0 25 VirtualFileSystem::mounts 0</span>

<span class="s0">1630 9 long_time 0 2 1403 1277 0 0 0 0 0 0 0 20 TrueClock::long_time 203</span>
<span class="s0">// get_long_time() returns the most accurate timer we have over a long</span>
<span class="s0">// interval.  It may not be very precise for measuring short intervals, but</span>
<span class="s0">// it should not drift substantially over the long haul.</span>

<span class="s0">1631 10 short_time 0 2 1403 1278 0 0 0 0 0 0 0 21 TrueClock::short_time 206</span>
<span class="s0">// get_short_time() returns the most precise timer we have over a short</span>
<span class="s0">// interval.  It may tend to drift over the long haul, but it should have</span>
<span class="s0">// lots of digits to measure short intervals very precisely.</span>

<span class="s0">1632 14 short_raw_time 0 2 1403 1279 0 0 0 0 0 0 0 25 TrueClock::short_raw_time 144</span>
<span class="s0">// get_short_raw_time() is like get_short_time(), but does not apply any</span>
<span class="s0">// corrections (e.g.  paranoid-clock) to the result returned by the OS.</span>

<span class="s0">1633 11 error_count 0 2 1353 1280 0 0 0 0 0 0 0 22 TrueClock::error_count 0</span>

<span class="s0">1634 8 progress 0 2 1405 1290 0 0 0 0 0 0 0 19 Patchfile::progress 0</span>

<span class="s0">1635 15 allow_multifile 0 6 1349 1292 1291 0 0 0 0 0 0 26 Patchfile::allow_multifile 0</span>

<span class="s0">1636 16 footprint_length 0 6 1353 1294 1293 0 0 0 0 0 0 27 Patchfile::footprint_length 0</span>

<span class="s0">1637 11 source_hash 0 10 1407 1297 0 1296 0 0 0 0 0 22 Patchfile::source_hash 0</span>

<span class="s0">1638 11 result_hash 0 2 1407 1298 0 0 0 0 0 0 0 22 Patchfile::result_hash 0</span>

<span class="s0">5</span>
<span class="s0">1639 12 get_pointers 0 1052 1053 33 MemoryUsagePointers::get_pointers 0</span>

<span class="s0">1640 18 get_typed_pointers 0 1052 1054 39 MemoryUsagePointers::get_typed_pointers 0</span>

<span class="s0">1641 17 get_subfile_names 0 1111 1116 28 Multifile::get_subfile_names 0</span>

<span class="s0">1642 9 get_files 0 1223 1224 26 VirtualFileList::get_files 0</span>

<span class="s0">1643 10 get_mounts 0 1237 1238 29 VirtualFileSystem::get_mounts 0</span>

</pre>
</body>
</html>