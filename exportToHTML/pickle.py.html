<html>
<head>
<title>pickle.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pickle.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; This module extends standard Python's pickle module so that it is 
capable of writing more efficient pickle files that contain Panda 
objects with shared pointers.  In particular, a single Python 
structure that contains many NodePaths into the same scene graph will 
write the NodePaths correctly when used with this pickle module, so 
that when it is unpickled later, the NodePaths will still reference 
into the same scene graph together. 
 
If you use the standard pickle module instead, the NodePaths will each 
duplicate its own copy of its scene graph. 
 
This is necessary because the standard pickle module doesn't provide a 
mechanism for sharing context between different objects written to the 
same pickle stream, so each NodePath has to write itself without 
knowing about the other NodePaths that will also be writing to the 
same stream.  This replacement module solves this problem by defining 
a ``__reduce_persist__()`` replacement method for ``__reduce__()``, 
which accepts a pointer to the Pickler object itself, allowing for 
shared context between all objects written by that Pickler. 
 
Unfortunately, cPickle cannot be supported, because it does not 
support extensions of this nature. &quot;&quot;&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">&quot;PickleError&quot;</span><span class="s2">, </span><span class="s3">&quot;PicklingError&quot;</span><span class="s2">, </span><span class="s3">&quot;UnpicklingError&quot;</span><span class="s2">, </span><span class="s3">&quot;Pickler&quot;</span><span class="s2">,</span>
           <span class="s3">&quot;Unpickler&quot;</span><span class="s2">, </span><span class="s3">&quot;dump&quot;</span><span class="s2">, </span><span class="s3">&quot;dumps&quot;</span><span class="s2">, </span><span class="s3">&quot;load&quot;</span><span class="s2">, </span><span class="s3">&quot;loads&quot;</span><span class="s2">, </span><span class="s3">&quot;HIGHEST_PROTOCOL&quot;</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">sys</span>
<span class="s4">from </span><span class="s1">panda3d</span><span class="s2">.</span><span class="s1">core </span><span class="s4">import </span><span class="s1">BamWriter</span><span class="s2">, </span><span class="s1">BamReader</span><span class="s2">, </span><span class="s1">TypedObject</span>

<span class="s4">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">):</span>
    <span class="s4">from </span><span class="s1">copyreg </span><span class="s4">import </span><span class="s1">dispatch_table</span>
<span class="s4">else</span><span class="s2">:</span>
    <span class="s4">from </span><span class="s1">copy_reg </span><span class="s4">import </span><span class="s1">dispatch_table</span>

<span class="s6"># A funny replacement for &quot;import pickle&quot; so we don't get confused</span>
<span class="s6"># with the local pickle.py.</span>
<span class="s1">pickle </span><span class="s2">= </span><span class="s1">__import__</span><span class="s2">(</span><span class="s3">'pickle'</span><span class="s2">)</span>

<span class="s1">HIGHEST_PROTOCOL </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">HIGHEST_PROTOCOL</span>

<span class="s1">PickleError </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">PickleError</span>
<span class="s1">PicklingError </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">PicklingError</span>
<span class="s1">UnpicklingError </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">UnpicklingError</span>

<span class="s4">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">):</span>
    <span class="s1">DEFAULT_PROTOCOL </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">DEFAULT_PROTOCOL</span>
    <span class="s1">__all__</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;DEFAULT_PROTOCOL&quot;</span><span class="s2">)</span>

    <span class="s1">BasePickler </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">_Pickler</span>
    <span class="s1">BaseUnpickler </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">_Unpickler</span>
<span class="s4">else</span><span class="s2">:</span>
    <span class="s1">BasePickler </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">Pickler</span>
    <span class="s1">BaseUnpickler </span><span class="s2">= </span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">Unpickler</span>


<span class="s4">class </span><span class="s1">Pickler</span><span class="s2">(</span><span class="s1">BasePickler</span><span class="s2">):</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">bamWriter </span><span class="s2">= </span><span class="s1">BamWriter</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_canonical </span><span class="s2">= {}</span>
        <span class="s1">BasePickler</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">clear_memo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">BasePickler</span><span class="s2">.</span><span class="s1">clear_memo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_canonical</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">bamWriter </span><span class="s2">= </span><span class="s1">BamWriter</span><span class="s2">()</span>

    <span class="s6"># We have to duplicate most of the save() method, so we can add</span>
    <span class="s6"># support for __reduce_persist__().</span>

    <span class="s4">def </span><span class="s1">save</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">save_persistent_id</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">proto </span><span class="s2">&gt;= </span><span class="s5">4</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">framer</span><span class="s2">.</span><span class="s1">commit_frame</span><span class="s2">()</span>

        <span class="s6"># Check for persistent id (defined by a subclass)</span>
        <span class="s1">pid </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">persistent_id</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">pid </span><span class="s4">is not None and </span><span class="s1">save_persistent_id</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">save_pers</span><span class="s2">(</span><span class="s1">pid</span><span class="s2">)</span>
            <span class="s4">return</span>

        <span class="s6"># Check if this is a Panda type that we've already saved; if so, store</span>
        <span class="s6"># a mapping to the canonical copy, so that Python's memoization system</span>
        <span class="s6"># works properly.  This is needed because Python uses id(obj) for</span>
        <span class="s6"># memoization, but there may be multiple Python wrappers for the same</span>
        <span class="s6"># C++ pointer, and we don't want that to result in duplication.</span>
        <span class="s1">t </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">TypedObject</span><span class="s2">.</span><span class="s1">__base__</span><span class="s2">):</span>
            <span class="s1">canonical </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_canonical</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">this</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">canonical </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">obj </span><span class="s2">= </span><span class="s1">canonical</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s6"># First time we're seeing this C++ pointer; save it as the</span>
                <span class="s6"># &quot;canonical&quot; version.</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_canonical</span><span class="s2">[</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">this</span><span class="s2">] = </span><span class="s1">obj</span>

        <span class="s6"># Check the memo</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">memo</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">id</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">x</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]))</span>
            <span class="s4">return</span>

        <span class="s6"># Check the type dispatch table</span>
        <span class="s1">f </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">f</span><span class="s2">:</span>
            <span class="s1">f</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">) </span><span class="s6"># Call unbound method with explicit self</span>
            <span class="s4">return</span>

        <span class="s6"># Check for a class with a custom metaclass; treat as regular class</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">issc </span><span class="s2">= </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">type</span><span class="s2">)</span>
        <span class="s4">except </span><span class="s1">TypeError</span><span class="s2">: </span><span class="s6"># t is not a class (old Boost; see SF #502085)</span>
            <span class="s1">issc </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s4">if </span><span class="s1">issc</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">save_global</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
            <span class="s4">return</span>

        <span class="s6"># Check copy_reg.dispatch_table</span>
        <span class="s1">reduce </span><span class="s2">= </span><span class="s1">dispatch_table</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">reduce</span><span class="s2">:</span>
            <span class="s1">rv </span><span class="s2">= </span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s6"># New code: check for a __reduce_persist__ method, then</span>
            <span class="s6"># fall back to standard methods.</span>
            <span class="s1">reduce </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s3">&quot;__reduce_persist__&quot;</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">reduce</span><span class="s2">:</span>
                <span class="s1">rv </span><span class="s2">= </span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s6"># Check for a __reduce_ex__ method, fall back to __reduce__</span>
                <span class="s1">reduce </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s3">&quot;__reduce_ex__&quot;</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">reduce</span><span class="s2">:</span>
                    <span class="s1">rv </span><span class="s2">= </span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">proto</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">reduce </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s3">&quot;__reduce__&quot;</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
                    <span class="s4">if </span><span class="s1">reduce</span><span class="s2">:</span>
                        <span class="s1">rv </span><span class="s2">= </span><span class="s1">reduce</span><span class="s2">()</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s4">raise </span><span class="s1">PicklingError</span><span class="s2">(</span><span class="s3">&quot;Can't pickle %r object: %r&quot; </span><span class="s2">%</span>
                                            <span class="s2">(</span><span class="s1">t</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">))</span>

        <span class="s6"># Check for string returned by reduce(), meaning &quot;save as global&quot;</span>
        <span class="s4">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">rv</span><span class="s2">) </span><span class="s4">is </span><span class="s1">str</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">save_global</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">rv</span><span class="s2">)</span>
            <span class="s4">return</span>

        <span class="s6"># Assert that reduce() returned a tuple</span>
        <span class="s4">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">rv</span><span class="s2">) </span><span class="s4">is not </span><span class="s1">tuple</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">PicklingError</span><span class="s2">(</span><span class="s3">&quot;%s must return string or tuple&quot; </span><span class="s2">% </span><span class="s1">reduce</span><span class="s2">)</span>

        <span class="s6"># Assert that it returned an appropriately sized tuple</span>
        <span class="s1">l </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">rv</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s2">(</span><span class="s5">2 </span><span class="s2">&lt;= </span><span class="s1">l </span><span class="s2">&lt;= </span><span class="s5">5</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">PicklingError</span><span class="s2">(</span><span class="s3">&quot;Tuple returned by %s must have &quot;</span>
                                <span class="s3">&quot;two to five elements&quot; </span><span class="s2">% </span><span class="s1">reduce</span><span class="s2">)</span>

        <span class="s6"># Save the reduce() output and finally memoize the object</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">save_reduce</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">=</span><span class="s1">obj</span><span class="s2">, *</span><span class="s1">rv</span><span class="s2">)</span>


<span class="s4">class </span><span class="s1">Unpickler</span><span class="s2">(</span><span class="s1">BaseUnpickler</span><span class="s2">):</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">bamReader </span><span class="s2">= </span><span class="s1">BamReader</span><span class="s2">()</span>
        <span class="s1">BaseUnpickler</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>

    <span class="s6"># Duplicate the load_reduce() function, to provide a special case</span>
    <span class="s6"># for the reduction function.</span>

    <span class="s4">def </span><span class="s1">load_reduce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">stack </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">stack</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">stack</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">stack</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>

        <span class="s6"># If the function name ends with &quot;_persist&quot;, then assume the</span>
        <span class="s6"># function wants the Unpickler as the first parameter.</span>
        <span class="s1">func_name </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s4">if </span><span class="s1">func_name</span><span class="s2">.</span><span class="s1">endswith</span><span class="s2">(</span><span class="s3">'_persist'</span><span class="s2">) </span><span class="s4">or </span><span class="s1">func_name</span><span class="s2">.</span><span class="s1">endswith</span><span class="s2">(</span><span class="s3">'Persist'</span><span class="s2">):</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s6"># Otherwise, use the existing pickle convention.</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>

        <span class="s1">stack</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] = </span><span class="s1">value</span>

    <span class="s4">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">):</span>
        <span class="s1">BaseUnpickler</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">[</span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">REDUCE</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]] = </span><span class="s1">load_reduce</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">BaseUnpickler</span><span class="s2">.</span><span class="s1">dispatch</span><span class="s2">[</span><span class="s1">pickle</span><span class="s2">.</span><span class="s1">REDUCE</span><span class="s2">] = </span><span class="s1">load_reduce</span>


<span class="s6"># Shorthands</span>
<span class="s4">from </span><span class="s1">io </span><span class="s4">import </span><span class="s1">BytesIO</span>

<span class="s4">def </span><span class="s1">dump</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">protocol</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s1">Pickler</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">protocol</span><span class="s2">).</span><span class="s1">dump</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">dumps</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">protocol</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s1">file </span><span class="s2">= </span><span class="s1">BytesIO</span><span class="s2">()</span>
    <span class="s1">Pickler</span><span class="s2">(</span><span class="s1">file</span><span class="s2">, </span><span class="s1">protocol</span><span class="s2">).</span><span class="s1">dump</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">file</span><span class="s2">.</span><span class="s1">getvalue</span><span class="s2">()</span>

<span class="s4">def </span><span class="s1">load</span><span class="s2">(</span><span class="s1">file</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s1">Unpickler</span><span class="s2">(</span><span class="s1">file</span><span class="s2">).</span><span class="s1">load</span><span class="s2">()</span>

<span class="s4">def </span><span class="s1">loads</span><span class="s2">(</span><span class="s1">str</span><span class="s2">):</span>
    <span class="s1">file </span><span class="s2">= </span><span class="s1">BytesIO</span><span class="s2">(</span><span class="s1">str</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">Unpickler</span><span class="s2">(</span><span class="s1">file</span><span class="s2">).</span><span class="s1">load</span><span class="s2">()</span>
</pre>
</body>
</html>