<html>
<head>
<title>libp3pnmtext.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3pnmtext.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">12 libp3pnmtext 4 g64k 12 panda3d.core </span>
<span class="s0">46</span>
<span class="s0">51 13 ~FreetypeFont 0 516 97 27 FreetypeFont::~FreetypeFont 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">41</span>
<span class="s0">inline FreetypeFont::~FreetypeFont(void);</span>

<span class="s0">52 14 set_point_size 0 4 97 28 FreetypeFont::set_point_size 0 1 1 295</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the point size of the font.  This controls the apparent size of the</span>
 <span class="s0">* font onscreen.  By convention, a 10 point font is about 1 screen unit high.</span>
 <span class="s0">*</span>
 <span class="s0">* This should only be called before any characters have been requested out of</span>
 <span class="s0">* the font, or immediately after calling clear().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool FreetypeFont::set_point_size(PN_stdfloat point_size);</span>

<span class="s0">53 14 get_point_size 0 4 97 28 FreetypeFont::get_point_size 0 1 2 46</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point size of the font.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PN_stdfloat FreetypeFont::get_point_size(void) const;</span>

<span class="s0">54 19 set_pixels_per_unit 0 4 97 33 FreetypeFont::set_pixels_per_unit 0 1 3 433</span>
<span class="s0">/**</span>
 <span class="s0">* Set the resolution of the texture map, and hence the clarity of the</span>
 <span class="s0">* resulting font.  This sets the number of pixels in the texture map that are</span>
 <span class="s0">* used for each onscreen unit.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this number larger results in an easier to read font, but at the</span>
 <span class="s0">* cost of more texture memory.</span>
 <span class="s0">*</span>
 <span class="s0">* This should only be called before any characters have been requested out of</span>
 <span class="s0">* the font, or immediately after calling clear().</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline bool FreetypeFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit);</span>

<span class="s0">55 19 get_pixels_per_unit 0 4 97 33 FreetypeFont::get_pixels_per_unit 0 1 4 81</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the resolution of the texture map.  See set_pixels_per_unit().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline PN_stdfloat FreetypeFont::get_pixels_per_unit(void) const;</span>

<span class="s0">56 14 set_pixel_size 0 4 97 28 FreetypeFont::set_pixel_size 0 1 5 197</span>
<span class="s0">/**</span>
 <span class="s0">* Computes the appropriate pixels_per_unit value to set the size of the font</span>
 <span class="s0">* in the texture to the indicated number of pixels.  This is just another way</span>
 <span class="s0">* to specify pixels_per_unit().</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline bool FreetypeFont::set_pixel_size(PN_stdfloat pixel_size);</span>

<span class="s0">57 14 get_pixel_size 0 4 97 28 FreetypeFont::get_pixel_size 0 1 6 80</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of the font in pixels, as it appears in the texture.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PN_stdfloat FreetypeFont::get_pixel_size(void) const;</span>

<span class="s0">58 16 set_scale_factor 0 4 97 30 FreetypeFont::set_scale_factor 0 1 7 565</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the factor by which the font is rendered larger by the FreeType</span>
 <span class="s0">* library before being filtered down to its actual size in the texture as</span>
 <span class="s0">* specified by set_pixels_per_unit().  This may be set to a number larger</span>
 <span class="s0">* than 1.0 to improve the font's antialiasing (since FreeType doesn't really</span>
 <span class="s0">* do a swell job of antialiasing by itself).  There is some performance</span>
 <span class="s0">* implication for setting this different than 1.0.</span>
 <span class="s0">*</span>
 <span class="s0">* This should only be called before any characters have been requested out of</span>
 <span class="s0">* the font, or immediately after calling clear().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline bool FreetypeFont::set_scale_factor(PN_stdfloat scale_factor);</span>

<span class="s0">59 16 get_scale_factor 0 4 97 30 FreetypeFont::get_scale_factor 0 1 8 74</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the antialiasing scale factor.  See set_scale_factor().</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline PN_stdfloat FreetypeFont::get_scale_factor(void) const;</span>

<span class="s0">60 20 set_native_antialias 0 4 97 34 FreetypeFont::set_native_antialias 0 1 9 469</span>
<span class="s0">/**</span>
 <span class="s0">* Sets whether the Freetype library's built-in antialias mode is enabled.</span>
 <span class="s0">* There are two unrelated ways to achieve antialiasing: with Freetype's</span>
 <span class="s0">* native antialias mode, and with the use of a scale_factor greater than one.</span>
 <span class="s0">* By default, both modes are enabled.</span>
 <span class="s0">*</span>
 <span class="s0">* At low resolutions, some fonts may do better with one mode or the other.</span>
 <span class="s0">* In general, Freetype's native antialiasing will produce less blurry</span>
 <span class="s0">* results, but may introduce more artifacts.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void FreetypeFont::set_native_antialias(bool native_antialias);</span>

<span class="s0">61 20 get_native_antialias 0 4 97 34 FreetypeFont::get_native_antialias 0 1 10 105</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether Freetype's built-in antialias mode is enabled.  See</span>
 <span class="s0">* set_native_antialias().</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline bool FreetypeFont::get_native_antialias(void) const;</span>

<span class="s0">62 19 get_font_pixel_size 0 4 97 33 FreetypeFont::get_font_pixel_size 0 1 11 386</span>
<span class="s0">/**</span>
 <span class="s0">* This is used to report whether the requested pixel size is being only</span>
 <span class="s0">* approximated by a fixed-pixel-size font.  This returns 0 in the normal</span>
 <span class="s0">* case, in which a scalable font is used, or the fixed-pixel-size font has</span>
 <span class="s0">* exactly the requested pixel size.</span>
 <span class="s0">*</span>
 <span class="s0">* If this returns non-zero, it is the pixel size of the font that we are</span>
 <span class="s0">* using to approximate our desired size.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int FreetypeFont::get_font_pixel_size(void) const;</span>

<span class="s0">63 15 get_line_height 0 4 97 29 FreetypeFont::get_line_height 0 1 12 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of units high each line of text is.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline PN_stdfloat FreetypeFont::get_line_height(void) const;</span>

<span class="s0">64 17 get_space_advance 0 4 97 31 FreetypeFont::get_space_advance 0 1 13 55</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of units wide a space is.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline PN_stdfloat FreetypeFont::get_space_advance(void) const;</span>

<span class="s0">65 19 get_points_per_unit 0 4 97 33 FreetypeFont::get_points_per_unit 0 1 14 146</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point size of the font that is one Panda unit high.  This is an</span>
 <span class="s0">* arbitrary Panda convention for text, and is set to 10.0.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline PN_stdfloat FreetypeFont::get_points_per_unit(void);</span>

<span class="s0">66 19 get_points_per_inch 0 4 97 33 FreetypeFont::get_points_per_inch 0 1 15 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of points in one inch.  This is a universal typographic</span>
 <span class="s0">* convention.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">static inline PN_stdfloat FreetypeFont::get_points_per_inch(void);</span>

<span class="s0">67 17 set_winding_order 0 4 97 31 FreetypeFont::set_winding_order 0 1 16 258</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies an explicitly winding order on this particular font.  This is</span>
 <span class="s0">* only necessary if the render_mode is RM_polygon or RM_solid, and only if</span>
 <span class="s0">* FreeType appears to guess wrong on this font.  Normally, you should leave</span>
 <span class="s0">* this at WO_default.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void FreetypeFont::set_winding_order(FreetypeFont::WindingOrder winding_order);</span>

<span class="s0">68 17 get_winding_order 0 4 97 31 FreetypeFont::get_winding_order 0 1 17 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the winding order set via set_winding_order().</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">inline FreetypeFont::WindingOrder FreetypeFont::get_winding_order(void) const;</span>

<span class="s0">69 12 PNMTextGlyph 0 260 100 26 PNMTextGlyph::PNMTextGlyph 0 2 18 19 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">119</span>
<span class="s0">explicit PNMTextGlyph::PNMTextGlyph(double advance);</span>
<span class="s0">inline PNMTextGlyph::PNMTextGlyph(PNMTextGlyph const &amp;) = default;</span>

<span class="s0">70 13 ~PNMTextGlyph 0 516 100 27 PNMTextGlyph::~PNMTextGlyph 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">PNMTextGlyph::~PNMTextGlyph(void);</span>

<span class="s0">71 11 get_advance 0 4 100 25 PNMTextGlyph::get_advance 0 1 20 106</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of pixels by which the pen should be advanced after</span>
 <span class="s0">* rendering this glyph.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int PNMTextGlyph::get_advance(void) const;</span>

<span class="s0">72 5 place 0 4 100 19 PNMTextGlyph::place 0 2 21 22 431</span>
<span class="s0">/**</span>
 <span class="s0">* Copies the glyph to the indicated destination image at the indicated</span>
 <span class="s0">* origin.  It colors the glyph pixels the indicated foreground color, blends</span>
 <span class="s0">* antialiased pixels with the appropriate amount of the foreground color and</span>
 <span class="s0">* the existing background color, and leaves other pixels alone.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This flavor of place() also fills in the interior color.  This requires</span>
 <span class="s0">* that determine_interior was called earlier.</span>
 <span class="s0">*/</span>
<span class="s0">187</span>
<span class="s0">void PNMTextGlyph::place(PNMImage &amp;dest_image, int xp, int yp, LColor const &amp;fg);</span>
<span class="s0">void PNMTextGlyph::place(PNMImage &amp;dest_image, int xp, int yp, LColor const &amp;fg, LColor const &amp;interior);</span>

<span class="s0">73 8 get_left 0 4 100 22 PNMTextGlyph::get_left 0 1 23 71</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x coordinate of the leftmost pixel in the glyph.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline int PNMTextGlyph::get_left(void) const;</span>

<span class="s0">74 9 get_right 0 4 100 23 PNMTextGlyph::get_right 0 1 24 72</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the x coordinate of the rightmost pixel in the glyph.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int PNMTextGlyph::get_right(void) const;</span>

<span class="s0">75 10 get_bottom 0 4 100 24 PNMTextGlyph::get_bottom 0 1 25 73</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the y coordinate of the bottommost pixel in the glyph.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int PNMTextGlyph::get_bottom(void) const;</span>

<span class="s0">76 7 get_top 0 4 100 21 PNMTextGlyph::get_top 0 1 26 70</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the y coordinate of the topmost pixel in the glyph.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline int PNMTextGlyph::get_top(void) const;</span>

<span class="s0">77 10 get_height 0 4 100 24 PNMTextGlyph::get_height 0 1 27 53</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the height of the glyph in pixels.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline int PNMTextGlyph::get_height(void) const;</span>

<span class="s0">78 9 get_width 0 4 100 23 PNMTextGlyph::get_width 0 1 28 52</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the width of the glyph in pixels.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline int PNMTextGlyph::get_width(void) const;</span>

<span class="s0">79 9 get_value 0 4 100 23 PNMTextGlyph::get_value 0 1 29 241</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the value of the indicated pixel of the glyph.  The result is in</span>
 <span class="s0">* the range [0, 1], where 0 indicates the pixel is not part of the glyph, and</span>
 <span class="s0">* 1 indicates it is.  Intermediate values are used to represent antialiasing.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline double PNMTextGlyph::get_value(int x, int y) const;</span>

<span class="s0">80 17 get_interior_flag 0 4 100 31 PNMTextGlyph::get_interior_flag 0 1 30 119</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the indicated pixel represents a pixel in the interior of a</span>
 <span class="s0">* hollow font, false otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline bool PNMTextGlyph::get_interior_flag(int x, int y) const;</span>

<span class="s0">81 12 PNMTextMaker 0 260 101 26 PNMTextMaker::PNMTextMaker 0 4 31 32 33 34 328</span>
<span class="s0">/**</span>
 <span class="s0">* The constructor expects the name of some font file that FreeType can read,</span>
 <span class="s0">* along with face_index, indicating which font within the file to load</span>
 <span class="s0">* (usually 0).</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This constructor works as above, but it takes the font data from an in-</span>
 <span class="s0">* memory buffer instead of from a named file.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">293</span>
<span class="s0">explicit PNMTextMaker::PNMTextMaker(Filename const &amp;font_filename, int face_index);</span>
<span class="s0">explicit PNMTextMaker::PNMTextMaker(char const *font_data, int data_length, int face_index);</span>
<span class="s0">explicit PNMTextMaker::PNMTextMaker(FreetypeFont const &amp;copy);</span>
<span class="s0">PNMTextMaker::PNMTextMaker(PNMTextMaker const &amp;copy);</span>

<span class="s0">82 13 ~PNMTextMaker 0 516 101 27 PNMTextMaker::~PNMTextMaker 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">34</span>
<span class="s0">PNMTextMaker::~PNMTextMaker(void);</span>

<span class="s0">83 8 is_valid 0 4 101 22 PNMTextMaker::is_valid 0 1 35 100</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the PNMTextMaker is valid and ready to generate text, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">47</span>
<span class="s0">inline bool PNMTextMaker::is_valid(void) const;</span>

<span class="s0">84 9 set_align 0 4 101 23 PNMTextMaker::set_align 0 1 36 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline void PNMTextMaker::set_align(PNMTextMaker::Alignment align_type);</span>

<span class="s0">85 9 get_align 0 4 101 23 PNMTextMaker::get_align 0 1 37 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline PNMTextMaker::Alignment PNMTextMaker::get_align(void) const;</span>

<span class="s0">86 17 set_interior_flag 0 4 101 31 PNMTextMaker::set_interior_flag 0 1 38 443</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag that indicates whether the interior of hollow fonts is</span>
 <span class="s0">* identified as a preprocess as each glyph is loaded.  If this flag is true,</span>
 <span class="s0">* you may specify an interior color along with a fg and bg color when you</span>
 <span class="s0">* place text; if the flag is false, the interior color is ignored.</span>
 <span class="s0">*</span>
 <span class="s0">* It is generally best to set_native_antialias(0) when using this feature.</span>
 <span class="s0">* Also, this works best when the pixel size is not very small.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void PNMTextMaker::set_interior_flag(bool interior_flag);</span>

<span class="s0">87 17 get_interior_flag 0 4 101 31 PNMTextMaker::get_interior_flag 0 1 39 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool PNMTextMaker::get_interior_flag(void) const;</span>

<span class="s0">88 6 set_fg 0 4 101 20 PNMTextMaker::set_fg 0 1 40 182</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the foreground color of text that will be generated by future calls to</span>
 <span class="s0">* generate_into().  This is the color that all of the &quot;on&quot; pixels in the font</span>
 <span class="s0">* will show as.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void PNMTextMaker::set_fg(LColor const &amp;fg);</span>

<span class="s0">89 6 get_fg 0 4 101 20 PNMTextMaker::get_fg 0 1 41 109</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the foreground color of text that will be generated by future calls</span>
 <span class="s0">* to generate_into().</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LColor const &amp;PNMTextMaker::get_fg(void) const;</span>

<span class="s0">90 12 set_interior 0 4 101 26 PNMTextMaker::set_interior 0 1 42 183</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color that will be used to render the interior portions of hollow</span>
 <span class="s0">* fonts in future calls to generate_into().  This is respected only if</span>
 <span class="s0">* interior_flag is true.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void PNMTextMaker::set_interior(LColor const &amp;interior);</span>

<span class="s0">91 12 get_interior 0 4 101 26 PNMTextMaker::get_interior 0 1 43 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color that will be used to render the interior portions of</span>
 <span class="s0">* hollow fonts.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline LColor const &amp;PNMTextMaker::get_interior(void) const;</span>

<span class="s0">92 25 set_distance_field_radius 0 4 101 39 PNMTextMaker::set_distance_field_radius 0 1 44 122</span>
<span class="s0">/**</span>
 <span class="s0">* If this is set to something other than 0, Panda will generate a signed</span>
 <span class="s0">* distance field with the given radius.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void PNMTextMaker::set_distance_field_radius(int radius);</span>

<span class="s0">93 25 get_distance_field_radius 0 4 101 39 PNMTextMaker::get_distance_field_radius 0 1 45 95</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the radius previously set with set_distance_field_radius, or 0</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline int PNMTextMaker::get_distance_field_radius(void) const;</span>

<span class="s0">94 13 generate_into 0 4 101 27 PNMTextMaker::generate_into 0 2 46 47 290</span>
<span class="s0">/**</span>
 <span class="s0">* Generates a single line of text into the indicated image at the indicated</span>
 <span class="s0">* position; the return value is the total width in pixels.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Generates a single line of text into the indicated image at the indicated</span>
 <span class="s0">* position; the return value is the total width in pixels.</span>
 <span class="s0">*/</span>
<span class="s0">195</span>
<span class="s0">inline int PNMTextMaker::generate_into(std::string const &amp;text, PNMImage &amp;dest_image, int x, int y);</span>
<span class="s0">int PNMTextMaker::generate_into(std::wstring const &amp;text, PNMImage &amp;dest_image, int x, int y);</span>

<span class="s0">95 10 calc_width 0 4 101 24 PNMTextMaker::calc_width 0 2 48 49 140</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the width in pixels of the indicated line of text.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the width in pixels of the indicated line of text.</span>
 <span class="s0">*/</span>
<span class="s0">117</span>
<span class="s0">inline int PNMTextMaker::calc_width(std::string const &amp;text);</span>
<span class="s0">int PNMTextMaker::calc_width(std::wstring const &amp;text);</span>

<span class="s0">96 9 get_glyph 0 4 101 23 PNMTextMaker::get_glyph 0 1 50 98</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the glyph for the indicated index, or NULL if it is not defined in</span>
 <span class="s0">* the font.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">PNMTextGlyph *PNMTextMaker::get_glyph(int character);</span>

<span class="s0">50</span>
<span class="s0">1 0 0 6 5 106 0 0 295 /**</span>
 <span class="s0">* Sets the point size of the font.  This controls the apparent size of the</span>
 <span class="s0">* font onscreen.  By convention, a 10 point font is about 1 screen unit high.</span>
 <span class="s0">*</span>
 <span class="s0">* This should only be called before any characters have been requested out of</span>
 <span class="s0">* the font, or immediately after calling clear().</span>
 <span class="s0">*/ 2 4 this 3 103  10 point_size 1 104  </span>
<span class="s0">2 0 0 6 6 104 0 0 46 /**</span>
 <span class="s0">* Returns the point size of the font.</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">3 0 0 6 7 106 0 0 433 /**</span>
 <span class="s0">* Set the resolution of the texture map, and hence the clarity of the</span>
 <span class="s0">* resulting font.  This sets the number of pixels in the texture map that are</span>
 <span class="s0">* used for each onscreen unit.</span>
 <span class="s0">*</span>
 <span class="s0">* Setting this number larger results in an easier to read font, but at the</span>
 <span class="s0">* cost of more texture memory.</span>
 <span class="s0">*</span>
 <span class="s0">* This should only be called before any characters have been requested out of</span>
 <span class="s0">* the font, or immediately after calling clear().</span>
 <span class="s0">*/ 2 4 this 3 103  15 pixels_per_unit 1 104  </span>
<span class="s0">4 0 0 6 8 104 0 0 81 /**</span>
 <span class="s0">* Returns the resolution of the texture map.  See set_pixels_per_unit().</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">5 0 0 6 9 106 0 0 197 /**</span>
 <span class="s0">* Computes the appropriate pixels_per_unit value to set the size of the font</span>
 <span class="s0">* in the texture to the indicated number of pixels.  This is just another way</span>
 <span class="s0">* to specify pixels_per_unit().</span>
 <span class="s0">*/ 2 4 this 3 103  10 pixel_size 1 104  </span>
<span class="s0">6 0 0 6 10 104 0 0 80 /**</span>
 <span class="s0">* Returns the size of the font in pixels, as it appears in the texture.</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">7 0 0 6 11 106 0 0 565 /**</span>
 <span class="s0">* Sets the factor by which the font is rendered larger by the FreeType</span>
 <span class="s0">* library before being filtered down to its actual size in the texture as</span>
 <span class="s0">* specified by set_pixels_per_unit().  This may be set to a number larger</span>
 <span class="s0">* than 1.0 to improve the font's antialiasing (since FreeType doesn't really</span>
 <span class="s0">* do a swell job of antialiasing by itself).  There is some performance</span>
 <span class="s0">* implication for setting this different than 1.0.</span>
 <span class="s0">*</span>
 <span class="s0">* This should only be called before any characters have been requested out of</span>
 <span class="s0">* the font, or immediately after calling clear().</span>
 <span class="s0">*/ 2 4 this 3 103  12 scale_factor 1 104  </span>
<span class="s0">8 0 0 6 12 104 0 0 74 /**</span>
 <span class="s0">* Returns the antialiasing scale factor.  See set_scale_factor().</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">9 0 0 4 13 109 0 0 469 /**</span>
 <span class="s0">* Sets whether the Freetype library's built-in antialias mode is enabled.</span>
 <span class="s0">* There are two unrelated ways to achieve antialiasing: with Freetype's</span>
 <span class="s0">* native antialias mode, and with the use of a scale_factor greater than one.</span>
 <span class="s0">* By default, both modes are enabled.</span>
 <span class="s0">*</span>
 <span class="s0">* At low resolutions, some fonts may do better with one mode or the other.</span>
 <span class="s0">* In general, Freetype's native antialiasing will produce less blurry</span>
 <span class="s0">* results, but may introduce more artifacts.</span>
 <span class="s0">*/ 2 4 this 3 103  16 native_antialias 1 106  </span>
<span class="s0">10 0 0 6 14 106 0 0 105 /**</span>
 <span class="s0">* Returns whether Freetype's built-in antialias mode is enabled.  See</span>
 <span class="s0">* set_native_antialias().</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">11 0 0 6 15 110 0 0 386 /**</span>
 <span class="s0">* This is used to report whether the requested pixel size is being only</span>
 <span class="s0">* approximated by a fixed-pixel-size font.  This returns 0 in the normal</span>
 <span class="s0">* case, in which a scalable font is used, or the fixed-pixel-size font has</span>
 <span class="s0">* exactly the requested pixel size.</span>
 <span class="s0">*</span>
 <span class="s0">* If this returns non-zero, it is the pixel size of the font that we are</span>
 <span class="s0">* using to approximate our desired size.</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">12 0 0 6 16 104 0 0 65 /**</span>
 <span class="s0">* Returns the number of units high each line of text is.</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">13 0 0 6 17 104 0 0 55 /**</span>
 <span class="s0">* Returns the number of units wide a space is.</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">14 0 0 6 18 104 0 0 146 /**</span>
 <span class="s0">* Returns the point size of the font that is one Panda unit high.  This is an</span>
 <span class="s0">* arbitrary Panda convention for text, and is set to 10.0.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">15 0 0 6 19 104 0 0 100 /**</span>
 <span class="s0">* Returns the number of points in one inch.  This is a universal typographic</span>
 <span class="s0">* convention.</span>
 <span class="s0">*/ 0 </span>
<span class="s0">16 0 0 4 20 109 0 0 258 /**</span>
 <span class="s0">* Specifies an explicitly winding order on this particular font.  This is</span>
 <span class="s0">* only necessary if the render_mode is RM_polygon or RM_solid, and only if</span>
 <span class="s0">* FreeType appears to guess wrong on this font.  Normally, you should leave</span>
 <span class="s0">* this at WO_default.</span>
 <span class="s0">*/ 2 4 this 3 103  13 winding_order 1 99  </span>
<span class="s0">17 0 0 6 21 99 0 0 65 /**</span>
 <span class="s0">* Returns the winding order set via set_winding_order().</span>
 <span class="s0">*/ 1 4 this 3 107  </span>
<span class="s0">18 0 0 15 24 113 70 0 0 1 6 param0 0 111  </span>
<span class="s0">19 0 0 7 24 113 70 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 7 advance 1 114  </span>
<span class="s0">20 0 0 6 26 110 0 0 106 /**</span>
 <span class="s0">* Returns the number of pixels by which the pen should be advanced after</span>
 <span class="s0">* rendering this glyph.</span>
 <span class="s0">*/ 1 4 this 3 111  </span>
<span class="s0">21 0 0 4 27 109 0 0 300 /**</span>
 <span class="s0">* Copies the glyph to the indicated destination image at the indicated</span>
 <span class="s0">* origin.  It colors the glyph pixels the indicated foreground color, blends</span>
 <span class="s0">* antialiased pixels with the appropriate amount of the foreground color and</span>
 <span class="s0">* the existing background color, and leaves other pixels alone.</span>
 <span class="s0">*/ 5 4 this 3 113  10 dest_image 1 115  2 xp 1 110  2 yp 1 110  2 fg 1 117  </span>
<span class="s0">22 0 0 4 27 109 0 0 129 /**</span>
 <span class="s0">* This flavor of place() also fills in the interior color.  This requires</span>
 <span class="s0">* that determine_interior was called earlier.</span>
 <span class="s0">*/ 6 4 this 3 113  10 dest_image 1 115  2 xp 1 110  2 yp 1 110  2 fg 1 117  8 interior 1 117  </span>
<span class="s0">23 0 0 6 28 110 0 0 71 /**</span>
 <span class="s0">* Returns the x coordinate of the leftmost pixel in the glyph.</span>
 <span class="s0">*/ 1 4 this 3 111  </span>
<span class="s0">24 0 0 6 29 110 0 0 72 /**</span>
 <span class="s0">* Returns the x coordinate of the rightmost pixel in the glyph.</span>
 <span class="s0">*/ 1 4 this 3 111  </span>
<span class="s0">25 0 0 6 30 110 0 0 73 /**</span>
 <span class="s0">* Returns the y coordinate of the bottommost pixel in the glyph.</span>
 <span class="s0">*/ 1 4 this 3 111  </span>
<span class="s0">26 0 0 6 31 110 0 0 70 /**</span>
 <span class="s0">* Returns the y coordinate of the topmost pixel in the glyph.</span>
 <span class="s0">*/ 1 4 this 3 111  </span>
<span class="s0">27 0 0 6 32 110 0 0 53 /**</span>
 <span class="s0">* Returns the height of the glyph in pixels.</span>
 <span class="s0">*/ 1 4 this 3 111  </span>
<span class="s0">28 0 0 6 33 110 0 0 52 /**</span>
 <span class="s0">* Returns the width of the glyph in pixels.</span>
 <span class="s0">*/ 1 4 this 3 111  </span>
<span class="s0">29 0 0 6 34 114 0 0 241 /**</span>
 <span class="s0">* Returns the value of the indicated pixel of the glyph.  The result is in</span>
 <span class="s0">* the range [0, 1], where 0 indicates the pixel is not part of the glyph, and</span>
 <span class="s0">* 1 indicates it is.  Intermediate values are used to represent antialiasing.</span>
 <span class="s0">*/ 3 4 this 3 111  1 x 1 110  1 y 1 110  </span>
<span class="s0">30 0 0 6 35 106 0 0 119 /**</span>
 <span class="s0">* Returns true if the indicated pixel represents a pixel in the interior of a</span>
 <span class="s0">* hollow font, false otherwise.</span>
 <span class="s0">*/ 3 4 this 3 111  1 x 1 110  1 y 1 110  </span>
<span class="s0">31 0 0 7 37 125 82 0 173 /**</span>
 <span class="s0">* The constructor expects the name of some font file that FreeType can read,</span>
 <span class="s0">* along with face_index, indicating which font within the file to load</span>
 <span class="s0">* (usually 0).</span>
 <span class="s0">*/ 2 13 font_filename 1 122  10 face_index 1 110  </span>
<span class="s0">32 0 0 7 37 125 82 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 107  </span>
<span class="s0">33 0 0 15 37 125 82 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 copy 1 126  </span>
<span class="s0">34 0 0 7 37 125 82 0 129 /**</span>
 <span class="s0">* This constructor works as above, but it takes the font data from an in-</span>
 <span class="s0">* memory buffer instead of from a named file.</span>
 <span class="s0">*/ 3 9 font_data 1 128  11 data_length 1 110  10 face_index 1 110  </span>
<span class="s0">35 0 0 6 40 106 0 0 100 /**</span>
 <span class="s0">* Returns true if the PNMTextMaker is valid and ready to generate text, false</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 126  </span>
<span class="s0">36 0 0 4 41 109 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 125  10 align_type 1 102  </span>
<span class="s0">37 0 0 6 42 102 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 126  </span>
<span class="s0">38 0 0 4 43 109 0 0 443 /**</span>
 <span class="s0">* Sets the flag that indicates whether the interior of hollow fonts is</span>
 <span class="s0">* identified as a preprocess as each glyph is loaded.  If this flag is true,</span>
 <span class="s0">* you may specify an interior color along with a fg and bg color when you</span>
 <span class="s0">* place text; if the flag is false, the interior color is ignored.</span>
 <span class="s0">*</span>
 <span class="s0">* It is generally best to set_native_antialias(0) when using this feature.</span>
 <span class="s0">* Also, this works best when the pixel size is not very small.</span>
 <span class="s0">*/ 2 4 this 3 125  13 interior_flag 1 106  </span>
<span class="s0">39 0 0 6 44 106 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 126  </span>
<span class="s0">40 0 0 4 45 109 0 0 182 /**</span>
 <span class="s0">* Sets the foreground color of text that will be generated by future calls to</span>
 <span class="s0">* generate_into().  This is the color that all of the &quot;on&quot; pixels in the font</span>
 <span class="s0">* will show as.</span>
 <span class="s0">*/ 2 4 this 3 125  2 fg 1 117  </span>
<span class="s0">41 0 0 6 46 117 0 0 109 /**</span>
 <span class="s0">* Returns the foreground color of text that will be generated by future calls</span>
 <span class="s0">* to generate_into().</span>
 <span class="s0">*/ 1 4 this 3 126  </span>
<span class="s0">42 0 0 4 47 109 0 0 183 /**</span>
 <span class="s0">* Sets the color that will be used to render the interior portions of hollow</span>
 <span class="s0">* fonts in future calls to generate_into().  This is respected only if</span>
 <span class="s0">* interior_flag is true.</span>
 <span class="s0">*/ 2 4 this 3 125  8 interior 1 117  </span>
<span class="s0">43 0 0 6 48 117 0 0 98 /**</span>
 <span class="s0">* Returns the color that will be used to render the interior portions of</span>
 <span class="s0">* hollow fonts.</span>
 <span class="s0">*/ 1 4 this 3 126  </span>
<span class="s0">44 0 0 4 49 109 0 0 122 /**</span>
 <span class="s0">* If this is set to something other than 0, Panda will generate a signed</span>
 <span class="s0">* distance field with the given radius.</span>
 <span class="s0">*/ 2 4 this 3 125  6 radius 1 110  </span>
<span class="s0">45 0 0 6 50 110 0 0 95 /**</span>
 <span class="s0">* Returns the radius previously set with set_distance_field_radius, or 0</span>
 <span class="s0">* otherwise.</span>
 <span class="s0">*/ 1 4 this 3 126  </span>
<span class="s0">46 0 0 6 51 110 0 0 144 /**</span>
 <span class="s0">* Generates a single line of text into the indicated image at the indicated</span>
 <span class="s0">* position; the return value is the total width in pixels.</span>
 <span class="s0">*/ 5 4 this 3 125  4 text 1 128  10 dest_image 1 115  1 x 1 110  1 y 1 110  </span>
<span class="s0">47 0 0 6 51 110 0 0 144 /**</span>
 <span class="s0">* Generates a single line of text into the indicated image at the indicated</span>
 <span class="s0">* position; the return value is the total width in pixels.</span>
 <span class="s0">*/ 5 4 this 3 125  4 text 1 128  10 dest_image 1 115  1 x 1 110  1 y 1 110  </span>
<span class="s0">48 0 0 6 52 110 0 0 69 /**</span>
 <span class="s0">* Returns the width in pixels of the indicated line of text.</span>
 <span class="s0">*/ 2 4 this 3 125  4 text 1 128  </span>
<span class="s0">49 0 0 6 52 110 0 0 69 /**</span>
 <span class="s0">* Returns the width in pixels of the indicated line of text.</span>
 <span class="s0">*/ 2 4 this 3 125  4 text 1 128  </span>
<span class="s0">50 0 0 6 53 113 0 0 98 /**</span>
 <span class="s0">* Returns the glyph for the indicated index, or NULL if it is not defined in</span>
 <span class="s0">* the font.</span>
 <span class="s0">*/ 2 4 this 3 125  9 character 1 110  </span>
<span class="s0">32</span>
<span class="s0">97 12 FreetypeFont 0 26625 12 FreetypeFont 12 FreetypeFont 0 0 0 0 51 1 129 17 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 0 0 1 0 98 0 0 0 1 99 247</span>
<span class="s0">/**</span>
 <span class="s0">* This is a common base class for both DynamicTextFont and PNMTextMaker.</span>
 <span class="s0">* Both of these are utility classes that use the FreeType library to generate</span>
 <span class="s0">* glyphs from fonts; this class abstracts out that common wrapper around</span>
 <span class="s0">* FreeType.</span>
 <span class="s0">*/</span>

<span class="s0">98 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for all things which can have a name.  The name is either</span>
 <span class="s0">* empty or nonempty, but it is never NULL.</span>
 <span class="s0">*/</span>

<span class="s0">99 12 WindingOrder 0 794624 26 FreetypeFont::WindingOrder 26 FreetypeFont::WindingOrder 97 0 0 0 0 0 0 0 0 0 4 10 WO_default 24 FreetypeFont::WO_default 0</span>
<span class="s0">0 7 WO_left 21 FreetypeFont::WO_left 0</span>
<span class="s0">1 8 WO_right 22 FreetypeFont::WO_right 0</span>
<span class="s0">2 10 WO_invalid 24 FreetypeFont::WO_invalid 0</span>
<span class="s0">3 0 0</span>

<span class="s0">100 12 PNMTextGlyph 0 26625 12 PNMTextGlyph 12 PNMTextGlyph 0 0 0 1 69 70 0 10 71 72 73 74 75 76 77 78 79 80 0 0 0 0 0 44</span>
<span class="s0">/**</span>
 <span class="s0">* A single glyph in a PNMTextMaker.</span>
 <span class="s0">*/</span>

<span class="s0">101 12 PNMTextMaker 0 26625 12 PNMTextMaker 12 PNMTextMaker 0 0 0 1 81 82 0 14 83 84 85 86 87 88 89 90 91 92 93 94 95 96 0 0 1 0 97 0 0 0 1 102 284</span>
<span class="s0">/**</span>
 <span class="s0">* This object uses the Freetype library to generate text directly into an</span>
 <span class="s0">* image.  It is different from the TextNode/DynamicTextFont interface, which</span>
 <span class="s0">* use the Freetype library to generate text in the scene graph, to be</span>
 <span class="s0">* rendered onscreen via the Panda render traversal.</span>
 <span class="s0">*/</span>

<span class="s0">102 9 Alignment 0 794624 23 PNMTextMaker::Alignment 23 PNMTextMaker::Alignment 101 0 0 0 0 0 0 0 0 0 3 6 A_left 20 PNMTextMaker::A_left 0</span>
<span class="s0">0 7 A_right 21 PNMTextMaker::A_right 0</span>
<span class="s0">1 8 A_center 22 PNMTextMaker::A_center 0</span>
<span class="s0">2 0 0</span>

<span class="s0">103 14 FreetypeFont * 0 8576 14 FreetypeFont * 14 FreetypeFont * 0 0 97 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">104 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 105 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">105 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">106 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">107 20 FreetypeFont const * 0 8576 20 FreetypeFont const * 20 FreetypeFont const * 0 0 108 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">108 18 FreetypeFont const 0 8832 18 FreetypeFont const 18 FreetypeFont const 0 0 97 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">109 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">110 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">111 20 PNMTextGlyph const * 0 8576 20 PNMTextGlyph const * 20 PNMTextGlyph const * 0 0 112 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">112 18 PNMTextGlyph const 0 8832 18 PNMTextGlyph const 18 PNMTextGlyph const 0 0 100 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">113 14 PNMTextGlyph * 0 8576 14 PNMTextGlyph * 14 PNMTextGlyph * 0 0 100 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">114 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">115 10 PNMImage * 0 8576 10 PNMImage * 10 PNMImage * 0 0 116 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">116 8 PNMImage 0 2048 8 PNMImage 8 PNMImage 0 0 0 0 0 0 0 0 0 0 0 0 1516</span>
<span class="s0">/**</span>
 <span class="s0">* The name of this class derives from the fact that we originally implemented</span>
 <span class="s0">* it as a layer on top of the &quot;pnm library&quot;, based on netpbm, which was built</span>
 <span class="s0">* to implement pbm, pgm, and pbm files, and is the underlying support of a</span>
 <span class="s0">* number of public-domain image file converters.  Nowadays we are no longer</span>
 <span class="s0">* derived directly from the pnm library, mainly to allow support of C++</span>
 <span class="s0">* iostreams instead of the C stdio FILE interface.</span>
 <span class="s0">*</span>
 <span class="s0">* Conceptually, a PNMImage is a two-dimensional array of xels, which are the</span>
 <span class="s0">* PNM-defined generic pixel type.  Each xel may have a red, green, and blue</span>
 <span class="s0">* component, or (if the image is grayscale) a gray component.  The image may</span>
 <span class="s0">* be read in, the individual xels manipulated, and written out again, or a</span>
 <span class="s0">* black image may be constructed from scratch.</span>
 <span class="s0">*</span>
 <span class="s0">* A PNMImage has a color space and a maxval, the combination of which defines</span>
 <span class="s0">* how a floating-point linear color value is encoded as an integer value in</span>
 <span class="s0">* memory.  The functions ending in _val operate on encoded colors, whereas</span>
 <span class="s0">* the regular ones work with linear floating-point values.  All operations</span>
 <span class="s0">* are color space correct unless otherwise specified.</span>
 <span class="s0">*</span>
 <span class="s0">* The image is of size XSize() by YSize() xels, numbered from top to bottom,</span>
 <span class="s0">* left to right, beginning at zero.</span>
 <span class="s0">*</span>
 <span class="s0">* Files can be specified by filename, or by an iostream pointer.  The</span>
 <span class="s0">* filename &quot;-&quot; refers to stdin or stdout.</span>
 <span class="s0">*</span>
 <span class="s0">* This class is not inherently thread-safe; use it from a single thread or</span>
 <span class="s0">* protect access using a mutex.</span>
 <span class="s0">*/</span>

<span class="s0">117 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 118 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">118 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 119 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">119 6 LColor 0 2105344 6 LColor 6 LColor 0 0 120 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">120 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 121 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">121 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">122 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 123 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">123 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 124 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">124 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* The name of a file, such as a texture file or an Egg file.  Stores the full</span>
 <span class="s0">* pathname, and includes functions for extracting out the directory prefix</span>
 <span class="s0">* part and the file extension and stuff.</span>
 <span class="s0">*</span>
 <span class="s0">* A Filename is also aware of the mapping between the Unix-like filename</span>
 <span class="s0">* convention we use internally, and the local OS's specific filename</span>
 <span class="s0">* convention, and it knows how to perform basic OS-specific I/O, like testing</span>
 <span class="s0">* for file existence and searching a searchpath, as well as the best way to</span>
 <span class="s0">* open an fstream for reading or writing.</span>
 <span class="s0">*/</span>

<span class="s0">125 14 PNMTextMaker * 0 8576 14 PNMTextMaker * 14 PNMTextMaker * 0 0 101 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">126 20 PNMTextMaker const * 0 8576 20 PNMTextMaker const * 20 PNMTextMaker const * 0 0 127 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">127 18 PNMTextMaker const 0 8832 18 PNMTextMaker const 18 PNMTextMaker const 0 0 101 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">128 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">1</span>
<span class="s0">129 13 winding_order 0 6 99 68 67 0 0 0 0 0 0 27 FreetypeFont::winding_order 0</span>

<span class="s0">0</span>
</pre>
</body>
</html>