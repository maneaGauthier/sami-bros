<html>
<head>
<title>libp3pgraphnodes.in</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libp3pgraphnodes.in</font>
</center></td></tr></table>
<pre><span class="s0">1673266749</span>
<span class="s0">3 3</span>
<span class="s0">16 libp3pgraphnodes 4 Bgt0 12 panda3d.core </span>
<span class="s0">196</span>
<span class="s0">173 15 upcast_to_Light 0 12 369 26 LightNode::upcast_to_Light 0 1 4 30</span>
<span class="s0">upcast from LightNode to Light</span>
<span class="s0">40</span>
<span class="s0">Light *LightNode::upcast_to_Light(void);</span>

<span class="s0">174 21 downcast_to_LightNode 0 12 370 28 Light::downcast_to_LightNode 0 0 32</span>
<span class="s0">downcast from Light to LightNode</span>
<span class="s0">46</span>
<span class="s0">LightNode *Light::downcast_to_LightNode(void);</span>

<span class="s0">175 19 upcast_to_PandaNode 0 12 369 30 LightNode::upcast_to_PandaNode 0 1 5 34</span>
<span class="s0">upcast from LightNode to PandaNode</span>
<span class="s0">48</span>
<span class="s0">PandaNode *LightNode::upcast_to_PandaNode(void);</span>

<span class="s0">176 21 downcast_to_LightNode 0 12 371 32 PandaNode::downcast_to_LightNode 0 0 36</span>
<span class="s0">downcast from PandaNode to LightNode</span>
<span class="s0">50</span>
<span class="s0">LightNode *PandaNode::downcast_to_LightNode(void);</span>

<span class="s0">177 6 output 0 6 369 17 LightNode::output 0 1 1 100</span>
<span class="s0">// We have to explicitly publish these because they resolve the multiple</span>
<span class="s0">// inheritance.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">virtual void LightNode::output(std::ostream &amp;out) const;</span>

<span class="s0">178 5 write 0 6 369 16 LightNode::write 0 1 2 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">virtual void LightNode::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">179 14 get_class_type 0 4 369 25 LightNode::get_class_type 0 1 3 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle LightNode::get_class_type(void);</span>

<span class="s0">180 10 ~LightNode 0 516 369 21 LightNode::~LightNode 0 0 0</span>
<span class="s0">28</span>
<span class="s0">LightNode::~LightNode(void);</span>

<span class="s0">181 12 AmbientLight 0 260 372 26 AmbientLight::AmbientLight 0 1 6 138</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Do not call the copy constructor directly; instead, use make_copy() or</span>
 <span class="s0">* copy_subgraph() to make a copy of a node.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">explicit AmbientLight::AmbientLight(std::string const &amp;name);</span>

<span class="s0">182 14 get_class_type 0 4 372 28 AmbientLight::get_class_type 0 1 7 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle AmbientLight::get_class_type(void);</span>

<span class="s0">183 13 ~AmbientLight 0 516 372 27 AmbientLight::~AmbientLight 0 0 0</span>
<span class="s0">34</span>
<span class="s0">AmbientLight::~AmbientLight(void);</span>

<span class="s0">184 12 CallbackNode 0 260 373 26 CallbackNode::CallbackNode 0 1 8 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">explicit CallbackNode::CallbackNode(std::string const &amp;name);</span>

<span class="s0">185 17 set_cull_callback 0 4 373 31 CallbackNode::set_cull_callback 0 1 9 1131</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the CallbackObject that will be notified when this node is visited</span>
 <span class="s0">* during the cull traversal.  This callback will be made during the cull</span>
 <span class="s0">* thread.</span>
 <span class="s0">*</span>
 <span class="s0">* The cull traversal is responsible for determining which nodes are visible</span>
 <span class="s0">* and within the view frustum, and for accumulating state and transform, and</span>
 <span class="s0">* generally building up the list of CullableObjects that are to be eventually</span>
 <span class="s0">* passed to the draw traversal for rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* At the time the cull traversal callback is made, the node has been</span>
 <span class="s0">* determined to be visible and it has passed the bounding-volume test, so it</span>
 <span class="s0">* lies within the view frustum.</span>
 <span class="s0">*</span>
 <span class="s0">* The callback is passed an instance of a NodeCullCallbackData, which</span>
 <span class="s0">* contains pointers to the CullTraverser and CullTraverserData--enough data</span>
 <span class="s0">* to examine the current node and its place within the scene graph.  The</span>
 <span class="s0">* callback *replaces* the normal cull behavior, so if your callback does</span>
 <span class="s0">* nothing, the cull traversal will not continue below this node.  If you wish</span>
 <span class="s0">* the cull traversal to continue to visit this node and below, you must call</span>
 <span class="s0">* cbdata-&gt;upcall() from your callback.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void CallbackNode::set_cull_callback(CallbackObject *object);</span>

<span class="s0">186 19 clear_cull_callback 0 4 373 33 CallbackNode::clear_cull_callback 0 1 10 78</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the callback set by an earlier call to set_cull_callback().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void CallbackNode::clear_cull_callback(void);</span>

<span class="s0">187 17 get_cull_callback 0 4 373 31 CallbackNode::get_cull_callback 0 1 11 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CallbackObject set by set_cull_callback().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline CallbackObject *CallbackNode::get_cull_callback(void) const;</span>

<span class="s0">188 17 set_draw_callback 0 4 373 31 CallbackNode::set_draw_callback 0 1 12 973</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the CallbackObject that will be notified when this node is visited</span>
 <span class="s0">* during the draw traversal.  This callback will be made during the draw</span>
 <span class="s0">* thread.</span>
 <span class="s0">*</span>
 <span class="s0">* The draw traversal is responsible for actually issuing the commands to the</span>
 <span class="s0">* graphics engine to draw primitives.  Its job is to walk through the list of</span>
 <span class="s0">* CullableObjects build up by the cull traversal, as quickly as possible,</span>
 <span class="s0">* issuing the appropriate commands to draw each one.</span>
 <span class="s0">*</span>
 <span class="s0">* At the time the draw traversal callback is made, the graphics state has</span>
 <span class="s0">* been loaded with the correct modelview transform and render state, and the</span>
 <span class="s0">* primitives (if any) in this node are ready to be drawn.</span>
 <span class="s0">*</span>
 <span class="s0">* The callback is passed an instance of a GeomDrawCallbackData, which</span>
 <span class="s0">* contains pointers to the current state and transform, as well as the</span>
 <span class="s0">* current GSG.  There is a Geom pointer as well, but it will always be NULL</span>
 <span class="s0">* to this callback, since the CallbackNode does not itself contain any Geoms.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline void CallbackNode::set_draw_callback(CallbackObject *object);</span>

<span class="s0">189 19 clear_draw_callback 0 4 373 33 CallbackNode::clear_draw_callback 0 1 13 78</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the callback set by an earlier call to set_draw_callback().</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline void CallbackNode::clear_draw_callback(void);</span>

<span class="s0">190 17 get_draw_callback 0 4 373 31 CallbackNode::get_draw_callback 0 1 14 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CallbackObject set by set_draw_callback().</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline CallbackObject *CallbackNode::get_draw_callback(void) const;</span>

<span class="s0">191 14 get_class_type 0 4 373 28 CallbackNode::get_class_type 0 1 15 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle CallbackNode::get_class_type(void);</span>

<span class="s0">192 13 ~CallbackNode 0 516 373 27 CallbackNode::~CallbackNode 0 0 0</span>
<span class="s0">34</span>
<span class="s0">CallbackNode::~CallbackNode(void);</span>

<span class="s0">193 11 ComputeNode 0 260 376 24 ComputeNode::ComputeNode 0 1 16 134</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a ComputeNode with the given name.  Use add_dispatch and  also</span>
 <span class="s0">* assign a shader using a ShaderAttrib.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">explicit ComputeNode::ComputeNode(std::string const &amp;name);</span>

<span class="s0">194 12 add_dispatch 0 4 376 25 ComputeNode::add_dispatch 0 2 17 18 388</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a dispatch command with the given number of work groups in the X, Y,</span>
 <span class="s0">* and Z dimensions.  Any of these values may be set to 1 if the respective</span>
 <span class="s0">* dimension should not be used.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Adds a dispatch command with the given number of work groups in the X, Y,</span>
 <span class="s0">* and Z dimensions.  Any of these values may be set to 1 if the respective</span>
 <span class="s0">* dimension should not be used.</span>
 <span class="s0">*/</span>
<span class="s0">161</span>
<span class="s0">inline void ComputeNode::add_dispatch(LVecBase3i const &amp;num_groups);</span>
<span class="s0">inline void ComputeNode::add_dispatch(int num_groups_x, int num_groups_y, int num_groups_z);</span>

<span class="s0">195 18 get_num_dispatches 0 4 376 31 ComputeNode::get_num_dispatches 0 1 19 83</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of times add_dispatch has been called on this object.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline std::size_t ComputeNode::get_num_dispatches(void) const;</span>

<span class="s0">196 12 get_dispatch 0 4 376 25 ComputeNode::get_dispatch 0 1 20 84</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the group counts of the nth dispatch associated with this object.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline LVecBase3i const &amp;ComputeNode::get_dispatch(std::size_t i) const;</span>

<span class="s0">197 12 set_dispatch 0 4 376 25 ComputeNode::set_dispatch 0 1 21 81</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the group counts of the nth dispatch associated with this object.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void ComputeNode::set_dispatch(std::size_t i, LVecBase3i const &amp;num_groups);</span>

<span class="s0">198 15 insert_dispatch 0 4 376 28 ComputeNode::insert_dispatch 0 1 22 253</span>
<span class="s0">/**</span>
 <span class="s0">* Inserts a dispatch command with the given number of work groups in the X,</span>
 <span class="s0">* Y, and Z dimensions at the given position in the list of dispatch commands.</span>
 <span class="s0">* Any of these values may be set to 1 if the respective dimension should not</span>
 <span class="s0">* be used.</span>
 <span class="s0">*/</span>
<span class="s0">86</span>
<span class="s0">inline void ComputeNode::insert_dispatch(std::size_t i, LVecBase3i const &amp;num_groups);</span>

<span class="s0">199 15 remove_dispatch 0 4 376 28 ComputeNode::remove_dispatch 0 1 23 57</span>
<span class="s0">/**</span>
 <span class="s0">* Erases the given dispatch index from the list.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void ComputeNode::remove_dispatch(std::size_t i);</span>

<span class="s0">200 16 clear_dispatches 0 4 376 29 ComputeNode::clear_dispatches 0 1 24 41</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all dispatch commands.</span>
 <span class="s0">*/</span>
<span class="s0">48</span>
<span class="s0">inline void ComputeNode::clear_dispatches(void);</span>

<span class="s0">201 14 get_class_type 0 4 376 27 ComputeNode::get_class_type 0 1 25 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle ComputeNode::get_class_type(void);</span>

<span class="s0">202 12 ~ComputeNode 0 516 376 25 ComputeNode::~ComputeNode 0 0 0</span>
<span class="s0">32</span>
<span class="s0">ComputeNode::~ComputeNode(void);</span>

<span class="s0">203 15 upcast_to_Light 0 12 380 30 LightLensNode::upcast_to_Light 0 1 37 34</span>
<span class="s0">upcast from LightLensNode to Light</span>
<span class="s0">44</span>
<span class="s0">Light *LightLensNode::upcast_to_Light(void);</span>

<span class="s0">204 25 downcast_to_LightLensNode 0 12 370 32 Light::downcast_to_LightLensNode 0 0 36</span>
<span class="s0">downcast from Light to LightLensNode</span>
<span class="s0">54</span>
<span class="s0">LightLensNode *Light::downcast_to_LightLensNode(void);</span>

<span class="s0">205 16 upcast_to_Camera 0 12 380 31 LightLensNode::upcast_to_Camera 0 1 38 35</span>
<span class="s0">upcast from LightLensNode to Camera</span>
<span class="s0">46</span>
<span class="s0">Camera *LightLensNode::upcast_to_Camera(void);</span>

<span class="s0">206 25 downcast_to_LightLensNode 0 12 381 33 Camera::downcast_to_LightLensNode 0 0 37</span>
<span class="s0">downcast from Camera to LightLensNode</span>
<span class="s0">55</span>
<span class="s0">LightLensNode *Camera::downcast_to_LightLensNode(void);</span>

<span class="s0">207 14 ~LightLensNode 0 518 380 29 LightLensNode::~LightLensNode 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">44</span>
<span class="s0">virtual LightLensNode::~LightLensNode(void);</span>

<span class="s0">208 18 has_specular_color 0 4 380 33 LightLensNode::has_specular_color 0 1 26 141</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if this light defines a specular color, false if the specular</span>
 <span class="s0">* color is derived automatically from the light color.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline bool LightLensNode::has_specular_color(void) const;</span>

<span class="s0">209 16 is_shadow_caster 0 4 380 31 LightLensNode::is_shadow_caster 0 1 27 75</span>
<span class="s0">/**</span>
 <span class="s0">* Returns whether this light is configured to cast shadows or not.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline bool LightLensNode::is_shadow_caster(void) const;</span>

<span class="s0">210 17 set_shadow_caster 0 4 380 32 LightLensNode::set_shadow_caster 0 2 28 29 609</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating whether this light should cast shadows or not.</span>
 <span class="s0">* This is the variant without buffer size, meaning that the current buffer</span>
 <span class="s0">* size will be kept (512x512 is the default). Note that enabling shadows will</span>
 <span class="s0">* require the shader generator to be enabled on the scene.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the flag indicating whether this light should cast shadows or not.</span>
 <span class="s0">* The xsize and ysize parameters specify the size of the shadow buffer that</span>
 <span class="s0">* will be set up, the sort parameter specifies the sort.  Note that enabling</span>
 <span class="s0">* shadows will require the shader generator to be enabled on the scene.</span>
 <span class="s0">*/</span>
<span class="s0">155</span>
<span class="s0">void LightLensNode::set_shadow_caster(bool caster);</span>
<span class="s0">void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort = -10);</span>

<span class="s0">211 22 get_shadow_buffer_sort 0 4 380 37 LightLensNode::get_shadow_buffer_sort 0 1 30 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the sort of the shadow buffer to be created for this light source.</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int LightLensNode::get_shadow_buffer_sort(void) const;</span>

<span class="s0">212 22 get_shadow_buffer_size 0 4 380 37 LightLensNode::get_shadow_buffer_size 0 1 31 85</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the size of the shadow buffer to be created for this light source.</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline LVecBase2i LightLensNode::get_shadow_buffer_size(void) const;</span>

<span class="s0">213 22 set_shadow_buffer_size 0 4 380 37 LightLensNode::set_shadow_buffer_size 0 1 32 82</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the size of the shadow buffer to be created for this light source.</span>
 <span class="s0">*/</span>
<span class="s0">74</span>
<span class="s0">inline void LightLensNode::set_shadow_buffer_size(LVecBase2i const &amp;size);</span>

<span class="s0">214 17 get_shadow_buffer 0 4 380 32 LightLensNode::get_shadow_buffer 0 1 33 214</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the buffer that has been constructed for a given GSG, or NULL if no</span>
 <span class="s0">* such buffer has (yet) been constructed.  This should be used for debugging</span>
 <span class="s0">* only, you will not need to call this normally.</span>
 <span class="s0">*/</span>
<span class="s0">92</span>
<span class="s0">inline GraphicsOutputBase *LightLensNode::get_shadow_buffer(GraphicsStateGuardianBase *gsg);</span>

<span class="s0">215 6 output 0 6 380 21 LightLensNode::output 0 1 34 100</span>
<span class="s0">// We have to explicitly publish these because they resolve the multiple</span>
<span class="s0">// inheritance.</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">virtual void LightLensNode::output(std::ostream &amp;out) const;</span>

<span class="s0">216 5 write 0 6 380 20 LightLensNode::write 0 1 35 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">81</span>
<span class="s0">virtual void LightLensNode::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">217 14 get_class_type 0 4 380 29 LightLensNode::get_class_type 0 1 36 0</span>
<span class="s0">54</span>
<span class="s0">static TypeHandle LightLensNode::get_class_type(void);</span>

<span class="s0">218 16 DirectionalLight 0 260 384 34 DirectionalLight::DirectionalLight 0 1 39 138</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Do not call the copy constructor directly; instead, use make_copy() or</span>
 <span class="s0">* copy_subgraph() to make a copy of a node.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">explicit DirectionalLight::DirectionalLight(std::string const &amp;name);</span>

<span class="s0">219 18 set_specular_color 0 4 384 36 DirectionalLight::set_specular_color 0 1 40 72</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color of specular highlights generated by the light.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void DirectionalLight::set_specular_color(LColor const &amp;color);</span>

<span class="s0">220 20 clear_specular_color 0 4 384 38 DirectionalLight::clear_specular_color 0 1 41 115</span>
<span class="s0">/**</span>
 <span class="s0">* Clears a custom specular color setting, meaning that the specular color</span>
 <span class="s0">* will now come from the color.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline void DirectionalLight::clear_specular_color(void);</span>

<span class="s0">221 18 get_specular_color 0 6 384 36 DirectionalLight::get_specular_color 0 0 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color of specular highlights generated by the light.  This is</span>
 <span class="s0">* usually the same as get_color().</span>
 <span class="s0">*/</span>
<span class="s0">84</span>
<span class="s0">virtual inline LColor const &amp;DirectionalLight::get_specular_color(void) const final;</span>

<span class="s0">222 9 get_point 0 4 384 27 DirectionalLight::get_point 0 1 42 349</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point in space at which the light is located.  This is local to</span>
 <span class="s0">* the coordinate space in which the light is assigned.</span>
 <span class="s0">*</span>
 <span class="s0">* This actually has no bearing on the visual effect of the light, since the</span>
 <span class="s0">* light is rendered as if it were infinitely far away.  This is only used to</span>
 <span class="s0">* create a visible representation of the light.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline LPoint3 const &amp;DirectionalLight::get_point(void) const;</span>

<span class="s0">223 9 set_point 0 4 384 27 DirectionalLight::set_point 0 1 43 65</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the point in space at which the light is located.</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline void DirectionalLight::set_point(LPoint3 const &amp;point);</span>

<span class="s0">224 13 get_direction 0 4 384 31 DirectionalLight::get_direction 0 1 44 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the direction in which the light is aimed.  This is local to the</span>
 <span class="s0">* coordinate space in which the light is assigned.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline LVector3 const &amp;DirectionalLight::get_direction(void) const;</span>

<span class="s0">225 13 set_direction 0 4 384 31 DirectionalLight::set_direction 0 1 45 58</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the direction in which the light is aimed.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void DirectionalLight::set_direction(LVector3 const &amp;direction);</span>

<span class="s0">226 14 get_class_type 0 4 384 32 DirectionalLight::get_class_type 0 1 46 0</span>
<span class="s0">57</span>
<span class="s0">static TypeHandle DirectionalLight::get_class_type(void);</span>

<span class="s0">227 17 ~DirectionalLight 0 516 384 35 DirectionalLight::~DirectionalLight 0 0 0</span>
<span class="s0">42</span>
<span class="s0">DirectionalLight::~DirectionalLight(void);</span>

<span class="s0">228 7 LODNode 0 260 395 16 LODNode::LODNode 0 1 47 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline explicit LODNode::LODNode(std::string const &amp;name);</span>

<span class="s0">229 16 make_default_lod 0 4 395 25 LODNode::make_default_lod 0 1 48 98</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a new LODNode of the type specified by the default-lod-type config</span>
 <span class="s0">* variable.</span>
 <span class="s0">*/</span>
<span class="s0">79</span>
<span class="s0">static PointerTo&lt; LODNode &gt; LODNode::make_default_lod(std::string const &amp;name);</span>

<span class="s0">230 10 add_switch 0 4 395 19 LODNode::add_switch 0 1 49 355</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a switch range to the LODNode.  This implies that the corresponding</span>
 <span class="s0">* child node has been parented to the node.</span>
 <span class="s0">*</span>
 <span class="s0">* The sense of in vs.  out distances is as if the object were coming towards</span>
 <span class="s0">* you from far away: it switches &quot;in&quot; at the far distance, and switches &quot;out&quot;</span>
 <span class="s0">* at the close distance.  Thus, &quot;in&quot; should be larger than &quot;out&quot;.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline void LODNode::add_switch(PN_stdfloat in, PN_stdfloat out);</span>

<span class="s0">231 10 set_switch 0 4 395 19 LODNode::set_switch 0 1 50 98</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the switching range of a particular child of the LODNode.  See</span>
 <span class="s0">* add_switch().</span>
 <span class="s0">*/</span>
<span class="s0">76</span>
<span class="s0">inline bool LODNode::set_switch(int index, PN_stdfloat in, PN_stdfloat out);</span>

<span class="s0">232 14 clear_switches 0 4 395 23 LODNode::clear_switches 0 1 51 146</span>
<span class="s0">/**</span>
 <span class="s0">* Removes the set of switching ranges for the LODNode, presumably in</span>
 <span class="s0">* conjunction with removing all of its children.  See add_switch().</span>
 <span class="s0">*/</span>
<span class="s0">42</span>
<span class="s0">inline void LODNode::clear_switches(void);</span>

<span class="s0">233 16 get_num_switches 0 4 395 25 LODNode::get_num_switches 0 1 52 184</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of switch ranges added to the LODNode.  This should</span>
 <span class="s0">* correspond to the number of children of the node in order for the LODNode</span>
 <span class="s0">* to function correctly.</span>
 <span class="s0">*/</span>
<span class="s0">49</span>
<span class="s0">inline int LODNode::get_num_switches(void) const;</span>

<span class="s0">234 6 get_in 0 4 395 15 LODNode::get_in 0 1 53 136</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;in&quot; distance of the indicated switch range.  This should be</span>
 <span class="s0">* larger than the &quot;out&quot; distance of the same range.</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">inline PN_stdfloat LODNode::get_in(int index) const;</span>

<span class="s0">235 7 get_out 0 4 395 16 LODNode::get_out 0 1 54 137</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the &quot;out&quot; distance of the indicated switch range.  This should be</span>
 <span class="s0">* smaller than the &quot;in&quot; distance of the same range.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline PN_stdfloat LODNode::get_out(int index) const;</span>

<span class="s0">236 17 get_lowest_switch 0 4 395 26 LODNode::get_lowest_switch 0 1 55 220</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number of the child with the lowest level of detail; that</span>
 <span class="s0">* is, the one that is designed to be seen from the farthest away.  This is</span>
 <span class="s0">* usually the first child, but it is not necessarily so.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline int LODNode::get_lowest_switch(void) const;</span>

<span class="s0">237 18 get_highest_switch 0 4 395 27 LODNode::get_highest_switch 0 1 56 228</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index number of the child with the highest level of detail;</span>
 <span class="s0">* that is, the one that is designed to be seen from the closest to the</span>
 <span class="s0">* camera.  This is usually the last child, but it is not necessarily so.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline int LODNode::get_highest_switch(void) const;</span>

<span class="s0">238 12 force_switch 0 4 395 21 LODNode::force_switch 0 1 57 149</span>
<span class="s0">/**</span>
 <span class="s0">* Forces the LODNode to show the indicated level instead of the level that</span>
 <span class="s0">* would normally be shown based on the distance from the camera.</span>
 <span class="s0">*/</span>
<span class="s0">45</span>
<span class="s0">inline void LODNode::force_switch(int index);</span>

<span class="s0">239 18 clear_force_switch 0 4 395 27 LODNode::clear_force_switch 0 1 58 133</span>
<span class="s0">/**</span>
 <span class="s0">* Undoes the effect of a previous call to force_switch() and releases the</span>
 <span class="s0">* LODNode to once again display the normal level.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline void LODNode::clear_force_switch(void);</span>

<span class="s0">240 13 set_lod_scale 0 4 395 22 LODNode::set_lod_scale 0 1 59 331</span>
<span class="s0">// for performance tuning, increasing this value should improve performance</span>
<span class="s0">// at the cost of model quality</span>

<span class="s0">// for performance tuning, increasing this value should improve performance</span>
<span class="s0">// at the cost of model quality</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the multiplier for lod distances.  A higher value means you'll see</span>
 <span class="s0">* farther switchs than normal</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void LODNode::set_lod_scale(PN_stdfloat value);</span>

<span class="s0">241 13 get_lod_scale 0 4 395 22 LODNode::get_lod_scale 0 1 60 51</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the multiplier for lod distances</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline PN_stdfloat LODNode::get_lod_scale(void) const;</span>

<span class="s0">242 10 set_center 0 4 395 19 LODNode::set_center 0 1 61 172</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the center of the LOD.  This is the point that is compared to the</span>
 <span class="s0">* camera (in camera space) to determine the particular LOD that should be</span>
 <span class="s0">* chosen.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline void LODNode::set_center(LPoint3 const &amp;center);</span>

<span class="s0">243 10 get_center 0 4 395 19 LODNode::get_center 0 1 62 170</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the center of the LOD.  This is the point that is compared to the</span>
 <span class="s0">* camera (in camera space) to determine the particular LOD that should be</span>
 <span class="s0">* chosen.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline LPoint3 const &amp;LODNode::get_center(void) const;</span>

<span class="s0">244 11 show_switch 0 4 395 20 LODNode::show_switch 0 2 63 64 1102</span>
<span class="s0">/**</span>
 <span class="s0">* This is provided as a debugging aid.  show_switch() will put the LODNode</span>
 <span class="s0">* into a special mode where rather than computing and drawing the appropriate</span>
 <span class="s0">* level of the LOD, a ring is drawn around the LODNode center indicating the</span>
 <span class="s0">* switch distances from the camera for the indicated level, and the geometry</span>
 <span class="s0">* of the indicated level is drawn in wireframe.</span>
 <span class="s0">*</span>
 <span class="s0">* Multiple different levels can be visualized this way at once.  Call</span>
 <span class="s0">* hide_switch() or hide_all_switches() to undo this mode and restore the</span>
 <span class="s0">* LODNode to its normal behavior.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* This is provided as a debugging aid.  show_switch() will put the LODNode</span>
 <span class="s0">* into a special mode where rather than computing and drawing the appropriate</span>
 <span class="s0">* level of the LOD, a ring is drawn around the LODNode center indicating the</span>
 <span class="s0">* switch distances from the camera for the indicated level, and the geometry</span>
 <span class="s0">* of the indicated level is drawn in wireframe.</span>
 <span class="s0">*</span>
 <span class="s0">* Multiple different levels can be visualized this way at once.  Call</span>
 <span class="s0">* hide_switch() or hide_all_switches() to undo this mode and restore the</span>
 <span class="s0">* LODNode to its normal behavior.</span>
 <span class="s0">*/</span>
<span class="s0">96</span>
<span class="s0">void LODNode::show_switch(int index);</span>
<span class="s0">void LODNode::show_switch(int index, LColor const &amp;color);</span>

<span class="s0">245 11 hide_switch 0 4 395 20 LODNode::hide_switch 0 1 65 53</span>
<span class="s0">/**</span>
 <span class="s0">* Disables a previous call to show_switch().</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void LODNode::hide_switch(int index);</span>

<span class="s0">246 17 show_all_switches 0 4 395 26 LODNode::show_all_switches 0 1 66 52</span>
<span class="s0">/**</span>
 <span class="s0">* Shows all levels in their default colors.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void LODNode::show_all_switches(void);</span>

<span class="s0">247 17 hide_all_switches 0 4 395 26 LODNode::hide_all_switches 0 1 67 71</span>
<span class="s0">/**</span>
 <span class="s0">* Hides all levels, restoring the LODNode to normal operation.</span>
 <span class="s0">*/</span>
<span class="s0">38</span>
<span class="s0">void LODNode::hide_all_switches(void);</span>

<span class="s0">248 12 is_any_shown 0 4 395 21 LODNode::is_any_shown 0 1 68 159</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if any switch has been shown with show_switch(), indicating</span>
 <span class="s0">* the LODNode is in debug show mode; or false if it is in the normal mode.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">inline bool LODNode::is_any_shown(void) const;</span>

<span class="s0">249 19 verify_child_bounds 0 4 395 28 LODNode::verify_child_bounds 0 1 69 274</span>
<span class="s0">/**</span>
 <span class="s0">* Returns true if the bounding volumes for the geometry of each fhild node</span>
 <span class="s0">* entirely fits within the switch_in radius for that child, or false</span>
 <span class="s0">* otherwise.  It is almost always a mistake for the geometry of an LOD level</span>
 <span class="s0">* to be larger than its switch_in radius.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">bool LODNode::verify_child_bounds(void) const;</span>

<span class="s0">250 14 get_class_type 0 4 395 23 LODNode::get_class_type 0 1 70 0</span>
<span class="s0">48</span>
<span class="s0">static TypeHandle LODNode::get_class_type(void);</span>

<span class="s0">251 8 ~LODNode 0 516 395 17 LODNode::~LODNode 0 0 0</span>
<span class="s0">24</span>
<span class="s0">LODNode::~LODNode(void);</span>

<span class="s0">252 11 FadeLODNode 0 260 399 24 FadeLODNode::FadeLODNode 0 1 71 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">explicit FadeLODNode::FadeLODNode(std::string const &amp;name);</span>

<span class="s0">253 13 set_fade_time 0 4 399 26 FadeLODNode::set_fade_time 0 1 72 55</span>
<span class="s0">/**</span>
 <span class="s0">* set the time taken to complete an LOD switch</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">inline void FadeLODNode::set_fade_time(PN_stdfloat t);</span>

<span class="s0">254 13 get_fade_time 0 4 399 26 FadeLODNode::get_fade_time 0 1 73 55</span>
<span class="s0">/**</span>
 <span class="s0">* get the time taken to complete an LOD switch</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline PN_stdfloat FadeLODNode::get_fade_time(void) const;</span>

<span class="s0">255 12 set_fade_bin 0 4 399 25 FadeLODNode::set_fade_bin 0 1 74 124</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the cull bin and draw order that is assigned to the fading part</span>
 <span class="s0">* of the geometry during a transition.</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">void FadeLODNode::set_fade_bin(std::string const &amp;name, int draw_order);</span>

<span class="s0">256 17 get_fade_bin_name 0 4 399 30 FadeLODNode::get_fade_bin_name 0 1 75 107</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the cull bin that is assigned to the fading part of the geometry</span>
 <span class="s0">* during a transition.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline std::string const &amp;FadeLODNode::get_fade_bin_name(void) const;</span>

<span class="s0">257 23 get_fade_bin_draw_order 0 4 399 36 FadeLODNode::get_fade_bin_draw_order 0 1 76 135</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the draw order that is assigned (along with the bin name) to the</span>
 <span class="s0">* fading part of the geometry during a transition.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int FadeLODNode::get_fade_bin_draw_order(void) const;</span>

<span class="s0">258 23 set_fade_state_override 0 4 399 36 FadeLODNode::set_fade_state_override 0 1 77 191</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the override value that is applied to the state changes necessary</span>
 <span class="s0">* to apply the fade effect.  This should be larger than any attrib overrides</span>
 <span class="s0">* on the fading geometry.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">void FadeLODNode::set_fade_state_override(int override);</span>

<span class="s0">259 23 get_fade_state_override 0 4 399 36 FadeLODNode::get_fade_state_override 0 1 78 189</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the override value that is applied to the state changes necessary</span>
 <span class="s0">* to apply the fade effect.  This should be larger than any attrib overrides</span>
 <span class="s0">* on the fading geometry.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int FadeLODNode::get_fade_state_override(void) const;</span>

<span class="s0">260 14 get_class_type 0 4 399 27 FadeLODNode::get_class_type 0 1 79 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle FadeLODNode::get_class_type(void);</span>

<span class="s0">261 12 ~FadeLODNode 0 516 399 25 FadeLODNode::~FadeLODNode 0 0 0</span>
<span class="s0">32</span>
<span class="s0">FadeLODNode::~FadeLODNode(void);</span>

<span class="s0">262 8 get_trav 0 4 403 30 NodeCullCallbackData::get_trav 0 1 80 193</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CullTraverser in use at the time of the callback.  This object</span>
 <span class="s0">* contains data that does not change during the traversal, such as the</span>
 <span class="s0">* DisplayRegion and Camera in use.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline CullTraverser *NodeCullCallbackData::get_trav(void) const;</span>

<span class="s0">263 8 get_data 0 4 403 30 NodeCullCallbackData::get_data 0 1 81 222</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the CullTraverserData in use at the time of the callback.  This</span>
 <span class="s0">* object contains data that changes at each node of the traversal, such as</span>
 <span class="s0">* the current node and the current net transform to that node.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline CullTraverserData &amp;NodeCullCallbackData::get_data(void) const;</span>

<span class="s0">264 14 get_class_type 0 4 403 36 NodeCullCallbackData::get_class_type 0 1 82 0</span>
<span class="s0">61</span>
<span class="s0">static TypeHandle NodeCullCallbackData::get_class_type(void);</span>

<span class="s0">265 10 PointLight 0 260 405 22 PointLight::PointLight 0 1 83 138</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Do not call the copy constructor directly; instead, use make_copy() or</span>
 <span class="s0">* copy_subgraph() to make a copy of a node.</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">explicit PointLight::PointLight(std::string const &amp;name);</span>

<span class="s0">266 18 set_specular_color 0 4 405 30 PointLight::set_specular_color 0 1 84 72</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color of specular highlights generated by the light.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline void PointLight::set_specular_color(LColor const &amp;color);</span>

<span class="s0">267 20 clear_specular_color 0 4 405 32 PointLight::clear_specular_color 0 1 85 115</span>
<span class="s0">/**</span>
 <span class="s0">* Clears a custom specular color setting, meaning that the specular color</span>
 <span class="s0">* will now come from the color.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">inline void PointLight::clear_specular_color(void);</span>

<span class="s0">268 18 get_specular_color 0 6 405 30 PointLight::get_specular_color 0 0 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color of specular highlights generated by the light.  This is</span>
 <span class="s0">* usually the same as get_color().</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">virtual inline LColor const &amp;PointLight::get_specular_color(void) const final;</span>

<span class="s0">269 15 set_attenuation 0 4 405 27 PointLight::set_attenuation 0 1 86 190</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the terms of the attenuation equation for the light.  These are, in</span>
 <span class="s0">* order, the constant, linear, and quadratic terms based on the distance from</span>
 <span class="s0">* the point to the vertex.</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline void PointLight::set_attenuation(LVecBase3 const &amp;attenuation);</span>

<span class="s0">270 15 get_attenuation 0 6 405 27 PointLight::get_attenuation 0 0 193</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the terms of the attenuation equation for the light.  These are, in</span>
 <span class="s0">* order, the constant, linear, and quadratic terms based on the distance from</span>
 <span class="s0">* the point to the vertex.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">virtual inline LVecBase3 const &amp;PointLight::get_attenuation(void) const final;</span>

<span class="s0">271 16 get_max_distance 0 4 405 28 PointLight::get_max_distance 0 1 87 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum distance at which the light has any effect, as previously</span>
 <span class="s0">* specified by set_max_distance.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline PN_stdfloat PointLight::get_max_distance(void) const;</span>

<span class="s0">272 16 set_max_distance 0 4 405 28 PointLight::set_max_distance 0 1 88 161</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the radius of the light's sphere of influence.  Beyond this distance, the</span>
 <span class="s0">* light may be attenuated to zero, if this is supported by the shader.</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline void PointLight::set_max_distance(PN_stdfloat max_distance);</span>

<span class="s0">273 9 get_point 0 4 405 21 PointLight::get_point 0 1 89 160</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the point in space at which the light is located.  This is local to</span>
 <span class="s0">* the coordinate space in which the light is assigned, and is usually 0.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline LPoint3 const &amp;PointLight::get_point(void) const;</span>

<span class="s0">274 9 set_point 0 4 405 21 PointLight::set_point 0 1 90 77</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the point in space at which the light is located.  Usually 0.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void PointLight::set_point(LPoint3 const &amp;point);</span>

<span class="s0">275 14 get_class_type 0 4 405 26 PointLight::get_class_type 0 1 91 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle PointLight::get_class_type(void);</span>

<span class="s0">276 11 ~PointLight 0 516 405 23 PointLight::~PointLight 0 0 0</span>
<span class="s0">30</span>
<span class="s0">PointLight::~PointLight(void);</span>

<span class="s0">277 14 RectangleLight 0 260 409 30 RectangleLight::RectangleLight 0 1 92 138</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Do not call the copy constructor directly; instead, use make_copy() or</span>
 <span class="s0">* copy_subgraph() to make a copy of a node.</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">explicit RectangleLight::RectangleLight(std::string const &amp;name);</span>

<span class="s0">278 16 get_max_distance 0 4 409 32 RectangleLight::get_max_distance 0 1 93 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum distance at which the light has any effect, as previously</span>
 <span class="s0">* specified by set_max_distance.</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline PN_stdfloat RectangleLight::get_max_distance(void) const;</span>

<span class="s0">279 16 set_max_distance 0 4 409 32 RectangleLight::set_max_distance 0 1 94 161</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the radius of the light's sphere of influence.  Beyond this distance, the</span>
 <span class="s0">* light may be attenuated to zero, if this is supported by the shader.</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline void RectangleLight::set_max_distance(PN_stdfloat max_distance);</span>

<span class="s0">280 14 get_class_type 0 4 409 30 RectangleLight::get_class_type 0 1 95 0</span>
<span class="s0">55</span>
<span class="s0">static TypeHandle RectangleLight::get_class_type(void);</span>

<span class="s0">281 15 ~RectangleLight 0 516 409 31 RectangleLight::~RectangleLight 0 0 0</span>
<span class="s0">38</span>
<span class="s0">RectangleLight::~RectangleLight(void);</span>

<span class="s0">282 18 SelectiveChildNode 0 260 410 38 SelectiveChildNode::SelectiveChildNode 0 1 96 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">80</span>
<span class="s0">inline explicit SelectiveChildNode::SelectiveChildNode(std::string const &amp;name);</span>

<span class="s0">283 14 get_class_type 0 4 410 34 SelectiveChildNode::get_class_type 0 1 97 0</span>
<span class="s0">59</span>
<span class="s0">static TypeHandle SelectiveChildNode::get_class_type(void);</span>

<span class="s0">284 19 ~SelectiveChildNode 0 516 410 39 SelectiveChildNode::~SelectiveChildNode 0 0 0</span>
<span class="s0">46</span>
<span class="s0">SelectiveChildNode::~SelectiveChildNode(void);</span>

<span class="s0">285 28 upcast_to_SelectiveChildNode 0 12 411 42 SequenceNode::upcast_to_SelectiveChildNode 0 1 102 46</span>
<span class="s0">upcast from SequenceNode to SelectiveChildNode</span>
<span class="s0">69</span>
<span class="s0">SelectiveChildNode *SequenceNode::upcast_to_SelectiveChildNode(void);</span>

<span class="s0">286 24 downcast_to_SequenceNode 0 12 410 44 SelectiveChildNode::downcast_to_SequenceNode 0 0 48</span>
<span class="s0">downcast from SelectiveChildNode to SequenceNode</span>
<span class="s0">65</span>
<span class="s0">SequenceNode *SelectiveChildNode::downcast_to_SequenceNode(void);</span>

<span class="s0">287 23 upcast_to_AnimInterface 0 12 411 37 SequenceNode::upcast_to_AnimInterface 0 1 103 41</span>
<span class="s0">upcast from SequenceNode to AnimInterface</span>
<span class="s0">59</span>
<span class="s0">AnimInterface *SequenceNode::upcast_to_AnimInterface(void);</span>

<span class="s0">288 24 downcast_to_SequenceNode 0 12 412 39 AnimInterface::downcast_to_SequenceNode 0 0 43</span>
<span class="s0">downcast from AnimInterface to SequenceNode</span>
<span class="s0">60</span>
<span class="s0">SequenceNode *AnimInterface::downcast_to_SequenceNode(void);</span>

<span class="s0">289 12 SequenceNode 0 260 411 26 SequenceNode::SequenceNode 0 1 98 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">68</span>
<span class="s0">inline explicit SequenceNode::SequenceNode(std::string const &amp;name);</span>

<span class="s0">290 14 get_num_frames 0 6 411 28 SequenceNode::get_num_frames 0 1 99 278</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the number of frames in the animation.  This is a property of the</span>
 <span class="s0">* animation and may not be directly adjusted by the user (although it may</span>
 <span class="s0">* change without warning with certain kinds of animations, since this is a</span>
 <span class="s0">* virtual method that may be overridden).</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">virtual int SequenceNode::get_num_frames(void) const;</span>

<span class="s0">291 14 set_frame_rate 0 4 411 28 SequenceNode::set_frame_rate 0 1 100 173</span>
<span class="s0">/**</span>
 <span class="s0">* Changes the advertised frame rate of the SequenceNode.  This can be used in</span>
 <span class="s0">* conjunction with get_play_rate() to change the effective frame rate of the</span>
 <span class="s0">* node.</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline void SequenceNode::set_frame_rate(double frame_rate);</span>

<span class="s0">292 14 get_frame_rate 0 4 411 28 SequenceNode::get_frame_rate 0 0 0</span>
<span class="s0">55</span>
<span class="s0">inline double SequenceNode::get_frame_rate(void) const;</span>

<span class="s0">293 14 get_class_type 0 4 411 28 SequenceNode::get_class_type 0 1 101 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle SequenceNode::get_class_type(void);</span>

<span class="s0">294 13 ~SequenceNode 0 516 411 27 SequenceNode::~SequenceNode 0 0 0</span>
<span class="s0">34</span>
<span class="s0">SequenceNode::~SequenceNode(void);</span>

<span class="s0">295 15 ShaderGenerator 0 260 414 32 ShaderGenerator::ShaderGenerator 0 2 104 105 189</span>
<span class="s0">/**</span>
 <span class="s0">* Create a ShaderGenerator.  This has no state, except possibly to cache</span>
 <span class="s0">* certain results.  The parameter that must be passed is the GSG to which the</span>
 <span class="s0">* shader generator belongs.</span>
 <span class="s0">*/</span>
<span class="s0">147</span>
<span class="s0">ShaderGenerator::ShaderGenerator(GraphicsStateGuardianBase const *gsg);</span>
<span class="s0">inline ShaderGenerator::ShaderGenerator(ShaderGenerator const &amp;) = default;</span>

<span class="s0">296 17 synthesize_shader 0 6 414 34 ShaderGenerator::synthesize_shader 0 1 106 794</span>
<span class="s0">/**</span>
 <span class="s0">* This is the routine that implements the next-gen fixed function pipeline by</span>
 <span class="s0">* synthesizing a shader.  It also takes care of setting up any buffers needed</span>
 <span class="s0">* to produce the requested effects.</span>
 <span class="s0">*</span>
 <span class="s0">* Currently supports:</span>
 <span class="s0">* - flat colors</span>
 <span class="s0">* - vertex colors</span>
 <span class="s0">* - lighting</span>
 <span class="s0">* - normal maps, even multiple</span>
 <span class="s0">* - gloss maps, but not multiple</span>
 <span class="s0">* - glow maps, but not multiple</span>
 <span class="s0">* - materials, but not updates to materials</span>
 <span class="s0">* - 2D textures</span>
 <span class="s0">* - all texture stage modes, including combine modes</span>
 <span class="s0">* - color scale attrib</span>
 <span class="s0">* - light ramps (for cartoon shading)</span>
 <span class="s0">* - shadow mapping</span>
 <span class="s0">* - most texgen modes</span>
 <span class="s0">* - texmatrix</span>
 <span class="s0">* - 1D/2D/3D textures, cube textures, 2D tex arrays</span>
 <span class="s0">* - linear/exp/exp2 fog</span>
 <span class="s0">* - animation</span>
 <span class="s0">*</span>
 <span class="s0">* Potential optimizations</span>
 <span class="s0">* - omit attenuation calculations if attenuation off</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">134</span>
<span class="s0">virtual ConstPointerTo&lt; ShaderAttrib &gt; ShaderGenerator::synthesize_shader(RenderState const *rs, GeomVertexAnimationSpec const &amp;anim);</span>

<span class="s0">297 24 rehash_generated_shaders 0 4 414 41 ShaderGenerator::rehash_generated_shaders 0 1 107 354</span>
<span class="s0">/**</span>
 <span class="s0">* Rehashes all the states with generated shaders, removing the ones that are</span>
 <span class="s0">* no longer fresh.</span>
 <span class="s0">*</span>
 <span class="s0">* Call this if certain state has changed in such a way as to require a rerun</span>
 <span class="s0">* of the shader generator.  This should be rare because in most cases, the</span>
 <span class="s0">* shader generator will automatically regenerate shaders as necessary.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">void ShaderGenerator::rehash_generated_shaders(void);</span>

<span class="s0">298 23 clear_generated_shaders 0 4 414 40 ShaderGenerator::clear_generated_shaders 0 1 108 159</span>
<span class="s0">/**</span>
 <span class="s0">* Removes all previously generated shaders, requiring all shaders to be</span>
 <span class="s0">* regenerated.  Does not clear cache of compiled shaders.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>
<span class="s0">52</span>
<span class="s0">void ShaderGenerator::clear_generated_shaders(void);</span>

<span class="s0">299 14 get_class_type 0 4 414 31 ShaderGenerator::get_class_type 0 1 109 0</span>
<span class="s0">56</span>
<span class="s0">static TypeHandle ShaderGenerator::get_class_type(void);</span>

<span class="s0">300 11 SphereLight 0 260 416 24 SphereLight::SphereLight 0 1 110 138</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Do not call the copy constructor directly; instead, use make_copy() or</span>
 <span class="s0">* copy_subgraph() to make a copy of a node.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">explicit SphereLight::SphereLight(std::string const &amp;name);</span>

<span class="s0">301 10 get_radius 0 4 416 23 SphereLight::get_radius 0 1 111 44</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the radius of the sphere.</span>
 <span class="s0">*/</span>
<span class="s0">55</span>
<span class="s0">inline PN_stdfloat SphereLight::get_radius(void) const;</span>

<span class="s0">302 10 set_radius 0 4 416 23 SphereLight::set_radius 0 1 112 41</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the radius of the sphere.</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline void SphereLight::set_radius(PN_stdfloat radius);</span>

<span class="s0">303 14 get_class_type 0 4 416 27 SphereLight::get_class_type 0 1 113 0</span>
<span class="s0">52</span>
<span class="s0">static TypeHandle SphereLight::get_class_type(void);</span>

<span class="s0">304 12 ~SphereLight 0 516 416 25 SphereLight::~SphereLight 0 0 0</span>
<span class="s0">32</span>
<span class="s0">SphereLight::~SphereLight(void);</span>

<span class="s0">305 9 Spotlight 0 260 417 20 Spotlight::Spotlight 0 1 114 138</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Do not call the copy constructor directly; instead, use make_copy() or</span>
 <span class="s0">* copy_subgraph() to make a copy of a node.</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">Spotlight::Spotlight(std::string const &amp;name);</span>

<span class="s0">306 12 set_exponent 0 4 417 23 Spotlight::set_exponent 0 1 115 398</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the exponent that controls the amount of light falloff from the center</span>
 <span class="s0">* of the spotlight.  The light is attenuated by the cosine of the angle</span>
 <span class="s0">* between the direction of the light and the direction of the point being</span>
 <span class="s0">* lighted, raised to the power of this exponent.  Thus, higher exponents</span>
 <span class="s0">* result in a more focused light source, regardless of the field-of-view of</span>
 <span class="s0">* the lens.</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline void Spotlight::set_exponent(PN_stdfloat exponent);</span>

<span class="s0">307 12 get_exponent 0 6 417 23 Spotlight::get_exponent 0 0 131</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the exponent that controls the amount of light falloff from the</span>
 <span class="s0">* center of the spotlight.  See set_exponent().</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">virtual inline PN_stdfloat Spotlight::get_exponent(void) const final;</span>

<span class="s0">308 18 set_specular_color 0 4 417 29 Spotlight::set_specular_color 0 1 116 72</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the color of specular highlights generated by the light.</span>
 <span class="s0">*/</span>
<span class="s0">63</span>
<span class="s0">inline void Spotlight::set_specular_color(LColor const &amp;color);</span>

<span class="s0">309 20 clear_specular_color 0 4 417 31 Spotlight::clear_specular_color 0 1 117 115</span>
<span class="s0">/**</span>
 <span class="s0">* Clears a custom specular color setting, meaning that the specular color</span>
 <span class="s0">* will now come from the color.</span>
 <span class="s0">*/</span>
<span class="s0">50</span>
<span class="s0">inline void Spotlight::clear_specular_color(void);</span>

<span class="s0">310 18 get_specular_color 0 6 417 29 Spotlight::get_specular_color 0 0 120</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the color of specular highlights generated by the light.  This is</span>
 <span class="s0">* usually the same as get_color().</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">virtual inline LColor const &amp;Spotlight::get_specular_color(void) const final;</span>

<span class="s0">311 15 set_attenuation 0 4 417 26 Spotlight::set_attenuation 0 1 118 190</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the terms of the attenuation equation for the light.  These are, in</span>
 <span class="s0">* order, the constant, linear, and quadratic terms based on the distance from</span>
 <span class="s0">* the point to the vertex.</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline void Spotlight::set_attenuation(LVecBase3 const &amp;attenuation);</span>

<span class="s0">312 15 get_attenuation 0 6 417 26 Spotlight::get_attenuation 0 0 193</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the terms of the attenuation equation for the light.  These are, in</span>
 <span class="s0">* order, the constant, linear, and quadratic terms based on the distance from</span>
 <span class="s0">* the point to the vertex.</span>
 <span class="s0">*/</span>
<span class="s0">77</span>
<span class="s0">virtual inline LVecBase3 const &amp;Spotlight::get_attenuation(void) const final;</span>

<span class="s0">313 16 get_max_distance 0 4 417 27 Spotlight::get_max_distance 0 1 119 122</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the maximum distance at which the light has any effect, as previously</span>
 <span class="s0">* specified by set_max_distance.</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline PN_stdfloat Spotlight::get_max_distance(void) const;</span>

<span class="s0">314 16 set_max_distance 0 4 417 27 Spotlight::set_max_distance 0 1 120 161</span>
<span class="s0">/**</span>
 <span class="s0">* Sets the radius of the light's sphere of influence.  Beyond this distance, the</span>
 <span class="s0">* light may be attenuated to zero, if this is supported by the shader.</span>
 <span class="s0">*/</span>
<span class="s0">66</span>
<span class="s0">inline void Spotlight::set_max_distance(PN_stdfloat max_distance);</span>

<span class="s0">315 9 make_spot 0 4 417 20 Spotlight::make_spot 0 1 121 619</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a newly-generated Texture that renders a circular spot image as</span>
 <span class="s0">* might be cast from the spotlight.  This may be projected onto target</span>
 <span class="s0">* geometry (for instance, via NodePath::project_texture()) instead of</span>
 <span class="s0">* actually enabling the light itself, as a cheesy way to make a high-</span>
 <span class="s0">* resolution spot appear on the geometry.</span>
 <span class="s0">*</span>
 <span class="s0">* pixel_width specifies the height and width of the new texture in pixels,</span>
 <span class="s0">* full_radius is a value in the range 0..1 that indicates the relative size</span>
 <span class="s0">* of the fully bright center spot, and fg and bg are the colors of the</span>
 <span class="s0">* interior and exterior of the spot, respectively.</span>
 <span class="s0">*/</span>
<span class="s0">115</span>
<span class="s0">static PointerTo&lt; Texture &gt; Spotlight::make_spot(int pixel_width, PN_stdfloat full_radius, LColor &amp;fg, LColor &amp;bg);</span>

<span class="s0">316 14 get_class_type 0 4 417 25 Spotlight::get_class_type 0 1 122 0</span>
<span class="s0">50</span>
<span class="s0">static TypeHandle Spotlight::get_class_type(void);</span>

<span class="s0">317 10 ~Spotlight 0 516 417 21 Spotlight::~Spotlight 0 0 0</span>
<span class="s0">28</span>
<span class="s0">Spotlight::~Spotlight(void);</span>

<span class="s0">318 10 SwitchNode 0 260 418 22 SwitchNode::SwitchNode 0 1 123 22</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline explicit SwitchNode::SwitchNode(std::string const &amp;name);</span>

<span class="s0">319 17 set_visible_child 0 4 418 29 SwitchNode::set_visible_child 0 1 124 90</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the particular child of this node, by index, that will be</span>
 <span class="s0">* visible.</span>
 <span class="s0">*/</span>
<span class="s0">53</span>
<span class="s0">inline void SwitchNode::set_visible_child(int index);</span>

<span class="s0">320 17 get_visible_child 0 6 418 29 SwitchNode::get_visible_child 0 1 125 65</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the index of the child that should be visible.</span>
 <span class="s0">*/</span>
<span class="s0">54</span>
<span class="s0">virtual int SwitchNode::get_visible_child(void) const;</span>

<span class="s0">321 14 get_class_type 0 4 418 26 SwitchNode::get_class_type 0 1 126 0</span>
<span class="s0">51</span>
<span class="s0">static TypeHandle SwitchNode::get_class_type(void);</span>

<span class="s0">322 11 ~SwitchNode 0 516 418 23 SwitchNode::~SwitchNode 0 0 0</span>
<span class="s0">30</span>
<span class="s0">SwitchNode::~SwitchNode(void);</span>

<span class="s0">323 12 UvScrollNode 0 260 419 26 UvScrollNode::UvScrollNode 0 2 127 128 34</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">221</span>
<span class="s0">inline explicit UvScrollNode::UvScrollNode(std::string const &amp;name, PN_stdfloat u_speed, PN_stdfloat v_speed, PN_stdfloat w_speed, PN_stdfloat r_speed);</span>
<span class="s0">inline explicit UvScrollNode::UvScrollNode(std::string const &amp;name);</span>

<span class="s0">324 11 set_u_speed 0 4 419 25 UvScrollNode::set_u_speed 0 1 129 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void UvScrollNode::set_u_speed(PN_stdfloat u_speed);</span>

<span class="s0">325 11 set_v_speed 0 4 419 25 UvScrollNode::set_v_speed 0 1 130 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void UvScrollNode::set_v_speed(PN_stdfloat v_speed);</span>

<span class="s0">326 11 set_w_speed 0 4 419 25 UvScrollNode::set_w_speed 0 1 131 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void UvScrollNode::set_w_speed(PN_stdfloat w_speed);</span>

<span class="s0">327 11 set_r_speed 0 4 419 25 UvScrollNode::set_r_speed 0 1 132 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline void UvScrollNode::set_r_speed(PN_stdfloat r_speed);</span>

<span class="s0">328 11 get_u_speed 0 4 419 25 UvScrollNode::get_u_speed 0 1 133 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat UvScrollNode::get_u_speed(void) const;</span>

<span class="s0">329 11 get_v_speed 0 4 419 25 UvScrollNode::get_v_speed 0 1 134 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat UvScrollNode::get_v_speed(void) const;</span>

<span class="s0">330 11 get_w_speed 0 4 419 25 UvScrollNode::get_w_speed 0 1 135 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat UvScrollNode::get_w_speed(void) const;</span>

<span class="s0">331 11 get_r_speed 0 4 419 25 UvScrollNode::get_r_speed 0 1 136 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline PN_stdfloat UvScrollNode::get_r_speed(void) const;</span>

<span class="s0">332 14 get_class_type 0 4 419 28 UvScrollNode::get_class_type 0 1 137 0</span>
<span class="s0">53</span>
<span class="s0">static TypeHandle UvScrollNode::get_class_type(void);</span>

<span class="s0">333 13 ~UvScrollNode 0 516 419 27 UvScrollNode::~UvScrollNode 0 0 0</span>
<span class="s0">34</span>
<span class="s0">UvScrollNode::~UvScrollNode(void);</span>

<span class="s0">334 18 SceneGraphAnalyzer 0 260 420 38 SceneGraphAnalyzer::SceneGraphAnalyzer 0 2 138 139 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">130</span>
<span class="s0">SceneGraphAnalyzer::SceneGraphAnalyzer(void);</span>
<span class="s0">inline SceneGraphAnalyzer::SceneGraphAnalyzer(SceneGraphAnalyzer const &amp;) = default;</span>

<span class="s0">335 19 ~SceneGraphAnalyzer 0 516 420 39 SceneGraphAnalyzer::~SceneGraphAnalyzer 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">46</span>
<span class="s0">SceneGraphAnalyzer::~SceneGraphAnalyzer(void);</span>

<span class="s0">336 12 set_lod_mode 0 4 420 32 SceneGraphAnalyzer::set_lod_mode 0 1 140 61</span>
<span class="s0">/**</span>
 <span class="s0">* Specifies the mode in which LODNodes are analyzed.</span>
 <span class="s0">*/</span>
<span class="s0">83</span>
<span class="s0">inline void SceneGraphAnalyzer::set_lod_mode(SceneGraphAnalyzer::LodMode lod_mode);</span>

<span class="s0">337 12 get_lod_mode 0 4 420 32 SceneGraphAnalyzer::get_lod_mode 0 1 141 59</span>
<span class="s0">/**</span>
 <span class="s0">* Returns the mode in which LODNodes are analyzed.</span>
 <span class="s0">*/</span>
<span class="s0">112</span>
<span class="s0">inline SceneGraphAnalyzer::LodMode SceneGraphAnalyzer::get_lod_mode(SceneGraphAnalyzer::LodMode lod_mode) const;</span>

<span class="s0">338 5 clear 0 4 420 25 SceneGraphAnalyzer::clear 0 1 142 79</span>
<span class="s0">/**</span>
 <span class="s0">* Resets all of the data in the analyzer in preparation for a new run.</span>
 <span class="s0">*/</span>
<span class="s0">37</span>
<span class="s0">void SceneGraphAnalyzer::clear(void);</span>

<span class="s0">339 8 add_node 0 4 420 28 SceneGraphAnalyzer::add_node 0 1 143 244</span>
<span class="s0">/**</span>
 <span class="s0">* Adds a new node to the set of data for analysis.  Normally, this would only</span>
 <span class="s0">* be called once, and passed the top of the scene graph, but it's possible to</span>
 <span class="s0">* repeatedly pass in subgraphs to get an analysis of all the graphs together.</span>
 <span class="s0">*/</span>
<span class="s0">51</span>
<span class="s0">void SceneGraphAnalyzer::add_node(PandaNode *node);</span>

<span class="s0">340 5 write 0 4 420 25 SceneGraphAnalyzer::write 0 1 144 44</span>
<span class="s0">/**</span>
 <span class="s0">* Describes all the data collected.</span>
 <span class="s0">*/</span>
<span class="s0">78</span>
<span class="s0">void SceneGraphAnalyzer::write(std::ostream &amp;out, int indent_level = 0) const;</span>

<span class="s0">341 13 get_num_nodes 0 4 420 33 SceneGraphAnalyzer::get_num_nodes 0 1 145 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_nodes(void) const;</span>

<span class="s0">342 17 get_num_instances 0 4 420 37 SceneGraphAnalyzer::get_num_instances 0 1 146 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_instances(void) const;</span>

<span class="s0">343 18 get_num_transforms 0 4 420 38 SceneGraphAnalyzer::get_num_transforms 0 1 147 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_transforms(void) const;</span>

<span class="s0">344 26 get_num_nodes_with_attribs 0 4 420 46 SceneGraphAnalyzer::get_num_nodes_with_attribs 0 1 148 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">70</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_nodes_with_attribs(void) const;</span>

<span class="s0">345 17 get_num_lod_nodes 0 4 420 37 SceneGraphAnalyzer::get_num_lod_nodes 0 1 149 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_lod_nodes(void) const;</span>

<span class="s0">346 18 get_num_geom_nodes 0 4 420 38 SceneGraphAnalyzer::get_num_geom_nodes 0 1 150 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">62</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_geom_nodes(void) const;</span>

<span class="s0">347 13 get_num_geoms 0 4 420 33 SceneGraphAnalyzer::get_num_geoms 0 1 151 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_geoms(void) const;</span>

<span class="s0">348 25 get_num_geom_vertex_datas 0 4 420 45 SceneGraphAnalyzer::get_num_geom_vertex_datas 0 1 152 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_geom_vertex_datas(void) const;</span>

<span class="s0">349 27 get_num_geom_vertex_formats 0 4 420 47 SceneGraphAnalyzer::get_num_geom_vertex_formats 0 1 153 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_geom_vertex_formats(void) const;</span>

<span class="s0">350 20 get_vertex_data_size 0 4 420 40 SceneGraphAnalyzer::get_vertex_data_size 0 1 154 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">72</span>
<span class="s0">inline std::size_t SceneGraphAnalyzer::get_vertex_data_size(void) const;</span>

<span class="s0">351 16 get_num_vertices 0 4 420 36 SceneGraphAnalyzer::get_num_vertices 0 1 155 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">60</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_vertices(void) const;</span>

<span class="s0">352 15 get_num_normals 0 4 420 35 SceneGraphAnalyzer::get_num_normals 0 1 156 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_normals(void) const;</span>

<span class="s0">353 14 get_num_colors 0 4 420 34 SceneGraphAnalyzer::get_num_colors 0 1 157 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_colors(void) const;</span>

<span class="s0">354 17 get_num_texcoords 0 4 420 37 SceneGraphAnalyzer::get_num_texcoords 0 1 158 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_texcoords(void) const;</span>

<span class="s0">355 12 get_num_tris 0 4 420 32 SceneGraphAnalyzer::get_num_tris 0 1 159 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">56</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_tris(void) const;</span>

<span class="s0">356 13 get_num_lines 0 4 420 33 SceneGraphAnalyzer::get_num_lines 0 1 160 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">57</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_lines(void) const;</span>

<span class="s0">357 14 get_num_points 0 4 420 34 SceneGraphAnalyzer::get_num_points 0 1 161 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">58</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_points(void) const;</span>

<span class="s0">358 15 get_num_patches 0 4 420 35 SceneGraphAnalyzer::get_num_patches 0 1 162 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_patches(void) const;</span>

<span class="s0">359 23 get_num_individual_tris 0 4 420 43 SceneGraphAnalyzer::get_num_individual_tris 0 1 163 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">67</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_individual_tris(void) const;</span>

<span class="s0">360 17 get_num_tristrips 0 4 420 37 SceneGraphAnalyzer::get_num_tristrips 0 1 164 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">61</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_tristrips(void) const;</span>

<span class="s0">361 27 get_num_triangles_in_strips 0 4 420 47 SceneGraphAnalyzer::get_num_triangles_in_strips 0 1 165 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_triangles_in_strips(void) const;</span>

<span class="s0">362 15 get_num_trifans 0 4 420 35 SceneGraphAnalyzer::get_num_trifans 0 1 166 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">59</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_trifans(void) const;</span>

<span class="s0">363 25 get_num_triangles_in_fans 0 4 420 45 SceneGraphAnalyzer::get_num_triangles_in_fans 0 1 167 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_triangles_in_fans(void) const;</span>

<span class="s0">364 27 get_num_vertices_in_patches 0 4 420 47 SceneGraphAnalyzer::get_num_vertices_in_patches 0 1 168 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">71</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_vertices_in_patches(void) const;</span>

<span class="s0">365 17 get_texture_bytes 0 4 420 37 SceneGraphAnalyzer::get_texture_bytes 0 1 169 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">69</span>
<span class="s0">inline std::size_t SceneGraphAnalyzer::get_texture_bytes(void) const;</span>

<span class="s0">366 20 get_num_long_normals 0 4 420 40 SceneGraphAnalyzer::get_num_long_normals 0 1 170 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">64</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_long_normals(void) const;</span>

<span class="s0">367 21 get_num_short_normals 0 4 420 41 SceneGraphAnalyzer::get_num_short_normals 0 1 171 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">65</span>
<span class="s0">inline int SceneGraphAnalyzer::get_num_short_normals(void) const;</span>

<span class="s0">368 23 get_total_normal_length 0 4 420 43 SceneGraphAnalyzer::get_total_normal_length 0 1 172 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s0">75</span>
<span class="s0">inline PN_stdfloat SceneGraphAnalyzer::get_total_normal_length(void) const;</span>

<span class="s0">172</span>
<span class="s0">1 0 0 4 8 426 0 0 88 // We have to explicitly publish these because they resolve the multiple</span>
<span class="s0">// inheritance. 2 4 this 3 422  3 out 1 424  </span>
<span class="s0">2 0 0 4 9 426 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 422  3 out 1 424  12 indent_level 5 398  </span>
<span class="s0">3 0 0 7 10 428 0 0 0 0 </span>
<span class="s0">4 0 0 6 3 430 0 0 0 1 4 this 3 429  </span>
<span class="s0">5 0 0 7 6 431 0 0 0 1 4 this 3 429  </span>
<span class="s0">6 0 0 7 13 433 183 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">7 0 0 7 14 428 0 0 0 0 </span>
<span class="s0">8 0 0 7 17 434 192 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">9 0 0 4 18 426 0 0 1131 /**</span>
 <span class="s0">* Sets the CallbackObject that will be notified when this node is visited</span>
 <span class="s0">* during the cull traversal.  This callback will be made during the cull</span>
 <span class="s0">* thread.</span>
 <span class="s0">*</span>
 <span class="s0">* The cull traversal is responsible for determining which nodes are visible</span>
 <span class="s0">* and within the view frustum, and for accumulating state and transform, and</span>
 <span class="s0">* generally building up the list of CullableObjects that are to be eventually</span>
 <span class="s0">* passed to the draw traversal for rendering.</span>
 <span class="s0">*</span>
 <span class="s0">* At the time the cull traversal callback is made, the node has been</span>
 <span class="s0">* determined to be visible and it has passed the bounding-volume test, so it</span>
 <span class="s0">* lies within the view frustum.</span>
 <span class="s0">*</span>
 <span class="s0">* The callback is passed an instance of a NodeCullCallbackData, which</span>
 <span class="s0">* contains pointers to the CullTraverser and CullTraverserData--enough data</span>
 <span class="s0">* to examine the current node and its place within the scene graph.  The</span>
 <span class="s0">* callback *replaces* the normal cull behavior, so if your callback does</span>
 <span class="s0">* nothing, the cull traversal will not continue below this node.  If you wish</span>
 <span class="s0">* the cull traversal to continue to visit this node and below, you must call</span>
 <span class="s0">* cbdata-&gt;upcall() from your callback.</span>
 <span class="s0">*/ 2 4 this 3 434  6 object 1 374  </span>
<span class="s0">10 0 0 4 19 426 0 0 78 /**</span>
 <span class="s0">* Removes the callback set by an earlier call to set_cull_callback().</span>
 <span class="s0">*/ 1 4 this 3 434  </span>
<span class="s0">11 0 0 7 20 374 0 0 65 /**</span>
 <span class="s0">* Returns the CallbackObject set by set_cull_callback().</span>
 <span class="s0">*/ 1 4 this 3 435  </span>
<span class="s0">12 0 0 4 24 426 0 0 973 /**</span>
 <span class="s0">* Sets the CallbackObject that will be notified when this node is visited</span>
 <span class="s0">* during the draw traversal.  This callback will be made during the draw</span>
 <span class="s0">* thread.</span>
 <span class="s0">*</span>
 <span class="s0">* The draw traversal is responsible for actually issuing the commands to the</span>
 <span class="s0">* graphics engine to draw primitives.  Its job is to walk through the list of</span>
 <span class="s0">* CullableObjects build up by the cull traversal, as quickly as possible,</span>
 <span class="s0">* issuing the appropriate commands to draw each one.</span>
 <span class="s0">*</span>
 <span class="s0">* At the time the draw traversal callback is made, the graphics state has</span>
 <span class="s0">* been loaded with the correct modelview transform and render state, and the</span>
 <span class="s0">* primitives (if any) in this node are ready to be drawn.</span>
 <span class="s0">*</span>
 <span class="s0">* The callback is passed an instance of a GeomDrawCallbackData, which</span>
 <span class="s0">* contains pointers to the current state and transform, as well as the</span>
 <span class="s0">* current GSG.  There is a Geom pointer as well, but it will always be NULL</span>
 <span class="s0">* to this callback, since the CallbackNode does not itself contain any Geoms.</span>
 <span class="s0">*/ 2 4 this 3 434  6 object 1 374  </span>
<span class="s0">13 0 0 4 25 426 0 0 78 /**</span>
 <span class="s0">* Removes the callback set by an earlier call to set_draw_callback().</span>
 <span class="s0">*/ 1 4 this 3 434  </span>
<span class="s0">14 0 0 7 26 374 0 0 65 /**</span>
 <span class="s0">* Returns the CallbackObject set by set_draw_callback().</span>
 <span class="s0">*/ 1 4 this 3 435  </span>
<span class="s0">15 0 0 7 28 428 0 0 0 0 </span>
<span class="s0">16 0 0 7 31 437 202 0 122 /**</span>
 <span class="s0">* Creates a ComputeNode with the given name.  Use add_dispatch and  also</span>
 <span class="s0">* assign a shader using a ShaderAttrib.</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">17 0 0 4 32 426 0 0 193 /**</span>
 <span class="s0">* Adds a dispatch command with the given number of work groups in the X, Y,</span>
 <span class="s0">* and Z dimensions.  Any of these values may be set to 1 if the respective</span>
 <span class="s0">* dimension should not be used.</span>
 <span class="s0">*/ 2 4 this 3 437  10 num_groups 1 438  </span>
<span class="s0">18 0 0 4 32 426 0 0 193 /**</span>
 <span class="s0">* Adds a dispatch command with the given number of work groups in the X, Y,</span>
 <span class="s0">* and Z dimensions.  Any of these values may be set to 1 if the respective</span>
 <span class="s0">* dimension should not be used.</span>
 <span class="s0">*/ 4 4 this 3 437  12 num_groups_x 1 398  12 num_groups_y 1 398  12 num_groups_z 1 398  </span>
<span class="s0">19 0 0 6 33 441 0 0 83 /**</span>
 <span class="s0">* Returns the number of times add_dispatch has been called on this object.</span>
 <span class="s0">*/ 1 4 this 3 439  </span>
<span class="s0">20 0 0 6 34 438 0 0 84 /**</span>
 <span class="s0">* Returns the group counts of the nth dispatch associated with this object.</span>
 <span class="s0">*/ 2 4 this 3 439  1 i 1 441  </span>
<span class="s0">21 0 0 4 35 426 0 0 81 /**</span>
 <span class="s0">* Sets the group counts of the nth dispatch associated with this object.</span>
 <span class="s0">*/ 3 4 this 3 437  1 i 1 441  10 num_groups 1 438  </span>
<span class="s0">22 0 0 4 36 426 0 0 253 /**</span>
 <span class="s0">* Inserts a dispatch command with the given number of work groups in the X,</span>
 <span class="s0">* Y, and Z dimensions at the given position in the list of dispatch commands.</span>
 <span class="s0">* Any of these values may be set to 1 if the respective dimension should not</span>
 <span class="s0">* be used.</span>
 <span class="s0">*/ 3 4 this 3 437  1 i 1 441  10 num_groups 1 438  </span>
<span class="s0">23 0 0 4 37 426 0 0 57 /**</span>
 <span class="s0">* Erases the given dispatch index from the list.</span>
 <span class="s0">*/ 2 4 this 3 437  1 i 1 441  </span>
<span class="s0">24 0 0 4 38 426 0 0 41 /**</span>
 <span class="s0">* Removes all dispatch commands.</span>
 <span class="s0">*/ 1 4 this 3 437  </span>
<span class="s0">25 0 0 7 43 428 0 0 0 0 </span>
<span class="s0">26 0 0 6 53 382 0 0 141 /**</span>
 <span class="s0">* Returns true if this light defines a specular color, false if the specular</span>
 <span class="s0">* color is derived automatically from the light color.</span>
 <span class="s0">*/ 1 4 this 3 443  </span>
<span class="s0">27 0 0 6 54 382 0 0 75 /**</span>
 <span class="s0">* Returns whether this light is configured to cast shadows or not.</span>
 <span class="s0">*/ 1 4 this 3 443  </span>
<span class="s0">28 0 0 4 55 426 0 0 297 /**</span>
 <span class="s0">* Sets the flag indicating whether this light should cast shadows or not.</span>
 <span class="s0">* This is the variant without buffer size, meaning that the current buffer</span>
 <span class="s0">* size will be kept (512x512 is the default). Note that enabling shadows will</span>
 <span class="s0">* require the shader generator to be enabled on the scene.</span>
 <span class="s0">*/ 2 4 this 3 445  6 caster 1 382  </span>
<span class="s0">29 0 0 4 55 426 0 0 310 /**</span>
 <span class="s0">* Sets the flag indicating whether this light should cast shadows or not.</span>
 <span class="s0">* The xsize and ysize parameters specify the size of the shadow buffer that</span>
 <span class="s0">* will be set up, the sort parameter specifies the sort.  Note that enabling</span>
 <span class="s0">* shadows will require the shader generator to be enabled on the scene.</span>
 <span class="s0">*/ 5 4 this 3 445  6 caster 1 382  12 buffer_xsize 1 398  12 buffer_ysize 1 398  4 sort 5 398  </span>
<span class="s0">30 0 0 6 56 398 0 0 85 /**</span>
 <span class="s0">* Returns the sort of the shadow buffer to be created for this light source.</span>
 <span class="s0">*/ 1 4 this 3 443  </span>
<span class="s0">31 0 0 7 57 446 0 0 85 /**</span>
 <span class="s0">* Returns the size of the shadow buffer to be created for this light source.</span>
 <span class="s0">*/ 1 4 this 3 443  </span>
<span class="s0">32 0 0 4 58 426 0 0 82 /**</span>
 <span class="s0">* Sets the size of the shadow buffer to be created for this light source.</span>
 <span class="s0">*/ 2 4 this 3 445  4 size 1 447  </span>
<span class="s0">33 0 0 7 59 452 0 0 214 /**</span>
 <span class="s0">* Returns the buffer that has been constructed for a given GSG, or NULL if no</span>
 <span class="s0">* such buffer has (yet) been constructed.  This should be used for debugging</span>
 <span class="s0">* only, you will not need to call this normally.</span>
 <span class="s0">*/ 2 4 this 3 445  3 gsg 1 450  </span>
<span class="s0">34 0 0 4 64 426 0 0 88 // We have to explicitly publish these because they resolve the multiple</span>
<span class="s0">// inheritance. 2 4 this 3 443  3 out 1 424  </span>
<span class="s0">35 0 0 4 65 426 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 443  3 out 1 424  12 indent_level 5 398  </span>
<span class="s0">36 0 0 7 66 428 0 0 0 0 </span>
<span class="s0">37 0 0 6 47 430 0 0 0 1 4 this 3 445  </span>
<span class="s0">38 0 0 7 50 453 0 0 0 1 4 this 3 445  </span>
<span class="s0">39 0 0 7 68 454 227 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">40 0 0 4 69 426 0 0 72 /**</span>
 <span class="s0">* Sets the color of specular highlights generated by the light.</span>
 <span class="s0">*/ 2 4 this 3 454  5 color 1 455  </span>
<span class="s0">41 0 0 4 70 426 0 0 115 /**</span>
 <span class="s0">* Clears a custom specular color setting, meaning that the specular color</span>
 <span class="s0">* will now come from the color.</span>
 <span class="s0">*/ 1 4 this 3 454  </span>
<span class="s0">42 0 0 6 77 458 0 0 349 /**</span>
 <span class="s0">* Returns the point in space at which the light is located.  This is local to</span>
 <span class="s0">* the coordinate space in which the light is assigned.</span>
 <span class="s0">*</span>
 <span class="s0">* This actually has no bearing on the visual effect of the light, since the</span>
 <span class="s0">* light is rendered as if it were infinitely far away.  This is only used to</span>
 <span class="s0">* create a visible representation of the light.</span>
 <span class="s0">*/ 1 4 this 3 456  </span>
<span class="s0">43 0 0 4 78 426 0 0 65 /**</span>
 <span class="s0">* Sets the point in space at which the light is located.</span>
 <span class="s0">*/ 2 4 this 3 454  5 point 1 458  </span>
<span class="s0">44 0 0 6 83 459 0 0 135 /**</span>
 <span class="s0">* Returns the direction in which the light is aimed.  This is local to the</span>
 <span class="s0">* coordinate space in which the light is assigned.</span>
 <span class="s0">*/ 1 4 this 3 456  </span>
<span class="s0">45 0 0 4 84 426 0 0 58 /**</span>
 <span class="s0">* Sets the direction in which the light is aimed.</span>
 <span class="s0">*/ 2 4 this 3 454  9 direction 1 459  </span>
<span class="s0">46 0 0 7 89 428 0 0 0 0 </span>
<span class="s0">47 0 0 7 92 460 251 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">48 0 0 7 93 460 251 0 98 /**</span>
 <span class="s0">* Creates a new LODNode of the type specified by the default-lod-type config</span>
 <span class="s0">* variable.</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">49 0 0 4 94 426 0 0 355 /**</span>
 <span class="s0">* Adds a switch range to the LODNode.  This implies that the corresponding</span>
 <span class="s0">* child node has been parented to the node.</span>
 <span class="s0">*</span>
 <span class="s0">* The sense of in vs.  out distances is as if the object were coming towards</span>
 <span class="s0">* you from far away: it switches &quot;in&quot; at the far distance, and switches &quot;out&quot;</span>
 <span class="s0">* at the close distance.  Thus, &quot;in&quot; should be larger than &quot;out&quot;.</span>
 <span class="s0">*/ 3 4 this 3 460  2 in 1 396  3 out 1 396  </span>
<span class="s0">50 0 0 6 95 382 0 0 98 /**</span>
 <span class="s0">* Changes the switching range of a particular child of the LODNode.  See</span>
 <span class="s0">* add_switch().</span>
 <span class="s0">*/ 4 4 this 3 460  5 index 1 398  2 in 1 396  3 out 1 396  </span>
<span class="s0">51 0 0 4 96 426 0 0 146 /**</span>
 <span class="s0">* Removes the set of switching ranges for the LODNode, presumably in</span>
 <span class="s0">* conjunction with removing all of its children.  See add_switch().</span>
 <span class="s0">*/ 1 4 this 3 460  </span>
<span class="s0">52 0 0 6 97 398 0 0 184 /**</span>
 <span class="s0">* Returns the number of switch ranges added to the LODNode.  This should</span>
 <span class="s0">* correspond to the number of children of the node in order for the LODNode</span>
 <span class="s0">* to function correctly.</span>
 <span class="s0">*/ 1 4 this 3 461  </span>
<span class="s0">53 0 0 6 98 396 0 0 136 /**</span>
 <span class="s0">* Returns the &quot;in&quot; distance of the indicated switch range.  This should be</span>
 <span class="s0">* larger than the &quot;out&quot; distance of the same range.</span>
 <span class="s0">*/ 2 4 this 3 461  5 index 1 398  </span>
<span class="s0">54 0 0 6 100 396 0 0 137 /**</span>
 <span class="s0">* Returns the &quot;out&quot; distance of the indicated switch range.  This should be</span>
 <span class="s0">* smaller than the &quot;in&quot; distance of the same range.</span>
 <span class="s0">*/ 2 4 this 3 461  5 index 1 398  </span>
<span class="s0">55 0 0 6 102 398 0 0 220 /**</span>
 <span class="s0">* Returns the index number of the child with the lowest level of detail; that</span>
 <span class="s0">* is, the one that is designed to be seen from the farthest away.  This is</span>
 <span class="s0">* usually the first child, but it is not necessarily so.</span>
 <span class="s0">*/ 1 4 this 3 461  </span>
<span class="s0">56 0 0 6 103 398 0 0 228 /**</span>
 <span class="s0">* Returns the index number of the child with the highest level of detail;</span>
 <span class="s0">* that is, the one that is designed to be seen from the closest to the</span>
 <span class="s0">* camera.  This is usually the last child, but it is not necessarily so.</span>
 <span class="s0">*/ 1 4 this 3 461  </span>
<span class="s0">57 0 0 4 104 426 0 0 149 /**</span>
 <span class="s0">* Forces the LODNode to show the indicated level instead of the level that</span>
 <span class="s0">* would normally be shown based on the distance from the camera.</span>
 <span class="s0">*/ 2 4 this 3 460  5 index 1 398  </span>
<span class="s0">58 0 0 4 105 426 0 0 133 /**</span>
 <span class="s0">* Undoes the effect of a previous call to force_switch() and releases the</span>
 <span class="s0">* LODNode to once again display the normal level.</span>
 <span class="s0">*/ 1 4 this 3 460  </span>
<span class="s0">59 0 0 4 106 426 0 0 113 /**</span>
 <span class="s0">* Sets the multiplier for lod distances.  A higher value means you'll see</span>
 <span class="s0">* farther switchs than normal</span>
 <span class="s0">*/ 2 4 this 3 460  5 value 1 396  </span>
<span class="s0">60 0 0 6 107 396 0 0 51 /**</span>
 <span class="s0">* Returns the multiplier for lod distances</span>
 <span class="s0">*/ 1 4 this 3 461  </span>
<span class="s0">61 0 0 4 108 426 0 0 172 /**</span>
 <span class="s0">* Specifies the center of the LOD.  This is the point that is compared to the</span>
 <span class="s0">* camera (in camera space) to determine the particular LOD that should be</span>
 <span class="s0">* chosen.</span>
 <span class="s0">*/ 2 4 this 3 460  6 center 1 458  </span>
<span class="s0">62 0 0 6 109 458 0 0 170 /**</span>
 <span class="s0">* Returns the center of the LOD.  This is the point that is compared to the</span>
 <span class="s0">* camera (in camera space) to determine the particular LOD that should be</span>
 <span class="s0">* chosen.</span>
 <span class="s0">*/ 1 4 this 3 461  </span>
<span class="s0">63 0 0 4 119 426 0 0 550 /**</span>
 <span class="s0">* This is provided as a debugging aid.  show_switch() will put the LODNode</span>
 <span class="s0">* into a special mode where rather than computing and drawing the appropriate</span>
 <span class="s0">* level of the LOD, a ring is drawn around the LODNode center indicating the</span>
 <span class="s0">* switch distances from the camera for the indicated level, and the geometry</span>
 <span class="s0">* of the indicated level is drawn in wireframe.</span>
 <span class="s0">*</span>
 <span class="s0">* Multiple different levels can be visualized this way at once.  Call</span>
 <span class="s0">* hide_switch() or hide_all_switches() to undo this mode and restore the</span>
 <span class="s0">* LODNode to its normal behavior.</span>
 <span class="s0">*/ 2 4 this 3 460  5 index 1 398  </span>
<span class="s0">64 0 0 4 119 426 0 0 550 /**</span>
 <span class="s0">* This is provided as a debugging aid.  show_switch() will put the LODNode</span>
 <span class="s0">* into a special mode where rather than computing and drawing the appropriate</span>
 <span class="s0">* level of the LOD, a ring is drawn around the LODNode center indicating the</span>
 <span class="s0">* switch distances from the camera for the indicated level, and the geometry</span>
 <span class="s0">* of the indicated level is drawn in wireframe.</span>
 <span class="s0">*</span>
 <span class="s0">* Multiple different levels can be visualized this way at once.  Call</span>
 <span class="s0">* hide_switch() or hide_all_switches() to undo this mode and restore the</span>
 <span class="s0">* LODNode to its normal behavior.</span>
 <span class="s0">*/ 3 4 this 3 460  5 index 1 398  5 color 1 455  </span>
<span class="s0">65 0 0 4 120 426 0 0 53 /**</span>
 <span class="s0">* Disables a previous call to show_switch().</span>
 <span class="s0">*/ 2 4 this 3 460  5 index 1 398  </span>
<span class="s0">66 0 0 4 121 426 0 0 52 /**</span>
 <span class="s0">* Shows all levels in their default colors.</span>
 <span class="s0">*/ 1 4 this 3 460  </span>
<span class="s0">67 0 0 4 122 426 0 0 71 /**</span>
 <span class="s0">* Hides all levels, restoring the LODNode to normal operation.</span>
 <span class="s0">*/ 1 4 this 3 460  </span>
<span class="s0">68 0 0 6 123 382 0 0 159 /**</span>
 <span class="s0">* Returns true if any switch has been shown with show_switch(), indicating</span>
 <span class="s0">* the LODNode is in debug show mode; or false if it is in the normal mode.</span>
 <span class="s0">*/ 1 4 this 3 461  </span>
<span class="s0">69 0 0 6 124 382 0 0 274 /**</span>
 <span class="s0">* Returns true if the bounding volumes for the geometry of each fhild node</span>
 <span class="s0">* entirely fits within the switch_in radius for that child, or false</span>
 <span class="s0">* otherwise.  It is almost always a mistake for the geometry of an LOD level</span>
 <span class="s0">* to be larger than its switch_in radius.</span>
 <span class="s0">*/ 1 4 this 3 461  </span>
<span class="s0">70 0 0 7 125 428 0 0 0 0 </span>
<span class="s0">71 0 0 7 128 463 261 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">72 0 0 4 129 426 0 0 55 /**</span>
 <span class="s0">* set the time taken to complete an LOD switch</span>
 <span class="s0">*/ 2 4 this 3 463  1 t 1 396  </span>
<span class="s0">73 0 0 6 130 396 0 0 55 /**</span>
 <span class="s0">* get the time taken to complete an LOD switch</span>
 <span class="s0">*/ 1 4 this 3 464  </span>
<span class="s0">74 0 0 4 132 426 0 0 124 /**</span>
 <span class="s0">* Specifies the cull bin and draw order that is assigned to the fading part</span>
 <span class="s0">* of the geometry during a transition.</span>
 <span class="s0">*/ 3 4 this 3 463  4 name 1 432  10 draw_order 1 398  </span>
<span class="s0">75 0 0 6 133 432 0 0 107 /**</span>
 <span class="s0">* Returns the cull bin that is assigned to the fading part of the geometry</span>
 <span class="s0">* during a transition.</span>
 <span class="s0">*/ 1 4 this 3 464  </span>
<span class="s0">76 0 0 6 134 398 0 0 135 /**</span>
 <span class="s0">* Returns the draw order that is assigned (along with the bin name) to the</span>
 <span class="s0">* fading part of the geometry during a transition.</span>
 <span class="s0">*/ 1 4 this 3 464  </span>
<span class="s0">77 0 0 4 140 426 0 0 191 /**</span>
 <span class="s0">* Specifies the override value that is applied to the state changes necessary</span>
 <span class="s0">* to apply the fade effect.  This should be larger than any attrib overrides</span>
 <span class="s0">* on the fading geometry.</span>
 <span class="s0">*/ 2 4 this 3 463  8 override 1 398  </span>
<span class="s0">78 0 0 6 141 398 0 0 189 /**</span>
 <span class="s0">* Returns the override value that is applied to the state changes necessary</span>
 <span class="s0">* to apply the fade effect.  This should be larger than any attrib overrides</span>
 <span class="s0">* on the fading geometry.</span>
 <span class="s0">*/ 1 4 this 3 464  </span>
<span class="s0">79 0 0 7 143 428 0 0 0 0 </span>
<span class="s0">80 0 0 7 147 469 0 0 193 /**</span>
 <span class="s0">* Returns the CullTraverser in use at the time of the callback.  This object</span>
 <span class="s0">* contains data that does not change during the traversal, such as the</span>
 <span class="s0">* DisplayRegion and Camera in use.</span>
 <span class="s0">*/ 1 4 this 3 467  </span>
<span class="s0">81 0 0 6 148 470 0 0 222 /**</span>
 <span class="s0">* Returns the CullTraverserData in use at the time of the callback.  This</span>
 <span class="s0">* object contains data that changes at each node of the traversal, such as</span>
 <span class="s0">* the current node and the current net transform to that node.</span>
 <span class="s0">*/ 1 4 this 3 467  </span>
<span class="s0">82 0 0 7 149 428 0 0 0 0 </span>
<span class="s0">83 0 0 7 151 472 276 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">84 0 0 4 152 426 0 0 72 /**</span>
 <span class="s0">* Sets the color of specular highlights generated by the light.</span>
 <span class="s0">*/ 2 4 this 3 472  5 color 1 455  </span>
<span class="s0">85 0 0 4 153 426 0 0 115 /**</span>
 <span class="s0">* Clears a custom specular color setting, meaning that the specular color</span>
 <span class="s0">* will now come from the color.</span>
 <span class="s0">*/ 1 4 this 3 472  </span>
<span class="s0">86 0 0 4 156 426 0 0 190 /**</span>
 <span class="s0">* Sets the terms of the attenuation equation for the light.  These are, in</span>
 <span class="s0">* order, the constant, linear, and quadratic terms based on the distance from</span>
 <span class="s0">* the point to the vertex.</span>
 <span class="s0">*/ 2 4 this 3 472  11 attenuation 1 473  </span>
<span class="s0">87 0 0 6 162 396 0 0 122 /**</span>
 <span class="s0">* Returns the maximum distance at which the light has any effect, as previously</span>
 <span class="s0">* specified by set_max_distance.</span>
 <span class="s0">*/ 1 4 this 3 474  </span>
<span class="s0">88 0 0 4 163 426 0 0 161 /**</span>
 <span class="s0">* Sets the radius of the light's sphere of influence.  Beyond this distance, the</span>
 <span class="s0">* light may be attenuated to zero, if this is supported by the shader.</span>
 <span class="s0">*/ 2 4 this 3 472  12 max_distance 1 396  </span>
<span class="s0">89 0 0 6 165 458 0 0 160 /**</span>
 <span class="s0">* Returns the point in space at which the light is located.  This is local to</span>
 <span class="s0">* the coordinate space in which the light is assigned, and is usually 0.</span>
 <span class="s0">*/ 1 4 this 3 474  </span>
<span class="s0">90 0 0 4 166 426 0 0 77 /**</span>
 <span class="s0">* Sets the point in space at which the light is located.  Usually 0.</span>
 <span class="s0">*/ 2 4 this 3 472  5 point 1 458  </span>
<span class="s0">91 0 0 7 168 428 0 0 0 0 </span>
<span class="s0">92 0 0 7 171 476 281 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">93 0 0 6 172 396 0 0 122 /**</span>
 <span class="s0">* Returns the maximum distance at which the light has any effect, as previously</span>
 <span class="s0">* specified by set_max_distance.</span>
 <span class="s0">*/ 1 4 this 3 477  </span>
<span class="s0">94 0 0 4 173 426 0 0 161 /**</span>
 <span class="s0">* Sets the radius of the light's sphere of influence.  Beyond this distance, the</span>
 <span class="s0">* light may be attenuated to zero, if this is supported by the shader.</span>
 <span class="s0">*/ 2 4 this 3 476  12 max_distance 1 396  </span>
<span class="s0">95 0 0 7 175 428 0 0 0 0 </span>
<span class="s0">96 0 0 7 178 479 284 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">97 0 0 7 179 428 0 0 0 0 </span>
<span class="s0">98 0 0 7 187 480 294 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">99 0 0 6 188 398 0 0 278 /**</span>
 <span class="s0">* Returns the number of frames in the animation.  This is a property of the</span>
 <span class="s0">* animation and may not be directly adjusted by the user (although it may</span>
 <span class="s0">* change without warning with certain kinds of animations, since this is a</span>
 <span class="s0">* virtual method that may be overridden).</span>
 <span class="s0">*/ 1 4 this 3 481  </span>
<span class="s0">100 0 0 4 189 426 0 0 173 /**</span>
 <span class="s0">* Changes the advertised frame rate of the SequenceNode.  This can be used in</span>
 <span class="s0">* conjunction with get_play_rate() to change the effective frame rate of the</span>
 <span class="s0">* node.</span>
 <span class="s0">*/ 2 4 this 3 480  10 frame_rate 1 413  </span>
<span class="s0">101 0 0 7 193 428 0 0 0 0 </span>
<span class="s0">102 0 0 7 182 479 284 0 0 1 4 this 3 480  </span>
<span class="s0">103 0 0 6 185 483 0 0 0 1 4 this 3 480  </span>
<span class="s0">104 0 0 23 197 486 0 0 189 /**</span>
 <span class="s0">* Create a ShaderGenerator.  This has no state, except possibly to cache</span>
 <span class="s0">* certain results.  The parameter that must be passed is the GSG to which the</span>
 <span class="s0">* shader generator belongs.</span>
 <span class="s0">*/ 1 3 gsg 1 484  </span>
<span class="s0">105 0 0 15 197 486 0 0 0 1 6 param0 0 487  </span>
<span class="s0">106 0 0 7 198 497 0 0 794 /**</span>
 <span class="s0">* This is the routine that implements the next-gen fixed function pipeline by</span>
 <span class="s0">* synthesizing a shader.  It also takes care of setting up any buffers needed</span>
 <span class="s0">* to produce the requested effects.</span>
 <span class="s0">*</span>
 <span class="s0">* Currently supports:</span>
 <span class="s0">* - flat colors</span>
 <span class="s0">* - vertex colors</span>
 <span class="s0">* - lighting</span>
 <span class="s0">* - normal maps, even multiple</span>
 <span class="s0">* - gloss maps, but not multiple</span>
 <span class="s0">* - glow maps, but not multiple</span>
 <span class="s0">* - materials, but not updates to materials</span>
 <span class="s0">* - 2D textures</span>
 <span class="s0">* - all texture stage modes, including combine modes</span>
 <span class="s0">* - color scale attrib</span>
 <span class="s0">* - light ramps (for cartoon shading)</span>
 <span class="s0">* - shadow mapping</span>
 <span class="s0">* - most texgen modes</span>
 <span class="s0">* - texmatrix</span>
 <span class="s0">* - 1D/2D/3D textures, cube textures, 2D tex arrays</span>
 <span class="s0">* - linear/exp/exp2 fog</span>
 <span class="s0">* - animation</span>
 <span class="s0">*</span>
 <span class="s0">* Potential optimizations</span>
 <span class="s0">* - omit attenuation calculations if attenuation off</span>
 <span class="s0">*</span>
 <span class="s0">*/ 3 4 this 3 486  2 rs 1 491  4 anim 1 494  </span>
<span class="s0">107 0 0 4 199 426 0 0 354 /**</span>
 <span class="s0">* Rehashes all the states with generated shaders, removing the ones that are</span>
 <span class="s0">* no longer fresh.</span>
 <span class="s0">*</span>
 <span class="s0">* Call this if certain state has changed in such a way as to require a rerun</span>
 <span class="s0">* of the shader generator.  This should be rare because in most cases, the</span>
 <span class="s0">* shader generator will automatically regenerate shaders as necessary.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 486  </span>
<span class="s0">108 0 0 4 200 426 0 0 159 /**</span>
 <span class="s0">* Removes all previously generated shaders, requiring all shaders to be</span>
 <span class="s0">* regenerated.  Does not clear cache of compiled shaders.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/ 1 4 this 3 486  </span>
<span class="s0">109 0 0 7 201 428 0 0 0 0 </span>
<span class="s0">110 0 0 7 203 498 304 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">111 0 0 6 204 396 0 0 44 /**</span>
 <span class="s0">* Returns the radius of the sphere.</span>
 <span class="s0">*/ 1 4 this 3 499  </span>
<span class="s0">112 0 0 4 205 426 0 0 41 /**</span>
 <span class="s0">* Sets the radius of the sphere.</span>
 <span class="s0">*/ 2 4 this 3 498  6 radius 1 396  </span>
<span class="s0">113 0 0 7 207 428 0 0 0 0 </span>
<span class="s0">114 0 0 23 210 501 317 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">115 0 0 4 211 426 0 0 398 /**</span>
 <span class="s0">* Sets the exponent that controls the amount of light falloff from the center</span>
 <span class="s0">* of the spotlight.  The light is attenuated by the cosine of the angle</span>
 <span class="s0">* between the direction of the light and the direction of the point being</span>
 <span class="s0">* lighted, raised to the power of this exponent.  Thus, higher exponents</span>
 <span class="s0">* result in a more focused light source, regardless of the field-of-view of</span>
 <span class="s0">* the lens.</span>
 <span class="s0">*/ 2 4 this 3 501  8 exponent 1 396  </span>
<span class="s0">116 0 0 4 214 426 0 0 72 /**</span>
 <span class="s0">* Sets the color of specular highlights generated by the light.</span>
 <span class="s0">*/ 2 4 this 3 501  5 color 1 455  </span>
<span class="s0">117 0 0 4 215 426 0 0 115 /**</span>
 <span class="s0">* Clears a custom specular color setting, meaning that the specular color</span>
 <span class="s0">* will now come from the color.</span>
 <span class="s0">*/ 1 4 this 3 501  </span>
<span class="s0">118 0 0 4 218 426 0 0 190 /**</span>
 <span class="s0">* Sets the terms of the attenuation equation for the light.  These are, in</span>
 <span class="s0">* order, the constant, linear, and quadratic terms based on the distance from</span>
 <span class="s0">* the point to the vertex.</span>
 <span class="s0">*/ 2 4 this 3 501  11 attenuation 1 473  </span>
<span class="s0">119 0 0 6 221 396 0 0 122 /**</span>
 <span class="s0">* Returns the maximum distance at which the light has any effect, as previously</span>
 <span class="s0">* specified by set_max_distance.</span>
 <span class="s0">*/ 1 4 this 3 502  </span>
<span class="s0">120 0 0 4 222 426 0 0 161 /**</span>
 <span class="s0">* Sets the radius of the light's sphere of influence.  Beyond this distance, the</span>
 <span class="s0">* light may be attenuated to zero, if this is supported by the shader.</span>
 <span class="s0">*/ 2 4 this 3 501  12 max_distance 1 396  </span>
<span class="s0">121 0 0 7 224 506 0 0 619 /**</span>
 <span class="s0">* Returns a newly-generated Texture that renders a circular spot image as</span>
 <span class="s0">* might be cast from the spotlight.  This may be projected onto target</span>
 <span class="s0">* geometry (for instance, via NodePath::project_texture()) instead of</span>
 <span class="s0">* actually enabling the light itself, as a cheesy way to make a high-</span>
 <span class="s0">* resolution spot appear on the geometry.</span>
 <span class="s0">*</span>
 <span class="s0">* pixel_width specifies the height and width of the new texture in pixels,</span>
 <span class="s0">* full_radius is a value in the range 0..1 that indicates the relative size</span>
 <span class="s0">* of the fully bright center spot, and fg and bg are the colors of the</span>
 <span class="s0">* interior and exterior of the spot, respectively.</span>
 <span class="s0">*/ 4 11 pixel_width 1 398  11 full_radius 1 396  2 fg 1 505  2 bg 1 505  </span>
<span class="s0">122 0 0 7 225 428 0 0 0 0 </span>
<span class="s0">123 0 0 7 228 507 322 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">124 0 0 4 229 426 0 0 90 /**</span>
 <span class="s0">* Specifies the particular child of this node, by index, that will be</span>
 <span class="s0">* visible.</span>
 <span class="s0">*/ 2 4 this 3 507  5 index 1 398  </span>
<span class="s0">125 0 0 6 230 398 0 0 65 /**</span>
 <span class="s0">* Returns the index of the child that should be visible.</span>
 <span class="s0">*/ 1 4 this 3 508  </span>
<span class="s0">126 0 0 7 232 428 0 0 0 0 </span>
<span class="s0">127 0 0 7 235 510 333 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 name 1 432  </span>
<span class="s0">128 0 0 7 235 510 333 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 5 4 name 1 432  7 u_speed 1 396  7 v_speed 1 396  7 w_speed 1 396  7 r_speed 1 396  </span>
<span class="s0">129 0 0 4 236 426 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 510  7 u_speed 1 396  </span>
<span class="s0">130 0 0 4 237 426 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 510  7 v_speed 1 396  </span>
<span class="s0">131 0 0 4 238 426 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 510  7 w_speed 1 396  </span>
<span class="s0">132 0 0 4 239 426 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 2 4 this 3 510  7 r_speed 1 396  </span>
<span class="s0">133 0 0 6 240 396 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 511  </span>
<span class="s0">134 0 0 6 241 396 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 511  </span>
<span class="s0">135 0 0 6 242 396 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 511  </span>
<span class="s0">136 0 0 6 243 396 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 511  </span>
<span class="s0">137 0 0 7 248 428 0 0 0 0 </span>
<span class="s0">138 0 0 7 251 513 335 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 0 </span>
<span class="s0">139 0 0 15 251 513 335 0 0 1 6 param0 0 514  </span>
<span class="s0">140 0 0 4 254 426 0 0 61 /**</span>
 <span class="s0">* Specifies the mode in which LODNodes are analyzed.</span>
 <span class="s0">*/ 2 4 this 3 513  8 lod_mode 1 421  </span>
<span class="s0">141 0 0 6 255 421 0 0 59 /**</span>
 <span class="s0">* Returns the mode in which LODNodes are analyzed.</span>
 <span class="s0">*/ 2 4 this 3 514  8 lod_mode 1 421  </span>
<span class="s0">142 0 0 4 256 426 0 0 79 /**</span>
 <span class="s0">* Resets all of the data in the analyzer in preparation for a new run.</span>
 <span class="s0">*/ 1 4 this 3 513  </span>
<span class="s0">143 0 0 4 257 426 0 0 244 /**</span>
 <span class="s0">* Adds a new node to the set of data for analysis.  Normally, this would only</span>
 <span class="s0">* be called once, and passed the top of the scene graph, but it's possible to</span>
 <span class="s0">* repeatedly pass in subgraphs to get an analysis of all the graphs together.</span>
 <span class="s0">*/ 2 4 this 3 513  4 node 1 431  </span>
<span class="s0">144 0 0 4 258 426 0 0 44 /**</span>
 <span class="s0">* Describes all the data collected.</span>
 <span class="s0">*/ 3 4 this 3 514  3 out 1 424  12 indent_level 5 398  </span>
<span class="s0">145 0 0 6 259 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">146 0 0 6 260 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">147 0 0 6 261 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">148 0 0 6 262 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">149 0 0 6 263 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">150 0 0 6 264 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">151 0 0 6 265 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">152 0 0 6 266 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">153 0 0 6 267 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">154 0 0 6 268 441 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">155 0 0 6 269 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">156 0 0 6 270 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">157 0 0 6 271 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">158 0 0 6 272 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">159 0 0 6 273 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">160 0 0 6 274 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">161 0 0 6 275 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">162 0 0 6 276 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">163 0 0 6 277 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">164 0 0 6 278 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">165 0 0 6 279 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">166 0 0 6 280 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">167 0 0 6 281 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">168 0 0 6 282 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">169 0 0 6 283 441 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">170 0 0 6 284 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">171 0 0 6 285 398 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">172 0 0 6 286 396 0 0 10 /**</span>
 <span class="s0">*</span>
 <span class="s0">*/ 1 4 this 3 514  </span>
<span class="s0">147</span>
<span class="s0">369 9 LightNode 0 141313 9 LightNode 9 LightNode 0 0 0 0 180 0 3 177 178 179 0 0 2 3 370 173 174 3 371 175 176 0 0 161</span>
<span class="s0">/**</span>
 <span class="s0">* A derivative of Light and of PandaNode.  All kinds of Light except</span>
 <span class="s0">* Spotlight (which must inherit from LensNode instead) inherit from this</span>
 <span class="s0">* class.</span>
 <span class="s0">*/</span>

<span class="s0">370 5 Light 0 2048 5 Light 5 Light 0 0 0 0 0 0 0 0 0 0 0 0 231</span>
<span class="s0">/**</span>
 <span class="s0">* The abstract interface to all kinds of lights.  The actual light objects</span>
 <span class="s0">* also inherit from PandaNode, and can therefore be added to the scene graph</span>
 <span class="s0">* at some arbitrary point to define the coordinate system of effect.</span>
 <span class="s0">*/</span>

<span class="s0">371 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175</span>
<span class="s0">/**</span>
 <span class="s0">* A basic node of the scene graph or data graph.  This is the base class of</span>
 <span class="s0">* all specialized nodes, and also serves as a generic node with no special</span>
 <span class="s0">* properties.</span>
 <span class="s0">*/</span>

<span class="s0">372 12 AmbientLight 0 141313 12 AmbientLight 12 AmbientLight 0 0 0 1 181 183 0 1 182 0 0 1 0 369 0 0 0 0 188</span>
<span class="s0">/**</span>
 <span class="s0">* A light source that seems to illuminate all points in space at once.  This</span>
 <span class="s0">* kind of light need not actually be part of the scene graph, since it has no</span>
 <span class="s0">* meaningful position.</span>
 <span class="s0">*/</span>

<span class="s0">373 12 CallbackNode 0 141313 12 CallbackNode 12 CallbackNode 0 0 0 1 184 192 2 516 517 7 185 186 187 188 189 190 191 0 0 1 0 371 0 0 0 0 120</span>
<span class="s0">/**</span>
 <span class="s0">* A special node that can issue arbitrary callbacks to user code, either</span>
 <span class="s0">* during the cull or draw traversals.</span>
 <span class="s0">*/</span>

<span class="s0">374 16 CallbackObject * 0 8576 16 CallbackObject * 16 CallbackObject * 0 0 375 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">375 14 CallbackObject 0 2048 14 CallbackObject 14 CallbackObject 0 0 0 0 0 0 0 0 0 0 0 0 276</span>
<span class="s0">/**</span>
 <span class="s0">* This is a generic object that can be assigned to a callback at various</span>
 <span class="s0">* points in the rendering process.  This is actually a base class for a</span>
 <span class="s0">* handful of specialized callback object types.  You can also subclass it</span>
 <span class="s0">* yourself to make your own callback handler.</span>
 <span class="s0">*/</span>

<span class="s0">376 11 ComputeNode 0 141313 11 ComputeNode 11 ComputeNode 0 0 0 1 193 202 1 518 8 194 195 196 197 198 199 200 201 1 550 0 1 0 371 0 0 0 0 121</span>
<span class="s0">/**</span>
 <span class="s0">* A special node, the sole purpose of which is to invoke a dispatch operation</span>
 <span class="s0">* on the assigned compute shader.</span>
 <span class="s0">*/</span>

<span class="s0">377 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 378 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">378 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">379 11 LODNodeType 0 532481 11 LODNodeType 11 LODNodeType 0 0 0 0 0 0 0 0 0 0 2 7 LNT_pop 7 LNT_pop 0</span>
<span class="s0">0 8 LNT_fade 8 LNT_fade 0</span>
<span class="s0">1 0 0</span>

<span class="s0">380 13 LightLensNode 0 26625 13 LightLensNode 13 LightLensNode 0 0 0 0 207 2 519 520 10 208 209 210 211 212 213 214 215 216 217 0 0 2 3 370 203 204 3 381 205 206 0 0 215</span>
<span class="s0">/**</span>
 <span class="s0">* A derivative of Light and of Camera.  The name might be misleading: it does</span>
 <span class="s0">* not directly derive from LensNode, but through the Camera class.  The</span>
 <span class="s0">* Camera serves no purpose unless shadows are enabled.</span>
 <span class="s0">*/</span>

<span class="s0">381 6 Camera 0 2048 6 Camera 6 Camera 0 0 0 0 0 0 0 0 0 0 0 0 121</span>
<span class="s0">/**</span>
 <span class="s0">* A node that can be positioned around in the scene graph to represent a</span>
 <span class="s0">* point of view for rendering a scene.</span>
 <span class="s0">*/</span>

<span class="s0">382 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">383 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 75</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all two-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">384 16 DirectionalLight 0 141313 16 DirectionalLight 16 DirectionalLight 0 0 0 1 218 227 3 521 522 523 7 219 220 222 223 224 225 226 0 0 1 0 380 0 0 0 0 96</span>
<span class="s0">/**</span>
 <span class="s0">* A light shining from infinitely far away in a particular direction, like</span>
 <span class="s0">* sunlight.</span>
 <span class="s0">*/</span>

<span class="s0">385 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 386 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">386 6 LColor 0 2105344 6 LColor 6 LColor 0 0 387 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">387 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 388 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">388 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">389 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 390 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">390 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 391 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">391 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component point in space (as opposed to a three-component</span>
 <span class="s0">* vector, which represents a direction and a distance).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">392 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 393 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">393 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 394 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">394 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338</span>
<span class="s0">/**</span>
 <span class="s0">* This is a three-component vector distance (as opposed to a three-component</span>
 <span class="s0">* point, which represents a particular point in space).  Some of the methods</span>
 <span class="s0">* are slightly different between LPoint3 and LVector3; in particular,</span>
 <span class="s0">* subtraction of two points yields a vector, while addition of a vector and a</span>
 <span class="s0">* point yields a point.</span>
 <span class="s0">*/</span>

<span class="s0">395 7 LODNode 0 141313 7 LODNode 7 LODNode 0 0 0 1 228 251 6 524 525 526 527 528 529 22 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 2 551 552 0 1 0 371 0 0 0 0 190</span>
<span class="s0">/**</span>
 <span class="s0">* A Level-of-Detail node.  This selects only one of its children for</span>
 <span class="s0">* rendering, according to the distance from the camera and the table</span>
 <span class="s0">* indicated in the associated LOD object.</span>
 <span class="s0">*/</span>

<span class="s0">396 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 397 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">397 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">398 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">399 11 FadeLODNode 0 141313 11 FadeLODNode 11 FadeLODNode 0 0 0 1 252 261 4 530 531 532 533 8 253 254 255 256 257 258 259 260 0 0 1 0 395 0 0 0 0 61</span>
<span class="s0">/**</span>
 <span class="s0">* A Level-of-Detail node with alpha based switching.</span>
 <span class="s0">*/</span>

<span class="s0">400 12 string const 0 8832 17 std::string const 17 std::string const 0 0 401 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">401 6 string 0 2105344 11 std::string 11 std::string 0 0 402 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">402 20 basic_string&lt; char &gt; 0 2048 25 std::basic_string&lt; char &gt; 25 std::basic_string&lt; char &gt; 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">403 20 NodeCullCallbackData 0 10241 20 NodeCullCallbackData 20 NodeCullCallbackData 0 0 0 0 0 0 3 262 263 264 0 0 1 0 404 0 0 0 0 114</span>
<span class="s0">/**</span>
 <span class="s0">* This kind of CallbackData is passed to the CallbackObject added to</span>
 <span class="s0">* CallbackNode:set_cull_callback().</span>
 <span class="s0">*/</span>

<span class="s0">404 12 CallbackData 0 2048 12 CallbackData 12 CallbackData 0 0 0 0 0 0 0 0 0 0 0 0 348</span>
<span class="s0">/**</span>
 <span class="s0">* This is a generic data block that is passed along to a CallbackObject when</span>
 <span class="s0">* a callback is made.  It contains data specific to the particular callback</span>
 <span class="s0">* type in question.</span>
 <span class="s0">*</span>
 <span class="s0">* This is actually an abstract base class and contains no data.</span>
 <span class="s0">* Specializations of this class will contain the actual data relevant to each</span>
 <span class="s0">* callback type.</span>
 <span class="s0">*/</span>

<span class="s0">405 10 PointLight 0 141313 10 PointLight 10 PointLight 0 0 0 1 265 276 4 534 535 536 537 8 266 267 269 271 272 273 274 275 0 0 1 0 380 0 0 0 0 94</span>
<span class="s0">/**</span>
 <span class="s0">* A light originating from a single point in space, and shining in all</span>
 <span class="s0">* directions.</span>
 <span class="s0">*/</span>

<span class="s0">406 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 407 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">407 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 408 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">408 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77</span>
<span class="s0">/**</span>
 <span class="s0">* This is the base class for all three-component vectors and points.</span>
 <span class="s0">*/</span>

<span class="s0">409 14 RectangleLight 0 141313 14 RectangleLight 14 RectangleLight 0 0 0 1 277 281 1 538 3 278 279 280 0 0 1 0 380 0 0 0 0 150</span>
<span class="s0">/**</span>
 <span class="s0">* This is a type of area light that is an axis aligned rectangle, pointing</span>
 <span class="s0">* along the Y axis in the positive direction.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">410 18 SelectiveChildNode 0 141313 18 SelectiveChildNode 18 SelectiveChildNode 0 0 0 1 282 284 0 1 283 0 0 1 0 371 0 0 0 0 112</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for nodes like LODNode and SequenceNode that select only one</span>
 <span class="s0">* visible child at a time.</span>
 <span class="s0">*/</span>

<span class="s0">411 12 SequenceNode 0 141313 12 SequenceNode 12 SequenceNode 0 0 0 1 289 294 1 539 3 290 291 293 0 0 2 3 410 285 286 3 412 287 288 0 0 118</span>
<span class="s0">/**</span>
 <span class="s0">* A node that automatically cycles through rendering each one of its children</span>
 <span class="s0">* according to its frame rate.</span>
 <span class="s0">*/</span>

<span class="s0">412 13 AnimInterface 0 2048 13 AnimInterface 13 AnimInterface 0 0 0 0 0 0 0 0 0 0 0 0 226</span>
<span class="s0">/**</span>
 <span class="s0">* This is the fundamental interface for things that have a play/loop/stop</span>
 <span class="s0">* type interface for frame-based animation, such as animated characters.</span>
 <span class="s0">* This is the base class for AnimControl and other, similar classes.</span>
 <span class="s0">*/</span>

<span class="s0">413 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">414 15 ShaderGenerator 0 75777 15 ShaderGenerator 15 ShaderGenerator 0 0 0 1 295 0 0 4 296 297 298 299 0 0 1 0 415 0 0 0 0 1069</span>
<span class="s0">/**</span>
 <span class="s0">* The ShaderGenerator is a device that effectively replaces the classic fixed</span>
 <span class="s0">* function pipeline with a 'next-gen' fixed function pipeline.  The next-gen</span>
 <span class="s0">* fixed function pipeline supports features like normal mapping, gloss</span>
 <span class="s0">* mapping, cartoon lighting, and so forth.  It works by automatically</span>
 <span class="s0">* generating a shader from a given RenderState.</span>
 <span class="s0">*</span>
 <span class="s0">* Currently, there is one ShaderGenerator object per GraphicsStateGuardian.</span>
 <span class="s0">* It is our intent that in time, people will write classes that derive from</span>
 <span class="s0">* ShaderGenerator but which yield slightly different results.</span>
 <span class="s0">*</span>
 <span class="s0">* The ShaderGenerator owes its existence to the 'Bamboo Team' at Carnegie</span>
 <span class="s0">* Mellon's Entertainment Technology Center.  This is a group of students who,</span>
 <span class="s0">* as a semester project, decided that next-gen graphics should be accessible</span>
 <span class="s0">* to everyone, even if they don't know shader programming.  The group</span>
 <span class="s0">* consisted of:</span>
 <span class="s0">*</span>
 <span class="s0">* Aaron Lo, Programmer Heegun Lee, Programmer Erin Fernandez, Artist/Tester</span>
 <span class="s0">* Joe Grubb, Artist/Tester Ivan Ortega, Technical Artist/Tester</span>
 <span class="s0">*</span>
 <span class="s0">* Thanks to them!</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">415 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410</span>
<span class="s0">/**</span>
 <span class="s0">* A base class for things which need to inherit from both TypedObject and</span>
 <span class="s0">* from ReferenceCount.  It's convenient to define this intermediate base</span>
 <span class="s0">* class instead of multiply inheriting from the two classes each time they</span>
 <span class="s0">* are needed, so that we can sensibly pass around pointers to things which</span>
 <span class="s0">* are both TypedObjects and ReferenceCounters.</span>
 <span class="s0">*</span>
 <span class="s0">* See also TypedObject for detailed instructions.</span>
 <span class="s0">*/</span>

<span class="s0">416 11 SphereLight 0 141313 11 SphereLight 11 SphereLight 0 0 0 1 300 304 1 540 3 301 302 303 0 0 1 0 405 0 0 0 0 174</span>
<span class="s0">/**</span>
 <span class="s0">* A sphere light is like a point light, except that it represents a sphere</span>
 <span class="s0">* with a radius, rather than being an infinitely thin point in space.</span>
 <span class="s0">*</span>
 <span class="s0">* @since 1.10.0</span>
 <span class="s0">*/</span>

<span class="s0">417 9 Spotlight 0 141313 9 Spotlight 9 Spotlight 0 0 0 1 305 317 4 541 542 543 544 8 306 308 309 311 313 314 315 316 0 0 1 0 380 0 0 0 0 390</span>
<span class="s0">/**</span>
 <span class="s0">* A light originating from a single point in space, and shining in a</span>
 <span class="s0">* particular direction, with a cone-shaped falloff.</span>
 <span class="s0">*</span>
 <span class="s0">* The Spotlight frustum is defined using a Lens, so it can have any of the</span>
 <span class="s0">* properties that a camera lens can have.</span>
 <span class="s0">*</span>
 <span class="s0">* Note that the class is named Spotlight instead of SpotLight, because</span>
 <span class="s0">* &quot;spotlight&quot; is a single English word, instead of two words.</span>
 <span class="s0">*/</span>

<span class="s0">418 10 SwitchNode 0 141313 10 SwitchNode 10 SwitchNode 0 0 0 1 318 322 1 545 3 319 320 321 0 0 1 0 410 0 0 0 0 95</span>
<span class="s0">/**</span>
 <span class="s0">* A node that renders only one of its children, according to the user's</span>
 <span class="s0">* indication.</span>
 <span class="s0">*/</span>

<span class="s0">419 12 UvScrollNode 0 141313 12 UvScrollNode 12 UvScrollNode 0 0 0 1 323 333 4 546 547 548 549 9 324 325 326 327 328 329 330 331 332 0 0 1 0 371 0 0 0 0 83</span>
<span class="s0">/**</span>
 <span class="s0">* This node is placed at key points within the scene graph to animate uvs.</span>
 <span class="s0">*/</span>

<span class="s0">420 18 SceneGraphAnalyzer 0 26625 18 SceneGraphAnalyzer 18 SceneGraphAnalyzer 0 0 0 1 334 335 0 33 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 0 0 0 0 1 421 103</span>
<span class="s0">/**</span>
 <span class="s0">* A handy class that can scrub over a scene graph and collect interesting</span>
 <span class="s0">* statistics on it.</span>
 <span class="s0">*/</span>

<span class="s0">421 7 LodMode 0 794624 27 SceneGraphAnalyzer::LodMode 27 SceneGraphAnalyzer::LodMode 420 0 0 0 0 0 0 0 0 0 4 9 LM_lowest 29 SceneGraphAnalyzer::LM_lowest 0</span>
<span class="s0">0 10 LM_highest 30 SceneGraphAnalyzer::LM_highest 0</span>
<span class="s0">1 6 LM_all 26 SceneGraphAnalyzer::LM_all 0</span>
<span class="s0">2 7 LM_none 27 SceneGraphAnalyzer::LM_none 0</span>
<span class="s0">3 0 0</span>

<span class="s0">422 17 LightNode const * 0 8576 17 LightNode const * 17 LightNode const * 0 0 423 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">423 15 LightNode const 0 8832 15 LightNode const 15 LightNode const 0 0 369 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">424 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 425 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">425 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">426 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">427 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732</span>
<span class="s0">/**</span>
 <span class="s0">* TypeHandle is the identifier used to differentiate C++ class types.  Any</span>
 <span class="s0">* C++ classes that inherit from some base class, and must be differentiated</span>
 <span class="s0">* at run time, should store a static TypeHandle object that can be queried</span>
 <span class="s0">* through a static member function named get_class_type().  Most of the time,</span>
 <span class="s0">* it is also desirable to inherit from TypedObject, which provides some</span>
 <span class="s0">* virtual functions to return the TypeHandle for a particular instance.</span>
 <span class="s0">*</span>
 <span class="s0">* At its essence, a TypeHandle is simply a unique identifier that is assigned</span>
 <span class="s0">* by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so</span>
 <span class="s0">* that ancestry of a particular type may be queried, and the type name may be</span>
 <span class="s0">* retrieved for run-time display.</span>
 <span class="s0">*/</span>

<span class="s0">428 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 427 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">429 11 LightNode * 0 8576 11 LightNode * 11 LightNode * 0 0 369 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">430 7 Light * 0 8576 7 Light * 7 Light * 0 0 370 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">431 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 371 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">432 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">433 14 AmbientLight * 0 8576 14 AmbientLight * 14 AmbientLight * 0 0 372 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">434 14 CallbackNode * 0 8576 14 CallbackNode * 14 CallbackNode * 0 0 373 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">435 20 CallbackNode const * 0 8576 20 CallbackNode const * 20 CallbackNode const * 0 0 436 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">436 18 CallbackNode const 0 8832 18 CallbackNode const 18 CallbackNode const 0 0 373 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">437 13 ComputeNode * 0 8576 13 ComputeNode * 13 ComputeNode * 0 0 376 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">438 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 377 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">439 19 ComputeNode const * 0 8576 19 ComputeNode const * 19 ComputeNode const * 0 0 440 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">440 17 ComputeNode const 0 8832 17 ComputeNode const 17 ComputeNode const 0 0 376 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">441 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 442 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">442 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">443 21 LightLensNode const * 0 8576 21 LightLensNode const * 21 LightLensNode const * 0 0 444 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">444 19 LightLensNode const 0 8832 19 LightLensNode const 19 LightLensNode const 0 0 380 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">445 15 LightLensNode * 0 8576 15 LightLensNode * 15 LightLensNode * 0 0 380 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">446 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 383 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">447 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 448 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">448 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 383 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">449 18 GraphicsOutputBase 0 2048 18 GraphicsOutputBase 18 GraphicsOutputBase 0 0 0 0 0 0 0 0 0 0 0 0 80</span>
<span class="s0">/**</span>
 <span class="s0">* An abstract base class for GraphicsOutput, for all the usual reasons.</span>
 <span class="s0">*/</span>

<span class="s0">450 27 GraphicsStateGuardianBase * 0 8576 27 GraphicsStateGuardianBase * 27 GraphicsStateGuardianBase * 0 0 451 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">451 25 GraphicsStateGuardianBase 0 2048 25 GraphicsStateGuardianBase 25 GraphicsStateGuardianBase 0 0 0 0 0 0 0 0 0 0 0 0 607</span>
<span class="s0">/**</span>
 <span class="s0">* This is a base class for the GraphicsStateGuardian class, which is itself a</span>
 <span class="s0">* base class for the various GSG's for different platforms.  This class</span>
 <span class="s0">* contains all the function prototypes to support the double-dispatch of GSG</span>
 <span class="s0">* to geoms, transitions, etc.  It lives in a separate class in its own</span>
 <span class="s0">* package so we can avoid circular build dependency problems.</span>
 <span class="s0">*</span>
 <span class="s0">* GraphicsStateGuardians are not actually writable to bam files, of course,</span>
 <span class="s0">* but they may be passed as event parameters, so they inherit from</span>
 <span class="s0">* TypedWritableReferenceCount instead of TypedReferenceCount for that</span>
 <span class="s0">* convenience.</span>
 <span class="s0">*/</span>

<span class="s0">452 20 GraphicsOutputBase * 0 8576 20 GraphicsOutputBase * 20 GraphicsOutputBase * 0 0 449 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">453 8 Camera * 0 8576 8 Camera * 8 Camera * 0 0 381 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">454 18 DirectionalLight * 0 8576 18 DirectionalLight * 18 DirectionalLight * 0 0 384 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">455 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 385 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">456 24 DirectionalLight const * 0 8576 24 DirectionalLight const * 24 DirectionalLight const * 0 0 457 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">457 22 DirectionalLight const 0 8832 22 DirectionalLight const 22 DirectionalLight const 0 0 384 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">458 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 389 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">459 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 392 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">460 9 LODNode * 0 8576 9 LODNode * 9 LODNode * 0 0 395 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">461 15 LODNode const * 0 8576 15 LODNode const * 15 LODNode const * 0 0 462 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">462 13 LODNode const 0 8832 13 LODNode const 13 LODNode const 0 0 395 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">463 13 FadeLODNode * 0 8576 13 FadeLODNode * 13 FadeLODNode * 0 0 399 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">464 19 FadeLODNode const * 0 8576 19 FadeLODNode const * 19 FadeLODNode const * 0 0 465 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">465 17 FadeLODNode const 0 8832 17 FadeLODNode const 17 FadeLODNode const 0 0 399 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">466 13 CullTraverser 0 2048 13 CullTraverser 13 CullTraverser 0 0 0 0 0 0 0 0 0 0 0 0 279</span>
<span class="s0">/**</span>
 <span class="s0">* This object performs a depth-first traversal of the scene graph, with</span>
 <span class="s0">* optional view-frustum culling, collecting CullState and searching for</span>
 <span class="s0">* GeomNodes.  Each renderable Geom encountered is passed along with its</span>
 <span class="s0">* associated RenderState to the CullHandler object.</span>
 <span class="s0">*/</span>

<span class="s0">467 28 NodeCullCallbackData const * 0 8576 28 NodeCullCallbackData const * 28 NodeCullCallbackData const * 0 0 468 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">468 26 NodeCullCallbackData const 0 8832 26 NodeCullCallbackData const 26 NodeCullCallbackData const 0 0 403 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">469 15 CullTraverser * 0 8576 15 CullTraverser * 15 CullTraverser * 0 0 466 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">470 19 CullTraverserData * 0 8576 19 CullTraverserData * 19 CullTraverserData * 0 0 471 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">471 17 CullTraverserData 0 2048 17 CullTraverserData 17 CullTraverserData 0 0 0 0 0 0 0 0 0 0 0 0 464</span>
<span class="s0">/**</span>
 <span class="s0">* This collects together the pieces of data that are accumulated for each</span>
 <span class="s0">* node while walking the scene graph during the cull traversal.</span>
 <span class="s0">*</span>
 <span class="s0">* Having this as a separate object simplifies the parameter list to</span>
 <span class="s0">* CullTraverser::r_traverse(), as well as to other functions like</span>
 <span class="s0">* PandaNode::cull_callback().  It also makes it easier to add cull</span>
 <span class="s0">* parameters, and provides a place to abstract out some of the cull behavior</span>
 <span class="s0">* (like view-frustum culling).</span>
 <span class="s0">*/</span>

<span class="s0">472 12 PointLight * 0 8576 12 PointLight * 12 PointLight * 0 0 405 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">473 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 406 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">474 18 PointLight const * 0 8576 18 PointLight const * 18 PointLight const * 0 0 475 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">475 16 PointLight const 0 8832 16 PointLight const 16 PointLight const 0 0 405 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">476 16 RectangleLight * 0 8576 16 RectangleLight * 16 RectangleLight * 0 0 409 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">477 22 RectangleLight const * 0 8576 22 RectangleLight const * 22 RectangleLight const * 0 0 478 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">478 20 RectangleLight const 0 8832 20 RectangleLight const 20 RectangleLight const 0 0 409 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">479 20 SelectiveChildNode * 0 8576 20 SelectiveChildNode * 20 SelectiveChildNode * 0 0 410 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">480 14 SequenceNode * 0 8576 14 SequenceNode * 14 SequenceNode * 0 0 411 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">481 20 SequenceNode const * 0 8576 20 SequenceNode const * 20 SequenceNode const * 0 0 482 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">482 18 SequenceNode const 0 8832 18 SequenceNode const 18 SequenceNode const 0 0 411 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">483 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 412 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">484 33 GraphicsStateGuardianBase const * 0 8576 33 GraphicsStateGuardianBase const * 33 GraphicsStateGuardianBase const * 0 0 485 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">485 31 GraphicsStateGuardianBase const 0 8832 31 GraphicsStateGuardianBase const 31 GraphicsStateGuardianBase const 0 0 451 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">486 17 ShaderGenerator * 0 8576 17 ShaderGenerator * 17 ShaderGenerator * 0 0 414 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">487 23 ShaderGenerator const * 0 8576 23 ShaderGenerator const * 23 ShaderGenerator const * 0 0 488 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">488 21 ShaderGenerator const 0 8832 21 ShaderGenerator const 21 ShaderGenerator const 0 0 414 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">489 18 ShaderAttrib const 0 8832 18 ShaderAttrib const 18 ShaderAttrib const 0 0 490 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">490 12 ShaderAttrib 0 2048 12 ShaderAttrib 12 ShaderAttrib 0 0 0 0 0 0 0 0 0 0 0 0 10</span>
<span class="s0">/**</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>

<span class="s0">491 19 RenderState const * 0 8576 19 RenderState const * 19 RenderState const * 0 0 492 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">492 17 RenderState const 0 8832 17 RenderState const 17 RenderState const 0 0 493 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">493 11 RenderState 0 2048 11 RenderState 11 RenderState 0 0 0 0 0 0 0 0 0 0 0 0 340</span>
<span class="s0">/**</span>
 <span class="s0">* This represents a unique collection of RenderAttrib objects that correspond</span>
 <span class="s0">* to a particular renderable state.</span>
 <span class="s0">*</span>
 <span class="s0">* You should not attempt to create or modify a RenderState object directly.</span>
 <span class="s0">* Instead, call one of the make() functions to create one for you.  And</span>
 <span class="s0">* instead of modifying a RenderState object, create a new one.</span>
 <span class="s0">*/</span>

<span class="s0">494 31 GeomVertexAnimationSpec const * 0 8576 31 GeomVertexAnimationSpec const * 31 GeomVertexAnimationSpec const * 0 0 495 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">495 29 GeomVertexAnimationSpec const 0 8832 29 GeomVertexAnimationSpec const 29 GeomVertexAnimationSpec const 0 0 496 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">496 23 GeomVertexAnimationSpec 0 2048 23 GeomVertexAnimationSpec 23 GeomVertexAnimationSpec 0 0 0 0 0 0 0 0 0 0 0 0 550</span>
<span class="s0">/**</span>
 <span class="s0">* This object describes how the vertex animation, if any, represented in a</span>
 <span class="s0">* GeomVertexData is encoded.</span>
 <span class="s0">*</span>
 <span class="s0">* Vertex animation includes soft-skinned skeleton animation and morphs (blend</span>
 <span class="s0">* shapes), and might be performed on the CPU by Panda, or passed down to the</span>
 <span class="s0">* graphics backed to be performed on the hardware (depending on the</span>
 <span class="s0">* hardware's advertised capabilities).</span>
 <span class="s0">*</span>
 <span class="s0">* Changing this setting doesn't by itself change the way the animation is</span>
 <span class="s0">* actually performed; this just specifies how the vertices are set up to be</span>
 <span class="s0">* animated.</span>
 <span class="s0">*/</span>

<span class="s0">497 20 ShaderAttrib const * 0 8576 20 ShaderAttrib const * 20 ShaderAttrib const * 0 0 489 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">498 13 SphereLight * 0 8576 13 SphereLight * 13 SphereLight * 0 0 416 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">499 19 SphereLight const * 0 8576 19 SphereLight const * 19 SphereLight const * 0 0 500 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">500 17 SphereLight const 0 8832 17 SphereLight const 17 SphereLight const 0 0 416 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">501 11 Spotlight * 0 8576 11 Spotlight * 11 Spotlight * 0 0 417 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">502 17 Spotlight const * 0 8576 17 Spotlight const * 17 Spotlight const * 0 0 503 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">503 15 Spotlight const 0 8832 15 Spotlight const 15 Spotlight const 0 0 417 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">504 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688</span>
<span class="s0">/**</span>
 <span class="s0">* Represents a texture object, which is typically a single 2-d image but may</span>
 <span class="s0">* also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube</span>
 <span class="s0">* map texture.</span>
 <span class="s0">*</span>
 <span class="s0">* A texture's image data might be stored in system RAM (see get_ram_image())</span>
 <span class="s0">* or its image may be represented in texture memory on one or more</span>
 <span class="s0">* GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern</span>
 <span class="s0">* is that a texture is loaded from an image file on disk, which copies its</span>
 <span class="s0">* image data into system RAM; then the first time the texture is rendered its</span>
 <span class="s0">* image data is copied to texture memory (actually, to the graphics API), and</span>
 <span class="s0">* the system RAM image is automatically freed.</span>
 <span class="s0">*/</span>

<span class="s0">505 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 386 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">506 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 504 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">507 12 SwitchNode * 0 8576 12 SwitchNode * 12 SwitchNode * 0 0 418 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">508 18 SwitchNode const * 0 8576 18 SwitchNode const * 18 SwitchNode const * 0 0 509 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">509 16 SwitchNode const 0 8832 16 SwitchNode const 16 SwitchNode const 0 0 418 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">510 14 UvScrollNode * 0 8576 14 UvScrollNode * 14 UvScrollNode * 0 0 419 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">511 20 UvScrollNode const * 0 8576 20 UvScrollNode const * 20 UvScrollNode const * 0 0 512 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">512 18 UvScrollNode const 0 8832 18 UvScrollNode const 18 UvScrollNode const 0 0 419 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">513 20 SceneGraphAnalyzer * 0 8576 20 SceneGraphAnalyzer * 20 SceneGraphAnalyzer * 0 0 420 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">514 26 SceneGraphAnalyzer const * 0 8576 26 SceneGraphAnalyzer const * 26 SceneGraphAnalyzer const * 0 0 515 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">515 24 SceneGraphAnalyzer const 0 8832 24 SceneGraphAnalyzer const 24 SceneGraphAnalyzer const 0 0 420 0 0 0 0 0 0 0 0 0 0</span>

<span class="s0">0</span>
<span class="s0">34</span>
<span class="s0">516 13 cull_callback 0 6 374 187 185 0 0 0 0 0 0 27 CallbackNode::cull_callback 0</span>

<span class="s0">517 13 draw_callback 0 6 374 190 188 0 0 0 0 0 0 27 CallbackNode::draw_callback 0</span>

<span class="s0">518 10 dispatches 0 358 377 196 197 0 0 199 195 198 0 23 ComputeNode::dispatches 0</span>

<span class="s0">519 13 shadow_caster 0 2 382 209 0 0 0 0 0 0 0 28 LightLensNode::shadow_caster 0</span>

<span class="s0">520 18 shadow_buffer_size 0 6 383 212 213 0 0 0 0 0 0 33 LightLensNode::shadow_buffer_size 0</span>

<span class="s0">521 14 specular_color 0 6 385 221 219 0 0 0 0 0 0 32 DirectionalLight::specular_color 0</span>

<span class="s0">522 5 point 0 6 389 222 223 0 0 0 0 0 0 23 DirectionalLight::point 0</span>

<span class="s0">523 9 direction 0 6 392 224 225 0 0 0 0 0 0 27 DirectionalLight::direction 0</span>

<span class="s0">524 3 ins 0 66 396 234 0 0 0 0 233 0 0 12 LODNode::ins 0</span>

<span class="s0">525 4 outs 0 66 396 235 0 0 0 0 233 0 0 13 LODNode::outs 0</span>

<span class="s0">526 13 lowest_switch 0 2 398 236 0 0 0 0 0 0 0 22 LODNode::lowest_switch 0</span>

<span class="s0">527 14 highest_switch 0 2 398 237 0 0 0 0 0 0 0 23 LODNode::highest_switch 0</span>

<span class="s0">528 9 lod_scale 0 6 396 241 240 0 0 0 0 0 0 18 LODNode::lod_scale 0</span>

<span class="s0">529 6 center 0 6 389 243 242 0 0 0 0 0 0 15 LODNode::center 0</span>

<span class="s0">530 9 fade_time 0 6 396 254 253 0 0 0 0 0 0 22 FadeLODNode::fade_time 0</span>

<span class="s0">531 13 fade_bin_name 0 2 400 256 0 0 0 0 0 0 0 26 FadeLODNode::fade_bin_name 0</span>

<span class="s0">532 19 fade_bin_draw_order 0 2 398 257 0 0 0 0 0 0 0 32 FadeLODNode::fade_bin_draw_order 0</span>

<span class="s0">533 19 fade_state_override 0 6 398 259 258 0 0 0 0 0 0 32 FadeLODNode::fade_state_override 0</span>

<span class="s0">534 14 specular_color 0 6 385 268 266 0 0 0 0 0 0 26 PointLight::specular_color 0</span>

<span class="s0">535 11 attenuation 0 6 406 270 269 0 0 0 0 0 0 23 PointLight::attenuation 0</span>

<span class="s0">536 12 max_distance 0 6 396 271 272 0 0 0 0 0 0 24 PointLight::max_distance 0</span>

<span class="s0">537 5 point 0 6 389 273 274 0 0 0 0 0 0 17 PointLight::point 0</span>

<span class="s0">538 12 max_distance 0 6 396 278 279 0 0 0 0 0 0 28 RectangleLight::max_distance 0</span>

<span class="s0">539 10 frame_rate 0 6 413 292 291 0 0 0 0 0 0 24 SequenceNode::frame_rate 0</span>

<span class="s0">540 6 radius 0 6 396 301 302 0 0 0 0 0 0 19 SphereLight::radius 0</span>

<span class="s0">541 8 exponent 0 6 396 307 306 0 0 0 0 0 0 19 Spotlight::exponent 0</span>

<span class="s0">542 14 specular_color 0 6 385 310 308 0 0 0 0 0 0 25 Spotlight::specular_color 0</span>

<span class="s0">543 11 attenuation 0 6 406 312 311 0 0 0 0 0 0 22 Spotlight::attenuation 0</span>

<span class="s0">544 12 max_distance 0 6 396 313 314 0 0 0 0 0 0 23 Spotlight::max_distance 0</span>

<span class="s0">545 13 visible_child 0 6 398 320 319 0 0 0 0 0 0 25 SwitchNode::visible_child 0</span>

<span class="s0">546 7 u_speed 0 6 396 328 324 0 0 0 0 0 0 21 UvScrollNode::u_speed 0</span>

<span class="s0">547 7 v_speed 0 6 396 329 325 0 0 0 0 0 0 21 UvScrollNode::v_speed 0</span>

<span class="s0">548 7 w_speed 0 6 396 330 326 0 0 0 0 0 0 21 UvScrollNode::w_speed 0</span>

<span class="s0">549 7 r_speed 0 6 396 331 327 0 0 0 0 0 0 21 UvScrollNode::r_speed 0</span>

<span class="s0">3</span>
<span class="s0">550 14 get_dispatches 0 195 196 27 ComputeNode::get_dispatches 0</span>

<span class="s0">551 7 get_ins 0 233 234 16 LODNode::get_ins 0</span>

<span class="s0">552 8 get_outs 0 233 235 17 LODNode::get_outs 0</span>

</pre>
</body>
</html>